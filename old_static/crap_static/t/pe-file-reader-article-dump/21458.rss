<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>PE-File Reader [article - dump]</title>
    <link>https://0x00sec.org/t/pe-file-reader-article-dump/21458</link>
    <description>## Pe File Reader

**[Opening .exe files to analyze the PE-header]**

Hello_Friend,
and welcome to the 20&#39;s, Cybermonkeys!

Let&#39;s start this decade by learning some stuff.
Last year, we already took an in-depth look at [Linux-binaries (aka ELF files)](https://metabytezero.blogspot.com/2019/10/elf-file-structure.html), now let&#39;s start messing around with it&#39;s infamous Windows-Counterpart (that also happens to be the xBox file format).

#### Introduction

The PE-file format is around for quite some time now, and while heavy optimizations took place, it hasn&#39;t really changed all that much since then. In fact, it is one of the most widely encountered file formats out in the wilds. Although there is technically a difference between PE32 files (32bit) and PE32+ files (64bit), we will ignore this fact for the sake of this blogpost.
Some file extensions deriving from this format are:

* .acm   [ a Windows audio-codec]
* .ax    [MPEG-4 DVD format]
* .cpl   [dynamic link libraries for control panels]
* .dll   [dynamic link libraries]
* .drv   [hardware drivers]
* .efi   [extensible firmware interface]
* .exe   [executable file]
* .mui   [multilingual user interface]
* .ocx   [activeX form extension]
* .scr   [screensaver file format]
* .sys   [system file]
* .tsp   [truespeech audio format]

There are other types as we will encounter, but this should give you an idea of how common this format(and it&#39;s augmentations) is.

#### Tools and resources

Before we even start thinking about messing around with PE-files, it would help a lot to have some documentation and software to make our lives easier. Luckily for us, [Microsoft has released a structured documentation about the PE-file format.](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#the-rsrc-section)

Next, it would be nice to have a disassembler to look into the actual file (or at least a hex-viewer). One might ask why we bother to write our own program at all when there are already hundreds and hundreds of good disassemblers out there. The answer is: we are not going to write a disassembler here. We are writing a program to inspect the header file (fast) with the option to augment it so it can modify the behaviour of the executable and bend it to our will (not in this tutorial tho). Personally, [I found REDasm to be a nice and fast little program.](https://redasm.io/)

[![|320x227](upload://1P4d1TN79kDD4jz9Lg4lXOQxNcE.png)](https://1.bp.blogspot.com/-fPYP067UuX8/XhSknKNojoI/AAAAAAAABME/LUUxbi_4Gw8EZiMahQPNFG5zYQCF5XxvQCNcBGAsYHQ/s1600/redasm.png)Although it can show you program flux and branches and whatnot, I only used it to view the file in hexadecimal format. Here is a picture of the PE-file header I inspected for testing purposes:

As you can see, I am not using much of the fancy functions that the disassembler has, although it is a good tool to start learning reverse-engineering, so kudos to the makers of this tool.
[dark theme kind of sucks, but you have to decide for yourself]

Also it&#39;s good to have some hello-world programs ready for testing purposes. Import and export stuff in these programs, respectively, and you will see differences in the binary structure of the files. Besides that we don&#39;t really need anything else, I used Visual Studio, but this is dependant on your personal preferences.

#### Differences and similarities between PE and ELF

[![|226x320](upload://bUlRnyA6Z9krIwOyFo3rDP5G5yf.png)](https://1.bp.blogspot.com/-mWlOnaZEEZ4/XhSyAQ8UT9I/AAAAAAAABMQ/iMLQuL1YK2sMl0m1djujzrxWjkUCLzr6QCNcBGAsYHQ/s1600/800px-Portable_Executable_32_bit_Structure_in_SVG_fixed.svg.png)For readers of my previous article, this could be quite interesting.
In fact, PE-files and ELF-files aren&#39;t that much different from each other. But Microsoft has, again, chosen their own weird methods of implementing stuff as we will see. I took a shot from Wikipedia describing the basic structure of the PE-file, you can see it in the picture.

Now, the probably biggest difference is the  **MS-DOS stub**  at the beginning of the file.
Yes, you read correctly: MS-DOS!
It&#39;s still a thing, even in 2020. Microsoft has chosen this due to downward compatibility reasons. While I can not understand this choice at all, MS probably thought it would be good to have it. What it does is telling that &quot;This program cannot be run in DOS mode&quot; - no shit Sherlock! It is technically possible to specify another stub [with the linker option  **/stub** ], but why bother anyways? If anybody fires up an old 16-bit machine and tries to play Call of Duty on it, they must be crazy anyways.
There is a historical importance to this stub, and yes, you could re-write your complete program to run in this 16bit stub, but if you do I will personally come to your home and spank your ass until you apologize.

Another interesting construct is the so called Rich-header right after the MS-DOS stub.
**It is essentially Microsoft spying on**   **you**  for the purpose of &quot;defending against Malware authors&quot;.
If you are interested in this topic or simply want to know how to get rid of the Rich-header,
read [this article](http://bytepointer.com/articles/the_microsoft_rich_header.htm) from bytepointer [good page, pretty old tho, recommend this one].
It will show you how to patch your Linker to cut out the Rich-header.

So, the MS-DOS stub starts at 0x40, and including the Rich-header, it usually stretches up to 0x100 or 0x120, somewhere around there. So while we did not find anything in common with ELF-files, we already figured out that  **each PE-file has an unnecessary overhead of around 100 bytes** .
Good job, Microsoft!

Okay, now let&#39;s see whether we can find anything that these two file formats DO have in common.
At the &quot;beginning&quot; of each PE-file we can find the  **PE-file header.**  If you remember the article about ELF-files, this is something both formats share. It holds basic information about the number of sections, some pointers, stuff like that.
It is essentially the MS counterpart of the ELF header, except it is incomplete.
For whatever reasons, there is another &quot; **optional header** &quot; following the PE-file header. Now don&#39;t get confused here, beside the name there is nothing &quot;optional&quot; about this header. Only these two in conjunction form a complete PE-header. [ffs Microsoft, get your shit together]

Following up we can find the  **data directories** , essentially pointers to the sections at runtime. These are used mostly by the loader, to get to the section offsets really fast when loading up the binary for execution. They don&#39;t serve any other purpose.

[![|211x320](upload://lP4W2FodCa9AycwXdv6ckoYbCSY.jpeg)](https://1.bp.blogspot.com/-IOeWTcIxZvA/XhSz70jrowI/AAAAAAAABMc/qX65JATTe9QhWGvcZA3mCvHEiuo8ku7kACNcBGAsYHQ/s1600/ripof.jpg)After that we get right into the  **sections** , or rather, the what-would-be section header table (although MS doesn&#39;t call it like that). Each section contained in the program is listed here, with a pointer to the in-memory location of the section. We will get there eventually, but let&#39;s talk about sections a bit longer.
For most parts, each section in a PE-file has an almost identical counterpart inside ELF-files, often even sharing the same name. Unlike ELF-files, the PE format does not really distinguish between sections and segments. There are simply sections, period.  **There is no such thing like a program header table** , which may be a curse or a bless, depending on your look at it. The section header table is used for linking and loading the binary, so the PE-files are somewhat more consistent at execution time.
For some reason, compilers like the one in Visual Studio sometimes place read-only data inside the .text section instead of .rdata, mixing it up with executable code. Be cautious, for this can lead to problems during disassembly.

One of the most important sections,  **.edata**  and  **.idata** , have no equivalent in ELF-files. They contain exported and imported functions. The .idata section specifies which symbols to import from .DLLs, while the .edata section lists symbols and addresses that the binary exports. In practise, .idata and .edata are often merged withing the .rdata section, but besides that work exactly like I just described.
Resolving of external dependencies works similar to ELF-files, Microsoft just uses a struct called &quot; **Import Address Table** &quot; (or IAT) instead of the ELFish &quot;Global Offset Table&quot;. Microsoft uses so called  **Thunks**  for external library calls, which happen to be jump gates of pointers, so basically there is no big difference between Windows-thunks and ELf-stubs.

Another thing to know is that Visual Studio emits int3 instructions to pad and align functions. This has no deeper meaning, you could as well use nop-operations, it&#39;s just MS&#39;s style to do the same things and call it by different name. The int3 instructions normally serve as breakpoints for debuggers, but since they are placed in the void between actual code sections, this is not really of an issue.

#### Implementing a File Reader [1] Opening and Reading a binary

Now, let&#39;s start implementing our own PE dumper, [similar to the one we wrote for ELF files](https://metabytezero.blogspot.com/2019/08/writing-disassembler.html),
but much simpler. Think of it more like a prototype for future projects. I will talk about this at the end of the blogpost. To get to work, we first need to consider some things:

* How will the binary be loaded
* How are we going to orient our self over the file
* How do we actually read values and output them
* How do we confirm that the values are correct

For each of these points, there are slippery slopes and shortcuts, and I had to reorganize the program several times due to false assumptions, so on the way through the code, let me explain how to overcome coding problems with skill rather than with speed.

Let&#39;s just look at the beginning of the main function first:

```
int _tmain(int argc, TCHAR *argv[])
{
 //file handles
 HANDLE targetBinary;
 LPDWORD readBytes = 0;
 DWORD fileSize;

 //the pointer that will serve as bookmark
 int readPointer = 0x0;

 //get system info to validate some byte values
 SYSTEM_INFO si;
 GetSystemInfo(&amp;si);

 fprintf(stdout, &quot;The page size for this system is %u bytes.\n&quot;, si.dwPageSize);


 //handle to file needs to be called via CreateHandle
 targetBinary = CreateFile(L&quot;C:/Program Files (x86)/Wizards of the Coast/MTGA/MTGA.exe&quot;, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
 fileSize = GetFileSize(targetBinary, NULL);

 fprintf(stdout, &quot;File is %d Kbytes large\n&quot;, fileSize/1024);
 char *fileContent = new char[fileSize];

 
 if (targetBinary != INVALID_HANDLE_VALUE)
 {
  DWORD retVal = 0;
  //if function successfull, retVal is != 0
  if(!(retVal = ReadFile(targetBinary, (LPVOID)fileContent,fileSize, readBytes, NULL)))
  {
   fprintf(stdout, &quot;There was an error reading input file!: %d returned.\n&quot;,retVal);
   exit (-1);
  }

  //fprintf(stdout, &quot;Return value of ReadFile(5) is %d\n&quot;, retVal);
 }

   [ ... ]

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
```

Copy

**[  1  ] The _tmain function**
The first line already looks weird, I admit ^^
If you invoke int _tmain, you enable 16bit modes in C++ code. Well, that&#39;s the short version for this, at least.

**_tmain**  is like a switch that automatically decides whether main or wmain should be called, a Microsoft extension.
It enables Unicode (UTF-16) character sets and also swaps the bytes because of it&#39;s endianess, thus resulting in the program seeing a bunch of 0 terminated strings rather than char arrays. If you want to know more, go to [this Stackoverflow post](https://stackoverflow.com/questions/895827/what-is-the-difference-between-tmain-and-main-in-c). We basically Increase the support for modern operation systems and their weird file names while also using it as a kind of safety measure for reading hex values. I&#39;ll talk about it in future posts, especially on Assembler.

**[  3-6  ] Handle to load the binary**
Remember the first point on our list? Let&#39;s start with that. I&#39;m sure many of you will know how to read a file in C++, but let me introduce file Handles to you. A handle is basically a pointer to something. In this case, it&#39;s to a file. This pointer helps us to read, write, copy or overwrite said file however we want. It is also useful if we want to modify the binary later. Let&#39;s not stick to this for too long,  **it&#39;s a higher level-pointer that&#39;s well documented** . The  **LPDWORD**  and  **DWORD**  are both integers that we&#39;ll be using to read the binary into memory.

**[  9  ] The binary pointer**
One part of the answer to  **How are we going to orient our self over the file**  lies within this variable. As the name tries to imply, it will save our current location while moving through the file, but currently it&#39;s set to 0 so it just points to the very beginning.

**[  18-19  ] Open FileHandle**
At 18-19 we are creating the actual HANDLE file object. The first argument  **CreateFile**  takes is a path to a file. We are providing an Unicode version [with the &quot;L&quot; prefix] of the string, so every language should be supported. Also, CreateFile is a nice function, it accepts both forward- and backward-slashes.  *Way to go, CreateFile!*
The next parameters are access rights and some attributes, and all I had to do is [look into the documentation](https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea) and fiddle it out until it worked. Let&#39;s skip this trivial path

It&#39;s really up to you which binary you pick for testing, but it  **really**  is useful to test multiple files during development. You don&#39;t want to fall to false assumptions. I was halfway through development when I realized that not all values are at fixed locations. In fact, none of them really are. Alas, had I only tested multiple files first, I had saved at least 2 hours of rewriting and testing stuff.
*Fool your assumptinons before getting fooled by your assumptions.*

**[  26-37  ] Read the file into memory**
We created a file, now it is time to read it. The [ReadFile function](https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfile) isn&#39;t an easy function to work with. At first I should say that there are 2 versions of the function, a synchronous and an asynchronous one. The latter is required for reading streams, drivers and the like, stuff that changes a lot, and it is called  **ReadFileEx** . We will need a callback here, as you&#39;ll notice.

#### Implementing a File Reader [2] Functions and callback

It&#39;s time to look at some functions that we&#39;ll be using to step over the file and output stuff. We are going to plan ahead here. Since we want to extend the program in the future, we will already implement a function to output a chunk of hex bytes with line numbering, just like a disassembler. Also, make sure you are really understanding what&#39;s going on, especially with the  **OR-operation** . We&#39;ll get to this, let&#39;s first again look at the code and think about it after wards.

```
#include &lt;windows.h&gt;
#include &lt;tchar.h&gt;
#include &lt;iostream&gt;

#define QWORD_L 8
#define DWORD_L 4
#define BYTE_L 1
#define WORD_L 2

using namespace std;
//for use in callback
DWORD transfered = 0;

//actual callback for asynchronous reading
VOID CALLBACK finished
(
 __in  DWORD dwErrorCode,
 __in  DWORD dwNumberOfBytesTransfered,
 __in  LPOVERLAPPED lpOverlapped
)
{
 _tprintf(TEXT(&quot;Error code:\t%x\n&quot;), dwErrorCode);
 _tprintf(TEXT(&quot;Number of bytes:\t%x\n&quot;), dwNumberOfBytesTransfered);
 transfered = dwNumberOfBytesTransfered;
}

//later for oop (parameter called by reference)
void copy_bytes(char* &amp;dump,  char* &amp;memory, int start, int end)
{
 int counter = 0;

 while (start &lt; end)
 {
  memory[counter++] = dump[start++];
 }
 return;
}

//give single data fields or output values
//TO DO: write function so you can input start, dword (or whatever)
void output_data(char* memory, int start, int end)
{
 if (end &lt; start)
  return;
 fprintf(stdout, &quot;0x&quot;);
 while (end &gt;= start)
 {
  fprintf(stdout, &quot;%02hhX&quot;, memory[end]);
  end--;
 }
}

//same function, but grabbing text this time, so reversed output direction (big-endian)
void output_data_ascii(char* memory, int start, int end)
{
 if (end &lt; start)
  return;
 while (start &lt; end)
 {
  fprintf(stdout, &quot;%c&quot;, memory[start]);
  start++;
 }
}

//because file shambles
int getValuePNTR(const char* memory, int &amp;start, int size)
{
 uint64_tretVal = 0;

 //now just add up array fields 
 for (int i = start + size-1,j = size-1; j &gt;= 0; --j, i--)
 {
  //fprintf(stdout, &quot;\ncycle: %d, memory: [%x]&quot;, j, memory[i]);

  if ((unsigned char)memory[i] == 00 &amp;&amp; j &gt; 0)
   retVal &lt;&lt;= 8;
  else
   retVal |= ((unsigned char)(memory[i]) &lt;&lt; (8 * j));
 }
 //get the next field after this one
 start += size;
 return retVal;
}
//overwrite function
int saveValuePNTR(char* memory, int start, int size)
{
 uint64_tretVal = 0;
 for (int i = start + size - 1, j = size - 1; j &gt;= 0; --j, i--)
 {
  if ((unsigned char)memory[i] == 00 &amp;&amp; j &gt; 0)
   retVal &lt;&lt;= 8;
  else
   retVal |= ((unsigned char)(memory[i]) &lt;&lt; (8 * j));
 }
 return retVal;
}

//output stuff
void output_bytes(char* memory, int start, int end)
{
 //tracker for formatting the dump
 int counter = 1;
 int linebreaker = 0;

 int offset = start ? start % 0x10 : 0;

 //output the binary, use upper case X in format string for BIG LETTERS
 fprintf(stdout, &quot;%010x: &quot;, start - offset);

 for (int i = start - offset; i &lt; end; i++)
 {
  if (counter &gt; 3)
  {
   // print dots if we have an uneven countVal
   if (offset &gt; 0)
   {
    offset--;
    fprintf(stdout, &quot;.. &quot;);
    counter = 0;
   }
   else
   {
    fprintf(stdout, &quot;%02hhX &quot;, memory[i]);
    counter = 0;
   }
   linebreaker++;
  }
  else
  {
   // print dots if we have an uneven countVal
   if (offset &gt; 0)
   {
    offset--;
    fprintf(stdout, &quot;..&quot;);
   }
   else //print the opcode
    fprintf(stdout, &quot;%02hhX&quot;, memory[i]);
  }
  counter++;

  if (linebreaker &gt; 3)
  {
   fprintf(stdout, &quot;\n&quot;);
   fprintf(stdout, &quot;%#010x: &quot;, i + 1);
   linebreaker = 0;
  }
 }
 cout &lt;&lt; endl &lt;&lt; endl;
}
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
```

Copy

It looks longer than it is, really. The hardest part is probably the last one. Right after the imports, I created some macros to represent byte lengths. Now, I know I could just type in the numbers, but it really is better to read, and also did I have problems with the standard ones so I made my own.

**[ 1-8 ] The callback for ReadFile**
This callback works in conjunction with the ReadFile function we already looked at in the beginning of _tmain. I was just copying it from the Microsoft documentations, so you&#39;d be better off by just searching there. If you just want to understand it for now, it kind of copys chunks of data of fixed size, checking for EOF in between reads. The callback can be used to transmit errors and signals. It bounces a parameter referenced to as &quot;NumbersOfBytesTransfered&quot; over each cycle. There&#39;s really not that much up with it. Also it doesn&#39;t stop on a NULL-byte because it thinks that it&#39;s a string termination, which is kinda nice.

**[ 27-37 ] Copy between files**
This function can be used to copy chunks of bytes between different files. Remember that we created a file with our file handle, we might want to automatically insert code chunks at special points in the code some time in the future. Consider this function a typical  *it will come in handy  **LATER*** .

**[ 41-63 ] Output raw data**
These two functions can be used to output data from the binary. You might notice the format string  **%02hhx** . It is a 2 digit hexadecimal format, and you should get used to this kind of format strings.

* **0**
  * fill the number with zeros to align the digits (f.e. write 0001 instead of 1)
* **2**
  * the length of the number
* **hh**
  * if followed by a x, this will make the input an unsigned char
* **x**
  * output as hexadecimal number as specified

The third part is crucial. When working with hexadecimal output we are  **always required to work with unsigned chars** , as I had to learn the hard way. If you don&#39;t state that you are expecting the values to be unsigned, your output will be totally random, since the first bit in each variable is usually interpreted as the sign. If you get strange readings during testing, check for the signing of especially chars.

You&#39;ll notice that for the second function, I broke my own premise of always using unsigned chars. Yikes! The reason for this is simple: we aren&#39;t using any hex values here. When dealing with binaries, you&#39;ll often encounter data saved in plain text form. Usually strings, but sometimes information for the loader, too. These strings are stored in  **big-endian** , which means they are &quot;forward&quot; written in the file (like in, how a human would read them). 

That&#39;s great, they made this so we have an easy life reading the strings, right?! NAHAA, it&#39;s only because they get read in reverse order into memory later anyway. Don&#39;t assume anybody would help you fiddling around with their stuff! [JK lol]

**[ 66-98 ] Oh, to read a DWORD**
These next functions are really our bread and butter. We are going to call them very often, indeed. And it is them that feature the OR-operation that took me almost 2 weeks. It failed constantly, and I had no idea why.
Both functions start identically: They take a chunk of data as first argument, a pointer into that chunk as second one, and a to-read size as third parameter. One difference you might notice is that the first functions takes the start parameter as a call-by-reference so we can increment it while we are at it. This way you can read values and at the same time increment the file pointer, which saves us some memory.

Both functions first define a  **uint64_t** . Normally I had used DWORD or QWORD here, but recently I found out my program would crash when reading 64bit code, so we are using the 8 byte long variable here all along.
I was going to write how awesome DWORD is because it&#39;s managed by operation system instead of language, but uint64_t should be 8 byte long always, too, so we won&#39;t get any problems in the future, except maybe someone invents 128bit processors, but this is actually pretty unlikely (in 2020, lul).

Following along, we check whether we read a zero-byte, and if so, we just shift the return variable one byte to the left. This is necessary because we might read a zero as last input, and instead of just adding 00 as the count for position 0, we would shift the first byte out of scope. You can try this out and see it yourself if you want, or you can just trust me on this one.

After we found the byte, we have to shift it to the left a number of times equal to the relative position inside the byte-mask. For example, if we have the value 1 at the third position of the value, we have to shift it to the left three times. This is a bit of a brainfuck at first, especially since values are usually stored little-endian style, but you&#39;ll get used to it pretty fast. After the value was shifted, we (logical) OR it against the return variable. This way we insert the correct value byte by byte.

The biggest difference between these two functions is probably that the first one increments the filepointer after reading the value, so we can just read the next, and the next and so forth. The latter doesn&#39;t do so, since we want to save the value from the binary AND call the first function after wards to output it, so this is just ease-of-use here.

**[ 99 ] Future use as decompiler**
This whole function is designed to nicely print out a (big) chunk of data in a form that you would expect from a typical hex-editor. In the whole example program I&#39;m currently not using it for anything, but I tested and fine-tuned it, so feel free to give it a try. It will print out line numbers as well as a little gap between DWORDS, so you can examine the binary. Although I am not really using it (or explaining), it is extremely useful to have for future examinations of binaries, so just keep it there, and maybe play around with it a little.

#### Implementing a File Reader [3] The main work

After the setup of all our functions and the loading of the binary into memory, it is time to actually get some data out of it. But first we have to solve a riddle in the file:
**Where the fuck does it start anyways?**

The answer to this question is:  *it depends...*
&quot;Ah, great, another of these undecided binaries&quot;, you might think.
&quot;Get your shit together, man!&quot;

In fact the first value we need to extract from the binary is the most crucial for us at this point: The value at  **0x3c** . This magic number is an address at which we can find the PE-signature, and after that the real information is hidden. In it&#39;s original form my program featured a function that just hard-reads this value, but since we have all our nice functions at the top, we are going to use them right away. Let&#39;s take a look:

```
//first, get that 0x3c word so we know where to start reading
 readPointer = saveValuePNTR(fileContent, 0x3c, WORD_L);
 fprintf(stdout, &quot;\nINITIALISING....\nReadpointer before operation: %x&quot;,readPointer);
 fprintf(stdout, &quot;\n[DWORD]  PE-SIGNATURE           :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, &quot;\nReadpointer after operation: %x\nInitialising finished&quot;, readPointer);

 //first block: PE FILE HEADER
 fprintf(stdout, &quot;\n\nCollect Information (PE file header):&quot;);
 fprintf(stdout, &quot;\n[WORD]  Mashinae Type          :0x%08x&quot;, getValuePNTR(fileContent, readPointer, WORD_L));
 unsigned int sectionCount = saveValuePNTR(fileContent, readPointer, WORD_L);            
 fprintf(stdout, &quot;\n[WORD]  Number of Sections     :0x%08x&quot;, getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, &quot;\n[DWORD] Timestamp              :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, &quot;\n[DWORD] Pointer to symbol table:0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, &quot;\n[DWORD] Number of Symbols      :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, &quot;\n[WORD]  Size of optional header:0x%08x&quot;, getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, &quot;\n[WORD]  Characteristics        :0x%08x&quot;, getValuePNTR(fileContent, readPointer, WORD_L));
 
 
```

Copy

Right at the start, we first grab the information about the PE-Signature, as I said it is located at 0x3c, and it is 2 byte long, hence the WORD_L. After that, I wrote a little initialization output just to be sure everything works as expected. Notable are the use of the  **fprintf function.**  By using this, we can later swap out the stdout with a file pointer, so we can easily create log files about our readings.
I decided to use the format string  **0x%08x**  to give the output a fixed length of 8 digits. This will have to be tweaked for QWORDS later on.

The first block we are going to read is the PE file header. You can see in  **line 10**  how we are able to save some information that will come in handy later with the help of the  **saveValuePNTR**  function. The rest is just outputting information for now. This is pretty much how the rest of the code looks, with some exeptions for 64bit systems, as you can see below:

```
//second block: OPTIONAL HEADER
 fprintf(stdout, &quot;\n\nOPTIONAL HEADER [general fields]:&quot;);
 unsigned int type = saveValuePNTR(fileContent, readPointer, WORD_L);              
 fprintf(stdout, &quot;\n[WORD] Architecture            :0x%08x&quot;, getValuePNTR(fileContent, readPointer, WORD_L));
 if (type == 0x010b)
  fprintf(stdout, &quot;  -&gt;  [32 bit]&quot;);
 else if (type == 0x20b)
  fprintf(stdout, &quot;  -&gt;  [64 bit]&quot;);
 else if (type == 0x107)
  fprintf(stdout, &quot;  -&gt;  [ROM img]&quot;);
 else
  fprintf(stdout, &quot;  -&gt;  [unknown]&quot;);

 fprintf(stdout, &quot;\n[BYTE] Major Linker Version    :0x%08x&quot;, getValuePNTR(fileContent, readPointer, BYTE_L));
 fprintf(stdout, &quot;\n[BYTE] Minor Linker Version    :0x%08x&quot;, getValuePNTR(fileContent, readPointer, BYTE_L));
 fprintf(stdout, &quot;\n[DWORD]Size of Code            :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, &quot;\n[DWORD]SizeofInitialisedData   :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, &quot;\n[DWORD]SizeifUninialisedData   :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, &quot;\n[DWORD]Adress of Entrypoint    :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, &quot;\n[DWORD]CodeBase                :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));

 //next field depending on arch (only present in 32bit executables)
 if (type == 0x010b)
  fprintf(stdout, &quot;\n[DWORD]Base of Data            :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));


 fprintf(stdout, &quot;\n\nOPTIONAL HEADER [windows only fields]:&quot;);
 fprintf(stdout, &quot;\n[DWORD / QWORD]ImageBase       :&quot;);

 unsigned int base;
 //next field depending on arch, 4 byte in 32bit, 8 byte in 64bit
 if (type == 0x010b)
 {
  base = saveValuePNTR(fileContent, readPointer, DWORD_L);
  fprintf(stdout, &quot;0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  //fprintf(stdout, &quot;\nDEBUG:     0x%08x , pointer @ %x     \n&quot;, base,readPointer);
 }
 else if (type == 0x020b)
 {
  base = saveValuePNTR(fileContent, readPointer, QWORD_L);
  fprintf(stdout, &quot;0x%016x&quot;, getValuePNTR(fileContent, readPointer, QWORD_L));
 }
 else
  base = 0xFFFFFFFF;

 unsigned int offset_segment = saveValuePNTR(fileContent, readPointer, DWORD_L);
 fprintf(stdout, &quot;\n[DWORD]Section Alignement      :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, &quot;\n...beginning of text segment @  0x%08x&quot;, (base + offset_segment));

 fprintf(stdout, &quot;\n[DWORD]File Alignement         :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, &quot;\n[WORD] OS VERSION major        :0x%08x&quot;, getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, &quot;\n[WORD] OS VERSION minor        :0x%08x&quot;, getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, &quot;\n[WORD] image version major     :0x%08x&quot;, getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, &quot;\n[WORD] image version minor     :0x%08x&quot;, getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, &quot;\n[WORD] subsystem major version :0x%08x&quot;, getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, &quot;\n[WORD] subsystem minor version :0x%08x&quot;, getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, &quot;\n[DWORD] xxxXXX ZERO VAL XXXxxx :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, &quot;\n[DWORD] Imagesize in bytes     :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, &quot;\n[DWORD] Size of headers        :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, &quot;\n[DWORD] Checksum               :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));

 unsigned int subsystem = saveValuePNTR(fileContent, readPointer, WORD_L);
 fprintf(stdout, &quot;\n[WORD]  Subsystem version      :0x%08x&quot;, getValuePNTR(fileContent, readPointer, WORD_L));

 unsigned int dll_characteristic = saveValuePNTR(fileContent, readPointer, WORD_L);
 fprintf(stdout, &quot;\n[WORD]  DLL characteristics    :0x%08x&quot;, getValuePNTR(fileContent, readPointer, WORD_L));

 //the next 4 values depend on architecture
 if (type == 0x010b)
 {
  fprintf(stdout, &quot;\n[DWORD] SizeOfStackReserve     :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\n[DWORD] SizeOfStackCommit      :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\n[DWORD] SizeOfHeapReserve      :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\n[DWORD] SizeOfHeapCommit       :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
 }
 else if (type == 0x20b)
 {
  fprintf(stdout, &quot;\n[QWORD] SizeOfStackReserve     :0x%016x&quot;, getValuePNTR(fileContent, readPointer, QWORD_L));
  fprintf(stdout, &quot;\n[QWORD] SizeOfStackCommit      :0x%016x&quot;, getValuePNTR(fileContent, readPointer, QWORD_L));
  fprintf(stdout, &quot;\n[QWORD] SizeOfHeapReserve      :0x%016x&quot;, getValuePNTR(fileContent, readPointer, QWORD_L));
  fprintf(stdout, &quot;\n[QWORD] SizeOfHeapCommit       :0x%016x&quot;, getValuePNTR(fileContent, readPointer, QWORD_L));
 }
 
 
 
 
 
 
 
 
 
```

Copy

We are going to read the rest of the header and optional header. At some points, like in lines 5-12, it is necessary to differentiate between x86 and x86-64 systems. We can make this differentiation with the help of the value we read in line 3. This is one of the more crucial information we have to gather, as it is used further below again. Also, note that we have to expand the format string to  **0x%016x**  if we are to output 64bit information.
Since a single byte needs 2 digits to be displayed ( from range 00 to ff ), we have to expand the format string in these cases. Luckily, there are only minor differences between 32bit and 64bit binaries. I suggest you read into the [Microsoft Documentation](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#dll-characteristics), as I stated earlier.

In the documentation, you can see the length of the fields in each architecture, so we just have to insert some switches there and use our existing functions to expand to a QWORD_L there. Some values are of mere WORD length, and some are even single BYTE.

Coming up next are the  **Data Directories** . These are essentially pointers into sections, and they are primarily for the linker, so that he has some shortcuts when setting up the process into memory. You CAN, however, use them to find important sections like the Import Table (which is one of the most important ones), so when augmenting a program, these pointers will be useful to your augmentor program.

```
unsigned int remainder = saveValuePNTR(fileContent, readPointer, DWORD_L);
 fprintf(stdout, &quot;\n[DWORD] Remaining header count :0x%08x [Remaining data directories]&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, &quot;\nPointer now @ %x&quot;, readPointer);

 //next up are the data directories, there are usually 16 of them
 //each is 8 byte, so 16 * 8 = 128 &gt;&gt; size of directory entries

 if (remainder == 16)
 {
  fprintf(stdout, &quot;\n\n############################################################\nData Directory entries:&quot;);
  fprintf(stdout, &quot;\nExport Table           :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;      [Size]   :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nImport Table           :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;      [Size]   :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nResource Table         :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;      [Size]   :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nException Table        :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;      [Size]   :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nCertification Table    :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;      [Size]   :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nBase Relocation Table  :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;      [Size]   :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nDebug                  :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;      [Size]   :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nArchitecture           :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;      [Size]   :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nGlobal PTR             :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;      [Size]   :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nTLS Table              :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;      [Size]   :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nLoad Config Table      :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;      [Size]   :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nBound Import           :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;      [Size]   :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nIAT                    :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;      [Size]   :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nDelay Import Descriptor:0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;      [Size]   :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nCLR Runtime Header     :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;      [Size]   :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nReserved Zero Value    :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;      [Size]   :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nEnd Data Directories, PNTr now @  %x&quot;, readPointer);
 }
 else
 {
  fprintf(stdout, &quot;\n\nDetected non-standart data directories, recalculating Pointer ...&quot;);
  readPointer += (remainder) * 8;
  fprintf(stdout, &quot;\nEnd Data Directories, PNTr now @  %x&quot;, readPointer);
 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
```

Copy

At first, we save the remainder of data directories. Now, don&#39;t get confused here, a PE file usually has 16 data directories.  **ALWAYS** . But when, for example, the remainder counts 10, it means that some directories are empty. For example, a binary may not export anything, or does not have a Debug section. If, for whatever reason, the binary has more or less than 16 data directories, we skip the output (for now), and recalculate the beginning of the section headers.

**The else part is wrong at the moment!**
As I just described, the remainder is  **not**  the actual number of data directories, but I will just leave it as it is for now, it should not be too hard to recalculate if you ever have the need for it.

There is only one part left:  **The actual section headers** , so let&#39;s dive right in:

```
/*
  Following section headers
  Each section header is 40 byte large (5 DWORDS)
  You can calculate the beginning of the headers, 
  but we came here anyways so let&#39;s skip that part
 */
 fprintf(stdout, &quot;\n\n##########   BEGINNING OF SECTION HEADERS   ##########\n&quot;);
 for (int i = 0; i &lt; sectionCount; i++)
 {
  //first output the name in plain ascii, big-endian
  fprintf(stdout, &quot;\n\n###################    &quot;);
  output_data_ascii(fileContent, readPointer, readPointer + 8);
  fprintf(stdout, &quot;    ###################&quot;);

  readPointer += 8;
  fprintf(stdout, &quot;\nVirtual Size           :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nVirtual Address        :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nSize of Raw Data       :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nPointer to Raw Data    :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nPointer to Relocations :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nPointer to line numbers:0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nNumber of Relocations  :0x%08x&quot;, getValuePNTR(fileContent, readPointer, WORD_L));
  fprintf(stdout, &quot;\nNumber of line numbers :0x%08x&quot;, getValuePNTR(fileContent, readPointer, WORD_L));
  fprintf(stdout, &quot;\nCharacteristix         :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
 }

 //close handle, end of operations
 CloseHandle(targetBinary);
        std::cout &lt;&lt; &quot;\nEnd reached!\n&quot;;

 return 0;
}

```

Copy

This is the last part of our program so far, and it will grab the section headers from the binary.
Each section header has a fixed size and the same values associated with it, so we can just use a loop to grab all of them. Since the name of each section is stored in big-endian, aka human-readable way, we have to call our output_data_ascii function here. There isn&#39;t really any magic in here, nothing you didn&#39;t already encounter. Note that we manually have to increment the readPointer variable in each loop, since the output_data_ascii function doesn&#39;t do this for us. The amount of section headers is already stored in the variable  **sectionCount** , so we always have the right amounts of loops ready.

At the end we need to close the handle to prevent memory leakage and overflowing.

#### Full code

Here I want to paste the full code in a single file so it&#39;s easier to just copypasta it if you want to try it out yourself:

```
#include &lt;windows.h=&quot;&quot;&gt;
#include &lt;tchar.h=&quot;&quot;&gt;
#include &lt;iostream&gt;

#define QWORD_L 8
#define DWORD_L 4
#define BYTE_L 1
#define WORD_L 2

using namespace std;
//for use in callback
DWORD transfered = 0;

//actual callback for asynchronous reading
VOID CALLBACK finished
(
 __in  DWORD dwErrorCode,
 __in  DWORD dwNumberOfBytesTransfered,
 __in  LPOVERLAPPED lpOverlapped
)
{
 _tprintf(TEXT(&quot;Error code:\t%x\n&quot;), dwErrorCode);
 _tprintf(TEXT(&quot;Number of bytes:\t%x\n&quot;), dwNumberOfBytesTransfered);
 transfered = dwNumberOfBytesTransfered;
}

//later for oop (parameter called by reference)
void copy_bytes(char* &amp;dump,  char* &amp;memory, int start, int end)
{
 int counter = 0;

 while (start &lt; end)
 {
  memory[counter++] = dump[start++];
 }
 return;
}

//give single data fields or output values
//TO DO: write function so you can input start, dword (or whatever)
void output_data(char* memory, int start, int end)
{
 if (end &lt; start)
  return;
 fprintf(stdout, &quot;0x&quot;);
 while (end &gt;= start)
 {
  fprintf(stdout, &quot;%02hhX&quot;, memory[end]);
  end--;
 }
}

//same function, but grabbing text this time, so reversed output direction (big-endian)
void output_data_ascii(char* memory, int start, int end)
{
 if (end &lt; start)
  return;
 while (start &lt; end)
 {
  fprintf(stdout, &quot;%c&quot;, memory[start]);
  start++;
 }
}

//because file shambles
int getValuePNTR(const char* memory, int &amp;start, int size)
{
 uint64_t retVal = 0;

 //now just add up array fields 
 for (int i = start + size-1,j = size-1; j &gt;= 0; --j, i--)
 {
  //fprintf(stdout, &quot;\ncycle: %d, memory: [%x]&quot;, j, memory[i]);

  if ((unsigned char)memory[i] == 00 &amp;&amp; j &gt; 0)
   retVal &lt;&lt;= 8;
  else
   retVal |= ((unsigned char)(memory[i]) &lt;&lt; (8 * j));
 }
 //get the next field after this one
 start += size;
 return retVal;
}
//overwrite function
int saveValuePNTR(char* memory, int start, int size)
{
 uint64_t retVal = 0;
 for (int i = start + size - 1, j = size - 1; j &gt;= 0; --j, i--)
 {
  if ((unsigned char)memory[i] == 00 &amp;&amp; j &gt; 0)
   retVal &lt;&lt;= 8;
  else
   retVal |= ((unsigned char)(memory[i]) &lt;&lt; (8 * j));
 }
 return retVal;
}

//output stuff
void output_bytes(char* memory, int start, int end)
{
 //tracker for formatting the dump
 int counter = 1;
 int linebreaker = 0;

 int offset = start ? start % 0x10 : 0;

 //output the binary, use upper case X in format string for BIG LETTERS
 fprintf(stdout, &quot;%010x: &quot;, start - offset);

 for (int i = start - offset; i &lt; end; i++)
 {

  if (counter &gt; 3)
  {
   // print dots if we have an uneven countVal
   if (offset &gt; 0)
   {
    offset--;
    fprintf(stdout, &quot;.. &quot;);
    counter = 0;
   }
   else
   {
    fprintf(stdout, &quot;%02hhX &quot;, memory[i]);
    counter = 0;
   }
   linebreaker++;
  }
  else
  {
   // print dots if we have an uneven countVal
   if (offset &gt; 0)
   {
    offset--;
    fprintf(stdout, &quot;..&quot;);
   }
   else //print the opcode
    fprintf(stdout, &quot;%02hhX&quot;, memory[i]);
  }
  counter++;

  if (linebreaker &gt; 3)
  {
   fprintf(stdout, &quot;\n&quot;);
   fprintf(stdout, &quot;%#010x: &quot;, i + 1);
   linebreaker = 0;
  }

 }
 cout &lt;&lt; endl &lt;&lt; endl;
}

int _tmain(int argc, TCHAR *argv[])
{
 //file handles
 HANDLE targetBinary;
 LPDWORD readBytes = 0;
 DWORD fileSize;

 //the pointer that will serve as bookmark
 int readPointer = 0x0;

 //get system info to validate some byte values
 SYSTEM_INFO si;
 GetSystemInfo(&amp;si);

 fprintf(stdout, &quot;The page size for this system is %u bytes.\n&quot;, si.dwPageSize);


 //handle to file needs to be called via CreateHandle
 targetBinary = CreateFile(L&quot;C:/Program Files (x86)/Wizards of the Coast/MTGA/MTGA.exe&quot;, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
 fileSize = GetFileSize(targetBinary, NULL);

 fprintf(stdout, &quot;File is %d Kbytes large\n&quot;, fileSize/1024);
 char *fileContent = new char[fileSize];

 
 if (targetBinary != INVALID_HANDLE_VALUE)
 {
  DWORD retVal = 0;
  //if function successfull, retVal is != 0
  if(!(retVal = ReadFile(targetBinary, (LPVOID)fileContent,fileSize, readBytes, NULL)))
  {
   fprintf(stdout, &quot;There was an error reading input file!: %d returned.\n&quot;,retVal);
   exit (-1);
  }

  //fprintf(stdout, &quot;Return value of ReadFile(5) is %d\n&quot;, retVal);
 }

 //first, get that 0x3c word so we know where to start reading
 readPointer = saveValuePNTR(fileContent, 0x3c, WORD_L);
 fprintf(stdout, &quot;\nINITIALISING....\nReadpointer before operation: %x&quot;,readPointer);
 fprintf(stdout, &quot;\n[DWORD]  PE-SIGNATURE           :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, &quot;\nReadpointer after operation: %x\nInitialising finished&quot;, readPointer);

 //first block: PE FILE HEADER
 fprintf(stdout, &quot;\n\nCollect Information (PE file header):&quot;);
 fprintf(stdout, &quot;\n[WORD]  Mashinae Type          :0x%08x&quot;, getValuePNTR(fileContent, readPointer, WORD_L));
 unsigned int sectionCount = saveValuePNTR(fileContent, readPointer, WORD_L);            
 fprintf(stdout, &quot;\n[WORD]  Number of Sections     :0x%08x&quot;, getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, &quot;\n[DWORD] Timestamp              :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, &quot;\n[DWORD] Pointer to symbol table:0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, &quot;\n[DWORD] Number of Symbols      :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, &quot;\n[WORD]  Size of optional header:0x%08x&quot;, getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, &quot;\n[WORD]  Characteristics        :0x%08x&quot;, getValuePNTR(fileContent, readPointer, WORD_L));

 //second block: OPTIONAL HEADER
 fprintf(stdout, &quot;\n\nOPTIONAL HEADER [general fields]:&quot;);
 unsigned int type = saveValuePNTR(fileContent, readPointer, WORD_L);              
 fprintf(stdout, &quot;\n[WORD] Architecture            :0x%08x&quot;, getValuePNTR(fileContent, readPointer, WORD_L));
 if (type == 0x010b)
  fprintf(stdout, &quot;  -&gt;  [32 bit]&quot;);
 else if (type == 0x20b)
  fprintf(stdout, &quot;  -&gt;  [64 bit]&quot;);
 else if (type == 0x107)
  fprintf(stdout, &quot;  -&gt;  [ROM img]&quot;);
 else
  fprintf(stdout, &quot;  -&gt;  [unknown]&quot;);

 fprintf(stdout, &quot;\n[BYTE] Major Linker Version    :0x%08x&quot;, getValuePNTR(fileContent, readPointer, BYTE_L));
 fprintf(stdout, &quot;\n[BYTE] Minor Linker Version    :0x%08x&quot;, getValuePNTR(fileContent, readPointer, BYTE_L));
 fprintf(stdout, &quot;\n[DWORD]Size of Code            :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, &quot;\n[DWORD]SizeofInitialisedData   :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, &quot;\n[DWORD]SizeifUninialisedData   :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, &quot;\n[DWORD]Adress of Entrypoint    :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, &quot;\n[DWORD]CodeBase                :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));

 //next field depending on arch (only present in 32bit executables)
 if (type == 0x010b)
  fprintf(stdout, &quot;\n[DWORD]Base of Data            :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));


 fprintf(stdout, &quot;\n\nOPTIONAL HEADER [windows only fields]:&quot;);
 fprintf(stdout, &quot;\n[DWORD / QWORD]ImageBase       :&quot;);

 unsigned int base;
 //next field depending on arch, 4 byte in 32bit, 8 byte in 64bit
 if (type == 0x010b)
 {
  base = saveValuePNTR(fileContent, readPointer, DWORD_L);
  fprintf(stdout, &quot;0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  //fprintf(stdout, &quot;\nDEBUG:     0x%08x , pointer @ %x     \n&quot;, base,readPointer);
 }
 else if (type == 0x020b)
 {
  base = saveValuePNTR(fileContent, readPointer, QWORD_L);
  fprintf(stdout, &quot;0x%016x&quot;, getValuePNTR(fileContent, readPointer, QWORD_L));
 }
 else
  base = 0xFFFFFFFF;

 unsigned int offset_segment = saveValuePNTR(fileContent, readPointer, DWORD_L);
 fprintf(stdout, &quot;\n[DWORD]Section Alignement      :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, &quot;\n...beginning of text segment @  0x%08x&quot;, (base + offset_segment));

 fprintf(stdout, &quot;\n[DWORD]File Alignement         :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, &quot;\n[WORD] OS VERSION major        :0x%08x&quot;, getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, &quot;\n[WORD] OS VERSION minor        :0x%08x&quot;, getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, &quot;\n[WORD] image version major     :0x%08x&quot;, getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, &quot;\n[WORD] image version minor     :0x%08x&quot;, getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, &quot;\n[WORD] subsystem major version :0x%08x&quot;, getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, &quot;\n[WORD] subsystem minor version :0x%08x&quot;, getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, &quot;\n[DWORD] xxxXXX ZERO VAL XXXxxx :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, &quot;\n[DWORD] Imagesize in bytes     :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, &quot;\n[DWORD] Size of headers        :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, &quot;\n[DWORD] Checksum               :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));

 unsigned int subsystem = saveValuePNTR(fileContent, readPointer, WORD_L);
 fprintf(stdout, &quot;\n[WORD]  Subsystem version      :0x%08x&quot;, getValuePNTR(fileContent, readPointer, WORD_L));

 unsigned int dll_characteristic = saveValuePNTR(fileContent, readPointer, WORD_L);
 fprintf(stdout, &quot;\n[WORD]  DLL characteristics    :0x%08x&quot;, getValuePNTR(fileContent, readPointer, WORD_L));

 //the next 4 values depend on architecture
 if (type == 0x010b)
 {
  fprintf(stdout, &quot;\n[DWORD] SizeOfStackReserve     :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\n[DWORD] SizeOfStackCommit      :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\n[DWORD] SizeOfHeapReserve      :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\n[DWORD] SizeOfHeapCommit       :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
 }
 else if (type == 0x20b)
 {
  fprintf(stdout, &quot;\n[QWORD] SizeOfStackReserve     :0x%016x&quot;, getValuePNTR(fileContent, readPointer, QWORD_L));
  fprintf(stdout, &quot;\n[QWORD] SizeOfStackCommit      :0x%016x&quot;, getValuePNTR(fileContent, readPointer, QWORD_L));
  fprintf(stdout, &quot;\n[QWORD] SizeOfHeapReserve      :0x%016x&quot;, getValuePNTR(fileContent, readPointer, QWORD_L));
  fprintf(stdout, &quot;\n[QWORD] SizeOfHeapCommit       :0x%016x&quot;, getValuePNTR(fileContent, readPointer, QWORD_L));
 }
 fprintf(stdout, &quot;\n[DWORD] LoaderFlag (zeroVal)   :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));

 unsigned int remainder = saveValuePNTR(fileContent, readPointer, DWORD_L);
 fprintf(stdout, &quot;\n[DWORD] Remaining header count :0x%08x [Remaining data directories]&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, &quot;\nPointer now @ %x&quot;, readPointer);

 //next up are the data directories, there are usually 16 of them
 //each is 8 byte, so 16 * 8 = 128 &gt;&gt; size of directory entries

 if (remainder == 16)
 {
  fprintf(stdout, &quot;\n\n############################################################\nData Directory entries:&quot;);
  fprintf(stdout, &quot;\nExport Table           :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;      [Size]   :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nImport Table           :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;      [Size]   :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nResource Table         :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;      [Size]   :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nException Table        :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;      [Size]   :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nCertification Table    :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;      [Size]   :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nBase Relocation Table  :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;      [Size]   :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nDebug                  :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;      [Size]   :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nArchitecture           :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;      [Size]   :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nGlobal PTR             :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;      [Size]   :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nTLS Table              :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;      [Size]   :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nLoad Config Table      :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;      [Size]   :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nBound Import           :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;      [Size]   :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nIAT                    :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;      [Size]   :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nDelay Import Descriptor:0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;      [Size]   :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nCLR Runtime Header     :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;      [Size]   :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nReserved Zero Value    :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;      [Size]   :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nEnd Data Directories, PNTr now @  %x&quot;, readPointer);
 }
 else
 {
  fprintf(stdout, &quot;\n\nDetected non-standart data directories, recalculating Pointer ...&quot;);
  readPointer += (remainder) * 8;
  fprintf(stdout, &quot;\nEnd Data Directories, PNTr now @  %x&quot;, readPointer);
 }
 
 /*
  Following section headers
  Each section header is 40 byte large (5 DWORDS)
  You can calculate the beginning of the headers, 
  but we came here anyways so let&#39;s skip that part
 */
 fprintf(stdout, &quot;\n\n##########   BEGINNING OF SECTION HEADERS   ##########\n&quot;);
 for (int i = 0; i &lt; sectionCount; i++)
 {
  //first output the name in plain ascii, big-endian
  fprintf(stdout, &quot;\n\n###################    &quot;);
  output_data_ascii(fileContent, readPointer, readPointer + 8);
  fprintf(stdout, &quot;    ###################&quot;);

  readPointer += 8;
  fprintf(stdout, &quot;\nVirtual Size           :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nVirtual Address        :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nSize of Raw Data       :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nPointer to Raw Data    :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nPointer to Relocations :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nPointer to line numbers:0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, &quot;\nNumber of Relocations  :0x%08x&quot;, getValuePNTR(fileContent, readPointer, WORD_L));
  fprintf(stdout, &quot;\nNumber of line numbers :0x%08x&quot;, getValuePNTR(fileContent, readPointer, WORD_L));
  fprintf(stdout, &quot;\nCharacteristix         :0x%08x&quot;, getValuePNTR(fileContent, readPointer, DWORD_L));
 }

 //close handle, end of operations
 CloseHandle(targetBinary);
    std::cout &lt;&lt; &quot;\nEnd reached!\n&quot;;

 return 0;
}
```

Copy

Good thing is that I had the chance to fix last-minute bugs while writing this blogpost. Yay!

#### Conclusion

[![|320x312](upload://n9xB33fk1XB9dIHDqMv466w7t9M.png)](https://1.bp.blogspot.com/-hGeMa1IQYpE/XjAv6rBjb7I/AAAAAAAABNk/U4HLL4QKG04SURo14aL7SbfhjJKG4Dl4gCNcBGAsYHQ/s1600/Capture.PNG)I hope I could show you that it is really not  *that*  hard to read out a binary if you have a fundamental understanding of how operating systems work. Of course there are some major differences between Windows, Linux, Arm (like Raspbian, which basically is a Linux, but on a different processor) and other platforms, but in general they tend to be very similar to each other. For example, there is always a header, a separate code section and sections that are write-protected. And of course Microsoft needed to do their own thing, and although I prefer ELF files myself, there is not that much difference to PE files all in all. Here is a final picture of the program in action:

**Where to go from here?**
Well, I hope to write a code-injection tutorial in the future, so you can consider this the basics of this topic. We took a deep dive into the structure of PE files here, but we haven&#39;t even looked at actual processor instructions inside the code sections. Don&#39;t worry, tho, we&#39;ll get there eventually. For now, try to open different files with this code, and try to dump code sections with the help of the currently unused  **output_bytes**  function. In fact, try to expand this program to actually manipulate values in the target binary. If you manage to do this, you are a big step further at becoming a professional hacker. If you have questions, feel free to ask them to me, but don&#39;t expect me to know everything ^^

Some good sources to this topic, although for Linux, are Dennis Adriesses&#39; [Practical Binary Analysis](https://www.amazon.de/Practical-Binary-Analysis-Instrumentation-Disassembly/dp/1593279124/ref=sr_1_1?__mk_de_DE=%C3%85M%C3%85%C5%BD%C3%95%C3%91&amp;crid=19E3OACZKAKPL&amp;keywords=practical+binary+analysis&amp;qid=1580214941&amp;sprefix=practical+binary+%2Caps%2C161&amp;sr=8-1) and Ryan O&#39;Neil&#39;s [Learning Linux Binary Analysis](https://www.amazon.de/Learning-Linux-Binary-Analysis-English/dp/1782167102/ref=sr_1_3?__mk_de_DE=%C3%85M%C3%85%C5%BD%C3%95%C3%91&amp;keywords=learning+linux+binary+analysis&amp;qid=1580214990&amp;sr=8-3).

In fact, I came up with this whole code myself after reading Mr. Adriesses book, which is a major pro for this book, since it imparts knowledge that helps to come up with own solutions rather than just copypasting from the book. I really like this topic and will definately focus my research more on this, but one step after another, chummer...

That&#39;s it, I hope you liked this article! Thank you for reading it to the end.</description>
    
    <lastBuildDate>Wed, 27 May 2020 13:22:39 +0000</lastBuildDate>
    <category>Programming</category>
    <atom:link href="https://0x00sec.org/t/pe-file-reader-article-dump/21458.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>PE-File Reader [article - dump]</title>
        <dc:creator><![CDATA[system]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 121 days. New replies are no longer allowed.</p>
          <p><a href="https://0x00sec.org/t/pe-file-reader-article-dump/21458/4">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/pe-file-reader-article-dump/21458/4</link>
        <pubDate>Fri, 25 Sep 2020 11:04:02 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-21458-4</guid>
        <source url="https://0x00sec.org/t/pe-file-reader-article-dump/21458.rss">PE-File Reader [article - dump]</source>
      </item>
      <item>
        <title>PE-File Reader [article - dump]</title>
        <dc:creator><![CDATA[Danus]]></dc:creator>
        <description><![CDATA[
            <p>You should probably format and edit your articles before you post them here</p>
          <p><a href="https://0x00sec.org/t/pe-file-reader-article-dump/21458/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/pe-file-reader-article-dump/21458/3</link>
        <pubDate>Wed, 27 May 2020 13:22:39 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-21458-3</guid>
        <source url="https://0x00sec.org/t/pe-file-reader-article-dump/21458.rss">PE-File Reader [article - dump]</source>
      </item>
      <item>
        <title>PE-File Reader [article - dump]</title>
        <dc:creator><![CDATA[clockw0rk]]></dc:creator>
        <description><![CDATA[
            <p>This sure is a long article,<br>
and forgive me that I did not edit it to cut out links to my blog (from where this is copied, shameless self-bump here).<br>
I can dump more stuff I wrote here if you want</p>
          <p><a href="https://0x00sec.org/t/pe-file-reader-article-dump/21458/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/pe-file-reader-article-dump/21458/2</link>
        <pubDate>Tue, 26 May 2020 19:05:16 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-21458-2</guid>
        <source url="https://0x00sec.org/t/pe-file-reader-article-dump/21458.rss">PE-File Reader [article - dump]</source>
      </item>
      <item>
        <title>PE-File Reader [article - dump]</title>
        <dc:creator><![CDATA[clockw0rk]]></dc:creator>
        <description><![CDATA[
            <h2>Pe File Reader</h2>
<p><strong>[Opening .exe files to analyze the PE-header]</strong></p>
<p>Hello_Friend,<br>
and welcome to the 20s, Cybermonkeys!</p>
<p>Lets start this decade by learning some stuff.<br>
Last year, we already took an in-depth look at <a href="https://metabytezero.blogspot.com/2019/10/elf-file-structure.html" rel="noopener nofollow ugc">Linux-binaries (aka ELF files)</a>, now lets start messing around with its infamous Windows-Counterpart (that also happens to be the xBox file format).</p>
<h4>Introduction</h4>
<p>The PE-file format is around for quite some time now, and while heavy optimizations took place, it hasnt really changed all that much since then. In fact, it is one of the most widely encountered file formats out in the wilds. Although there is technically a difference between PE32 files (32bit) and PE32+ files (64bit), we will ignore this fact for the sake of this blogpost.<br>
Some file extensions deriving from this format are:</p>
<ul>
<li>.acm   [ a Windows audio-codec]</li>
<li>.ax    [MPEG-4 DVD format]</li>
<li>.cpl   [dynamic link libraries for control panels]</li>
<li>.dll   [dynamic link libraries]</li>
<li>.drv   [hardware drivers]</li>
<li>.efi   [extensible firmware interface]</li>
<li>.exe   [executable file]</li>
<li>.mui   [multilingual user interface]</li>
<li>.ocx   [activeX form extension]</li>
<li>.scr   [screensaver file format]</li>
<li>.sys   [system file]</li>
<li>.tsp   [truespeech audio format]</li>
</ul>
<p>There are other types as we will encounter, but this should give you an idea of how common this format(and its augmentations) is.</p>
<h4>Tools and resources</h4>
<p>Before we even start thinking about messing around with PE-files, it would help a lot to have some documentation and software to make our lives easier. Luckily for us, <a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#the-rsrc-section" rel="noopener nofollow ugc">Microsoft has released a structured documentation about the PE-file format.</a></p>
<p>Next, it would be nice to have a disassembler to look into the actual file (or at least a hex-viewer). One might ask why we bother to write our own program at all when there are already hundreds and hundreds of good disassemblers out there. The answer is: we are not going to write a disassembler here. We are writing a program to inspect the header file (fast) with the option to augment it so it can modify the behaviour of the executable and bend it to our will (not in this tutorial tho). Personally, <a href="https://redasm.io/" rel="noopener nofollow ugc">I found REDasm to be a nice and fast little program.</a></p>
<p><a href="https://1.bp.blogspot.com/-fPYP067UuX8/XhSknKNojoI/AAAAAAAABME/LUUxbi_4Gw8EZiMahQPNFG5zYQCF5XxvQCNcBGAsYHQ/s1600/redasm.png" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/original/2X/0/0cc7fde8c6116dc617f72b698fb4e8533726f60c.png" alt="" data-base62-sha1="1P4d1TN79kDD4jz9Lg4lXOQxNcE" width="320" height="227"></a>Although it can show you program flux and branches and whatnot, I only used it to view the file in hexadecimal format. Here is a picture of the PE-file header I inspected for testing purposes:</p>
<p>As you can see, I am not using much of the fancy functions that the disassembler has, although it is a good tool to start learning reverse-engineering, so kudos to the makers of this tool.<br>
[dark theme kind of sucks, but you have to decide for yourself]</p>
<p>Also its good to have some hello-world programs ready for testing purposes. Import and export stuff in these programs, respectively, and you will see differences in the binary structure of the files. Besides that we dont really need anything else, I used Visual Studio, but this is dependant on your personal preferences.</p>
<h4>Differences and similarities between PE and ELF</h4>
<p><a href="https://1.bp.blogspot.com/-mWlOnaZEEZ4/XhSyAQ8UT9I/AAAAAAAABMQ/iMLQuL1YK2sMl0m1djujzrxWjkUCLzr6QCNcBGAsYHQ/s1600/800px-Portable_Executable_32_bit_Structure_in_SVG_fixed.svg.png" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/original/2X/5/5376a952d28cdfbf90136cc3be6b70e37c62e13f.png" alt="" data-base62-sha1="bUlRnyA6Z9krIwOyFo3rDP5G5yf" width="226" height="320"></a>For readers of my previous article, this could be quite interesting.<br>
In fact, PE-files and ELF-files arent that much different from each other. But Microsoft has, again, chosen their own weird methods of implementing stuff as we will see. I took a shot from Wikipedia describing the basic structure of the PE-file, you can see it in the picture.</p>
<p>Now, the probably biggest difference is the  <strong>MS-DOS stub</strong>  at the beginning of the file.<br>
Yes, you read correctly: MS-DOS!<br>
Its still a thing, even in 2020. Microsoft has chosen this due to downward compatibility reasons. While I can not understand this choice at all, MS probably thought it would be good to have it. What it does is telling that This program cannot be run in DOS mode - no shit Sherlock! It is technically possible to specify another stub [with the linker option  <strong>/stub</strong> ], but why bother anyways? If anybody fires up an old 16-bit machine and tries to play Call of Duty on it, they must be crazy anyways.<br>
There is a historical importance to this stub, and yes, you could re-write your complete program to run in this 16bit stub, but if you do I will personally come to your home and spank your ass until you apologize.</p>
<p>Another interesting construct is the so called Rich-header right after the MS-DOS stub.<br>
<strong>It is essentially Microsoft spying on</strong>   <strong>you</strong>  for the purpose of defending against Malware authors.<br>
If you are interested in this topic or simply want to know how to get rid of the Rich-header,<br>
read <a href="http://bytepointer.com/articles/the_microsoft_rich_header.htm" rel="noopener nofollow ugc">this article</a> from bytepointer [good page, pretty old tho, recommend this one].<br>
It will show you how to patch your Linker to cut out the Rich-header.</p>
<p>So, the MS-DOS stub starts at 0x40, and including the Rich-header, it usually stretches up to 0x100 or 0x120, somewhere around there. So while we did not find anything in common with ELF-files, we already figured out that  <strong>each PE-file has an unnecessary overhead of around 100 bytes</strong> .<br>
Good job, Microsoft!</p>
<p>Okay, now lets see whether we can find anything that these two file formats DO have in common.<br>
At the beginning of each PE-file we can find the  <strong>PE-file header.</strong>  If you remember the article about ELF-files, this is something both formats share. It holds basic information about the number of sections, some pointers, stuff like that.<br>
It is essentially the MS counterpart of the ELF header, except it is incomplete.<br>
For whatever reasons, there is another " <strong>optional header</strong> " following the PE-file header. Now dont get confused here, beside the name there is nothing optional about this header. Only these two in conjunction form a complete PE-header. [ffs Microsoft, get your shit together]</p>
<p>Following up we can find the  <strong>data directories</strong> , essentially pointers to the sections at runtime. These are used mostly by the loader, to get to the section offsets really fast when loading up the binary for execution. They dont serve any other purpose.</p>
<p><a href="https://1.bp.blogspot.com/-IOeWTcIxZvA/XhSz70jrowI/AAAAAAAABMc/qX65JATTe9QhWGvcZA3mCvHEiuo8ku7kACNcBGAsYHQ/s1600/ripof.jpg" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/original/2X/9/98f3cf60dc5e34db329b5fc804fd834db6c3ac50.jpeg" alt="" data-base62-sha1="lP4W2FodCa9AycwXdv6ckoYbCSY" width="211" height="320"></a>After that we get right into the  <strong>sections</strong> , or rather, the what-would-be section header table (although MS doesnt call it like that). Each section contained in the program is listed here, with a pointer to the in-memory location of the section. We will get there eventually, but lets talk about sections a bit longer.<br>
For most parts, each section in a PE-file has an almost identical counterpart inside ELF-files, often even sharing the same name. Unlike ELF-files, the PE format does not really distinguish between sections and segments. There are simply sections, period.  <strong>There is no such thing like a program header table</strong> , which may be a curse or a bless, depending on your look at it. The section header table is used for linking and loading the binary, so the PE-files are somewhat more consistent at execution time.<br>
For some reason, compilers like the one in Visual Studio sometimes place read-only data inside the .text section instead of .rdata, mixing it up with executable code. Be cautious, for this can lead to problems during disassembly.</p>
<p>One of the most important sections,  <strong>.edata</strong>  and  <strong>.idata</strong> , have no equivalent in ELF-files. They contain exported and imported functions. The .idata section specifies which symbols to import from .DLLs, while the .edata section lists symbols and addresses that the binary exports. In practise, .idata and .edata are often merged withing the .rdata section, but besides that work exactly like I just described.<br>
Resolving of external dependencies works similar to ELF-files, Microsoft just uses a struct called " <strong>Import Address Table</strong> " (or IAT) instead of the ELFish Global Offset Table. Microsoft uses so called  <strong>Thunks</strong>  for external library calls, which happen to be jump gates of pointers, so basically there is no big difference between Windows-thunks and ELf-stubs.</p>
<p>Another thing to know is that Visual Studio emits int3 instructions to pad and align functions. This has no deeper meaning, you could as well use nop-operations, its just MSs style to do the same things and call it by different name. The int3 instructions normally serve as breakpoints for debuggers, but since they are placed in the void between actual code sections, this is not really of an issue.</p>
<h4>Implementing a File Reader [1] Opening and Reading a binary</h4>
<p>Now, lets start implementing our own PE dumper, <a href="https://metabytezero.blogspot.com/2019/08/writing-disassembler.html" rel="noopener nofollow ugc">similar to the one we wrote for ELF files</a>,<br>
but much simpler. Think of it more like a prototype for future projects. I will talk about this at the end of the blogpost. To get to work, we first need to consider some things:</p>
<ul>
<li>How will the binary be loaded</li>
<li>How are we going to orient our self over the file</li>
<li>How do we actually read values and output them</li>
<li>How do we confirm that the values are correct</li>
</ul>
<p>For each of these points, there are slippery slopes and shortcuts, and I had to reorganize the program several times due to false assumptions, so on the way through the code, let me explain how to overcome coding problems with skill rather than with speed.</p>
<p>Lets just look at the beginning of the main function first:</p>
<pre><code class="lang-auto">int _tmain(int argc, TCHAR *argv[])
{
 //file handles
 HANDLE targetBinary;
 LPDWORD readBytes = 0;
 DWORD fileSize;

 //the pointer that will serve as bookmark
 int readPointer = 0x0;

 //get system info to validate some byte values
 SYSTEM_INFO si;
 GetSystemInfo(&amp;si);

 fprintf(stdout, "The page size for this system is %u bytes.\n", si.dwPageSize);


 //handle to file needs to be called via CreateHandle
 targetBinary = CreateFile(L"C:/Program Files (x86)/Wizards of the Coast/MTGA/MTGA.exe", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
 fileSize = GetFileSize(targetBinary, NULL);

 fprintf(stdout, "File is %d Kbytes large\n", fileSize/1024);
 char *fileContent = new char[fileSize];

 
 if (targetBinary != INVALID_HANDLE_VALUE)
 {
  DWORD retVal = 0;
  //if function successfull, retVal is != 0
  if(!(retVal = ReadFile(targetBinary, (LPVOID)fileContent,fileSize, readBytes, NULL)))
  {
   fprintf(stdout, "There was an error reading input file!: %d returned.\n",retVal);
   exit (-1);
  }

  //fprintf(stdout, "Return value of ReadFile(5) is %d\n", retVal);
 }

   [ ... ]

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
</code></pre>
<p>Copy</p>
<p><strong>[  1  ] The _tmain function</strong><br>
The first line already looks weird, I admit ^^<br>
If you invoke int _tmain, you enable 16bit modes in C++ code. Well, thats the short version for this, at least.</p>
<p><strong>_tmain</strong>  is like a switch that automatically decides whether main or wmain should be called, a Microsoft extension.<br>
It enables Unicode (UTF-16) character sets and also swaps the bytes because of its endianess, thus resulting in the program seeing a bunch of 0 terminated strings rather than char arrays. If you want to know more, go to <a href="https://stackoverflow.com/questions/895827/what-is-the-difference-between-tmain-and-main-in-c" rel="noopener nofollow ugc">this Stackoverflow post</a>. We basically Increase the support for modern operation systems and their weird file names while also using it as a kind of safety measure for reading hex values. Ill talk about it in future posts, especially on Assembler.</p>
<p><strong>[  3-6  ] Handle to load the binary</strong><br>
Remember the first point on our list? Lets start with that. Im sure many of you will know how to read a file in C++, but let me introduce file Handles to you. A handle is basically a pointer to something. In this case, its to a file. This pointer helps us to read, write, copy or overwrite said file however we want. It is also useful if we want to modify the binary later. Lets not stick to this for too long,  <strong>its a higher level-pointer thats well documented</strong> . The  <strong>LPDWORD</strong>  and  <strong>DWORD</strong>  are both integers that well be using to read the binary into memory.</p>
<p><strong>[  9  ] The binary pointer</strong><br>
One part of the answer to  <strong>How are we going to orient our self over the file</strong>  lies within this variable. As the name tries to imply, it will save our current location while moving through the file, but currently its set to 0 so it just points to the very beginning.</p>
<p><strong>[  18-19  ] Open FileHandle</strong><br>
At 18-19 we are creating the actual HANDLE file object. The first argument  <strong>CreateFile</strong>  takes is a path to a file. We are providing an Unicode version [with the L prefix] of the string, so every language should be supported. Also, CreateFile is a nice function, it accepts both forward- and backward-slashes.  <em>Way to go, CreateFile!</em><br>
The next parameters are access rights and some attributes, and all I had to do is <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea" rel="noopener nofollow ugc">look into the documentation</a> and fiddle it out until it worked. Lets skip this trivial path</p>
<p>Its really up to you which binary you pick for testing, but it  <strong>really</strong>  is useful to test multiple files during development. You dont want to fall to false assumptions. I was halfway through development when I realized that not all values are at fixed locations. In fact, none of them really are. Alas, had I only tested multiple files first, I had saved at least 2 hours of rewriting and testing stuff.<br>
<em>Fool your assumptinons before getting fooled by your assumptions.</em></p>
<p><strong>[  26-37  ] Read the file into memory</strong><br>
We created a file, now it is time to read it. The <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfile" rel="noopener nofollow ugc">ReadFile function</a> isnt an easy function to work with. At first I should say that there are 2 versions of the function, a synchronous and an asynchronous one. The latter is required for reading streams, drivers and the like, stuff that changes a lot, and it is called  <strong>ReadFileEx</strong> . We will need a callback here, as youll notice.</p>
<h4>Implementing a File Reader [2] Functions and callback</h4>
<p>Its time to look at some functions that well be using to step over the file and output stuff. We are going to plan ahead here. Since we want to extend the program in the future, we will already implement a function to output a chunk of hex bytes with line numbering, just like a disassembler. Also, make sure you are really understanding whats going on, especially with the  <strong>OR-operation</strong> . Well get to this, lets first again look at the code and think about it after wards.</p>
<pre><code class="lang-auto">#include &lt;windows.h&gt;
#include &lt;tchar.h&gt;
#include &lt;iostream&gt;

#define QWORD_L 8
#define DWORD_L 4
#define BYTE_L 1
#define WORD_L 2

using namespace std;
//for use in callback
DWORD transfered = 0;

//actual callback for asynchronous reading
VOID CALLBACK finished
(
 __in  DWORD dwErrorCode,
 __in  DWORD dwNumberOfBytesTransfered,
 __in  LPOVERLAPPED lpOverlapped
)
{
 _tprintf(TEXT("Error code:\t%x\n"), dwErrorCode);
 _tprintf(TEXT("Number of bytes:\t%x\n"), dwNumberOfBytesTransfered);
 transfered = dwNumberOfBytesTransfered;
}

//later for oop (parameter called by reference)
void copy_bytes(char* &amp;dump,  char* &amp;memory, int start, int end)
{
 int counter = 0;

 while (start &lt; end)
 {
  memory[counter++] = dump[start++];
 }
 return;
}

//give single data fields or output values
//TO DO: write function so you can input start, dword (or whatever)
void output_data(char* memory, int start, int end)
{
 if (end &lt; start)
  return;
 fprintf(stdout, "0x");
 while (end &gt;= start)
 {
  fprintf(stdout, "%02hhX", memory[end]);
  end--;
 }
}

//same function, but grabbing text this time, so reversed output direction (big-endian)
void output_data_ascii(char* memory, int start, int end)
{
 if (end &lt; start)
  return;
 while (start &lt; end)
 {
  fprintf(stdout, "%c", memory[start]);
  start++;
 }
}

//because file shambles
int getValuePNTR(const char* memory, int &amp;start, int size)
{
 uint64_tretVal = 0;

 //now just add up array fields 
 for (int i = start + size-1,j = size-1; j &gt;= 0; --j, i--)
 {
  //fprintf(stdout, "\ncycle: %d, memory: [%x]", j, memory[i]);

  if ((unsigned char)memory[i] == 00 &amp;&amp; j &gt; 0)
   retVal &lt;&lt;= 8;
  else
   retVal |= ((unsigned char)(memory[i]) &lt;&lt; (8 * j));
 }
 //get the next field after this one
 start += size;
 return retVal;
}
//overwrite function
int saveValuePNTR(char* memory, int start, int size)
{
 uint64_tretVal = 0;
 for (int i = start + size - 1, j = size - 1; j &gt;= 0; --j, i--)
 {
  if ((unsigned char)memory[i] == 00 &amp;&amp; j &gt; 0)
   retVal &lt;&lt;= 8;
  else
   retVal |= ((unsigned char)(memory[i]) &lt;&lt; (8 * j));
 }
 return retVal;
}

//output stuff
void output_bytes(char* memory, int start, int end)
{
 //tracker for formatting the dump
 int counter = 1;
 int linebreaker = 0;

 int offset = start ? start % 0x10 : 0;

 //output the binary, use upper case X in format string for BIG LETTERS
 fprintf(stdout, "%010x: ", start - offset);

 for (int i = start - offset; i &lt; end; i++)
 {
  if (counter &gt; 3)
  {
   // print dots if we have an uneven countVal
   if (offset &gt; 0)
   {
    offset--;
    fprintf(stdout, ".. ");
    counter = 0;
   }
   else
   {
    fprintf(stdout, "%02hhX ", memory[i]);
    counter = 0;
   }
   linebreaker++;
  }
  else
  {
   // print dots if we have an uneven countVal
   if (offset &gt; 0)
   {
    offset--;
    fprintf(stdout, "..");
   }
   else //print the opcode
    fprintf(stdout, "%02hhX", memory[i]);
  }
  counter++;

  if (linebreaker &gt; 3)
  {
   fprintf(stdout, "\n");
   fprintf(stdout, "%#010x: ", i + 1);
   linebreaker = 0;
  }
 }
 cout &lt;&lt; endl &lt;&lt; endl;
}
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
</code></pre>
<p>Copy</p>
<p>It looks longer than it is, really. The hardest part is probably the last one. Right after the imports, I created some macros to represent byte lengths. Now, I know I could just type in the numbers, but it really is better to read, and also did I have problems with the standard ones so I made my own.</p>
<p><strong>[ 1-8 ] The callback for ReadFile</strong><br>
This callback works in conjunction with the ReadFile function we already looked at in the beginning of _tmain. I was just copying it from the Microsoft documentations, so youd be better off by just searching there. If you just want to understand it for now, it kind of copys chunks of data of fixed size, checking for EOF in between reads. The callback can be used to transmit errors and signals. It bounces a parameter referenced to as NumbersOfBytesTransfered over each cycle. Theres really not that much up with it. Also it doesnt stop on a NULL-byte because it thinks that its a string termination, which is kinda nice.</p>
<p><strong>[ 27-37 ] Copy between files</strong><br>
This function can be used to copy chunks of bytes between different files. Remember that we created a file with our file handle, we might want to automatically insert code chunks at special points in the code some time in the future. Consider this function a typical  <em>it will come in handy  <strong>LATER</strong></em> .</p>
<p><strong>[ 41-63 ] Output raw data</strong><br>
These two functions can be used to output data from the binary. You might notice the format string  <strong>%02hhx</strong> . It is a 2 digit hexadecimal format, and you should get used to this kind of format strings.</p>
<ul>
<li>
<strong>0</strong>
<ul>
<li>fill the number with zeros to align the digits (f.e. write 0001 instead of 1)</li>
</ul>
</li>
<li>
<strong>2</strong>
<ul>
<li>the length of the number</li>
</ul>
</li>
<li>
<strong>hh</strong>
<ul>
<li>if followed by a x, this will make the input an unsigned char</li>
</ul>
</li>
<li>
<strong>x</strong>
<ul>
<li>output as hexadecimal number as specified</li>
</ul>
</li>
</ul>
<p>The third part is crucial. When working with hexadecimal output we are  <strong>always required to work with unsigned chars</strong> , as I had to learn the hard way. If you dont state that you are expecting the values to be unsigned, your output will be totally random, since the first bit in each variable is usually interpreted as the sign. If you get strange readings during testing, check for the signing of especially chars.</p>
<p>Youll notice that for the second function, I broke my own premise of always using unsigned chars. Yikes! The reason for this is simple: we arent using any hex values here. When dealing with binaries, youll often encounter data saved in plain text form. Usually strings, but sometimes information for the loader, too. These strings are stored in  <strong>big-endian</strong> , which means they are forward written in the file (like in, how a human would read them).</p>
<p>Thats great, they made this so we have an easy life reading the strings, right?! NAHAA, its only because they get read in reverse order into memory later anyway. Dont assume anybody would help you fiddling around with their stuff! [JK lol]</p>
<p><strong>[ 66-98 ] Oh, to read a DWORD</strong><br>
These next functions are really our bread and butter. We are going to call them very often, indeed. And it is them that feature the OR-operation that took me almost 2 weeks. It failed constantly, and I had no idea why.<br>
Both functions start identically: They take a chunk of data as first argument, a pointer into that chunk as second one, and a to-read size as third parameter. One difference you might notice is that the first functions takes the start parameter as a call-by-reference so we can increment it while we are at it. This way you can read values and at the same time increment the file pointer, which saves us some memory.</p>
<p>Both functions first define a  <strong>uint64_t</strong> . Normally I had used DWORD or QWORD here, but recently I found out my program would crash when reading 64bit code, so we are using the 8 byte long variable here all along.<br>
I was going to write how awesome DWORD is because its managed by operation system instead of language, but uint64_t should be 8 byte long always, too, so we wont get any problems in the future, except maybe someone invents 128bit processors, but this is actually pretty unlikely (in 2020, lul).</p>
<p>Following along, we check whether we read a zero-byte, and if so, we just shift the return variable one byte to the left. This is necessary because we might read a zero as last input, and instead of just adding 00 as the count for position 0, we would shift the first byte out of scope. You can try this out and see it yourself if you want, or you can just trust me on this one.</p>
<p>After we found the byte, we have to shift it to the left a number of times equal to the relative position inside the byte-mask. For example, if we have the value 1 at the third position of the value, we have to shift it to the left three times. This is a bit of a brainfuck at first, especially since values are usually stored little-endian style, but youll get used to it pretty fast. After the value was shifted, we (logical) OR it against the return variable. This way we insert the correct value byte by byte.</p>
<p>The biggest difference between these two functions is probably that the first one increments the filepointer after reading the value, so we can just read the next, and the next and so forth. The latter doesnt do so, since we want to save the value from the binary AND call the first function after wards to output it, so this is just ease-of-use here.</p>
<p><strong>[ 99 ] Future use as decompiler</strong><br>
This whole function is designed to nicely print out a (big) chunk of data in a form that you would expect from a typical hex-editor. In the whole example program Im currently not using it for anything, but I tested and fine-tuned it, so feel free to give it a try. It will print out line numbers as well as a little gap between DWORDS, so you can examine the binary. Although I am not really using it (or explaining), it is extremely useful to have for future examinations of binaries, so just keep it there, and maybe play around with it a little.</p>
<h4>Implementing a File Reader [3] The main work</h4>
<p>After the setup of all our functions and the loading of the binary into memory, it is time to actually get some data out of it. But first we have to solve a riddle in the file:<br>
<strong>Where the fuck does it start anyways?</strong></p>
<p>The answer to this question is:  <em>it depends</em><br>
Ah, great, another of these undecided binaries, you might think.<br>
Get your shit together, man!</p>
<p>In fact the first value we need to extract from the binary is the most crucial for us at this point: The value at  <strong>0x3c</strong> . This magic number is an address at which we can find the PE-signature, and after that the real information is hidden. In its original form my program featured a function that just hard-reads this value, but since we have all our nice functions at the top, we are going to use them right away. Lets take a look:</p>
<pre><code class="lang-auto">//first, get that 0x3c word so we know where to start reading
 readPointer = saveValuePNTR(fileContent, 0x3c, WORD_L);
 fprintf(stdout, "\nINITIALISING....\nReadpointer before operation: %x",readPointer);
 fprintf(stdout, "\n[DWORD]  PE-SIGNATURE           :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\nReadpointer after operation: %x\nInitialising finished", readPointer);

 //first block: PE FILE HEADER
 fprintf(stdout, "\n\nCollect Information (PE file header):");
 fprintf(stdout, "\n[WORD]  Mashinae Type          :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 unsigned int sectionCount = saveValuePNTR(fileContent, readPointer, WORD_L);            
 fprintf(stdout, "\n[WORD]  Number of Sections     :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, "\n[DWORD] Timestamp              :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[DWORD] Pointer to symbol table:0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[DWORD] Number of Symbols      :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[WORD]  Size of optional header:0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, "\n[WORD]  Characteristics        :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 
 
</code></pre>
<p>Copy</p>
<p>Right at the start, we first grab the information about the PE-Signature, as I said it is located at 0x3c, and it is 2 byte long, hence the WORD_L. After that, I wrote a little initialization output just to be sure everything works as expected. Notable are the use of the  <strong>fprintf function.</strong>  By using this, we can later swap out the stdout with a file pointer, so we can easily create log files about our readings.<br>
I decided to use the format string  <strong>0x%08x</strong>  to give the output a fixed length of 8 digits. This will have to be tweaked for QWORDS later on.</p>
<p>The first block we are going to read is the PE file header. You can see in  <strong>line 10</strong>  how we are able to save some information that will come in handy later with the help of the  <strong>saveValuePNTR</strong>  function. The rest is just outputting information for now. This is pretty much how the rest of the code looks, with some exeptions for 64bit systems, as you can see below:</p>
<pre><code class="lang-auto">//second block: OPTIONAL HEADER
 fprintf(stdout, "\n\nOPTIONAL HEADER [general fields]:");
 unsigned int type = saveValuePNTR(fileContent, readPointer, WORD_L);              
 fprintf(stdout, "\n[WORD] Architecture            :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 if (type == 0x010b)
  fprintf(stdout, "  -&gt;  [32 bit]");
 else if (type == 0x20b)
  fprintf(stdout, "  -&gt;  [64 bit]");
 else if (type == 0x107)
  fprintf(stdout, "  -&gt;  [ROM img]");
 else
  fprintf(stdout, "  -&gt;  [unknown]");

 fprintf(stdout, "\n[BYTE] Major Linker Version    :0x%08x", getValuePNTR(fileContent, readPointer, BYTE_L));
 fprintf(stdout, "\n[BYTE] Minor Linker Version    :0x%08x", getValuePNTR(fileContent, readPointer, BYTE_L));
 fprintf(stdout, "\n[DWORD]Size of Code            :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[DWORD]SizeofInitialisedData   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[DWORD]SizeifUninialisedData   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[DWORD]Adress of Entrypoint    :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[DWORD]CodeBase                :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));

 //next field depending on arch (only present in 32bit executables)
 if (type == 0x010b)
  fprintf(stdout, "\n[DWORD]Base of Data            :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));


 fprintf(stdout, "\n\nOPTIONAL HEADER [windows only fields]:");
 fprintf(stdout, "\n[DWORD / QWORD]ImageBase       :");

 unsigned int base;
 //next field depending on arch, 4 byte in 32bit, 8 byte in 64bit
 if (type == 0x010b)
 {
  base = saveValuePNTR(fileContent, readPointer, DWORD_L);
  fprintf(stdout, "0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  //fprintf(stdout, "\nDEBUG:     0x%08x , pointer @ %x     \n", base,readPointer);
 }
 else if (type == 0x020b)
 {
  base = saveValuePNTR(fileContent, readPointer, QWORD_L);
  fprintf(stdout, "0x%016x", getValuePNTR(fileContent, readPointer, QWORD_L));
 }
 else
  base = 0xFFFFFFFF;

 unsigned int offset_segment = saveValuePNTR(fileContent, readPointer, DWORD_L);
 fprintf(stdout, "\n[DWORD]Section Alignement      :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n...beginning of text segment @  0x%08x", (base + offset_segment));

 fprintf(stdout, "\n[DWORD]File Alignement         :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[WORD] OS VERSION major        :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, "\n[WORD] OS VERSION minor        :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, "\n[WORD] image version major     :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, "\n[WORD] image version minor     :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, "\n[WORD] subsystem major version :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, "\n[WORD] subsystem minor version :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, "\n[DWORD] xxxXXX ZERO VAL XXXxxx :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[DWORD] Imagesize in bytes     :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[DWORD] Size of headers        :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[DWORD] Checksum               :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));

 unsigned int subsystem = saveValuePNTR(fileContent, readPointer, WORD_L);
 fprintf(stdout, "\n[WORD]  Subsystem version      :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));

 unsigned int dll_characteristic = saveValuePNTR(fileContent, readPointer, WORD_L);
 fprintf(stdout, "\n[WORD]  DLL characteristics    :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));

 //the next 4 values depend on architecture
 if (type == 0x010b)
 {
  fprintf(stdout, "\n[DWORD] SizeOfStackReserve     :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\n[DWORD] SizeOfStackCommit      :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\n[DWORD] SizeOfHeapReserve      :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\n[DWORD] SizeOfHeapCommit       :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 }
 else if (type == 0x20b)
 {
  fprintf(stdout, "\n[QWORD] SizeOfStackReserve     :0x%016x", getValuePNTR(fileContent, readPointer, QWORD_L));
  fprintf(stdout, "\n[QWORD] SizeOfStackCommit      :0x%016x", getValuePNTR(fileContent, readPointer, QWORD_L));
  fprintf(stdout, "\n[QWORD] SizeOfHeapReserve      :0x%016x", getValuePNTR(fileContent, readPointer, QWORD_L));
  fprintf(stdout, "\n[QWORD] SizeOfHeapCommit       :0x%016x", getValuePNTR(fileContent, readPointer, QWORD_L));
 }
 
 
 
 
 
 
 
 
 
</code></pre>
<p>Copy</p>
<p>We are going to read the rest of the header and optional header. At some points, like in lines 5-12, it is necessary to differentiate between x86 and x86-64 systems. We can make this differentiation with the help of the value we read in line 3. This is one of the more crucial information we have to gather, as it is used further below again. Also, note that we have to expand the format string to  <strong>0x%016x</strong>  if we are to output 64bit information.<br>
Since a single byte needs 2 digits to be displayed ( from range 00 to ff ), we have to expand the format string in these cases. Luckily, there are only minor differences between 32bit and 64bit binaries. I suggest you read into the <a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#dll-characteristics" rel="noopener nofollow ugc">Microsoft Documentation</a>, as I stated earlier.</p>
<p>In the documentation, you can see the length of the fields in each architecture, so we just have to insert some switches there and use our existing functions to expand to a QWORD_L there. Some values are of mere WORD length, and some are even single BYTE.</p>
<p>Coming up next are the  <strong>Data Directories</strong> . These are essentially pointers into sections, and they are primarily for the linker, so that he has some shortcuts when setting up the process into memory. You CAN, however, use them to find important sections like the Import Table (which is one of the most important ones), so when augmenting a program, these pointers will be useful to your augmentor program.</p>
<pre><code class="lang-auto">unsigned int remainder = saveValuePNTR(fileContent, readPointer, DWORD_L);
 fprintf(stdout, "\n[DWORD] Remaining header count :0x%08x [Remaining data directories]", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\nPointer now @ %x", readPointer);

 //next up are the data directories, there are usually 16 of them
 //each is 8 byte, so 16 * 8 = 128 &gt;&gt; size of directory entries

 if (remainder == 16)
 {
  fprintf(stdout, "\n\n############################################################\nData Directory entries:");
  fprintf(stdout, "\nExport Table           :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nImport Table           :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nResource Table         :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nException Table        :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nCertification Table    :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nBase Relocation Table  :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nDebug                  :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nArchitecture           :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nGlobal PTR             :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nTLS Table              :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nLoad Config Table      :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nBound Import           :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nIAT                    :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nDelay Import Descriptor:0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nCLR Runtime Header     :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nReserved Zero Value    :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nEnd Data Directories, PNTr now @  %x", readPointer);
 }
 else
 {
  fprintf(stdout, "\n\nDetected non-standart data directories, recalculating Pointer ...");
  readPointer += (remainder) * 8;
  fprintf(stdout, "\nEnd Data Directories, PNTr now @  %x", readPointer);
 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
</code></pre>
<p>Copy</p>
<p>At first, we save the remainder of data directories. Now, dont get confused here, a PE file usually has 16 data directories.  <strong>ALWAYS</strong> . But when, for example, the remainder counts 10, it means that some directories are empty. For example, a binary may not export anything, or does not have a Debug section. If, for whatever reason, the binary has more or less than 16 data directories, we skip the output (for now), and recalculate the beginning of the section headers.</p>
<p><strong>The else part is wrong at the moment!</strong><br>
As I just described, the remainder is  <strong>not</strong>  the actual number of data directories, but I will just leave it as it is for now, it should not be too hard to recalculate if you ever have the need for it.</p>
<p>There is only one part left:  <strong>The actual section headers</strong> , so lets dive right in:</p>
<pre><code class="lang-auto">/*
  Following section headers
  Each section header is 40 byte large (5 DWORDS)
  You can calculate the beginning of the headers, 
  but we came here anyways so let's skip that part
 */
 fprintf(stdout, "\n\n##########   BEGINNING OF SECTION HEADERS   ##########\n");
 for (int i = 0; i &lt; sectionCount; i++)
 {
  //first output the name in plain ascii, big-endian
  fprintf(stdout, "\n\n###################    ");
  output_data_ascii(fileContent, readPointer, readPointer + 8);
  fprintf(stdout, "    ###################");

  readPointer += 8;
  fprintf(stdout, "\nVirtual Size           :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nVirtual Address        :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nSize of Raw Data       :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nPointer to Raw Data    :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nPointer to Relocations :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nPointer to line numbers:0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nNumber of Relocations  :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
  fprintf(stdout, "\nNumber of line numbers :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
  fprintf(stdout, "\nCharacteristix         :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 }

 //close handle, end of operations
 CloseHandle(targetBinary);
        std::cout &lt;&lt; "\nEnd reached!\n";

 return 0;
}

</code></pre>
<p>Copy</p>
<p>This is the last part of our program so far, and it will grab the section headers from the binary.<br>
Each section header has a fixed size and the same values associated with it, so we can just use a loop to grab all of them. Since the name of each section is stored in big-endian, aka human-readable way, we have to call our output_data_ascii function here. There isnt really any magic in here, nothing you didnt already encounter. Note that we manually have to increment the readPointer variable in each loop, since the output_data_ascii function doesnt do this for us. The amount of section headers is already stored in the variable  <strong>sectionCount</strong> , so we always have the right amounts of loops ready.</p>
<p>At the end we need to close the handle to prevent memory leakage and overflowing.</p>
<h4>Full code</h4>
<p>Here I want to paste the full code in a single file so its easier to just copypasta it if you want to try it out yourself:</p>
<pre><code class="lang-auto">#include &lt;windows.h=""&gt;
#include &lt;tchar.h=""&gt;
#include &lt;iostream&gt;

#define QWORD_L 8
#define DWORD_L 4
#define BYTE_L 1
#define WORD_L 2

using namespace std;
//for use in callback
DWORD transfered = 0;

//actual callback for asynchronous reading
VOID CALLBACK finished
(
 __in  DWORD dwErrorCode,
 __in  DWORD dwNumberOfBytesTransfered,
 __in  LPOVERLAPPED lpOverlapped
)
{
 _tprintf(TEXT("Error code:\t%x\n"), dwErrorCode);
 _tprintf(TEXT("Number of bytes:\t%x\n"), dwNumberOfBytesTransfered);
 transfered = dwNumberOfBytesTransfered;
}

//later for oop (parameter called by reference)
void copy_bytes(char* &amp;dump,  char* &amp;memory, int start, int end)
{
 int counter = 0;

 while (start &lt; end)
 {
  memory[counter++] = dump[start++];
 }
 return;
}

//give single data fields or output values
//TO DO: write function so you can input start, dword (or whatever)
void output_data(char* memory, int start, int end)
{
 if (end &lt; start)
  return;
 fprintf(stdout, "0x");
 while (end &gt;= start)
 {
  fprintf(stdout, "%02hhX", memory[end]);
  end--;
 }
}

//same function, but grabbing text this time, so reversed output direction (big-endian)
void output_data_ascii(char* memory, int start, int end)
{
 if (end &lt; start)
  return;
 while (start &lt; end)
 {
  fprintf(stdout, "%c", memory[start]);
  start++;
 }
}

//because file shambles
int getValuePNTR(const char* memory, int &amp;start, int size)
{
 uint64_t retVal = 0;

 //now just add up array fields 
 for (int i = start + size-1,j = size-1; j &gt;= 0; --j, i--)
 {
  //fprintf(stdout, "\ncycle: %d, memory: [%x]", j, memory[i]);

  if ((unsigned char)memory[i] == 00 &amp;&amp; j &gt; 0)
   retVal &lt;&lt;= 8;
  else
   retVal |= ((unsigned char)(memory[i]) &lt;&lt; (8 * j));
 }
 //get the next field after this one
 start += size;
 return retVal;
}
//overwrite function
int saveValuePNTR(char* memory, int start, int size)
{
 uint64_t retVal = 0;
 for (int i = start + size - 1, j = size - 1; j &gt;= 0; --j, i--)
 {
  if ((unsigned char)memory[i] == 00 &amp;&amp; j &gt; 0)
   retVal &lt;&lt;= 8;
  else
   retVal |= ((unsigned char)(memory[i]) &lt;&lt; (8 * j));
 }
 return retVal;
}

//output stuff
void output_bytes(char* memory, int start, int end)
{
 //tracker for formatting the dump
 int counter = 1;
 int linebreaker = 0;

 int offset = start ? start % 0x10 : 0;

 //output the binary, use upper case X in format string for BIG LETTERS
 fprintf(stdout, "%010x: ", start - offset);

 for (int i = start - offset; i &lt; end; i++)
 {

  if (counter &gt; 3)
  {
   // print dots if we have an uneven countVal
   if (offset &gt; 0)
   {
    offset--;
    fprintf(stdout, ".. ");
    counter = 0;
   }
   else
   {
    fprintf(stdout, "%02hhX ", memory[i]);
    counter = 0;
   }
   linebreaker++;
  }
  else
  {
   // print dots if we have an uneven countVal
   if (offset &gt; 0)
   {
    offset--;
    fprintf(stdout, "..");
   }
   else //print the opcode
    fprintf(stdout, "%02hhX", memory[i]);
  }
  counter++;

  if (linebreaker &gt; 3)
  {
   fprintf(stdout, "\n");
   fprintf(stdout, "%#010x: ", i + 1);
   linebreaker = 0;
  }

 }
 cout &lt;&lt; endl &lt;&lt; endl;
}

int _tmain(int argc, TCHAR *argv[])
{
 //file handles
 HANDLE targetBinary;
 LPDWORD readBytes = 0;
 DWORD fileSize;

 //the pointer that will serve as bookmark
 int readPointer = 0x0;

 //get system info to validate some byte values
 SYSTEM_INFO si;
 GetSystemInfo(&amp;si);

 fprintf(stdout, "The page size for this system is %u bytes.\n", si.dwPageSize);


 //handle to file needs to be called via CreateHandle
 targetBinary = CreateFile(L"C:/Program Files (x86)/Wizards of the Coast/MTGA/MTGA.exe", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
 fileSize = GetFileSize(targetBinary, NULL);

 fprintf(stdout, "File is %d Kbytes large\n", fileSize/1024);
 char *fileContent = new char[fileSize];

 
 if (targetBinary != INVALID_HANDLE_VALUE)
 {
  DWORD retVal = 0;
  //if function successfull, retVal is != 0
  if(!(retVal = ReadFile(targetBinary, (LPVOID)fileContent,fileSize, readBytes, NULL)))
  {
   fprintf(stdout, "There was an error reading input file!: %d returned.\n",retVal);
   exit (-1);
  }

  //fprintf(stdout, "Return value of ReadFile(5) is %d\n", retVal);
 }

 //first, get that 0x3c word so we know where to start reading
 readPointer = saveValuePNTR(fileContent, 0x3c, WORD_L);
 fprintf(stdout, "\nINITIALISING....\nReadpointer before operation: %x",readPointer);
 fprintf(stdout, "\n[DWORD]  PE-SIGNATURE           :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\nReadpointer after operation: %x\nInitialising finished", readPointer);

 //first block: PE FILE HEADER
 fprintf(stdout, "\n\nCollect Information (PE file header):");
 fprintf(stdout, "\n[WORD]  Mashinae Type          :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 unsigned int sectionCount = saveValuePNTR(fileContent, readPointer, WORD_L);            
 fprintf(stdout, "\n[WORD]  Number of Sections     :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, "\n[DWORD] Timestamp              :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[DWORD] Pointer to symbol table:0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[DWORD] Number of Symbols      :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[WORD]  Size of optional header:0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, "\n[WORD]  Characteristics        :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));

 //second block: OPTIONAL HEADER
 fprintf(stdout, "\n\nOPTIONAL HEADER [general fields]:");
 unsigned int type = saveValuePNTR(fileContent, readPointer, WORD_L);              
 fprintf(stdout, "\n[WORD] Architecture            :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 if (type == 0x010b)
  fprintf(stdout, "  -&gt;  [32 bit]");
 else if (type == 0x20b)
  fprintf(stdout, "  -&gt;  [64 bit]");
 else if (type == 0x107)
  fprintf(stdout, "  -&gt;  [ROM img]");
 else
  fprintf(stdout, "  -&gt;  [unknown]");

 fprintf(stdout, "\n[BYTE] Major Linker Version    :0x%08x", getValuePNTR(fileContent, readPointer, BYTE_L));
 fprintf(stdout, "\n[BYTE] Minor Linker Version    :0x%08x", getValuePNTR(fileContent, readPointer, BYTE_L));
 fprintf(stdout, "\n[DWORD]Size of Code            :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[DWORD]SizeofInitialisedData   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[DWORD]SizeifUninialisedData   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[DWORD]Adress of Entrypoint    :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[DWORD]CodeBase                :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));

 //next field depending on arch (only present in 32bit executables)
 if (type == 0x010b)
  fprintf(stdout, "\n[DWORD]Base of Data            :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));


 fprintf(stdout, "\n\nOPTIONAL HEADER [windows only fields]:");
 fprintf(stdout, "\n[DWORD / QWORD]ImageBase       :");

 unsigned int base;
 //next field depending on arch, 4 byte in 32bit, 8 byte in 64bit
 if (type == 0x010b)
 {
  base = saveValuePNTR(fileContent, readPointer, DWORD_L);
  fprintf(stdout, "0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  //fprintf(stdout, "\nDEBUG:     0x%08x , pointer @ %x     \n", base,readPointer);
 }
 else if (type == 0x020b)
 {
  base = saveValuePNTR(fileContent, readPointer, QWORD_L);
  fprintf(stdout, "0x%016x", getValuePNTR(fileContent, readPointer, QWORD_L));
 }
 else
  base = 0xFFFFFFFF;

 unsigned int offset_segment = saveValuePNTR(fileContent, readPointer, DWORD_L);
 fprintf(stdout, "\n[DWORD]Section Alignement      :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n...beginning of text segment @  0x%08x", (base + offset_segment));

 fprintf(stdout, "\n[DWORD]File Alignement         :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[WORD] OS VERSION major        :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, "\n[WORD] OS VERSION minor        :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, "\n[WORD] image version major     :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, "\n[WORD] image version minor     :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, "\n[WORD] subsystem major version :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, "\n[WORD] subsystem minor version :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, "\n[DWORD] xxxXXX ZERO VAL XXXxxx :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[DWORD] Imagesize in bytes     :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[DWORD] Size of headers        :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[DWORD] Checksum               :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));

 unsigned int subsystem = saveValuePNTR(fileContent, readPointer, WORD_L);
 fprintf(stdout, "\n[WORD]  Subsystem version      :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));

 unsigned int dll_characteristic = saveValuePNTR(fileContent, readPointer, WORD_L);
 fprintf(stdout, "\n[WORD]  DLL characteristics    :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));

 //the next 4 values depend on architecture
 if (type == 0x010b)
 {
  fprintf(stdout, "\n[DWORD] SizeOfStackReserve     :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\n[DWORD] SizeOfStackCommit      :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\n[DWORD] SizeOfHeapReserve      :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\n[DWORD] SizeOfHeapCommit       :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 }
 else if (type == 0x20b)
 {
  fprintf(stdout, "\n[QWORD] SizeOfStackReserve     :0x%016x", getValuePNTR(fileContent, readPointer, QWORD_L));
  fprintf(stdout, "\n[QWORD] SizeOfStackCommit      :0x%016x", getValuePNTR(fileContent, readPointer, QWORD_L));
  fprintf(stdout, "\n[QWORD] SizeOfHeapReserve      :0x%016x", getValuePNTR(fileContent, readPointer, QWORD_L));
  fprintf(stdout, "\n[QWORD] SizeOfHeapCommit       :0x%016x", getValuePNTR(fileContent, readPointer, QWORD_L));
 }
 fprintf(stdout, "\n[DWORD] LoaderFlag (zeroVal)   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));

 unsigned int remainder = saveValuePNTR(fileContent, readPointer, DWORD_L);
 fprintf(stdout, "\n[DWORD] Remaining header count :0x%08x [Remaining data directories]", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\nPointer now @ %x", readPointer);

 //next up are the data directories, there are usually 16 of them
 //each is 8 byte, so 16 * 8 = 128 &gt;&gt; size of directory entries

 if (remainder == 16)
 {
  fprintf(stdout, "\n\n############################################################\nData Directory entries:");
  fprintf(stdout, "\nExport Table           :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nImport Table           :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nResource Table         :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nException Table        :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nCertification Table    :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nBase Relocation Table  :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nDebug                  :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nArchitecture           :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nGlobal PTR             :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nTLS Table              :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nLoad Config Table      :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nBound Import           :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nIAT                    :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nDelay Import Descriptor:0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nCLR Runtime Header     :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nReserved Zero Value    :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nEnd Data Directories, PNTr now @  %x", readPointer);
 }
 else
 {
  fprintf(stdout, "\n\nDetected non-standart data directories, recalculating Pointer ...");
  readPointer += (remainder) * 8;
  fprintf(stdout, "\nEnd Data Directories, PNTr now @  %x", readPointer);
 }
 
 /*
  Following section headers
  Each section header is 40 byte large (5 DWORDS)
  You can calculate the beginning of the headers, 
  but we came here anyways so let's skip that part
 */
 fprintf(stdout, "\n\n##########   BEGINNING OF SECTION HEADERS   ##########\n");
 for (int i = 0; i &lt; sectionCount; i++)
 {
  //first output the name in plain ascii, big-endian
  fprintf(stdout, "\n\n###################    ");
  output_data_ascii(fileContent, readPointer, readPointer + 8);
  fprintf(stdout, "    ###################");

  readPointer += 8;
  fprintf(stdout, "\nVirtual Size           :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nVirtual Address        :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nSize of Raw Data       :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nPointer to Raw Data    :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nPointer to Relocations :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nPointer to line numbers:0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nNumber of Relocations  :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
  fprintf(stdout, "\nNumber of line numbers :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
  fprintf(stdout, "\nCharacteristix         :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 }

 //close handle, end of operations
 CloseHandle(targetBinary);
    std::cout &lt;&lt; "\nEnd reached!\n";

 return 0;
}
</code></pre>
<p>Copy</p>
<p>Good thing is that I had the chance to fix last-minute bugs while writing this blogpost. Yay!</p>
<h4>Conclusion</h4>
<p><a href="https://1.bp.blogspot.com/-hGeMa1IQYpE/XjAv6rBjb7I/AAAAAAAABNk/U4HLL4QKG04SURo14aL7SbfhjJKG4Dl4gCNcBGAsYHQ/s1600/Capture.PNG" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/original/2X/a/a24620a028f2bb8c14616c3316afc7e2e46d225a.png" alt="" data-base62-sha1="n9xB33fk1XB9dIHDqMv466w7t9M" width="320" height="312"></a>I hope I could show you that it is really not  <em>that</em>  hard to read out a binary if you have a fundamental understanding of how operating systems work. Of course there are some major differences between Windows, Linux, Arm (like Raspbian, which basically is a Linux, but on a different processor) and other platforms, but in general they tend to be very similar to each other. For example, there is always a header, a separate code section and sections that are write-protected. And of course Microsoft needed to do their own thing, and although I prefer ELF files myself, there is not that much difference to PE files all in all. Here is a final picture of the program in action:</p>
<p><strong>Where to go from here?</strong><br>
Well, I hope to write a code-injection tutorial in the future, so you can consider this the basics of this topic. We took a deep dive into the structure of PE files here, but we havent even looked at actual processor instructions inside the code sections. Dont worry, tho, well get there eventually. For now, try to open different files with this code, and try to dump code sections with the help of the currently unused  <strong>output_bytes</strong>  function. In fact, try to expand this program to actually manipulate values in the target binary. If you manage to do this, you are a big step further at becoming a professional hacker. If you have questions, feel free to ask them to me, but dont expect me to know everything ^^</p>
<p>Some good sources to this topic, although for Linux, are Dennis Adriesses <a href="https://www.amazon.de/Practical-Binary-Analysis-Instrumentation-Disassembly/dp/1593279124/ref=sr_1_1?__mk_de_DE=%C3%85M%C3%85%C5%BD%C3%95%C3%91&amp;crid=19E3OACZKAKPL&amp;keywords=practical+binary+analysis&amp;qid=1580214941&amp;sprefix=practical+binary+%2Caps%2C161&amp;sr=8-1" rel="noopener nofollow ugc">Practical Binary Analysis</a> and Ryan ONeils <a href="https://www.amazon.de/Learning-Linux-Binary-Analysis-English/dp/1782167102/ref=sr_1_3?__mk_de_DE=%C3%85M%C3%85%C5%BD%C3%95%C3%91&amp;keywords=learning+linux+binary+analysis&amp;qid=1580214990&amp;sr=8-3" rel="noopener nofollow ugc">Learning Linux Binary Analysis</a>.</p>
<p>In fact, I came up with this whole code myself after reading Mr. Adriesses book, which is a major pro for this book, since it imparts knowledge that helps to come up with own solutions rather than just copypasting from the book. I really like this topic and will definately focus my research more on this, but one step after another, chummer</p>
<p>Thats it, I hope you liked this article! Thank you for reading it to the end.</p>
          <p><a href="https://0x00sec.org/t/pe-file-reader-article-dump/21458/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/pe-file-reader-article-dump/21458/1</link>
        <pubDate>Tue, 26 May 2020 19:03:56 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-21458-1</guid>
        <source url="https://0x00sec.org/t/pe-file-reader-article-dump/21458.rss">PE-File Reader [article - dump]</source>
      </item>
  </channel>
</rss>
