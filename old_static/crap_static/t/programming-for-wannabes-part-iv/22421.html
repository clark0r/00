<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Programming for Wannabes. Part IV - Programming - 0x00sec - The Home of the Hacker</title>
<meta name="description" content="Some people have asked me to continue this seriesâ€¦ and actually this paper was half written almost two years agoâ€¦ so I decided to finish himâ€¦ you know, the Mortal Kombat wayâ€¦ Not sure if I will write Part Vâ€¦ but Part IV &amp;hellip;">
<meta name="generator" content="Discourse 3.1.0.beta6 - https://github.com/discourse/discourse version 80a1709965fa59da824b2e3392976fc6fc898f80">
<link rel="icon" type="image/png" href="../../uploads/default/optimized/2X/3/30c4e7d76acf879a124fdfe4d8d126afe628c189_2_32x32.png">
<link rel="apple-touch-icon" type="image/png" href="../../uploads/default/optimized/2X/c/c5e37f667fd0fe006ffa67653c662fb64fec597e_2_180x180.png">
<meta name="theme-color" media="all" content="#171616">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, user-scalable=yes, viewport-fit=cover">
<link rel="canonical" href="22421.html" />
<link rel="search" type="application/opensearchdescription+xml" href="../../opensearch.xml" title="0x00sec - The Home of the Hacker Search">
<link href="../../stylesheets/color_definitions_0x00sec-v2_15_57_a5ef387651921c3e4c7aa1108536015ba8299efb.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" class="light-scheme" />
<link href="../../stylesheets/desktop_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="desktop" />
<link href="../../stylesheets/chat_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="chat" />
<link href="../../stylesheets/discourse-details_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-details" />
<link href="../../stylesheets/discourse-lazy-videos_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-lazy-videos" />
<link href="../../stylesheets/discourse-local-dates_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-local-dates" />
<link href="../../stylesheets/discourse-narrative-bot_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-narrative-bot" />
<link href="../../stylesheets/discourse-presence_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-presence" />
<link href="../../stylesheets/discourse-spoiler-alert_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-spoiler-alert" />
<link href="../../stylesheets/docker_manager_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="docker_manager" />
<link href="../../stylesheets/poll_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="poll" />
<link href="../../stylesheets/chat_desktop_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="chat_desktop" />
<link href="../../stylesheets/poll_desktop_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="poll_desktop" />
<link href="../../stylesheets/desktop_theme_46_f36ade55bf80933494fe3b5fab518f477de3bd4e.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="desktop_theme" data-theme-id="46" data-theme-name="header links v2" />
<link href="../../stylesheets/desktop_theme_57_8c0e890a61cdb4c5833a9f9c96664ed164e7d645.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="desktop_theme" data-theme-id="57" data-theme-name="0x00sec-v2" />
<link rel="stylesheet" href="https://s3.amazonaws.com/0x00sec/monokai-sublime.css">
<script src="https://s3.amazonaws.com/0x00sec/highlight.pack.js"></script>
<link rel="preload" href="../../theme-javascripts/440fd21108f5ba9e5dfe06cca9fc842569d5a874.js%3F__ws=0x00sec.org" as="script">
<script defer src="../../theme-javascripts/440fd21108f5ba9e5dfe06cca9fc842569d5a874.js%3F__ws=0x00sec.org" data-theme-id="40"></script>
<link rel="alternate nofollow" type="application/rss+xml" title="RSS feed of &#39;Programming for Wannabes. Part IV&#39;" href="22421.rss" />
<meta property="og:site_name" content="0x00sec - The Home of the Hacker" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://0x00sec.org/uploads/default/original/2X/2/27a5373af868edade07624e8205c46e79c247445.jpeg" />
<meta property="og:image" content="https://0x00sec.org/uploads/default/original/2X/2/27a5373af868edade07624e8205c46e79c247445.jpeg" />
<meta property="og:url" content="https://0x00sec.org/t/programming-for-wannabes-part-iv/22421" />
<meta name="twitter:url" content="https://0x00sec.org/t/programming-for-wannabes-part-iv/22421" />
<meta property="og:title" content="Programming for Wannabes. Part IV" />
<meta name="twitter:title" content="Programming for Wannabes. Part IV" />
<meta property="og:description" content="Some people have asked me to continue this seriesâ€¦ and actually this paper was half written almost two years agoâ€¦ so I decided to finish himâ€¦ you know, the Mortal Kombat wayâ€¦ Not sure if I will write Part Vâ€¦ but Part IV is here ðŸ™‚   Letâ€™s continue our journey towards the ultimate mastering of the computer which will lead us to full enlightenment. So far, we have learnt a few things about computers and, in the meantime, we have already create our first shellcode. However, we have just..." />
<meta name="twitter:description" content="Some people have asked me to continue this seriesâ€¦ and actually this paper was half written almost two years agoâ€¦ so I decided to finish himâ€¦ you know, the Mortal Kombat wayâ€¦ Not sure if I will write Part Vâ€¦ but Part IV is here ðŸ™‚   Letâ€™s continue our journey towards the ultimate mastering of the computer which will lead us to full enlightenment. So far, we have learnt a few things about computers and, in the meantime, we have already create our first shellcode. However, we have just..." />
<meta property="og:article:section" content="Programming" />
<meta property="og:article:section:color" content="92278F" />
<meta property="og:article:tag" content="programming" />
<meta property="og:article:tag" content="clang" />
<meta property="og:article:tag" content="assembly" />
<meta name="twitter:label1" value="Reading time" />
<meta name="twitter:data1" value="17 mins ðŸ•‘" />
<meta name="twitter:label2" value="Likes" />
<meta name="twitter:data2" value="30 â¤" />
<meta property="article:published_time" content="2020-07-26T15:05:01+00:00" />
<meta property="og:ignore_canonical" content="true" />
</head>
<body class="crawler ">
<div id="top-navbar" class="container">
<span id="top-navbar-links" style="display:none;">

<a href="https://init.0x00sec.org" class="dow-menu">Init</a>
<a href="https://discord.gg/c6BHVfn" class="dow-menu">Discord</a>
<a href="https://init.0x00sec.org/?partners" class="dow-menu">Partners</a>
</span>
</div>
<header>
<a href="../../index.html">
0x00sec - The Home of the Hacker
</a>
</header>
<div id="main-outlet" class="wrap" role="main">
<div id="topic-title">
<h1>
<a href="22421.html">Programming for Wannabes. Part IV</a>
</h1>
<div class="topic-category" itemscope itemtype="http://schema.org/BreadcrumbList">
<span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
<a href="../../c/programming/61.html" class="badge-wrapper bullet" itemprop="item">
<span class="badge-category-bg" style="background-color: #92278F"></span>
<span class="badge-category clear-badge">
<span class="category-name" itemprop="name">Programming</span>
</span>
</a>
<meta itemprop="position" content="1" />
</span>
</div>
<div class="topic-category">
<div class="discourse-tags list-tags">
<a href="../../tag/programming.html" class="discourse-tag" rel="tag">programming</a>,
<a href="../../tag/clang.html" class="discourse-tag" rel="tag">clang</a>,
<a href="../../tag/assembly.html" class="discourse-tag" rel="tag">assembly</a>
</div>
</div>
</div>
<div itemscope itemtype="http://schema.org/DiscussionForumPosting">
<meta itemprop="headline" content="Programming for Wannabes. Part IV">
<meta itemprop="articleSection" content="Programming">
<meta itemprop="keywords" content="programming, clang, assembly">
<div itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
<meta itemprop="name" content="0x00sec - The Home of the Hacker">
<div itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
<meta itemprop="url" content="https://0x00sec.org/uploads/default/original/2X/c/c5e37f667fd0fe006ffa67653c662fb64fec597e.png">
</div>
</div>
<div id="post_1" class="topic-body crawler-post">
<div class="crawler-post-meta">
<span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a itemprop="url" href="https://0x00sec.org/u/0x00pf"><span itemprop="name">0x00pf</span></a>
(pico)
</span>
<link itemprop="mainEntityOfPage" href="22421.html">
<span class="crawler-post-infos">
<time itemprop="datePublished" datetime="2020-07-26T15:05:01Z" class="post-time">
July 26, 2020, 3:05pm
</time>
<meta itemprop="dateModified" content="2020-07-26T15:05:01Z">
<span itemprop="position">1</span>
</span>
</div>
<div class="post" itemprop="articleBody">
<p>Some people have asked me to continue this seriesâ€¦ and actually this paper was half written almost two years agoâ€¦ so I decided to <em>finish him</em>â€¦ you know, the <em>Mortal Kombat</em> wayâ€¦ Not sure if I will write Part Vâ€¦ but Part IV is here <img src="../../images/emoji/twitter/slight_smile.png%3Fv=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<hr>
<p>Letâ€™s continue our journey towards the ultimate mastering of the computer which will lead us to full enlightenment. So far, we have learnt a few things about computers and, in the meantime, we have already create our first shellcode. However, we have just scratched the surface of this whole fieldâ€¦ you still have things to learn.</p>
<p>In this part we are going to dive into how programs are built and get in contact with the insights of some exploitation techniques.</p>
<h1>Stacks</h1>
<p>In order to go further in our study we have to introduce a new computer element. <strong>The Stack</strong>. The Stack is just a very simple data structure. It is, maybe, the one and only data structure that is available when programming in assembly. Do to panic, you will see in a second that it is damn simple.</p>
<p>Iâ€™m pretty sure you already know this, but just in case, letâ€™s add a simple explanation here. You can think about a <strong>stack</strong> as a physical <strong>stack</strong>. Think for instance about the stack you build when you wash your dishes. You wash one dish and you put it aside. Then you wash another one, and you put it on top of the previous,â€¦ and so on. At the end you have a stack of dishes.</p>
<p>Now, letâ€™s imagine that is lunch time and you have to take a few dishes to serve your food. What do you do?. Yes, you take first the dish on the top of the stack. The last one you put in the stack. You can try to get the one in the bottom, but that is pretty difficult.</p>
<p>So, a <strong>stack</strong> is a so-called LIFO structure. LIFO stands for <em>Last In, First out</em>. The last dish you put in the stack is the first one you are gonna take whenever you are hungry. There is other major structure called FIFO. I bet you can figure out by know how does it work.</p>
<h1>The STACK</h1>
<p>At processor level, a stack is basically a pointer to a memory block. Usually, the processor provides a dedicated register to hold that pointer and, guess what?, it is usually named <em>Stack Pointer</em>. This will be engraved in your soul by the end of this instalment. This is one of those special register we had mentioned in previous parts of this course. Now, we know the most important two (among those special registers): The <em>Instruction Pointer</em> and the <em>Stack Pointer</em>. They are special because some processor instructions only work on the values of those registers.</p>
<p>For the specific case of the <em>Stack Pointer</em>, there are two basic operations you can perform with a stack:</p>
<ul>
<li>
<code>PUSH</code>. This operation pushes/stores a value in the stack.</li>
<li>
<code>POP</code>. This operation pops/retrieves a value from the stack</li>
</ul>
<p>In general, this is all you need to know at assembly level. However, letâ€™s go a bit deeper in the implementation, just for the sake of our personal enlightenment :). After all this is what we are trying to achieveâ€¦ Do you know why hackers uses a hood? donâ€™t you?..It is because they had reached an enlightenment level that transcend their physical body and their head actually emits lightâ€¦ thatâ€™s why they cover their head with a hoodâ€¦ it is not about looking coolâ€¦ is about not looking weird.</p>
<p>Anyways, the first thing we have to know about a <em>stack</em> implementation is that it grows. This is not strictly correct, but it is the best way to see it now. What this means is that we can implement the stack in two different ways:</p>
<ul>
<li>We can make the stack grow up, towards the high memory addresses</li>
<li>We can make the stack grow down, towards the low memory addresses</li>
</ul>
<p>Most processors nowadays makes the stack grow down, or allow us to chose the model we prefer. The only architecture I know it grows the stack up is PA-RISC. What does this means, well, this just means that, whenever you <code>push</code> a value in the stack, the <em>Stack Pointer</em> is decremented and, whenever you <code>pop</code> a value from the stack, the <em>Stack Pointer</em> gets incremented.</p>
<p>The second thing we have to know about a <em>stack</em> implementation is where the <em>Stack Pointer</em> points. There are two ways of doing this. You (actually the processor designer) can decide that the <em>Stack Pointer</em> points to the last used position in the stack, or you can decide that the <em>Stack Pointer</em> points to the last free position in the stack. For Intel processors the <em>Stack Pointer</em> always points to the last used stack position.</p>
<p>With all this information we can now figure out how to implement the <code>PUSH</code> and <code>POP</code> instructions</p>
<pre><code>             SP First Free               SP Last Used
===========================================================
Grow Down     PUSH V                      PUSH B
              --------------------------------------------
              MOV [SP], V                SUB SP, WS
              SUB SP, WS                 MOV [SP], V

              POP V                      POP V
              ----------------------------------------------
              ADD SP, WS                 MOV V, [SP]
              MOV V, [SP]                ADD SP, WS
============================================================
Grow Up       PUSH V                     PUSH B
              ----------------------------------------------
              MOV [SP], V                ADD SP, WS
              ADD SP, WS                 MOV [SP], V

              POP V                      POP V
              ----------------------------------------------
              SUB SP, WS                 MOV V, [SP]
              MOV V, [SP]                SUB SP, WS
</code></pre>
<p>In the table above, <code>V</code> represents the value we want to store in the stack, and <code>WS</code> is the default processor word size in bytes (check the <a href="../programming-for-wannabees-part-iii-your-first-shell-code/1279/1.html" class="inline-onebox">Programming for Wannabees. Part III. Your first Shell Code</a> for details). <code>SP</code> is the stack pointer (usually a special register, and the <code>[]</code> operator means that we want to access the contents of the address pointed by whatever we put inside the <code>[]</code>. This is called indirect addressing, butâ€¦ we havenâ€™t talked about addressing so far, so, just remember it allows to access the content of a memory position.</p>
<p>You may be wonderingâ€¦ why should I care about the table above?. I will just do <code>PUSH</code> and <code>POP</code> and the processor will take care of doing the right things with the stack pointer. That is true. However, sometimes you will need to manipulate the registers yourself or, while reversing code, you will find manipulations of the <em>Stack Pointer</em> like the ones shown above (compilers do this things)â€¦ so it is convenient to understand how does this works.</p>
<blockquote>
<p>Modern processors uses microcode to implement they machine code. This is, each opcode in the processor is a small program of lower level instructions that deals directly with the datapaths on the processor. <code>PUSH</code> and <code>POP</code> in real-life microcode wonâ€™t look like our example above, but could be pretty similar. VAX machines were one of the first one to use microcode to implement its instruction set.</p>
</blockquote>
<h1>What is the Stack used for?</h1>
<p>The generic response is: <em>to store temporal values</em>. This is a pretty generic answer. Some more specific examples are:</p>
<ul>
<li>Implement nested functions storing the return addresses in the stack</li>
<li>Store local variables (actually local scoped variables)</li>
<li>Store function parameters for certain ABIs</li>
<li>Enable recursion</li>
</ul>
<p>Actually, all the examples given above, can be condensed in a single concept. The so called <code>stack frame</code> of a functionâ€¦ But to go deeper in that we first need to know what a function is.</p>
<h1>Functions</h1>
<p>In the computers realm, functions mimics the mathematical concepts. In that sense, a function is something that receives some parameters and return some value/values. This is the case for most high level languages like C or Python. However, at assembly level, this concept does not really exist. The high level languages just make use of the processor instructions to provide that abstractionâ€¦ After all this is what computer sciences are all aboutâ€¦ to create the illusion of something happening that is not really happening. It is about fooling people :).</p>
<p>You can achieve this in many different ways, as we will see in a while. However, each programming language and also the operating system defines some default rules so all components in the system can talk to each other. We have already mentioned this a few times, it is the so-called <strong>ABI</strong> (Application Binary Interface). As we progress in this section this concept will make more senseâ€¦ I hope.</p>
<p>For us, a function is a piece of code, stored somewhere in memory that we can execute at any time, passing some data in, and optionally, receiving some data back. Letâ€™s see how we can do this.</p>
<h2>Assembly support</h2>
<p>So, how does the processor supports the implementation of functions. Well, the first thing we have to do is to be able to change the flow of our program. So far, all the programs we have seen work sequentially. We start at a given instruction, and the program reads those instruction one after the other.</p>
<p>In general, we will want to call our functions many times. Actually that is one of the fundamental reasons to define functions, to avoid copying the same code whenever it is needed, making our programs grow in size, and making it really difficult to maintain. So, what we need is a way to change the <code>Instruction Pointer</code>. We could use our well known <code>MOV</code> instruction to update the <code>RIP</code> register (the instruction pointer) and force the processor to continue the execution in a new memory address. However it does not work like that (well it does sometimes)â€¦ To be honest I have never tried that outside of a debugger, but, anyway, there are very good reasons to use the processor mnemonics to chance the Instruction Pointer, instead of doing it directly by ourselves.</p>
<p>It is not the right time to go into these details, but for the more advanced and curious reader you can search for concepts as processor pipelines, branch prediction units and processor cache to figure out why it is better to use the proper instructions when changing program flow.</p>
<p>So, the machine instructions traditionally used to <em>call a function</em> in assembler for the Intel platform are <code>CALL</code> and <code>RET</code>. Letâ€™s see what <code>CALL</code> does.</p>
<p>First thing <code>CALL</code> does is to push into the stack the address of the next instruction. The so-called <em>Return Address</em> (remember this name). Then it changes the instruction pointer to the address passed as parameter.</p>
<p>After invoking a <code>CALL</code> instruction, our program will continue in the address passed as parameter and store in the stack the address we have to return to in order to continue the execution whenever we are done with our function. So basically a <code>CALL</code> instruction does something like:</p>
<pre><code class="lang-auto">CALL ADDR  -&gt; PUSH RIP + 1
              JMP  ADDR
</code></pre>
<p>The <code>RET</code> instructions does the opposite. it recovers a value from the stack and sets <code>RIP</code> to that value. Unless we had messed up with the stack in our function (letâ€™s talk about smashing the stack in a whileâ€¦), the address in the stack should be the instruction just after the <code>CALL</code>.</p>
<pre><code class="lang-auto">RET      -&gt; POP RIP
</code></pre>
<p>Letâ€™s rewrite the function we used in the first part of this course with information we have now:</p>
<pre><code class="lang-auto">f1: mov eax, 0xa
    mov edx, 0x14
    add eax, edx
    ret

main:(... Program starts here....) 
     call f1
      (... program continues here ...)
</code></pre>
<p>So far so good. Now we know how the processor allows us to run a piece of code located somewhere in the memory and, when done, return back just to the point where we were before calling the function.</p>
<h2>ABI. Parameters and return values</h2>
<p>The function we have just written, does not receive any parameter and does not return anything. Well it actually returns a value under some platforms but we will see why in a second.</p>
<p>So, how can we pass parameters and receive returns values from an assembly function?. The answer isâ€¦ it is up to us. At assembly level we can do whatever we want. However there are a few reasonable options to deal with this in a systematic and ordered way. Letâ€™s check them out:</p>
<ul>
<li>We can push our parameters in the stack and receive the result in a register. This is the way used by <code>x86</code> (Intel 32 bits) applicationsâ€¦</li>
<li>We can store our parameters in the registers and receive the result also in registers. This is roughly how a <code>x86-64</code> application works. For 64bits processors we have a lot of registers so it is faster to just use the registers to pass the parameters than using the stack (after all the stack is memory and is slower than the registers). However, for functions that receives a lot of parameters, the stack is used when no more registers are availableâ€¦ Now you know why it is better to define functions with a reasonable number of parameters.</li>
<li>We can use some registers to pass parameters in and some registers to pass parameters out. This is what ARM and MIPS doesâ€¦ again, when there are enough registers available to hold the parameters and return values.</li>
</ul>
<blockquote>
<p>When our function can return more than one value we would use output parameters passed as reference so they can be modified by the function. In this case return values are manages exactly the same as parameters are, in a sense they are also parameters. You can figure out what would happen if you try to just store return values in the stack within the functionâ€¦ It wonâ€™t work straight away. But do that when you have finished reading this instalment.</p>
</blockquote>
<p>In principle, the <code>ABI</code> depends on the operating system, however, in practice, it is mostly driven by the processor. This way, Linux follows the so-called System V ABI, and Windows have its own, but both uses the stack for 32 bits and registers for 64bits, even when Windows defines more cases and different registers may be used for the parameters.</p>
<p>Now, letâ€™s modify our test function so it will get the two numbers to be added as parameters. We will chose to pass parameters in registers and return the result also in registers. As we said above, this is the Linux 64bits ABI. Specifically for this case:</p>
<pre><code class="lang-auto">Param 1  | Param 2 | Param 3 | Param 4 | Return
   RDI   |    RSI  |    RDX  |    RCX  |   RAX
</code></pre>
<p>So, the code will now look like this:</p>
<pre><code class="lang-auto">f1: mov rax, rdi	; Copy Param 1 in RAX
    add rax, rsi	; Add Param1+Param2 in RAX
    ret	

main:(... Program starts here....) 
     mov rdi, 0x0a	 ; Param 1
     mov rsi, 0x14	 ; Param 2
     call f1
			; RAX contains Param1 + Param2
      (... program continues here ...)

</code></pre>
<p>That was easy right?.</p>
<p>Actually, this function is compatible with the System V ABI followed by GNU/Linuxâ€¦ or in other words, we can call this function from a C program and it will work as expected:</p>
<p>This is the assembly function in file <code>ex.S</code>â€¦ letâ€™s use AT&amp;T asm so we can just use the file directly with <code>gcc</code> for compiling.</p>
<pre><code class="lang-auto">	.global f1
f1:	mov %rdi, %rax
	add %rsi,%rax
	ret
</code></pre>
<p>This is the C main program in file <code>ex.c</code>:</p>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;

int f1 (int a, int b); // Prototype

int main (void) {
  printf ("Result: %d\n", f1 (10, 20));
}
</code></pre>
<p>Yesâ€¦ we are polite and we include the prototype for our asm function.</p>
<p>Now we can compile:</p>
<pre><code>$ gcc -o ex ex.c ex.S
$ ./ex
Result: 30
</code></pre>
<p>I would say that if you do not find this to be really coolâ€¦ then you are reading the wrong tutorial <img src="../../images/emoji/twitter/slight_smile.png%3Fv=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<p>Note that if we decide to use a different solution to deal with our parameters (using the stack or a different set of registers) this wonâ€™t workâ€¦ because we will not be using the GNU/Linux System V ABI and our function will not be compatible with the system it is intended to be used withâ€¦ However, from another asm function we can call other functions in any way we wantâ€¦ it is just that it will not play nicely with tools like C compilers as we have just seen.</p>
<h2>The Function Prologue and Epilogue</h2>
<p>We already know how to call a function (some code somewhere in memory) and we have already made a decision on how to get data in and out. This is enough when you work in assembly or with very simple functions, but for higher level languages we usually need a few more things.</p>
<p>These are some examples:</p>
<ul>
<li>We will usually need some local variables. These variables will only exists within our function and will disappear after the <code>RET</code> instructionâ€¦ or at least, their values will not be valid any more.</li>
<li>For languages like C++, the local variables may be objects. In general, destroying an object implies the execution of the so-called destructorâ€¦ that is just another name for a function that has to be executed before returning.</li>
<li>We may need to be able to write re-entrant code in order to write recursive functions</li>
</ul>
<p>What this means is that, for higher level languages, we usually have to do some additional things when entering and leaving a function. In general, all this is generated by the compiler and for application programmers it does not matter at all. However, if you are reversing some code generated from a high level language you will be exposed to these constructors/structures.</p>
<p>The code that is executed when entering the function is known as <em>Function Prologue</em>, and the code executed when leaving a function is known as <em>Function Epilogue</em>. Letâ€™s dive a bit more on this.</p>
<h2>Minimal Prologue and Epilogue. The Stack Frame</h2>
<p>In the simplest case, a C function prologue and epilogue will look like this:</p>
<pre><code class="lang-auto">	push rbp
	mov  rbp, rsp
	sub  rsp, 0x10
	; PUSH registers used locally
        (... FUNCTION BODY ...)
	; POP Registers used locally
	mov rsp, rbp
	pop rbp
	ret
</code></pre>
<p>You will see code like this all over the place when reversing applications. So, letâ€™s invest some time understanding this concept.</p>
<p>The first three instructions are the function prologue. What the compiler usually do is to copy the current stack pointer in an auxiliary register. For Intel platforms this is usually <code>RBP</code> where <code>BP</code> stands for <strong>Base Pointer</strong> (and <code>R</code> roughly means we are working with 64bits, <code>EBP</code> is the 32bits version and <code>BP</code> the 16bits version). This register is the one that defines the so called <strong>Stack Frame</strong>. We will get to this in a sec.</p>
<p>Letâ€™s look at the code in detail. We get into the function and the stack contains the return address as we described before. Then we store the current value of <code>RBP</code>â€¦ just because we are going to modify it and we want to restore it before returning, so the calling function does not have to care about changes to that register. Also, think about the case when a function is called from inside another functionâ€¦</p>
<p>Then, we store in <code>RBP</code>, our base register, the current top of the stack. And after that, we increase the stack (remember it grows down on Intel platforms so we have to substract a value to grow the stack). For this specific function, the stack will look like this (supposing parameters are passed on registers - 64bits Intel-)</p>
<pre><code>ADDR
X      Start    --&gt;  Return Address
       RBP      --&gt;  RBP
                --&gt;  4 bytes
                --&gt;  4 bytes
                --&gt;  4 bytes
X-24   RSP      --&gt;  4 bytes
</code></pre>
<p>The figure above shows the stack after the function prologue. In this example, the stack area going from the return address to the current value of the Stack Pointer is the so called stack frame for this function. OK, some books or authors may consider it slightly different, but what it is important is the concept. Note that if the ABI requires to push the parameters in the stack, those parameters will also be part of the function stack frame (they will be placed before the return address)â€¦ well, as I said, depends on who is writing about it.</p>
<p>So, the stack frame, is a chunk of the stack that contains all the information required by a function to work. This is very convenient. If we just call now another function within this function, a new stack frame will be added to the stack. When the function returns, the stack gets cleaned and the previous stack frame is just there. This way we can call multiple functions (even the same one) many times and keep the local variables of each invocation unmodified.</p>
<p>To finish this, letâ€™s take a look to the function epilogue. It just restore the stack pointer and the <code>RBP</code> base pointer, leaving the stack ready for executing <code>RET</code> and effectively getting rid of all local storage used by the function (the local variables).</p>
<p>Note that the <code>sub esp, 0x10</code> in the prologue is the equivalent to do 4 <code>pops</code> in the stackâ€¦ Substracting a values from <code>RSP</code> allows us to allocate memory in the stack in a very easy way. The fact that the <code>RBP</code> base pointer holds the address of the original stack pointer allows us to release/free all that local memory just restoring the stack pointer. And we do that copying <code>RBP</code> back into <code>RSP</code>. See the stack figure above.</p>
<h2>Do we need the stack frame?</h2>
<p>As we have seen, defining a stack frame makes our lives easier in the general case, however, specially when the functions are small it actually introduces a little overhead (both on execution time and also on memory) and does not provide much more. Also, not using a stack frame frees a register (<code>RBP</code> for intel processors) that can be used for operations in the function and therefore improve performance.</p>
<p>Sometimes, it may be interesting to get rid of it. and this can be done using the compiler flag <code>-fomit-frame-pointer</code>. Just for illustration process, these is the <code>func1</code> in our previous example with and width out frame pointer:</p>
<pre><code class="lang-auto">WITH FRAME POINTER                          | WITHOUT FRAME POINTER
55           push   rbp                     |
48 89 e5     mov    rbp,rsp                 |
c6 45 ff 10  mov    BYTE PTR [rbp-0x1],0x10 | c6 44 24 ff 10  mov    BYTE PTR [rsp-0x1],0x10
0f b6 45 ff  movzx  eax,BYTE PTR [rbp-0x1]  | 0f b6 44 24 ff  movzx  eax,BYTE PTR [rsp-0x1]
83 c0 01     add    eax,0x1                 | 83 c0 01        add    eax,0x1
5d           pop    rbp                     |
c3           ret                            | c3              ret

</code></pre>
<p>As you can see the saving is not that much.</p>
<h2>Other things that happens when you leave a function</h2>
<p>What we have described is the very basics on what is going on under the hood when calling a function. However, depending on different factors a lot more things may happen.</p>
<p>We had already mentioned the C++ case. All those objects you create in your functions just does not go away magically. They are usually created in the stack and when the method returns, the stack has to be traversed to find out the locally created objects and call the appropriate destructors. This process is known generically as <a href="https://en.wikipedia.org/wiki/Call_stack#Unwinding" title="unwinding" rel="nofollow noopener">unwinding</a>. Soâ€¦ calling a C++ function/methods, despite of how simple the code may look like, can be doing quite a bunch of things under the hood and be way less efficient than a longer raw C version.</p>
<p>Also stack protections (we will talk about this later) requires extra code that needs to be executed when the function ends to detected corruptions in the stack.</p>
<h2>Local Variables</h2>
<p>The last piece to understand the stack structure when a function is called are the local variables. Almost any decent programming language support local variables. A local variable is one that only exist in a given context, usually within a function. Compare this to a so-called global variable that is accessible from anywhere in the program at any timeâ€¦ Ahâ€¦ yesâ€¦ sureâ€¦ global variables are evil (end of mandatory disclaimer).</p>
<p>So, the easiest way to create variables local to a function is to store them in the function stack frame. We had already seen how this is created for each function call, and therefore, anything we allocate in there will remain there for the function associated to it. So local variables are just allocated making room in the stack. In other words, they are declared changing the <em>Stack Pointer</em>.</p>
<p>To see this, and introduce the next concept we are going to learn, letâ€™s play with a simple hands-on example. Pay attention. What we are going to do right now, is something you can always do when you are not fully sure about somethingâ€¦ just write a test and see what happens. This technique is invaluable during the learning process and you should use it as much as you can.</p>
<p>In this case, we are going to declare a few functions in a C program, with different local variables and see what happens. Yes sure, to declare a local variable in C you just need to declare the variable inside the function you want the variable to be local toâ€¦</p>
<pre><code class="lang-auto">int func1 (void) {
  unsigned char a = 0x10;
  return a+1;
}
int func2 (void) {
  int a = 0x10;
  unsigned char b = 0x20;
  int c = 0x30;

  return a+b+c;
}

void func3 (int a, int b) {
  char str[100];

}
int main() {
}
</code></pre>
<p>Nothing really exciting. We declared three functions with some local variables of different types. Letâ€™s look at the assembly:</p>
<h2><code>func1</code></h2>
<p>This is how <code>func1</code> looks like:</p>
<pre><code class="lang-auto">$ objdump -Mintel -d local_vars | grep -A7 "&lt;func1&gt;"
00000000000005fa &lt;func1&gt;:
 5fa:   55                      push   rbp
 5fb:   48 89 e5                mov    rbp,rsp
 5fe:   c6 45 ff 10             mov    BYTE PTR [rbp-0x1],0x10
 602:   0f b6 45 ff             movzx  eax,BYTE PTR [rbp-0x1]
 606:   83 c0 01                add    eax,0x1
 609:   5d                      pop    rbp
 60a:   c3                      ret

</code></pre>
<p>We can see the function prologue (storing <code>rbp</code> and making it point to the stack). Then we see that <code>mov</code> instruction, copying the value <code>0x10</code> into <code>[rbp-0x1]</code>â€¦ That is our local variable. <code>RBP</code> will point to the top of to stack, as the stack grows to lower address (goes down) for intel machines, the next empty position in the stack is <code>rbp - 1</code>.</p>
<p>During reverse engineering code, you will have to identify the different local variables in the function. Most decent tools nowadays allows you to give names to these <code>rbp</code> offsets, or in other words, to name the local variables in the function you are reversing. That helps a lot during the process.</p>
<p>However here, we are missing a component that is common in functions but that, for this simple function, gcc have just thrown away because it is not needed. The peculiarity of this function is that it is a so-called leaf function. This means that this function does not call any other function. The practical effect of this is that we do not need to allocate memory in the stack for our local variables.</p>
<p>Stack memory is usually allocated adjusting the Stack Pointer. In this case we just use the stack freely asâ€¦ no other function will be executed that could overwrite our local variable values.</p>
<p>Letâ€™s just quickly modify <code>func1</code> in our program like this:</p>
<pre><code class="lang-auto">int func1 (void) {
  unsigned char a = 0x10;
  a += func2 ();
  return a+1;
}
</code></pre>
<p>When compiling you will get a warning about <code>func2</code> not defined. You shall always honour warnings like those, but in this case, the prototype of the function actually matches the default prototype assigned by gcc and everything is going to be fine. Anyway, be free to add <code>func2</code> prototype above <code>func1</code> definition to remove the warning.</p>
<p>Now, we can take a look to the new code generated for <code>func1</code>.</p>
<pre><code class="lang-auto">4$ objdump -Mintel -d local_vars | grep -A11 "&lt;func1&gt;:"
000000000000066a &lt;func1&gt;:
 66a:   55                      push   rbp
 66b:   48 89 e5                mov    rbp,rsp
 66e:   48 83 ec 10             sub    rsp,0x10
 672:   c6 45 ff 10             mov    BYTE PTR [rbp-0x1],0x10
 676:   b8 00 00 00 00          mov    eax,0x0
 67b:   e8 0c 00 00 00          call   68c &lt;func2&gt;
 680:   00 45 ff                add    BYTE PTR [rbp-0x1],al
 683:   0f b6 45 ff             movzx  eax,BYTE PTR [rbp-0x1]
 687:   83 c0 01                add    eax,0x1
 68a:   c9                      leave
 68b:   c3                      ret
</code></pre>
<p>Now we can see the instruction <code>sub rsp, 0x10</code> that allocates 16 bytes in the stack before calling <code>func2</code>. Why 16 byte?.. Well, for 64bits intel processors the stack has to be aligned to blocks of 16 bytes. This is apparently related to the biggest register size that can be pushed into the stack (SSE extension). In this case we just need 1 byte (our variable is at <code>rbp-0x1</code>) but we have to allocate 16 at least.</p>
<p>The <code>leave</code> instruction is a high level procedure exit function complementary to <code>enter</code>. <code>leave</code> actually implements our function epilogue in one instructionâ€¦ sets <code>RSP</code> to <code>RBP</code> and pop <code>RBP</code>. If you check the Intel manual for <code>enter</code> instruction you will see that this instruction does a lotâ€¦ what roughly means that it is slow. Looks like compiler writers know that and they just generate the required instructions for each case. Thatâ€™s why you wonâ€™t see <code>enter</code> very often on binaries.</p>
<h2><code>func2</code></h2>
<p>Now, letâ€™s look at <code>func2</code>:</p>
<pre><code class="lang-auto">$ objdump -Mintel -d local_vars | grep -A12 "&lt;func2&gt;"
000000000000067b &lt;func2&gt;:
 67b:   55                      push   rbp
 67c:   48 89 e5                mov    rbp,rsp
 67f:   c7 45 f8 10 00 00 00    mov    DWORD PTR [rbp-0x8],0x10
 686:   c6 45 f7 20             mov    BYTE PTR [rbp-0x9],0x20
 68a:   c7 45 fc 30 00 00 00    mov    DWORD PTR [rbp-0x4],0x30
 691:   0f b6 55 f7             movzx  edx,BYTE PTR [rbp-0x9]
 695:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]
 698:   01 c2                   add    edx,eax
 69a:   8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]
 69d:   01 d0                   add    eax,edx
 69f:   5d                      pop    rbp
 6a0:   c3                      ret

</code></pre>
<p>The first thing we notice is that the compiler has reordered the variables. We declared and <code>int</code>, then a <code>char</code> and then another <code>int</code>, but the variables are stored slightly differently:</p>
<pre><code>         STACK CONTENT   RBP Index
           RET Addr
RBP-&gt;       RBP
            c1	           -1
            c2             -2
		    c3             -3
		    c4             -4  [rbp - 0x4] &lt;- int  (32bits)
			a1             -5
			a2             -6
			a3             -7
			a4             -8  [rbp - 0x8] &lt;- int  (32bits)
			b              -9  [rbp - 0x9] &lt;- char (8 bits)
</code></pre>
<p>As we can see, the <code>char</code> variable (that uses just 1 byte) is stored at the very end of the stack, this is probably the compiler trying to ensure memory alignment and optimising the use of stack memory. Anyway, the interesting thing here is than the compiler can re-order the local variables as it thinks is better (check <a href="../simple-buffer-overflow-demonstration/1131/4.html">this</a>).</p>
<h2>Then <code>func3</code>
</h2>
<p>Now it is time to look into <code>func3</code>. Things are going to get more interesting now:</p>
<pre><code class="lang-auto">00000000000006a1 &lt;func3&gt;:
 6a1:   55                      push   rbp
 6a2:   48 89 e5                mov    rbp,rsp
 6a5:   48 81 ec 90 00 00 00    sub    rsp,0x90
 6ac:   89 bd 7c ff ff ff       mov    DWORD PTR [rbp-0x84],edi
 6b2:   89 b5 78 ff ff ff       mov    DWORD PTR [rbp-0x88],esi
 6b8:   64 48 8b 04 25 28 00    mov    rax,QWORD PTR fs:0x28
 6bf:   00 00
 6c1:   48 89 45 f8             mov    QWORD PTR [rbp-0x8],rax
 6c5:   31 c0                   xor    eax,eax
 6c7:   90                      nop
 6c8:   48 8b 45 f8             mov    rax,QWORD PTR [rbp-0x8]
 6cc:   64 48 33 04 25 28 00    xor    rax,QWORD PTR fs:0x28
 6d3:   00 00
 6d5:   74 05                   je     6dc &lt;func3+0x3b&gt;
 6d7:   e8 64 fe ff ff          call   540 &lt;__stack_chk_fail@plt&gt;
 6dc:   c9                      leave
 6dd:   c3                      ret
</code></pre>
<p>The first thing we see just before the function prologue is an update of the <code>RSP</code> pointer. This is effectively the declaration of the array of our function (actually of all the local variables at once). Updating <code>RSP</code> is actually equivalent, as we have briefly mentioned already, to reserve a chunk of the stack because this part wonâ€™t be used by <code>pushes</code> or <code>pops</code> or <code>calls</code> within the function (well, unless something goes really crazy in the program and we â€¦ overwrite the stackâ€¦ but we are getting to that in a while).</p>
<p>So, as the stack grows downwards (to the lower address), subtracting a value for RSP is the way to allocate memory in the stack.</p>
<blockquote>
<p>As you can see local variables are allocated/freed just decreasing/increasing <code>SP</code>â€¦ This means that they are not initialised automatically. In other words, this means that when you call a function many times one after the other, the same area of the stack will be used again and again to hold the function stack frame. If you do not initialise your variables yourself, they will hold values from previous invocations and you get those strange situations of functions that fail the first time but then they work fineâ€¦ It is not witchcraft is just variable initialisationâ€¦</p>
</blockquote>
<p>Now the following question ariseâ€¦ Why is the compiler allocating <code>0x90</code> (144 bytes) instead of the 120 that we asked for?.. Well, it is actually allocating the right size. if you pay attention to the rest of the code those <code>0x90</code> bytes includes a 8 bytes value at <code>[rbp-0x8]</code> (we will come back to this in a sec) and two values at <code>[rbp-0x84]</code> and <code>[rbp-0x88]</code> to store the parameters passed to the function (do you remember? par1 -&gt; rdi/edi par2 rsi/esi). So 144-8-8-8 = 120.</p>
<p>Note however that for a 64bits machine the stack pointer needs to be always aligned to 16 bytes (yes bytes), in order to accommodate values for SSE registers. So, just keep in mind that sometimes the compiler will just allocate more stack space than needed in order to maintain its alignment and also it will pad small data types to also keep the memory properly aligned.</p>
<blockquote>
<p>Try to recompile the program with different values for the buffer sizeâ€¦ specially odd numbers and see the result. Alternative re-read the section about <code>func1</code></p>
</blockquote>
<h1>Buffer overflows</h1>
<p>So now we have got all the pieces to understand what is a buffer overflow and how it can be used to modify the normal program flowâ€¦ which at the end is what an attacker is looking for, a way to execute arbitrary code, or at least some code that can provide some advantage or access to the machine.</p>
<p>Letâ€™s get back for a sec to our <code>func3</code> and how the stack is laid out after the function prologue is executed.</p>
<pre><code>X+0x8            Ret Address
X        RBP  -&gt; RBP
X-0x8            Some data here
(...)
X-0x90   RSP  -&gt; str (func3 buffer)
</code></pre>
<p>So, basically, if we can write more than <code>0x90</code> bytes into <code>str</code> we will start writing beyond the function stack frame and eventually we could overwrite the return address and therefore control the flow of the program. Actually we could overwrite the stack frame of the function that called the buggy one.</p>
<p>Note that our <code>func3</code> does nothing and therefore there is no way to overwrite the buffer. Actually, we can only overwrite the buffer when the programmer have made a mistake developing the program. A so-called bug.</p>
<p>Letâ€™s make a mistake so we can learn more about how the stack can get smashed and its consequences.</p>
<h2>A vulnerable program</h2>
<p>So, letâ€™s use a new program where we can actually overwrite the stack and also, letâ€™s take that chance to dump the stack content for better realise what is going on.</p>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;

#define SIZE 13
#define OFF  12

void func (char *a) {
  long  first=0x1122334455667788;
  char s[50];
  char *d=s;
  int i;
  long *p;

  p = (&amp;first) + OFF;
  for (i = 0; i &lt; SIZE; p--,i++) printf ("%p -&gt; %0lx\n", p, *p);
  while (*d++ = *a++);

  p = (&amp;first) +OFF;
  printf ("---------\n");
  for (i = 0; i &lt; SIZE; p--,i++) printf ("%p -&gt; %0lx\n", p, *p);
  
}

int main (int argc, char *argv[]) {
  printf ("Return address: %p\n----\n", &amp;&amp;the_end);
  func (argv[1]);
 the_end:
  return 0;
}
</code></pre>
<p>So the program just dumps the stackâ€¦ overwrites the buffer with the parameter passed through the command line, and them dumps the stack again, before leaving the function.</p>
<p><em>Note:I manually adjusted the values of <code>SIZE</code> and <code>OFF</code> to just dump the interesting part for this example</em></p>
<p>Letâ€™s see what happens when we run it:</p>
<pre><code class="lang-auto">$ ./vul `perl -e "print 'A'x80;"`
Return address: 0x56330f66a833     &lt;-----------------------+
----                                                       |
0x7ffd9b5eab88 -&gt; 56330f66a833      &lt;- Return Address -----+
0x7ffd9b5eab80 -&gt; 7ffd9b5eaba0      &lt;- RBP
0x7ffd9b5eab78 -&gt; 2f0fef490dd7a400
0x7ffd9b5eab70 -&gt; 7f2c512559f0
0x7ffd9b5eab68 -&gt; 56330f66a88d
0x7ffd9b5eab60 -&gt; 1
0x7ffd9b5eab58 -&gt; f0b2ff
0x7ffd9b5eab50 -&gt; 7ffd9b5eabb8
0x7ffd9b5eab48 -&gt; 7f2c51247660
0x7ffd9b5eab40 -&gt; 9                &lt;- Buffer
0x7ffd9b5eab38 -&gt; 7ffd9b5eab38
0x7ffd9b5eab30 -&gt; 7ffd9b5eab40
0x7ffd9b5eab28 -&gt; 1122334455667788 &lt;- first
---------
0x7ffd9b5eab88 -&gt; 4141414141414141 &lt;- Return address overwritten
0x7ffd9b5eab80 -&gt; 4141414141414141
0x7ffd9b5eab78 -&gt; 4141414141414141
0x7ffd9b5eab70 -&gt; 4141414141414141
0x7ffd9b5eab68 -&gt; 4141414141414141
0x7ffd9b5eab60 -&gt; 4141414141414141
0x7ffd9b5eab58 -&gt; 4141414141414141
0x7ffd9b5eab50 -&gt; 4141414141414141
0x7ffd9b5eab48 -&gt; 4141414141414141
0x7ffd9b5eab40 -&gt; 4141414141414141
0x7ffd9b5eab38 -&gt; 7ffd9b5eab38
0x7ffd9b5eab30 -&gt; 7ffd9b5eab91
0x7ffd9b5eab28 -&gt; 1122334455667788
*** stack smashing detected ***: &lt;unknown&gt; terminated
Aborted
</code></pre>
<p><em>NOTE:You will get completely different addresses in the first column. Thatâ€™s normal</em></p>
<p>Yes, as you can see we can overwrite the return address in the stack so we could control the application flow whenever the function returns. Right?</p>
<p>Unfortunately things are not that easy nowadays and, as you can see, instead of crashing (because there is no code at address <code>0x4141414141414141</code>) we get a nice message informing us that the stack has been <em>Smashed</em>â€¦</p>
<blockquote>
<p>When trying to exploit a program, instead of using a sequence of <code>A</code>s as we did here, you better use a <a href="https://en.wikipedia.org/wiki/De_Bruijn_sequence" rel="nofollow noopener">De Bruijn Sequence</a> as it has interesting properties to find relevant offsets in memory</p>
</blockquote>
<h2>Canaries</h2>
<p>The reason why our program didnâ€™t crashed is because it is compiled with stack protection, or in other words the application uses canaries to detect changes in the stack. Letâ€™s see how this works checking the code of this function.</p>
<pre><code class="lang-auto">0000000000006fa &lt;func&gt;:
 6fa:   55                      push   rbp
 6fb:   48 89 e5                mov    rbp,rsp
 6fe:   48 83 ec 70             sub    rsp,0x70
 702:   48 89 7d 98             mov    QWORD PTR [rbp-0x68],rdi
 706:   64 48 8b 04 25 28 00    mov    rax,QWORD PTR fs:0x28
 70d:   00 00
 70f:   48 89 45 f8             mov    QWORD PTR [rbp-0x8],rax
(...)
 7e3:   48 8b 45 f8             mov    rax,QWORD PTR [rbp-0x8]
 7e7:   64 48 33 04 25 28 00    xor    rax,QWORD PTR fs:0x28
 7ee:   00 00
 7f0:   74 05                   je     7f7 &lt;func+0xfd&gt;
 7f2:   e8 c9 fd ff ff          call   5c0 &lt;__stack_chk_fail@plt&gt;
 7f7:   c9                      leave
 7f8:   c3                      ret

</code></pre>
<p>So, at the beginning of the function we can see how the function stores the value of <code>fs:0x28</code> into local variable <code>[rbp-0x8]</code>â€¦ that is the first available position in the stack after the return address and the <code>rbp</code> register.</p>
<p>The function does its stuff and at the end, it checks this local variable and compares it with the original value at <code>fs:0x28</code>. If the values doesnâ€™t mach, a special function named <code>__stack_chk_fail</code> is called. This is the function that shows the message in the console when we smash the canary.</p>
<p>Note that this code is only generated when we have a buffer in the function. Check back our <code>func1</code> and <code>func2</code> in the previous exampleâ€¦ no canaryâ€¦ because, in principle we cannot override the stack without overflowing a buffer.</p>
<p>So, with this information, letâ€™s annotate once again the output of this simple program, but this time adjusting the sequence of <code>A</code> to the value that gets the canary check function executed:</p>
<pre><code class="lang-auto">$ ./vul `perl -e "print 'A'x57;"`
Return address: 0x559e7cf9b833       &lt;-------------------------+
----                                                           |
0x7ffd1a347e68 -&gt; 559e7cf9b833       &lt;--- Return Address ------+
0x7ffd1a347e60 -&gt; 7ffd1a347e80       &lt;-- RBP
0x7ffd1a347e58 -&gt; 4c77054d1b6f8100   &lt;-- Canary
0x7ffd1a347e50 -&gt; 7f2d1ac4c9f0
0x7ffd1a347e48 -&gt; 559e7cf9b88d
0x7ffd1a347e40 -&gt; 1
0x7ffd1a347e38 -&gt; f0b2ff
0x7ffd1a347e30 -&gt; 7ffd1a347e98
0x7ffd1a347e28 -&gt; 7f2d1ac3e660
0x7ffd1a347e20 -&gt; 9                  &lt;-- Buffer
0x7ffd1a347e18 -&gt; 7ffd1a347e18
0x7ffd1a347e10 -&gt; 7ffd1a347e20
0x7ffd1a347e08 -&gt; 1122334455667788   &lt;-- first
---------
0x7ffd1a347e68 -&gt; 559e7cf9b833
0x7ffd1a347e60 -&gt; 7ffd1a347e80
0x7ffd1a347e58 -&gt; 4c77054d1b6f0041  &lt;- First byte of canary overwritten
0x7ffd1a347e50 -&gt; 4141414141414141
0x7ffd1a347e48 -&gt; 4141414141414141
0x7ffd1a347e40 -&gt; 4141414141414141
0x7ffd1a347e38 -&gt; 4141414141414141
0x7ffd1a347e30 -&gt; 4141414141414141
0x7ffd1a347e28 -&gt; 4141414141414141
0x7ffd1a347e20 -&gt; 4141414141414141
0x7ffd1a347e18 -&gt; 7ffd1a347e18
0x7ffd1a347e10 -&gt; 7ffd1a347e5a
0x7ffd1a347e08 -&gt; 1122334455667788
*** stack smashing detected ***: &lt;unknown&gt; terminated
Aborted

</code></pre>
<p>To finish with this topic, just say that the initialisation code of the program (do you remember all that code that gets executed before <code>main</code> and that we got rid of it in a previous instalment?) generates a canary as a random number that gets stored at <code>fs:0x28</code>. <code>fs</code> is a segment register. We will not talk about this right now, just consider this a special memory address.</p>
<h2>Exploiting buffer overflows</h2>
<p>Actually this section is just going to be a suggestion for you to read about the topic on the internet. There are plenty of great tutorials out there explaining how to exploit buffer overflows and how to circumvent canaries or deal with <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization" rel="nofollow noopener">ASLR</a> or <a href="https://en.wikipedia.org/wiki/Position-independent_code#PIE" rel="nofollow noopener">PIE binaries</a> (like the one in our example).</p>
<p>After all, this is a programming course, and the objective is for you to understand how to build programs and also how programs are built. Hope that at least, now you know enough about this topic to easily follow any exploitation tutorial out there and update it to make it work for your systemâ€¦ yesâ€¦ things usually just doesnâ€™t work out of the box and knowing this details will help you figure out why a lot faster.</p>
<p>â€¦ that was easier than I expected <img src="../../images/emoji/twitter/slight_smile.png%3Fv=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<h1>The ARM Case</h1>
<p>Now, that we know everything about the stack on Intel processors, letâ€™s take a look to what happens on other platforms. letâ€™s start with our beloved ARM. We are going to recompile the three function test program we used earlier in this section and look inside it.</p>
<pre><code class="lang-auto">$ arm-linux-gnueabi-gcc -o local_vars-arm local_vars.c
$ arm-linux-gnueabi-objdump -d local_vars-arm
</code></pre>
<p>As we did before, letâ€™s go function by function analysing the code generated:</p>
<h2>
<code>func1</code> ARM</h2>
<p>Before fully understand this code we need to learn a little bit of basics about ARM registers. As it happens with the Intel processor, ARM has some special registers. In principle, ARM names the registers as <code>RX</code> where <code>X</code> is a number running from 0 to 15 for the 32bits architecture (64bits uses other names). However a bunch of those have special meanings:</p>
<pre><code>REGISTER  ALIAS  DESCRIPTION
R11       FP     Frame Pointer
R12       IP     Intra Procedural Call
R13       SP     Stack Pointer
R14       LR     Link Pointer
R15       PC     Program Counter
</code></pre>
<p>From those special ones, the following are relevant for our current discussion:</p>
<ul>
<li>
<code>R11/FP</code>. This register is used as frame pointer in the same way that <code>RBP</code> on the Intel platform.</li>
<li>
<code>R13/SP</code>. This is the stack pointer and works exactly like the <code>RSP</code> Intel register</li>
<li>
<code>R14/LR</code>. This is called the Link Register. Whenever a function is called this register contains the <em>Return Address</em>. As you may remember, for intel processors, this value is stored in the stack before transferring the control to the function. ARM, PowerPC, Pa-RISC and SPARC uses this other approach of storing the value in a register</li>
<li>
<code>R15/PC</code>. This is the instruction pointer or program counter and we already know everything about it.</li>
</ul>
<p>With this information, lets take a look</p>
<pre><code class="lang-auto">00010468 &lt;func1&gt;:
   10468:       e52db004        push    {fp}            ; (str fp, [sp, #-4]!)
   1046c:       e28db000        add     fp, sp, #0
   10470:       e24dd00c        sub     sp, sp, #12
   10474:       e3a03010        mov     r3, #16
   10478:       e54b3005        strb    r3, [fp, #-5]
   1047c:       e55b3005        ldrb    r3, [fp, #-5]
   10480:       e2833001        add     r3, r3, #1
   10484:       e1a00003        mov     r0, r3
   10488:       e28bd000        add     sp, fp, #0
   1048c:       e49db004        pop     {fp}            ; (ldr fp, [sp], #4)
   10490:       e12fff1e        bx      lr

</code></pre>
<p>The first things the function does is to store in the stack the current frame pointerâ€¦ in other words, the frame pointer of the function calling us. Then this function frame pointer is initialised to the current Stack Pointer value plus 0 in this case. We will see an example later when this is done differently, but for now we are just setting up our frame pointer to point to the top of of the stack.</p>
<p>Then we find the <code>sub sp,sp #12</code> that makes some room in the stackâ€¦ Iâ€™ll let up to you to figure out what this 12 value comes fromâ€¦ It is room for 3 wordsâ€¦ it doesnâ€™t make much sense to me at first glanceâ€¦ so I smell some fun ahead in order to figure this out.</p>
<p>Then we have the main function codeâ€¦ the code looks funny but if we enable optimisations we will not see most of the interesting things. Anyway, it allows us to see how ARM access local variablesâ€¦ remember the <code>[rbp-0xNN]</code> for Intel processors?. Sure, so taking into account that <code>fp</code> is the new <code>RBP</code>, <code>strb r3, [fp, #-5]</code> stores register <code>r3</code> on the stack frame position 5, and the <code>ldrb</code> loads it from that same position. So this is how local variables looks like for ARM.</p>
<p>Finally the value to be returned is stored in <code>r0</code> and the stack restored.</p>
<p>Note that, instead of using a <code>RET</code> instruction taking the return value from the stack, the code branches to the position indicated by the link register that, if you remember, was updated with the proper return address, when calling the function.</p>
<p>We will skip now <code>func2</code> as it doesnâ€™t give us much more information and letâ€™s go straight into <code>func3</code>.</p>
<h2>
<code>func3</code> for ARM</h2>
<p>Letâ€™s take a look to the assembly:</p>
<pre><code class="lang-auto">000104dc &lt;func3&gt;:
   104dc:       e92d4800        push    {fp, lr}
   104e0:       e28db004        add     fp, sp, #4
   104e4:       e24dd090        sub     sp, sp, #136    ; 0x88
   104e8:       e50b0090        str     r0, [fp, #-144] ; 0xffffff70
   104ec:       e50b1094        str     r1, [fp, #-148] ; 0xffffff6c
   104f0:       e59f3028        ldr     r3, [pc, #40]   ; 10520 &lt;func3+0x44&gt;
   104f4:       e5933000        ldr     r3, [r3]
   104f8:       e50b3008        str     r3, [fp, #-8]
   104fc:       e1a00000        nop                     ; (mov r0, r0)
   10500:       e59f3018        ldr     r3, [pc, #24]   ; 10520 &lt;func3+0x44&gt;
   10504:       e51b2008        ldr     r2, [fp, #-8]
   10508:       e5933000        ldr     r3, [r3]
   1050c:       e1520003        cmp     r2, r3
   10510:       0a000000        beq     10518 &lt;func3+0x3c&gt;
   10514:       ebffff8b        bl      10348 &lt;__stack_chk_fail@plt&gt;
   10518:       e24bd004        sub     sp, fp, #4
   1051c:       e8bd8800        pop     {fp, pc}
   10520:       00020f08        .word   0x00020f08

</code></pre>
<p>The first thing we must note is that the function prologue and epilogue are now different. For this function, the compiler has generated code to store the <code>fp</code> and <code>lr</code> registers in the stack (see the first pushâ€¦ yes, ARM allows you to push multiple registers in just one instruction). This means thatâ€¦ the return address will be stored in the stack and thereforeâ€¦ it can be overwrittenâ€¦ Yes, for a while you thought that smashing the stack will not work for ARM because the return address is stored in a registerâ€¦ donâ€™t you?</p>
<p>Actually, this works fine for calling just one function. In the general case, when a function is called and it also calls other functions (nested functions), we need to store the value of this register somewhere we can recover it at some point (actually when we return from the inner function), to return to the right place in the program. And the place for doing that is in the stackâ€¦ normally. What if we store <code>fp</code> and <code>lr</code> somewhereelse?.. May that mitigate buffer overflows?.. :think:</p>
<blockquote>
<p>ARM differentiates between leaf and non-leaf functions. A leaf function is a function that doesnâ€™t call any other function. Basically this means that we do not need to store the Link Register to return from the function (as far as we do not modify it in the function body). Non-leaf functions needs to store the return address stored in the Link Register and they do this usually in the stack frame pointed by register <code>fp</code>. There are also special instructions for calling those.</p>
</blockquote>
<p>Now, take a look the the epilogue. Instead or branching (jumping) as in <code>func1</code>, in this case we just pop <code>lr</code> directly on the Program Counter registerâ€¦ effectively changing the program flow.</p>
<p>We can also see how the buffer is allocated substracting a value from <code>sp</code>. Note that this is ARM 32bits (all opcodes are 32bits and everything is 32bits aligned) so the stack is likely 8 bytes aligned. You can try to check this by yourself</p>
<p>Finally, note that the canary implementation follows the same concept that we discussed for the Intel processorsâ€¦ it is just stored somewhere else</p>
<h1>The MIPS Case</h1>
<p>For completeness, less recompile our test programs for MIPS and check how all this is done for those processors:</p>
<pre><code class="lang-auto">$ mips-linux-gnu-gcc -o local_vars-mips local_vars.c
$ mips-linux-gnu-objdump -d local_vars-mips

</code></pre>
<h2>
<code>func1</code> for MIPS</h2>
<p>This is how <code>func1</code> for MIPS looks like:</p>
<pre><code class="lang-auto">004007b0 &lt;func1&gt;:
  4007b0:       27bdfff0        addiu   sp,sp,-16
  4007b4:       afbe000c        sw      s8,12(sp)
  4007b8:       03a0f025        move    s8,sp
  4007bc:       24020010        li      v0,16
  4007c0:       a3c20007        sb      v0,7(s8)
  4007c4:       93c20007        lbu     v0,7(s8)
  4007c8:       24420001        addiu   v0,v0,1
  4007cc:       03c0e825        move    sp,s8
  4007d0:       8fbe000c        lw      s8,12(sp)
  4007d4:       27bd0010        addiu   sp,sp,16
  4007d8:       03e00008        jr      ra
  4007dc:       00000000        nop

</code></pre>
<p>The first thing we notice is that registers are named differently. We already knew that, donâ€™t we? Just looking to the code, and without much knowledge about the MIPS architecture we can already identify the prologue and the epilogue of the function. The <code>sp</code> register is of course the Stack Pointer, and we see how space is allocated and free at the beginning and the end of the function.</p>
<p>Also, we can infer from the code that register <code>s8</code> is the one used as frame pointer, at least for this version of gcc. The prologue of the function adjusts <code>sp</code>, stores <code>s8</code> (our frame pointer) in the top of the stack and then sets <code>s8</code> to the bottom of the stack, so local variables are indexed with positive indexes.</p>
<p>The epilogue restores the <code>sp</code> value (frees memory <code>addiu sp,sp,16</code>), restores <code>s8</code> (<code>lw s8, 12(sp)</code> lw - <em>Load World</em>) and returns. As it happens with ARM, the return address (thatâ€™s where the <code>ra</code> register takes its name, I told you to remember that name) is stored in a register instead of in the stack, and return from a function is performed just jumping back to the content of <code>ra</code> (<code>jr</code> stands for <em>Jump Register</em>).</p>
<p>Just in case you are not familiar with the indexed notation used by <code>objdump</code> for MIPS. The value <code>7(s8)</code> means in Intel mnemonics <code>[s8 + 7]</code> as we already know that <code>s8</code> is our <code>RBP</code> for MIPS, we see the usual pattern to access local variables. Just note that in this case we first update <code>sp</code> and then we set <code>s8</code> instead of setting <code>s8</code> and then updating <code>sp</code> as we have seen for the Intel platform. This is way the MIPS code uses positive indexes and the intel one uses negative indexes.</p>
<h2>
<code>func3</code> for MIPS</h2>
<p><code>func3</code> is more interesting as we know, so letâ€™s take a look to how it looks like for a MIPS processor:</p>
<pre><code class="lang-auto">0040082c &lt;func3&gt;:
  40082c:       27bdff60        addiu   sp,sp,-160
  400830:       afbf009c        sw      ra,156(sp)
  400834:       afbe0098        sw      s8,152(sp)
  400838:       03a0f025        move    s8,sp
  40083c:       3c1c0042        lui     gp,0x42
  400840:       279c9010        addiu   gp,gp,-28656
  400844:       afbc0010        sw      gp,16(sp)
  400848:       afc400a0        sw      a0,160(s8)
  40084c:       afc500a4        sw      a1,164(s8)
  400850:       8f82804c        lw      v0,-32692(gp)
  400854:       8c420000        lw      v0,0(v0)
  400858:       afc20094        sw      v0,148(s8)
  40085c:       00000000        nop
  400860:       8f82804c        lw      v0,-32692(gp)
  400864:       8fc30094        lw      v1,148(s8)
  400868:       8c420000        lw      v0,0(v0)
  40086c:       10620005        beq     v1,v0,400884 &lt;func3+0x58&gt;
  400870:       00000000        nop
  400874:       8f828048        lw      v0,-32696(gp)
  400878:       0040c825        move    t9,v0
  40087c:       0320f809        jalr    t9
  400880:       00000000        nop
  400884:       03c0e825        move    sp,s8
  400888:       8fbf009c        lw      ra,156(sp)
  40088c:       8fbe0098        lw      s8,152(sp)
  400890:       27bd00a0        addiu   sp,sp,160
  400894:       03e00008        jr      ra
  400898:       00000000        nop

</code></pre>
<p>For <code>func3</code> as we had already seen for the previous architectures, the compiler generates code to store not just the frame pointer but also the return address. Also note the stack allocation size adjustment done by the compiler to keep properly alignment stack memory.</p>
<p>The function epilogue is the complementary. We restore <code>sp</code>, then recover the values for <code>ra</code> and <code>s8</code>â€¦ give the stack memory back, updating the <code>sp</code> register and finally returning to the value contained on <code>ra</code>.</p>
<p>The canaries are managed slightly differently, but overall we can see how the value is retrieved from a special memory location identified by the <code>gp</code> register. This register is intended to point to the middle of a 64K block of memory located in the heap and intended to store constants and local variablesâ€¦ Not the same thing that a segment register (remember <code>fs</code> on Intel) but fullfill the function.</p>
<h1>Conclusions</h1>
<p>This is it for this part. This time we had learn how functions are implemented and the role the stack play on software. Also we had also found out why buffer overflows are dangerous and how canaries can be used to detect those overflows and prevent the exploitation of those bugs.</p>
<p>Finally we took a look to how all this looks for ARM and MIPS just to find thatâ€¦ they work roughly the same way <img src="../../images/emoji/twitter/slight_smile.png%3Fv=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/LikeAction" />
<meta itemprop="userInteractionCount" content="21" />
<span class="post-likes">21 Likes</span>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/CommentAction" />
<meta itemprop="userInteractionCount" content="0" />
</div>
<div class="crawler-linkback-list" itemscope itemtype="http://schema.org/ItemList">
<div itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
<a itemprop="url" href="../programming-for-wanabes-x-file-details-in-asm/25843.html">Programming for Wanabes X. File details in asm</a>
<meta itemprop="position" content="7">
</div>
<div itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
<a itemprop="url" href="../programming-for-wanabes-ix-finding-files-in-asm/25794.html">Programming for Wanabes IX. Finding Files in asm</a>
<meta itemprop="position" content="8">
</div>
<div itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
<a itemprop="url" href="../programming-for-wanabes-viii-file-details/25738.html">Programming for Wanabes VIII. File Details</a>
<meta itemprop="position" content="9">
</div>
</div>
</div>
<div id="post_2" itemprop="comment" itemscope itemtype="http://schema.org/Comment" class="topic-body crawler-post">
<div class="crawler-post-meta">
<span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a itemprop="url" href="https://0x00sec.org/u/black_bit"><span itemprop="name">black_bit</span></a>
</span>
<link itemprop="mainEntityOfPage" href="22421.html">
<span class="crawler-post-infos">
<time itemprop="datePublished" datetime="2020-07-26T15:37:24Z" class="post-time">
July 26, 2020, 3:37pm
</time>
<meta itemprop="dateModified" content="2020-07-26T15:37:24Z">
<span itemprop="position">2</span>
</span>
</div>
<div class="post" itemprop="text">
<p>Woooooooooooooooooooooooooooooooooooooooooooooo!!! your awsome!!!</p>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/LikeAction" />
<meta itemprop="userInteractionCount" content="2" />
<span class="post-likes">2 Likes</span>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/CommentAction" />
<meta itemprop="userInteractionCount" content="0" />
</div>
</div>
<div id="post_3" itemprop="comment" itemscope itemtype="http://schema.org/Comment" class="topic-body crawler-post">
<div class="crawler-post-meta">
<span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a itemprop="url" href="https://0x00sec.org/u/Danus"><span itemprop="name">Danus</span></a>
</span>
<link itemprop="mainEntityOfPage" href="22421.html">
<span class="crawler-post-infos">
<time itemprop="datePublished" datetime="2020-07-27T08:15:30Z" class="post-time">
July 27, 2020, 8:15am
</time>
<meta itemprop="dateModified" content="2020-07-27T08:15:30Z">
<span itemprop="position">3</span>
</span>
</div>
<div class="post" itemprop="text">
<p>This is amazing, great job!</p>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/LikeAction" />
<meta itemprop="userInteractionCount" content="3" />
<span class="post-likes">3 Likes</span>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/CommentAction" />
<meta itemprop="userInteractionCount" content="0" />
</div>
</div>
<div id="post_4" itemprop="comment" itemscope itemtype="http://schema.org/Comment" class="topic-body crawler-post">
<div class="crawler-post-meta">
<span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a itemprop="url" href="https://0x00sec.org/u/messede"><span itemprop="name">messede</span></a>
</span>
<link itemprop="mainEntityOfPage" href="22421.html">
<span class="crawler-post-infos">
<time itemprop="datePublished" datetime="2020-08-11T03:40:09Z" class="post-time">
August 11, 2020, 3:40am
</time>
<meta itemprop="dateModified" content="2020-08-11T03:40:09Z">
<span itemprop="position">4</span>
</span>
</div>
<div class="post" itemprop="text">
<p><a class="mention" href="https://0x00sec.org/u/0x00pf">@0x00pf</a> you are not thanked enough , so thank you !</p>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/LikeAction" />
<meta itemprop="userInteractionCount" content="1" />
<span class="post-likes">1 Like</span>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/CommentAction" />
<meta itemprop="userInteractionCount" content="0" />
</div>
</div>
<div id="post_5" itemprop="comment" itemscope itemtype="http://schema.org/Comment" class="topic-body crawler-post">
<div class="crawler-post-meta">
<span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a itemprop="url" href="https://0x00sec.org/u/NotBackslash"><span itemprop="name">NotBackslash</span></a>
(backslash)
</span>
<link itemprop="mainEntityOfPage" href="22421.html">
<span class="crawler-post-infos">
<time itemprop="datePublished" datetime="2020-08-13T06:45:30Z" class="post-time">
August 13, 2020, 6:45am
</time>
<meta itemprop="dateModified" content="2020-08-13T06:45:30Z">
<span itemprop="position">5</span>
</span>
</div>
<div class="post" itemprop="text">
<p>Holy shitâ€¦ Great writeup, you should be proud of yourself.</p>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/LikeAction" />
<meta itemprop="userInteractionCount" content="2" />
<span class="post-likes">2 Likes</span>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/CommentAction" />
<meta itemprop="userInteractionCount" content="0" />
</div>
</div>
<div id="post_6" itemprop="comment" itemscope itemtype="http://schema.org/Comment" class="topic-body crawler-post">
<div class="crawler-post-meta">
<span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a itemprop="url" href="https://0x00sec.org/u/jeff"><span itemprop="name">jeff</span></a>
(jeff)
</span>
<link itemprop="mainEntityOfPage" href="22421.html">
<span class="crawler-post-infos">
<time itemprop="datePublished" datetime="2020-08-13T14:39:55Z" class="post-time">
August 13, 2020, 2:39pm
</time>
<meta itemprop="dateModified" content="2020-08-13T14:39:55Z">
<span itemprop="position">6</span>
</span>
</div>
<div class="post" itemprop="text">
<p>great content as always, nice to see back to writing articles again!</p>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/LikeAction" />
<meta itemprop="userInteractionCount" content="1" />
<span class="post-likes">1 Like</span>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/CommentAction" />
<meta itemprop="userInteractionCount" content="0" />
</div>
</div>
<div id="post_7" itemprop="comment" itemscope itemtype="http://schema.org/Comment" class="topic-body crawler-post">
<div class="crawler-post-meta">
<span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a itemprop="url" href="https://0x00sec.org/u/system"><span itemprop="name">system</span></a>
(system)
Closed
</span>
<link itemprop="mainEntityOfPage" href="22421.html">
<span class="crawler-post-infos">
<time itemprop="datePublished" datetime="2020-11-25T07:17:51Z" class="post-time">
November 25, 2020, 7:17am
</time>
<meta itemprop="dateModified" content="2020-11-25T07:17:51Z">
<span itemprop="position">7</span>
</span>
</div>
<div class="post" itemprop="text">
<p>This topic was automatically closed after 121 days. New replies are no longer allowed.</p>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/LikeAction" />
<meta itemprop="userInteractionCount" content="0" />
<span class="post-likes"></span>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/CommentAction" />
<meta itemprop="userInteractionCount" content="0" />
</div>
</div>
</div>
</div>
<footer class="container wrap">
<nav class="crawler-nav">
<ul>
<li itemscope itemtype="http://schema.org/SiteNavigationElement">
<span itemprop="name">
<a href="../../index.html" itemprop="url">Home </a>
</span>
</li>
<li itemscope itemtype="http://schema.org/SiteNavigationElement">
<span itemprop="name">
<a href="../../categories.html" itemprop="url">Categories </a>
</span>
</li>
<li itemscope itemtype="http://schema.org/SiteNavigationElement">
<span itemprop="name">
<a href="https://0x00sec.org/guidelines" itemprop="url">FAQ/Guidelines </a>
</span>
</li>
<li itemscope itemtype="http://schema.org/SiteNavigationElement">
<span itemprop="name">
<a href="../../tos.html" itemprop="url">Terms of Service </a>
</span>
</li>
<li itemscope itemtype="http://schema.org/SiteNavigationElement">
<span itemprop="name">
<a href="../../privacy.html" itemprop="url">Privacy Policy </a>
</span>
</li>
</ul>
</nav>
<p class="powered-by-link">Powered by <a href="https://www.discourse.org">Discourse</a>, best viewed with JavaScript enabled</p>
</footer>
<script src="https://instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>
</body>
</html>
