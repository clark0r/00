<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Rewriting LibC functions in malwares</title>
    <link>https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004</link>
    <description>Hello everyone;

I wonder why some malware dev, rewrite some libc functions in their malware, like strcat, strcpy, malloc ....

Thanks !!</description>
    
    <lastBuildDate>Mon, 26 Mar 2018 10:21:32 +0000</lastBuildDate>
    <category>Malware</category>
    <atom:link href="https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Rewriting LibC functions in malwares</title>
        <dc:creator><![CDATA[system]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 30 days. New replies are no longer allowed.</p>
          <p><a href="https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004/13">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004/13</link>
        <pubDate>Mon, 23 Apr 2018 13:07:33 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-6004-13</guid>
        <source url="https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004.rss">Rewriting LibC functions in malwares</source>
      </item>
      <item>
        <title>Rewriting LibC functions in malwares</title>
        <dc:creator><![CDATA[BlackYenii]]></dc:creator>
        <description><![CDATA[
            <p><a class="mention" href="https://d.clarkee.co.uk/u/dtm">@dtm</a> <a class="mention" href="https://d.clarkee.co.uk/u/0x00pf">@0x00pf</a> Thank youu very much <img src="https://0x00sec.org/images/emoji/twitter/smiley.png?v=9" title=":smiley:" class="emoji" alt=":smiley:"><img src="https://0x00sec.org/images/emoji/twitter/smiley.png?v=9" title=":smiley:" class="emoji" alt=":smiley:"><img src="https://0x00sec.org/images/emoji/twitter/smiley.png?v=9" title=":smiley:" class="emoji" alt=":smiley:"><img src="https://0x00sec.org/images/emoji/twitter/smiley.png?v=9" title=":smiley:" class="emoji" alt=":smiley:"><br>
I understand ^^</p>
          <p><a href="https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004/12">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004/12</link>
        <pubDate>Mon, 26 Mar 2018 10:21:32 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-6004-12</guid>
        <source url="https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004.rss">Rewriting LibC functions in malwares</source>
      </item>
      <item>
        <title>Rewriting LibC functions in malwares</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="BlackYenii" data-post="9" data-topic="6004">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://d.clarkee.co.uk/user_avatar/d.clarkee.co.uk/blackyenii/48/2505_2.png" class="avatar"> BlackYenii:</div>
<blockquote>
<p>does it have any relation with having a  position independent in memory?</p>
</blockquote>
</aside>
<p>It indeed makes things easier, if your program will be moving around in its own addressing space (or in another processes addressing space) and not just standing at the entry point specified in its ELF header (for GNU/Linux systems), then it is very handy to do not depend on anything external.</p>
<p>To better understand why, we need to roughly known a libc C function is invoked:</p>
<ul>
<li>Call an entry on a memory table (<code>PLT</code> <em>Procedure Linkage table</em>)</li>
<li>At the first invocation, the dynamic linker is fired to resolve the address of the function you want to call in the library (and even load the library if needed)</li>
<li>Then, the entry in that memory table is patched with the resolved address so, next time, it does not need to call the dynamic linker (you already know where the function is located).</li>
</ul>
<p>So, even in the stationary case (whenever all the symbols your program uses have been resolved), all your calls to a libc function goes through an indirection. For the gory details check theses two great post at 0x00sec</p>
<p><a href="https://0x00sec.org/t/linux-internals-the-art-of-symbol-resolution/1488" class="onebox" target="_blank" rel="noopener nofollow ugc">https://0x00sec.org/t/linux-internals-the-art-of-symbol-resolution/1488</a></p>
<p><a href="https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082" class="onebox" target="_blank" rel="noopener nofollow ugc">https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082</a></p>
<p>So, coming back to your question. Once the PLT table is resolved/updated, you can just call any libc function from any memory position, through that table. In order to make your program Position Independent  you need to let the compiler know, independently of the libraries you use. So, I do not see a big advantage on that side.</p>
<p>However, if you want your code to be loaded using non standard techniques (as it may happen with a virus or other malwares), having all your program self-contained makes things easier as you do not have to care about linking or resolving symbols… on the other hand, whatever functionality you need, you will have to implement your self/add to your program manually… Which, depending on what the program has to do may be quite some work…</p>
          <p><a href="https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004/11">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004/11</link>
        <pubDate>Mon, 26 Mar 2018 05:50:26 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-6004-11</guid>
        <source url="https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004.rss">Rewriting LibC functions in malwares</source>
      </item>
      <item>
        <title>Rewriting LibC functions in malwares</title>
        <dc:creator><![CDATA[dtm]]></dc:creator>
        <description><![CDATA[
            <p>In the Windows environment, using functions from libc (e.g. <code>memcpy</code>, <code>strcpy</code>) requires the <code>msvcrt.dll</code> library to be present in the process space which means that the binary must be linked with it in its import table assuming the source contains its direct usage (as opposed to dynamically retrieving it as aforementioned or by using the <code>GetProcAddress</code>/<code>LoadLibrary</code> pair but using these two functions also requires linking). The import table by itself is <em>not</em> position-independent but can be pseudo-independent with the reliance on another table structure known as the <em>relocation table</em>.</p>
<p>Depending on these two structures needs <em>more</em> information to be able to locate them. In a standard PE binary, the PE headers are responsible for describing the structure of the program which includes the import and relocation tables. To programmatically calculate these offsets requires the use of such data structure which only introduces more size and as <a class="mention" href="https://d.clarkee.co.uk/u/0x00pf">@0x00pf</a> mentioned, smaller sizes are ideal for viruses. To programmatically fix the offsets of the import table such that it is “position-independent” requires more code which in turn expands the size.</p>
<p>So as you can see, it’s just much simpler and effective to implement these functions yourself. The trade-off clearly isn’t worth it with libc. Shellcode is the way to go.</p>
          <p><a href="https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004/10">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004/10</link>
        <pubDate>Sun, 25 Mar 2018 23:46:53 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-6004-10</guid>
        <source url="https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004.rss">Rewriting LibC functions in malwares</source>
      </item>
      <item>
        <title>Rewriting LibC functions in malwares</title>
        <dc:creator><![CDATA[BlackYenii]]></dc:creator>
        <description><![CDATA[
            <p>Thanks <a class="mention" href="https://d.clarkee.co.uk/u/dtm">@dtm</a> and <a class="mention" href="https://d.clarkee.co.uk/u/0x00pf">@0x00pf</a> … does it have any relation with having a  position independent in memory?</p>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://github.githubassets.com/favicons/favicon.svg" class="site-icon" width="32" height="32">
      <a href="https://github.com/elfmaster/skeksi_virus" target="_blank" rel="noopener nofollow ugc">GitHub</a>
  </header>
  <article class="onebox-body">
    <img src="https://0x00sec.s3.amazonaws.com/original/2X/5/576c87448774e3e9c463e2ebfb47709cea74f01a.jpeg" class="thumbnail onebox-avatar" width="400" height="400">

<h3><a href="https://github.com/elfmaster/skeksi_virus" target="_blank" rel="noopener nofollow ugc">elfmaster/skeksi_virus</a></h3>

<p>Devestating and awesome Linux X86_64 ELF Virus. Contribute to elfmaster/skeksi_virus development by creating an account on GitHub.</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

          <p><a href="https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004/9">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004/9</link>
        <pubDate>Sun, 25 Mar 2018 22:06:48 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-6004-9</guid>
        <source url="https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004.rss">Rewriting LibC functions in malwares</source>
      </item>
      <item>
        <title>Rewriting LibC functions in malwares</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>On top of <a class="mention" href="https://d.clarkee.co.uk/u/dtm">@dtm</a> points I’d add:</p>
<ol start="3">
<li>Your binary will be way smaller which is, in general, a desirable feature for a malware</li>
</ol>
<p><em>I think point 2 is a very good reason</em></p>
          <p><a href="https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004/8">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004/8</link>
        <pubDate>Sun, 25 Mar 2018 07:43:27 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-6004-8</guid>
        <source url="https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004.rss">Rewriting LibC functions in malwares</source>
      </item>
      <item>
        <title>Rewriting LibC functions in malwares</title>
        <dc:creator><![CDATA[dtm]]></dc:creator>
        <description><![CDATA[
            <p>The only reasons I can think of for implementing your own functions would be the following:</p>
<ol>
<li>Evading signature-based or heuristic detection.</li>
</ol>
<p>Let’s say I have a keylogger and I want it to upload logs to my FTP server. If I directly link the executable such that functions like <code>FtpOpenFile</code> and <code>FtpPutFile</code> exist in the imports in plain text and can be seen to be used in the code section, it would be very suspicious. If I can replace them by implementing my own self-coded networking library that has an FTP protocol, it <em>could</em> reduce the chance of it being suspicious. This is probably not the reason for why the above samples implement their own libc functions because they wouldn’t be classified as potentially unwanted.</p>
<ol start="2">
<li>Reducing dependencies in the binary.</li>
</ol>
<p>Sometimes, dependencies are troublesome for malware that infects other objects. In the case of viruses, having as little dependencies is ideal because the environment of the host is considered to be volatile. What I mean by this is that if you select a host at random, there is no guarantee that the execution environment will contain what the virus may need to properly do its task, therefore, to eliminate dependency is to become entirely self-sufficient.</p>
<p>A very classical example of this is dynamically obtaining WinAPI functions by walking the process’ PEB’s executable modules under the assumption that <em>all</em> processes must have the <code>ntdll.dll</code> and <code>kernel32.dll</code> libraries present. Because of this, any malcode that lives in the process space of a host has access to whatever it needs to interact with the OS without having to rely on what already exists in the host’s environment.</p>
<p>Other than that, your guess is as good as mine.  ¯\_(ツ)_/¯</p>
          <p><a href="https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004/7">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004/7</link>
        <pubDate>Sun, 25 Mar 2018 01:30:08 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-6004-7</guid>
        <source url="https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004.rss">Rewriting LibC functions in malwares</source>
      </item>
      <item>
        <title>Rewriting LibC functions in malwares</title>
        <dc:creator><![CDATA[BlackYenii]]></dc:creator>
        <description><![CDATA[
            <p>Hope to have some clarifications from <a class="mention" href="https://d.clarkee.co.uk/u/dtm">@dtm</a> <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
          <p><a href="https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004/6">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004/6</link>
        <pubDate>Sat, 24 Mar 2018 21:10:33 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-6004-6</guid>
        <source url="https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004.rss">Rewriting LibC functions in malwares</source>
      </item>
      <item>
        <title>Rewriting LibC functions in malwares</title>
        <dc:creator><![CDATA[BlackYenii]]></dc:creator>
        <description><![CDATA[
            <p>First thanks for replying, but whats is the problem if IDA detect LibC functions ? They are not malicious …</p>
          <p><a href="https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004/5">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004/5</link>
        <pubDate>Sat, 24 Mar 2018 21:09:53 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-6004-5</guid>
        <source url="https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004.rss">Rewriting LibC functions in malwares</source>
      </item>
      <item>
        <title>Rewriting LibC functions in malwares</title>
        <dc:creator><![CDATA[Malware_Info]]></dc:creator>
        <description><![CDATA[
            <p>May be b’coz malware analysts heavily rely on FLIRT signatures,a feature provided by IDA,which actually finds libc functions in the assembly code and renames it with the library name.<br>
<a href="https://www.hex-rays.com/products/ida/tech/flirt/in_depth.shtml" class="onebox" target="_blank" rel="nofollow noopener">https://www.hex-rays.com/products/ida/tech/flirt/in_depth.shtml</a><br>
IDA relies on some tactics to find this libc functions,so defeat this techniques they should have written libc functions by hand.<br>
If i’m wrong plz correct me!</p>
          <p><a href="https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004/4">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004/4</link>
        <pubDate>Sat, 24 Mar 2018 14:30:41 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-6004-4</guid>
        <source url="https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004.rss">Rewriting LibC functions in malwares</source>
      </item>
      <item>
        <title>Rewriting LibC functions in malwares</title>
        <dc:creator><![CDATA[BlackYenii]]></dc:creator>
        <description><![CDATA[
            <p>Carberp :<br>
</p><aside class="onebox githubblob">
  <header class="source">
      <a href="https://github.com/nyx0/Carberp/blob/master/Source/Strings.cpp" target="_blank" rel="nofollow noopener">github.com</a>
  </header>
  <article class="onebox-body">
    <h4><a href="https://github.com/nyx0/Carberp/blob/master/Source/Strings.cpp" target="_blank" rel="nofollow noopener">nyx0/Carberp/blob/master/Source/Strings.cpp</a></h4>
<pre><code class="lang-cpp">#include &lt;windows.h&gt;

#include "Memory.h"
#include "GetApi.h"
#include "Strings.h"
#include "BotClasses.h"


#include "StrWildCmp.cpp"

DWORD WINAPI m_lstrncmp( const char *szstr1, const char *szstr2, int nlen )
{
	if ( !szstr1 || !szstr2 )
		return -1;

	DWORD dwReturn;

	__asm
	{
		pushad
</code></pre>

  This file has been truncated. <a href="https://github.com/nyx0/Carberp/blob/master/Source/Strings.cpp" target="_blank" rel="nofollow noopener">show original</a>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>
<br>
<aside class="onebox githubblob">
  <header class="source">
      <a href="https://github.com/nyx0/Carberp/blob/master/Source/Memory.cpp" target="_blank" rel="nofollow noopener">github.com</a>
  </header>
  <article class="onebox-body">
    <h4><a href="https://github.com/nyx0/Carberp/blob/master/Source/Memory.cpp" target="_blank" rel="nofollow noopener">nyx0/Carberp/blob/master/Source/Memory.cpp</a></h4>
<pre><code class="lang-cpp">#include &lt;windows.h&gt;

#include "Memory.h"
#include "GetApi.h"
#include "Utils.h"
#include "ntdll.h"

//#include "BotDebug.h"

void *m_memset( void *szBuffer, DWORD dwSym, DWORD dwLen )
{
	if ( !szBuffer )
		return NULL;

	__asm
	{
		pushad
		mov		edi,[szBuffer]
		mov		ecx,[dwLen]
		mov		eax,[dwSym]
</code></pre>

  This file has been truncated. <a href="https://github.com/nyx0/Carberp/blob/master/Source/Memory.cpp" target="_blank" rel="nofollow noopener">show original</a>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>
<p></p>
<p>A virus from Github<br>
</p><aside class="onebox githubblob">
  <header class="source">
      <a href="https://github.com/elfmaster/skeksi_virus/blob/master/virus.c" target="_blank" rel="nofollow noopener">github.com</a>
  </header>
  <article class="onebox-body">
    <h4><a href="https://github.com/elfmaster/skeksi_virus/blob/master/virus.c" target="_blank" rel="nofollow noopener">elfmaster/skeksi_virus/blob/master/virus.c</a></h4>
<pre><code class="lang-c">/*
 * Skeksi Virus v0.1 - infects files that are ELF_X86_64 Linux ET_EXEC's
 * Written by ElfMaster - ryan@bitlackeys.org
 *
 * Compile:
 * gcc -g -O0 -DANTIDEBUG -DINFECT_PLTGOT  -fno-stack-protector -c virus.c -fpic -o virus.o
 * gcc -N -fno-stack-protector -nostdlib virus.o -o virus
 *
 * Using -DDEBUG will allow Virus to print debug output
 *
 * Usage:
 * ./virus
 *
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
</code></pre>

  This file has been truncated. <a href="https://github.com/elfmaster/skeksi_virus/blob/master/virus.c" target="_blank" rel="nofollow noopener">show original</a>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>
<p></p>
          <p><a href="https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004/3">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004/3</link>
        <pubDate>Sat, 24 Mar 2018 14:00:09 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-6004-3</guid>
        <source url="https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004.rss">Rewriting LibC functions in malwares</source>
      </item>
      <item>
        <title>Rewriting LibC functions in malwares</title>
        <dc:creator><![CDATA[oaktree]]></dc:creator>
        <description><![CDATA[
            <p>Where have you seen this? Mentioning some examples would be great.</p>
          <p><a href="https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004/2">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004/2</link>
        <pubDate>Sat, 24 Mar 2018 13:20:33 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-6004-2</guid>
        <source url="https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004.rss">Rewriting LibC functions in malwares</source>
      </item>
      <item>
        <title>Rewriting LibC functions in malwares</title>
        <dc:creator><![CDATA[BlackYenii]]></dc:creator>
        <description><![CDATA[
            <p>Hello everyone;</p>
<p>I wonder why some malware dev, rewrite some libc functions in their malware, like strcat, strcpy, malloc …</p>
<p>Thanks !!</p>
          <p><a href="https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004/1">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004/1</link>
        <pubDate>Sat, 24 Mar 2018 13:07:19 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-6004-1</guid>
        <source url="https://d.clarkee.co.uk/t/rewriting-libc-functions-in-malwares/6004.rss">Rewriting LibC functions in malwares</source>
      </item>
  </channel>
</rss>
