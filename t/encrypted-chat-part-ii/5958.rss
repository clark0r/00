<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Encrypted Chat: Part II</title>
    <link>https://0x00sec.org/t/encrypted-chat-part-ii/5958</link>
    <description>_This post is part two of a multi-part series. If you haven&#39;t already, please read part one here: [Encrypted Chat: Part I](https://0x00sec.org/t/encrypted-chat-part-i/5839)_

Welcome Back
===========
After gaining an understanding of the concepts behind my encrypted chat server, we&#39;re now ready to take a closer look at the code to see how the client and server operate.

Part Two: The Code
---------------------------
These are the files that make up the encrypted chat project:

    File         Description                     Category
    ----------------------------------------------------------------
    client.py    Chat Client                     Networking
    server.py    Chat Server                     Networking, Control
    dhke.py      Diffie-Hellman Key Exchange     Crypto
    cipher.py    AES Encryption and Decryption   Crypto
    cli.py       Command-Line Interface          Interface

The client and the server share a lot of the same code, especially when it comes to the encryption and decryption of messages. However, since the server handles the majority of the processing, we&#39;ll start there. 

_I&#39;m only going to be showing the important bits so therefore some trivial code will be omitted (indicated by ...). The full code can be found [here](https://github.com/spec-sec/SecureChat)._

2A. Server Code - Key Exchange
--------------------------------------------

[server.py](https://github.com/spec-sec/SecureChat/blob/master/server.py)
--------------------------------------------------------------------------------------------------
```py
# Inside Server Class
def __init__(self, host=&#39;127.0.0.1&#39;, port=DEFAULT_PORT):
    ...
    self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    self.dh_params = M2DH.gen_params(DH_SIZE, 2)
    ...
```

We start by creating a new socket that the server will communicate on. 

```py
self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
```

We indicate the use of the [IPv4 address family](https://en.wikipedia.org/wiki/IPv4#Addressing) (e.g. `0x00sec.org`, `74.125.136.94`) with `socket.AF_INET`, and the use of [TCP](https://en.wikipedia.org/wiki/Transmission_Control_Protocol) with `socket.SOCK_STREAM`.

Next, we generate the parameters for the Diffie-Hellman key exchange with the `DH` module from `m2crypto`.

```py
self.dh_params = M2DH.gen_params(DH_SIZE, 2)
```

Remember that we needed to create two public values: a prime modulus _p_ and prime base _g_. When we indicate the size (in bits) of the desired prime (a minimum of 2048 bits for the shared prime is recommended) and which generator we want to use, this function returns a class containing _p_ and _g_. It does this using [OpenSSL](https://www.openssl.org), a &quot;robust, commercial-grade, and full-featured toolkit for the Transport Layer Security (TLS) and Secure Sockets Layer (SSL) protocols&quot; and a &quot;general-purpose cryptography library.&quot; You&#39;ll find many other programs use this library, such as [OpenVPN](https://openvpn.net). 

We can now wait for new clients to connect, with which we will attempt Diffie-Hellman key exchange and listen for their incoming encrypted messages.

```py
while True:
    connection, address = self.socket.accept()
    client = Client(self, connection, address)
    ...
    self.clients.append(client)
    ...
    threading.Thread(target=self.listen, args=(client, )).start()
```

We use our socket to accept the next incoming connection (this function is blocking) and initialize it as a new client. Let&#39;s take a look at what happens when we do that:

```py
# Inside Client Class (this is the client object the server uses)
def __init__(self, server, connection, address):
    ...
    self.key = self.dh(server.dh_params)
```
       
The client class takes in a server (to which the client belongs), a socket connection, and address in the format `(ip_address, port)`. It then calls `dh()` to generate the shared key.

```py
# Inside Client Class
def dh(self, dh_params):
    &quot;&quot;&quot;
    Perform Diffie-Hellman Key Exchange with a client.
    :param dh_params: p and g generated by DH
    :return shared_key: shared encryption key for AES
    &quot;&quot;&quot;
    # p: shared prime
    p = DH.b2i(dh_params.p)
    # g: primitive root modulo
    g = DH.b2i(dh_params.g)
    # a: randomized private key
    a = DH.gen_private_key()
    # Generate public key from p, g, and a
    public_key = DH.gen_public_key(g, a, p)
    # Create a DH message to send to client as bytes
    dh_message = bytes(DH(p, g, public_key))
    self.connection.sendall(dh_message)
    # Receive public key from client as bytes
    try:
        response = self.connection.recv(LEN_PK)
    except ConnectionError:
        print(&quot;Key Exchange with {} failed&quot;.format(self.address[0]))
        return None
    client_key = DH.b2i(response)
    # Calculate shared key with newly received client key
    shared_key = DH.get_shared_key(client_key, a, p)
    return shared_key
```

First, the method converts the _p_ and _g_ parameters from bytes to integers with `DH.b2i`, located in `dhke.py`. It then generates a random private key _a_ (also an integer). The server&#39;s public key for this exchange is calculated by raising _g_ to the power of _a_ and modulo-ing the result by _p_ with `DH.gen_public_key()`.

```py
def gen_public_key(g, private, p):
    # g^private % p
    return pow(g, private, p)
```

Now it can use the values _p_, _g_, and _public_key_ to construct a public message to send to the client. 

_**Note: the client needs these three values to generate its own public key_

The following line creates a new `DH` object and converts it to bytes:

```py
dh_message = bytes(DH(p, g, public_key))
```

We can see how the three variables are encoded into bytes in the `__bytes__` method of `DH`:

```py
def __bytes__(self):
    &quot;&quot;&quot;
    Convert DH message to bytes.
    :return: packaged DH message as bytes
    +-------+-----------+------------+
    | Prime | Generator | Public Key |
    |  1024 |    16     |    1024    |
    +-------+-----------+------------+
    &quot;&quot;&quot;
    prm = self.package(self.p, LEN_PRIME)
    gen = self.package(self.g, LEN_GEN)
    pbk = self.package(self.pk, LEN_PK)
    return prm + gen + pbk
```

Since we need a standardized message format for the client to unpack, the first 1024 bytes belong to _p_, the following 16 to _g_, and the last 1024 to the _public key_. The `package` method just converts the integer variable to bytes and adds padding until it hits the desired length:

```py
def package(i, length):
    &quot;&quot;&quot;
    Package an integer as a bytes object of length &quot;length&quot;.
    :param i: integer to be package
    :param length: desired length of the bytes object
    :return: bytes representation of the integer
    &quot;&quot;&quot;
    # Convert i to hex and remove &#39;0x&#39; from the left
    i_hex = hex(i)[2:]
    # Make the length of i_hex a multiple of 2
    if len(i_hex) % 2 != 0:
        i_hex = &#39;0&#39; + i_hex
    # Convert hex string into bytes
    i_bytes = binascii.unhexlify(i_hex)
    # Check to make sure bytes to not exceed the max length
    len_i = len(i_bytes)
    if len_i &gt; length:
        raise InvalidDH(&quot;Length Exceeds Maximum of {}&quot;.format(length))
    # Generate padding for the remaining space on the left
    i_padding = bytes(length - len_i)
    return i_padding + i_bytes
```

With the message all packaged up, we send it over to the client and wait for a response with the client&#39;s public key:

```py
self.connection.sendall(dh_message)
try:
    response = self.connection.recv(LEN_PK)
except ConnectionError:
    print(&quot;Key Exchange with {} failed&quot;.format(self.address[0]))
    return None
client_key = DH.b2i(response)
```

We then convert the response from bytes to an integer and pass it into the `DH.get_shared_key()` method with our own private key _a_ and the shared prime _p_:

```py
shared_key = DH.get_shared_key(client_key, a, p)
```

`get_shared_key()` calculates `(client_key ^ a) % p`, converts the results to a hex string, and passes it through `sha256` to standardize its length:

```py
def get_shared_key(public, private, p):
    &quot;&quot;&quot;
    Calculate a shared key from a foreign public key, a local private
    key, and a shared prime.
    :param public: public key as an integer
    :param private: private key as an integer
    :param p: prime number
    :return: shared key as a 256-bit bytes object
    &quot;&quot;&quot;
    s = pow(public, private, p)
    s_hex = hex(s)[2:]
    # Make the length of s_hex a multiple of 2
    if len(s_hex) % 2 != 0:
        s_hex = &#39;0&#39; + s_hex
    # Convert hex to bytes
    s_bytes = binascii.unhexlify(s_hex)
    # Hash and return the hex result
    return sha256(s_bytes).digest()
```

Finally, we&#39;ve got a shared key! That&#39;s pretty cool, but of course it was a little more complicated in practice than it was in theory. Now, where were we?

With the key declared, we have just finished initializing a client within the server. 

```py
client = Client(self, connection, address)
...
# Add client to list of clients on server
self.clients.append(client)
...
# Listen for incoming messages from client
threading.Thread(target=self.listen, args=(client, )).start()
```

In a new thread we listen for income encrypted messages from the client, decrypt them, and broadcast them (re-encrypted) to every other client on the server with `self.listen`.

This post is already long enough as-is, so I&#39;ll stop here for now. Check in next time when we&#39;ll look at how the server processes messages and maybe see what&#39;s going on with the client. Thanks for reading!</description>
    
    <lastBuildDate>Thu, 22 Mar 2018 04:45:19 +0000</lastBuildDate>
    <category>Programming</category>
    <atom:link href="https://0x00sec.org/t/encrypted-chat-part-ii/5958.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Encrypted Chat: Part II</title>
        <dc:creator><![CDATA[system]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 30 days. New replies are no longer allowed.</p>
          <p><a href="https://0x00sec.org/t/encrypted-chat-part-ii/5958/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/encrypted-chat-part-ii/5958/3</link>
        <pubDate>Sat, 21 Apr 2018 00:12:24 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-5958-3</guid>
        <source url="https://0x00sec.org/t/encrypted-chat-part-ii/5958.rss">Encrypted Chat: Part II</source>
      </item>
      <item>
        <title>Encrypted Chat: Part II</title>
        <dc:creator><![CDATA[johnmarston]]></dc:creator>
        <description><![CDATA[
            <p>Awesome post! I appreciate how you went into some detail about the implementation of Diffie-Hellman. Looking forward to the next segment about the server <img src="https://0x00sec.org/images/emoji/twitter/+1/6.png?v=9" title=":+1:t6:" class="emoji" alt=":+1:t6:"></p>
          <p><a href="https://0x00sec.org/t/encrypted-chat-part-ii/5958/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/encrypted-chat-part-ii/5958/2</link>
        <pubDate>Thu, 22 Mar 2018 04:45:19 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-5958-2</guid>
        <source url="https://0x00sec.org/t/encrypted-chat-part-ii/5958.rss">Encrypted Chat: Part II</source>
      </item>
      <item>
        <title>Encrypted Chat: Part II</title>
        <dc:creator><![CDATA[spec]]></dc:creator>
        <description><![CDATA[
            <p><em>This post is part two of a multi-part series. If you haven’t already, please read part one here: <a href="https://0x00sec.org/t/encrypted-chat-part-i/5839">Encrypted Chat: Part I</a></em></p>
<h1>Welcome Back</h1>
<p>After gaining an understanding of the concepts behind my encrypted chat server, we’re now ready to take a closer look at the code to see how the client and server operate.</p>
<h2>Part Two: The Code</h2>
<p>These are the files that make up the encrypted chat project:</p>
<pre><code>File         Description                     Category
----------------------------------------------------------------
client.py    Chat Client                     Networking
server.py    Chat Server                     Networking, Control
dhke.py      Diffie-Hellman Key Exchange     Crypto
cipher.py    AES Encryption and Decryption   Crypto
cli.py       Command-Line Interface          Interface
</code></pre>
<p>The client and the server share a lot of the same code, especially when it comes to the encryption and decryption of messages. However, since the server handles the majority of the processing, we’ll start there.</p>
<p><em>I’m only going to be showing the important bits so therefore some trivial code will be omitted (indicated by …). The full code can be found <a href="https://github.com/spec-sec/SecureChat" rel="nofollow noopener">here</a>.</em></p>
<h2>2A. Server Code - Key Exchange</h2>
<h2><a href="https://github.com/spec-sec/SecureChat/blob/master/server.py" rel="nofollow noopener">server.py</a></h2>
<pre><code class="lang-auto"># Inside Server Class
def __init__(self, host='127.0.0.1', port=DEFAULT_PORT):
    ...
    self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    self.dh_params = M2DH.gen_params(DH_SIZE, 2)
    ...
</code></pre>
<p>We start by creating a new socket that the server will communicate on.</p>
<pre><code class="lang-auto">self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
</code></pre>
<p>We indicate the use of the <a href="https://en.wikipedia.org/wiki/IPv4#Addressing" rel="nofollow noopener">IPv4 address family</a> (e.g. <code>0x00sec.org</code>, <code>74.125.136.94</code>) with <code>socket.AF_INET</code>, and the use of <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol" rel="nofollow noopener">TCP</a> with <code>socket.SOCK_STREAM</code>.</p>
<p>Next, we generate the parameters for the Diffie-Hellman key exchange with the <code>DH</code> module from <code>m2crypto</code>.</p>
<pre><code class="lang-auto">self.dh_params = M2DH.gen_params(DH_SIZE, 2)
</code></pre>
<p>Remember that we needed to create two public values: a prime modulus <em>p</em> and prime base <em>g</em>. When we indicate the size (in bits) of the desired prime (a minimum of 2048 bits for the shared prime is recommended) and which generator we want to use, this function returns a class containing <em>p</em> and <em>g</em>. It does this using <a href="https://www.openssl.org" rel="nofollow noopener">OpenSSL</a>, a “robust, commercial-grade, and full-featured toolkit for the Transport Layer Security (TLS) and Secure Sockets Layer (SSL) protocols” and a “general-purpose cryptography library.” You’ll find many other programs use this library, such as <a href="https://openvpn.net" rel="nofollow noopener">OpenVPN</a>.</p>
<p>We can now wait for new clients to connect, with which we will attempt Diffie-Hellman key exchange and listen for their incoming encrypted messages.</p>
<pre><code class="lang-auto">while True:
    connection, address = self.socket.accept()
    client = Client(self, connection, address)
    ...
    self.clients.append(client)
    ...
    threading.Thread(target=self.listen, args=(client, )).start()
</code></pre>
<p>We use our socket to accept the next incoming connection (this function is blocking) and initialize it as a new client. Let’s take a look at what happens when we do that:</p>
<pre><code class="lang-auto"># Inside Client Class (this is the client object the server uses)
def __init__(self, server, connection, address):
    ...
    self.key = self.dh(server.dh_params)
</code></pre>
<p>The client class takes in a server (to which the client belongs), a socket connection, and address in the format <code>(ip_address, port)</code>. It then calls <code>dh()</code> to generate the shared key.</p>
<pre><code class="lang-auto"># Inside Client Class
def dh(self, dh_params):
    """
    Perform Diffie-Hellman Key Exchange with a client.
    :param dh_params: p and g generated by DH
    :return shared_key: shared encryption key for AES
    """
    # p: shared prime
    p = DH.b2i(dh_params.p)
    # g: primitive root modulo
    g = DH.b2i(dh_params.g)
    # a: randomized private key
    a = DH.gen_private_key()
    # Generate public key from p, g, and a
    public_key = DH.gen_public_key(g, a, p)
    # Create a DH message to send to client as bytes
    dh_message = bytes(DH(p, g, public_key))
    self.connection.sendall(dh_message)
    # Receive public key from client as bytes
    try:
        response = self.connection.recv(LEN_PK)
    except ConnectionError:
        print("Key Exchange with {} failed".format(self.address[0]))
        return None
    client_key = DH.b2i(response)
    # Calculate shared key with newly received client key
    shared_key = DH.get_shared_key(client_key, a, p)
    return shared_key
</code></pre>
<p>First, the method converts the <em>p</em> and <em>g</em> parameters from bytes to integers with <code>DH.b2i</code>, located in <code>dhke.py</code>. It then generates a random private key <em>a</em> (also an integer). The server’s public key for this exchange is calculated by raising <em>g</em> to the power of <em>a</em> and modulo-ing the result by <em>p</em> with <code>DH.gen_public_key()</code>.</p>
<pre><code class="lang-auto">def gen_public_key(g, private, p):
    # g^private % p
    return pow(g, private, p)
</code></pre>
<p>Now it can use the values <em>p</em>, <em>g</em>, and <em>public_key</em> to construct a public message to send to the client.</p>
<p><em>**Note: the client needs these three values to generate its own public key</em></p>
<p>The following line creates a new <code>DH</code> object and converts it to bytes:</p>
<pre><code class="lang-auto">dh_message = bytes(DH(p, g, public_key))
</code></pre>
<p>We can see how the three variables are encoded into bytes in the <code>__bytes__</code> method of <code>DH</code>:</p>
<pre><code class="lang-auto">def __bytes__(self):
    """
    Convert DH message to bytes.
    :return: packaged DH message as bytes
    +-------+-----------+------------+
    | Prime | Generator | Public Key |
    |  1024 |    16     |    1024    |
    +-------+-----------+------------+
    """
    prm = self.package(self.p, LEN_PRIME)
    gen = self.package(self.g, LEN_GEN)
    pbk = self.package(self.pk, LEN_PK)
    return prm + gen + pbk
</code></pre>
<p>Since we need a standardized message format for the client to unpack, the first 1024 bytes belong to <em>p</em>, the following 16 to <em>g</em>, and the last 1024 to the <em>public key</em>. The <code>package</code> method just converts the integer variable to bytes and adds padding until it hits the desired length:</p>
<pre><code class="lang-auto">def package(i, length):
    """
    Package an integer as a bytes object of length "length".
    :param i: integer to be package
    :param length: desired length of the bytes object
    :return: bytes representation of the integer
    """
    # Convert i to hex and remove '0x' from the left
    i_hex = hex(i)[2:]
    # Make the length of i_hex a multiple of 2
    if len(i_hex) % 2 != 0:
        i_hex = '0' + i_hex
    # Convert hex string into bytes
    i_bytes = binascii.unhexlify(i_hex)
    # Check to make sure bytes to not exceed the max length
    len_i = len(i_bytes)
    if len_i &gt; length:
        raise InvalidDH("Length Exceeds Maximum of {}".format(length))
    # Generate padding for the remaining space on the left
    i_padding = bytes(length - len_i)
    return i_padding + i_bytes
</code></pre>
<p>With the message all packaged up, we send it over to the client and wait for a response with the client’s public key:</p>
<pre><code class="lang-auto">self.connection.sendall(dh_message)
try:
    response = self.connection.recv(LEN_PK)
except ConnectionError:
    print("Key Exchange with {} failed".format(self.address[0]))
    return None
client_key = DH.b2i(response)
</code></pre>
<p>We then convert the response from bytes to an integer and pass it into the <code>DH.get_shared_key()</code> method with our own private key <em>a</em> and the shared prime <em>p</em>:</p>
<pre><code class="lang-auto">shared_key = DH.get_shared_key(client_key, a, p)
</code></pre>
<p><code>get_shared_key()</code> calculates <code>(client_key ^ a) % p</code>, converts the results to a hex string, and passes it through <code>sha256</code> to standardize its length:</p>
<pre><code class="lang-auto">def get_shared_key(public, private, p):
    """
    Calculate a shared key from a foreign public key, a local private
    key, and a shared prime.
    :param public: public key as an integer
    :param private: private key as an integer
    :param p: prime number
    :return: shared key as a 256-bit bytes object
    """
    s = pow(public, private, p)
    s_hex = hex(s)[2:]
    # Make the length of s_hex a multiple of 2
    if len(s_hex) % 2 != 0:
        s_hex = '0' + s_hex
    # Convert hex to bytes
    s_bytes = binascii.unhexlify(s_hex)
    # Hash and return the hex result
    return sha256(s_bytes).digest()
</code></pre>
<p>Finally, we’ve got a shared key! That’s pretty cool, but of course it was a little more complicated in practice than it was in theory. Now, where were we?</p>
<p>With the key declared, we have just finished initializing a client within the server.</p>
<pre><code class="lang-auto">client = Client(self, connection, address)
...
# Add client to list of clients on server
self.clients.append(client)
...
# Listen for incoming messages from client
threading.Thread(target=self.listen, args=(client, )).start()
</code></pre>
<p>In a new thread we listen for income encrypted messages from the client, decrypt them, and broadcast them (re-encrypted) to every other client on the server with <code>self.listen</code>.</p>
<p>This post is already long enough as-is, so I’ll stop here for now. Check in next time when we’ll look at how the server processes messages and maybe see what’s going on with the client. Thanks for reading!</p>
          <p><a href="https://0x00sec.org/t/encrypted-chat-part-ii/5958/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/encrypted-chat-part-ii/5958/1</link>
        <pubDate>Thu, 22 Mar 2018 00:12:21 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-5958-1</guid>
        <source url="https://0x00sec.org/t/encrypted-chat-part-ii/5958.rss">Encrypted Chat: Part II</source>
      </item>
  </channel>
</rss>
