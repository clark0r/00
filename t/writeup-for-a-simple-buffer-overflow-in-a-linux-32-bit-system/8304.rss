<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Writeup for a simple buffer overflow in a linux 32 bit system</title>
    <link>https://0x00sec.org/t/writeup-for-a-simple-buffer-overflow-in-a-linux-32-bit-system/8304</link>
    <description>This is a writeup on the simplest exploitable binary (buffer overflow, 32 bit, no ASLR, executable stack) but with (I think) a different approach with respect to the usual writeups.

In particular, how to calculate the address of a buffer knowing the environment variables contents.

The post is here: https://ktln2.org/2018/08/13/pratical-approach-exploitation/</description>
    
    <lastBuildDate>Wed, 29 Aug 2018 16:33:32 +0000</lastBuildDate>
    <category>Beginner Guides</category>
    <atom:link href="https://0x00sec.org/t/writeup-for-a-simple-buffer-overflow-in-a-linux-32-bit-system/8304.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Writeup for a simple buffer overflow in a linux 32 bit system</title>
        <dc:creator><![CDATA[colental]]></dc:creator>
        <description><![CDATA[
            <p>Excellent article - it really helped me understand the fundamentals of buffer overflows. Thanks for sharing.</p>
          <p><a href="https://0x00sec.org/t/writeup-for-a-simple-buffer-overflow-in-a-linux-32-bit-system/8304/8">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/writeup-for-a-simple-buffer-overflow-in-a-linux-32-bit-system/8304/8</link>
        <pubDate>Wed, 29 Aug 2018 16:33:32 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-8304-8</guid>
        <source url="https://0x00sec.org/t/writeup-for-a-simple-buffer-overflow-in-a-linux-32-bit-system/8304.rss">Writeup for a simple buffer overflow in a linux 32 bit system</source>
      </item>
      <item>
        <title>Writeup for a simple buffer overflow in a linux 32 bit system</title>
        <dc:creator><![CDATA[Techno_Forg]]></dc:creator>
        <description><![CDATA[
            <p>I was speaking of ASLR, but couldn’t recall the exact name… lololol. I will look into Protostar since I have heard much great things about it.</p>
          <p><a href="https://0x00sec.org/t/writeup-for-a-simple-buffer-overflow-in-a-linux-32-bit-system/8304/7">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/writeup-for-a-simple-buffer-overflow-in-a-linux-32-bit-system/8304/7</link>
        <pubDate>Tue, 28 Aug 2018 21:32:30 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-8304-7</guid>
        <source url="https://0x00sec.org/t/writeup-for-a-simple-buffer-overflow-in-a-linux-32-bit-system/8304.rss">Writeup for a simple buffer overflow in a linux 32 bit system</source>
      </item>
      <item>
        <title>Writeup for a simple buffer overflow in a linux 32 bit system</title>
        <dc:creator><![CDATA[Baud]]></dc:creator>
        <description><![CDATA[
            <p>There are hardware protections such as the NX bit but they are supported by x86 architectures as well, they’re not exclusives of x64. If you want to practice buffer overflows on an unprotected system you should try Protostar, but you’ll have to write all your exploits for a x86 system. It’s also possible to disable every protection manually if you want to play with x64 exploitation.</p>
<p>The protections the author mentioned (I have the book too) were non executable stacks (NX) and address randomization (ASLR), Protostar doesn’t have any of the two on purpose.</p>
          <p><a href="https://0x00sec.org/t/writeup-for-a-simple-buffer-overflow-in-a-linux-32-bit-system/8304/6">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/writeup-for-a-simple-buffer-overflow-in-a-linux-32-bit-system/8304/6</link>
        <pubDate>Tue, 28 Aug 2018 16:08:51 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-8304-6</guid>
        <source url="https://0x00sec.org/t/writeup-for-a-simple-buffer-overflow-in-a-linux-32-bit-system/8304.rss">Writeup for a simple buffer overflow in a linux 32 bit system</source>
      </item>
      <item>
        <title>Writeup for a simple buffer overflow in a linux 32 bit system</title>
        <dc:creator><![CDATA[gipi]]></dc:creator>
        <description><![CDATA[
            <p>There are a certain numbers of protections in modern systems, also for 32 bit architectures.</p>
<p>In my post I don’t explain too much since the compilation flags used to generate the binary are such that the simplest memory configuration is created (i.e. executable stack, not randomized address, etc…) and seems unnecessary to me explain unncesserary stuffs.</p>
<p>In the future when I’ll need to explain the different memory models of a modern binary I’ll introduce them with some explanation.</p>
          <p><a href="https://0x00sec.org/t/writeup-for-a-simple-buffer-overflow-in-a-linux-32-bit-system/8304/5">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/writeup-for-a-simple-buffer-overflow-in-a-linux-32-bit-system/8304/5</link>
        <pubDate>Tue, 28 Aug 2018 15:04:41 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-8304-5</guid>
        <source url="https://0x00sec.org/t/writeup-for-a-simple-buffer-overflow-in-a-linux-32-bit-system/8304.rss">Writeup for a simple buffer overflow in a linux 32 bit system</source>
      </item>
      <item>
        <title>Writeup for a simple buffer overflow in a linux 32 bit system</title>
        <dc:creator><![CDATA[Techno_Forg]]></dc:creator>
        <description><![CDATA[
            <p>Hi, just wondering this but doesn’t x64 architecture have a protection against shellcode or something like that? Been working on The Art of Exploitation and they’ve mentioned something about a protection in the kernel to prevent abuse or something… don’t quote me on that. lololol.</p>
          <p><a href="https://0x00sec.org/t/writeup-for-a-simple-buffer-overflow-in-a-linux-32-bit-system/8304/4">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/writeup-for-a-simple-buffer-overflow-in-a-linux-32-bit-system/8304/4</link>
        <pubDate>Tue, 28 Aug 2018 14:36:19 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-8304-4</guid>
        <source url="https://0x00sec.org/t/writeup-for-a-simple-buffer-overflow-in-a-linux-32-bit-system/8304.rss">Writeup for a simple buffer overflow in a linux 32 bit system</source>
      </item>
      <item>
        <title>Writeup for a simple buffer overflow in a linux 32 bit system</title>
        <dc:creator><![CDATA[gipi]]></dc:creator>
        <description><![CDATA[
            <p>thank you for the feedback</p>
<p>I’m using a 32bit architecture mainly because it’s the simplest to attack and I have in mind to create a series of posts exploring the different “computational models” and the ways of attacking them. I would like to summarize my knowledge with a little bit of pratical and theoretical approach.</p>
<p>P.S: I have already practiced exploiting 64bit architectures but also more “exotic” ones, like ARM and MIPS; also using ROP techniques.</p>
          <p><a href="https://0x00sec.org/t/writeup-for-a-simple-buffer-overflow-in-a-linux-32-bit-system/8304/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/writeup-for-a-simple-buffer-overflow-in-a-linux-32-bit-system/8304/3</link>
        <pubDate>Mon, 27 Aug 2018 20:13:20 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-8304-3</guid>
        <source url="https://0x00sec.org/t/writeup-for-a-simple-buffer-overflow-in-a-linux-32-bit-system/8304.rss">Writeup for a simple buffer overflow in a linux 32 bit system</source>
      </item>
      <item>
        <title>Writeup for a simple buffer overflow in a linux 32 bit system</title>
        <dc:creator><![CDATA[Baud]]></dc:creator>
        <description><![CDATA[
            <p>G’evening fellow Italian! I have to say, your article was probably one of the clearest I’ve seen regarding basic buffer overflows, very beginner-friendly. Plus, that environment variable tip was new to me so thank you for sharing that.</p>
<p>I have to ask out of curiosity… are you using a 32 bits architecture because you haven’t written any 64 bits shellcode before or because of simplicity? If it’s because you still haven’t practiced shellcoding in a 64 bits environment I feel like sharing this simple local shellcode I wrote a few days ago as a little reference in case you wish to know more about more modern systems:</p>
<pre><code>xor %rdx, %rdx                    ; RDX = 0
push %rdx                         ; pushes RDX to act as a string terminator
mov $0x68732f2f6e69622f, %rax     ; copies the /bin/sh string into RAX encoded in ASCII
push %rax                         ; pushes the string on the stack
mov %rsp, %rdi                    ; copies the address of the string inside RDI
push %rdx                         ; pushes RDX on the stack, it's the address to the environment string, NULL
push %rdi                         ; pushes the address of the string too
mov %rsp, %rsi                    ; RSI now contains the address of the string, which is also the address of the parameters, terminated by NULL
xor %rax, %rax                    ; RAX = 0
mov $0x3b, %al                    ; loads the ID of execve
syscall                           ; executes the system call
</code></pre>
<p>If you’re wondering, “syscall” is just the same as “int 0x80” <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
          <p><a href="https://0x00sec.org/t/writeup-for-a-simple-buffer-overflow-in-a-linux-32-bit-system/8304/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/writeup-for-a-simple-buffer-overflow-in-a-linux-32-bit-system/8304/2</link>
        <pubDate>Mon, 27 Aug 2018 19:21:23 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-8304-2</guid>
        <source url="https://0x00sec.org/t/writeup-for-a-simple-buffer-overflow-in-a-linux-32-bit-system/8304.rss">Writeup for a simple buffer overflow in a linux 32 bit system</source>
      </item>
      <item>
        <title>Writeup for a simple buffer overflow in a linux 32 bit system</title>
        <dc:creator><![CDATA[gipi]]></dc:creator>
        <description><![CDATA[
            <p>This is a writeup on the simplest exploitable binary (buffer overflow, 32 bit, no ASLR, executable stack) but with (I think) a different approach with respect to the usual writeups.</p>
<p>In particular, how to calculate the address of a buffer knowing the environment variables contents.</p>
<p>The post is here: <a href="https://ktln2.org/2018/08/13/pratical-approach-exploitation/" rel="nofollow noopener">https://ktln2.org/2018/08/13/pratical-approach-exploitation/</a></p>
          <p><a href="https://0x00sec.org/t/writeup-for-a-simple-buffer-overflow-in-a-linux-32-bit-system/8304/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/writeup-for-a-simple-buffer-overflow-in-a-linux-32-bit-system/8304/1</link>
        <pubDate>Mon, 27 Aug 2018 14:07:22 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-8304-1</guid>
        <source url="https://0x00sec.org/t/writeup-for-a-simple-buffer-overflow-in-a-linux-32-bit-system/8304.rss">Writeup for a simple buffer overflow in a linux 32 bit system</source>
      </item>
  </channel>
</rss>
