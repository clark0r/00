<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Introducing STAN. A simple tool for RE beginners</title>
    <link>https://0x00sec.org/t/introducing-stan-a-simple-tool-for-re-beginners/2505</link>
    <description>Those of you that are following me on twitter may have heard about STAN. This is my pet project to learn about reverse engineering. It was born as an experiment with the capstone disassembly framework (http://www.capstone-engine.org/), and it evolved in something usable for simple projects.

If you want to use it for your practice, or you want to take a look to the code, or even you want to extend it for your own needs... just grab the code here:

https://github.com/0x00pf/STAN

STAN is an early alpha phase and you may expect crashes and some misbehaviour. In general, for simple challenges it should work fine, but... as I said, it is just a pet project. So far it only works with GNU/Linux binaries and with ELF format for x86 and ARM (only 32bits for ARM).

# A Simple Crackme for Testing
So, instead of writing a boring tutorial on the different options. I will just solve a very simple challenge.

Here it is:


    #!/bin/sh

    cat &lt;&lt; EOM | base64 -d | gunzip &gt; /tmp/specimen
    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
    EOM


Just run it and you will get the challenge in the `tmp` folder

# Basic STAN Operations
So, let&#39;s launch STAN passing as parameter our challenge:

    $ stan /tmp/specimen
    STAN is a sTAtic aNalyser. v 0.1
    (c) pico

    + Opening file &#39;/tmp/specimen&#39;
    + Loaded &#39;/tmp/specimen&#39; 4808 bytes
    + ELF Machine ID: 62
    + Arch: 1 Mode:2 Type: 1
    + Processing Core...
    Starting analysis
    + Processing 4 sections/segments
    + Processing section [0] &#39;.text&#39;
      * Analysing 342 instructions
    + Processing section [1] &#39;.rodata&#39;
    + Processing section [2] &#39;.eh_frame&#39;
    + Processing section [3] &#39;.data&#39;
    --------------------------------------
    CASE: &#39;corpse&#39;
    CORE: 0x696140
    ......................................
    + Dumming Core
      - File         : /tmp/specimen
      - Size         : 4808
      - Type         : ELF64
      - Valid        : VALID
      - Architecture : X86
      - Mode         : 64bits
    [00] text_00 Addr:0x400000 Offset:0x0000 Size:0x06f0 (1776)
    [01] data_01 Addr:0x601000 Offset:0x1000 Size:0x000c (12)
    .................................................
    [00]           .text 0x03 Addr:0x400144 Offset:0x0144 Size:0x0433 (   1075) [text_00+0x0144]
    [01]         .rodata 0x06 Addr:0x400577 Offset:0x0577 Size:0x003f (     63) [text_00+0x0577]
    [02]       .eh_frame 0x06 Addr:0x4005b8 Offset:0x05b8 Size:0x0138 (    312) [text_00+0x05b8]
    [03]           .data 0x06 Addr:0x601000 Offset:0x1000 Size:0x000c (     12) [data_01+0x0000]
    --------------------------------------
    STAN] &gt;

It shows a bunch of data related to the ELF file.. Let&#39;s look directly to the code:

    STAN] &gt; dis.section .text
    (the whole program is dumped)

The family of `dis` commands are used for disassembling code. The `dis.section` one, disassembles a whole section. Usually you will use the `dis.function` that disassembles just 1 function. Any way, in this case, dumping the whole section will allow us to quickly find the main function.

Oops. I haven&#39;t mention that, but the challenge is a stripped binary... so no symbols in it. STAN can deal with symbols and show then to you... but the stripped binary is just smaller to be included as text in this write up.

So, if you quickly browse the asm code, you will see the string `Password:` towards the begining of the dump. That is our `main` function. Alternatively, STAN creates a special symbol named `__entry_point` to reference the program entry point. Starting from there and following the different function calls you will eventually arrive to the same point.

# The main function
Let&#39;s take a look to the main function at the same time we discover more STAN functions. 

    STAN] &gt; dis.function .text
    + Function &#39;.text&#39;@0x400144 found at section &#39;.text&#39;(1075,342)

                                     .text:
    400144:   48 81 ec 08 04 00 00    	sub	rsp, 0x408
    40014b:   ba 0b 00 00 00          	mov	edx, 0xb
    400150:   be 8a 05 40 00          	mov	esi, 0x40058a		#  40058a(.rodata+13) : &#39;Password: &#39;
    400155:   bf 01 00 00 00          	mov	edi, 1
    40015a:   31 c0                   	xor	eax, eax
    40015c:   e8 b0 00 00 00          	call	&lt;func_400211&gt;			#  &lt;func_400211&gt; 400211(.text+0xcd)
    400161:   48 89 e6                	mov	rsi, rsp
    400164:   ba 00 04 00 00          	mov	edx, 0x400
    400169:   31 ff                   	xor	edi, edi
    40016b:   31 c0                   	xor	eax, eax
    40016d:   e8 98 00 00 00          	call	&lt;func_40020a&gt;			#  &lt;func_40020a&gt; 40020a(.text+0xc6)
    400172:   ff c8                   	dec	eax
    400174:   48 89 e7                	mov	rdi, rsp
    400177:   48 98                   	cdqe
    400179:   c6 04 04 00             	mov	byte ptr [rsp + rax], 0
    40017d:   e8 29 00 00 00          	call	&lt;func_4001ab&gt;			#  &lt;func_4001ab&gt; 4001ab(.text+0x67)
    400182:   31 c0                   	xor	eax, eax
    400184:   48 81 c4 08 04 00 00    	add	rsp, 0x408
    40018b:   c3                      	ret
    + Stopped after founding symbol &#39;__entry_point&#39; (18 instructions)
    STAN] &gt;

As you can see, STAN already show us strings if the are referenced from the program (not always the case) and it also creates dummy names for every function it finds. You can see three function calls in the main program.

If you further explore the first two `func_400211` and `func_40020a` you will find out that the first one is a `write` and the second one is a `read`. To figure out this using STAN you will have to dump the whole section. The opcode analysis module is still pretty basic and it cannot figure out complex structures like the one you will find in there.

Alternatively, use your intuition. If you have already run the program, you know it will show a message and then ask for some input... Let&#39;s go that path and let&#39;s use the renaming functions provided by STAN:

    STAN] &gt; func.rename func_400211 maybe_write
     + Found function func_400211
     + Found Symbol func_400211
    STAN] &gt; func.rename func_40020a maybe_read
     + Found function func_40020a
     + Found Symbol func_40020a
    STAN] &gt;

&gt; _Note: All those debug messages will eventially disappear :)_

If we now dump the code again, it will look like this:

    STAN] &gt; dis.function .text
    + Function &#39;.text&#39;@0x400144 found at section &#39;.text&#39;(1075,342)

                                     .text:
    400144:   48 81 ec 08 04 00 00    	sub	rsp, 0x408
    40014b:   ba 0b 00 00 00          	mov	edx, 0xb
    400150:   be 8a 05 40 00          	mov	esi, 0x40058a		#  40058a(.rodata+13) : &#39;Password: &#39;
    400155:   bf 01 00 00 00          	mov	edi, 1
    40015a:   31 c0                   	xor	eax, eax
    40015c:   e8 b0 00 00 00          	call	&lt;maybe_write&gt;			#  &lt;maybe_write&gt; 400211(.text+0xcd)
    400161:   48 89 e6                	mov	rsi, rsp
    400164:   ba 00 04 00 00          	mov	edx, 0x400
    400169:   31 ff                   	xor	edi, edi
    40016b:   31 c0                   	xor	eax, eax
    40016d:   e8 98 00 00 00          	call	&lt;maybe_read&gt;			#  &lt;maybe_read&gt; 40020a(.text+0xc6)
    400172:   ff c8                   	dec	eax
    400174:   48 89 e7                	mov	rdi, rsp
    400177:   48 98                   	cdqe
    400179:   c6 04 04 00             	mov	byte ptr [rsp + rax], 0
    40017d:   e8 29 00 00 00          	call	&lt;func_4001ab&gt;			#  &lt;func_4001ab&gt; 4001ab(.text+0x67)
    400182:   31 c0                   	xor	eax, eax
    400184:   48 81 c4 08 04 00 00    	add	rsp, 0x408
    40018b:   c3                      	ret
    + Stopped after founding symbol &#39;__entry_point&#39; (18 instructions)
    STAN] &gt;

# Getting there
So, we have figured out the `write` and the `read` and there is only one more function left, the mysterious `func_4001ab`. So, we better figure out what we are passing as parameter to the function.

You are probably better than me, but I cannot really remember the calling convention for 64bits functions... so I added a `help.abi` command to STAN to remember me the order:

    STAN] &gt; help.abi
      Current Core is: Linux X86 64bits
      -&gt; func (RDI, RSI, RDX, RCX) -&gt; RAX
    STAN] &gt;

Good, so, let&#39;s look at the code above to figure out what we may expect to receive in that mysterious function... OK, let&#39;s rename it before continuing.

`STAN] func.rename func_4001ab mystery`

So, we can see that `RDI` is initialised with `RSP` (the top of the stack). And what may be in the top of the stack?. Let&#39;s check the previous function, the read:

    RDI = 0 (xor edi,edi)
    RSI = RSP
    RDX = 0x400

So, it actually looks like a `read` call, and the second parameter is the buffer to store the data that is set to the top of the stack. Then, without changing anything we call the `mystery` function passing as parameter whatever we had read from the user.

OK. It is being time for a break so, let&#39;s note down what we have found out, before we leave so we do not have to start from scratch when we come back:

    STAN] &gt; func.rename func_4001ab mystery
     + Found function func_4001ab
     + Found Symbol func_4001ab
    STAN] &gt; comment.add 40016d read (0 = stdin, RSP, 0x400)
    + Adding comment &#39;read (0 = stdin, RSP, 0x400)&#39; at 0x40016d
    STAN] &gt; comment.add 40017d mystery (RSP) -&gt; we just pass in the data read from the user
    + Adding comment &#39;mystery (RSP) -&gt; we just pass in the data read from the user&#39; at 0x40017d

Yes, we can add comments to specific addresses. And then the code will look like this:

    STAN] &gt; dis.function .text
    + Function &#39;.text&#39;@0x400144 found at section &#39;.text&#39;(1075,342)

                                     .text:
    400144:   48 81 ec 08 04 00 00    	sub	rsp, 0x408
    40014b:   ba 0b 00 00 00          	mov	edx, 0xb
    400150:   be 8a 05 40 00          	mov	esi, 0x40058a		#  40058a(.rodata+13) : &#39;Password: &#39;
    400155:   bf 01 00 00 00          	mov	edi, 1
    40015a:   31 c0                   	xor	eax, eax
    40015c:   e8 b0 00 00 00          	call	&lt;maybe_write&gt;			#  &lt;maybe_write&gt; 400211(.text+0xcd)
    400161:   48 89 e6                	mov	rsi, rsp
    400164:   ba 00 04 00 00          	mov	edx, 0x400
    400169:   31 ff                   	xor	edi, edi
    40016b:   31 c0                   	xor	eax, eax
    40016d:   e8 98 00 00 00          	call	&lt;maybe_read&gt;			#  &lt;maybe_read&gt; 40020a(.text+0xc6)
                                            ; read (0 = stdin, RSP, 0x400)
    400172:   ff c8                   	dec	eax
    400174:   48 89 e7                	mov	rdi, rsp
    400177:   48 98                   	cdqe
    400179:   c6 04 04 00             	mov	byte ptr [rsp + rax], 0
    40017d:   e8 29 00 00 00          	call	&lt;mystery&gt;			#  &lt;mystery&gt; 4001ab(.text+0x67)
                                            ; mystery (RSP) -&gt; we just pass in the data read from the user
    400182:   31 c0                   	xor	eax, eax
    400184:   48 81 c4 08 04 00 00    	add	rsp, 0x408
    40018b:   c3                      	ret
    + Stopped after founding symbol &#39;__entry_point&#39; (18 instructions)

  Time to save our work and take a break. 
Just type:

    STAN] case.save

# Finishing the challenge
Hope you have had a nice break. I did. Now we can launch again STAN, but this time we are going to open the file from the STAN command-line

    $ stan
    STAN is a sTAtic aNalyser. v 0.1
    (c) pico

    STAN] core.load /tmp/specimen
    + Cleanning up core
    + Deleting Segments....
    + Deleting Sections....
    + Deleting Symbols....
    + Opening file &#39;/tmp/specimen&#39;
    + Loaded &#39;/tmp/specimen&#39; 4808 bytes
    + ELF Machine ID: 62
    + Arch: 1 Mode:2 Type: 1
    + Processing Core...
    Starting analysis
    + Processing 4 sections/segments
    + Processing section [0] &#39;.text&#39;
      * Analysing 342 instructions
    + Processing section [1] &#39;.rodata&#39;
    + Processing section [2] &#39;.eh_frame&#39;
    + Processing section [3] &#39;.data&#39;
    STAN] case.load /tmp/specimen.srep
    -&gt; SYMBOL: &#39;mystery&#39; &#39;4001ab&#39;
     + Found function mystery
     + Found Symbol mystery
    -&gt; FUNCTION: &#39;mystery&#39; &#39;0x4001ab&#39;
    -&gt; COMMENT: &#39;read (0 = stdin, RSP, 0x400)&#39; &#39;0x40016d&#39;
    -&gt; COMMENT: &#39;mystery (RSP) -&gt; we just pass in the data read from the user&#39; &#39;0x40017d&#39;
    STAN] 

As you can imagine `core.load` allows you to load a binary from the disk (you can use TAB completion to navigate the file system), then you use `case.load` to load your previous saved status. For the time being `case.save` saves the state as a file with the same name than the binary under analysis but with extension `.srep`.

Now we can go, and reverse the `mystery` function:

# Unveiling the `mystery`
Let&#39;s disassemble `mystery`

    STAN] &gt; dis.function mystery
    + Function &#39;mystery&#39;@0x4001ab found at section &#39;.text&#39;(1075,342)

                                   mystery:
    4001ab:   51                      	push	rcx
    4001ac:   be 77 05 40 00          	mov	esi, 0x400577		#  &lt;.rodata&gt; 400577(.rodata+0) : &#39;0x00sec&#39;
    4001b1:   e8 98 02 00 00          	call	&lt;func_40044e&gt;			#  &lt;func_40044e&gt; 40044e(.text+0x30a)
    4001b6:   85 c0                   	test	eax, eax
    4001b8:   75 11                   	jne	&lt;l0&gt;			# 4001cb(.text+0x87)
    4001ba:   ba 05 00 00 00          	mov	edx, 5
    4001bf:   be 7f 05 40 00          	mov	esi, 0x40057f		#  40057f(.rodata+8) : &#39;Good\n&#39;
    4001c4:   bf 01 00 00 00          	mov	edi, 1
    4001c9:   eb 11                   	jmp	&lt;l1&gt;			# 4001dc(.text+0x98)
                                        l0:
    4001cb:   ba 04 00 00 00          	mov	edx, 4
    4001d0:   be 85 05 40 00          	mov	esi, 0x400585		#  400585(.rodata+e) : &#39;Bad\n&#39;
    4001d5:   bf 01 00 00 00          	mov	edi, 1
    4001da:   31 c0                   	xor	eax, eax
                                        l1:
    4001dc:   e8 30 00 00 00          	call	&lt;maybe_write&gt;			#  &lt;maybe_write&gt; 400211(.text+0xcd)
    4001e1:   83 c8 ff                	or	eax, 0xffffffff
    4001e4:   5a                      	pop	rdx
    4001e5:   c3                      	ret


Here we find two labels: `l0` and `l1`. And we can also see a call to what we believe is a `write` after setting the strings for the right and wrong password. Everything should be obvious now, but let&#39;s  rename the labels for the LuLz

    STAN] &gt; label.rename l0 BadBoy
     + Found label l0
    - DEBUG: Symbol &#39;l0&#39; not found
    STAN] &gt; label.rename l1 print_and_exit
     + Found label l1
    - DEBUG: Symbol &#39;l1&#39; not found
    STAN] &gt; dis.function mystery
    + Function &#39;mystery&#39;@0x4001ab found at section &#39;.text&#39;(1075,342)

                                   mystery:
    4001ab:   51                      	push	rcx
    4001ac:   be 77 05 40 00          	mov	esi, 0x400577		#  &lt;.rodata&gt; 400577(.rodata+0) : &#39;0x00sec&#39;
    4001b1:   e8 98 02 00 00          	call	&lt;func_40044e&gt;			#  &lt;func_40044e&gt; 40044e(.text+0x30a)
    4001b6:   85 c0                   	test	eax, eax
    4001b8:   75 11                   	jne	&lt;BadBoy&gt;			# 4001cb(.text+0x87)
    4001ba:   ba 05 00 00 00          	mov	edx, 5
    4001bf:   be 7f 05 40 00          	mov	esi, 0x40057f		#  40057f(.rodata+8) : &#39;Good\n&#39;
    4001c4:   bf 01 00 00 00          	mov	edi, 1
    4001c9:   eb 11                   	jmp	&lt;print_and_exit&gt;			# 4001dc(.text+0x98)
                                    BadBoy:
    4001cb:   ba 04 00 00 00          	mov	edx, 4
    4001d0:   be 85 05 40 00          	mov	esi, 0x400585		#  400585(.rodata+e) : &#39;Bad\n&#39;
    4001d5:   bf 01 00 00 00          	mov	edi, 1
    4001da:   31 c0                   	xor	eax, eax
                            print_and_exit:
    4001dc:   e8 30 00 00 00          	call	&lt;maybe_write&gt;			#  &lt;maybe_write&gt; 400211(.text+0xcd)
    4001e1:   83 c8 ff                	or	eax, 0xffffffff
    4001e4:   5a                      	pop	rdx
    4001e5:   c3                      	ret

OK... so can you figure out the password for this crackme?
In case you wonder, the `func_40044e` is actually `strcmp` you can dive deeper in the code to figure this out... `dis.function func_40044e`... this is a simple one if you want to try.

# Other commands you may find interesting
Just for completion, these are a few commands that may also be useful if you want to play with STAN:

* `comment.del addr`: Deletes a previous comment... sometimes we make mistakes :)
* `mem.dump x addr count`. Dumps content of address `addr` as hex bytes. You can change `x` by `p` to dump words (pointers)

    `STAN] &gt; mem.dump x 0x400577 10`

* `func.def`. This allows you to tell STAN that you believe there is a function at some address. As I said, the analysis module is pretty poor so you may spot obvious functions that STAN missed.

And, I haven&#39;t say that... but STAN is colourful :slight_smile:. This is how our functions looks like after all our hard work :wink:
 
&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/f/f361ce0600547aae8c889ba32786b398ba907a3a.png&quot; width=&quot;690&quot; height=&quot;467&quot;&gt; 

# Conclusions
As a final note, I have found this little tool very useful. It is not as powerful as radare2 or binary ninja, but it is very easy to use and helps a bit but still force you to do some work... which is something good when you are starting and you are still learning the basics.

It is still a lot to do and as I said, it is kind of alpha SW, so, use it at your own risk :blush: 

hack fun</description>
    
    <lastBuildDate>Fri, 23 Jun 2017 05:47:01 +0000</lastBuildDate>
    <category>Reverse Engineering</category>
    <atom:link href="https://0x00sec.org/t/introducing-stan-a-simple-tool-for-re-beginners/2505.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Introducing STAN. A simple tool for RE beginners</title>
        <dc:creator><![CDATA[ricksanchez]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="0x00pf" data-post="8" data-topic="2505" data-full="true">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://0x00sec.org/user_avatar/0x00sec.org/0x00pf/40/199_2.png" class="avatar"> 0x00pf:</div>
<blockquote>
<p>OK… my bad I just checked the lines in the source file not the actual LoCs. Just run sloccount on my first PoC and it  reported 978 LoC, so roughly just 1KLoc. Sorry about the confusion.</p>
</blockquote>
</aside>
<p>Oh if that’s the case things obviously change… and I thought you’re a genius man, but just 978 LoC that’s not even 1k. mpfff weak stuff man <img src="https://0x00sec.org/images/emoji/twitter/grimacing.png?v=9" title=":grimacing:" class="emoji" alt=":grimacing:"> .</p>
<p>Ah common <a class="mention" href="https://0x00sec.org/u/0x00pf">@0x00pf</a> it doesnt matter if it’s 1k or 1.2k LoC… It’s an alpha release and it’s already a tool which makes the life of every beginner RE or someone who wants to step into that area easier and what’s even more important more approachable!</p>
<p>You’ll add more stuff and it’ll grow.  For what I saw in your post here I will still be massively impressed no matter what.</p>
          <p><a href="https://0x00sec.org/t/introducing-stan-a-simple-tool-for-re-beginners/2505/9">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/introducing-stan-a-simple-tool-for-re-beginners/2505/9</link>
        <pubDate>Fri, 23 Jun 2017 05:47:01 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-2505-9</guid>
        <source url="https://0x00sec.org/t/introducing-stan-a-simple-tool-for-re-beginners/2505.rss">Introducing STAN. A simple tool for RE beginners</source>
      </item>
      <item>
        <title>Introducing STAN. A simple tool for RE beginners</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>OK… my bad I just checked the lines in the source file not the actual LoCs. Just run <code>sloccount</code> on my first PoC and it  reported 978 LoC, so roughly just 1KLoc. Sorry about the confusion.</p>
          <p><a href="https://0x00sec.org/t/introducing-stan-a-simple-tool-for-re-beginners/2505/8">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/introducing-stan-a-simple-tool-for-re-beginners/2505/8</link>
        <pubDate>Thu, 22 Jun 2017 21:35:46 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-2505-8</guid>
        <source url="https://0x00sec.org/t/introducing-stan-a-simple-tool-for-re-beginners/2505.rss">Introducing STAN. A simple tool for RE beginners</source>
      </item>
      <item>
        <title>Introducing STAN. A simple tool for RE beginners</title>
        <dc:creator><![CDATA[ricksanchez]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="0x00pf" data-post="4" data-topic="2505">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://0x00sec.org/user_avatar/0x00sec.org/0x00pf/40/199_2.png" class="avatar"> 0x00pf:</div>
<blockquote>
<p>it will not be that easy. Actually the challenge I’m working on completely defeats STAN… but I’ll do some improvements to the tool before releasing the challenge (still waiting for some feedback on the challenge tho)</p>
</blockquote>
</aside>
<p>just joking man <img src="https://0x00sec.org/images/emoji/twitter/smiley.png?v=9" title=":smiley:" class="emoji" alt=":smiley:"> . Also you’re telling your story of “just 1.2kLoC in a couple of days” like it is nothing. I’d need way longer ofr that. So I’m massively impressed <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<p>Also looking forward to the next challenge <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
          <p><a href="https://0x00sec.org/t/introducing-stan-a-simple-tool-for-re-beginners/2505/7">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/introducing-stan-a-simple-tool-for-re-beginners/2505/7</link>
        <pubDate>Thu, 22 Jun 2017 19:30:50 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-2505-7</guid>
        <source url="https://0x00sec.org/t/introducing-stan-a-simple-tool-for-re-beginners/2505.rss">Introducing STAN. A simple tool for RE beginners</source>
      </item>
      <item>
        <title>Introducing STAN. A simple tool for RE beginners</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>Thanks <a class="mention" href="https://0x00sec.org/u/smartone">@SmartOne</a></p>
<p>That capstone framework is amazing. I’ve got a working PoC (around 1.2KLoC) in a couple of days. Then it took me 2/3 days to just refactor that code in something with a bit of structure. So, roughly it took two complete weekends plus some hours every day during the week.</p>
<p>Regarding the idea, I knew about capstone and I wanted to try it. Just followed the documentation in their site and the test program started to grow very fast <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:">…</p>
          <p><a href="https://0x00sec.org/t/introducing-stan-a-simple-tool-for-re-beginners/2505/6">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/introducing-stan-a-simple-tool-for-re-beginners/2505/6</link>
        <pubDate>Thu, 22 Jun 2017 16:31:00 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-2505-6</guid>
        <source url="https://0x00sec.org/t/introducing-stan-a-simple-tool-for-re-beginners/2505.rss">Introducing STAN. A simple tool for RE beginners</source>
      </item>
      <item>
        <title>Introducing STAN. A simple tool for RE beginners</title>
        <dc:creator><![CDATA[SmartOne]]></dc:creator>
        <description><![CDATA[
            <p>This is crazy <img src="https://0x00sec.org/images/emoji/twitter/open_mouth.png?v=9" title=":open_mouth:" class="emoji" alt=":open_mouth:"> Phenomenous work! And you did it all on your own? How long did it actually take you to code it/get the idea?<br>
Best, SmartOne</p>
          <p><a href="https://0x00sec.org/t/introducing-stan-a-simple-tool-for-re-beginners/2505/5">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/introducing-stan-a-simple-tool-for-re-beginners/2505/5</link>
        <pubDate>Thu, 22 Jun 2017 16:20:15 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-2505-5</guid>
        <source url="https://0x00sec.org/t/introducing-stan-a-simple-tool-for-re-beginners/2505.rss">Introducing STAN. A simple tool for RE beginners</source>
      </item>
      <item>
        <title>Introducing STAN. A simple tool for RE beginners</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p><a class="mention" href="https://0x00sec.org/u/ricksanchez">@ricksanchez</a>… it will not be that easy. Actually the challenge I’m working on completely defeats STAN… but I’ll do some improvements to the tool before releasing the challenge (still waiting for some feedback on the challenge tho)</p>
<p><a class="mention" href="https://0x00sec.org/u/pry0cc">@pry0cc</a> I look forward  to any feedback. What’s next?.. well I have realised that STAN is way too STAtic and it needs some big change in the disassembling module…  It is coming <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<p><em>UPDATE: You have autocompletion of the commands pressing TAB. Just pressing TAB on a blank prompt will show you all of commands… thanks to the amazing <code>readline</code> library!)</em></p>
          <p><a href="https://0x00sec.org/t/introducing-stan-a-simple-tool-for-re-beginners/2505/4">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/introducing-stan-a-simple-tool-for-re-beginners/2505/4</link>
        <pubDate>Thu, 22 Jun 2017 16:16:07 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-2505-4</guid>
        <source url="https://0x00sec.org/t/introducing-stan-a-simple-tool-for-re-beginners/2505.rss">Introducing STAN. A simple tool for RE beginners</source>
      </item>
      <item>
        <title>Introducing STAN. A simple tool for RE beginners</title>
        <dc:creator><![CDATA[pry0cc]]></dc:creator>
        <description><![CDATA[
            <p>My internal mental monologue:</p>
<p>"Hmm I wonder where Pico is. He seems kind of quiet lately’<br>
“Who’s Stan?”<br>
“OH DAMN HE’S ONLY DONE IT AGAIN”</p>
<p>This is super cool. I am so happy you have made something just for beginners. Most of the commands are readable, and thus easier to remember.</p>
<p>As somebody who is just getting into RE. I am going to give this a try. I’ll give you my feedback, I understand it is super early days. I wonder what you will add next?</p>
          <p><a href="https://0x00sec.org/t/introducing-stan-a-simple-tool-for-re-beginners/2505/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/introducing-stan-a-simple-tool-for-re-beginners/2505/3</link>
        <pubDate>Thu, 22 Jun 2017 07:42:15 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-2505-3</guid>
        <source url="https://0x00sec.org/t/introducing-stan-a-simple-tool-for-re-beginners/2505.rss">Introducing STAN. A simple tool for RE beginners</source>
      </item>
      <item>
        <title>Introducing STAN. A simple tool for RE beginners</title>
        <dc:creator><![CDATA[ricksanchez]]></dc:creator>
        <description><![CDATA[
            <p>You mad man <a class="mention" href="https://0x00sec.org/u/0x00pf">@0x00pf</a> . Nice post as always.</p>
<p>Soon you will post challenges and then we can just run STAN and it will spit out the solutions <img src="https://0x00sec.org/images/emoji/twitter/grimacing.png?v=9" title=":grimacing:" class="emoji" alt=":grimacing:"></p>
          <p><a href="https://0x00sec.org/t/introducing-stan-a-simple-tool-for-re-beginners/2505/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/introducing-stan-a-simple-tool-for-re-beginners/2505/2</link>
        <pubDate>Thu, 22 Jun 2017 06:15:15 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-2505-2</guid>
        <source url="https://0x00sec.org/t/introducing-stan-a-simple-tool-for-re-beginners/2505.rss">Introducing STAN. A simple tool for RE beginners</source>
      </item>
      <item>
        <title>Introducing STAN. A simple tool for RE beginners</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>Those of you that are following me on twitter may have heard about STAN. This is my pet project to learn about reverse engineering. It was born as an experiment with the capstone disassembly framework (<a href="http://www.capstone-engine.org/" rel="noopener nofollow ugc">http://www.capstone-engine.org/</a>), and it evolved in something usable for simple projects.</p>
<p>If you want to use it for your practice, or you want to take a look to the code, or even you want to extend it for your own needs… just grab the code here:</p>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://github.githubassets.com/favicons/favicon.svg" class="site-icon" width="32" height="32">
      <a href="https://github.com/0x00pf/STAN" target="_blank" rel="noopener nofollow ugc">GitHub</a>
  </header>
  <article class="onebox-body">
    <img src="https://0x00sec.s3.amazonaws.com/original/2X/a/a35c2bf9477f702a5322cfd1c8f54353d79c1d16.png" class="thumbnail" width="" height="">

<h3><a href="https://github.com/0x00pf/STAN" target="_blank" rel="noopener nofollow ugc">0x00pf/STAN</a></h3>

<p>STAN is a sTAtic aNalyser. Contribute to 0x00pf/STAN development by creating an account on GitHub.</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>STAN is an early alpha phase and you may expect crashes and some misbehaviour. In general, for simple challenges it should work fine, but… as I said, it is just a pet project. So far it only works with GNU/Linux binaries and with ELF format for x86 and ARM (only 32bits for ARM).</p>
<h1>A Simple Crackme for Testing</h1>
<p>So, instead of writing a boring tutorial on the different options. I will just solve a very simple challenge.</p>
<p>Here it is:</p>
<pre><code>#!/bin/sh

cat &lt;&lt; EOM | base64 -d | gunzip &gt; /tmp/specimen
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
EOM
</code></pre>
<p>Just run it and you will get the challenge in the <code>tmp</code> folder</p>
<h1>Basic STAN Operations</h1>
<p>So, let’s launch STAN passing as parameter our challenge:</p>
<pre><code>$ stan /tmp/specimen
STAN is a sTAtic aNalyser. v 0.1
(c) pico

+ Opening file '/tmp/specimen'
+ Loaded '/tmp/specimen' 4808 bytes
+ ELF Machine ID: 62
+ Arch: 1 Mode:2 Type: 1
+ Processing Core...
Starting analysis
+ Processing 4 sections/segments
+ Processing section [0] '.text'
  * Analysing 342 instructions
+ Processing section [1] '.rodata'
+ Processing section [2] '.eh_frame'
+ Processing section [3] '.data'
--------------------------------------
CASE: 'corpse'
CORE: 0x696140
......................................
+ Dumming Core
  - File         : /tmp/specimen
  - Size         : 4808
  - Type         : ELF64
  - Valid        : VALID
  - Architecture : X86
  - Mode         : 64bits
[00] text_00 Addr:0x400000 Offset:0x0000 Size:0x06f0 (1776)
[01] data_01 Addr:0x601000 Offset:0x1000 Size:0x000c (12)
.................................................
[00]           .text 0x03 Addr:0x400144 Offset:0x0144 Size:0x0433 (   1075) [text_00+0x0144]
[01]         .rodata 0x06 Addr:0x400577 Offset:0x0577 Size:0x003f (     63) [text_00+0x0577]
[02]       .eh_frame 0x06 Addr:0x4005b8 Offset:0x05b8 Size:0x0138 (    312) [text_00+0x05b8]
[03]           .data 0x06 Addr:0x601000 Offset:0x1000 Size:0x000c (     12) [data_01+0x0000]
--------------------------------------
STAN] &gt;
</code></pre>
<p>It shows a bunch of data related to the ELF file… Let’s look directly to the code:</p>
<pre><code>STAN] &gt; dis.section .text
(the whole program is dumped)
</code></pre>
<p>The family of <code>dis</code> commands are used for disassembling code. The <code>dis.section</code> one, disassembles a whole section. Usually you will use the <code>dis.function</code> that disassembles just 1 function. Any way, in this case, dumping the whole section will allow us to quickly find the main function.</p>
<p>Oops. I haven’t mention that, but the challenge is a stripped binary… so no symbols in it. STAN can deal with symbols and show then to you… but the stripped binary is just smaller to be included as text in this write up.</p>
<p>So, if you quickly browse the asm code, you will see the string <code>Password:</code> towards the begining of the dump. That is our <code>main</code> function. Alternatively, STAN creates a special symbol named <code>__entry_point</code> to reference the program entry point. Starting from there and following the different function calls you will eventually arrive to the same point.</p>
<h1>The main function</h1>
<p>Let’s take a look to the main function at the same time we discover more STAN functions.</p>
<pre><code>STAN] &gt; dis.function .text
+ Function '.text'@0x400144 found at section '.text'(1075,342)

                                 .text:
400144:   48 81 ec 08 04 00 00    	sub	rsp, 0x408
40014b:   ba 0b 00 00 00          	mov	edx, 0xb
400150:   be 8a 05 40 00          	mov	esi, 0x40058a		#  40058a(.rodata+13) : 'Password: '
400155:   bf 01 00 00 00          	mov	edi, 1
40015a:   31 c0                   	xor	eax, eax
40015c:   e8 b0 00 00 00          	call	&lt;func_400211&gt;			#  &lt;func_400211&gt; 400211(.text+0xcd)
400161:   48 89 e6                	mov	rsi, rsp
400164:   ba 00 04 00 00          	mov	edx, 0x400
400169:   31 ff                   	xor	edi, edi
40016b:   31 c0                   	xor	eax, eax
40016d:   e8 98 00 00 00          	call	&lt;func_40020a&gt;			#  &lt;func_40020a&gt; 40020a(.text+0xc6)
400172:   ff c8                   	dec	eax
400174:   48 89 e7                	mov	rdi, rsp
400177:   48 98                   	cdqe
400179:   c6 04 04 00             	mov	byte ptr [rsp + rax], 0
40017d:   e8 29 00 00 00          	call	&lt;func_4001ab&gt;			#  &lt;func_4001ab&gt; 4001ab(.text+0x67)
400182:   31 c0                   	xor	eax, eax
400184:   48 81 c4 08 04 00 00    	add	rsp, 0x408
40018b:   c3                      	ret
+ Stopped after founding symbol '__entry_point' (18 instructions)
STAN] &gt;
</code></pre>
<p>As you can see, STAN already show us strings if the are referenced from the program (not always the case) and it also creates dummy names for every function it finds. You can see three function calls in the main program.</p>
<p>If you further explore the first two <code>func_400211</code> and <code>func_40020a</code> you will find out that the first one is a <code>write</code> and the second one is a <code>read</code>. To figure out this using STAN you will have to dump the whole section. The opcode analysis module is still pretty basic and it cannot figure out complex structures like the one you will find in there.</p>
<p>Alternatively, use your intuition. If you have already run the program, you know it will show a message and then ask for some input… Let’s go that path and let’s use the renaming functions provided by STAN:</p>
<pre><code>STAN] &gt; func.rename func_400211 maybe_write
 + Found function func_400211
 + Found Symbol func_400211
STAN] &gt; func.rename func_40020a maybe_read
 + Found function func_40020a
 + Found Symbol func_40020a
STAN] &gt;
</code></pre>
<blockquote>
<p><em>Note: All those debug messages will eventially disappear <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></em></p>
</blockquote>
<p>If we now dump the code again, it will look like this:</p>
<pre><code>STAN] &gt; dis.function .text
+ Function '.text'@0x400144 found at section '.text'(1075,342)

                                 .text:
400144:   48 81 ec 08 04 00 00    	sub	rsp, 0x408
40014b:   ba 0b 00 00 00          	mov	edx, 0xb
400150:   be 8a 05 40 00          	mov	esi, 0x40058a		#  40058a(.rodata+13) : 'Password: '
400155:   bf 01 00 00 00          	mov	edi, 1
40015a:   31 c0                   	xor	eax, eax
40015c:   e8 b0 00 00 00          	call	&lt;maybe_write&gt;			#  &lt;maybe_write&gt; 400211(.text+0xcd)
400161:   48 89 e6                	mov	rsi, rsp
400164:   ba 00 04 00 00          	mov	edx, 0x400
400169:   31 ff                   	xor	edi, edi
40016b:   31 c0                   	xor	eax, eax
40016d:   e8 98 00 00 00          	call	&lt;maybe_read&gt;			#  &lt;maybe_read&gt; 40020a(.text+0xc6)
400172:   ff c8                   	dec	eax
400174:   48 89 e7                	mov	rdi, rsp
400177:   48 98                   	cdqe
400179:   c6 04 04 00             	mov	byte ptr [rsp + rax], 0
40017d:   e8 29 00 00 00          	call	&lt;func_4001ab&gt;			#  &lt;func_4001ab&gt; 4001ab(.text+0x67)
400182:   31 c0                   	xor	eax, eax
400184:   48 81 c4 08 04 00 00    	add	rsp, 0x408
40018b:   c3                      	ret
+ Stopped after founding symbol '__entry_point' (18 instructions)
STAN] &gt;
</code></pre>
<h1>Getting there</h1>
<p>So, we have figured out the <code>write</code> and the <code>read</code> and there is only one more function left, the mysterious <code>func_4001ab</code>. So, we better figure out what we are passing as parameter to the function.</p>
<p>You are probably better than me, but I cannot really remember the calling convention for 64bits functions… so I added a <code>help.abi</code> command to STAN to remember me the order:</p>
<pre><code>STAN] &gt; help.abi
  Current Core is: Linux X86 64bits
  -&gt; func (RDI, RSI, RDX, RCX) -&gt; RAX
STAN] &gt;
</code></pre>
<p>Good, so, let’s look at the code above to figure out what we may expect to receive in that mysterious function… OK, let’s rename it before continuing.</p>
<p><code>STAN] func.rename func_4001ab mystery</code></p>
<p>So, we can see that <code>RDI</code> is initialised with <code>RSP</code> (the top of the stack). And what may be in the top of the stack?. Let’s check the previous function, the read:</p>
<pre><code>RDI = 0 (xor edi,edi)
RSI = RSP
RDX = 0x400
</code></pre>
<p>So, it actually looks like a <code>read</code> call, and the second parameter is the buffer to store the data that is set to the top of the stack. Then, without changing anything we call the <code>mystery</code> function passing as parameter whatever we had read from the user.</p>
<p>OK. It is being time for a break so, let’s note down what we have found out, before we leave so we do not have to start from scratch when we come back:</p>
<pre><code>STAN] &gt; func.rename func_4001ab mystery
 + Found function func_4001ab
 + Found Symbol func_4001ab
STAN] &gt; comment.add 40016d read (0 = stdin, RSP, 0x400)
+ Adding comment 'read (0 = stdin, RSP, 0x400)' at 0x40016d
STAN] &gt; comment.add 40017d mystery (RSP) -&gt; we just pass in the data read from the user
+ Adding comment 'mystery (RSP) -&gt; we just pass in the data read from the user' at 0x40017d
</code></pre>
<p>Yes, we can add comments to specific addresses. And then the code will look like this:</p>
<pre><code>STAN] &gt; dis.function .text
+ Function '.text'@0x400144 found at section '.text'(1075,342)

                                 .text:
400144:   48 81 ec 08 04 00 00    	sub	rsp, 0x408
40014b:   ba 0b 00 00 00          	mov	edx, 0xb
400150:   be 8a 05 40 00          	mov	esi, 0x40058a		#  40058a(.rodata+13) : 'Password: '
400155:   bf 01 00 00 00          	mov	edi, 1
40015a:   31 c0                   	xor	eax, eax
40015c:   e8 b0 00 00 00          	call	&lt;maybe_write&gt;			#  &lt;maybe_write&gt; 400211(.text+0xcd)
400161:   48 89 e6                	mov	rsi, rsp
400164:   ba 00 04 00 00          	mov	edx, 0x400
400169:   31 ff                   	xor	edi, edi
40016b:   31 c0                   	xor	eax, eax
40016d:   e8 98 00 00 00          	call	&lt;maybe_read&gt;			#  &lt;maybe_read&gt; 40020a(.text+0xc6)
                                        ; read (0 = stdin, RSP, 0x400)
400172:   ff c8                   	dec	eax
400174:   48 89 e7                	mov	rdi, rsp
400177:   48 98                   	cdqe
400179:   c6 04 04 00             	mov	byte ptr [rsp + rax], 0
40017d:   e8 29 00 00 00          	call	&lt;mystery&gt;			#  &lt;mystery&gt; 4001ab(.text+0x67)
                                        ; mystery (RSP) -&gt; we just pass in the data read from the user
400182:   31 c0                   	xor	eax, eax
400184:   48 81 c4 08 04 00 00    	add	rsp, 0x408
40018b:   c3                      	ret
+ Stopped after founding symbol '__entry_point' (18 instructions)
</code></pre>
<p>Time to save our work and take a break.<br>
Just type:</p>
<pre><code>STAN] case.save
</code></pre>
<h1>Finishing the challenge</h1>
<p>Hope you have had a nice break. I did. Now we can launch again STAN, but this time we are going to open the file from the STAN command-line</p>
<pre><code>$ stan
STAN is a sTAtic aNalyser. v 0.1
(c) pico

STAN] core.load /tmp/specimen
+ Cleanning up core
+ Deleting Segments....
+ Deleting Sections....
+ Deleting Symbols....
+ Opening file '/tmp/specimen'
+ Loaded '/tmp/specimen' 4808 bytes
+ ELF Machine ID: 62
+ Arch: 1 Mode:2 Type: 1
+ Processing Core...
Starting analysis
+ Processing 4 sections/segments
+ Processing section [0] '.text'
  * Analysing 342 instructions
+ Processing section [1] '.rodata'
+ Processing section [2] '.eh_frame'
+ Processing section [3] '.data'
STAN] case.load /tmp/specimen.srep
-&gt; SYMBOL: 'mystery' '4001ab'
 + Found function mystery
 + Found Symbol mystery
-&gt; FUNCTION: 'mystery' '0x4001ab'
-&gt; COMMENT: 'read (0 = stdin, RSP, 0x400)' '0x40016d'
-&gt; COMMENT: 'mystery (RSP) -&gt; we just pass in the data read from the user' '0x40017d'
STAN] 
</code></pre>
<p>As you can imagine <code>core.load</code> allows you to load a binary from the disk (you can use TAB completion to navigate the file system), then you use <code>case.load</code> to load your previous saved status. For the time being <code>case.save</code> saves the state as a file with the same name than the binary under analysis but with extension <code>.srep</code>.</p>
<p>Now we can go, and reverse the <code>mystery</code> function:</p>
<h1>Unveiling the <code>mystery</code>
</h1>
<p>Let’s disassemble <code>mystery</code></p>
<pre><code>STAN] &gt; dis.function mystery
+ Function 'mystery'@0x4001ab found at section '.text'(1075,342)

                               mystery:
4001ab:   51                      	push	rcx
4001ac:   be 77 05 40 00          	mov	esi, 0x400577		#  &lt;.rodata&gt; 400577(.rodata+0) : '0x00sec'
4001b1:   e8 98 02 00 00          	call	&lt;func_40044e&gt;			#  &lt;func_40044e&gt; 40044e(.text+0x30a)
4001b6:   85 c0                   	test	eax, eax
4001b8:   75 11                   	jne	&lt;l0&gt;			# 4001cb(.text+0x87)
4001ba:   ba 05 00 00 00          	mov	edx, 5
4001bf:   be 7f 05 40 00          	mov	esi, 0x40057f		#  40057f(.rodata+8) : 'Good\n'
4001c4:   bf 01 00 00 00          	mov	edi, 1
4001c9:   eb 11                   	jmp	&lt;l1&gt;			# 4001dc(.text+0x98)
                                    l0:
4001cb:   ba 04 00 00 00          	mov	edx, 4
4001d0:   be 85 05 40 00          	mov	esi, 0x400585		#  400585(.rodata+e) : 'Bad\n'
4001d5:   bf 01 00 00 00          	mov	edi, 1
4001da:   31 c0                   	xor	eax, eax
                                    l1:
4001dc:   e8 30 00 00 00          	call	&lt;maybe_write&gt;			#  &lt;maybe_write&gt; 400211(.text+0xcd)
4001e1:   83 c8 ff                	or	eax, 0xffffffff
4001e4:   5a                      	pop	rdx
4001e5:   c3                      	ret
</code></pre>
<p>Here we find two labels: <code>l0</code> and <code>l1</code>. And we can also see a call to what we believe is a <code>write</code> after setting the strings for the right and wrong password. Everything should be obvious now, but let’s  rename the labels for the LuLz</p>
<pre><code>STAN] &gt; label.rename l0 BadBoy
 + Found label l0
- DEBUG: Symbol 'l0' not found
STAN] &gt; label.rename l1 print_and_exit
 + Found label l1
- DEBUG: Symbol 'l1' not found
STAN] &gt; dis.function mystery
+ Function 'mystery'@0x4001ab found at section '.text'(1075,342)

                               mystery:
4001ab:   51                      	push	rcx
4001ac:   be 77 05 40 00          	mov	esi, 0x400577		#  &lt;.rodata&gt; 400577(.rodata+0) : '0x00sec'
4001b1:   e8 98 02 00 00          	call	&lt;func_40044e&gt;			#  &lt;func_40044e&gt; 40044e(.text+0x30a)
4001b6:   85 c0                   	test	eax, eax
4001b8:   75 11                   	jne	&lt;BadBoy&gt;			# 4001cb(.text+0x87)
4001ba:   ba 05 00 00 00          	mov	edx, 5
4001bf:   be 7f 05 40 00          	mov	esi, 0x40057f		#  40057f(.rodata+8) : 'Good\n'
4001c4:   bf 01 00 00 00          	mov	edi, 1
4001c9:   eb 11                   	jmp	&lt;print_and_exit&gt;			# 4001dc(.text+0x98)
                                BadBoy:
4001cb:   ba 04 00 00 00          	mov	edx, 4
4001d0:   be 85 05 40 00          	mov	esi, 0x400585		#  400585(.rodata+e) : 'Bad\n'
4001d5:   bf 01 00 00 00          	mov	edi, 1
4001da:   31 c0                   	xor	eax, eax
                        print_and_exit:
4001dc:   e8 30 00 00 00          	call	&lt;maybe_write&gt;			#  &lt;maybe_write&gt; 400211(.text+0xcd)
4001e1:   83 c8 ff                	or	eax, 0xffffffff
4001e4:   5a                      	pop	rdx
4001e5:   c3                      	ret
</code></pre>
<p>OK… so can you figure out the password for this crackme?<br>
In case you wonder, the <code>func_40044e</code> is actually <code>strcmp</code> you can dive deeper in the code to figure this out… <code>dis.function func_40044e</code>… this is a simple one if you want to try.</p>
<h1>Other commands you may find interesting</h1>
<p>Just for completion, these are a few commands that may also be useful if you want to play with STAN:</p>
<ul>
<li>
<p><code>comment.del addr</code>: Deletes a previous comment… sometimes we make mistakes <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
</li>
<li>
<p><code>mem.dump x addr count</code>. Dumps content of address <code>addr</code> as hex bytes. You can change <code>x</code> by <code>p</code> to dump words (pointers)</p>
<p><code>STAN] &gt; mem.dump x 0x400577 10</code></p>
</li>
<li>
<p><code>func.def</code>. This allows you to tell STAN that you believe there is a function at some address. As I said, the analysis module is pretty poor so you may spot obvious functions that STAN missed.</p>
</li>
</ul>
<p>And, I haven’t say that… but STAN is colourful <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:">. This is how our functions looks like after all our hard work <img src="https://0x00sec.org/images/emoji/twitter/wink.png?v=9" title=":wink:" class="emoji" alt=":wink:"></p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/f/f361ce0600547aae8c889ba32786b398ba907a3a.png" width="690" height="467"> </p>
<h1>Conclusions</h1>
<p>As a final note, I have found this little tool very useful. It is not as powerful as radare2 or binary ninja, but it is very easy to use and helps a bit but still force you to do some work… which is something good when you are starting and you are still learning the basics.</p>
<p>It is still a lot to do and as I said, it is kind of alpha SW, so, use it at your own risk <img src="https://0x00sec.org/images/emoji/twitter/blush.png?v=9" title=":blush:" class="emoji" alt=":blush:"></p>
<p>hack fun</p>
          <p><a href="https://0x00sec.org/t/introducing-stan-a-simple-tool-for-re-beginners/2505/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/introducing-stan-a-simple-tool-for-re-beginners/2505/1</link>
        <pubDate>Wed, 21 Jun 2017 22:23:25 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-2505-1</guid>
        <source url="https://0x00sec.org/t/introducing-stan-a-simple-tool-for-re-beginners/2505.rss">Introducing STAN. A simple tool for RE beginners</source>
      </item>
  </channel>
</rss>
