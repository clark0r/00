<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Tutorial: Creating Yara Signatures for Malware Detection</title>
    <link>https://0x00sec.org/t/tutorial-creating-yara-signatures-for-malware-detection/5453</link>
    <description># Tutorial: Creating Yara Signatures for Malware Detection

## Introduction
We all know it&#39;s way more fun to hack shit than to patch shit. That said, not all employers will be satisfied with a hacker who can only compromise systems. Some companies want security researchers that are able to apply patches based on malware samples/breach data they have collected or have found in the wild.

#### Author Assigned Level: Newbie or Wannabe


#### Required Skills
There really aren&#39;t too many skills required for this. The deeper you understand malware anlaysis and reverse engineering, the more capable you&#39;ll be at finding unique ways to catch malware. But this won&#39;t hinder you from writing amazing yara rules. Most of the rules I&#39;ve seen are pretty basic. Most look like a python script that took 5 minutes to write. The skill and detail comes in the analysis. Not in the actual yara rule itself.

* GNU Linux
* Familiar with C syntax  (not required, but useful)
* Regex (not required, but useful)
 

#### Disclaimer
I learned yara on the streets, not in the schools. I have about 30hrs experience with yara. A weekend for me.

-----
# The paper
I can finally be a bit more open when talking about yara. Most of what I&#39;ve been writing this weekend has been a bit...reserved as it was for work. We can now talk in a more relaxed environment.

I&#39;ll be going over the following:

1. Rule Identifiers
2. Yara Keywords
3. Strings
a. Hexadecimal
b. Text Strings
c. String Modifiers
d. Regular Expression
e. Sets of strings
f. Anonymous strings
4. Conditions
a. Boolean
b. Counting string instances
c. String offsets or virtual addresses
d. Match Length
e. File size
f. Executable entry_point
g. Accessing data at a given position
h. Applying one condition across many strings
i. Iterating over string occurrences
5. Referencing other rules
6. Yara Essentials
a. Global Rules
b. Private Rules
c. Rule tags
d. Metadata
e. Using Modules
f. Undefined values
g. External/Argument Values
h. Including Files

Let&#39;s get started. I want to do something else tonight besides just doc.

---

Yara mostly resembles the syntax of the C language. Here is a simple rule that does nothing.

&gt; rule HelloRule 
&gt; {
&gt; condition:
&gt; false
&gt; }


### Rule Identifier

The word the follows **rule**, in this case &quot;dummy&quot;, is known as the **rule identifier**. They can be:

* alphanumeric characters
* underscore character
* first char can&#39;t be a digit
* case-sensitive
* cannot exceed 128 characters

### Yara Keywords

The following can&#39;t be used as a rule identifier because they&#39;re special to the yara language.

&gt; all, and, any, ascii, at, condition, contains
&gt; entrypoint, false, filesize, fullword, for, global, in
&gt; import, include, int8, int16, int32, int8be, int16be
&gt; int32be, matches, meta, nocase, not, or, of
&gt; private, rule, strings, them, true, uint8, uint16
&gt; uint32, uint8be, uint16be, uint32be, wide

Generally, yara has two sections: **strings definition **and **condition**.

```php
rule HelloRule2    // This is an example
{
    strings:
        $my_text_string = &quot;text here&quot;
        $my_hex_string = { E2 34 A1 C8 23 FB }

    condition:
        $my_text_string or $my_hex_string
}
```

This rule will be active when either string is found.  
As you can see, you can also add comments.

---


## Hexadecimal Strings

**Wildcards**  
Acceptable uses for hex-strings are wildcards, which are represented with a &quot;?&quot; mark.

```php
rule GambitWildcard
{
    strings:
       $hex_string = { EF 44 ?? D8 A? FB }

    condition:
       $hex_string
}
```

This will catch any of the following:

```php
EF 44 01 D8 AA FB
EF 44 AA D8 AB FB
```

#### **Unknown Length of Wildcard  **

Strings with an unknown length can be represented as the following:

```php
rule MarioJump
{
        strings:
           $hex_string = { F4 23 [4-6] 62 B4 }

        condition:
           $hex_string
}
```

This will catch any of the following:

```php
F4 23 01 02 03 04 62 B4
F4 23 AA BB CC DD EE FF 62 B4
```

**Infinite** is also possible

```php
rule BuzzLightyear
{
        strings:
           $hex_string = { F4 23 [-] 62 B4 }

        condition:
           $hex_string
}
```

This will catch any of the following:

```php
F4 23 AA FF 62 B4
F4 23 AA AA AA AA AA...FF FF 62 B4
```

#### **Conditional Strings**

You can create 1 to as many statements as you like

```php
rule WorriedRabbit
{
    strings:
       $hex_string = { BA 21 ( DA BC | C6 ) A5 }

    condition:
       $hex_string
}
```

This will catch any of the following:

```php
BA 21 DA BC A5
BA 21 C6 A5
```

#### **Mixing it all up**

You can also combine them all, of course

```php
rule WorriedGabmitLightyearJump
{
    strings:
       $hex_string = { BA ?? ( DA [2-4] | C6 ) A5 }

    condition:
       $hex_string
}
```

This will catch any of the following:

```php
BA 01 DA 01 02 03 04 A5
BA AA C6 A5
BA FF DA 01 02 A5
```

---

## Text Strings

An alternative to hex-strings, one can also use text strings.

```php
rule KimPossible
{
    strings:
        $alert_string = &quot;Whats the Sitch&quot;

    condition:
       $alert_string
}
```

One can also use the following escape sequences, just like in C:

**\\* **Double Quotes  
**\** Backslash  
**\t** Horizontal Tab  
**\n** New line  
**\xdd** Any byte in hexadecimal notation

### Modifiers

#### **Case-insensitive strings**

By default, Yara is case-sensitive, but you can turn that off.

```php
rule ThickSkin
{
    strings:
        $strong_string = &quot;Iron&quot; nocase

    condition:
        $strong_string
}
```

#### Wide-character strings

The **wide** modifer can be used to search for strings encoded with two bytes per character, something typically in many executable binaries. If the string &quot;FatTony&quot; appears encoded as two bytes per character, it will be caught if we use the modifer **wide**. Let&#39;s also add the nocase modifier as &quot;FatTony&quot; might be &quot;fattony&quot; and we wouldn&#39;t want to miss that.

```php
rule FatTony
{
    strings:
        $fat_villain = &quot;FatTony&quot; wide nocase

    condition:
        $fat_villain
}
```

**\[ ! \] Important**: Keep in mind that this modifier interleaves the ASCII codes of the characters in the string with zeroes, it does not support truly UTF-16 strings containing non-English characters. To add a search for strings in both **ASCII** and **wide**, use the following:

```php
rule ASCIIFatTony
{
    strings:
        $fat_villain = &quot;FatTony&quot; wide ascii nocase

    condition:
        $fat_villain
}
```

**ASCII is assumed by default** so you don&#39;t have to add ascii if you want to search for FatTony by ascii alone.

```php
rule ASCIIFatTony
{
    strings:
        $fat_villain = &quot;FatTony&quot;

    condition:
        $fat_villain
}
```

This works if you want to search without the **wide **and** nocase** modifiers.

#### Fullwords Modifier

This modifier will catch on words that **DO NOT** have prepend and append the word with a character.

```php
rule ShadyDomain
{
    strings:
        $shady_domain = &quot;faceebook&quot; fullword

    condition:
       $shady_domain
}
```

This will catch any of the following:

```py
www.faceebook.com
www.myportal.faceebook.com
https://secure.faceebook.com
```

This will** NOT catch** any of the following:

```php
www.myfaceebook.com
thefaceebook.com
```

The difference is that that the fullword is prepended or appended by a _special character,_ not a _regular character_.

### Regular Expression

Enclosed in forward slashes instead of double quotes, \(like Perl Programming\), yara allows for RegEx.

```php
rule RegularShow
{
    strings:
        $re1 = /md5: [0-9a-fA-F]{32}/
        $re2 = /state: (on|off)/

    condition:
        $re1 and $re2
}
```

This will catch any md5 string it finds, in either state.

One can also apply text modifiers such as **nocase**,** ascii**,** wide**,** **and **fullword **to RegEx as well.

#### Metacharacters:

A **metacharacter** is a character that has a special meaning \(instead of a literal meaning\) to a computer program. For RegEx, these are the following meanings

**\** Quote the next metacharacter  
**^** Match the beginning of the file  
**$** Match the end of the file  
**\|** Alternation  
**\(\)** Grouping  
**\[\]** Bracketed character class

The following **quantifiers** are also recognized:

**\*** Match 0 or more times  
**+** Match 1 or more times  
**?** Match 0 or 1 times  
**{n}** Match exactly n-times  
**{n, }** Match at least n-times  
**{ ,m}** Match at most m-times  
**{n,m}** Match n to m-times.

The following **escape sequences** are recognized:

**\t** Tab \(HT, TAB\)  
**\n** New Line \(LF, NL\)  
**\r **Return \(CR\)  
**\f** Form feed \(FF\)  
**\a** Alarm bell  
**\xNN** Character whose ordinal number is the given hexadecimal number

These are the recognized character classes:

**\w** Match a _word \_character \(alphanumeric plus &quot;\_&quot;\)  
**\W** Match a non-word character  
**\s** Match a whitespace character  
**\S** Match a non-whitespace character  
**\d **Match a decimal digit character  
**\D** Match a non-digit character  
**\b** Match a word boundary  
**\B** Match except at a word boundary


#### Sets of strings

If the event where you want a certain number of strings from a list to be hit, you can implement the following:

```php
rule MigosPresent
{
    strings:
        $m1 = &quot;Quavo&quot;
        $m2 = &quot;Offset&quot;
        $m3 = &quot;Takeoff&quot;

    condition:
        2 of ($m1,$m2,$m3)
}
```

If any of the two Migos members are present, then the Migos are present.

You can also use wildcards to represent a set. Used this way, you would use the **\*** wildcard.

```php
rule MigosPresent
{
    strings:
        $m1 = &quot;Quavo&quot;
        $m2 = &quot;Offset&quot;
        $m3 = &quot;Takeoff&quot;

    condition:
        2 of ($m*)
}
```

To represent all variables in strings, you can use the **them** keyword.

```php
rule ThreeRappersPresent
{
    strings:
        $m1 = &quot;Quavo&quot;
        $m2 = &quot;Offset&quot;
        $m3 = &quot;Takeoff&quot;
        $q1 = &quot;Cardi B&quot;

    condition:
        3 of them // equivalent to 3 of ($*)
}
```

Any expression that returns a numeric value can be used. Here is an example of the keywords **any** and **all **being used.

```php
rule Squad
{
    strings:
        $m1 = &quot;Quavo&quot;
        $m2 = &quot;Offset&quot;
        $m3 = &quot;Takeoff&quot;
        $q1 = &quot;Cardi B&quot;

    condition:
        3 of them // equivalent to 3 of ($*)
        all of them
        any of ($*) and 2 of ($*)    // Fancy way of using any in a rule that requires 3.
}
```

#### Anonymous strings with **of** and **for...of**

If the event where you are not specifically referencing strings, you can just use **$** to reference them all.

```php
rule AnonymousStrings
{
    strings:
        $ = &quot;dummy1&quot;
        $ = &quot;dummy2&quot;

    condition:
        1 of them
}
```

---

## Conditions

Yara allows for boolean expressions via the operators, **and**, **or**, and **not **and** relational. **Arithmetic operators \(**+,-,\*,\,%**\) and bitwise operators \(**&amp;, \|, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, ~, ^**\) can also be used on numerical expressions.

#### Boolean

String identifiers can also be used within a condition, acting as a Boolean variables whose value depends on the presence or not of the associated string in a file.

```php
rule Example
{
    strings:
        $hero1a = &quot;Batman&quot;
        $hero1b = &quot;Robin&quot;
        $hero2a = &quot;Edward&quot;
        $hero2b = &quot;Alphonse&quot;

    condition:
        ($hero1a or $hero1b) and ($hero2a or $hero2b)
}
```

#### Counting string instances

Sometimes we need to know not only if a certain string is present or not, but how many times the string appears in the file or process memory. The number of occurrences of each string is represented by a variable whose name is the string identifier but with a \# character in place of the $ character. For example:

```c
rule Ransomware
{
    strings:
        $a = &quot;encrypted&quot;
        $b = &quot;btc&quot;

    condition:
        #a == 2 and #b &gt; 2
}
```

This rule matches any file or process containing the string $a exactly two times, and more than two occurrences of string $b.

#### String offsets or virtual addresses

In the majority of cases, when a string identifier is used in a condition, we are willing to know if the associated string is anywhere within the file or process memory, but sometimes we need to know **if the string is at some specific offset of the file** or **at some virtual address within the process address space**. In such situtations the operator **at** is what we need.

```c
rule Offset
{
    strings:
        $a = &quot;encrypted&quot;
        $b = &quot;btc&quot;

    condition:
        $a at 100 and $b at 200
}
```

If string $a is found at offset 100 within the file \(or at virtual address 100 if applied to a running process\), it will catch. The string $b should also be at offset 200. You can also use hexadecimal instead of decimal notation.

```c
rule Offset
{
    strings:
        $a = &quot;encrypted&quot;
        $b = &quot;btc&quot;

    condition:
        $a at 0x64 and $b at 0xC8
}
```

While the **at** operator is very specific, you can use the **in **operator to specify a range the string can be located at.

```c
rule InExample
{
    strings:
        $a = &quot;encrypted&quot;
        $b = &quot;btc&quot;

    condition:
        $a in (0..100) and $b in (100..filesize)
}
```

String $a must be found at offset between 0-100, while string $b must be at an offset between 100 and the end of the file EOF.

YOu can also get the offset or virtual address of the i-th occurrence of string $a by using **@a\[ i \]**. The indexes are one-based, so the first occurrence would be **@a\[1\]**, the second being **@a\[2\]**, and so on. It doesn&#39;t start at @a\[0\]. If you provide an index greater than the number of occurrences of the string, the result will be a NaN \(Not a Number\) value.

#### Match Length

For many regular expressions and hex strings containing jumps, the length of the match is variable. If you have the regular expression /fo\*/ the strings “fo”, “foo” and “fooo” can be matches, all of them with a different length.

You can use the length of the matches as part of your condition by using the character **!** in front of the string identifier, in a similar way you use the @ character for the offset. **!a\[1\]** **is the length for the first match of $a**, **!a\[2\]** **is the length for the second match, and so on. !a is a abbreviated form of !a\[1\].**

```php
rule Hak5
{
    strings:
        $re1 = /hack*/    // Will catch on hacker, hacked, hack, hack*

    condition:
        !re1[1] == 4 and !re1[2] &gt; 6
}
```

This will catch the following:

```
We hack things. We are hackers.
```

The first instance of &#39;hack&#39; is re1 and it&#39;s equal to length 4. the second instance of &#39;hack&#39; has at least length 6.

#### File size

String identifiers are not the only variables that can appear in the condition \(in fact, rules can be defined without any string definition\), there are other special variables that can be used as well. **filesize** holds the size of the file being scanned. The size is expressed in bytes.

```php
rule FileSizeExample
{
    condition:
       filesize &gt; 200KB
}
```

We use the **KB** postfix to set the size in which the file will be caught on to **200KB**. It automatically multiples the value of the constant by 1024. The **MB** postfix can be used to multiply the value by 2^20. Both prefixes can be used only with decimal constants.

**\[ ! \] Important**:** filesize **only works when the rule is applied to a file. If applied to a running process, it won&#39;t ever match.

#### Executable entry\_point

If the file is a **Portable Executable **\(**PE**\) or **Executable and Linkable Format** \(**ELF**\), this variable holds the raw offset of the executable&#39;s entry point in case we are scanning a file. If we&#39;re scanning a running process, the **entry\_point** will hold the virtual address of the main executable&#39;s entry point. \_A typical use of this variable is to look for some pattern at the entry point to detect packers or simple file infectors. \_The current way to use **entry\_point** is by importing the lib for **PE** and/or **ELF** and use their respective functions. Yara&#39;s **entrypoint** function is depreciated starting at version 3. This is how it looks pre-version 3.

```php
rule EntryPointExample1
{
    strings:
        $a = { E8 00 00 00 00 }

    condition:
       $a at entrypoint
}

rule EntryPointExample2
{
    strings:
        $a = { 9C 50 66 A1 ?? ?? ?? 00 66 A9 ?? ?? 58 0F 85 }

    condition:
       $a in (entrypoint..entrypoint + 10)
}
```

**\[ ! \] Important - **Again, **don&#39;t use yara&#39;s entrypoint**. Import PE and/or ELF and use **pe.entry\_point** and/or **elf.entry\_point**.

#### Accessing data at a given position

If you want to read data from a specific offset and save it as a variable you can use one of the following:

```php
int8(&lt;offset or virtual address&gt;)
int16(&lt;offset or virtual address&gt;)
int32(&lt;offset or virtual address&gt;)

uint8(&lt;offset or virtual address&gt;)
uint16(&lt;offset or virtual address&gt;)
uint32(&lt;offset or virtual address&gt;)

int8be(&lt;offset or virtual address&gt;)
int16be(&lt;offset or virtual address&gt;)
int32be(&lt;offset or virtual address&gt;)

uint8be(&lt;offset or virtual address&gt;)
uint16be(&lt;offset or virtual address&gt;)
uint32be(&lt;offset or virtual address&gt;)
```

Default is little-endian. If you want to read a big-endian integer use the corresponding function ending in **be**.

The &amp;lt;offset or virtual address&amp;gt; parameter can be any expression returning an unsigned integer, including the return value of one the uintXX functions itself.

```php
rule IsPE
{
  condition:
     // MZ signature at offset 0 and ...
     uint16(0) == 0x5A4D and
     // ... PE signature at offset stored in MZ header at 0x3C
     uint32(uint32(0x3C)) == 0x00004550
}
```

#### for...of: Applying one condition across many strings

To apply a for loop that will check if a set of strings are true to a specific condition, use the following syntax:

```php
for num of string_set : ( boolean_expression )
```

The **boolean\_expression** is evaluated for every string in **string\_set** and there must be at least **num** of them true.  
One can also exchange **num** with other keywords such as **all **or** any**.

```php
for any of ($a,$b,$c) : ( $ at elf.entry_point  )
```

The &quot;$&quot; represents all of the strings in the set. In this example, it&#39;s strings $a, $b, and $c.

You can also employ the symbols **\#** and **@** to make reference to the number of occurrences and the first offset of each string.

```php
for all of them : ( # &gt; 3 )
for all of ($a*) : ( @ &gt; @b )
```

#### Iterating over string occurrences

If you want to iterate over offsets and test a condition, one can do the following:

```php
rule Three_Peat
{
    strings:
        $a = &quot;dummy1&quot;
        $b = &quot;dummy2&quot;

    condition:
        for all i in (1,2,3) : ( @a[i] + 10 == @b[i] )
}
```

This rule says that the first three occurrences of $b should be 10 bytes away from the first three occurrences of $a. Another way to write this is the following:

```php
for all i in (1..3) : ( @a[i] + 10 == @b[i] )
```

We can also use expression as well. In this example, we are iterating over every occurrence of $a \(_remember that \#a represents the number of occurrences of $a_\). **This rule is specifying that every occurrence of $a should be within the first 100 bytes of the file.**

```php
for all i in (1..#a) : ( @a[i] &lt; 100 )
```

You can also set it so it&#39;s a set amount of occurrence for the first 100 bytes.

```php
for any i in (1..#a) : ( @a[i] &lt; 100 )
for 2 i in (1..#a) : ( @a[i] &lt; 100 )
```

#### Referencing other rules

Just like in C when referencing functions, the function, or in this case the rule, must be defined prior to being used.

```c
rule Rule1
{
    strings:
        $a = &quot;dummy1&quot;

    condition:
        $a
}

rule Rule2
{
    strings:
        $a = &quot;dummy2&quot;

    condition:
        $a and Rule1
}
```

---

## Yara Essentials

#### Global Rules

Allows users to impose restrictions in all the rules. If you want all your rules to ignore the files that exceed a certain size limit, you could go rule by rule making the required modifications to their conditions, or just write a global rule like this one:

```php
global rule SizeLimit
{
    condition:
        filesize &lt; 2MB
}
```

You can define as many global rules as you want. They&#39;ll run before the other rules.

#### Private Rules

Private rules don&#39;t have an output when they match. When paired with referencing other rules, this can allow for a cleaner output. Such that, to get to superMalicious, maybe one private rule is that file must be ELF. Once that is confirmed, then the next rule will execute. But we don&#39;t want to see ELF, in output. We just want to know if it&#39;s superMalicious or not. To create a private rule, just add **private** in front of rule.

```php
private rule PrivateRule
{
    ...
}
```

#### Rule tags

You can tag your rules in case you only want to see the output of type ruleName.

```php
rule TagsExample1 : Foo Bar Baz
{
    ...
}

rule TagsExample2 : Bar
{
    ...
}
```

#### Metadata

This allows for additional data to be stored in a rule.

```php
rule MetadataExample
{
    meta:
        my_identifier_1 = &quot;Some string data&quot;
        my_identifier_2 = 24
        my_identifier_3 = true

    strings:
        $my_text_string = &quot;text here&quot;
        $my_hex_string = { E2 34 A1 C8 23 FB }

    condition:
        $my_text_string or $my_hex_string
}
```

#### Using Modules

Some modules are officially distributed with YARA like PE and Cuckoo. They can be imported just like python, but add double quotes.

```py
import &quot;pe&quot;
import &quot;cuckoo&quot;
```

Once imported, you can use the feature by using its name prior to the function.

```c
pe.entry_point == 0x1000
cuckoo.http_request(/someregexp/)
```

#### Undefined Values

Some values are left as undefined when they are ran. If the following rule executes on a file that&#39;s of type ELF but it finds the string, it will result in something like TRUE &amp; Undefined.

```php
import &quot;pe&quot;

rule Test
{
  strings:
      $a = &quot;some string&quot;

  condition:
      $a and pe.entry_point == 0x1000
}
```

Be careful.

#### External Variables

External variables allow you to define rules which depend on values provided from &#39;the other side&#39;.

```php
rule ExternalVariable1
{
    condition:
       ext_var == 10
}
```

ext\_var is an external variable whos value is assigned at runtime, \(use **-d**  on the command line and parameter of **compile** and **match** methods in yara-python\). External variables could be of types: int, str, or boolean.

External variables can be used with the operators: **contains** and **matches**. **Contains** returns true if the string contains the specified substring. **Matches** returns true if the string matches the given **regular expression**.

```php
rule ExternalVariable2
{
    condition:
        string_ext_var contains &quot;text&quot;
}

rule ExternalVariable3
{
    condition:
        string_ext_var matches /[a-z]+/
}
```

**Contains **is True for ExternalVariable2 and **matches** is True for ExternalVariable3

You can also use regex modifiers along with the matches operator.

```php
rule ExternalVariableExample5
{
    condition:
        /* case insensitive single-line mode */
        string_ext_var matches /[a-z]+/is
}
```

This will match for case-insensitive due to the **i**.

Remember, you must define all external variables at run-time. This can be done with the **-d **argument.

#### Including files

Of course, you can include other files in yara, using the C-type import, \#include...but without the \# and with double quotes. You can use relative paths, absolute paths, and if windows, paths with drives.

```py
include &quot;Migos.yar&quot;
include &quot;../CardiB.yar&quot;
include &quot;/home/user/yara/IsRapper.yar&quot;
include &quot;c:\\yara\\includes\\oldRappers.yar&quot;
include &quot;c://yara/includes/oldRappers.yar&quot;
```
----
# Conclusions
Alright, now you know how to write some Yara Rules.
Here&#39;s some malware repos, rules, and tools that allow you to generate yara rules. If you install yarGen, just point it at the malware, and it will the write a signature for that malware. If you want to catch a family of malware, it&#39;s better to generalize it across the entire family.

Resources:
https://github.com/Yara-Rules/rules
https://www.bsk-consulting.de/2015/02/16/write-simple-sound-yara-rules/
&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/d/db6c7562f43757b690942a27eb7b0960d6833d5d.png&quot; width=&quot;468&quot; height=&quot;386&quot;&gt;https://www.f-secure.com/v-descs/worm_w32_downadup_al.shtml
https://www.f-secure.com/v-descs/worm_w32_downadup.shtml
https://support.microsoft.com/en-us/help/962007/virus-alert-about-the-win32-conficker-worm
https://www.f-secure.com/v-descs/worm_w32_downadup_a.shtml
https://www.f-secure.com/v-descs/worm_w32_downadup_gen.shtml
https://www.f-secure.com/v-descs/worm_w32_downaduprun_a.shtml

Yara
https://www.experts-exchange.com/questions/29042297/How-to-test-yara-rule.html
https://www.securityartwork.es/2013/10/11/yara-101/
https://stixproject.github.io/documentation/idioms/yara-test-mechanism/
https://github.com/Neo23x0/yarGen
https://github.com/radare/radare2/blob/master/doc/yara.md
https://www.bsk-consulting.de/2015/02/16/write-simple-sound-yara-rules/
https://www.bsk-consulting.de/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/
https://www.bsk-consulting.de/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/

xxd
https://www.systutorials.com/docs/linux/man/1-xxd/

comparing command
awk &#39;FNR==NR{a[$1];next}($1 in a){print}&#39; malcourse.strings zoo.conficker.strings &gt; same-strings

Malware repos
https://github.com/Malshare/MalShare-Toolkit.git
http://malshare.com/about.php

\#FreestyleFebruary</description>
    
    <lastBuildDate>Thu, 22 Feb 2018 09:11:47 +0000</lastBuildDate>
    <category>Malware</category>
    <atom:link href="https://0x00sec.org/t/tutorial-creating-yara-signatures-for-malware-detection/5453.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Tutorial: Creating Yara Signatures for Malware Detection</title>
        <dc:creator><![CDATA[system]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 30 days. New replies are no longer allowed.</p>
          <p><a href="https://0x00sec.org/t/tutorial-creating-yara-signatures-for-malware-detection/5453/4">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/tutorial-creating-yara-signatures-for-malware-detection/5453/4</link>
        <pubDate>Wed, 14 Mar 2018 11:00:47 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-5453-4</guid>
        <source url="https://0x00sec.org/t/tutorial-creating-yara-signatures-for-malware-detection/5453.rss">Tutorial: Creating Yara Signatures for Malware Detection</source>
      </item>
      <item>
        <title>Tutorial: Creating Yara Signatures for Malware Detection</title>
        <dc:creator><![CDATA[Sirius]]></dc:creator>
        <description><![CDATA[
            <p>You’re missing a <span class="hashtag">#FreestyleFebruary</span> tag, my guy.</p>
          <p><a href="https://0x00sec.org/t/tutorial-creating-yara-signatures-for-malware-detection/5453/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/tutorial-creating-yara-signatures-for-malware-detection/5453/2</link>
        <pubDate>Mon, 12 Feb 2018 18:12:44 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-5453-2</guid>
        <source url="https://0x00sec.org/t/tutorial-creating-yara-signatures-for-malware-detection/5453.rss">Tutorial: Creating Yara Signatures for Malware Detection</source>
      </item>
      <item>
        <title>Tutorial: Creating Yara Signatures for Malware Detection</title>
        <dc:creator><![CDATA[REal0day]]></dc:creator>
        <description><![CDATA[
            <h1>Tutorial: Creating Yara Signatures for Malware Detection</h1>
<h2>Introduction</h2>
<p>We all know it’s way more fun to hack shit than to patch shit. That said, not all employers will be satisfied with a hacker who can only compromise systems. Some companies want security researchers that are able to apply patches based on malware samples/breach data they have collected or have found in the wild.</p>
<h4>Author Assigned Level: Newbie or Wannabe</h4>
<h4>Required Skills</h4>
<p>There really aren’t too many skills required for this. The deeper you understand malware anlaysis and reverse engineering, the more capable you’ll be at finding unique ways to catch malware. But this won’t hinder you from writing amazing yara rules. Most of the rules I’ve seen are pretty basic. Most look like a python script that took 5 minutes to write. The skill and detail comes in the analysis. Not in the actual yara rule itself.</p>
<ul>
<li>GNU Linux</li>
<li>Familiar with C syntax  (not required, but useful)</li>
<li>Regex (not required, but useful)</li>
</ul>
<h4>Disclaimer</h4>
<p>I learned yara on the streets, not in the schools. I have about 30hrs experience with yara. A weekend for me.</p>
<hr>
<h1>The paper</h1>
<p>I can finally be a bit more open when talking about yara. Most of what I’ve been writing this weekend has been a bit…reserved as it was for work. We can now talk in a more relaxed environment.</p>
<p>I’ll be going over the following:</p>
<ol>
<li>Rule Identifiers</li>
<li>Yara Keywords</li>
<li>Strings<br>
a. Hexadecimal<br>
b. Text Strings<br>
c. String Modifiers<br>
d. Regular Expression<br>
e. Sets of strings<br>
f. Anonymous strings</li>
<li>Conditions<br>
a. Boolean<br>
b. Counting string instances<br>
c. String offsets or virtual addresses<br>
d. Match Length<br>
e. File size<br>
f. Executable entry_point<br>
g. Accessing data at a given position<br>
h. Applying one condition across many strings<br>
i. Iterating over string occurrences</li>
<li>Referencing other rules</li>
<li>Yara Essentials<br>
a. Global Rules<br>
b. Private Rules<br>
c. Rule tags<br>
d. Metadata<br>
e. Using Modules<br>
f. Undefined values<br>
g. External/Argument Values<br>
h. Including Files</li>
</ol>
<p>Let’s get started. I want to do something else tonight besides just doc.</p>
<hr>
<p>Yara mostly resembles the syntax of the C language. Here is a simple rule that does nothing.</p>
<blockquote>
<p>rule HelloRule<br>
{<br>
condition:<br>
false<br>
}</p>
</blockquote>
<h3>Rule Identifier</h3>
<p>The word the follows <strong>rule</strong>, in this case “dummy”, is known as the <strong>rule identifier</strong>. They can be:</p>
<ul>
<li>alphanumeric characters</li>
<li>underscore character</li>
<li>first char can’t be a digit</li>
<li>case-sensitive</li>
<li>cannot exceed 128 characters</li>
</ul>
<h3>Yara Keywords</h3>
<p>The following can’t be used as a rule identifier because they’re special to the yara language.</p>
<blockquote>
<p>all, and, any, ascii, at, condition, contains<br>
entrypoint, false, filesize, fullword, for, global, in<br>
import, include, int8, int16, int32, int8be, int16be<br>
int32be, matches, meta, nocase, not, or, of<br>
private, rule, strings, them, true, uint8, uint16<br>
uint32, uint8be, uint16be, uint32be, wide</p>
</blockquote>
<p>Generally, yara has two sections: **strings definition **and <strong>condition</strong>.</p>
<pre><code class="lang-php">rule HelloRule2    // This is an example
{
    strings:
        $my_text_string = "text here"
        $my_hex_string = { E2 34 A1 C8 23 FB }

    condition:
        $my_text_string or $my_hex_string
}
</code></pre>
<p>This rule will be active when either string is found.<br>
As you can see, you can also add comments.</p>
<hr>
<h2>Hexadecimal Strings</h2>
<p><strong>Wildcards</strong><br>
Acceptable uses for hex-strings are wildcards, which are represented with a “?” mark.</p>
<pre><code class="lang-php">rule GambitWildcard
{
    strings:
       $hex_string = { EF 44 ?? D8 A? FB }

    condition:
       $hex_string
}
</code></pre>
<p>This will catch any of the following:</p>
<pre><code class="lang-php">EF 44 01 D8 AA FB
EF 44 AA D8 AB FB
</code></pre>
<h4>**Unknown Length of Wildcard  **</h4>
<p>Strings with an unknown length can be represented as the following:</p>
<pre><code class="lang-php">rule MarioJump
{
        strings:
           $hex_string = { F4 23 [4-6] 62 B4 }

        condition:
           $hex_string
}
</code></pre>
<p>This will catch any of the following:</p>
<pre><code class="lang-php">F4 23 01 02 03 04 62 B4
F4 23 AA BB CC DD EE FF 62 B4
</code></pre>
<p><strong>Infinite</strong> is also possible</p>
<pre><code class="lang-php">rule BuzzLightyear
{
        strings:
           $hex_string = { F4 23 [-] 62 B4 }

        condition:
           $hex_string
}
</code></pre>
<p>This will catch any of the following:</p>
<pre><code class="lang-php">F4 23 AA FF 62 B4
F4 23 AA AA AA AA AA...FF FF 62 B4
</code></pre>
<h4><strong>Conditional Strings</strong></h4>
<p>You can create 1 to as many statements as you like</p>
<pre><code class="lang-php">rule WorriedRabbit
{
    strings:
       $hex_string = { BA 21 ( DA BC | C6 ) A5 }

    condition:
       $hex_string
}
</code></pre>
<p>This will catch any of the following:</p>
<pre><code class="lang-php">BA 21 DA BC A5
BA 21 C6 A5
</code></pre>
<h4><strong>Mixing it all up</strong></h4>
<p>You can also combine them all, of course</p>
<pre><code class="lang-php">rule WorriedGabmitLightyearJump
{
    strings:
       $hex_string = { BA ?? ( DA [2-4] | C6 ) A5 }

    condition:
       $hex_string
}
</code></pre>
<p>This will catch any of the following:</p>
<pre><code class="lang-php">BA 01 DA 01 02 03 04 A5
BA AA C6 A5
BA FF DA 01 02 A5
</code></pre>
<hr>
<h2>Text Strings</h2>
<p>An alternative to hex-strings, one can also use text strings.</p>
<pre><code class="lang-php">rule KimPossible
{
    strings:
        $alert_string = "Whats the Sitch"

    condition:
       $alert_string
}
</code></pre>
<p>One can also use the following escape sequences, just like in C:</p>
<p>*<em>\</em> **Double Quotes<br>
*<em>*</em> Backslash<br>
<strong>\t</strong> Horizontal Tab<br>
<strong>\n</strong> New line<br>
<strong>\xdd</strong> Any byte in hexadecimal notation</p>
<h3>Modifiers</h3>
<h4><strong>Case-insensitive strings</strong></h4>
<p>By default, Yara is case-sensitive, but you can turn that off.</p>
<pre><code class="lang-php">rule ThickSkin
{
    strings:
        $strong_string = "Iron" nocase

    condition:
        $strong_string
}
</code></pre>
<h4>Wide-character strings</h4>
<p>The <strong>wide</strong> modifer can be used to search for strings encoded with two bytes per character, something typically in many executable binaries. If the string “FatTony” appears encoded as two bytes per character, it will be caught if we use the modifer <strong>wide</strong>. Let’s also add the nocase modifier as “FatTony” might be “fattony” and we wouldn’t want to miss that.</p>
<pre><code class="lang-php">rule FatTony
{
    strings:
        $fat_villain = "FatTony" wide nocase

    condition:
        $fat_villain
}
</code></pre>
<p><strong>[ ! ] Important</strong>: Keep in mind that this modifier interleaves the ASCII codes of the characters in the string with zeroes, it does not support truly UTF-16 strings containing non-English characters. To add a search for strings in both <strong>ASCII</strong> and <strong>wide</strong>, use the following:</p>
<pre><code class="lang-php">rule ASCIIFatTony
{
    strings:
        $fat_villain = "FatTony" wide ascii nocase

    condition:
        $fat_villain
}
</code></pre>
<p><strong>ASCII is assumed by default</strong> so you don’t have to add ascii if you want to search for FatTony by ascii alone.</p>
<pre><code class="lang-php">rule ASCIIFatTony
{
    strings:
        $fat_villain = "FatTony"

    condition:
        $fat_villain
}
</code></pre>
<p>This works if you want to search without the <strong>wide <strong>and</strong> nocase</strong> modifiers.</p>
<h4>Fullwords Modifier</h4>
<p>This modifier will catch on words that <strong>DO NOT</strong> have prepend and append the word with a character.</p>
<pre><code class="lang-php">rule ShadyDomain
{
    strings:
        $shady_domain = "faceebook" fullword

    condition:
       $shady_domain
}
</code></pre>
<p>This will catch any of the following:</p>
<pre><code class="lang-auto">www.faceebook.com
www.myportal.faceebook.com
https://secure.faceebook.com
</code></pre>
<p>This will** NOT catch** any of the following:</p>
<pre><code class="lang-php">www.myfaceebook.com
thefaceebook.com
</code></pre>
<p>The difference is that that the fullword is prepended or appended by a <em>special character,</em> not a <em>regular character</em>.</p>
<h3>Regular Expression</h3>
<p>Enclosed in forward slashes instead of double quotes, (like Perl Programming), yara allows for RegEx.</p>
<pre><code class="lang-php">rule RegularShow
{
    strings:
        $re1 = /md5: [0-9a-fA-F]{32}/
        $re2 = /state: (on|off)/

    condition:
        $re1 and $re2
}
</code></pre>
<p>This will catch any md5 string it finds, in either state.</p>
<p>One can also apply text modifiers such as <strong>nocase</strong>,** ascii**,** wide**,** **and **fullword **to RegEx as well.</p>
<h4>Metacharacters:</h4>
<p>A <strong>metacharacter</strong> is a character that has a special meaning (instead of a literal meaning) to a computer program. For RegEx, these are the following meanings</p>
<p>*<em>*</em> Quote the next metacharacter<br>
<strong>^</strong> Match the beginning of the file<br>
<strong>$</strong> Match the end of the file<br>
<strong>|</strong> Alternation<br>
<strong>()</strong> Grouping<br>
<strong>[]</strong> Bracketed character class</p>
<p>The following <strong>quantifiers</strong> are also recognized:</p>
<p><strong>*</strong> Match 0 or more times<br>
<strong>+</strong> Match 1 or more times<br>
<strong>?</strong> Match 0 or 1 times<br>
<strong>{n}</strong> Match exactly n-times<br>
<strong>{n, }</strong> Match at least n-times<br>
<strong>{ ,m}</strong> Match at most m-times<br>
<strong>{n,m}</strong> Match n to m-times.</p>
<p>The following <strong>escape sequences</strong> are recognized:</p>
<p><strong>\t</strong> Tab (HT, TAB)<br>
<strong>\n</strong> New Line (LF, NL)<br>
**\r **Return (CR)<br>
<strong>\f</strong> Form feed (FF)<br>
<strong>\a</strong> Alarm bell<br>
<strong>\xNN</strong> Character whose ordinal number is the given hexadecimal number</p>
<p>These are the recognized character classes:</p>
<p><strong>\w</strong> Match a _word _character (alphanumeric plus “_”)<br>
<strong>\W</strong> Match a non-word character<br>
<strong>\s</strong> Match a whitespace character<br>
<strong>\S</strong> Match a non-whitespace character<br>
**\d **Match a decimal digit character<br>
<strong>\D</strong> Match a non-digit character<br>
<strong>\b</strong> Match a word boundary<br>
<strong>\B</strong> Match except at a word boundary</p>
<h4>Sets of strings</h4>
<p>If the event where you want a certain number of strings from a list to be hit, you can implement the following:</p>
<pre><code class="lang-php">rule MigosPresent
{
    strings:
        $m1 = "Quavo"
        $m2 = "Offset"
        $m3 = "Takeoff"

    condition:
        2 of ($m1,$m2,$m3)
}
</code></pre>
<p>If any of the two Migos members are present, then the Migos are present.</p>
<p>You can also use wildcards to represent a set. Used this way, you would use the <strong>*</strong> wildcard.</p>
<pre><code class="lang-php">rule MigosPresent
{
    strings:
        $m1 = "Quavo"
        $m2 = "Offset"
        $m3 = "Takeoff"

    condition:
        2 of ($m*)
}
</code></pre>
<p>To represent all variables in strings, you can use the <strong>them</strong> keyword.</p>
<pre><code class="lang-php">rule ThreeRappersPresent
{
    strings:
        $m1 = "Quavo"
        $m2 = "Offset"
        $m3 = "Takeoff"
        $q1 = "Cardi B"

    condition:
        3 of them // equivalent to 3 of ($*)
}
</code></pre>
<p>Any expression that returns a numeric value can be used. Here is an example of the keywords <strong>any</strong> and **all **being used.</p>
<pre><code class="lang-php">rule Squad
{
    strings:
        $m1 = "Quavo"
        $m2 = "Offset"
        $m3 = "Takeoff"
        $q1 = "Cardi B"

    condition:
        3 of them // equivalent to 3 of ($*)
        all of them
        any of ($*) and 2 of ($*)    // Fancy way of using any in a rule that requires 3.
}
</code></pre>
<h4>Anonymous strings with <strong>of</strong> and <strong>for…of</strong>
</h4>
<p>If the event where you are not specifically referencing strings, you can just use <strong>$</strong> to reference them all.</p>
<pre><code class="lang-php">rule AnonymousStrings
{
    strings:
        $ = "dummy1"
        $ = "dummy2"

    condition:
        1 of them
}
</code></pre>
<hr>
<h2>Conditions</h2>
<p>Yara allows for boolean expressions via the operators, <strong>and</strong>, <strong>or</strong>, and <strong>not <strong>and</strong> relational. <strong>Arithmetic operators (</strong>+,-,*,,%</strong>) and bitwise operators (<strong>&amp;, |, &lt;&lt;, &gt;&gt;, ~, ^</strong>) can also be used on numerical expressions.</p>
<h4>Boolean</h4>
<p>String identifiers can also be used within a condition, acting as a Boolean variables whose value depends on the presence or not of the associated string in a file.</p>
<pre><code class="lang-php">rule Example
{
    strings:
        $hero1a = "Batman"
        $hero1b = "Robin"
        $hero2a = "Edward"
        $hero2b = "Alphonse"

    condition:
        ($hero1a or $hero1b) and ($hero2a or $hero2b)
}
</code></pre>
<h4>Counting string instances</h4>
<p>Sometimes we need to know not only if a certain string is present or not, but how many times the string appears in the file or process memory. The number of occurrences of each string is represented by a variable whose name is the string identifier but with a # character in place of the $ character. For example:</p>
<pre><code class="lang-auto">rule Ransomware
{
    strings:
        $a = "encrypted"
        $b = "btc"

    condition:
        #a == 2 and #b &gt; 2
}
</code></pre>
<p>This rule matches any file or process containing the string $a exactly two times, and more than two occurrences of string $b.</p>
<h4>String offsets or virtual addresses</h4>
<p>In the majority of cases, when a string identifier is used in a condition, we are willing to know if the associated string is anywhere within the file or process memory, but sometimes we need to know <strong>if the string is at some specific offset of the file</strong> or <strong>at some virtual address within the process address space</strong>. In such situtations the operator <strong>at</strong> is what we need.</p>
<pre><code class="lang-auto">rule Offset
{
    strings:
        $a = "encrypted"
        $b = "btc"

    condition:
        $a at 100 and $b at 200
}
</code></pre>
<p>If string $a is found at offset 100 within the file (or at virtual address 100 if applied to a running process), it will catch. The string $b should also be at offset 200. You can also use hexadecimal instead of decimal notation.</p>
<pre><code class="lang-auto">rule Offset
{
    strings:
        $a = "encrypted"
        $b = "btc"

    condition:
        $a at 0x64 and $b at 0xC8
}
</code></pre>
<p>While the <strong>at</strong> operator is very specific, you can use the **in **operator to specify a range the string can be located at.</p>
<pre><code class="lang-auto">rule InExample
{
    strings:
        $a = "encrypted"
        $b = "btc"

    condition:
        $a in (0..100) and $b in (100..filesize)
}
</code></pre>
<p>String $a must be found at offset between 0-100, while string $b must be at an offset between 100 and the end of the file EOF.</p>
<p>YOu can also get the offset or virtual address of the i-th occurrence of string $a by using <strong><span class="mention">@a</span>[ i ]</strong>. The indexes are one-based, so the first occurrence would be <strong><span class="mention">@a</span>[1]</strong>, the second being <strong><span class="mention">@a</span>[2]</strong>, and so on. It doesn’t start at <span class="mention">@a</span>[0]. If you provide an index greater than the number of occurrences of the string, the result will be a NaN (Not a Number) value.</p>
<h4>Match Length</h4>
<p>For many regular expressions and hex strings containing jumps, the length of the match is variable. If you have the regular expression /fo*/ the strings “fo”, “foo” and “fooo” can be matches, all of them with a different length.</p>
<p>You can use the length of the matches as part of your condition by using the character <strong>!</strong> in front of the string identifier, in a similar way you use the @ character for the offset. <strong>!a[1]</strong> <strong>is the length for the first match of $a</strong>, <strong>!a[2]</strong> <strong>is the length for the second match, and so on. !a is a abbreviated form of !a[1].</strong></p>
<pre><code class="lang-php">rule Hak5
{
    strings:
        $re1 = /hack*/    // Will catch on hacker, hacked, hack, hack*

    condition:
        !re1[1] == 4 and !re1[2] &gt; 6
}
</code></pre>
<p>This will catch the following:</p>
<pre><code class="lang-auto">We hack things. We are hackers.
</code></pre>
<p>The first instance of ‘hack’ is re1 and it’s equal to length 4. the second instance of ‘hack’ has at least length 6.</p>
<h4>File size</h4>
<p>String identifiers are not the only variables that can appear in the condition (in fact, rules can be defined without any string definition), there are other special variables that can be used as well. <strong>filesize</strong> holds the size of the file being scanned. The size is expressed in bytes.</p>
<pre><code class="lang-php">rule FileSizeExample
{
    condition:
       filesize &gt; 200KB
}
</code></pre>
<p>We use the <strong>KB</strong> postfix to set the size in which the file will be caught on to <strong>200KB</strong>. It automatically multiples the value of the constant by 1024. The <strong>MB</strong> postfix can be used to multiply the value by 2^20. Both prefixes can be used only with decimal constants.</p>
<p><strong>[ ! ] Important</strong>:** filesize **only works when the rule is applied to a file. If applied to a running process, it won’t ever match.</p>
<h4>Executable entry_point</h4>
<p>If the file is a **Portable Executable **(<strong>PE</strong>) or <strong>Executable and Linkable Format</strong> (<strong>ELF</strong>), this variable holds the raw offset of the executable’s entry point in case we are scanning a file. If we’re scanning a running process, the <strong>entry_point</strong> will hold the virtual address of the main executable’s entry point. _A typical use of this variable is to look for some pattern at the entry point to detect packers or simple file infectors. _The current way to use <strong>entry_point</strong> is by importing the lib for <strong>PE</strong> and/or <strong>ELF</strong> and use their respective functions. Yara’s <strong>entrypoint</strong> function is depreciated starting at version 3. This is how it looks pre-version 3.</p>
<pre><code class="lang-php">rule EntryPointExample1
{
    strings:
        $a = { E8 00 00 00 00 }

    condition:
       $a at entrypoint
}

rule EntryPointExample2
{
    strings:
        $a = { 9C 50 66 A1 ?? ?? ?? 00 66 A9 ?? ?? 58 0F 85 }

    condition:
       $a in (entrypoint..entrypoint + 10)
}
</code></pre>
<p>**[ ! ] Important - **Again, <strong>don’t use yara’s entrypoint</strong>. Import PE and/or ELF and use <strong>pe.entry_point</strong> and/or <strong>elf.entry_point</strong>.</p>
<h4>Accessing data at a given position</h4>
<p>If you want to read data from a specific offset and save it as a variable you can use one of the following:</p>
<pre><code class="lang-php">int8(&lt;offset or virtual address&gt;)
int16(&lt;offset or virtual address&gt;)
int32(&lt;offset or virtual address&gt;)

uint8(&lt;offset or virtual address&gt;)
uint16(&lt;offset or virtual address&gt;)
uint32(&lt;offset or virtual address&gt;)

int8be(&lt;offset or virtual address&gt;)
int16be(&lt;offset or virtual address&gt;)
int32be(&lt;offset or virtual address&gt;)

uint8be(&lt;offset or virtual address&gt;)
uint16be(&lt;offset or virtual address&gt;)
uint32be(&lt;offset or virtual address&gt;)
</code></pre>
<p>Default is little-endian. If you want to read a big-endian integer use the corresponding function ending in <strong>be</strong>.</p>
<p>The &lt;offset or virtual address&gt; parameter can be any expression returning an unsigned integer, including the return value of one the uintXX functions itself.</p>
<pre><code class="lang-php">rule IsPE
{
  condition:
     // MZ signature at offset 0 and ...
     uint16(0) == 0x5A4D and
     // ... PE signature at offset stored in MZ header at 0x3C
     uint32(uint32(0x3C)) == 0x00004550
}
</code></pre>
<h4>for…of: Applying one condition across many strings</h4>
<p>To apply a for loop that will check if a set of strings are true to a specific condition, use the following syntax:</p>
<pre><code class="lang-php">for num of string_set : ( boolean_expression )
</code></pre>
<p>The <strong>boolean_expression</strong> is evaluated for every string in <strong>string_set</strong> and there must be at least <strong>num</strong> of them true.<br>
One can also exchange <strong>num</strong> with other keywords such as <strong>all <strong>or</strong> any</strong>.</p>
<pre><code class="lang-php">for any of ($a,$b,$c) : ( $ at elf.entry_point  )
</code></pre>
<p>The “$” represents all of the strings in the set. In this example, it’s strings $a, $b, and $c.</p>
<p>You can also employ the symbols <strong>#</strong> and <strong>@</strong> to make reference to the number of occurrences and the first offset of each string.</p>
<pre><code class="lang-php">for all of them : ( # &gt; 3 )
for all of ($a*) : ( @ &gt; @b )
</code></pre>
<h4>Iterating over string occurrences</h4>
<p>If you want to iterate over offsets and test a condition, one can do the following:</p>
<pre><code class="lang-php">rule Three_Peat
{
    strings:
        $a = "dummy1"
        $b = "dummy2"

    condition:
        for all i in (1,2,3) : ( @a[i] + 10 == @b[i] )
}
</code></pre>
<p>This rule says that the first three occurrences of $b should be 10 bytes away from the first three occurrences of $a. Another way to write this is the following:</p>
<pre><code class="lang-php">for all i in (1..3) : ( @a[i] + 10 == @b[i] )
</code></pre>
<p>We can also use expression as well. In this example, we are iterating over every occurrence of $a (<em>remember that <span class="hashtag">#a</span> represents the number of occurrences of $a</em>). <strong>This rule is specifying that every occurrence of $a should be within the first 100 bytes of the file.</strong></p>
<pre><code class="lang-php">for all i in (1..#a) : ( @a[i] &lt; 100 )
</code></pre>
<p>You can also set it so it’s a set amount of occurrence for the first 100 bytes.</p>
<pre><code class="lang-php">for any i in (1..#a) : ( @a[i] &lt; 100 )
for 2 i in (1..#a) : ( @a[i] &lt; 100 )
</code></pre>
<h4>Referencing other rules</h4>
<p>Just like in C when referencing functions, the function, or in this case the rule, must be defined prior to being used.</p>
<pre><code class="lang-auto">rule Rule1
{
    strings:
        $a = "dummy1"

    condition:
        $a
}

rule Rule2
{
    strings:
        $a = "dummy2"

    condition:
        $a and Rule1
}
</code></pre>
<hr>
<h2>Yara Essentials</h2>
<h4>Global Rules</h4>
<p>Allows users to impose restrictions in all the rules. If you want all your rules to ignore the files that exceed a certain size limit, you could go rule by rule making the required modifications to their conditions, or just write a global rule like this one:</p>
<pre><code class="lang-php">global rule SizeLimit
{
    condition:
        filesize &lt; 2MB
}
</code></pre>
<p>You can define as many global rules as you want. They’ll run before the other rules.</p>
<h4>Private Rules</h4>
<p>Private rules don’t have an output when they match. When paired with referencing other rules, this can allow for a cleaner output. Such that, to get to superMalicious, maybe one private rule is that file must be ELF. Once that is confirmed, then the next rule will execute. But we don’t want to see ELF, in output. We just want to know if it’s superMalicious or not. To create a private rule, just add <strong>private</strong> in front of rule.</p>
<pre><code class="lang-php">private rule PrivateRule
{
    ...
}
</code></pre>
<h4>Rule tags</h4>
<p>You can tag your rules in case you only want to see the output of type ruleName.</p>
<pre><code class="lang-php">rule TagsExample1 : Foo Bar Baz
{
    ...
}

rule TagsExample2 : Bar
{
    ...
}
</code></pre>
<h4>Metadata</h4>
<p>This allows for additional data to be stored in a rule.</p>
<pre><code class="lang-php">rule MetadataExample
{
    meta:
        my_identifier_1 = "Some string data"
        my_identifier_2 = 24
        my_identifier_3 = true

    strings:
        $my_text_string = "text here"
        $my_hex_string = { E2 34 A1 C8 23 FB }

    condition:
        $my_text_string or $my_hex_string
}
</code></pre>
<h4>Using Modules</h4>
<p>Some modules are officially distributed with YARA like PE and Cuckoo. They can be imported just like python, but add double quotes.</p>
<pre><code class="lang-auto">import "pe"
import "cuckoo"
</code></pre>
<p>Once imported, you can use the feature by using its name prior to the function.</p>
<pre><code class="lang-auto">pe.entry_point == 0x1000
cuckoo.http_request(/someregexp/)
</code></pre>
<h4>Undefined Values</h4>
<p>Some values are left as undefined when they are ran. If the following rule executes on a file that’s of type ELF but it finds the string, it will result in something like TRUE &amp; Undefined.</p>
<pre><code class="lang-php">import "pe"

rule Test
{
  strings:
      $a = "some string"

  condition:
      $a and pe.entry_point == 0x1000
}
</code></pre>
<p>Be careful.</p>
<h4>External Variables</h4>
<p>External variables allow you to define rules which depend on values provided from ‘the other side’.</p>
<pre><code class="lang-php">rule ExternalVariable1
{
    condition:
       ext_var == 10
}
</code></pre>
<p>ext_var is an external variable whos value is assigned at runtime, (use <strong>-d</strong>  on the command line and parameter of <strong>compile</strong> and <strong>match</strong> methods in yara-python). External variables could be of types: int, str, or boolean.</p>
<p>External variables can be used with the operators: <strong>contains</strong> and <strong>matches</strong>. <strong>Contains</strong> returns true if the string contains the specified substring. <strong>Matches</strong> returns true if the string matches the given <strong>regular expression</strong>.</p>
<pre><code class="lang-php">rule ExternalVariable2
{
    condition:
        string_ext_var contains "text"
}

rule ExternalVariable3
{
    condition:
        string_ext_var matches /[a-z]+/
}
</code></pre>
<p>**Contains **is True for ExternalVariable2 and <strong>matches</strong> is True for ExternalVariable3</p>
<p>You can also use regex modifiers along with the matches operator.</p>
<pre><code class="lang-php">rule ExternalVariableExample5
{
    condition:
        /* case insensitive single-line mode */
        string_ext_var matches /[a-z]+/is
}
</code></pre>
<p>This will match for case-insensitive due to the <strong>i</strong>.</p>
<p>Remember, you must define all external variables at run-time. This can be done with the **-d **argument.</p>
<h4>Including files</h4>
<p>Of course, you can include other files in yara, using the C-type import, <span class="hashtag">#include</span>…but without the # and with double quotes. You can use relative paths, absolute paths, and if windows, paths with drives.</p>
<pre><code class="lang-auto">include "Migos.yar"
include "../CardiB.yar"
include "/home/user/yara/IsRapper.yar"
include "c:\\yara\\includes\\oldRappers.yar"
include "c://yara/includes/oldRappers.yar"
</code></pre>
<hr>
<h1>Conclusions</h1>
<p>Alright, now you know how to write some Yara Rules.<br>
Here’s some malware repos, rules, and tools that allow you to generate yara rules. If you install yarGen, just point it at the malware, and it will the write a signature for that malware. If you want to catch a family of malware, it’s better to generalize it across the entire family.</p>
<p>Resources:<br>
<a href="https://github.com/Yara-Rules/rules" class="onebox" target="_blank" rel="noopener nofollow ugc">https://github.com/Yara-Rules/rules</a><br>
<a href="https://www.bsk-consulting.de/2015/02/16/write-simple-sound-yara-rules/" class="onebox" target="_blank" rel="noopener nofollow ugc">https://www.bsk-consulting.de/2015/02/16/write-simple-sound-yara-rules/</a><br>
<img src="//0x00sec.s3.amazonaws.com/original/2X/d/db6c7562f43757b690942a27eb7b0960d6833d5d.png" width="468" height="386"><a href="https://www.f-secure.com/v-descs/worm_w32_downadup_al.shtml" class="inline-onebox-loading" rel="noopener nofollow ugc">https://www.f-secure.com/v-descs/worm_w32_downadup_al.shtml</a><br>
<a href="https://www.f-secure.com/v-descs/worm_w32_downadup.shtml" class="inline-onebox-loading" rel="noopener nofollow ugc">https://www.f-secure.com/v-descs/worm_w32_downadup.shtml</a><br>
<a href="https://support.microsoft.com/en-us/help/962007/virus-alert-about-the-win32-conficker-worm" class="inline-onebox-loading" rel="noopener nofollow ugc">https://support.microsoft.com/en-us/help/962007/virus-alert-about-the-win32-conficker-worm</a><br>
<a href="https://www.f-secure.com/v-descs/worm_w32_downadup_a.shtml" class="inline-onebox-loading" rel="noopener nofollow ugc">https://www.f-secure.com/v-descs/worm_w32_downadup_a.shtml</a><br>
<a href="https://www.f-secure.com/v-descs/worm_w32_downadup_gen.shtml" class="inline-onebox-loading" rel="noopener nofollow ugc">https://www.f-secure.com/v-descs/worm_w32_downadup_gen.shtml</a><br>
<a href="https://www.f-secure.com/v-descs/worm_w32_downaduprun_a.shtml" class="inline-onebox-loading" rel="noopener nofollow ugc">https://www.f-secure.com/v-descs/worm_w32_downaduprun_a.shtml</a></p>
<p>Yara<br>
<a href="https://www.experts-exchange.com/questions/29042297/How-to-test-yara-rule.html" class="onebox" target="_blank" rel="noopener nofollow ugc">https://www.experts-exchange.com/questions/29042297/How-to-test-yara-rule.html</a><br>
<a href="https://www.securityartwork.es/2013/10/11/yara-101/" class="onebox" target="_blank" rel="noopener nofollow ugc">https://www.securityartwork.es/2013/10/11/yara-101/</a><br>
<a href="https://stixproject.github.io/documentation/idioms/yara-test-mechanism/" class="onebox" target="_blank" rel="noopener nofollow ugc">https://stixproject.github.io/documentation/idioms/yara-test-mechanism/</a><br>
<a href="https://github.com/Neo23x0/yarGen" class="onebox" target="_blank" rel="noopener nofollow ugc">https://github.com/Neo23x0/yarGen</a><br>
<a href="https://github.com/radare/radare2/blob/master/doc/yara.md" class="onebox" target="_blank" rel="noopener nofollow ugc">https://github.com/radare/radare2/blob/master/doc/yara.md</a><br>
<a href="https://www.bsk-consulting.de/2015/02/16/write-simple-sound-yara-rules/" class="onebox" target="_blank" rel="noopener nofollow ugc">https://www.bsk-consulting.de/2015/02/16/write-simple-sound-yara-rules/</a><br>
<a href="https://www.bsk-consulting.de/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/" class="onebox" target="_blank" rel="noopener nofollow ugc">https://www.bsk-consulting.de/2015/10/17/how-to-write-simple-but-sound-yara-rules-part-2/</a><br>
<a href="https://www.bsk-consulting.de/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/" class="onebox" target="_blank" rel="noopener nofollow ugc">https://www.bsk-consulting.de/2016/04/15/how-to-write-simple-but-sound-yara-rules-part-3/</a></p>
<p>xxd<br>
<a href="https://www.systutorials.com/docs/linux/man/1-xxd/" class="onebox" target="_blank" rel="noopener nofollow ugc">https://www.systutorials.com/docs/linux/man/1-xxd/</a></p>
<p>comparing command<br>
awk ‘FNR==NR{a[$1];next}($1 in a){print}’ malcourse.strings zoo.conficker.strings &gt; same-strings</p>
<p>Malware repos<br>
<a href="https://github.com/Malshare/MalShare-Toolkit.git" class="onebox" target="_blank" rel="noopener nofollow ugc">https://github.com/Malshare/MalShare-Toolkit.git</a><br>
<a href="http://malshare.com/about.php" class="onebox" target="_blank" rel="noopener nofollow ugc">http://malshare.com/about.php</a></p>
<p><span class="hashtag">#FreestyleFebruary</span></p>
          <p><a href="https://0x00sec.org/t/tutorial-creating-yara-signatures-for-malware-detection/5453/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/tutorial-creating-yara-signatures-for-malware-detection/5453/1</link>
        <pubDate>Mon, 12 Feb 2018 11:00:47 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-5453-1</guid>
        <source url="https://0x00sec.org/t/tutorial-creating-yara-signatures-for-malware-detection/5453.rss">Tutorial: Creating Yara Signatures for Malware Detection</source>
      </item>
  </channel>
</rss>
