<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>[Malware Analysis] Case GBC-17_124: The dropper Part II - Challenges - 0x00sec - The Home of the Hacker</title>
<meta name="description" content="Continuing the discussion from [Malware Analysis] Case GBC-17_124: The dropper Part I: 
The get_msg Function
Our analysis is going pretty well. By now, we know that the get_msg function is the one that gets the data from&amp;hellip;">
<meta name="generator" content="Discourse 3.1.0.beta6 - https://github.com/discourse/discourse version 80a1709965fa59da824b2e3392976fc6fc898f80">
<link rel="icon" type="image/png" href="../../uploads/default/optimized/2X/3/30c4e7d76acf879a124fdfe4d8d126afe628c189_2_32x32.png">
<link rel="apple-touch-icon" type="image/png" href="../../uploads/default/optimized/2X/c/c5e37f667fd0fe006ffa67653c662fb64fec597e_2_180x180.png">
<meta name="theme-color" media="all" content="#171616">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, user-scalable=yes, viewport-fit=cover">
<link rel="canonical" href="../malware-analysis-case-gbc-17-124-the-dripper-part-ii/3409.html" />
<link rel="search" type="application/opensearchdescription+xml" href="../../opensearch.xml" title="0x00sec - The Home of the Hacker Search">
<link href="../../stylesheets/color_definitions_0x00sec-v2_15_57_a5ef387651921c3e4c7aa1108536015ba8299efb.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" class="light-scheme" />
<link href="../../stylesheets/desktop_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="desktop" />
<link href="../../stylesheets/chat_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="chat" />
<link href="../../stylesheets/discourse-details_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-details" />
<link href="../../stylesheets/discourse-lazy-videos_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-lazy-videos" />
<link href="../../stylesheets/discourse-local-dates_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-local-dates" />
<link href="../../stylesheets/discourse-narrative-bot_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-narrative-bot" />
<link href="../../stylesheets/discourse-presence_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-presence" />
<link href="../../stylesheets/discourse-spoiler-alert_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-spoiler-alert" />
<link href="../../stylesheets/docker_manager_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="docker_manager" />
<link href="../../stylesheets/poll_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="poll" />
<link href="../../stylesheets/chat_desktop_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="chat_desktop" />
<link href="../../stylesheets/poll_desktop_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="poll_desktop" />
<link href="../../stylesheets/desktop_theme_46_f36ade55bf80933494fe3b5fab518f477de3bd4e.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="desktop_theme" data-theme-id="46" data-theme-name="header links v2" />
<link href="../../stylesheets/desktop_theme_57_8c0e890a61cdb4c5833a9f9c96664ed164e7d645.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="desktop_theme" data-theme-id="57" data-theme-name="0x00sec-v2" />
<link rel="stylesheet" href="https://s3.amazonaws.com/0x00sec/monokai-sublime.css">
<script src="https://s3.amazonaws.com/0x00sec/highlight.pack.js"></script>
<link rel="preload" href="../../theme-javascripts/440fd21108f5ba9e5dfe06cca9fc842569d5a874.js%3F__ws=0x00sec.org" as="script">
<script defer src="../../theme-javascripts/440fd21108f5ba9e5dfe06cca9fc842569d5a874.js%3F__ws=0x00sec.org" data-theme-id="40"></script>
<link rel="alternate nofollow" type="application/rss+xml" title="RSS feed of &#39;[Malware Analysis] Case GBC-17_124: The dropper Part II&#39;" href="3409.rss" />
<meta property="og:site_name" content="0x00sec - The Home of the Hacker" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://0x00sec.org/uploads/default/original/2X/2/27a5373af868edade07624e8205c46e79c247445.jpeg" />
<meta property="og:image" content="https://0x00sec.org/uploads/default/original/2X/2/27a5373af868edade07624e8205c46e79c247445.jpeg" />
<meta property="og:url" content="https://0x00sec.org/t/malware-analysis-case-gbc-17-124-the-dropper-part-ii/3409" />
<meta name="twitter:url" content="https://0x00sec.org/t/malware-analysis-case-gbc-17-124-the-dropper-part-ii/3409" />
<meta property="og:title" content="[Malware Analysis] Case GBC-17_124: The dropper Part II" />
<meta name="twitter:title" content="[Malware Analysis] Case GBC-17_124: The dropper Part II" />
<meta property="og:description" content="Continuing the discussion from [Malware Analysis] Case GBC-17_124: The dropper Part I:  The get_msg Function Our analysis is going pretty well. By now, we know that the get_msg function is the one that gets the data from the network, data that is later dumped into a file. Time to rip it off:                                 get_msg:                                           │ 00400aad:   55                      	push	rbp                               │ 00400aae:   48 89 e5                	mov	rbp..." />
<meta name="twitter:description" content="Continuing the discussion from [Malware Analysis] Case GBC-17_124: The dropper Part I:  The get_msg Function Our analysis is going pretty well. By now, we know that the get_msg function is the one that gets the data from the network, data that is later dumped into a file. Time to rip it off:                                 get_msg:                                           │ 00400aad:   55                      	push	rbp                               │ 00400aae:   48 89 e5                	mov	rbp..." />
<meta property="og:article:section" content="Reverse Engineering" />
<meta property="og:article:section:color" content="12A89D" />
<meta property="og:article:section" content="Challenges" />
<meta property="og:article:section:color" content="283890" />
<meta property="og:article:tag" content="malware" />
<meta property="og:article:tag" content="dropper" />
<meta property="og:article:tag" content="assembly" />
<meta property="og:article:tag" content="challengesolution" />
<meta name="twitter:label1" value="Reading time" />
<meta name="twitter:data1" value="7 mins 🕑" />
<meta name="twitter:label2" value="Likes" />
<meta name="twitter:data2" value="6 ❤" />
<meta property="article:published_time" content="2017-08-25T15:59:06+00:00" />
<meta property="og:ignore_canonical" content="true" />
</head>
<body class="crawler ">
<div id="top-navbar" class="container">
<span id="top-navbar-links" style="display:none;">

<a href="https://init.0x00sec.org" class="dow-menu">Init</a>
<a href="https://discord.gg/c6BHVfn" class="dow-menu">Discord</a>
<a href="https://init.0x00sec.org/?partners" class="dow-menu">Partners</a>
</span>
</div>
<header>
<a href="../../index.html">
0x00sec - The Home of the Hacker
</a>
</header>
<div id="main-outlet" class="wrap" role="main">
<div id="topic-title">
<h1>
<a href="../malware-analysis-case-gbc-17-124-the-dripper-part-ii/3409.html">[Malware Analysis] Case GBC-17_124: The dropper Part II</a>
</h1>
<div class="topic-category" itemscope itemtype="http://schema.org/BreadcrumbList">
<span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
<a href="../../c/reverse-engineering/58.html" class="badge-wrapper bullet" itemprop="item">
<span class="badge-category-bg" style="background-color: #12A89D"></span>
<span class="badge-category clear-badge">
<span class="category-name" itemprop="name">Reverse Engineering</span>
</span>
</a>
<meta itemprop="position" content="1" />
</span>
<span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
<a href="../../c/reverse-engineering/challenges.html" class="badge-wrapper bullet" itemprop="item">
<span class="badge-category-bg" style="background-color: #283890"></span>
<span class="badge-category clear-badge">
<span class="category-name" itemprop="name">Challenges</span>
</span>
</a>
<meta itemprop="position" content="2" />
</span>
</div>
<div class="topic-category">
<div class="discourse-tags list-tags">
<a href="../../tag/malware.html" class="discourse-tag" rel="tag">malware</a>,
<a href="../../tag/dropper.html" class="discourse-tag" rel="tag">dropper</a>,
<a href="../../tag/assembly.html" class="discourse-tag" rel="tag">assembly</a>,
<a href="../../tag/challengesolution.html" class="discourse-tag" rel="tag">challengesolution</a>
</div>
</div>
</div>
<div itemscope itemtype="http://schema.org/DiscussionForumPosting">
<meta itemprop="headline" content="[Malware Analysis] Case GBC-17_124: The dropper Part II">
<meta itemprop="articleSection" content="Challenges">
<meta itemprop="keywords" content="malware, dropper, assembly, challengesolution">
<div itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
<meta itemprop="name" content="0x00sec - The Home of the Hacker">
<div itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
<meta itemprop="url" content="https://0x00sec.org/uploads/default/original/2X/c/c5e37f667fd0fe006ffa67653c662fb64fec597e.png">
</div>
</div>
<div id="post_1" class="topic-body crawler-post">
<div class="crawler-post-meta">
<span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a itemprop="url" href="https://0x00sec.org/u/0x00pf"><span itemprop="name">0x00pf</span></a>
(pico)
</span>
<link itemprop="mainEntityOfPage" href="../malware-analysis-case-gbc-17-124-the-dripper-part-ii/3409.html">
<span class="crawler-post-infos">
<time itemprop="datePublished" datetime="2017-08-25T15:59:06Z" class="post-time">
August 25, 2017, 3:59pm
</time>
<meta itemprop="dateModified" content="2017-08-27T17:34:33Z">
<span itemprop="position">1</span>
</span>
</div>
<div class="post" itemprop="articleBody">
<p>Continuing the discussion from <a href="../malware-analysis-case-gbc-17-124-the-dropper-part-i/3408.html">[Malware Analysis] Case GBC-17_124: The dropper Part I</a>:</p>
<h1>The <code>get_msg</code> Function</h1>
<p>Our analysis is going pretty well. By now, we know that the <code>get_msg</code> function is the one that gets the data from the network, data that is later dumped into a file. Time to rip it off:</p>
<pre><code class="lang-auto">                               get_msg:                                           │
00400aad:   55                      	push	rbp                               │
00400aae:   48 89 e5                	mov	rbp, rsp                          │
00400ab1:   53                      	push	rbx                               │
00400ab2:   48 81 ec 58 04 00 00    	sub	rsp, 0x458                        │
00400ab9:   89 bd ac fb ff ff       	mov	dword ptr [rbp - 0x454], edi      │; {ls_rbp-1108}
00400abf:   48 89 b5 a0 fb ff ff    	mov	qword ptr [rbp - 0x460], rsi      │; {ls_rbp-1120}
00400ac6:   64 48 8b 04 25 28 00 00 	mov	rax, qword ptr fs:[0x28]          │
00400acf:   48 89 45 e8             	mov	qword ptr [rbp - 0x18], rax       │; {ls_rbp-24}
00400ad3:   31 c0                   	xor	eax, eax                          │
00400ad5:   e8 c6 fe ff ff          	call	&lt;rand@plt&gt;                        │; &lt;rand@plt&gt; 4009a0(.plt+0x140)
00400ada:   89 85 c4 fb ff ff       	mov	dword ptr [rbp - 0x43c], eax      │; {ls_rbp-1084}
</code></pre>
<p>We can see the typical stack arrangement common to normal C functions as well as the set of the canary in the stack to detect stack corruption. The function parameters are also stored in local variables at <code>rbp - 0x454</code> for the first parameter and <code>rbp-0x460</code> for the second.</p>
<p><em>Note: Remember that for Linux 64bits bits binaries, parameters are passed in registers as: <code>func (RDI, RSI, RDX, RCX)</code></em></p>
<p><em>Note1: <code>EDI</code> is actually the lower 32 bits part of the 64bits register <code>RDI</code></em></p>
<p>After that, we find a call to <code>rand</code> that, as you know, generates a random number. This first random number gets stored at <code>rbp + 0x43c</code>.</p>
<pre><code class="lang-auto">00400ae0:   8b 85 c4 fb ff ff       	mov	eax, dword ptr [rbp - 0x43c]      │; {ls_rbp-1084}
00400ae6:   89 c7                   	mov	edi, eax                          │
00400ae8:   e8 f3 fd ff ff          	call	&lt;htonl@plt&gt;                       │; &lt;htonl@plt&gt; 4008e0(.plt+0x80)
00400aed:   89 85 b8 fb ff ff       	mov	dword ptr [rbp - 0x448], eax      │; {ls_rbp-1096}
</code></pre>
<p>Then, that number is converted to network order and stored at local variable <code>rbp-0x448</code> to be used later.</p>
<pre><code class="lang-auto">00400af3:   48 8b 05 de 15 20 00    	mov	rax, qword ptr [rip + 0x2015de]   │; &lt;http_req&gt; 6020d8(.data+18)  :
00400afa:   48 89 c7                	mov	rdi, rax                          │
00400afd:   e8 7e fd ff ff          	call	&lt;strlen@plt&gt;                      │; &lt;strlen@plt&gt; 400880(.plt+0x20)
00400b02:   48 89 c2                	mov	rdx, rax                          │
00400b05:   48 8b 0d cc 15 20 00    	mov	rcx, qword ptr [rip + 0x2015cc]   │; &lt;http_req&gt; 6020d8(.data+18)  :
00400b0c:   8b 85 ac fb ff ff       	mov	eax, dword ptr [rbp - 0x454]      │; {ls_rbp-1108}
00400b12:   48 89 ce                	mov	rsi, rcx                          │
00400b15:   89 c7                   	mov	edi, eax                          │
00400b17:   e8 54 fd ff ff          	call	&lt;write@plt&gt;                       │; &lt;write@plt&gt; 400870(.plt+0x10)
</code></pre>
<p>Next, the program calculates the length of the <code>http_req</code> symbol and sends it through the network using <code>write</code>. We use as first parameter to <code>write</code> the local variable <code>rbp - 0x454</code> (see how that value flows into <code>RDI</code>). If you recall, <code>rbp - 0x454</code> contains the first parameter passed to the function. You can go quickly back to the <code>main</code> function and verify that the first parameter is actually the socket associated to the current server connection.</p>
<p>This is a good time to start naming variables using your preferred tool. As you progress filling in proper names for those <code>rbp + XXX</code> the code becomes more and more readable. Most disassemblers provides this option, so does STAN (check <code>func.var</code> command). I will not do that here so you can follow the paper even using <code>objdump</code> :).</p>
<p>Also note the instruction pointer relative addressing to reference <code>http_req</code>. This is common for global variables that lives in the <code>.data</code> segment instead of in the stack. We already have a symbol for it and our preferred disassembler is showing it. Depending on the tool you may already get the content of the global var. For instance, radare2 will generate a symbol whose name is actually the content of the string (when the variable points to a string). Something like this:</p>
<pre><code class="lang-auto">0x00400b38      488b05911520.  mov rax, qword [rip + 0x201591] ; [0x6020d0:8]=0x400fd8 str.HTTP_1.0_200_OK_
nServer:_ShadowHTTP_3.26__SECURED__nContent_type:_text_html__charset_UTF_8_nContent_Length:__1_n_nPNG LEA obj.http_hdr
; obj.http_hdr
</code></pre>
<p>With the current STAN version you have to manually dereference the pointer (this is going to change soon!). Something like this:</p>
<pre><code>STAN] &gt; mem.dump p 6020d8 1
+ Dumping 1 items from segment '.data'
0x6020d8: 0x401050	&lt;_IO_stdin_used +128&gt;

STAN] &gt; mem.dump x 401050 100
+ Dumping 100 items from segment '.rodata'
          | 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |0123456789abcdef
----------+-------------------------------------------------+----------------
0x401050 : 47 45 54 20 2f 20 48 54 54 50 2f 31 2e 31 0a 55 |GET / HTTP/1.1.U
0x401060 : 73 65 72 2d 41 67 65 6e 74 3a 42 6c 61 63 6b 4e |ser-Agent:BlackN
0x401070 : 69 62 62 6c 65 73 20 35 2e 33 32 20 78 4f 53 20 |ibbles 5.32 xOS
0x401080 : 32 2e 31 0a 0a 00 49 6e 76 61 6c 69 64 20 6e 75 |2.1...Invalid nu
0x401090 : 6d 62 65 72 20 6f 66 20 70 61 72 61 6d 65 74 65 |mber of paramete
0x4010a0 : 72 73 0a 00 73 6f 63 6b 65 74 3a 00 63 6f 6e 6e |rs..socket:.conn
0x4010b0 : 65 63 74 3a                                     |ect:
</code></pre>
<p>Anyway, the dropper has already sent an HTTP request to the remote server. Let’s see what happen next</p>
<pre><code class="lang-auto">00400b1c:   48 8d 8d b8 fb ff ff    	lea	rcx, qword ptr [rbp - 0x448]      │; {ls_rbp-1096}
00400b23:   8b 85 ac fb ff ff       	mov	eax, dword ptr [rbp - 0x454]      │; {ls_rbp-1108}
00400b29:   ba 04 00 00 00          	mov	edx, 4                            │
00400b2e:   48 89 ce                	mov	rsi, rcx                          │
00400b31:   89 c7                   	mov	edi, eax                          │
00400b33:   e8 38 fd ff ff          	call	&lt;write@plt&gt;                       │; &lt;write@plt&gt; 400870(.plt+0x10)
</code></pre>
<p>Right after that, the dropper sends to the server the random value generated at the beginning of the function in network order (<code>rbp - 0x448]</code>). Do you remember we have already seen this in the wireshark TCP Stream earlier on?</p>
<pre><code class="lang-auto">00400b38:   48 8b 05 91 15 20 00    	mov	rax, qword ptr [rip + 0x201591]   │; &lt;http_hdr&gt; 6020d0(.data+10)  :
00400b3f:   48 89 c7                	mov	rdi, rax                          │
00400b42:   e8 39 fd ff ff          	call	&lt;strlen@plt&gt;                      │; &lt;strlen@plt&gt; 400880(.plt+0x20)
00400b47:   48 89 c2                	mov	rdx, rax                          │
00400b4a:   48 8d 8d e0 fb ff ff    	lea	rcx, qword ptr [rbp - 0x420]      │; {ls_rbp-1056}
00400b51:   8b 85 ac fb ff ff       	mov	eax, dword ptr [rbp - 0x454]      │; {ls_rbp-1108}
00400b57:   48 89 ce                	mov	rsi, rcx                          │
00400b5a:   89 c7                   	mov	edi, eax                          │
00400b5c:   e8 9f fd ff ff          	call	&lt;read@plt&gt;                        │; &lt;read@plt&gt; 400900(.plt+0xa0)
</code></pre>
<p>And after that, it calculates the length of another global var (<code>http_hdr</code>) and reads that amount of data from the server. So, the dropper is expecting a specific header from the server. I already know that this data is going to be dump so I would not comment more on this.</p>
<pre><code class="lang-auto">00400b61:   48 8d 8d b8 fb ff ff    	lea	rcx, qword ptr [rbp - 0x448]      │; {ls_rbp-1096}
00400b68:   8b 85 ac fb ff ff       	mov	eax, dword ptr [rbp - 0x454]      │; {ls_rbp-1108}
00400b6e:   ba 04 00 00 00          	mov	edx, 4                            │
00400b73:   48 89 ce                	mov	rsi, rcx                          │
00400b76:   89 c7                   	mov	edi, eax                          │
00400b78:   e8 83 fd ff ff          	call	&lt;read@plt&gt;                        │; &lt;read@plt&gt; 400900(.plt+0xa0)
</code></pre>
<p>Now it reads an integer (4 bytes) from the network and stores it again on <code>rbp - 0x448</code>… uhm… let’s see what happens next.</p>
<pre><code class="lang-auto">00400b7d:   8b 85 b8 fb ff ff       	mov	eax, dword ptr [rbp - 0x448]      │; {ls_rbp-1096}
00400b83:   89 c7                   	mov	edi, eax                          │
00400b85:   e8 06 fe ff ff          	call	&lt;ntohl@plt&gt;                       │; &lt;ntohl@plt&gt; 400990(.plt+0x130)
00400b8a:   89 85 c8 fb ff ff       	mov	dword ptr [rbp - 0x438], eax      │; {ls_rbp-1080}
</code></pre>
<p>The value read from the network is converted to host format and stored at <code>rbp - 0x438</code>. At this point we can assume that <code>rbp - 0x448</code> is a kind of temporal variable and therefore not important for us. Let’s keep going.</p>
<pre><code class="lang-auto">00400b90:   8b 85 c4 fb ff ff       	mov	eax, dword ptr [rbp - 0x43c]      │; {ls_rbp-1084}
00400b96:   8b 95 c8 fb ff ff       	mov	edx, dword ptr [rbp - 0x438]      │; {ls_rbp-1080}
00400b9c:   31 d0                   	xor	eax, edx                          │
00400b9e:   89 85 bc fb ff ff       	mov	dword ptr [rbp - 0x444], eax      │; {ls_rbp-1092}
</code></pre>
<p>Aha, a <code>xor</code>. This is interesting. We are xoring the value we have just received from the server <code>rbp - 0x438</code> with the random value we generated (either check the text above or, if you have renamed your local vars you will immediately see that). Let’s keep analysing the code but this looks like a good candidate for our encryption key.</p>
<p><code>rbp - 0x444 -&gt; candidate_key</code></p>
<pre><code class="lang-auto">00400ba4:   48 8d 8d b8 fb ff ff    	lea	rcx, qword ptr [rbp - 0x448]      │; {ls_rbp-1096}
00400bab:   8b 85 ac fb ff ff       	mov	eax, dword ptr [rbp - 0x454]      │; {ls_rbp-1108}
00400bb1:   ba 04 00 00 00          	mov	edx, 4                            │
00400bb6:   48 89 ce                	mov	rsi, rcx                          │
00400bb9:   89 c7                   	mov	edi, eax                          │
00400bbb:   e8 40 fd ff ff          	call	&lt;read@plt&gt;                        │; &lt;read@plt&gt; 400900(.plt+0xa0)
00400bc0:   8b 85 b8 fb ff ff       	mov	eax, dword ptr [rbp - 0x448]      │; {ls_rbp-1096}
00400bc6:   89 c7                   	mov	edi, eax                          │
00400bc8:   e8 c3 fd ff ff          	call	&lt;ntohl@plt&gt;                       │; &lt;ntohl@plt&gt; 400990(.plt+0x130)
00400bcd:   89 85 cc fb ff ff       	mov	dword ptr [rbp - 0x434], eax      │; {ls_rbp-1076}
00400bd3:   8b 85 cc fb ff ff       	mov	eax, dword ptr [rbp - 0x434]      │; {ls_rbp-1076}
00400bd9:   48 98                   	cdqe	                                  │
00400bdb:   48 89 c7                	mov	rdi, rax                          │
00400bde:   e8 5d fd ff ff          	call	&lt;malloc@plt&gt;                      │; &lt;malloc@plt&gt; 400940(.plt+0xe0)
00400be3:   48 89 85 d0 fb ff ff    	mov	qword ptr [rbp - 0x430], rax      │; {ls_rbp-1072}
00400bea:   8b 85 cc fb ff ff       	mov	eax, dword ptr [rbp - 0x434]      │; {ls_rbp-1076}
00400bf0:   89 85 b8 fb ff ff       	mov	dword ptr [rbp - 0x448], eax      │; {ls_rbp-1096}
00400bf6:   eb 49                   	jmp	&lt;l7&gt;                              │; 400c41(.text+0x281)
</code></pre>
<p>This is a big chunk but, by now, it should be very easy to interpret. This is what it does:</p>
<ul>
<li>Reads an integer from the network and stores it in our temporal var (<code>rbp - 0x448</code>)</li>
<li>Converts it to host representation</li>
<li>Allocates a buffer with size equals to the value we have just received from the network!</li>
</ul>
<p>Looking to the assignments at the end we can see that:</p>
<ul>
<li>The pointer returned by <code>malloc</code> is stored at <code>rbp - 0x430</code>
</li>
<li>The size of the buffer is copied at <code>rbp - 0x448</code>
</li>
</ul>
<p>Then we find an unconditional jump (<code>jmp</code>) that usually means we are about to start a loop.</p>
<pre><code class="lang-auto">                                    l8:                                           │
00400bf8:   8b 85 b8 fb ff ff       	mov	eax, dword ptr [rbp - 0x448]      │; {ls_rbp-1096}
00400bfe:   89 c3                   	mov	ebx, eax                          │
00400c00:   8b 85 b8 fb ff ff       	mov	eax, dword ptr [rbp - 0x448]      │; {ls_rbp-1096}
00400c06:   48 63 d0                	movsxd	rdx, eax                          │
00400c09:   8b 85 cc fb ff ff       	mov	eax, dword ptr [rbp - 0x434]      │; {ls_rbp-1076}
00400c0f:   48 63 c8                	movsxd	rcx, eax                          │
00400c12:   8b 85 b8 fb ff ff       	mov	eax, dword ptr [rbp - 0x448]      │; {ls_rbp-1096}
00400c18:   48 98                   	cdqe	                                  │
00400c1a:   48 29 c1                	sub	rcx, rax                          │
00400c1d:   48 8b 85 d0 fb ff ff    	mov	rax, qword ptr [rbp - 0x430]      │; {ls_rbp-1072}
00400c24:   48 01 c1                	add	rcx, rax                          │
00400c27:   8b 85 ac fb ff ff       	mov	eax, dword ptr [rbp - 0x454]      │; {ls_rbp-1108}
00400c2d:   48 89 ce                	mov	rsi, rcx                          │
00400c30:   89 c7                   	mov	edi, eax                          │
00400c32:   e8 c9 fc ff ff          	call	&lt;read@plt&gt;                        │; &lt;read@plt&gt; 400900(.plt+0xa0)
00400c37:   29 c3                   	sub	ebx, eax                          │
00400c39:   89 d8                   	mov	eax, ebx                          │
00400c3b:   89 85 b8 fb ff ff       	mov	dword ptr [rbp - 0x448], eax      │; {ls_rbp-1096}
                                    l7:                                           │
00400c41:   8b 85 b8 fb ff ff       	mov	eax, dword ptr [rbp - 0x448]      │; {ls_rbp-1096}
00400c47:   85 c0                   	test	eax, eax                          │
00400c49:   75 ad                   	jne	&lt;l8&gt;                              │; 400bf8(.text+0x238)
</code></pre>
<p>Sure this is a loop using a loop index <code>rbp - 0x448</code>. That was a copy of the size of the data we are going to receive from the net. Again, I will leave the detailed analysis of this loop as an exercise to the reader. The loop basically reads data from the network and stores it in the allocated buffer until all data has been processed.</p>
<pre><code class="lang-auto">00400c4b:   8b 85 ac fb ff ff       	mov	eax, dword ptr [rbp - 0x454]      │; {ls_rbp-1108}
00400c51:   89 c7                   	mov	edi, eax                          │
00400c53:   e8 98 fc ff ff          	call	&lt;close@plt&gt;                       │; &lt;close@plt&gt; 4008f0(.plt+0x90)
</code></pre>
<p>Then the socket is closed… :o we have actually found a bug LoL.</p>
<p>The rest of the program is jut another loop. Again I will just give you some hints for you to reverse it. By now you should already be an expert on reversing loops :). If any of you experience real difficulties going through this code just post your question in the comments.</p>
<ul>
<li>The loop is XORing the buffer got from the network with the key we calculated and stored at <code>rbp - 0x444</code>
</li>
<li>The key is an integer so the program stores a pointer to the key in <code>rbp- 0x428</code> to go through the int (4 bytes) byte by byte</li>
<li>All that funny <code>shr, and, add, sub</code> code… is the modulus 4 calculation… I think <img src="../../images/emoji/twitter/stuck_out_tongue.png%3Fv=9" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:">
</li>
</ul>
<p>With this info and some googling you should be able to make sense out of the code below.</p>
<pre><code class="lang-auto">00400c58:   48 8b 85 a0 fb ff ff    	mov	rax, qword ptr [rbp - 0x460]      │; {ls_rbp-1120}
00400c5f:   8b 95 cc fb ff ff       	mov	edx, dword ptr [rbp - 0x434]      │; {ls_rbp-1076}
00400c65:   89 10                   	mov	dword ptr [rax], edx              │
00400c67:   48 8d 85 bc fb ff ff    	lea	rax, qword ptr [rbp - 0x444]      │; {ls_rbp-1092}
00400c6e:   48 89 85 d8 fb ff ff    	mov	qword ptr [rbp - 0x428], rax      │; {ls_rbp-1064}
00400c75:   c7 85 c0 fb ff ff 00 00 	mov	dword ptr [rbp - 0x440], 0        │; {ls_rbp-1088}
00400c7f:   eb 56                   	jmp	&lt;l9&gt;                              │; 400cd7(.text+0x317)
                                   l10:                                           │
00400c81:   8b 85 c0 fb ff ff       	mov	eax, dword ptr [rbp - 0x440]      │; {ls_rbp-1088}
00400c87:   48 63 d0                	movsxd	rdx, eax                          │
00400c8a:   48 8b 85 d0 fb ff ff    	mov	rax, qword ptr [rbp - 0x430]      │; {ls_rbp-1072}
00400c91:   48 8d 0c 02             	lea	rcx, qword ptr [rdx + rax]        │
00400c95:   8b 85 c0 fb ff ff       	mov	eax, dword ptr [rbp - 0x440]      │; {ls_rbp-1088}
00400c9b:   48 63 d0                	movsxd	rdx, eax                          │
00400c9e:   48 8b 85 d0 fb ff ff    	mov	rax, qword ptr [rbp - 0x430]      │; {ls_rbp-1072}
00400ca5:   48 01 d0                	add	rax, rdx                          │
00400ca8:   0f b6 30                	movzx	esi, byte ptr [rax]               │
00400cab:   8b 85 c0 fb ff ff       	mov	eax, dword ptr [rbp - 0x440]      │; {ls_rbp-1088}
00400cb1:   99                      	cdq	                                  │
00400cb2:   c1 ea 1e                	shr	edx, 0x1e                         │
00400cb5:   01 d0                   	add	eax, edx                          │
00400cb7:   83 e0 03                	and	eax, 3                            │
00400cba:   29 d0                   	sub	eax, edx                          │
00400cbc:   48 63 d0                	movsxd	rdx, eax                          │
00400cbf:   48 8b 85 d8 fb ff ff    	mov	rax, qword ptr [rbp - 0x428]      │; {ls_rbp-1064}
00400cc6:   48 01 d0                	add	rax, rdx                          │
00400cc9:   0f b6 00                	movzx	eax, byte ptr [rax]               │
00400ccc:   31 f0                   	xor	eax, esi                          │
00400cce:   88 01                   	mov	byte ptr [rcx], al                │
00400cd0:   83 85 c0 fb ff ff 01    	add	dword ptr [rbp - 0x440], 1        │; {ls_rbp-1088}
                                    l9:                                           │
00400cd7:   8b 85 c0 fb ff ff       	mov	eax, dword ptr [rbp - 0x440]      │; {ls_rbp-1088}
00400cdd:   3b 85 cc fb ff ff       	cmp	eax, dword ptr [rbp - 0x434]      │; {ls_rbp-1076}
00400ce3:   7c 9c                   	jl	&lt;l10&gt;                             │; 400c81(.text+0x2c1)
</code></pre>
<p>Finally, the function prepares itself to return the pointer to the <code>malloced</code> buffer (that now contains the decoded data received from the network), check the canary and clean the stack</p>
<pre><code class="lang-auto">00400ce5:   48 8b 85 d0 fb ff ff    	mov	rax, qword ptr [rbp - 0x430]      │; {ls_rbp-1072}
00400cec:   48 8b 5d e8             	mov	rbx, qword ptr [rbp - 0x18]       │; {ls_rbp-24}
00400cf0:   64 48 33 1c 25 28 00 00 	xor	rbx, qword ptr fs:[0x28]          │
00400cf9:   74 05                   	je	&lt;l11&gt;                             │; 400d00(.text+0x340)
00400cfb:   e8 90 fb ff ff          	call	&lt;__stack_chk_fail@plt&gt;            │; &lt;__stack_chk_fail@plt&gt; 400890(.plt+0x30)
                                   l11:                                           │
00400d00:   48 81 c4 58 04 00 00    	add	rsp, 0x458                        │
00400d07:   5b                      	pop	rbx                               │
00400d08:   5d                      	pop	rbp                               │
00400d09:   c3                      	ret	                                  │
</code></pre>
<h1>Getting the Sample</h1>
<p>So, what have we learn about the dropper after analysing it?</p>
<ul>
<li>The data is xor encoded</li>
<li>The encoding key is an integer (4 bytes) calculated as the xor of a random number generated by the dropper and another random number received from the server.</li>
<li>During the communication, we can see the local random number in the request to the server</li>
<li>The server responds with 2 consecutive integers. The first integer is used to generate the key and the second integer is the size of the data that is going to be transferred</li>
<li>The HTTP headers are not used at all and can be safely ignored.</li>
</ul>
<p>With all this information let’s look again to our network dump using wireshark. First the request to the server, that shall contain the random number generated by the dropper</p>
<pre><code>00000000  47 45 54 20 2f 20 48 54  54 50 2f 31 2e 31 0a 55 GET / HT TP/1.1.U
00000010  73 65 72 2d 41 67 65 6e  74 3a 42 6c 61 63 6b 4e ser-Agen t:BlackN
00000020  69 62 62 6c 65 73 20 35  2e 33 32 20 78 4f 53 20 ibbles 5 .32 xOS 
00000030  32 2e 31 0a 0a                                   2.1..
00000035  6b 8b 45 67                                      k.Eg
</code></pre>
<p>So, the number we are interested on is: 0x6b8b4567</p>
<p><em>Note: We can figure out the length of the HTTP header dumping the <code>http_req</code> symbol in the dropper binary, as we have seen previously. In general, HTTP headers finish with two black lines (‘0a 0a’ in the dump).</em></p>
<p>Now let’s look at the server response</p>
<pre><code>00000000  48 54 54 50 2f 31 2e 30  20 32 30 30 20 4f 4b 0a HTTP/1.0  200 OK.
00000010  53 65 72 76 65 72 3a 20  53 68 61 64 6f 77 48 54 Server:  ShadowHT
00000020  54 50 2f 33 2e 32 36 20  5b 53 45 43 55 52 45 44 TP/3.26  [SECURED
00000030  5d 0a 43 6f 6e 74 65 6e  74 2d 74 79 70 65 3a 20 ].Conten t-type: 
00000040  74 65 78 74 2f 68 74 6d  6c 3b 20 63 68 61 72 73 text/htm l; chars
00000050  65 74 3d 55 54 46 2d 38  0a 43 6f 6e 74 65 6e 74 et=UTF-8 .Content
00000060  2d 4c 65 6e 67 74 68 3a  20 2d 31 0a 0a 50 4e 47 -Length:  -1..PNG
00000070  74 29 86 72                                      t).r
00000074  00 20 38 00 6a 86 ee 59  17 c2 a3 1f 15 c3 a2 1f . 8.j..Y ........
 (...)
</code></pre>
<p>The key number is just after the <code>PNG</code> string : <code>0x74298672</code> and the file size is next: <code>0x00203800</code>.</p>
<p>Now we can calculate the key:</p>
<pre><code>0x6b8b4567 ^ 0x74298672 = 0x1fa2c315
</code></pre>
<p>Finally, you need to dump the data and write a small program to decode the data. I have already told you how to dump the data from wireshark into a file and how to skip a header. Now you know that you have to also skip the <code>PNG</code> string and the 2 integers sent by the server. Just check the new offset and dump the thing.</p>
<pre><code>$ dd if=png.dump of=sample bs=1 skip=$((0x78))
</code></pre>
<p>Done, we just need a program to decode the file and we are done. This is my quick and dirty <code>xor</code> decoder in C. You can use any language you want.</p>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int
main (int argc, char *argv[])
{
  unsigned char *p, *k;
  int len;
  int key = atoi (argv[2]);
  int i;
  FILE *f;

  f = fopen (argv[1], "rb");
  fseek (f, 0L, SEEK_END);
  len = ftell (f);
  fseek (f, 0L, SEEK_SET);
  printf ("File size is: %d\n", len);
  printf ("key %x\n", key);
  p = malloc (len);
  fread (p, 1, len, f);
  fclose (f);
  k = &amp;key;
  for (i = 0; i &lt; len; i++) p[i] ^= k[i % 4];
  f = fopen (argv[1], "wb");
  fwrite (p, 1, len, f);
  fclose (f);

</code></pre>
<p>And, after all this, we can finally recover our sample!</p>
<pre><code>$ cp sample sample.1
$  ./xor1 sample.1 530760469
File size is: 2111488
key 1fa2c315
$  file sample.1
sample.1: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.24, BuildID[sha1]=0x0ec065afe8fd78ff18381dc09b0be805364c3c95, not stripped
</code></pre>
<h1>Next</h1>
<p>Believe it or no, you have got the first flag… just run <code>strings sample.1| grep CTF</code> <img src="../../images/emoji/twitter/slight_smile.png%3Fv=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<p>Awesome… you have successfully analysed a malware dropper. Now, you have to start again and analyse the actual malware sample. I hope it would be a lot easier now that you can make good use of all the experience you have gained analysing the dropper. Actually you will find a lot of familiar code in the sample what should make your analysis faster and easier. Anyhow, I’ll wait a couple of weeks for you to get the flags and before release Part II… Maybe some of you would write Part II for me <img src="../../images/emoji/twitter/wink.png%3Fv=9" title=":wink:" class="emoji" alt=":wink:"></p>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/LikeAction" />
<meta itemprop="userInteractionCount" content="6" />
<span class="post-likes">6 Likes</span>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/CommentAction" />
<meta itemprop="userInteractionCount" content="0" />
</div>
<div class="crawler-linkback-list" itemscope itemtype="http://schema.org/ItemList">
<div itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
<a itemprop="url" href="../malware-analysis-case-gbc-17-124-the-malware-part-iii/3543.html">[Malware Analysis] Case GBC-17_124: The malware Part III</a>
<meta itemprop="position" content="2">
</div>
</div>
</div>
</div>
</div>
<footer class="container wrap">
<nav class="crawler-nav">
<ul>
<li itemscope itemtype="http://schema.org/SiteNavigationElement">
<span itemprop="name">
<a href="../../index.html" itemprop="url">Home </a>
</span>
</li>
<li itemscope itemtype="http://schema.org/SiteNavigationElement">
<span itemprop="name">
<a href="../../categories.html" itemprop="url">Categories </a>
</span>
</li>
<li itemscope itemtype="http://schema.org/SiteNavigationElement">
<span itemprop="name">
<a href="https://0x00sec.org/guidelines" itemprop="url">FAQ/Guidelines </a>
</span>
</li>
<li itemscope itemtype="http://schema.org/SiteNavigationElement">
<span itemprop="name">
<a href="../../tos.html" itemprop="url">Terms of Service </a>
</span>
</li>
<li itemscope itemtype="http://schema.org/SiteNavigationElement">
<span itemprop="name">
<a href="../../privacy.html" itemprop="url">Privacy Policy </a>
</span>
</li>
</ul>
</nav>
<p class="powered-by-link">Powered by <a href="https://www.discourse.org">Discourse</a>, best viewed with JavaScript enabled</p>
</footer>
<script src="https://instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>
</body>
</html>
