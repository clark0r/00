<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Programming for Wanabes VIII. File Details</title>
    <link>https://0x00sec.org/t/programming-for-wanabes-viii-file-details/25738</link>
    <description>We have learnt how to scan directories and list their content, now we need to figure out how to get the details of the directory contents so we can chose the files we are interested on. This is actually very simple and requires one single system call.

# The `stat` system call

The `stat` system call, allow us to get all the details of a specific fie. The prototype of this syscall is :

```C
int stat(const char *pathname, struct stat *statbuf);
```

And the `struct stat` (now we know what a struct is don&#39;t we?), contains the following information:

```C
struct stat {
       dev_t     st_dev;         /* ID of device containing file */
       ino_t     st_ino;         /* Inode number */
       mode_t    st_mode;        /* File type and mode */
       nlink_t   st_nlink;       /* Number of hard links */
       uid_t     st_uid;         /* User ID of owner */
       gid_t     st_gid;         /* Group ID of owner */
       dev_t     st_rdev;        /* Device ID (if special file) */
       off_t     st_size;        /* Total size, in bytes */
       blksize_t st_blksize;     /* Block size for filesystem I/O */
       blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */

       /* Since Linux 2.6, the kernel supports nanosecond
          precision for the following timestamp fields.
          For the details before Linux 2.6, see NOTES. */

        struct timespec st_atim;  /* Time of last access */
        struct timespec st_mtim;  /* Time of last modification */
        struct timespec st_ctim;  /* Time of last status change */
};
```

The most interesting field for us is `st_mode`, but there is a lot of other useful information that we will be using in the future. The structure is describe in the `stat` man page for your future references.

# Understanding the `st_mode` field

The `st_mode` field encodes the type of file and also the permissions. The man page includes some sample code showing us how to access that information. So, the way to access the type of file is using the bit mask `S_IFMT`:

```C
struct st sb;
stat (a_file_name, &amp;sb);
int type = sb.st_mode &amp; S_IFMT
```

The `&amp;` operator is a bitwise AND.... It basically matches two binary numbers and only the bits that are the same remains. Let&#39;s see what is in `S_IFMT`. I can tell you directly, but I believe it is going to be good for you to learn how to get this information by yourself, so you can find whatever you want  in the future.

We will start looking in the header files indicated by the man page. At the top of the man page you will see the `includes` you need to add to your program to use the system call. 


    NAME
           stat, fstat, lstat, fstatat - get file status
    
    SYNOPSIS
           #include &lt;sys/types.h&gt;
           #include &lt;sys/stat.h&gt;
           #include &lt;unistd.h&gt;


The `sys/types.h` sounds pretty generic so I will skip it (you can actually look into it, but you won&#39;t find anything). So let&#39;s look into `sys/stat.h` that sounds more like the specifics for `stat`.

    $ grep &quot;IFMT&quot; /usr/include/sys/stat.h
    # define S_IFMT         __S_IFMT
    #define __S_ISTYPE(mode, mask)  (((mode) &amp; __S_IFMT) == (mask))

Well, looks like the actual value is defined somewhere else, but we can see also a macro to quickly check against the different types. We can use it like:

```C
__S_ISTYPE(sb.st_mode,S_IFREG)
// is equivalent to
(((sb.st_mode) &amp; __S_IFMT) == (S_IFREG)
```

That second define is called a macro. They work the same than the normal defines (they are just substituted by its value in the code before compiling) but we can use parameters to write more complex expressions. When we use parameters, the `define` is said to define a macro instead of a constant.

So, in order to find out the actual value of `S_IFMT`, we need to look into the includes, included by the include :). 

    $ grep &quot;#include&quot; /usr/include/sys/stat.h
    #include &lt;features.h&gt;
    #include &lt;bits/types.h&gt;         /* For __mode_t and __dev_t.  */
    #include &lt;bits/stat.h&gt;

_NOTE:I&#39;m using grep to show this information. It is, in general, very handy to do it this way, but I would recommend, at the beginning, to find these information manually, that is, opening the file in an editor and browse through it. The reason is that you will see how this system include files look like and get familiar with them. You will also find curious thing that will spark your curiosity._

Again, we can go through all of them systematically, but `bits/stat.h` looks like the best candidate.

    $ grep &quot;IFMT&quot; /usr/include/bits/stat.h
    #define __S_IFMT        0170000 /* These bits determine file type.  */

We found it!. Actually if we open the file, we will also find, all the other relevant constants. These are the ones:

```C
#define __S_IFMT        0170000 /* These bits determine file type.  */

/* File types.  */
#define __S_IFDIR       0040000 /* Directory.  */
#define __S_IFCHR       0020000 /* Character device.  */
#define __S_IFBLK       0060000 /* Block device.  */
#define __S_IFREG       0100000 /* Regular file.  */
#define __S_IFIFO       0010000 /* FIFO.  */
#define __S_IFLNK       0120000 /* Symbolic link.  */
#define __S_IFSOCK      0140000 /* Socket.  */

/* Protection bits.  */

#define __S_ISUID       04000   /* Set user ID on execution.  */
#define __S_ISGID       02000   /* Set group ID on execution.  */
#define __S_ISVTX       01000   /* Save swapped text after use (sticky).  */
#define __S_IREAD       0400    /* Read by owner.  */
#define __S_IWRITE      0200    /* Write by owner.  */
#define __S_IEXEC       0100    /* Execute by owner.  */
```

But. Wait a minute!. Those numbers look a bit weird isn&#39;t it?

# Base 8, octal numbers
So far we have been using decimal numbers (using base 10) and also hexadecimal numbers (using base 16). OK, true, and binaries (using base 2). However there is another base that is useful when working with computers. This is base 8 and the numbers represented in this base are said to be in octal format.

In C, you can write octal numbers just adding a `0` at the beginning of the number, the same way that we add a `0x` to represent an hexadecimal value. Octal representation is useful when we need to manipulate blocks of 3 bits (0 to 7.... that&#39;s eight values, hence octal). So, let&#39;s try to understand the values of the constants used by `stat`.

To understand how this matches to the hexadecimal representation, let&#39;s just count using both bases:

    HEX   OCT  BIN
    0     0    0000 0000
    1     1    0000 0001  &lt;--
    2     2    0000 0010  &lt;--
    3     3    0000 0011 
    4     4    0000 0100  &lt;--
    5     5    0000 0101
    6     6    0000 0110
    7     7    0000 0111
    8    10    0000 1000
    9    11    0000 1001  &lt;--
    A    12    0000 1010  &lt;--
    B    13    0000 1011
    C    14    0000 1100 &lt;--
    D    15    0000 1101
    F    16    0000 1110
    10   17    0000 1111
    11   21    0001 0000

As you can see, when using the octal representation, the first digit of our number is actually the value of the lower 3 bits of the number. Each position in the number, represents the next 3 bytes, so the octal representation is very useful when we need to work with blocks of 3 bits, instead of 4 (we use hexadecimal in those cases).

For instance, check this out. Hopefully it will look familiar to you:

    chmod 777 afile
          000 111 111 111 -&gt; 0777
          0001 1111 1111  -&gt; 0x1ff

Both number `0x1ff` and `0777` are the same number (511 in decimal), but the octal representation allows us to write the digits as groups of three bits. In this case, each bit represent the execution, read and write permissions for the file. Imagine to use `chmod` with the decimal or hexadecimal numbers... It would be very tricky to change permissions of a file like that.

Anyhow and summing up, octal representation is used here and there whenever it is convenient to access the bits in a number in groups of three and not four. And one of these cases is the file permissions.

# Back to the `st_mode` constants
Now, we can look again to the `st_mode` constants:

```C
#define __S_IFMT        0170000 /* These bits determine file type.  */

/* File types.  */
#define __S_IFDIR       0040000 /* Directory.  */
#define __S_IFCHR       0020000 /* Character device.  */
#define __S_IFBLK       0060000 /* Block device.  */
#define __S_IFREG       0100000 /* Regular file.  */
#define __S_IFIFO       0010000 /* FIFO.  */
#define __S_IFLNK       0120000 /* Symbolic link.  */
#define __S_IFSOCK      0140000 /* Socket.  */

/* Protection bits.  */

#define __S_ISUID       04000   /* Set user ID on execution.  */
#define __S_ISGID       02000   /* Set group ID on execution.  */
#define __S_ISVTX       01000   /* Save swapped text after use (sticky).  */
#define __S_IREAD       0400    /* Read by owner.  */
#define __S_IWRITE      0200    /* Write by owner.  */
#define __S_IEXEC       0100    /* Execute by owner.  */
```

Let&#39;s first figure out the structure of this field. Representing the different octal values as bit masks. You can check the table in the previous section to verify the values, but we just use blocks of 3 bits....

    001 111 000 000 000 000  -&gt; __S_IFMT   (0170000)
	000 100 000 000 000 000  -&gt; __S_IFDIR  (0040000)
	000 010 000 000 000 000  -&gt; __S_IFCHR  (0020000)
	000 110 000 000 000 000  -&gt; __S_IFBLK  (0060000)
	001 000 000 000 000 000  -&gt; __S_IFREG  (0100000)
	000 001 000 000 000 000  -&gt; __S_IFIFO  (0010000)
	001 010 000 000 000 000  -&gt; __S_IFLNK  (0120000)
	001 100 000 000 000 000  -&gt; __S_IFSOCK (0140000)
      ^ ^^^	
    000 000 100 000 000 000  -&gt; __S_ISUID  (0004000)
	000 000 010 000 000 000  -&gt; __S_ISGID  (0002000)
	000 000 001 000 000 000  -&gt; __S_ISVTX  (0001000)
            ^^^	
	000 000 000 100 000 000  -&gt; __S_IREAD  (0000400)
	000 000 000 010 000 000  -&gt; __S_IWRITE (0000200)
	000 000 000 001 000 000  -&gt; __S_IEXEC  (0000100)
	            ^^^

As we can see the `__S_IFMT` is a mask to extract the high bits from the field that identify the type of file. Also note how the constant for the types of files have been defined as high numbers so we can compare directly just after ANDing the mask.

After the type of file, we find the special file attributes that indicates if the file is _SetUID_ or _SetGUID_ and also if the sticky bit is activate. And after that follows the file permissions for the owner, the group and the rest of users.

Yes, you are right, `bits/stat.h` only defines the mask for the owner. Actually, the constant defined above shouldn&#39;t be used by normal programs, we should use the ones redefined in `sys/stat.h`. I will include them here for you to check them out:

```C
/* Protection bits.  */

#define S_ISUID __S_ISUID       /* Set user ID on execution.  */
#define S_ISGID __S_ISGID       /* Set group ID on execution.  */

#define S_IRUSR __S_IREAD       /* Read by owner.  */
#define S_IWUSR __S_IWRITE      /* Write by owner.  */
#define S_IXUSR __S_IEXEC       /* Execute by owner.  */
/* Read, write, and execute by owner.  */
#define S_IRWXU (__S_IREAD|__S_IWRITE|__S_IEXEC)

#define S_IRGRP (S_IRUSR &gt;&gt; 3)  /* Read by group.  */
#define S_IWGRP (S_IWUSR &gt;&gt; 3)  /* Write by group.  */
#define S_IXGRP (S_IXUSR &gt;&gt; 3)  /* Execute by group.  */
/* Read, write, and execute by group.  */
#define S_IRWXG (S_IRWXU &gt;&gt; 3)

#define S_IROTH (S_IRGRP &gt;&gt; 3)  /* Read by others.  */
#define S_IWOTH (S_IWGRP &gt;&gt; 3)  /* Write by others.  */
#define S_IXOTH (S_IXGRP &gt;&gt; 3)  /* Execute by others.  */
/* Read, write, and execute by others.  */
#define S_IRWXO (S_IRWXG &gt;&gt; 3)
```

I had removed a couple of lines to make easier reading the file. Here you can see how all constants are redefined, and the group and other permissions are just redefined as shifted versions of the original user masks we have just seen.

&gt; NOTE: The `&gt;&gt;` operator shifts all the bits of the left hand operand to the right as many positions as the right hand operand indicates. `S_IRUSR &gt;&gt; 3` will shift `S_IRUSR` value 3 positions to the right. In this case: `S_IRUSR = __S_IREAD = 0000400` shifting this three positions to the right will produce `040` (remember octal digits works on groups of 3 bits).

Well, this has been a kindof a digression, but this concepts are usually confusing for the beginners and I though it would be great to add some explanation in the course,

# Back to our `select_target`

So, know we can modify our `select_target` to find the kind of files we are interested on. This is how the new function will look like:

```C
int select_target (PAYLOAD_FUNC pf) {
  char                buf[BUF_SIZE];
  struct linux_dirent *de;
  struct stat         st;
  int                 fd, n, i;
  
  if ((fd = open (folder, O_RDONLY | O_DIRECTORY)) &lt; 0) MFW_EXIT(&quot;open:&quot;);

  while (1) {
    n = getdents (fd, buf, BUF_SIZE);
    if (n &lt; 0) MFW_EXIT (&quot;getdents:&quot;);
    if (n == 0) break;

    for (i = 0; i &lt; n;) {
      de = (struct linux_dirent *)(buf + i);
	  
      if ((fstatat (fs, de-&gt;d_name, &amp;st)) &lt; 0) {
		  perror (&quot;stat:&quot;);
		  continue; // Just ignore the error
      }
      if (((st.st_mode &amp; S_IFMT) == S_IFREG)
		  &amp;&amp; (st.st_mode &amp; 00111))
		  pf (target);
      
      i += de-&gt;d_reclen;

    }
  }
 done:
  close (fd);
  return 0;
}
```

Two comments on this code:

1. We have used `fstatat` instead of `fstat` or `stat`, so we do not have to build the full path to the file before calling `stat`. This syscall uses the directory file descriptor as base and tried to look for the file **AT** the directory that we pass as first parameter. In this case it is very convenient and we avoid allocating memory for strings and concatenating them.
2. This is the `select_target` for a virus. We are checking that the directory entry is a regular file (`S_IFREG`) and then we check that it is executable. In this case we are just checking for all possible executable permissions but that may be different in a real case.

The permission checking could also be written like:

```C
st.st_mode &amp; 00111; // Is the same than
st.st_mode &amp; (S_IXUSR|S_IXGRP|S_IXOTH)
```

Second one is better as you can easily see what we are comparing to... and the generated code would be the same... But first one is shorter and I chose that.

Now, you can try to change the program to look for other kind of files as it my happen in the case of ransomware or spyware. But you need a last piece of knowledge in order to be able to complete the implementation of `select_target`.

# Recursive functions
The problem with our current `select_target` is that, it can only scan a single directory. In general, we should be able to scan the whole disk, that means that, we need to modify the function so, each time we find a directory, we also scan it. Or in other words, each time we find a directory we need to call ourselves again with the new directory name to scan.

A function that call itself is known as a recursive function. Recursive functions are very powerful and usually allows us to write very small and elegant code to deal with complex problems. A classical example is traversing a tree. It is way easier to do it with a recursive function that with normal iterative code.

In general, recursive function trades code complexity with memory usage. That is normal, we always trade either speed, memory or complexity. That&#39;s life. A recursive function will make extensive use of the stack creating stack frames again and again each time it calls itself. But other than that they are neat solutions to many problems, and usually requires way less code that an iterative solution.


# A recursive `select_target`
So, it&#39;s time to modify our program to be able to scan the whole disk. For that we will need to modify the function signature, so we get the current folder being scanned in the stack frame of our function and we can continue our work at the right place after processing every subfolder.

We will also add some messages and some indention to the function, for easily check that your function is working fine:


```C

int level = 0;
char tabs[1024];

int payload (char *target) {
  printf (&quot;%s Doing malware things to %s\n&quot;, tabs, target);
}

int select_target (int old_fd, char *folder, PAYLOAD_FUNC pf) {
  char                buf[BUF_SIZE];
  int                 flag = 1;
  struct linux_dirent *de;
  struct stat         st;
  int                 fd, n, i;
  
  // Scan directory

  // Open directory using open
  printf (&quot;%s Processing : %s\n&quot;, tabs, folder); 
  if ((fd = openat (old_fd, folder, O_RDONLY | O_DIRECTORY)) &lt; 0) MFW_EXIT(&quot;open:&quot;);
  // Update indentation string
  tabs[level] = &#39; &#39;;
  level ++;
  
  while (flag) {
    n = getdents (fd, buf, BUF_SIZE);
    if (n &lt; 0) MFW_EXIT (&quot;getdents:&quot;);
    if (n == 0) break;

    // Build file name
    for (i = 0; i &lt; n;) {
      de = (struct linux_dirent *)(buf + i);
      if ((fstatat (fd, de-&gt;d_name, &amp;st, 0)) &lt; 0) {
	    perror (&quot;stat:&quot;);
	    continue; // Just ignore the error&lt;- This is a bug can you fix it?
      }
      if (((st.st_mode &amp; S_IFMT) == S_IFREG)
	        &amp;&amp; (st.st_mode &amp; 00111))
	           pf (de-&gt;d_name);
      else if (((st.st_mode &amp; S_IFMT) == S_IFDIR)
	             &amp;&amp; !(de-&gt;d_name[0] == &#39;.&#39;
		              &amp;&amp; (de-&gt;d_name[1] == 0
		                  || (de-&gt;d_name[1] == &#39;.&#39; &amp;&amp; de-&gt;d_name[2]==0))))
	                          select_target (fd, de-&gt;d_name, pf);
	 
      i += de-&gt;d_reclen;
    }
  }
  // Remove indentation
  tabs[level] = 0;
  level--;
  close (fd);
  return 0;
}
```

Despite the indentation thingy (we just add a space to a string every time we enter the function and remove it every time we left), there are two main changes:

```C
  if ((fd = openat (old_fd, folder, O_RDONLY | O_DIRECTORY)) &lt; 0) MFW_EXIT(&quot;open:&quot;);
```

We have changed `open` for `openat`. This works the same than `statat`, we just pass as first parameter a file descriptor and, if the second parameter (the `pathname`) is relative it will open the file from the indicated directory, otherwise, if the path is absolute, will behave like a normal open.

This is convenient so we do not need to build the full file name ourselves. That is not a big deal (`strcpy`+ `strcat`), but this way we do not have to.

The second change is the recursive call. Basically, we just need to check if the directory entry is a directory. If that is the case we call ourselves again with the sub-directory name. However, remember the `.` and `..` entries we mentioned in last instalment?.... Sure, you do... well, we need to skip those, otherwise we get into an infinite loop.... This is the rest of the check.

```C
if (((st.st_mode &amp; S_IFMT) == S_IFDIR)
	             &amp;&amp; !(de-&gt;d_name[0] == &#39;.&#39;
		              &amp;&amp; (de-&gt;d_name[1] == 0
		                  || (de-&gt;d_name[1] == &#39;.&#39; &amp;&amp; de-&gt;d_name[2]==0))))
	                          select_target (fd, de-&gt;d_name, pf);
```

So, our `select_target` for malwares that need to look for files is ready. 

# Removing libC

So, we have been learning a lot about C programming, and we haven&#39;t talked much about asm. We will be looking to assembler in the coming instalments, but before starting with that we are going to remove the libc dependencies from our current test program, so we can have full control on the assembler version we are going to generate.

So far, we are using the following system calls:

    exit
    write
    openat
    close
    getdents
    fstatat

So, our first task will be to generate a mini libc version for our program. This is easier than expected:

```asm
	.global mfw_exit
	.global mfw_write
	.global mfw_close
	.global mfw_openat
	.global mfw_newfstatat
	.global mfw_getdents
	
mfw_write:
	mov $0x01, %eax
	syscall
	ret
	
mfw_openat:
	mov $0x101, %eax
	syscall
	ret
	
mfw_close:
	mov $0x03, %eax
	syscall
	ret

mfw_exit:
	mov $0x3c, %eax
	syscall
	ret

mfw_newfstatat:
	mov %rcx, %r10
	mov %0x106, %eax
	syscall
	ret

mfw_getdents:
	mov $78, %eax
	syscall
	ret

mfw_open:
	mov $0x02, %eax
	syscall
	ret

mfw_lstat:
	mov $0x06, %eax
	syscall
	ret

```

Have you noticed something strange?. The implementation of all syscalls is pretty straightforward, except for the `fstatat`. This syscall has a peculiarity. The C ABI and the kernel ABI are different for the forth parameter. C function get that parameter on `RCX` as we already know, but the kernel syscalls expect them on `R10`. I forgot about that and expend quite sometime figuring out why the syscall was failing.

# The final version
So, this is how the final version will look like:

```C
#include &lt;fcntl.h&gt;
#include &lt;sys/types.h&gt;  
#include &lt;sys/stat.h&gt;   // Stat struct

#define BUF_SIZE 1024

// XXX: Move this to a .h file
// Dirent Data struct
struct linux_dirent {
  long           d_ino;
  long           d_off;
  unsigned short d_reclen;
  char           d_name[];
};

int     mfw_getdents (int fd, char *buf, int len);
int     mfw_exit (int r);
int     mfw_openat(int dirfd, const char *pathname, int flags);
int     mfw_newfstatat (int dirfd, char *p, struct stat *st, int flags);
int     mfw_close (int fd);
size_t  mfw_write(int fd, const void *buf, size_t count);

#define MFW_EXIT(s) do {mfw_exit (1);} while (0)

typedef int (*PAYLOAD_FUNC)(char *);

// Global vars
int level = 0;
char tabs[1024];

int mfw_puts (char *s) {
  while (*s) mfw_write (1, s++, 1);
}

// Helper function to write tabbed strings 
int mfw_print_tstr (char *s, char *v) {
  mfw_puts (tabs);
  mfw_puts (s);
  if (v) mfw_puts (v);
  mfw_puts (&quot;\n&quot;);
}

int payload (char *target) {
  mfw_print_tstr (&quot;   ++ Doing malware things to &quot;, target);
}

int select_target (int old_fd, char *folder, PAYLOAD_FUNC pf) {
  char                buf[BUF_SIZE];
  struct linux_dirent *de;
  struct stat         st;
  int                 fd, n, i;

  tabs[level] = &#39; &#39;;
  level ++;

  mfw_print_tstr (&quot;&gt;&gt; Entering &quot;, folder);

  if ((fd = mfw_openat (old_fd, folder, O_RDONLY | O_DIRECTORY)) &lt; 0) goto clean;
  
  while (1) {
    n = mfw_getdents (fd, buf, BUF_SIZE);
    if (n &lt; 0) continue; // Silently ignore errors
    if (n == 0) break;

    for (i = 0; i &lt; n;) {
      de = (struct linux_dirent *)(buf + i);
      if ((mfw_newfstatat (fd, de-&gt;d_name, &amp;st, 0)) &lt; 0) goto next;
      
      if (((st.st_mode &amp; S_IFMT) == S_IFREG) &amp;&amp; (st.st_mode &amp; 00111))
	    pf (de-&gt;d_name);
      else if (((st.st_mode &amp; S_IFMT) == S_IFDIR)
	       &amp;&amp; !(de-&gt;d_name[0] == &#39;.&#39;
		     &amp;&amp; (de-&gt;d_name[1] == 0
		         || (de-&gt;d_name[1] == &#39;.&#39; &amp;&amp; de-&gt;d_name[2]==0))))
	    select_target (fd, de-&gt;d_name, pf);
    next:
      i += de-&gt;d_reclen;
    }
  }
 clean:
  mfw_print_tstr (&quot;&lt;&lt; Leaving &quot;, folder);
  tabs[level] = 0;
  level--;
  mfw_close (fd);
  return 0;
}

int main (int argc, char *argv[]) {
  for (int i = 0; i &lt; 1024; tabs[i++] = 0);
  while (select_target(0, argv[1], payload));
}

```

As I did last time. This version has a few updates that I haven&#39;t described in the text. Try to understand what they are for and do not hesitate to ask your questions in case you cannot figure it out by yourself.

I named the asm code in previous section `minilibc.S`. So, in order to compile my program I have to do:

    gcc -o select_files select_file.c minilibc.S

# Conclusion
We have now working code to scan a disk and test some basic file information as the type of file and the permissions. We have also learned how to navigate the system include files to find out the information we need and also how to master the octal numeric representation.

We have removed the libC dependencies and we are ready for a asm implementation. We will find out if that asm implementation worth the extra effort, and after that we will be ready to get started with some simple payload....

## Read the whole series here

[Part VII. Finding files](https://0x00sec.org/t/programming-for-wanabes-vii-finding-files-i/25662)
[Part VI. Malware Introduction](https://0x00sec.org/t/programming-for-wannabes-part-vi-malware-introduction/25595)
[Part V. A dropper](https://0x00sec.org/t/programming-for-wannabes-part-v-a-dropper/23090)
[Part IV. The stack](https://0x00sec.org/t/programming-for-wannabes-part-iv/22421)
[Part III. Your first Shell Code](https://0x00sec.org/t/programming-for-wannabees-part-iii-your-first-shell-code/1279)
[Part II and a Half. Part II for ARM and MIPS](https://0x00sec.org/t/programming-for-wannabes-part-ii-and-a-half/1196)
[Part II. Shrinking your program](https://0x00sec.org/t/programming-for-wannabes-part-ii/1164)
[Part I. Getting Started](https://0x00sec.org/t/programming-for-wannabes-part-i/1143)</description>
    
    <lastBuildDate>Wed, 21 Apr 2021 14:31:14 +0000</lastBuildDate>
    <category>Programming</category>
    <atom:link href="https://0x00sec.org/t/programming-for-wanabes-viii-file-details/25738.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Programming for Wanabes VIII. File Details</title>
        <dc:creator><![CDATA[system]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 121 days. New replies are no longer allowed.</p>
          <p><a href="https://0x00sec.org/t/programming-for-wanabes-viii-file-details/25738/5">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/programming-for-wanabes-viii-file-details/25738/5</link>
        <pubDate>Fri, 20 Aug 2021 13:18:32 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-25738-5</guid>
        <source url="https://0x00sec.org/t/programming-for-wanabes-viii-file-details/25738.rss">Programming for Wanabes VIII. File Details</source>
      </item>
      <item>
        <title>Programming for Wanabes VIII. File Details</title>
        <dc:creator><![CDATA[crimsonRain]]></dc:creator>
        <description><![CDATA[
            <p>Good stuff as usual!</p>
          <p><a href="https://0x00sec.org/t/programming-for-wanabes-viii-file-details/25738/4">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/programming-for-wanabes-viii-file-details/25738/4</link>
        <pubDate>Wed, 21 Apr 2021 14:31:14 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-25738-4</guid>
        <source url="https://0x00sec.org/t/programming-for-wanabes-viii-file-details/25738.rss">Programming for Wanabes VIII. File Details</source>
      </item>
      <item>
        <title>Programming for Wanabes VIII. File Details</title>
        <dc:creator><![CDATA[messede]]></dc:creator>
        <description><![CDATA[
            <p>Thank you , for putting your time and effort into this series , i have learnt a lot from your work  <img src="https://0x00sec.org/images/emoji/twitter/+1.png?v=9" title=":+1:" class="emoji" alt=":+1:"> <img src="https://0x00sec.org/images/emoji/twitter/+1.png?v=9" title=":+1:" class="emoji" alt=":+1:"> <img src="https://0x00sec.org/images/emoji/twitter/+1.png?v=9" title=":+1:" class="emoji" alt=":+1:"> .</p>
          <p><a href="https://0x00sec.org/t/programming-for-wanabes-viii-file-details/25738/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/programming-for-wanabes-viii-file-details/25738/3</link>
        <pubDate>Wed, 21 Apr 2021 13:59:54 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-25738-3</guid>
        <source url="https://0x00sec.org/t/programming-for-wanabes-viii-file-details/25738.rss">Programming for Wanabes VIII. File Details</source>
      </item>
      <item>
        <title>Programming for Wanabes VIII. File Details</title>
        <dc:creator><![CDATA[ricksanchez]]></dc:creator>
        <description><![CDATA[
            <p>You’re killing it again <a class="mention" href="https://0x00sec.org/u/0x00pf">@0x00pf</a>! Loving that you’re continuing this series after all!</p>
          <p><a href="https://0x00sec.org/t/programming-for-wanabes-viii-file-details/25738/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/programming-for-wanabes-viii-file-details/25738/2</link>
        <pubDate>Wed, 21 Apr 2021 06:06:36 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-25738-2</guid>
        <source url="https://0x00sec.org/t/programming-for-wanabes-viii-file-details/25738.rss">Programming for Wanabes VIII. File Details</source>
      </item>
      <item>
        <title>Programming for Wanabes VIII. File Details</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>We have learnt how to scan directories and list their content, now we need to figure out how to get the details of the directory contents so we can chose the files we are interested on. This is actually very simple and requires one single system call.</p>
<h1>The <code>stat</code> system call</h1>
<p>The <code>stat</code> system call, allow us to get all the details of a specific fie. The prototype of this syscall is :</p>
<pre><code class="lang-auto">int stat(const char *pathname, struct stat *statbuf);
</code></pre>
<p>And the <code>struct stat</code> (now we know what a struct is don’t we?), contains the following information:</p>
<pre><code class="lang-auto">struct stat {
       dev_t     st_dev;         /* ID of device containing file */
       ino_t     st_ino;         /* Inode number */
       mode_t    st_mode;        /* File type and mode */
       nlink_t   st_nlink;       /* Number of hard links */
       uid_t     st_uid;         /* User ID of owner */
       gid_t     st_gid;         /* Group ID of owner */
       dev_t     st_rdev;        /* Device ID (if special file) */
       off_t     st_size;        /* Total size, in bytes */
       blksize_t st_blksize;     /* Block size for filesystem I/O */
       blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */

       /* Since Linux 2.6, the kernel supports nanosecond
          precision for the following timestamp fields.
          For the details before Linux 2.6, see NOTES. */

        struct timespec st_atim;  /* Time of last access */
        struct timespec st_mtim;  /* Time of last modification */
        struct timespec st_ctim;  /* Time of last status change */
};
</code></pre>
<p>The most interesting field for us is <code>st_mode</code>, but there is a lot of other useful information that we will be using in the future. The structure is describe in the <code>stat</code> man page for your future references.</p>
<h1>Understanding the <code>st_mode</code> field</h1>
<p>The <code>st_mode</code> field encodes the type of file and also the permissions. The man page includes some sample code showing us how to access that information. So, the way to access the type of file is using the bit mask <code>S_IFMT</code>:</p>
<pre><code class="lang-auto">struct st sb;
stat (a_file_name, &amp;sb);
int type = sb.st_mode &amp; S_IFMT
</code></pre>
<p>The <code>&amp;</code> operator is a bitwise AND… It basically matches two binary numbers and only the bits that are the same remains. Let’s see what is in <code>S_IFMT</code>. I can tell you directly, but I believe it is going to be good for you to learn how to get this information by yourself, so you can find whatever you want  in the future.</p>
<p>We will start looking in the header files indicated by the man page. At the top of the man page you will see the <code>includes</code> you need to add to your program to use the system call.</p>
<pre><code>NAME
       stat, fstat, lstat, fstatat - get file status

SYNOPSIS
       #include &lt;sys/types.h&gt;
       #include &lt;sys/stat.h&gt;
       #include &lt;unistd.h&gt;
</code></pre>
<p>The <code>sys/types.h</code> sounds pretty generic so I will skip it (you can actually look into it, but you won’t find anything). So let’s look into <code>sys/stat.h</code> that sounds more like the specifics for <code>stat</code>.</p>
<pre><code>$ grep "IFMT" /usr/include/sys/stat.h
# define S_IFMT         __S_IFMT
#define __S_ISTYPE(mode, mask)  (((mode) &amp; __S_IFMT) == (mask))
</code></pre>
<p>Well, looks like the actual value is defined somewhere else, but we can see also a macro to quickly check against the different types. We can use it like:</p>
<pre><code class="lang-auto">__S_ISTYPE(sb.st_mode,S_IFREG)
// is equivalent to
(((sb.st_mode) &amp; __S_IFMT) == (S_IFREG)
</code></pre>
<p>That second define is called a macro. They work the same than the normal defines (they are just substituted by its value in the code before compiling) but we can use parameters to write more complex expressions. When we use parameters, the <code>define</code> is said to define a macro instead of a constant.</p>
<p>So, in order to find out the actual value of <code>S_IFMT</code>, we need to look into the includes, included by the include :).</p>
<pre><code>$ grep "#include" /usr/include/sys/stat.h
#include &lt;features.h&gt;
#include &lt;bits/types.h&gt;         /* For __mode_t and __dev_t.  */
#include &lt;bits/stat.h&gt;
</code></pre>
<p><em>NOTE:I’m using grep to show this information. It is, in general, very handy to do it this way, but I would recommend, at the beginning, to find these information manually, that is, opening the file in an editor and browse through it. The reason is that you will see how this system include files look like and get familiar with them. You will also find curious thing that will spark your curiosity.</em></p>
<p>Again, we can go through all of them systematically, but <code>bits/stat.h</code> looks like the best candidate.</p>
<pre><code>$ grep "IFMT" /usr/include/bits/stat.h
#define __S_IFMT        0170000 /* These bits determine file type.  */
</code></pre>
<p>We found it!. Actually if we open the file, we will also find, all the other relevant constants. These are the ones:</p>
<pre><code class="lang-auto">#define __S_IFMT        0170000 /* These bits determine file type.  */

/* File types.  */
#define __S_IFDIR       0040000 /* Directory.  */
#define __S_IFCHR       0020000 /* Character device.  */
#define __S_IFBLK       0060000 /* Block device.  */
#define __S_IFREG       0100000 /* Regular file.  */
#define __S_IFIFO       0010000 /* FIFO.  */
#define __S_IFLNK       0120000 /* Symbolic link.  */
#define __S_IFSOCK      0140000 /* Socket.  */

/* Protection bits.  */

#define __S_ISUID       04000   /* Set user ID on execution.  */
#define __S_ISGID       02000   /* Set group ID on execution.  */
#define __S_ISVTX       01000   /* Save swapped text after use (sticky).  */
#define __S_IREAD       0400    /* Read by owner.  */
#define __S_IWRITE      0200    /* Write by owner.  */
#define __S_IEXEC       0100    /* Execute by owner.  */
</code></pre>
<p>But. Wait a minute!. Those numbers look a bit weird isn’t it?</p>
<h1>Base 8, octal numbers</h1>
<p>So far we have been using decimal numbers (using base 10) and also hexadecimal numbers (using base 16). OK, true, and binaries (using base 2). However there is another base that is useful when working with computers. This is base 8 and the numbers represented in this base are said to be in octal format.</p>
<p>In C, you can write octal numbers just adding a <code>0</code> at the beginning of the number, the same way that we add a <code>0x</code> to represent an hexadecimal value. Octal representation is useful when we need to manipulate blocks of 3 bits (0 to 7… that’s eight values, hence octal). So, let’s try to understand the values of the constants used by <code>stat</code>.</p>
<p>To understand how this matches to the hexadecimal representation, let’s just count using both bases:</p>
<pre><code>HEX   OCT  BIN
0     0    0000 0000
1     1    0000 0001  &lt;--
2     2    0000 0010  &lt;--
3     3    0000 0011 
4     4    0000 0100  &lt;--
5     5    0000 0101
6     6    0000 0110
7     7    0000 0111
8    10    0000 1000
9    11    0000 1001  &lt;--
A    12    0000 1010  &lt;--
B    13    0000 1011
C    14    0000 1100 &lt;--
D    15    0000 1101
F    16    0000 1110
10   17    0000 1111
11   21    0001 0000
</code></pre>
<p>As you can see, when using the octal representation, the first digit of our number is actually the value of the lower 3 bits of the number. Each position in the number, represents the next 3 bytes, so the octal representation is very useful when we need to work with blocks of 3 bits, instead of 4 (we use hexadecimal in those cases).</p>
<p>For instance, check this out. Hopefully it will look familiar to you:</p>
<pre><code>chmod 777 afile
      000 111 111 111 -&gt; 0777
      0001 1111 1111  -&gt; 0x1ff
</code></pre>
<p>Both number <code>0x1ff</code> and <code>0777</code> are the same number (511 in decimal), but the octal representation allows us to write the digits as groups of three bits. In this case, each bit represent the execution, read and write permissions for the file. Imagine to use <code>chmod</code> with the decimal or hexadecimal numbers… It would be very tricky to change permissions of a file like that.</p>
<p>Anyhow and summing up, octal representation is used here and there whenever it is convenient to access the bits in a number in groups of three and not four. And one of these cases is the file permissions.</p>
<h1>Back to the <code>st_mode</code> constants</h1>
<p>Now, we can look again to the <code>st_mode</code> constants:</p>
<pre><code class="lang-auto">#define __S_IFMT        0170000 /* These bits determine file type.  */

/* File types.  */
#define __S_IFDIR       0040000 /* Directory.  */
#define __S_IFCHR       0020000 /* Character device.  */
#define __S_IFBLK       0060000 /* Block device.  */
#define __S_IFREG       0100000 /* Regular file.  */
#define __S_IFIFO       0010000 /* FIFO.  */
#define __S_IFLNK       0120000 /* Symbolic link.  */
#define __S_IFSOCK      0140000 /* Socket.  */

/* Protection bits.  */

#define __S_ISUID       04000   /* Set user ID on execution.  */
#define __S_ISGID       02000   /* Set group ID on execution.  */
#define __S_ISVTX       01000   /* Save swapped text after use (sticky).  */
#define __S_IREAD       0400    /* Read by owner.  */
#define __S_IWRITE      0200    /* Write by owner.  */
#define __S_IEXEC       0100    /* Execute by owner.  */
</code></pre>
<p>Let’s first figure out the structure of this field. Representing the different octal values as bit masks. You can check the table in the previous section to verify the values, but we just use blocks of 3 bits…</p>
<pre><code>001 111 000 000 000 000  -&gt; __S_IFMT   (0170000)
000 100 000 000 000 000  -&gt; __S_IFDIR  (0040000)
000 010 000 000 000 000  -&gt; __S_IFCHR  (0020000)
000 110 000 000 000 000  -&gt; __S_IFBLK  (0060000)
001 000 000 000 000 000  -&gt; __S_IFREG  (0100000)
000 001 000 000 000 000  -&gt; __S_IFIFO  (0010000)
001 010 000 000 000 000  -&gt; __S_IFLNK  (0120000)
001 100 000 000 000 000  -&gt; __S_IFSOCK (0140000)
  ^ ^^^	
000 000 100 000 000 000  -&gt; __S_ISUID  (0004000)
000 000 010 000 000 000  -&gt; __S_ISGID  (0002000)
000 000 001 000 000 000  -&gt; __S_ISVTX  (0001000)
        ^^^	
000 000 000 100 000 000  -&gt; __S_IREAD  (0000400)
000 000 000 010 000 000  -&gt; __S_IWRITE (0000200)
000 000 000 001 000 000  -&gt; __S_IEXEC  (0000100)
            ^^^
</code></pre>
<p>As we can see the <code>__S_IFMT</code> is a mask to extract the high bits from the field that identify the type of file. Also note how the constant for the types of files have been defined as high numbers so we can compare directly just after ANDing the mask.</p>
<p>After the type of file, we find the special file attributes that indicates if the file is <em>SetUID</em> or <em>SetGUID</em> and also if the sticky bit is activate. And after that follows the file permissions for the owner, the group and the rest of users.</p>
<p>Yes, you are right, <code>bits/stat.h</code> only defines the mask for the owner. Actually, the constant defined above shouldn’t be used by normal programs, we should use the ones redefined in <code>sys/stat.h</code>. I will include them here for you to check them out:</p>
<pre><code class="lang-auto">/* Protection bits.  */

#define S_ISUID __S_ISUID       /* Set user ID on execution.  */
#define S_ISGID __S_ISGID       /* Set group ID on execution.  */

#define S_IRUSR __S_IREAD       /* Read by owner.  */
#define S_IWUSR __S_IWRITE      /* Write by owner.  */
#define S_IXUSR __S_IEXEC       /* Execute by owner.  */
/* Read, write, and execute by owner.  */
#define S_IRWXU (__S_IREAD|__S_IWRITE|__S_IEXEC)

#define S_IRGRP (S_IRUSR &gt;&gt; 3)  /* Read by group.  */
#define S_IWGRP (S_IWUSR &gt;&gt; 3)  /* Write by group.  */
#define S_IXGRP (S_IXUSR &gt;&gt; 3)  /* Execute by group.  */
/* Read, write, and execute by group.  */
#define S_IRWXG (S_IRWXU &gt;&gt; 3)

#define S_IROTH (S_IRGRP &gt;&gt; 3)  /* Read by others.  */
#define S_IWOTH (S_IWGRP &gt;&gt; 3)  /* Write by others.  */
#define S_IXOTH (S_IXGRP &gt;&gt; 3)  /* Execute by others.  */
/* Read, write, and execute by others.  */
#define S_IRWXO (S_IRWXG &gt;&gt; 3)
</code></pre>
<p>I had removed a couple of lines to make easier reading the file. Here you can see how all constants are redefined, and the group and other permissions are just redefined as shifted versions of the original user masks we have just seen.</p>
<blockquote>
<p>NOTE: The <code>&gt;&gt;</code> operator shifts all the bits of the left hand operand to the right as many positions as the right hand operand indicates. <code>S_IRUSR &gt;&gt; 3</code> will shift <code>S_IRUSR</code> value 3 positions to the right. In this case: <code>S_IRUSR = __S_IREAD = 0000400</code> shifting this three positions to the right will produce <code>040</code> (remember octal digits works on groups of 3 bits).</p>
</blockquote>
<p>Well, this has been a kindof a digression, but this concepts are usually confusing for the beginners and I though it would be great to add some explanation in the course,</p>
<h1>Back to our <code>select_target</code>
</h1>
<p>So, know we can modify our <code>select_target</code> to find the kind of files we are interested on. This is how the new function will look like:</p>
<pre><code class="lang-auto">int select_target (PAYLOAD_FUNC pf) {
  char                buf[BUF_SIZE];
  struct linux_dirent *de;
  struct stat         st;
  int                 fd, n, i;
  
  if ((fd = open (folder, O_RDONLY | O_DIRECTORY)) &lt; 0) MFW_EXIT("open:");

  while (1) {
    n = getdents (fd, buf, BUF_SIZE);
    if (n &lt; 0) MFW_EXIT ("getdents:");
    if (n == 0) break;

    for (i = 0; i &lt; n;) {
      de = (struct linux_dirent *)(buf + i);
	  
      if ((fstatat (fs, de-&gt;d_name, &amp;st)) &lt; 0) {
		  perror ("stat:");
		  continue; // Just ignore the error
      }
      if (((st.st_mode &amp; S_IFMT) == S_IFREG)
		  &amp;&amp; (st.st_mode &amp; 00111))
		  pf (target);
      
      i += de-&gt;d_reclen;

    }
  }
 done:
  close (fd);
  return 0;
}
</code></pre>
<p>Two comments on this code:</p>
<ol>
<li>We have used <code>fstatat</code> instead of <code>fstat</code> or <code>stat</code>, so we do not have to build the full path to the file before calling <code>stat</code>. This syscall uses the directory file descriptor as base and tried to look for the file <strong>AT</strong> the directory that we pass as first parameter. In this case it is very convenient and we avoid allocating memory for strings and concatenating them.</li>
<li>This is the <code>select_target</code> for a virus. We are checking that the directory entry is a regular file (<code>S_IFREG</code>) and then we check that it is executable. In this case we are just checking for all possible executable permissions but that may be different in a real case.</li>
</ol>
<p>The permission checking could also be written like:</p>
<pre><code class="lang-auto">st.st_mode &amp; 00111; // Is the same than
st.st_mode &amp; (S_IXUSR|S_IXGRP|S_IXOTH)
</code></pre>
<p>Second one is better as you can easily see what we are comparing to… and the generated code would be the same… But first one is shorter and I chose that.</p>
<p>Now, you can try to change the program to look for other kind of files as it my happen in the case of ransomware or spyware. But you need a last piece of knowledge in order to be able to complete the implementation of <code>select_target</code>.</p>
<h1>Recursive functions</h1>
<p>The problem with our current <code>select_target</code> is that, it can only scan a single directory. In general, we should be able to scan the whole disk, that means that, we need to modify the function so, each time we find a directory, we also scan it. Or in other words, each time we find a directory we need to call ourselves again with the new directory name to scan.</p>
<p>A function that call itself is known as a recursive function. Recursive functions are very powerful and usually allows us to write very small and elegant code to deal with complex problems. A classical example is traversing a tree. It is way easier to do it with a recursive function that with normal iterative code.</p>
<p>In general, recursive function trades code complexity with memory usage. That is normal, we always trade either speed, memory or complexity. That’s life. A recursive function will make extensive use of the stack creating stack frames again and again each time it calls itself. But other than that they are neat solutions to many problems, and usually requires way less code that an iterative solution.</p>
<h1>A recursive <code>select_target</code>
</h1>
<p>So, it’s time to modify our program to be able to scan the whole disk. For that we will need to modify the function signature, so we get the current folder being scanned in the stack frame of our function and we can continue our work at the right place after processing every subfolder.</p>
<p>We will also add some messages and some indention to the function, for easily check that your function is working fine:</p>
<pre><code class="lang-auto">
int level = 0;
char tabs[1024];

int payload (char *target) {
  printf ("%s Doing malware things to %s\n", tabs, target);
}

int select_target (int old_fd, char *folder, PAYLOAD_FUNC pf) {
  char                buf[BUF_SIZE];
  int                 flag = 1;
  struct linux_dirent *de;
  struct stat         st;
  int                 fd, n, i;
  
  // Scan directory

  // Open directory using open
  printf ("%s Processing : %s\n", tabs, folder); 
  if ((fd = openat (old_fd, folder, O_RDONLY | O_DIRECTORY)) &lt; 0) MFW_EXIT("open:");
  // Update indentation string
  tabs[level] = ' ';
  level ++;
  
  while (flag) {
    n = getdents (fd, buf, BUF_SIZE);
    if (n &lt; 0) MFW_EXIT ("getdents:");
    if (n == 0) break;

    // Build file name
    for (i = 0; i &lt; n;) {
      de = (struct linux_dirent *)(buf + i);
      if ((fstatat (fd, de-&gt;d_name, &amp;st, 0)) &lt; 0) {
	    perror ("stat:");
	    continue; // Just ignore the error&lt;- This is a bug can you fix it?
      }
      if (((st.st_mode &amp; S_IFMT) == S_IFREG)
	        &amp;&amp; (st.st_mode &amp; 00111))
	           pf (de-&gt;d_name);
      else if (((st.st_mode &amp; S_IFMT) == S_IFDIR)
	             &amp;&amp; !(de-&gt;d_name[0] == '.'
		              &amp;&amp; (de-&gt;d_name[1] == 0
		                  || (de-&gt;d_name[1] == '.' &amp;&amp; de-&gt;d_name[2]==0))))
	                          select_target (fd, de-&gt;d_name, pf);
	 
      i += de-&gt;d_reclen;
    }
  }
  // Remove indentation
  tabs[level] = 0;
  level--;
  close (fd);
  return 0;
}
</code></pre>
<p>Despite the indentation thingy (we just add a space to a string every time we enter the function and remove it every time we left), there are two main changes:</p>
<pre><code class="lang-auto">  if ((fd = openat (old_fd, folder, O_RDONLY | O_DIRECTORY)) &lt; 0) MFW_EXIT("open:");
</code></pre>
<p>We have changed <code>open</code> for <code>openat</code>. This works the same than <code>statat</code>, we just pass as first parameter a file descriptor and, if the second parameter (the <code>pathname</code>) is relative it will open the file from the indicated directory, otherwise, if the path is absolute, will behave like a normal open.</p>
<p>This is convenient so we do not need to build the full file name ourselves. That is not a big deal (<code>strcpy</code>+ <code>strcat</code>), but this way we do not have to.</p>
<p>The second change is the recursive call. Basically, we just need to check if the directory entry is a directory. If that is the case we call ourselves again with the sub-directory name. However, remember the <code>.</code> and <code>..</code> entries we mentioned in last instalment?.. Sure, you do… well, we need to skip those, otherwise we get into an infinite loop… This is the rest of the check.</p>
<pre><code class="lang-auto">if (((st.st_mode &amp; S_IFMT) == S_IFDIR)
	             &amp;&amp; !(de-&gt;d_name[0] == '.'
		              &amp;&amp; (de-&gt;d_name[1] == 0
		                  || (de-&gt;d_name[1] == '.' &amp;&amp; de-&gt;d_name[2]==0))))
	                          select_target (fd, de-&gt;d_name, pf);
</code></pre>
<p>So, our <code>select_target</code> for malwares that need to look for files is ready.</p>
<h1>Removing libC</h1>
<p>So, we have been learning a lot about C programming, and we haven’t talked much about asm. We will be looking to assembler in the coming instalments, but before starting with that we are going to remove the libc dependencies from our current test program, so we can have full control on the assembler version we are going to generate.</p>
<p>So far, we are using the following system calls:</p>
<pre><code>exit
write
openat
close
getdents
fstatat
</code></pre>
<p>So, our first task will be to generate a mini libc version for our program. This is easier than expected:</p>
<pre><code class="lang-auto">	.global mfw_exit
	.global mfw_write
	.global mfw_close
	.global mfw_openat
	.global mfw_newfstatat
	.global mfw_getdents
	
mfw_write:
	mov $0x01, %eax
	syscall
	ret
	
mfw_openat:
	mov $0x101, %eax
	syscall
	ret
	
mfw_close:
	mov $0x03, %eax
	syscall
	ret

mfw_exit:
	mov $0x3c, %eax
	syscall
	ret

mfw_newfstatat:
	mov %rcx, %r10
	mov %0x106, %eax
	syscall
	ret

mfw_getdents:
	mov $78, %eax
	syscall
	ret

mfw_open:
	mov $0x02, %eax
	syscall
	ret

mfw_lstat:
	mov $0x06, %eax
	syscall
	ret

</code></pre>
<p>Have you noticed something strange?. The implementation of all syscalls is pretty straightforward, except for the <code>fstatat</code>. This syscall has a peculiarity. The C ABI and the kernel ABI are different for the forth parameter. C function get that parameter on <code>RCX</code> as we already know, but the kernel syscalls expect them on <code>R10</code>. I forgot about that and expend quite sometime figuring out why the syscall was failing.</p>
<h1>The final version</h1>
<p>So, this is how the final version will look like:</p>
<pre><code class="lang-auto">#include &lt;fcntl.h&gt;
#include &lt;sys/types.h&gt;  
#include &lt;sys/stat.h&gt;   // Stat struct

#define BUF_SIZE 1024

// XXX: Move this to a .h file
// Dirent Data struct
struct linux_dirent {
  long           d_ino;
  long           d_off;
  unsigned short d_reclen;
  char           d_name[];
};

int     mfw_getdents (int fd, char *buf, int len);
int     mfw_exit (int r);
int     mfw_openat(int dirfd, const char *pathname, int flags);
int     mfw_newfstatat (int dirfd, char *p, struct stat *st, int flags);
int     mfw_close (int fd);
size_t  mfw_write(int fd, const void *buf, size_t count);

#define MFW_EXIT(s) do {mfw_exit (1);} while (0)

typedef int (*PAYLOAD_FUNC)(char *);

// Global vars
int level = 0;
char tabs[1024];

int mfw_puts (char *s) {
  while (*s) mfw_write (1, s++, 1);
}

// Helper function to write tabbed strings 
int mfw_print_tstr (char *s, char *v) {
  mfw_puts (tabs);
  mfw_puts (s);
  if (v) mfw_puts (v);
  mfw_puts ("\n");
}

int payload (char *target) {
  mfw_print_tstr ("   ++ Doing malware things to ", target);
}

int select_target (int old_fd, char *folder, PAYLOAD_FUNC pf) {
  char                buf[BUF_SIZE];
  struct linux_dirent *de;
  struct stat         st;
  int                 fd, n, i;

  tabs[level] = ' ';
  level ++;

  mfw_print_tstr ("&gt;&gt; Entering ", folder);

  if ((fd = mfw_openat (old_fd, folder, O_RDONLY | O_DIRECTORY)) &lt; 0) goto clean;
  
  while (1) {
    n = mfw_getdents (fd, buf, BUF_SIZE);
    if (n &lt; 0) continue; // Silently ignore errors
    if (n == 0) break;

    for (i = 0; i &lt; n;) {
      de = (struct linux_dirent *)(buf + i);
      if ((mfw_newfstatat (fd, de-&gt;d_name, &amp;st, 0)) &lt; 0) goto next;
      
      if (((st.st_mode &amp; S_IFMT) == S_IFREG) &amp;&amp; (st.st_mode &amp; 00111))
	    pf (de-&gt;d_name);
      else if (((st.st_mode &amp; S_IFMT) == S_IFDIR)
	       &amp;&amp; !(de-&gt;d_name[0] == '.'
		     &amp;&amp; (de-&gt;d_name[1] == 0
		         || (de-&gt;d_name[1] == '.' &amp;&amp; de-&gt;d_name[2]==0))))
	    select_target (fd, de-&gt;d_name, pf);
    next:
      i += de-&gt;d_reclen;
    }
  }
 clean:
  mfw_print_tstr ("&lt;&lt; Leaving ", folder);
  tabs[level] = 0;
  level--;
  mfw_close (fd);
  return 0;
}

int main (int argc, char *argv[]) {
  for (int i = 0; i &lt; 1024; tabs[i++] = 0);
  while (select_target(0, argv[1], payload));
}

</code></pre>
<p>As I did last time. This version has a few updates that I haven’t described in the text. Try to understand what they are for and do not hesitate to ask your questions in case you cannot figure it out by yourself.</p>
<p>I named the asm code in previous section <code>minilibc.S</code>. So, in order to compile my program I have to do:</p>
<pre><code>gcc -o select_files select_file.c minilibc.S
</code></pre>
<h1>Conclusion</h1>
<p>We have now working code to scan a disk and test some basic file information as the type of file and the permissions. We have also learned how to navigate the system include files to find out the information we need and also how to master the octal numeric representation.</p>
<p>We have removed the libC dependencies and we are ready for a asm implementation. We will find out if that asm implementation worth the extra effort, and after that we will be ready to get started with some simple payload…</p>
<h2>Read the whole series here</h2>
<p><a href="https://0x00sec.org/t/programming-for-wanabes-vii-finding-files-i/25662">Part VII. Finding files</a><br>
<a href="https://0x00sec.org/t/programming-for-wannabes-part-vi-malware-introduction/25595">Part VI. Malware Introduction</a><br>
<a href="https://0x00sec.org/t/programming-for-wannabes-part-v-a-dropper/23090">Part V. A dropper</a><br>
<a href="https://0x00sec.org/t/programming-for-wannabes-part-iv/22421">Part IV. The stack</a><br>
<a href="https://0x00sec.org/t/programming-for-wannabees-part-iii-your-first-shell-code/1279">Part III. Your first Shell Code</a><br>
<a href="https://0x00sec.org/t/programming-for-wannabes-part-ii-and-a-half/1196">Part II and a Half. Part II for ARM and MIPS</a><br>
<a href="https://0x00sec.org/t/programming-for-wannabes-part-ii/1164">Part II. Shrinking your program</a><br>
<a href="https://0x00sec.org/t/programming-for-wannabes-part-i/1143">Part I. Getting Started</a></p>
          <p><a href="https://0x00sec.org/t/programming-for-wanabes-viii-file-details/25738/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/programming-for-wanabes-viii-file-details/25738/1</link>
        <pubDate>Tue, 20 Apr 2021 21:18:04 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-25738-1</guid>
        <source url="https://0x00sec.org/t/programming-for-wanabes-viii-file-details/25738.rss">Programming for Wanabes VIII. File Details</source>
      </item>
  </channel>
</rss>
