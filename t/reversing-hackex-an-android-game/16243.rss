<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Reversing HackEx - An android game</title>
    <link>https://0x00sec.org/t/reversing-hackex-an-android-game/16243</link>
    <description>Hello peeps. I&#39;m sp0re. This is my first post on 0x00sec, you can find more about me on [my website](https://sp0re.sh).  Today we are going to reverse engineer the network protocol of an android game so that we can automate the game, and earn unlimited money while drinking sodas and eating doritos. When looking online, they&#39;ve had issue with cheaters for years now. But is it really that easy to cheat in this game? Let&#39;s find out.

The game in question is [HackEx](https://play.google.com/store/apps/details?id=com.byeline.hackex&amp;hl=en) It&#39;s an online &quot;hacking&quot; simulator game for mobile. The goal is quite simple, you &quot;hack&quot; into other players in order to steal their money, drop some spam viruses or spyware, so you are able to upgrade your software by buying better versions or stealing better versions from others.

# Environment Setup
Before tinkering, we need to set our environment up and running. For android reversing, I usually use [android studio](https://developer.android.com/studio) as well as an x86_64 android emulator. x86_64 mainly because I&#39;m more comfortable reading it over ARM.

First, open android studio and create a random project.

Once done, click on **tools&gt;AVD Manager** and spin up a new emulator. When it asks you to select a system image, click on **x86 Images** and take one with (Google APIs). For some reasons, it will allow you to have a rooted emulator.

![2019-09-13-124655_1027x672_scrot|690x451](upload://cwriZqd57kvhnUBBhzKu3gvdrKR.png) 

I will take Oreo (Api level 26) because why not.

Once configured, you need to start it using `emulator` in order to get a writable system endpoint. it will be useful later.

    $ ~/Android/Sdk/emulator/emulator -list-avds
    Pixel_2_API_26
    $ ~/Android/Sdk/emulator/emulator -writable-system -avd Pixel_2_API_26

Now we also need [Android Debug Bridge](https://wiki.archlinux.org/index.php/Android_Debug_Bridge) in order to communicate easily with our emulator. On arch linux, you can pull the binary using the following command:

    pacman -S android-tools


Once ADB is installed, and your emulator is running, you can check that everything is setup correctly by running

    adb devices

If you get an output, you are good to go! But, just to be proactive, we will restart adbd on the emulator as root, by using the following command:

    adb root


# Application Discovery
Before starting the leet stuff, let&#39;s have a first glance of the game. I downloaded the apk from the google store on my phone, then pulled the apk on my computer.

From there, once your emulator is running, you need to run the following command to install the APK on it:

    adb install /path/to/app.apk

![apk_install|600x500](upload://vfDFFLbN0GhBYuOwbd51HOHSD5I.gif) 

Nice! The apk is installed, now we can just open it and play with it.

So the game is pretty simple, you scan for victims, then &quot;hack&quot; them, and it will show you a progress bar in the processes window. Once complete, you can connect to their system. Once connected, you can download their stuff, upload some of your stuff, or attempt to crack their bank password. each of these actions take time and are represented as progress bars in the process window.

Now since this game is multiplayer. It is safe to assume that all these actions are sent to the server for synchronizing with all the player. Say if someone &quot;hacks&quot; my system, and flushes my bank account, I have to see it. So let&#39;s try to determine how the application is communicating with the server.

# Network Analysis

## Network discovery

In order to intercept the communication between the app and it&#39;s server, we will push `tcpdump` to the emulator. I suggest taking it from this [Static-binaries](https://github.com/yunchih/static-binaries) repo found on github.

    $ adb push tcpdump /data/local/tmp/
    tcpdump: 1 file pushed. 66.0 MB/s (2377024 bytes in 0.034s)
    $ adb shell
    # cd /data/local/tmp &amp;&amp; chmod 700 tcpdump
    # ./tcpdump -i any -s0 -n -w /sdcard/out.pcap

Now all we have to do it playing a bit the game, and then exit tcpdump. It will create a pcap located at /sdcard.

Now we extract the pcap:

    $ adb pull /sdcard/out.pcap . 

And open it with wireshark:

![open_pcap_wiresark|690x371](upload://kN4bUhV1NcLPp4PrzioYJk5c8ob.gif) 

There&#39;s a lot of packets from this dump. The first goal here is to identify the server&#39;s IP in order to filter the traffic. In order to do that, I assumed that some of the packet would contain &quot;hackex&quot; as this is the name of the application. Let&#39;s checkk that with strings:

    $ strings -n 6 out.pcap | grep -i &quot;hackex&quot;
     hackex
    hackex
    hackex
    hackex
    api.hackex.net
    *.hackex.net
    [...]

This seems like the DNS entries of a cert file. Good thing is that we have an api endpoint to poke at, and the protocol is HTTP. The bad thing is that the traffic is probably encrypted using SSL.

to verify that, in wireshark, we can click on **edit &gt; Find Packet...** and search for the string **api.hackex.net**

it returns a Client Hello packet from TLS1.2. It&#39;s not as easy as we thought!

## Network decryption

We therefore need a way to decrypt SSL traffic, in order to get  the http content.
For that, the best way it to proxy all the traffic to burp, and install burp&#39;s certificate to the emulator.

Unfortunately, since a recent version of Android, user certificates are not used by applications without consent. There&#39;s 2 workarounds for that:

- We install the certificate as a system certificate, but we need root
- We patch the apk to use our user certificate.

Obviously, as we are root, we are going to set burp certificate as a system cert!

Fire up burp, go to **proxy** tab, then the **Options** subtab and add a new listener. It needs to listener on all interface, using a different port than the default one

![burp_setup|690x370](upload://z6VvqAqJdOYpzGGmqxHOG6baMtw.gif) 

Now export the certificate on your computer. In order for the emulator to accept it, you need to transform the der file to pem, and rename it using `subject_hash_old`:

    openssl x509 -inform DER -in cacert.der -out cacert.pem  
    openssl x509 -inform PEM -subject_hash_old -in cacert.pem |head -1  
    mv cacert.pem &lt;hash&gt;.0  


my cert is `9a5ba575.0`. so I use this command to push the cert to the emulator:

    $ adb push 9a5ba575.0 /sdcard

now we need to add the certificate to the /system/etc/security/cacerts/ location. to do that, we need to remount the partition as `rw` . To do that, connect to the emulator shell and run the following command:

    $ adb shell
    # mount -o rw,remount /system

Once done, move the file to the above path:

    # mv /sdcard/9a5ba575.0 /system/etc/security/cacerts/
    # chmod 644 /system/etc/security/cacerts/9a5ba575.0

And finally, reboot the emulator using `adb reboot`.

Now if you go to Settings, browse to **Security &amp; location &gt; Encryption &amp; credentials &gt; Trusted credentials** you should see PortSwigger CA.

![cacert_installed|289x500](upload://cs8Iy0phfiMibkgE73NljE3N8Iq.jpeg) 

Success! We can now get the traffic using burp! But to do that, we need to proxy the traffic to our burp. For this, you will need to restart the emulator with the following command:

    $ ~/Android/Sdk/emulator/emulator -writable-system -avd Pixel_2_API_26 -http-proxy 127.0.0.1:8080

![ssl_decrypted|690x374](upload://51djRAAtsTdDA6SjGy6Qwi9bkK2.png) 

Boom! SSL Decryption!

Now let&#39;s start the game again, and play a bit, we should see some communication.

I can quicky see a lot of traffic, but each request is made with 2 parameters, `sig` and `sig2`
It seems that the application is signing each request before sending them. So the server is sure that the request is coming from the application, and not from other means. We can verify that by editing a request in burp repeater:

Legit request:
![legit_req|690x441](upload://1kjQEW24IZkBnHFavfWIuLm1MEW.png) 

Wrong request:
![wrong_req|690x440](upload://icSpkFFXm2KzWzpo1NX07BQhxGn.png) 

**YES, THE SERVER IS DUMB**

So if we want to be able to use the api without the game, we need the logic to construct the `sig` parameters.

# Reversing Time

## Static analysis

We will decompile the APK using `jadx`. This will let us see the sources and the assets of the app.

    $ mkdir jadx_out
    $ jadx -d jadx_out apkdir/base.apk

Once finished, in the `jadx_out` folder, you&#39;ll find the sources and the resources. Go to the sources, and grep for &quot;api.hackex.net&quot;:

    $ grep -r &quot;api.hackex.net&quot; .
    com/byeline/hackex/k/e.java:    public static String f1971a = &quot;https://api.hackex.net/v8/&quot;;
    com/byeline/hackex/k/e.java:        f1971a = &quot;https://api.hackex.net/v8/&quot;;
    com/byeline/hackex/d/a.java:        return (c) new retrofit2.m.a().a(&quot;https://api.hackex.net/v8/&quot;).a(aVar.a(Collections.singletonList(y.HTTP_1_1)).a()).a((retrofit2.e.a) retrofit2.a.a.a.a(configure)).a((retrofit2.c.a) g.a()).a().a(c.class);

In the file `com/byeline/hackex/k/e.java`, the api url is defined, we can go and analyse this file to see what we do with the string.

We can see many methods that apparently handle the rest communication. For instance, we can see in the following method that the server is handling the `user_bank` endpoint, probably when the user checks his bank account in the game:

![user_bank|651x500](upload://goA5BU4FplbYVr9aTwCYSmCaX0C.jpeg) 

We can also see the code that creates the `sig` parameter. Though we see that it doesn&#39;t create the `sig2` parameter anywhere. 

For the `sig` param, we create an empty hashMap, and give it to `SettingsManager.flux()`. I suspect the hash_map contains the request parameters if there are any. Let&#39;s check another function:

![victim_user_bank|559x500](upload://oZEf9YZBjhoCDe1ydrlLauuWbP7.png) 

This is indeed the case. We can see above that we give the hashmap the values `victim_user_id` as well as `String.valueOf(i2)`.

This make me believe that `SettingsManager.flux()` handles the signature generation. Let&#39;s find it using grep.

    $ grep -r &quot;flux&quot; .
    ./com/byeline/hackex/settings/SettingsManager.java:    public static native String flux(Map&lt;String, String&gt; map);
    ./com/byeline/hackex/settings/SettingsManager.java:        sb.append(flux(c(str)));

Checking this file, we see that flux is a native function. This doesn&#39;t sound good! Does it? It means the function is probably coming from a compiled library. We can confirm it by cating the file and see the following code:

    static {
        System.loadLibrary(&quot;HackEx&quot;);
    }
    
Therefore, the code for generating the signature is stored in a lib named libHackEx.so.

    # find / -name &quot;*libHackEx.so*&quot; 2&gt;/dev/null                                                                                                                         
    /data/app/com.byeline.hackex-E-Wrx3wEw35mpVavUJ0_RA==/lib/x86_64/libHackEx.so

thankfuly it&#39;s in x86_64. We can pull it and analyse it.

    # cd /data/app/com.byeline.hackex-E-Wrx3wEw35mpVavUJ0_RA==/lib/x86_64/
    # file libHackEx.so
    libHackEx.so: ELF shared object, 64-bit LSB x86-64, for Android 21, built by NDK r18 (5002713), BuildID=b70b329b6121afd5ba59f2c716a8a56bef9fb294, stripped
    $ adb pull /data/app/com.byeline.hackex-E-Wrx3wEw35mpVavUJ0_RA==/lib/x86_64/libHackEx.so .

Now we have the library locally which is good news. The library is a native library for android, which means it follows the Java Native Interface convention (JNI). We won&#39;t talk much about JNI itself here because there&#39;s too much to be said about it, and it&#39;s not the point of this article. Key things to know are:

- The exported function have the following name: Java_(packageName)_(className)_(functionName)
- There&#39;s a lot of code handling interfact between JAVA and library code. For instance, if we feed a HashMap to a native library, obviously the library won&#39;t know how to handle that, so the JNI will translate it transparently. 

That being said, we are looking for a function called Java_com_byeline_hackex_settings_SettingsManager_flux. So let&#39;s open the file in `radare2`

![r2_open|690x234](upload://wRkit58Y0Elps7AXrxiSU1o1gZn.png) 

Now we type `afl` to list all functions. Since the binary is stripped, we won&#39;t get a lot of function names, but the interesting one should still be shown as it has to be named to be exprted.

    [0x0000e680]&gt; afl
    (...)
    0x0000e6e0   68 2870 -&gt; 2822 sym.Java_com_byeline_hackex_settings_SettingsManager_flux
    (...)

Nice, let&#39;s check it&#39;s content using `pdf @sym.Java_com_byeline_hackex_settings_SettingsManager_flux`

    [0x0000e680]&gt; pdf @sym.Java_com_byeline_hackex_settings_SettingsManager_flux

The output is 736 line of assembly code, a nightmare to reverse statically! But still, we can see some interesting stuff in it:

    0x0000e70f      e8acf8ffff     call sym.imp.clock_gettime

So it gets a timestamp. That&#39;s probably for the `sig2=` part as we saw earlier that it has the format of a timestamp in milisecond.

    0x0000e7db      488d358ffd01.  lea rsi, [0x0002e571]       ; &quot;sig2&quot;

The &quot;sig2&quot; string is hardcoded in, which confort the idea of this being the function we are looking for.

    0x0000eb3b      660f2805cd05.  movapd xmm0, xmmword [str.69540016560011007D2D2B63370A30573E3A607A730207381E3F070E38150414001B060273067F31] ; [0x2f110:16]=-1 ; &quot;69540016560011007D2D2B63370A30573E3A607A730207381E3F070E38150414001B060273067F31&quot;
    0x0000eb82      4c8d25470502.  lea r12, str.P3eoc0cO5zHSbzZeSrQL8f3wMGbIrZcpEkEh1OFv ; 0x2f0d0 ; &quot;P3eoc0cO5zHSbzZeSrQL8f3wMGbIrZcpEkEh1OFv&quot;

Those are 2 interesting strings. It is probably used to create the actual signature at the end. Also, the first string has a length of 80, and it&#39;s composed of hex, the second string has a length of 40. I think there&#39;s a high chance that for each char of the second string, we take 2 chars of the first one, get the hex value of it and do something that will result in a new string of length 40. The following block confirms my assumption:

![xor_block|690x154](upload://hS1cwYmCDvyEZP749WvVJq97MW3.jpeg) 

First we load in rdi (the address of rsp+rbx+0x160). then, we load a string in rsi, another one in rdx, and perform a scanf. We then xor a byte coming from rbp+r12 and mov it to rsp+rbx+0x130. We increment some counters, compare that one of the counter is equals to 0x50 (80) and jump back to the begining is it&#39;s below this value.

So as we increment rbx by 2 at each loop, I assume that the first string above is located at rsp+rbx+0x160, and the second string is located at rbp+r12. The resulting string is therefore probably in rsp+rbp+0x130.

Let&#39;s continue.

After this block, I do not spot a lot of easily decodable logic. Nonetheless, there&#39;s still some interesting stuff.

![sprintfs|690x349](upload://oUV85EQWfRFXJSHxGqrdEZJIGZY.png) 

We can see a sequence of sprintfs. 20 to be exact. this makes a string of exactly 40 chars. 

Finally, we can see the following interesting lines:

    0x0000f0d3      488d3509f501.  lea rsi, [0x0002e5e3]       ; &quot;sig&quot;
    0x0000f11f      488d35c1f401.  lea rsi, str.sig2           ; 0x2e5e7 ; &quot;&amp;sig2=&quot;

So at this point we construct the signature to be returned to the java class.

From here, we have greatly increased our knowledge of this function already. We can assume that from the 2 strange strings, we create a new one after a loop of xoring, and then we use it to sprintf something which is used to construct our final return string. But still, we now know where the parameters from the hashmap are coming from, and also that the timestamp is somehow involved. I think it&#39;s time to move to dynamic analysis.

## Dynamic Analysis

There&#39;s a lot of way to perform dynamic analysis. But for a native function like that, nothing beat GDB!

Let&#39;s setup gdb in our emulator to analyze this function at runtime. But before that, I&#39;d like an easier setup than analyzing the actual function using the game apk. Let&#39;s create a simple apk and link our library to it, so we can debug it more easily.

Fire up android studio, create a new projet with an empty activity. Then it is important to use the same package name as the game. So we will use **com.byeline.hackex**

![new_as_proj|645x500](upload://gwvPEGdAlyUasIkX40ktuUgvOi0.png) 

Now for the sake of easyness, let&#39;s add a button, and we&#39;ll trigger the `flux` function each time we click on it. in `activity_main.xml`, add a button, and change its id to `btnFlux`. Now in `MainActivity.java` file, edit the `onCreate` method and add the following code:

    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
        
    Button btn = findViewById(R.id.btnFlux);

    btn.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view)
        {
            // Do something 
        }
    });

Now we have to link our .so file to the project. For that you need to put the .so file in the following structure: 

![jniLibs_struct|275x372](upload://2iu8r7hXrRwGwGexyoTfn5vgVVG.png) 

Now create a package named `settings` inside of `com.byeline.hackex` and create a new class named `SettingsManager` in said class.

The code has to be the following:

    package com.byeline.hackex.settings;

    import java.util.Map;

    public class SettingsManager {

        public static native String flux(Map&lt;String, String&gt; map);

        static {
            System.loadLibrary(&quot;HackEx&quot;);
        }
    }

Good! Now let&#39;s edit `MainActivity.java` and add the following code in our button click listener:

    HashMap&lt;String, String&gt; lol = new HashMap&lt;&gt;();
    lol.put(&quot;parama&quot;, &quot;valuea&quot;);
    String ret = SettingsManager.flux(lol);
    Log.i(&quot;REVERSING&quot;, ret);

We will also put the same code **before** our click listener as it will let android map the library before we attach with gdb.

We are good to go, press `Alt+F10` and it should run on your emulator! At each click, if you check the `logcat` output in android studio, you should see a signature string:

![logcat_output|599x500](upload://wDkoxcT4ii3P7UyVec9IWPWeHqg.png) 

We are ready to debug. Now we need to get gdb setup and ready to go. On the emulator, GDB server is already present, and since it&#39;s x86_64, I can just use my normal GDB to connect to it, which is awesome.
If we just start the gdb server, and attach to it, we will not get any symbols as my computer doesn&#39;t know about my emulator&#39;s libraries, for this, we will have to pull them locally first. Let&#39;s create a new folder called fs, and pull some stuff in it.

    $ mkdir fs
    $ cd fs
    $ mkdir -p sysroot/system
    $ adb pull /system/lib sysroot/system/
    /system/lib/: 313 files pulled. 44.8 MB/s (140367100 bytes in 2.988s)
    $ adb pull /system/bin sysroot/system
    /system/bin/: 299 files pulled. 44.3 MB/s (79616683 bytes in 1.712s)
    $ chmod 755 sysroot/system/bin/*

And finally, let&#39;s add libHackEx.so in sysroot/system/lib folder

    $ cp ../libHackEx.so sysroot/system/lib/

Now, let&#39;s forward a port to our computer in order to connect gdb to the emulator&#39;s process

    $ adb forward tcp:12345 tcp:12345
    12345

Now let&#39;s start gdb locally. I use gdb [peda](https://github.com/longld/peda) for my reversing/exploit dev needs as it greatly increase the output of gdb, I suggest you do the same if you use stock gdb.

    $ gdb -q
    gdb-peda$

Now run the following commands to prepare gdb:

    gdb-peda$ set sysroot sysroot
    gdb-peda$ set solib-search-path sysroot/system/lib/
    gdb-peda$ handle SIG33 nostop noprint

You can add these commands in your ~/.gdbinit file so you don&#39;t have to retype them everytime you start gdb during this reversing study.

Finally:

    gdb-peda$ file sysroot/system/bin/app_process
    Reading symbols from sysroot/system/bin/app_process...
    Reading symbols from .gnu_debugdata for /home/void/articles/reversing_hackex/fs/sysroot/system/bin/app_process...
    (No debugging symbols found in .gnu_debugdata for /home/void/articles/reversing_hackex/fs/sysroot/system/bin/app_process)

Open a new terminal, make sure the apk is running on the emulator and use the following command to get it&#39;s pid

    $ adb shell ps |grep &quot;hackex&quot;
    u0_a87       10941  1492 1483224  81688 ep_poll    74cbba3792ba S com.byeline.hackex

Perfect, finally let&#39;s use gdbserver to attach to it:

    $ adb shell
    # gdbserver64 --attach :12345 10941
    Attached; pid = 10941
    Listening on port 12345

Locally, run this command in gdb:

    gdb-peda$ target remote :12345
    (Reading symbols...)

And we arrive at this screen:

![peda_output|463x500](upload://3iTHcqZLKBgJEblWBVromA4MOU7.jpeg) 

And now let&#39;s set a breakpoint at `Java_com_byeline_hackex_settings_SettingsManager_flux`

    gdb-peda$ b Java_com_byeline_hackex_settings_SettingsManager_flux
    Breakpoint 1 at 0x74cb9fb916e0
    gdb-peda$ c
    Continuing.

Now click the button and wabam! We break in the function! Now we could just step instruction by instruction and inspect the registers and the stack to understand the logic, but as we performed static analysis earlier, we can just break at some key point that we found interesting to gain some time and not go insane. For instance, we can break at the address `base + 0xeb90` which is the first instruction of our string creation loop we saw earlier. To get the base address of our library, we can use `vmmap` to get the list of mapped addresses:

    gdb-peda$ vmmap libHackEx.so
    0x000074cb9fb83000 0x000074cb9fbb9000 r-xp	/data/app/com.byeline.hackex-hii-krBwjRPa-wkgUi9Ldw==/lib/x86_64/libHackEx.so
    0x000074cb9fbba000 0x000074cb9fbbe000 r--p	/data/app/com.byeline.hackex-hii-krBwjRPa-wkgUi9Ldw==/lib/x86_64/libHackEx.so
    0x000074cb9fbbe000 0x000074cb9fbbf000 rw-p	/data/app/com.byeline.hackex-hii-krBwjRPa-wkgUi9Ldw==/lib/x86_64/libHackEx.so

Let&#39;s break at `0x000074cb9fb83000+0x3b90` and continue:
 
    gdb-peda$ b *0x000074cb9fb83000+0x3b90
    Breakpoint 2 at 0x74cb9fb86b90
    gdb-peda$ c

Ok, so we hit breakpoint 2, and we are where we want to be! Although we don&#39;t actually care about this loop right? We just want it&#39;s output. Let&#39;s put the breakpoint at `base+0xebca` instead, and continue the execution. We end up at the instruction `lea    rbx,[rsp+0x130]` so let&#39;s step one time and check the string at rbx:

    RBX: 0x7ffe3c8ebd30 (&quot;9gey50rOHWc0Upj2mH16Kd4OSxeGJOgdEpCjBI9G&quot;)

w00t! We have our final string! We can confirm that using the past 2 strings, if we xor `P` with `0x69`, we get char `9`. Yes!

Now let&#39;s carry on. There&#39;s still a lot of assembly code before the end of that function, and I don&#39;t want to step instruction by instruction until the end, so let&#39;s disassemble this function in gdb, and find a spot to break in.

    gdb-peda$ disas Java_com_byeline_hackex_settings_SettingsManager_flux

Remember all those sprintfs ? Since they are at the end of the function, we can assume their purpose is to create the final signature string, let&#39;s check what&#39;s the instruction before them to see if we could break somewhere and see what the sprintf are printing.

![task_hash|690x378](upload://aQ2Y9Bm2wDnYG4XMe6FetjVYQ9k.jpeg) 

Here we can see a function `taskClassifier_hash` being called, so the signature is a hash of something else? Let&#39;s verify that by runing hashid on a signature string:

    $ hashid
    6f632ea0f207f2426ea8cef93cd0e6ba76ed608e
    Analyzing &#39;6f632ea0f207f2426ea8cef93cd0e6ba76ed608e&#39;
    [+] SHA-1 
    [+] Double SHA-1 
    [+] RIPEMD-160 
    [+] Haval-160 
    [+] Tiger-160 
    [+] HAS-160 
    [+] LinkedIn 
    [+] Skein-256(160) 
    [+] Skein-512(160)

Of course it&#39;s a sha1 string! So the sprintf are just printing a sha1 hash, and the hash is probably made by this `taskClassifier_hash` function! Let&#39;s break on this call:

    gdb-peda$ b *0x000074cba190fe2c
    Breakpoint 2 at 0x74cba190fe2c
    gdb-peda$ c

And tadam!

    RDI: 0x74cba1658aa0 (&quot;sig21568473060002paramavaluea9gey50rOHWc0Upj2mH16Kd4OSxeGJOgdEpCjBI9G&quot;)

So, are we really hashing this string to get the signature? Let&#39;s continue, and grab the final signature from android-studio `logcat`

    e2727dd3c39aaf42a75f217c8b21975e72f58a7d&amp;sig2=1568473060002

now let&#39;s sha1 hash the above string manually:

    echo -n &quot;sig21568473060002paramavaluea9gey50rOHWc0Upj2mH16Kd4OSxeGJOgdEpCjBI9G&quot; | sha1sum 
    e2727dd3c39aaf42a75f217c8b21975e72f58a7d  -

W00t! We got the same hash!

So let&#39;s resume. The function takes the parameters from the hashmap, and construct such a string:

    sig2{timestamp}{paramkey}{paramvalue}9gey50rOHWc0Upj2mH16Kd4OSxeGJOgdEpCjBI9G

Then hash it using sha1, and return the hash.

Let&#39;s edit our `MainActivity.java` code, change the parameters, and click the button:

    HashMap&lt;String, String&gt; lol = new HashMap&lt;&gt;();
    lol.put(&quot;somethingsomething&quot;, &quot;chivatoiloveu&quot;);
    String ret = SettingsManager.flux(lol);
    Log.i(&quot;REVERSING&quot;, ret);

    btn.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view)
        {
            HashMap&lt;String, String&gt; lol = new HashMap&lt;&gt;();
            lol.put(&quot;somethingsomething&quot;, &quot;chivatoiloveu&quot;);
            String ret = SettingsManager.flux(lol);
            Log.i(&quot;REVERSING&quot;, ret);
        }
    });

The logcat output:

    I/REVERSING: e4247c3fd5804429ec6388aa748cb3e0cf668d1d&amp;sig2=1568474023095

So, the same way we did earlier, we can confirm if we sha1sum the following string:

    sig21568474023095somethingsomethingchivatoiloveu9gey50rOHWc0Upj2mH16Kd4OSxeGJOgdEpCjBI9G

    $ echo -ne &quot;sig21568474023095somethingsomethingchivatoiloveu9gey50rOHWc0Upj2mH16Kd4OSxeGJOgdEpCjBI9G&quot; |sha1sum 
    4d2fddb7dad43719bff07aa002eaf2272eb6db92  -

Huh, wasn&#39;t that too easy? Let&#39;s fire up gdb and see the hashed string again

    0x74cba166a380 (&quot;somethingsomethingchivatoiloveusig215684743411239gey50rOHWc0Upj2mH16Kd4OSxeGJOgdEpCjBI9G&quot;)

so now , the params are at the beginning of the string? would it be related to the params length? 

After many tests,  it seems that if the first char of the parameter is between s and z, and if the length of the parameter is above 2, then the param/value pair is put at the begining of the string, and if it isn&#39;t, then it is put after the timestamp.

So to get the above sha1, we need to hash the following string instead:

    somethingsomethingchivatoiloveusig215684740230959gey50rOHWc0Upj2mH16Kd4OSxeGJOgdEpCjBI9G

Which give the following hash:

    e4247c3fd5804429ec6388aa748cb3e0cf668d1d

Yay!

Now let&#39;s see what happens when we add multiple parameters. Let&#39;s edit our hashmap and add some more params:

    HashMap&lt;String, String&gt; lol = new HashMap&lt;&gt;();
    lol.put(&quot;somethingsomethingg&quot;, &quot;chivatoiloveu&quot;);
    lol.put(&quot;somethingelse&quot;, &quot;ilovemealso&quot;);
    String ret = SettingsManager.flux(lol);
    Log.i(&quot;REVERSING&quot;, ret);

We get:

    somethingsomethinggchivatoiloveusomethingelseilovemealsosig215684770776879gey50rOHWc0Upj2mH16Kd4OSxeGJOgdEpCjBI9G

If the first letter of the first param is before `s` then we get:

    somethingelseilovemealsosig21568477173996aomethingsomethinggchivatoiloveu9gey50rOHWc0Upj2mH16Kd4OSxeGJOgdEpCjBI9G

Nice, we are ready to write our script to bot the s\*\*t out of this game. We will try to list all users using the `user_victim` api endpoint. It requires only one parameter, `victim_user_id`. My python script therefore is the following:

```python
#!/usr/bin/env python3

import time
import requests
from datetime import datetime
from hashlib import sha1

APIKEY=&quot;0A8E520C-0F8A-9F36-8E89-F86E61A45BB1&quot;
url = &quot;https://api.hackex.net/v8/&quot;

def signature(params):
    before_sig2_params = []; after_sig2_params = []

    for p in params:
        k,v=p
        if len(k) &gt;= 2 or k[0] in &#39;stuvwxyz&#39;:
            before_sig2_params += [p]
        else:
            after_sig2_params += [p]
    ts = str(int(datetime.now().timestamp()*1000))

    raw = &quot;&quot;
    for p in before_sig2_params:
        k,v=p
        raw += f&quot;{k}{v}&quot;
    raw += f&quot;sig2{ts}&quot;
    for p in after_sig2_params:
        k,v=p
        raw += f&quot;{k}{v}&quot;

    raw += f&quot;9gey50rOHWc0Upj2mH16Kd4OSxeGJOgdEpCjBI9G&quot;

    return sha1(raw.encode(&#39;utf-8&#39;)).hexdigest() + f&quot;&amp;sig2={ts}&quot;

def main():

    s = requests.Session()
    s.headers.update({&quot;X-API-KEY&quot;: APIKEY})

    i = 7534914
    while True:
        i-=1
        uid = str(i)
        params = [(&quot;victim_user_id&quot;, uid)]
        req=url +f&quot;user_victim?victim_user_id={uid}&amp;sig=&quot;+signature(params)
        try:
            _r = s.get(req)
            r = _r.json()
        except AttributeError:
            print(req)
            exit()
        print(f&quot;id: {uid} | name: {r[&#39;user&#39;][&#39;username&#39;]} | ip: {r[&#39;user&#39;][&#39;ip&#39;]} | money: ${r[&#39;user_bank&#39;][&#39;checking&#39;]}&quot;)
        for so in r[&#39;user_software&#39;]:
            print(f&quot;{so[&#39;name&#39;]} -&gt; {so[&#39;software_level&#39;]} |&quot;, end=&quot;&quot;)
        print()

if __name__==&#39;__main__&#39;:
    main()
```

    $ python pwn.py 
    id: 7534913 | name: R Pay Too | ip: 15.251.62.189 | money: $0
    Spyware -&gt; 1 |Firewall -&gt; 1 |Bypasser -&gt; 2 |Password Encryptor -&gt; 1 |
    id: 7534912 | name: satheesan 8 | ip: 2.199.98.145 | money: $0
    Firewall -&gt; 1 |Bypasser -&gt; 1 |Password Encryptor -&gt; 1 |
    id: 7534911 | name: _FatalError_ | ip: 17.107.179.41 | money: $0
    Firewall -&gt; 2 |Bypasser -&gt; 1 |Password Cracker -&gt; 10 |Password Encryptor -&gt; 1 |
    id: 7534910 | name: janari janari | ip: 234.10.89.19 | money: $0
    Spyware -&gt; 1 |Firewall -&gt; 1 |Bypasser -&gt; 2 |Password Encryptor -&gt; 1 |
    id: 7534909 | name: 47heck | ip: 12.240.217.17 | money: $0
    Antivirus -&gt; 1 |Spyware -&gt; 2 |Firewall -&gt; 1 |Bypasser -&gt; 5 |Password Cracker -&gt; 1 |Password Encryptor -&gt; 1 |
    id: 7534908 | name: narashima | ip: 42.230.184.13 | money: $0
    Firewall -&gt; 1 |Bypasser -&gt; 1 |Password Encryptor -&gt; 1 |


# Conculsion
I hope the little reversing entertained you well. The developers of this game had issues with cheaters for years now, and they keep obfuscating this signature algorithm more and more, but obscurity != security. As long as they don&#39;t change their design, people will be able to cheat in this game.</description>
    
    <lastBuildDate>Fri, 20 Dec 2019 18:42:18 +0000</lastBuildDate>
    <category>Reverse Engineering</category>
    <atom:link href="https://0x00sec.org/t/reversing-hackex-an-android-game/16243.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Reversing HackEx - An android game</title>
        <dc:creator><![CDATA[system]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 121 days. New replies are no longer allowed.</p>
          <p><a href="https://0x00sec.org/t/reversing-hackex-an-android-game/16243/19">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/reversing-hackex-an-android-game/16243/19</link>
        <pubDate>Tue, 14 Jan 2020 09:25:16 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-16243-19</guid>
        <source url="https://0x00sec.org/t/reversing-hackex-an-android-game/16243.rss">Reversing HackEx - An android game</source>
      </item>
      <item>
        <title>Reversing HackEx - An android game</title>
        <dc:creator><![CDATA[Silver_Exploit]]></dc:creator>
        <description><![CDATA[
            <p>I had a problem while installing apk, if someone have this same problem this worked for me:<br>
<code>adb shell</code><br>
<code>mount -o rw,remount rootfs /</code></p>
          <p><a href="https://0x00sec.org/t/reversing-hackex-an-android-game/16243/18">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/reversing-hackex-an-android-game/16243/18</link>
        <pubDate>Fri, 20 Dec 2019 18:42:18 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-16243-18</guid>
        <source url="https://0x00sec.org/t/reversing-hackex-an-android-game/16243.rss">Reversing HackEx - An android game</source>
      </item>
      <item>
        <title>Reversing HackEx - An android game</title>
        <dc:creator><![CDATA[Silver_Exploit]]></dc:creator>
        <description><![CDATA[
            <p>My god what a nice post, I will take a look later for sure</p>
          <p><a href="https://0x00sec.org/t/reversing-hackex-an-android-game/16243/17">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/reversing-hackex-an-android-game/16243/17</link>
        <pubDate>Wed, 18 Dec 2019 08:35:55 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-16243-17</guid>
        <source url="https://0x00sec.org/t/reversing-hackex-an-android-game/16243.rss">Reversing HackEx - An android game</source>
      </item>
      <item>
        <title>Reversing HackEx - An android game</title>
        <dc:creator><![CDATA[Archangel9]]></dc:creator>
        <description><![CDATA[
            <p>I read his comment. Just trying to put this convo onto a new path and to see what <a class="mention" href="https://0x00sec.org/u/r3llun">@r3llun</a> opinion was. That is why I said “On a side tangent”. I probably should have added “unrelated to your response” to clarify.</p>
          <p><a href="https://0x00sec.org/t/reversing-hackex-an-android-game/16243/15">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/reversing-hackex-an-android-game/16243/15</link>
        <pubDate>Sun, 29 Sep 2019 05:11:29 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-16243-15</guid>
        <source url="https://0x00sec.org/t/reversing-hackex-an-android-game/16243.rss">Reversing HackEx - An android game</source>
      </item>
      <item>
        <title>Reversing HackEx - An android game</title>
        <dc:creator><![CDATA[r3llun]]></dc:creator>
        <description><![CDATA[
            <p>Not sure if this is related to my answer. However, I wouldn’t either want to work for a company that checks if your phone is rooted before hiring you and I won’t answer your question to discourage anyone for working for them. Hope it makes sense.</p>
          <p><a href="https://0x00sec.org/t/reversing-hackex-an-android-game/16243/14">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/reversing-hackex-an-android-game/16243/14</link>
        <pubDate>Wed, 25 Sep 2019 11:42:24 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-16243-14</guid>
        <source url="https://0x00sec.org/t/reversing-hackex-an-android-game/16243.rss">Reversing HackEx - An android game</source>
      </item>
      <item>
        <title>Reversing HackEx - An android game</title>
        <dc:creator><![CDATA[pry0cc]]></dc:creator>
        <description><![CDATA[
            <p>I’m not sure you read his comment.</p>
          <p><a href="https://0x00sec.org/t/reversing-hackex-an-android-game/16243/13">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/reversing-hackex-an-android-game/16243/13</link>
        <pubDate>Wed, 25 Sep 2019 09:50:19 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-16243-13</guid>
        <source url="https://0x00sec.org/t/reversing-hackex-an-android-game/16243.rss">Reversing HackEx - An android game</source>
      </item>
      <item>
        <title>Reversing HackEx - An android game</title>
        <dc:creator><![CDATA[Archangel9]]></dc:creator>
        <description><![CDATA[
            <p>On a side tangent, some companies and high end businesses, nowadays, actually restrict rooted phones and will not hire you, if you do have one. There is a specific security test that checks to see if the phone is rooted. I have even tested it on some of my own devices - it has not failed in showing which devices are rooted and which are not. How do you plan to get around that with a rooted phone?</p>
<p>-Archangel</p>
          <p><a href="https://0x00sec.org/t/reversing-hackex-an-android-game/16243/12">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/reversing-hackex-an-android-game/16243/12</link>
        <pubDate>Mon, 23 Sep 2019 04:18:49 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-16243-12</guid>
        <source url="https://0x00sec.org/t/reversing-hackex-an-android-game/16243.rss">Reversing HackEx - An android game</source>
      </item>
      <item>
        <title>Reversing HackEx - An android game</title>
        <dc:creator><![CDATA[DeepForest]]></dc:creator>
        <description><![CDATA[
            <p>Great work, big lesson for me.</p>
          <p><a href="https://0x00sec.org/t/reversing-hackex-an-android-game/16243/11">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/reversing-hackex-an-android-game/16243/11</link>
        <pubDate>Thu, 19 Sep 2019 21:44:02 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-16243-11</guid>
        <source url="https://0x00sec.org/t/reversing-hackex-an-android-game/16243.rss">Reversing HackEx - An android game</source>
      </item>
      <item>
        <title>Reversing HackEx - An android game</title>
        <dc:creator><![CDATA[badcor]]></dc:creator>
        <description><![CDATA[
            <p>Thank you for this amazing write-up. I enjoyed it !</p>
          <p><a href="https://0x00sec.org/t/reversing-hackex-an-android-game/16243/10">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/reversing-hackex-an-android-game/16243/10</link>
        <pubDate>Wed, 18 Sep 2019 17:09:01 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-16243-10</guid>
        <source url="https://0x00sec.org/t/reversing-hackex-an-android-game/16243.rss">Reversing HackEx - An android game</source>
      </item>
      <item>
        <title>Reversing HackEx - An android game</title>
        <dc:creator><![CDATA[r3llun]]></dc:creator>
        <description><![CDATA[
            <p>I usually read the articles without signing in. I just signed in to like this quality article <img src="https://0x00sec.org/images/emoji/twitter/stuck_out_tongue.png?v=9" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:"> . Just a quick note for anyone that doesn’t have rooted phone you can use this <a href="https://github.com/yeriomin/YalpStore" rel="nofollow noopener">app</a> to download the plain official apk. (It is unmaintained but it still works however)</p>
          <p><a href="https://0x00sec.org/t/reversing-hackex-an-android-game/16243/9">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/reversing-hackex-an-android-game/16243/9</link>
        <pubDate>Wed, 18 Sep 2019 15:10:27 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-16243-9</guid>
        <source url="https://0x00sec.org/t/reversing-hackex-an-android-game/16243.rss">Reversing HackEx - An android game</source>
      </item>
      <item>
        <title>Reversing HackEx - An android game</title>
        <dc:creator><![CDATA[vlo]]></dc:creator>
        <description><![CDATA[
            <p>Great post. Lot of useful information.</p>
<p>Thanks!</p>
          <p><a href="https://0x00sec.org/t/reversing-hackex-an-android-game/16243/7">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/reversing-hackex-an-android-game/16243/7</link>
        <pubDate>Sun, 15 Sep 2019 21:39:08 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-16243-7</guid>
        <source url="https://0x00sec.org/t/reversing-hackex-an-android-game/16243.rss">Reversing HackEx - An android game</source>
      </item>
      <item>
        <title>Reversing HackEx - An android game</title>
        <dc:creator><![CDATA[pr0j3ctr00t]]></dc:creator>
        <description><![CDATA[
            <p>damn… awesome write up… thanks for sharing it… we should keep doing this…</p>
          <p><a href="https://0x00sec.org/t/reversing-hackex-an-android-game/16243/6">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/reversing-hackex-an-android-game/16243/6</link>
        <pubDate>Sun, 15 Sep 2019 12:08:05 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-16243-6</guid>
        <source url="https://0x00sec.org/t/reversing-hackex-an-android-game/16243.rss">Reversing HackEx - An android game</source>
      </item>
      <item>
        <title>Reversing HackEx - An android game</title>
        <dc:creator><![CDATA[1gn0r4nd]]></dc:creator>
        <description><![CDATA[
            <p>Great writeup.<br>
A friend tried a similar thing with a .net/nodejs app.<br>
Decompiles just as easily. The goal there was to figure out how it licensed the software. Allowing the software to work without a license it is easy enough, but the license generation is more interesting. You confirmed that one needs to just make another C# app with the functions copied and then printout the intermediate results.</p>
          <p><a href="https://0x00sec.org/t/reversing-hackex-an-android-game/16243/5">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/reversing-hackex-an-android-game/16243/5</link>
        <pubDate>Sun, 15 Sep 2019 10:32:09 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-16243-5</guid>
        <source url="https://0x00sec.org/t/reversing-hackex-an-android-game/16243.rss">Reversing HackEx - An android game</source>
      </item>
      <item>
        <title>Reversing HackEx - An android game</title>
        <dc:creator><![CDATA[aazimcr]]></dc:creator>
        <description><![CDATA[
            <p>This is insanely well written!<br>
Beautifully organized content and flow, good one <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
          <p><a href="https://0x00sec.org/t/reversing-hackex-an-android-game/16243/4">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/reversing-hackex-an-android-game/16243/4</link>
        <pubDate>Sun, 15 Sep 2019 08:46:56 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-16243-4</guid>
        <source url="https://0x00sec.org/t/reversing-hackex-an-android-game/16243.rss">Reversing HackEx - An android game</source>
      </item>
      <item>
        <title>Reversing HackEx - An android game</title>
        <dc:creator><![CDATA[sp0re]]></dc:creator>
        <description><![CDATA[
            <p>Thank you!</p>
<p>I assume the developers though it is so hidden deep inside the guts or the application, nobody would try to get it, but they forgot some people find it fun to reverse such things <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
          <p><a href="https://0x00sec.org/t/reversing-hackex-an-android-game/16243/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/reversing-hackex-an-android-game/16243/3</link>
        <pubDate>Sat, 14 Sep 2019 17:40:56 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-16243-3</guid>
        <source url="https://0x00sec.org/t/reversing-hackex-an-android-game/16243.rss">Reversing HackEx - An android game</source>
      </item>
      <item>
        <title>Reversing HackEx - An android game</title>
        <dc:creator><![CDATA[pry0cc]]></dc:creator>
        <description><![CDATA[
            <p>Damn this is insane!</p>
<p>Really tells the tail of not hardcoding signature strings and relying on something (abeit hard to find!) stored on the client side.</p>
<p>Awesome writeup mate!!! So glad to have you on 0x00sec and thanks for sharing your knowledge to the community! I’m sure everybody here will find this writeup enlightening <img src="https://0x00sec.org/images/emoji/twitter/facepunch/3.png?v=9" title=":facepunch:t3:" class="emoji" alt=":facepunch:t3:"></p>
          <p><a href="https://0x00sec.org/t/reversing-hackex-an-android-game/16243/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/reversing-hackex-an-android-game/16243/2</link>
        <pubDate>Sat, 14 Sep 2019 17:37:36 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-16243-2</guid>
        <source url="https://0x00sec.org/t/reversing-hackex-an-android-game/16243.rss">Reversing HackEx - An android game</source>
      </item>
      <item>
        <title>Reversing HackEx - An android game</title>
        <dc:creator><![CDATA[sp0re]]></dc:creator>
        <description><![CDATA[
            <p>Hello peeps. I’m sp0re. This is my first post on 0x00sec, you can find more about me on <a href="https://sp0re.sh" rel="noopener nofollow ugc">my website</a>.  Today we are going to reverse engineer the network protocol of an android game so that we can automate the game, and earn unlimited money while drinking sodas and eating doritos. When looking online, they’ve had issue with cheaters for years now. But is it really that easy to cheat in this game? Let’s find out.</p>
<p>The game in question is <a href="https://play.google.com/store/apps/details?id=com.byeline.hackex&amp;hl=en" rel="noopener nofollow ugc">HackEx</a> It’s an online “hacking” simulator game for mobile. The goal is quite simple, you “hack” into other players in order to steal their money, drop some spam viruses or spyware, so you are able to upgrade your software by buying better versions or stealing better versions from others.</p>
<h1>Environment Setup</h1>
<p>Before tinkering, we need to set our environment up and running. For android reversing, I usually use <a href="https://developer.android.com/studio" rel="noopener nofollow ugc">android studio</a> as well as an x86_64 android emulator. x86_64 mainly because I’m more comfortable reading it over ARM.</p>
<p>First, open android studio and create a random project.</p>
<p>Once done, click on <strong>tools&gt;AVD Manager</strong> and spin up a new emulator. When it asks you to select a system image, click on <strong>x86 Images</strong> and take one with (Google APIs). For some reasons, it will allow you to have a rooted emulator.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/5/57c4dba77ec85eeae6d934857c1d1f6a540a850d.png" alt="2019-09-13-124655_1027x672_scrot" data-base62-sha1="cwriZqd57kvhnUBBhzKu3gvdrKR" width="690" height="451"></p>
<p>I will take Oreo (Api level 26) because why not.</p>
<p>Once configured, you need to start it using <code>emulator</code> in order to get a writable system endpoint. it will be useful later.</p>
<pre><code>$ ~/Android/Sdk/emulator/emulator -list-avds
Pixel_2_API_26
$ ~/Android/Sdk/emulator/emulator -writable-system -avd Pixel_2_API_26
</code></pre>
<p>Now we also need <a href="https://wiki.archlinux.org/index.php/Android_Debug_Bridge" rel="noopener nofollow ugc">Android Debug Bridge</a> in order to communicate easily with our emulator. On arch linux, you can pull the binary using the following command:</p>
<pre><code>pacman -S android-tools
</code></pre>
<p>Once ADB is installed, and your emulator is running, you can check that everything is setup correctly by running</p>
<pre><code>adb devices
</code></pre>
<p>If you get an output, you are good to go! But, just to be proactive, we will restart adbd on the emulator as root, by using the following command:</p>
<pre><code>adb root
</code></pre>
<h1>Application Discovery</h1>
<p>Before starting the leet stuff, let’s have a first glance of the game. I downloaded the apk from the google store on my phone, then pulled the apk on my computer.</p>
<p>From there, once your emulator is running, you need to run the following command to install the APK on it:</p>
<pre><code>adb install /path/to/app.apk
</code></pre>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/d/db07fbf641404540e8fae3af57425965725c58fe.gif" alt="apk_install" data-base62-sha1="vfDFFLbN0GhBYuOwbd51HOHSD5I" width="600" height="500"></p>
<p>Nice! The apk is installed, now we can just open it and play with it.</p>
<p>So the game is pretty simple, you scan for victims, then “hack” them, and it will show you a progress bar in the processes window. Once complete, you can connect to their system. Once connected, you can download their stuff, upload some of your stuff, or attempt to crack their bank password. each of these actions take time and are represented as progress bars in the process window.</p>
<p>Now since this game is multiplayer. It is safe to assume that all these actions are sent to the server for synchronizing with all the player. Say if someone “hacks” my system, and flushes my bank account, I have to see it. So let’s try to determine how the application is communicating with the server.</p>
<h1>Network Analysis</h1>
<h2>Network discovery</h2>
<p>In order to intercept the communication between the app and it’s server, we will push <code>tcpdump</code> to the emulator. I suggest taking it from this <a href="https://github.com/yunchih/static-binaries" rel="noopener nofollow ugc">Static-binaries</a> repo found on github.</p>
<pre><code>$ adb push tcpdump /data/local/tmp/
tcpdump: 1 file pushed. 66.0 MB/s (2377024 bytes in 0.034s)
$ adb shell
# cd /data/local/tmp &amp;&amp; chmod 700 tcpdump
# ./tcpdump -i any -s0 -n -w /sdcard/out.pcap
</code></pre>
<p>Now all we have to do it playing a bit the game, and then exit tcpdump. It will create a pcap located at /sdcard.</p>
<p>Now we extract the pcap:</p>
<pre><code>$ adb pull /sdcard/out.pcap . 
</code></pre>
<p>And open it with wireshark:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/9/91b7698697fca39d941c1c132d8fc62e30c25cab.gif" alt="open_pcap_wiresark" data-base62-sha1="kN4bUhV1NcLPp4PrzioYJk5c8ob" width="690" height="371"></p>
<p>There’s a lot of packets from this dump. The first goal here is to identify the server’s IP in order to filter the traffic. In order to do that, I assumed that some of the packet would contain “hackex” as this is the name of the application. Let’s checkk that with strings:</p>
<pre><code>$ strings -n 6 out.pcap | grep -i "hackex"
 hackex
hackex
hackex
hackex
api.hackex.net
*.hackex.net
[...]
</code></pre>
<p>This seems like the DNS entries of a cert file. Good thing is that we have an api endpoint to poke at, and the protocol is HTTP. The bad thing is that the traffic is probably encrypted using SSL.</p>
<p>to verify that, in wireshark, we can click on <strong>edit &gt; Find Packet…</strong> and search for the string <strong><a href="http://api.hackex.net" rel="noopener nofollow ugc">api.hackex.net</a></strong></p>
<p>it returns a Client Hello packet from TLS1.2. It’s not as easy as we thought!</p>
<h2>Network decryption</h2>
<p>We therefore need a way to decrypt SSL traffic, in order to get  the http content.<br>
For that, the best way it to proxy all the traffic to burp, and install burp’s certificate to the emulator.</p>
<p>Unfortunately, since a recent version of Android, user certificates are not used by applications without consent. There’s 2 workarounds for that:</p>
<ul>
<li>We install the certificate as a system certificate, but we need root</li>
<li>We patch the apk to use our user certificate.</li>
</ul>
<p>Obviously, as we are root, we are going to set burp certificate as a system cert!</p>
<p>Fire up burp, go to <strong>proxy</strong> tab, then the <strong>Options</strong> subtab and add a new listener. It needs to listener on all interface, using a different port than the default one</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/f/f6148f4f992c9140b66b1b69764133d20d5e4806.gif" alt="burp_setup" data-base62-sha1="z6VvqAqJdOYpzGGmqxHOG6baMtw" width="690" height="370"></p>
<p>Now export the certificate on your computer. In order for the emulator to accept it, you need to transform the der file to pem, and rename it using <code>subject_hash_old</code>:</p>
<pre><code>openssl x509 -inform DER -in cacert.der -out cacert.pem  
openssl x509 -inform PEM -subject_hash_old -in cacert.pem |head -1  
mv cacert.pem &lt;hash&gt;.0  
</code></pre>
<p>my cert is <code>9a5ba575.0</code>. so I use this command to push the cert to the emulator:</p>
<pre><code>$ adb push 9a5ba575.0 /sdcard
</code></pre>
<p>now we need to add the certificate to the /system/etc/security/cacerts/ location. to do that, we need to remount the partition as <code>rw</code> . To do that, connect to the emulator shell and run the following command:</p>
<pre><code>$ adb shell
# mount -o rw,remount /system
</code></pre>
<p>Once done, move the file to the above path:</p>
<pre><code># mv /sdcard/9a5ba575.0 /system/etc/security/cacerts/
# chmod 644 /system/etc/security/cacerts/9a5ba575.0
</code></pre>
<p>And finally, reboot the emulator using <code>adb reboot</code>.</p>
<p>Now if you go to Settings, browse to <strong>Security &amp; location &gt; Encryption &amp; credentials &gt; Trusted credentials</strong> you should see PortSwigger CA.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/5/57486dd86506434a2a619e8b411e2590c594d8ca.jpeg" alt="cacert_installed" data-base62-sha1="cs8Iy0phfiMibkgE73NljE3N8Iq" width="289" height="500"></p>
<p>Success! We can now get the traffic using burp! But to do that, we need to proxy the traffic to our burp. For this, you will need to restart the emulator with the following command:</p>
<pre><code>$ ~/Android/Sdk/emulator/emulator -writable-system -avd Pixel_2_API_26 -http-proxy 127.0.0.1:8080
</code></pre>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/2/232e067f76fd75aad384534b07b11adf35e2f66e.png" alt="ssl_decrypted" data-base62-sha1="51djRAAtsTdDA6SjGy6Qwi9bkK2" width="690" height="374"></p>
<p>Boom! SSL Decryption!</p>
<p>Now let’s start the game again, and play a bit, we should see some communication.</p>
<p>I can quicky see a lot of traffic, but each request is made with 2 parameters, <code>sig</code> and <code>sig2</code><br>
It seems that the application is signing each request before sending them. So the server is sure that the request is coming from the application, and not from other means. We can verify that by editing a request in burp repeater:</p>
<p>Legit request:<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/0/094e3452a992db65a91b1b9eb92240798c607ea2.png" alt="legit_req" data-base62-sha1="1kjQEW24IZkBnHFavfWIuLm1MEW" width="690" height="441"></p>
<p>Wrong request:<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/7/7f9bc933f5628ec520f73dfa1ee3eeb5f0db4d9f.png" alt="wrong_req" data-base62-sha1="icSpkFFXm2KzWzpo1NX07BQhxGn" width="690" height="440"></p>
<p><strong>YES, THE SERVER IS DUMB</strong></p>
<p>So if we want to be able to use the api without the game, we need the logic to construct the <code>sig</code> parameters.</p>
<h1>Reversing Time</h1>
<h2>Static analysis</h2>
<p>We will decompile the APK using <code>jadx</code>. This will let us see the sources and the assets of the app.</p>
<pre><code>$ mkdir jadx_out
$ jadx -d jadx_out apkdir/base.apk
</code></pre>
<p>Once finished, in the <code>jadx_out</code> folder, you’ll find the sources and the resources. Go to the sources, and grep for “<a href="http://api.hackex.net" rel="noopener nofollow ugc">api.hackex.net</a>”:</p>
<pre><code>$ grep -r "api.hackex.net" .
com/byeline/hackex/k/e.java:    public static String f1971a = "https://api.hackex.net/v8/";
com/byeline/hackex/k/e.java:        f1971a = "https://api.hackex.net/v8/";
com/byeline/hackex/d/a.java:        return (c) new retrofit2.m.a().a("https://api.hackex.net/v8/").a(aVar.a(Collections.singletonList(y.HTTP_1_1)).a()).a((retrofit2.e.a) retrofit2.a.a.a.a(configure)).a((retrofit2.c.a) g.a()).a().a(c.class);
</code></pre>
<p>In the file <code>com/byeline/hackex/k/e.java</code>, the api url is defined, we can go and analyse this file to see what we do with the string.</p>
<p>We can see many methods that apparently handle the rest communication. For instance, we can see in the following method that the server is handling the <code>user_bank</code> endpoint, probably when the user checks his bank account in the game:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/7/72ea25c7bed3f680b79783831e08a53603014ce2.jpeg" alt="user_bank" data-base62-sha1="goA5BU4FplbYVr9aTwCYSmCaX0C" width="651" height="500"></p>
<p>We can also see the code that creates the <code>sig</code> parameter. Though we see that it doesn’t create the <code>sig2</code> parameter anywhere.</p>
<p>For the <code>sig</code> param, we create an empty hashMap, and give it to <code>SettingsManager.flux()</code>. I suspect the hash_map contains the request parameters if there are any. Let’s check another function:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/a/af2c31e70890f185106da559f3e2b7a258c971dd.png" alt="victim_user_bank" data-base62-sha1="oZEf9YZBjhoCDe1ydrlLauuWbP7" width="559" height="500"></p>
<p>This is indeed the case. We can see above that we give the hashmap the values <code>victim_user_id</code> as well as <code>String.valueOf(i2)</code>.</p>
<p>This make me believe that <code>SettingsManager.flux()</code> handles the signature generation. Let’s find it using grep.</p>
<pre><code>$ grep -r "flux" .
./com/byeline/hackex/settings/SettingsManager.java:    public static native String flux(Map&lt;String, String&gt; map);
./com/byeline/hackex/settings/SettingsManager.java:        sb.append(flux(c(str)));
</code></pre>
<p>Checking this file, we see that flux is a native function. This doesn’t sound good! Does it? It means the function is probably coming from a compiled library. We can confirm it by cating the file and see the following code:</p>
<pre><code>static {
    System.loadLibrary("HackEx");
}
</code></pre>
<p>Therefore, the code for generating the signature is stored in a lib named libHackEx.so.</p>
<pre><code># find / -name "*libHackEx.so*" 2&gt;/dev/null                                                                                                                         
/data/app/com.byeline.hackex-E-Wrx3wEw35mpVavUJ0_RA==/lib/x86_64/libHackEx.so
</code></pre>
<p>thankfuly it’s in x86_64. We can pull it and analyse it.</p>
<pre><code># cd /data/app/com.byeline.hackex-E-Wrx3wEw35mpVavUJ0_RA==/lib/x86_64/
# file libHackEx.so
libHackEx.so: ELF shared object, 64-bit LSB x86-64, for Android 21, built by NDK r18 (5002713), BuildID=b70b329b6121afd5ba59f2c716a8a56bef9fb294, stripped
$ adb pull /data/app/com.byeline.hackex-E-Wrx3wEw35mpVavUJ0_RA==/lib/x86_64/libHackEx.so .
</code></pre>
<p>Now we have the library locally which is good news. The library is a native library for android, which means it follows the Java Native Interface convention (JNI). We won’t talk much about JNI itself here because there’s too much to be said about it, and it’s not the point of this article. Key things to know are:</p>
<ul>
<li>The exported function have the following name: Java_(packageName)<em>(className)</em>(functionName)</li>
<li>There’s a lot of code handling interfact between JAVA and library code. For instance, if we feed a HashMap to a native library, obviously the library won’t know how to handle that, so the JNI will translate it transparently.</li>
</ul>
<p>That being said, we are looking for a function called Java_com_byeline_hackex_settings_SettingsManager_flux. So let’s open the file in <code>radare2</code></p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/e/e64cc534b414ffc7486e10d217d9729d10418e75.png" alt="r2_open" data-base62-sha1="wRkit58Y0Elps7AXrxiSU1o1gZn" width="690" height="234"></p>
<p>Now we type <code>afl</code> to list all functions. Since the binary is stripped, we won’t get a lot of function names, but the interesting one should still be shown as it has to be named to be exprted.</p>
<pre><code>[0x0000e680]&gt; afl
(...)
0x0000e6e0   68 2870 -&gt; 2822 sym.Java_com_byeline_hackex_settings_SettingsManager_flux
(...)
</code></pre>
<p>Nice, let’s check it’s content using <code>pdf @sym.Java_com_byeline_hackex_settings_SettingsManager_flux</code></p>
<pre><code>[0x0000e680]&gt; pdf @sym.Java_com_byeline_hackex_settings_SettingsManager_flux
</code></pre>
<p>The output is 736 line of assembly code, a nightmare to reverse statically! But still, we can see some interesting stuff in it:</p>
<pre><code>0x0000e70f      e8acf8ffff     call sym.imp.clock_gettime
</code></pre>
<p>So it gets a timestamp. That’s probably for the <code>sig2=</code> part as we saw earlier that it has the format of a timestamp in milisecond.</p>
<pre><code>0x0000e7db      488d358ffd01.  lea rsi, [0x0002e571]       ; "sig2"
</code></pre>
<p>The “sig2” string is hardcoded in, which confort the idea of this being the function we are looking for.</p>
<pre><code>0x0000eb3b      660f2805cd05.  movapd xmm0, xmmword [str.69540016560011007D2D2B63370A30573E3A607A730207381E3F070E38150414001B060273067F31] ; [0x2f110:16]=-1 ; "69540016560011007D2D2B63370A30573E3A607A730207381E3F070E38150414001B060273067F31"
0x0000eb82      4c8d25470502.  lea r12, str.P3eoc0cO5zHSbzZeSrQL8f3wMGbIrZcpEkEh1OFv ; 0x2f0d0 ; "P3eoc0cO5zHSbzZeSrQL8f3wMGbIrZcpEkEh1OFv"
</code></pre>
<p>Those are 2 interesting strings. It is probably used to create the actual signature at the end. Also, the first string has a length of 80, and it’s composed of hex, the second string has a length of 40. I think there’s a high chance that for each char of the second string, we take 2 chars of the first one, get the hex value of it and do something that will result in a new string of length 40. The following block confirms my assumption:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/7/7d402fab7183b6006362b5d7a12680900ace7ea7.jpeg" alt="xor_block" data-base62-sha1="hS1cwYmCDvyEZP749WvVJq97MW3" width="690" height="154"></p>
<p>First we load in rdi (the address of rsp+rbx+0x160). then, we load a string in rsi, another one in rdx, and perform a scanf. We then xor a byte coming from rbp+r12 and mov it to rsp+rbx+0x130. We increment some counters, compare that one of the counter is equals to 0x50 (80) and jump back to the begining is it’s below this value.</p>
<p>So as we increment rbx by 2 at each loop, I assume that the first string above is located at rsp+rbx+0x160, and the second string is located at rbp+r12. The resulting string is therefore probably in rsp+rbp+0x130.</p>
<p>Let’s continue.</p>
<p>After this block, I do not spot a lot of easily decodable logic. Nonetheless, there’s still some interesting stuff.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/a/aea3628c3ee3ab4be83fb982903b521e539949fa.png" alt="sprintfs" data-base62-sha1="oUV85EQWfRFXJSHxGqrdEZJIGZY" width="690" height="349"></p>
<p>We can see a sequence of sprintfs. 20 to be exact. this makes a string of exactly 40 chars.</p>
<p>Finally, we can see the following interesting lines:</p>
<pre><code>0x0000f0d3      488d3509f501.  lea rsi, [0x0002e5e3]       ; "sig"
0x0000f11f      488d35c1f401.  lea rsi, str.sig2           ; 0x2e5e7 ; "&amp;sig2="
</code></pre>
<p>So at this point we construct the signature to be returned to the java class.</p>
<p>From here, we have greatly increased our knowledge of this function already. We can assume that from the 2 strange strings, we create a new one after a loop of xoring, and then we use it to sprintf something which is used to construct our final return string. But still, we now know where the parameters from the hashmap are coming from, and also that the timestamp is somehow involved. I think it’s time to move to dynamic analysis.</p>
<h2>Dynamic Analysis</h2>
<p>There’s a lot of way to perform dynamic analysis. But for a native function like that, nothing beat GDB!</p>
<p>Let’s setup gdb in our emulator to analyze this function at runtime. But before that, I’d like an easier setup than analyzing the actual function using the game apk. Let’s create a simple apk and link our library to it, so we can debug it more easily.</p>
<p>Fire up android studio, create a new projet with an empty activity. Then it is important to use the same package name as the game. So we will use <strong>com.byeline.hackex</strong></p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/7/73cfaab3400e04c723089b2c5615ed0f00e39e2c.png" alt="new_as_proj" data-base62-sha1="gwvPEGdAlyUasIkX40ktuUgvOi0" width="645" height="500"></p>
<p>Now for the sake of easyness, let’s add a button, and we’ll trigger the <code>flux</code> function each time we click on it. in <code>activity_main.xml</code>, add a button, and change its id to <code>btnFlux</code>. Now in <code>MainActivity.java</code> file, edit the <code>onCreate</code> method and add the following code:</p>
<pre><code>super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);
    
Button btn = findViewById(R.id.btnFlux);

btn.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View view)
    {
        // Do something 
    }
});
</code></pre>
<p>Now we have to link our .so file to the project. For that you need to put the .so file in the following structure:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/1/101b4d960dbe4bcbbe1416a3b91bbff19fc7e7ec.png" alt="jniLibs_struct" data-base62-sha1="2iu8r7hXrRwGwGexyoTfn5vgVVG" width="275" height="372"></p>
<p>Now create a package named <code>settings</code> inside of <code>com.byeline.hackex</code> and create a new class named <code>SettingsManager</code> in said class.</p>
<p>The code has to be the following:</p>
<pre><code>package com.byeline.hackex.settings;

import java.util.Map;

public class SettingsManager {

    public static native String flux(Map&lt;String, String&gt; map);

    static {
        System.loadLibrary("HackEx");
    }
}
</code></pre>
<p>Good! Now let’s edit <code>MainActivity.java</code> and add the following code in our button click listener:</p>
<pre><code>HashMap&lt;String, String&gt; lol = new HashMap&lt;&gt;();
lol.put("parama", "valuea");
String ret = SettingsManager.flux(lol);
Log.i("REVERSING", ret);
</code></pre>
<p>We will also put the same code <strong>before</strong> our click listener as it will let android map the library before we attach with gdb.</p>
<p>We are good to go, press <code>Alt+F10</code> and it should run on your emulator! At each click, if you check the <code>logcat</code> output in android studio, you should see a signature string:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/e/e4b7ae110fa067e3a8b5ed4cfb4bf0301a1db858.png" alt="logcat_output" data-base62-sha1="wDkoxcT4ii3P7UyVec9IWPWeHqg" width="599" height="500"></p>
<p>We are ready to debug. Now we need to get gdb setup and ready to go. On the emulator, GDB server is already present, and since it’s x86_64, I can just use my normal GDB to connect to it, which is awesome.<br>
If we just start the gdb server, and attach to it, we will not get any symbols as my computer doesn’t know about my emulator’s libraries, for this, we will have to pull them locally first. Let’s create a new folder called fs, and pull some stuff in it.</p>
<pre><code>$ mkdir fs
$ cd fs
$ mkdir -p sysroot/system
$ adb pull /system/lib sysroot/system/
/system/lib/: 313 files pulled. 44.8 MB/s (140367100 bytes in 2.988s)
$ adb pull /system/bin sysroot/system
/system/bin/: 299 files pulled. 44.3 MB/s (79616683 bytes in 1.712s)
$ chmod 755 sysroot/system/bin/*
</code></pre>
<p>And finally, let’s add libHackEx.so in sysroot/system/lib folder</p>
<pre><code>$ cp ../libHackEx.so sysroot/system/lib/
</code></pre>
<p>Now, let’s forward a port to our computer in order to connect gdb to the emulator’s process</p>
<pre><code>$ adb forward tcp:12345 tcp:12345
12345
</code></pre>
<p>Now let’s start gdb locally. I use gdb <a href="https://github.com/longld/peda" rel="noopener nofollow ugc">peda</a> for my reversing/exploit dev needs as it greatly increase the output of gdb, I suggest you do the same if you use stock gdb.</p>
<pre><code>$ gdb -q
gdb-peda$
</code></pre>
<p>Now run the following commands to prepare gdb:</p>
<pre><code>gdb-peda$ set sysroot sysroot
gdb-peda$ set solib-search-path sysroot/system/lib/
gdb-peda$ handle SIG33 nostop noprint
</code></pre>
<p>You can add these commands in your ~/.gdbinit file so you don’t have to retype them everytime you start gdb during this reversing study.</p>
<p>Finally:</p>
<pre><code>gdb-peda$ file sysroot/system/bin/app_process
Reading symbols from sysroot/system/bin/app_process...
Reading symbols from .gnu_debugdata for /home/void/articles/reversing_hackex/fs/sysroot/system/bin/app_process...
(No debugging symbols found in .gnu_debugdata for /home/void/articles/reversing_hackex/fs/sysroot/system/bin/app_process)
</code></pre>
<p>Open a new terminal, make sure the apk is running on the emulator and use the following command to get it’s pid</p>
<pre><code>$ adb shell ps |grep "hackex"
u0_a87       10941  1492 1483224  81688 ep_poll    74cbba3792ba S com.byeline.hackex
</code></pre>
<p>Perfect, finally let’s use gdbserver to attach to it:</p>
<pre><code>$ adb shell
# gdbserver64 --attach :12345 10941
Attached; pid = 10941
Listening on port 12345
</code></pre>
<p>Locally, run this command in gdb:</p>
<pre><code>gdb-peda$ target remote :12345
(Reading symbols...)
</code></pre>
<p>And we arrive at this screen:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/1/1729684be8a26be854fe541fcaf936055e4cad1f.jpeg" alt="peda_output" data-base62-sha1="3iTHcqZLKBgJEblWBVromA4MOU7" width="463" height="500"></p>
<p>And now let’s set a breakpoint at <code>Java_com_byeline_hackex_settings_SettingsManager_flux</code></p>
<pre><code>gdb-peda$ b Java_com_byeline_hackex_settings_SettingsManager_flux
Breakpoint 1 at 0x74cb9fb916e0
gdb-peda$ c
Continuing.
</code></pre>
<p>Now click the button and wabam! We break in the function! Now we could just step instruction by instruction and inspect the registers and the stack to understand the logic, but as we performed static analysis earlier, we can just break at some key point that we found interesting to gain some time and not go insane. For instance, we can break at the address <code>base + 0xeb90</code> which is the first instruction of our string creation loop we saw earlier. To get the base address of our library, we can use <code>vmmap</code> to get the list of mapped addresses:</p>
<pre><code>gdb-peda$ vmmap libHackEx.so
0x000074cb9fb83000 0x000074cb9fbb9000 r-xp	/data/app/com.byeline.hackex-hii-krBwjRPa-wkgUi9Ldw==/lib/x86_64/libHackEx.so
0x000074cb9fbba000 0x000074cb9fbbe000 r--p	/data/app/com.byeline.hackex-hii-krBwjRPa-wkgUi9Ldw==/lib/x86_64/libHackEx.so
0x000074cb9fbbe000 0x000074cb9fbbf000 rw-p	/data/app/com.byeline.hackex-hii-krBwjRPa-wkgUi9Ldw==/lib/x86_64/libHackEx.so
</code></pre>
<p>Let’s break at <code>0x000074cb9fb83000+0x3b90</code> and continue:</p>
<pre><code>gdb-peda$ b *0x000074cb9fb83000+0x3b90
Breakpoint 2 at 0x74cb9fb86b90
gdb-peda$ c
</code></pre>
<p>Ok, so we hit breakpoint 2, and we are where we want to be! Although we don’t actually care about this loop right? We just want it’s output. Let’s put the breakpoint at <code>base+0xebca</code> instead, and continue the execution. We end up at the instruction <code>lea    rbx,[rsp+0x130]</code> so let’s step one time and check the string at rbx:</p>
<pre><code>RBX: 0x7ffe3c8ebd30 ("9gey50rOHWc0Upj2mH16Kd4OSxeGJOgdEpCjBI9G")
</code></pre>
<p>w00t! We have our final string! We can confirm that using the past 2 strings, if we xor <code>P</code> with <code>0x69</code>, we get char <code>9</code>. Yes!</p>
<p>Now let’s carry on. There’s still a lot of assembly code before the end of that function, and I don’t want to step instruction by instruction until the end, so let’s disassemble this function in gdb, and find a spot to break in.</p>
<pre><code>gdb-peda$ disas Java_com_byeline_hackex_settings_SettingsManager_flux
</code></pre>
<p>Remember all those sprintfs ? Since they are at the end of the function, we can assume their purpose is to create the final signature string, let’s check what’s the instruction before them to see if we could break somewhere and see what the sprintf are printing.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/4/4bf7eac7a7768c1a6d13daf6a96989dc41c92ba2.jpeg" alt="task_hash" data-base62-sha1="aQ2Y9Bm2wDnYG4XMe6FetjVYQ9k" width="690" height="378"></p>
<p>Here we can see a function <code>taskClassifier_hash</code> being called, so the signature is a hash of something else? Let’s verify that by runing hashid on a signature string:</p>
<pre><code>$ hashid
6f632ea0f207f2426ea8cef93cd0e6ba76ed608e
Analyzing '6f632ea0f207f2426ea8cef93cd0e6ba76ed608e'
[+] SHA-1 
[+] Double SHA-1 
[+] RIPEMD-160 
[+] Haval-160 
[+] Tiger-160 
[+] HAS-160 
[+] LinkedIn 
[+] Skein-256(160) 
[+] Skein-512(160)
</code></pre>
<p>Of course it’s a sha1 string! So the sprintf are just printing a sha1 hash, and the hash is probably made by this <code>taskClassifier_hash</code> function! Let’s break on this call:</p>
<pre><code>gdb-peda$ b *0x000074cba190fe2c
Breakpoint 2 at 0x74cba190fe2c
gdb-peda$ c
</code></pre>
<p>And tadam!</p>
<pre><code>RDI: 0x74cba1658aa0 ("sig21568473060002paramavaluea9gey50rOHWc0Upj2mH16Kd4OSxeGJOgdEpCjBI9G")
</code></pre>
<p>So, are we really hashing this string to get the signature? Let’s continue, and grab the final signature from android-studio <code>logcat</code></p>
<pre><code>e2727dd3c39aaf42a75f217c8b21975e72f58a7d&amp;sig2=1568473060002
</code></pre>
<p>now let’s sha1 hash the above string manually:</p>
<pre><code>echo -n "sig21568473060002paramavaluea9gey50rOHWc0Upj2mH16Kd4OSxeGJOgdEpCjBI9G" | sha1sum 
e2727dd3c39aaf42a75f217c8b21975e72f58a7d  -
</code></pre>
<p>W00t! We got the same hash!</p>
<p>So let’s resume. The function takes the parameters from the hashmap, and construct such a string:</p>
<pre><code>sig2{timestamp}{paramkey}{paramvalue}9gey50rOHWc0Upj2mH16Kd4OSxeGJOgdEpCjBI9G
</code></pre>
<p>Then hash it using sha1, and return the hash.</p>
<p>Let’s edit our <code>MainActivity.java</code> code, change the parameters, and click the button:</p>
<pre><code>HashMap&lt;String, String&gt; lol = new HashMap&lt;&gt;();
lol.put("somethingsomething", "chivatoiloveu");
String ret = SettingsManager.flux(lol);
Log.i("REVERSING", ret);

btn.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View view)
    {
        HashMap&lt;String, String&gt; lol = new HashMap&lt;&gt;();
        lol.put("somethingsomething", "chivatoiloveu");
        String ret = SettingsManager.flux(lol);
        Log.i("REVERSING", ret);
    }
});
</code></pre>
<p>The logcat output:</p>
<pre><code>I/REVERSING: e4247c3fd5804429ec6388aa748cb3e0cf668d1d&amp;sig2=1568474023095
</code></pre>
<p>So, the same way we did earlier, we can confirm if we sha1sum the following string:</p>
<pre><code>sig21568474023095somethingsomethingchivatoiloveu9gey50rOHWc0Upj2mH16Kd4OSxeGJOgdEpCjBI9G

$ echo -ne "sig21568474023095somethingsomethingchivatoiloveu9gey50rOHWc0Upj2mH16Kd4OSxeGJOgdEpCjBI9G" |sha1sum 
4d2fddb7dad43719bff07aa002eaf2272eb6db92  -
</code></pre>
<p>Huh, wasn’t that too easy? Let’s fire up gdb and see the hashed string again</p>
<pre><code>0x74cba166a380 ("somethingsomethingchivatoiloveusig215684743411239gey50rOHWc0Upj2mH16Kd4OSxeGJOgdEpCjBI9G")
</code></pre>
<p>so now , the params are at the beginning of the string? would it be related to the params length?</p>
<p>After many tests,  it seems that if the first char of the parameter is between s and z, and if the length of the parameter is above 2, then the param/value pair is put at the begining of the string, and if it isn’t, then it is put after the timestamp.</p>
<p>So to get the above sha1, we need to hash the following string instead:</p>
<pre><code>somethingsomethingchivatoiloveusig215684740230959gey50rOHWc0Upj2mH16Kd4OSxeGJOgdEpCjBI9G
</code></pre>
<p>Which give the following hash:</p>
<pre><code>e4247c3fd5804429ec6388aa748cb3e0cf668d1d
</code></pre>
<p>Yay!</p>
<p>Now let’s see what happens when we add multiple parameters. Let’s edit our hashmap and add some more params:</p>
<pre><code>HashMap&lt;String, String&gt; lol = new HashMap&lt;&gt;();
lol.put("somethingsomethingg", "chivatoiloveu");
lol.put("somethingelse", "ilovemealso");
String ret = SettingsManager.flux(lol);
Log.i("REVERSING", ret);
</code></pre>
<p>We get:</p>
<pre><code>somethingsomethinggchivatoiloveusomethingelseilovemealsosig215684770776879gey50rOHWc0Upj2mH16Kd4OSxeGJOgdEpCjBI9G
</code></pre>
<p>If the first letter of the first param is before <code>s</code> then we get:</p>
<pre><code>somethingelseilovemealsosig21568477173996aomethingsomethinggchivatoiloveu9gey50rOHWc0Upj2mH16Kd4OSxeGJOgdEpCjBI9G
</code></pre>
<p>Nice, we are ready to write our script to bot the s**t out of this game. We will try to list all users using the <code>user_victim</code> api endpoint. It requires only one parameter, <code>victim_user_id</code>. My python script therefore is the following:</p>
<pre><code class="lang-python">#!/usr/bin/env python3

import time
import requests
from datetime import datetime
from hashlib import sha1

APIKEY="0A8E520C-0F8A-9F36-8E89-F86E61A45BB1"
url = "https://api.hackex.net/v8/"

def signature(params):
    before_sig2_params = []; after_sig2_params = []

    for p in params:
        k,v=p
        if len(k) &gt;= 2 or k[0] in 'stuvwxyz':
            before_sig2_params += [p]
        else:
            after_sig2_params += [p]
    ts = str(int(datetime.now().timestamp()*1000))

    raw = ""
    for p in before_sig2_params:
        k,v=p
        raw += f"{k}{v}"
    raw += f"sig2{ts}"
    for p in after_sig2_params:
        k,v=p
        raw += f"{k}{v}"

    raw += f"9gey50rOHWc0Upj2mH16Kd4OSxeGJOgdEpCjBI9G"

    return sha1(raw.encode('utf-8')).hexdigest() + f"&amp;sig2={ts}"

def main():

    s = requests.Session()
    s.headers.update({"X-API-KEY": APIKEY})

    i = 7534914
    while True:
        i-=1
        uid = str(i)
        params = [("victim_user_id", uid)]
        req=url +f"user_victim?victim_user_id={uid}&amp;sig="+signature(params)
        try:
            _r = s.get(req)
            r = _r.json()
        except AttributeError:
            print(req)
            exit()
        print(f"id: {uid} | name: {r['user']['username']} | ip: {r['user']['ip']} | money: ${r['user_bank']['checking']}")
        for so in r['user_software']:
            print(f"{so['name']} -&gt; {so['software_level']} |", end="")
        print()

if __name__=='__main__':
    main()
</code></pre>
<pre><code>$ python pwn.py 
id: 7534913 | name: R Pay Too | ip: 15.251.62.189 | money: $0
Spyware -&gt; 1 |Firewall -&gt; 1 |Bypasser -&gt; 2 |Password Encryptor -&gt; 1 |
id: 7534912 | name: satheesan 8 | ip: 2.199.98.145 | money: $0
Firewall -&gt; 1 |Bypasser -&gt; 1 |Password Encryptor -&gt; 1 |
id: 7534911 | name: _FatalError_ | ip: 17.107.179.41 | money: $0
Firewall -&gt; 2 |Bypasser -&gt; 1 |Password Cracker -&gt; 10 |Password Encryptor -&gt; 1 |
id: 7534910 | name: janari janari | ip: 234.10.89.19 | money: $0
Spyware -&gt; 1 |Firewall -&gt; 1 |Bypasser -&gt; 2 |Password Encryptor -&gt; 1 |
id: 7534909 | name: 47heck | ip: 12.240.217.17 | money: $0
Antivirus -&gt; 1 |Spyware -&gt; 2 |Firewall -&gt; 1 |Bypasser -&gt; 5 |Password Cracker -&gt; 1 |Password Encryptor -&gt; 1 |
id: 7534908 | name: narashima | ip: 42.230.184.13 | money: $0
Firewall -&gt; 1 |Bypasser -&gt; 1 |Password Encryptor -&gt; 1 |
</code></pre>
<h1>Conculsion</h1>
<p>I hope the little reversing entertained you well. The developers of this game had issues with cheaters for years now, and they keep obfuscating this signature algorithm more and more, but obscurity != security. As long as they don’t change their design, people will be able to cheat in this game.</p>
          <p><a href="https://0x00sec.org/t/reversing-hackex-an-android-game/16243/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/reversing-hackex-an-android-game/16243/1</link>
        <pubDate>Sat, 14 Sep 2019 17:25:16 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-16243-1</guid>
        <source url="https://0x00sec.org/t/reversing-hackex-an-android-game/16243.rss">Reversing HackEx - An android game</source>
      </item>
  </channel>
</rss>
