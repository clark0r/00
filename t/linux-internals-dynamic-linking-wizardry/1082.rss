<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Linux Internals ~ Dynamic Linking Wizardry</title>
    <link>https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082</link>
    <description>**UPDATE**: _Please refer to [Linux Internals - The Art Of Symbol Resolution](https://0x00sec.org/t/linux-internals-the-art-of-symbol-resolution/1488) for a more detailed and updated analysis of the concept._

Hey peeps! I hope you&#39;re all doing great. It&#39;s been a long time since my last post. Anyway, today I present to you something completely different from what you&#39;ve been used to seeing from me. This is more a self-research/study material. I&#39;m nowhere close to being an expert on this subject but I busted my ass off trying to understand the inner workings of Linux executables and it finally started making sense. So I thought &quot;Hey, why not share my findings? Not everyone know what&#39;s going on under the hood.&quot; Without further ado, let&#39;s get right into the amazing world of Dynamic Linking! 

###Prerequisites
```makefile
-Basic C Programming
-Pointers
-Knowledge of the ELF would make your reading much smoother
-Knowledge of Linkers and Loaders
-Patience
-Logic
-Will
```
If some of you don&#39;t have some of the prerequisites, I&#39;m here to tell you have no fear because I will try to explain it as simply as I can. Even if you don&#39;t have a background in the low-level world, I&#39;ll do my best so that after you finish reading this paper you will have at least the basic feel of it.

_**Disclaimer**_: As I mentioned before, this paper is a result of my own experimentation and study, so if I&#39;m explaining something falsely or inaccurately, feel free to point out any mistake. We all learn by doing and failing. 

---
##Relocations

_According to the ELF(5) man pages:_

_Relocation is the process of connecting symbolic references with symbolic definitions. Relocatable files must have information that describes how to modify their section contents, thus allowing executable and shared object files to hold the right information for a process&#39;s program image. Relocation entries are these data._

Let&#39;s forget about that definition for a while and make a simpler version of it by experimenting, shall we? Hopefully, by the end of this post you will have made your own conclusion without needing to read any wikipedia link or specification. I won&#39;t dig deep into relocations since today&#39;s topic is dynamic linking but I&#39;ll explain as much as it&#39;s needed so we can connect the pieces of the puzzle together. Relocations are crucial when it comes to dynamic linking. You can think of it as a binary patching mechanism which provides intel to the dynamic linker in order to resolve symbol definitions. I&#39;m referring to &quot;symbols&quot; but you may be wondering, what does that even mean? 

```c
extern int i;
puts();
```
THAT simple. Imagine those 2 lines of code as being a part of a .c file. Puts() and &#39;i&#39; are symbols. Specifically, they are names which need to be resolved by the dynamic linker. What do I mean by that? Your computer works with addresses, not names. Puts() belongs to the well known libc library, aka a shared object, which means it&#39;s not defined in our source file. So how can the code of puts() be executed if we haven&#39;t defined a piece of code for that function in our source file? Well, here comes the dynamic linker who will resolve the address of puts() in libc, patch the relocation that has been made in our source file about the puts() symbol and then execute the function. I will explain in much more detail the process shortly. 

As about the ```extern int i;``` line. Well, there isn&#39;t much difference in the resolution process so I&#39;ll let you figure that out by providing a [link](http://stackoverflow.com/questions/1433204/how-do-i-use-extern-to-share-variables-between-source-files-in-c) for some research in case you never heard of extern.

Let&#39;s have a look at the 64-bit relocation structs:

Version 1:
```c
typedef struct {
    /* Offset to the location that requires relocation */
    Elf64_Addr r_offset;
    /* 
     * 1. Info about the index of the symbol in the symbol table.
     * 2. Type of relocation that needs to be applied.
    */
    uint64_t   r_info    
} Elf64_Rel;
```
Version 2:
```c
typedef struct {
    Elf64_Addr r_offset;
    uint64_t r_info;
    int64_t  r_addend; /* Constant addend used in relocation calculations */
} Elf64_Rela;
```
Alright, I think I gave you a kickstart on relocations so you can look them up later on.

---
##The Art Of Dynamic Linking

After this small relocation introduction, it&#39;s time to dig a bit deeper. If you haven&#39;t understood the purpose of them yet, no worries, I&#39;m about illustrate an example with actual code. Here&#39;s our tiny source file.

**_Note_**: The code example will be performed on a 32-bit machine.
 
```c
int main(void) {
    puts(&quot;Hey!&quot;);
    return 0;
}
```

Let&#39;s try to compile it with ```gcc -m32 -o name name.c ```. 

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/7/7fcc400edabaa6e2e1b859658129dec70b9f9ddd.png&quot; width=&quot;690&quot; height=&quot;80&quot;&gt;

Hmm, I don&#39;t know about you, but I&#39;m getting some warnings on the fact that puts() isn&#39;t declared in my source file. Well, I feel risky so I&#39;ll give it a shot and try to run the executable. 

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/3/35a4487e4070c9a28aef2aa57173772e5c95b9ac.png&quot; width=&quot;690&quot; height=&quot;136&quot;&gt;

Look at that! I didn&#39;t define puts() anywhere in my source file, I didn&#39;t include any header file and yet the code ran smoothly. So what happened? To the assembler haters, don&#39;t click away, it&#39;s simpler than you think. Let the journey begin.

---

##Lazy Binding via PLT and GOT

Welcome to the meat of this paper. The PLT (Procedure Linkage Table) and GOT (Global Offset Table) are sections included in executables and shared libraries. Our main focus is on executables right now. When a program makes use of a shared library function, such as puts() or gets(), which are not resolved until runtime, we are in need of a mechanism that resolves the addresses of those shared functions. This mechanism isn&#39;t just a simple call instruction.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/d/d87939b8a2d09770626200865615bdf7b32646ea.png&quot; width=&quot;594&quot; height=&quot;369&quot;&gt;

Don&#39;t freak out! That&#39;s the code of our main function via the use of the ```objdump -D``` command. We are only interested in the ```call 80482e0 &lt;puts@plt&gt;``` instruction.

Looks like the call to puts() leads to the address 0x80482e0, which is the PLT table entry for puts(). You don&#39;t believe me? 
&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/7/7546bf74ee8abf052340741f4e97d6586a67860d.png&quot; width=&quot;611&quot; height=&quot;79&quot;&gt;

Think of PLT and GOT as arrays with indices/entries. Each index includes info about variable and function symbols of our code (i.e addresses). PLT is specialized in function symbols while GOT is used for both variables and functions.

Moving on, there is an indirect jump (jmp *0x804a00c) to the address stored at 0x804a00c. That address is a GOT entry that holds the address for the puts() function in the libc library. Keep in mind that address. But wait, the address of puts() hasn&#39;t been resolved yet, where will it jump to? 

####_Enter Lazy Binding_

All I mean by lazy binding is this:

The dynamic linker will not resolve every function at load time, but instead, it will resolve the functions while they are being called during runtime through the help of its buddies who have made it possible, PLT and GOT. Let&#39;s have a relocation throwback.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/1/1af4feb6b08b3d152c0aa9bdaa00dc2232143572.png&quot; width=&quot;687&quot; height=&quot;175&quot;&gt;

**_Note_**: The R_386_JUMP_SLOT is a relocation type for the PLT/GOT entries. For more details into relocations make sure you check out the ELF specifications [5].

Interesting! Did you notice a familiar offset? You didn&#39;t? Alright, let me zoom in for you.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/c/c7c2d0acfdbe72fc65d9f75cdc42917a5c2edbba.png&quot; width=&quot;575&quot; height=&quot;38&quot;&gt;

C&#39;mon, it should ring a bell now! It doesn&#39;t? Dayum, it&#39;s the indirect jump address from the PLT entry to the GOT entry! In other words, that relocation type is shouting loud and clear &quot;Find the address of puts() in libc and patch the offset 0x804a00c in the file with the address of puts().&quot; Let me refresh your memory.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/7/7546bf74ee8abf052340741f4e97d6586a67860d.png&quot; width=&quot;611&quot; height=&quot;79&quot;&gt;

Ok, time to focus! If you&#39;ve been sleeping while reading thus far, it&#39;s time wake up.  As you have probably noticed, the relocation offset is the same as the address that the puts() PLT entry jumps to. Since, puts() is being called for the first time, the dynamic linker has to resolve its address and it&#39;s going to accomplish that by placing its address in the GOT entry for puts(). As I said earlier, both PLT and GOT are filled with address entries, after the dynamic linker gets its address resolution job done ofcourse.  Let&#39;s have a look at the 0x804a00c address. 

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/8/8406d3f661847e78df27a27372e1342fc05a9d32.png&quot; width=&quot;511&quot; height=&quot;169&quot;&gt;

As you can see, the address belongs to the GOT section of our program. Let&#39;s zoom in once again. 

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/3/3e224bb273f01d0353d83319bea2a26e6d220e3e.png&quot; width=&quot;244&quot; height=&quot;19&quot;&gt;

The ```e6 82``` is an address. Specifically, it&#39;s the address 0x80482e6. Why is that? Well, that&#39;s because my machine is using little endian, which means it reverses the byte order, thus it appears as ```e6  82```. I&#39;m not sure as to why it&#39;s showing only **e6** **82** and not the whole address. I&#39;d say it&#39;s some kind of compiler optimization. I&#39;m 200% sure though that it does indeed point to the **0x80482e6** address. Anyway, let&#39;s have a look at the PLT section of our program once again.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/7/7546bf74ee8abf052340741f4e97d6586a67860d.png&quot; width=&quot;611&quot; height=&quot;79&quot;&gt;

Do you see what I see? The **0x80482e6** address belongs to the second instruction in the PLT section ( in this case, push $0x0). So, ```jmp *0x804a00c``` jumps to the **0x804a00c** address which contains the **0x80482e6** address within, which is the ```push $0x0``` instruction. That push instruction plays an important role, which is to push the GOT entry for puts() on the stack. The GOT entry offset for puts() is 0x0, which refers to the first GOT entry that is being reserved by a shared library symbol. That makes sense since it&#39;s the first function needing to be resolved, thus it&#39;s taking over the first entry. Now, if you remember what I told you before, GOT and PLT are like arrays with indices/entries. But when I say &quot;it&#39;s taking over the first entry&quot;, it&#39;s actually being stored at the 4th entry in the GOT, the GOT[3]. Why is that? That&#39;s because the previous entries are reserved for dynamic linking purposes. 

```sql
GOT[0] - Reserved by the dynamic segment of the ELF file which contains important dynamic-linking info.

GOT[1] - Reserved by the address of a structure called link_map, which is used for symbol resolution. Basically contains information about puts().

GOT[2] - Contains the address to the dynamic linker&#39;s function, aka _dl_runtime_resolve(), which resolves the symbol address for the shared library function.
```
The last instruction in the PLT section is a ```jmp 80482d0```. This address is a pointer to the first PLT entry in the executable. Let&#39;s take a look at it.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/1/13728bfe2c66a86c2149a66c3dfe53b78e126ae2.png&quot; width=&quot;519&quot; height=&quot;74&quot;&gt;

Hang in there, we are almost done. The first instruction pushes the address of the second GOT entry (GOT[1]) on the stack. Finally, the ```jmp *0x804a008``` is an indirect jump to the third GOT entry (GOT[2]), which contains the address of the dl_runtime_resolve() function, thus passing control to the dynamic linker and resolving the symbol&#39;s address. Right after that, the dynamic linker will patch the PLT and GOT entries with the help of relocations. Meaning, the next time there is a call to puts() in our program, there won&#39;t be any lazy binding process, but instead, there will be a brunch right into the function&#39;s code itself. 

---
##Summary

Let&#39;s sum up the dynamic linking process to make our life easier:

```makefile
-Calling puts() by jumping into the PLT section.
-Indirect jump into the address of the GOT.
-The GOT&#39;s address contains the address which points back to the 2nd PLT instruction.
-Push the first GOT entry on the stack, which is the entry for puts(), so that the dynamic linker can patch it later.
-Jump into the first entry in PLT.
-Push the address of GOT[1] on the stack which contains an offset pointing to the link_map structure for puts().
-Push the address of GOT[2], which is the dl_runtime_resolve() function in order to resolve the address of puts() in libc.
-Patch the relocations.
```

In conclusion, lazy binding increases performance at load time. That&#39;s the default linking way nowadays but that can be tweaked by changing the LD_BIND_NOW environment variable. 

Oh well, that&#39;s been it. I know it was a lot to take in. I did my best not to bombard you with completely technical terms. If you are reading this sentence, you are a true champion. Thank you for taking the time to read my paper and I hope you gained even a small piece of knowledge from it. Any kind of feedback would be much appreciated. If you have any questions, feel free to comment them down below or PM me. I will provide some reference links in case you found this paper interesting.

Reference Links:
[1] http://phrack.org/issues/58/5.html
[2] https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html
[3] https://github.com/mewrev/dissection
[4] http://www.airs.com/blog/archives/41
[5] http://refspecs.linuxbase.org/elf/elf.pdf


Later,
@_py</description>
    
    <lastBuildDate>Fri, 22 Dec 2017 00:36:39 +0000</lastBuildDate>
    <category>Linux</category>
    <atom:link href="https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Linux Internals ~ Dynamic Linking Wizardry</title>
        <dc:creator><![CDATA[oaktree]]></dc:creator>
        <description><![CDATA[
            
          <p><a href="https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082/11">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082/11</link>
        <pubDate>Fri, 22 Dec 2017 00:57:32 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1082-11</guid>
        <source url="https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082.rss">Linux Internals ~ Dynamic Linking Wizardry</source>
      </item>
      <item>
        <title>Linux Internals ~ Dynamic Linking Wizardry</title>
        <dc:creator><![CDATA[_py]]></dc:creator>
        <description><![CDATA[
            
          <p><a href="https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082/10">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082/10</link>
        <pubDate>Fri, 22 Dec 2017 00:36:39 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1082-10</guid>
        <source url="https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082.rss">Linux Internals ~ Dynamic Linking Wizardry</source>
      </item>
      <item>
        <title>Linux Internals ~ Dynamic Linking Wizardry</title>
        <dc:creator><![CDATA[_py]]></dc:creator>
        <description><![CDATA[
            
          <p><a href="https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082/9">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082/9</link>
        <pubDate>Wed, 08 Nov 2017 07:09:55 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1082-9</guid>
        <source url="https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082.rss">Linux Internals ~ Dynamic Linking Wizardry</source>
      </item>
      <item>
        <title>Linux Internals ~ Dynamic Linking Wizardry</title>
        <dc:creator><![CDATA[_py]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="_py" data-post="1" data-topic="1082">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://0x00sec.org/user_avatar/0x00sec.org/_py/40/4275_2.png" class="avatar"> _py:</div>
<blockquote>
<p>UPDATE: Please refer to Linux Internals - The Art Of Symbol Resolution for a more detailed analysis of the concept.</p>
</blockquote>
</aside>
<p>It’s fully documented in my updated version, but thanks for the note.</p>
          <p><a href="https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082/8">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082/8</link>
        <pubDate>Wed, 08 Nov 2017 06:36:12 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1082-8</guid>
        <source url="https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082.rss">Linux Internals ~ Dynamic Linking Wizardry</source>
      </item>
      <item>
        <title>Linux Internals ~ Dynamic Linking Wizardry</title>
        <dc:creator><![CDATA[levi]]></dc:creator>
        <description><![CDATA[
            <p>thanks for the post</p>
<aside class="quote no-group" data-username="_py" data-post="1" data-topic="1082">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://0x00sec.org/user_avatar/0x00sec.org/_py/40/4275_2.png" class="avatar"> _py:</div>
<blockquote>
<p>which is the push $0x0 instruction. That push instruction plays an important role, which is to push the GOT entry for puts() on the stack. The GOT entry offset for puts() is 0x0, which refers to the first GOT entry that is being reserved by a shared library symbo</p>
</blockquote>
</aside>
<p>actually it’s the offset of relocation entry for “puts” function in the relocation array for “PLT”  , as shown form running “readelf -r obj” , the relocation entry for “puts” , is at offset 0x0 form the beginning of .rel.plt section.</p>
<p>again thanks for the post and ur effort trying to share knowledge</p>
          <p><a href="https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082/7">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082/7</link>
        <pubDate>Wed, 08 Nov 2017 06:32:36 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1082-7</guid>
        <source url="https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082.rss">Linux Internals ~ Dynamic Linking Wizardry</source>
      </item>
      <item>
        <title>Linux Internals ~ Dynamic Linking Wizardry</title>
        <dc:creator><![CDATA[_py]]></dc:creator>
        <description><![CDATA[
            <p>Thank you so much for the encouraging comment <a class="mention" href="https://0x00sec.org/u/shahril">@shahril</a>!</p>
<blockquote>
<p>This is because the instruction jmp *0x804a00c will take the 4 bytes value at the 0x804a00c address. You can imagine that this instruction is the same as jmp dword ptr [0x804a00c].</p>
</blockquote>
<p>You are right about that. That’s the Intel version of the instruction (which I prefer way more than AT&amp;T’s tbh ). If I remember correctly, the official term is <strong>indirect jump</strong>. Weirdly enough objdump cut the address in half if you noticed while in my recent write-up GDB shows it fully, that’s why I was surprised in the beginning.</p>
<blockquote>
<p>I love how you introduced the concept of GOT through array indices [0][1][2], which really makes sense for me.</p>
</blockquote>
<p>I’m really glad! The ELF specs refer to the binary structures as tables (i.e symbol table, global offset table, relocation table), but in reality they are arrays either containing C structs or pointers.</p>
<p>If you enjoyed learning about GOT/PLT you might be interested in having a look at my most recent write-up on <a href="https://0x00sec.org/t/picoctf-write-up-bypassing-aslr-via-format-string-bug/1920">Bypassing ASLR via Format String Bug</a>, where I abuse the GOT to redirect code execution. I’m hoping to release another write-up soon where I’ll be abusing PLT in order to leak addresses via ROP.</p>
<p>Thank you once again for taking the time to read them both. I hope you developed a mental model as to how the linking internals work.</p>
<p>Cheers!</p>
          <p><a href="https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082/6">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082/6</link>
        <pubDate>Wed, 10 May 2017 18:28:59 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1082-6</guid>
        <source url="https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082.rss">Linux Internals ~ Dynamic Linking Wizardry</source>
      </item>
      <item>
        <title>Linux Internals ~ Dynamic Linking Wizardry</title>
        <dc:creator><![CDATA[shahril]]></dc:creator>
        <description><![CDATA[
            <p>Thanks for the paper <a class="mention" href="https://0x00sec.org/u/_py">@_py</a>!</p>
<p>Reading your newest article <em><a href="https://0x00sec.org/t/linux-internals-the-art-of-symbol-resolution/1488">Linux Internals - The Art Of Symbol Resolution</a></em> plus reading this again really makes sense, as I’m able to understand it in just one shot! I love how you introduced the concept of GOT through array indices [0][1][2], which really makes sense for me.</p>
<aside class="quote no-group" data-username="_py" data-post="1" data-topic="1082">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://0x00sec.org/user_avatar/0x00sec.org/_py/40/4275_2.png" class="avatar"> _py:</div>
<blockquote>
<p>I’m not sure as to why it’s showing only e6 82 and not the whole address. I’d say it’s some kind of compiler optimization.</p>
</blockquote>
</aside>
<p>It’s actually <code>e6 82 04 08</code> in the little-endian. It’s on the first and second line.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/8/8406d3f661847e78df27a27372e1342fc05a9d32.png" width="450" height="160"></p>
<p>This is because the instruction <code>jmp *0x804a00c</code> will take the 4 bytes value at the <code>0x804a00c</code> address. You can imagine that this instruction is the same as <code>jmp dword ptr [0x804a00c]</code>.</p>
<p>But this is an old write up of yours, so I guess you already know about this thing. <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<p>Cheers, thanks again for the paper!</p>
          <p><a href="https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082/5">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082/5</link>
        <pubDate>Wed, 10 May 2017 16:56:04 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1082-5</guid>
        <source url="https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082.rss">Linux Internals ~ Dynamic Linking Wizardry</source>
      </item>
      <item>
        <title>Linux Internals ~ Dynamic Linking Wizardry</title>
        <dc:creator><![CDATA[anon79434934]]></dc:creator>
        <description><![CDATA[
            <p>You know an article is good when I understand it.</p>
<p>-Phoenix750</p>
          <p><a href="https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082/4">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082/4</link>
        <pubDate>Tue, 13 Sep 2016 18:53:13 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1082-4</guid>
        <source url="https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082.rss">Linux Internals ~ Dynamic Linking Wizardry</source>
      </item>
      <item>
        <title>Linux Internals ~ Dynamic Linking Wizardry</title>
        <dc:creator><![CDATA[_py]]></dc:creator>
        <description><![CDATA[
            <p>I appreciate the feedback <a class="mention" href="https://0x00sec.org/u/0x00pf">@0x00pf</a>! I hope my explanation didn’t confuse you.</p>
          <p><a href="https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082/3</link>
        <pubDate>Tue, 13 Sep 2016 18:01:44 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1082-3</guid>
        <source url="https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082.rss">Linux Internals ~ Dynamic Linking Wizardry</source>
      </item>
      <item>
        <title>Linux Internals ~ Dynamic Linking Wizardry</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>Brilliant post <a class="mention" href="https://0x00sec.org/u/_py">@_py</a></p>
<p>I see some serious <a href="http://www.catb.org/jargon/html/H/heavy-wizardry.html" rel="nofollow noopener">heavy wizardry</a> in this post.</p>
          <p><a href="https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082/2</link>
        <pubDate>Tue, 13 Sep 2016 17:57:17 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1082-2</guid>
        <source url="https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082.rss">Linux Internals ~ Dynamic Linking Wizardry</source>
      </item>
      <item>
        <title>Linux Internals ~ Dynamic Linking Wizardry</title>
        <dc:creator><![CDATA[_py]]></dc:creator>
        <description><![CDATA[
            <p><strong>UPDATE</strong>: <em>Please refer to <a href="https://0x00sec.org/t/linux-internals-the-art-of-symbol-resolution/1488">Linux Internals - The Art Of Symbol Resolution</a> for a more detailed and updated analysis of the concept.</em></p>
<p>Hey peeps! I hope you’re all doing great. It’s been a long time since my last post. Anyway, today I present to you something completely different from what you’ve been used to seeing from me. This is more a self-research/study material. I’m nowhere close to being an expert on this subject but I busted my ass off trying to understand the inner workings of Linux executables and it finally started making sense. So I thought “Hey, why not share my findings? Not everyone know what’s going on under the hood.” Without further ado, let’s get right into the amazing world of Dynamic Linking!</p>
<p>##<span class="hashtag">#Prerequisites</span></p>
<pre><code class="lang-makefile">-Basic C Programming
-Pointers
-Knowledge of the ELF would make your reading much smoother
-Knowledge of Linkers and Loaders
-Patience
-Logic
-Will
</code></pre>
<p>If some of you don’t have some of the prerequisites, I’m here to tell you have no fear because I will try to explain it as simply as I can. Even if you don’t have a background in the low-level world, I’ll do my best so that after you finish reading this paper you will have at least the basic feel of it.</p>
<p><em><strong>Disclaimer</strong></em>: As I mentioned before, this paper is a result of my own experimentation and study, so if I’m explaining something falsely or inaccurately, feel free to point out any mistake. We all learn by doing and failing.</p>
<hr>
<p>#<span class="hashtag">#Relocations</span></p>
<p><em>According to the ELF(5) man pages:</em></p>
<p><em>Relocation is the process of connecting symbolic references with symbolic definitions. Relocatable files must have information that describes how to modify their section contents, thus allowing executable and shared object files to hold the right information for a process’s program image. Relocation entries are these data.</em></p>
<p>Let’s forget about that definition for a while and make a simpler version of it by experimenting, shall we? Hopefully, by the end of this post you will have made your own conclusion without needing to read any wikipedia link or specification. I won’t dig deep into relocations since today’s topic is dynamic linking but I’ll explain as much as it’s needed so we can connect the pieces of the puzzle together. Relocations are crucial when it comes to dynamic linking. You can think of it as a binary patching mechanism which provides intel to the dynamic linker in order to resolve symbol definitions. I’m referring to “symbols” but you may be wondering, what does that even mean?</p>
<pre><code class="lang-auto">extern int i;
puts();
</code></pre>
<p>THAT simple. Imagine those 2 lines of code as being a part of a .c file. Puts() and ‘i’ are symbols. Specifically, they are names which need to be resolved by the dynamic linker. What do I mean by that? Your computer works with addresses, not names. Puts() belongs to the well known libc library, aka a shared object, which means it’s not defined in our source file. So how can the code of puts() be executed if we haven’t defined a piece of code for that function in our source file? Well, here comes the dynamic linker who will resolve the address of puts() in libc, patch the relocation that has been made in our source file about the puts() symbol and then execute the function. I will explain in much more detail the process shortly.</p>
<p>As about the <code>extern int i;</code> line. Well, there isn’t much difference in the resolution process so I’ll let you figure that out by providing a <a href="http://stackoverflow.com/questions/1433204/how-do-i-use-extern-to-share-variables-between-source-files-in-c" rel="noopener nofollow ugc">link</a> for some research in case you never heard of extern.</p>
<p>Let’s have a look at the 64-bit relocation structs:</p>
<p>Version 1:</p>
<pre><code class="lang-auto">typedef struct {
    /* Offset to the location that requires relocation */
    Elf64_Addr r_offset;
    /* 
     * 1. Info about the index of the symbol in the symbol table.
     * 2. Type of relocation that needs to be applied.
    */
    uint64_t   r_info    
} Elf64_Rel;
</code></pre>
<p>Version 2:</p>
<pre><code class="lang-auto">typedef struct {
    Elf64_Addr r_offset;
    uint64_t r_info;
    int64_t  r_addend; /* Constant addend used in relocation calculations */
} Elf64_Rela;
</code></pre>
<p>Alright, I think I gave you a kickstart on relocations so you can look them up later on.</p>
<hr>
<p>#<span class="hashtag">#The</span> Art Of Dynamic Linking</p>
<p>After this small relocation introduction, it’s time to dig a bit deeper. If you haven’t understood the purpose of them yet, no worries, I’m about illustrate an example with actual code. Here’s our tiny source file.</p>
<p><strong><em>Note</em></strong>: The code example will be performed on a 32-bit machine.</p>
<pre><code class="lang-auto">int main(void) {
    puts("Hey!");
    return 0;
}
</code></pre>
<p>Let’s try to compile it with <code>gcc -m32 -o name name.c </code>.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/7/7fcc400edabaa6e2e1b859658129dec70b9f9ddd.png" width="690" height="80"></p>
<p>Hmm, I don’t know about you, but I’m getting some warnings on the fact that puts() isn’t declared in my source file. Well, I feel risky so I’ll give it a shot and try to run the executable.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/3/35a4487e4070c9a28aef2aa57173772e5c95b9ac.png" width="690" height="136"></p>
<p>Look at that! I didn’t define puts() anywhere in my source file, I didn’t include any header file and yet the code ran smoothly. So what happened? To the assembler haters, don’t click away, it’s simpler than you think. Let the journey begin.</p>
<hr>
<p>#<span class="hashtag">#Lazy</span> Binding via PLT and GOT</p>
<p>Welcome to the meat of this paper. The PLT (Procedure Linkage Table) and GOT (Global Offset Table) are sections included in executables and shared libraries. Our main focus is on executables right now. When a program makes use of a shared library function, such as puts() or gets(), which are not resolved until runtime, we are in need of a mechanism that resolves the addresses of those shared functions. This mechanism isn’t just a simple call instruction.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/d/d87939b8a2d09770626200865615bdf7b32646ea.png" width="594" height="369"></p>
<p>Don’t freak out! That’s the code of our main function via the use of the <code>objdump -D</code> command. We are only interested in the <code>call 80482e0 &lt;puts@plt&gt;</code> instruction.</p>
<p>Looks like the call to puts() leads to the address 0x80482e0, which is the PLT table entry for puts(). You don’t believe me?<br>
<img src="//0x00sec.s3.amazonaws.com/original/2X/7/7546bf74ee8abf052340741f4e97d6586a67860d.png" width="611" height="79"></p>
<p>Think of PLT and GOT as arrays with indices/entries. Each index includes info about variable and function symbols of our code (i.e addresses). PLT is specialized in function symbols while GOT is used for both variables and functions.</p>
<p>Moving on, there is an indirect jump (jmp *0x804a00c) to the address stored at 0x804a00c. That address is a GOT entry that holds the address for the puts() function in the libc library. Keep in mind that address. But wait, the address of puts() hasn’t been resolved yet, where will it jump to?</p>
<p>####<em>Enter Lazy Binding</em></p>
<p>All I mean by lazy binding is this:</p>
<p>The dynamic linker will not resolve every function at load time, but instead, it will resolve the functions while they are being called during runtime through the help of its buddies who have made it possible, PLT and GOT. Let’s have a relocation throwback.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/1/1af4feb6b08b3d152c0aa9bdaa00dc2232143572.png" width="687" height="175"></p>
<p><strong><em>Note</em></strong>: The R_386_JUMP_SLOT is a relocation type for the PLT/GOT entries. For more details into relocations make sure you check out the ELF specifications [5].</p>
<p>Interesting! Did you notice a familiar offset? You didn’t? Alright, let me zoom in for you.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/c/c7c2d0acfdbe72fc65d9f75cdc42917a5c2edbba.png" width="575" height="38"></p>
<p>C’mon, it should ring a bell now! It doesn’t? Dayum, it’s the indirect jump address from the PLT entry to the GOT entry! In other words, that relocation type is shouting loud and clear “Find the address of puts() in libc and patch the offset 0x804a00c in the file with the address of puts().” Let me refresh your memory.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/7/7546bf74ee8abf052340741f4e97d6586a67860d.png" width="611" height="79"></p>
<p>Ok, time to focus! If you’ve been sleeping while reading thus far, it’s time wake up.  As you have probably noticed, the relocation offset is the same as the address that the puts() PLT entry jumps to. Since, puts() is being called for the first time, the dynamic linker has to resolve its address and it’s going to accomplish that by placing its address in the GOT entry for puts(). As I said earlier, both PLT and GOT are filled with address entries, after the dynamic linker gets its address resolution job done ofcourse.  Let’s have a look at the 0x804a00c address.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/8/8406d3f661847e78df27a27372e1342fc05a9d32.png" width="511" height="169"></p>
<p>As you can see, the address belongs to the GOT section of our program. Let’s zoom in once again.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/3/3e224bb273f01d0353d83319bea2a26e6d220e3e.png" width="244" height="19"></p>
<p>The <code>e6 82</code> is an address. Specifically, it’s the address 0x80482e6. Why is that? Well, that’s because my machine is using little endian, which means it reverses the byte order, thus it appears as <code>e6  82</code>. I’m not sure as to why it’s showing only <strong>e6</strong> <strong>82</strong> and not the whole address. I’d say it’s some kind of compiler optimization. I’m 200% sure though that it does indeed point to the <strong>0x80482e6</strong> address. Anyway, let’s have a look at the PLT section of our program once again.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/7/7546bf74ee8abf052340741f4e97d6586a67860d.png" width="611" height="79"></p>
<p>Do you see what I see? The <strong>0x80482e6</strong> address belongs to the second instruction in the PLT section ( in this case, push $0x0). So, <code>jmp *0x804a00c</code> jumps to the <strong>0x804a00c</strong> address which contains the <strong>0x80482e6</strong> address within, which is the <code>push $0x0</code> instruction. That push instruction plays an important role, which is to push the GOT entry for puts() on the stack. The GOT entry offset for puts() is 0x0, which refers to the first GOT entry that is being reserved by a shared library symbol. That makes sense since it’s the first function needing to be resolved, thus it’s taking over the first entry. Now, if you remember what I told you before, GOT and PLT are like arrays with indices/entries. But when I say “it’s taking over the first entry”, it’s actually being stored at the 4th entry in the GOT, the GOT[3]. Why is that? That’s because the previous entries are reserved for dynamic linking purposes.</p>
<pre><code class="lang-sql">GOT[0] - Reserved by the dynamic segment of the ELF file which contains important dynamic-linking info.

GOT[1] - Reserved by the address of a structure called link_map, which is used for symbol resolution. Basically contains information about puts().

GOT[2] - Contains the address to the dynamic linker's function, aka _dl_runtime_resolve(), which resolves the symbol address for the shared library function.
</code></pre>
<p>The last instruction in the PLT section is a <code>jmp 80482d0</code>. This address is a pointer to the first PLT entry in the executable. Let’s take a look at it.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/1/13728bfe2c66a86c2149a66c3dfe53b78e126ae2.png" width="519" height="74"></p>
<p>Hang in there, we are almost done. The first instruction pushes the address of the second GOT entry (GOT[1]) on the stack. Finally, the <code>jmp *0x804a008</code> is an indirect jump to the third GOT entry (GOT[2]), which contains the address of the dl_runtime_resolve() function, thus passing control to the dynamic linker and resolving the symbol’s address. Right after that, the dynamic linker will patch the PLT and GOT entries with the help of relocations. Meaning, the next time there is a call to puts() in our program, there won’t be any lazy binding process, but instead, there will be a brunch right into the function’s code itself.</p>
<hr>
<p>#<span class="hashtag">#Summary</span></p>
<p>Let’s sum up the dynamic linking process to make our life easier:</p>
<pre><code class="lang-makefile">-Calling puts() by jumping into the PLT section.
-Indirect jump into the address of the GOT.
-The GOT's address contains the address which points back to the 2nd PLT instruction.
-Push the first GOT entry on the stack, which is the entry for puts(), so that the dynamic linker can patch it later.
-Jump into the first entry in PLT.
-Push the address of GOT[1] on the stack which contains an offset pointing to the link_map structure for puts().
-Push the address of GOT[2], which is the dl_runtime_resolve() function in order to resolve the address of puts() in libc.
-Patch the relocations.
</code></pre>
<p>In conclusion, lazy binding increases performance at load time. That’s the default linking way nowadays but that can be tweaked by changing the LD_BIND_NOW environment variable.</p>
<p>Oh well, that’s been it. I know it was a lot to take in. I did my best not to bombard you with completely technical terms. If you are reading this sentence, you are a true champion. Thank you for taking the time to read my paper and I hope you gained even a small piece of knowledge from it. Any kind of feedback would be much appreciated. If you have any questions, feel free to comment them down below or PM me. I will provide some reference links in case you found this paper interesting.</p>
<p>Reference Links:<br>
[1] <a href="http://phrack.org/issues/58/5.html" rel="noopener nofollow ugc">http://phrack.org/issues/58/5.html</a><br>
[2] <a href="https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html" rel="noopener nofollow ugc">https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html</a><br>
[3] <a href="https://github.com/mewrev/dissection" rel="noopener nofollow ugc">https://github.com/mewrev/dissection</a><br>
[4] <a href="http://www.airs.com/blog/archives/41" rel="noopener nofollow ugc">http://www.airs.com/blog/archives/41</a><br>
[5] <a href="http://refspecs.linuxbase.org/elf/elf.pdf" rel="noopener nofollow ugc">http://refspecs.linuxbase.org/elf/elf.pdf</a></p>
<p>Later,<br>
<a class="mention" href="https://0x00sec.org/u/_py">@_py</a></p>
          <p><a href="https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082/1</link>
        <pubDate>Tue, 13 Sep 2016 16:50:15 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1082-1</guid>
        <source url="https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082.rss">Linux Internals ~ Dynamic Linking Wizardry</source>
      </item>
  </channel>
</rss>
