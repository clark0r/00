<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Analyzing Modern Malware Techniques - Part 1</title>
    <link>https://0x00sec.org/t/analyzing-modern-malware-techniques-part-1/18663</link>
    <description>**Analyzing Modern Malware Techniques**

Fileless malware - Self Loading Technique

Fileless malware is nothing new, but is very much used today. The idea is to load a payload into memory and to leave as much as little evidence as possible on the hard drive of the computer. This can be achieve by various techniques such as:

1. Using PowerShell to further infection in the machine.
2. Using the Registry to save malicious payloads without dropping them on disk.
3. Using WMI(Windows Management Instrumentation) to collect data about the computer.

These techniques go under a category called “Living Off the Land” which means the malware authors utilize Windows tools to exploit and manipulate them for malicious activities.

Today we’re gonna look at [Kovter](https://www.trendmicro.com/vinfo/us/security/news/cybercrime-and-digital-threats/kovter-an-evolving-malware-gone-fileless), a click-fraud malware, it&#39;s file-less payload is a bit different from the techniques mentioned above. I will be looking at its unique way of loading its payload without dropping a single file on disk, I’ll be exploring a sample to show how it actually achieves this.

**Recommended background required:**

1. Knowledge in C and WIN API
2. Knowledge in x86 Assembly and basic usage of IDA PRO
3. Basic understanding of the PE File format

**Tools used for the article:**

1. IDA PRO 7.0
2. x64dbg
3. PEBear
4. Resource Hacker
5. VMWare Workstation 14.0

**Samples used:**

[4160d0e5938b2ff29347476788f3810e ](https://malshare.com/sample.php?action=detail&amp;hash=4160d0e5938b2ff29347476788f3810e)

**Setting up some goals:**

I found this sample in a [malwarebytes blog post](https://blog.malwarebytes.com/threat-analysis/2016/07/untangling-kovter/), Where the author goes into a brief mentioning that the sample loads an encrypted PE file from the resource section. It maps the file inside its own memory and dynamically resolves it completely, without dropping it on disk. It is then mentioned that the mapped payload lives off the loader host, it depends on it and without it, it cannot work.

**So we’re gonna be looking for:**

1. Resource section handling API(ResourceSize, ResourceLock, ResourceLoad).
2. Any memory allocating API(HeapAlloc, VirtualAlloc).
3. Reference to any PE File format structures.
4. API Resolving API’s(LoadLibrary, GetProcAddress).

We know the payload is encrypted so we don&#39;t want to dig in looking into how the file is decrypted, we want to find it decrypted.

**Static Analysis:**

I decided to first load the file in IDA and scan for strings or valuable imports:

![|432x340](upload://hMtu8NHeUPCFX64Z3Hh83hONIpX.png)

This is incredible - we find everything we need off the spot. Calls to HeapAlloc, VirtualAlloc, LoadLibrary, GetProcAddress and resource related functions.

Let&#39;s look at the entry point of the binary:
We’re presented with a long list of functions being called in a linear order.. not really helpful.

![image|120x432](upload://9TPYx4tpT7ZJB9i3dOYl5hSONEA.png) 

Before I dissect the malware further I decide to look into the resource section using Resource Hacker:

![|479x232](upload://fIn0RWDhZef4JxCzc2T6PIn2F5.png)

A resource, it&#39;s called **DATA** and its encrypted. So let’s be on the lookup for any reference to the string “**DATA**” in memory.

Back in IDA, it&#39;s really hard to realize what&#39;s going on if we go free diving in the binary. It’s better off to start at the bottom so first let&#39;s explore the areas that are of value.

We’ll start off with the Resource API calls:

A call to **FindResourceW** is referenced at **00402B0E**:

![|311x287](upload://o2XS4wW8nijnAF7uOLlOY5x7DYH.png)

We can easily map out the local Variables **var_8** and **var_C** and **ESI**, We know that by stdcall convention, the return value is passed into eax from each function.

[FindResourceW ](https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-findresourcea)returns a handle of type of HRSR(Handle to a resource information block) is passed inside esi.

[SizeOfResource](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-sizeofresource) returns a DWORD which represents the size of the resource in bytes, this goes into var_C

[LoadResource ](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadresource)returns a handle of type HGLOBAL which represents a handle to the source, it is directly passed into LockResource

[LoackResource ](https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-lockresource)returns a pointer to the first byte in the resource, this goes into var_8.

Let&#39;s rename everything in IDA so we&#39;ll have a more clear view of things:

![|341x329](upload://4HPhR5dYWIX4gz8NikQ8uLdKhra.png)

Cool, now lets rename the function to something more valuable for us, so we can find it later(**sub_00402AD0** -&gt; **LoadResourceFromMemory**)

Next let’s look at **VirtualAlloc**, we&#39;ll use the xrefs from the Import view in IDA to look up the **VirtualAlloc** API Call(can be found at **0x4029F0**):

![|388x243](upload://eXnoUb1FpqGwO8IcPUbrOD7yBwj.png)

We can map **var_34**, which will point to the first byte of the allocated space, it is used a lot during the program so lets rename it right now to **lpvoidPointerToAllocatedSpace**

the instruction sequence:

![|303x74](upload://q2qDm7bGwNJ6l9vAlOe8wlzFpRD.png)

is this an entry inside a structure or an array? I cannot tell for sure at this point.
If we scroll down, we can see **LoadLibrary** and **GetProcAddress** are being called in a loop fashion:

![|602x253](upload://fQy8Uf2H4wsuP4ju0YuOk5wuY0M.png)
![|602x408](upload://eLZT4SSRDrsCZSZ2kyHvBwLoeDo.png)

Let’s start from the top(code block **0x4029C2**): If **EDI** is not empty, a DLLs base address will be resolved using **LoadLibraryA**. That address will be saved in **EBX**, which we can clearly see is being passed to **GetProcAddress** to get a base address of an API(code block **0x40299C**). When resolved, it’s then saved inside [**EDX**].

then at location **loc_4029AE** two local variables are incremented by four which can be represented as an indexers inside an array of pointers.

At first glance, I instantly thought about one thing, the binary is attempting to resolve the Import Address Table of another binary. but it’s really too early to make such assumptions.

Lets give this function a name(**sub_40274C** -&gt; **ExecuteNewResolvedPEinResources**)
Now let&#39;s check who called **ExecuteNewResolvedPEinResources**, it’s **sub_402C58**. Hmm.. Interesting this function also calls **LoadResourceFromMemory**.

The caller of this function(**sub_402C58**) is the **start** function which is the entry point of the program. In addition **sub_402C58** is also the last function being called before the loader binary shuts itself down. Great! We know where to stop and what to look out for!

![|346x111](upload://kFP9twCgzwRPa8ZsKRu3qlt6hMi.png)

**Dynamic Analysis**:

Breakpoints to set before execution:

1. LoadResourceFromMemory(**00402CA5**)
2. ExecuteNewResolvedPEinResources(**00402D7F**)
3. VirtualAlloc(**00402807**)
4. LoadLibraryA(**00402941**)
5. sub_402C58(**00402C58**)

Right so upon execution we should directly land at **sub_402C58**.

before entering **LoadResourceFromMemory**(**0x402CA5**), we can see “**DATA**” is being passed into **EAX** which is the name of the resource we saw before.
![|602x41](upload://rMs279JDUctXssLetFKFuQvqRi8.png)
Then we can see that the pointer to the first byte in the loaded resource is being passed into **var_8**(**ebp-8**).

![|582x68](upload://fosqFrvkGqPfTab3RvFETkbZEVS.png)

but as we exit the function, we lose all reference to it, we just know its located at **0x00407064**(the resource is still encrypted.)

Looking at the code following that function, we just see a huge linear code block - calling various functions. We could go scanning these functions, but this might go into a rabbit hole I wish not enter. I’m working on the assumption that as soon as the file is going to be mapped into memory, it&#39;s going to be mapped in its decrypted form. I decide to step over most of these calls.

![image|293x500](upload://syPPoIIoG9FHqHsGfLdD47ci1ym.png) 

And what do you know - if we continue skipping these functions we’ll start seeing the string MZP being shown in the debugger. first its referenced as “M8Z” and finally before entering **ExecuteNewResolvedPEinResources** (**0x402D7E**)  We get a valid PE file header!

![|602x37](upload://kXGgRJHJGVuIppRviEonpnyY7d1.png)

![|596x164](upload://8ta87eaXiZlb7klUPIQkOHr10Au.png)

**EDX** contains a pointer to the decrypted file, **EAX** contains the path string to the location of the loader binary and **ECX** contains value **0x00066A00**.

So let&#39;s go into **ExecuteNewResolvedPEinResources** in IDA and see if we can map this data out(yes we can!)

![|561x122](upload://neJbmsjPVz8zfhEVECbtqHPnpqq.png)

If we keep on going, nothing really happens until we hit the code block at **loc_4027BB**:

![|455x94](upload://3plcrXOUGSxUT5ckMRCCHpjlt4J.png)

**var_38** passed by **EBX** is now a pointer to a newly allocated PE File, after calling the function(**0x4027BE**) in the block it returns that pointer into **EAX**.

If we do decide to enter that function(**0x4027BE**), it leads to a rabbit hole of more functions. I decided not to get into it(If we resolve the location of the calls to HeapAlloc, this function might eventually call it. I speculate that this function has something to do with either confusing the analyst or it attempts to map out different sections of the PE, either way it has not much value to us anyway).

**EAX** assigns this new pointer into **var_10** and **var_18** and then something interesting happens - the binary attempts to check if [**EAX**] contains the string “**ZM**”(0x5A4D). I input the data I collected inside IDA:

![|452x225](upload://4GNEuTQ1WKBIxIBqspEiar6C68i.png)

I decide to conclude that **var_18** is actually a pointer to **IMAGE_DOS_HEADER**, well see if this assumption is correct.

At the next code block, the code loads the address of the **IMAGE_DOS_HEADER** and adds **0x3C** to it and attempts to compare it to &quot;**EP**&quot;( 0x4550).

![|602x77](upload://rjfuPYOE2CymNZvSDjqbwAOw3Yq.png)

**e_lfanew** is the last field in the **IMAGE_DOS_HEADER** and contains a the offset of the IMAGE_NT_HEADERS structure in the file, “**PE**” is the the value of the first field located inside **IMAGE_NT_HEADERS**, **Signature**:

![|453x166](upload://hfKZHH376vPPAF0W0TR5TVUjELL.png)

The next code block calls **VirtualAlloc**. I decide to map my assumptions into IDA:

![|585x244](upload://9kt4rdPfsWqRkGG3F0Jug7UqpD1.png)
**SizeOfImage** field located inside the **OptionalHeader** represents the size of the binary in bytes. **EAX** plus **EAX** will contain double that size. so its for two binaries.

At this point, there is too much evidence to conclude that the loader binary is loading and mapping out the file located in the resource section “DATA”.

The next code block contains the following instructions:

![|602x137](upload://nAH9uaRWxVrcmBFFsnOq49y8eeT.png)

if we look through the entire block **var_14** is almost always passed in **EDX**, and looking inside the function **sub_4022B4** we can see that both **EAX** and **EDX** are being used. **EAX** when passed to this function will point past the entire size of the PE file. while **EDX** will contain random data. If we’ll dig even deeper inside **sub_4022B4**. we can see the data contained in **EDX** is being written on the boundary allocated previously for the second PE file! so let’s rename everything:

![|489x119](upload://4SHOmWKunjS7G6nkukZCTCEpj9x.png)

If we keep reversing this entire code block, the main conclusion is the code block is copying the first resource binary we found to **lpvoidPointedToNewAllocatedAreaForImage**+**SizeOfImage**+4. then at **0x0040287D**, the resource binary is being copied again to **lpvoidPointedToNewAllocatedAreaForImage**.

These two binaries are separated by a boundary contained in the variable **lpvoidDataToPopulate**( contains the value **0x66A00**)
We rename sub_4022B4 to **MapMemoryData**, and var_14 will be renamed to **lpvoidDataToPopulate**.

Re-mapped view of IDA:

![|391x503](upload://bcCTyB6QGyNowTRAnxKIrxbBE3L.png)

Boundary value:

![|592x49](upload://emoOW3UJ55f8sUElj7EYLBWrgHx.png)

we move on to the code block located at **0x00402891**:

![|602x217](upload://nSzzh8LN2gIIXmguWuNb7dB7X3w.png)

This loop goes through all the sections located within the resource and maps them into the newly allocated memory.

![|460x428](upload://wlpagPOK7xr5NQzfYdVMd29xbj2.png)

This can be observed in the debugger if we access and view the dump of **EAX** before call to **MapMemoryData** and after the call. it should be noted that the sections are being mapped into the first memory area allocated for the PE from the resource sections and not the second.
![|602x99](upload://lyNDYhmtZZD67qwOzWiGgoPanyU.png)
At **0x4028EC**, we can see that the ImageBase of the resource binary in memory is being changed, this field located in IMAGE_OPTIONAL_HEADER is usually set for 0x400000 for binaries but it&#39;s being changed, to point to the memory pointed by the new allocated memory for the binary.

![|579x191](upload://orZcNr2sAcSlVda5HR6SPFZNRHl.png)

In the next block it gets really interesting(**0x4029B6**):

A loop begins to resolve the IAT, of the second area allocated for the binary mapped into memory. I will not bother explaining this in depth but this entire thing occurs in this loop which is described in this diagram:

![|602x284](upload://wBqoxwsyA2OWor5uk9qQJDRIcBF.png)
![|602x497](upload://eBfLI7BCMSo3d8nypRqeoAqiSzP.png)

And now finally, after iterating resolving the IAT we jump into **loc_4029D0**.

![|534x246](upload://pC9fTLqModat4BdZ8sZQoTwov4l.png)

The address of the entry point of the binary is passed into **var_8**, and then it is called. the two loaded binaries depending on each other to execute, one is going to execute its code and the other contains resolved IAT addresses. 

Lets create a diagram detailing how this loader operates so it would be more clear what just happened and it would also be easier for us to understand the loading of payload.

![|551x302](upload://4zUWUxBmdizUgL06d3dC7pJnnQx.png)

**Conclusion**:
In this article, I demonstrated how a malware might hide itself in memory by loading its encrypted payload into itself, thus attempting to stay undetectable and to avoid dropping files on disk.

In the next part of this series we’ll be exploring how malware might use PowerShell and the Registry to execute a File-less attack.

**Resources used:**
[PE File Format](http://www.openrce.org/reference_library/files/reference/PE%20Format.pdf)
[Untangling Kovter’s persistence methods](https://blog.malwarebytes.com/threat-analysis/2016/07/untangling-kovter/)</description>
    
    <lastBuildDate>Wed, 22 Jan 2020 17:45:58 +0000</lastBuildDate>
    <category>Malware</category>
    <atom:link href="https://0x00sec.org/t/analyzing-modern-malware-techniques-part-1/18663.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Analyzing Modern Malware Techniques - Part 1</title>
        <dc:creator><![CDATA[system]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 121 days. New replies are no longer allowed.</p>
          <p><a href="https://0x00sec.org/t/analyzing-modern-malware-techniques-part-1/18663/10">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/analyzing-modern-malware-techniques-part-1/18663/10</link>
        <pubDate>Tue, 19 May 2020 07:14:50 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-18663-10</guid>
        <source url="https://0x00sec.org/t/analyzing-modern-malware-techniques-part-1/18663.rss">Analyzing Modern Malware Techniques - Part 1</source>
      </item>
      <item>
        <title>Analyzing Modern Malware Techniques - Part 1</title>
        <dc:creator><![CDATA[z3r0.aka.k1d]]></dc:creator>
        <description><![CDATA[
            <p>great explanation<br>
Thank for this knowledge</p>
          <p><a href="https://0x00sec.org/t/analyzing-modern-malware-techniques-part-1/18663/9">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/analyzing-modern-malware-techniques-part-1/18663/9</link>
        <pubDate>Wed, 22 Jan 2020 17:45:58 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-18663-9</guid>
        <source url="https://0x00sec.org/t/analyzing-modern-malware-techniques-part-1/18663.rss">Analyzing Modern Malware Techniques - Part 1</source>
      </item>
      <item>
        <title>Analyzing Modern Malware Techniques - Part 1</title>
        <dc:creator><![CDATA[CyborgHawk]]></dc:creator>
        <description><![CDATA[
            <p>Windows RE <img src="https://0x00sec.org/images/emoji/twitter/slightly_smiling_face.png?v=9" title=":slightly_smiling_face:" class="emoji" alt=":slightly_smiling_face:"></p>
          <p><a href="https://0x00sec.org/t/analyzing-modern-malware-techniques-part-1/18663/8">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/analyzing-modern-malware-techniques-part-1/18663/8</link>
        <pubDate>Tue, 21 Jan 2020 04:04:56 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-18663-8</guid>
        <source url="https://0x00sec.org/t/analyzing-modern-malware-techniques-part-1/18663.rss">Analyzing Modern Malware Techniques - Part 1</source>
      </item>
      <item>
        <title>Analyzing Modern Malware Techniques - Part 1</title>
        <dc:creator><![CDATA[Danus]]></dc:creator>
        <description><![CDATA[
            <p>I don’t do block chain, regarding RE it depends on what you want to learn. C? ASM? Intel? ARM? Windows? Linux?</p>
          <p><a href="https://0x00sec.org/t/analyzing-modern-malware-techniques-part-1/18663/7">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/analyzing-modern-malware-techniques-part-1/18663/7</link>
        <pubDate>Mon, 20 Jan 2020 16:59:37 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-18663-7</guid>
        <source url="https://0x00sec.org/t/analyzing-modern-malware-techniques-part-1/18663.rss">Analyzing Modern Malware Techniques - Part 1</source>
      </item>
      <item>
        <title>Analyzing Modern Malware Techniques - Part 1</title>
        <dc:creator><![CDATA[CyborgHawk]]></dc:creator>
        <description><![CDATA[
            <p>Can I have any Blockchain and Reverse Engineering related researches ?</p>
          <p><a href="https://0x00sec.org/t/analyzing-modern-malware-techniques-part-1/18663/6">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/analyzing-modern-malware-techniques-part-1/18663/6</link>
        <pubDate>Mon, 20 Jan 2020 07:02:26 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-18663-6</guid>
        <source url="https://0x00sec.org/t/analyzing-modern-malware-techniques-part-1/18663.rss">Analyzing Modern Malware Techniques - Part 1</source>
      </item>
      <item>
        <title>Analyzing Modern Malware Techniques - Part 1</title>
        <dc:creator><![CDATA[pry0cc]]></dc:creator>
        <description><![CDATA[
            <p>Epic dude!</p>
<p>Welcome to the community!</p>
          <p><a href="https://0x00sec.org/t/analyzing-modern-malware-techniques-part-1/18663/5">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/analyzing-modern-malware-techniques-part-1/18663/5</link>
        <pubDate>Sun, 19 Jan 2020 19:27:10 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-18663-5</guid>
        <source url="https://0x00sec.org/t/analyzing-modern-malware-techniques-part-1/18663.rss">Analyzing Modern Malware Techniques - Part 1</source>
      </item>
      <item>
        <title>Analyzing Modern Malware Techniques - Part 1</title>
        <dc:creator><![CDATA[alioo]]></dc:creator>
        <description><![CDATA[
            <p>good job i liked your way in explanation <img src="https://0x00sec.org/images/emoji/twitter/clap.png?v=9" title=":clap:" class="emoji" alt=":clap:"> <img src="https://0x00sec.org/images/emoji/twitter/clap.png?v=9" title=":clap:" class="emoji" alt=":clap:"><br>
waiting for the next part <img src="https://0x00sec.org/images/emoji/twitter/star_struck.png?v=9" title=":star_struck:" class="emoji" alt=":star_struck:"></p>
          <p><a href="https://0x00sec.org/t/analyzing-modern-malware-techniques-part-1/18663/4">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/analyzing-modern-malware-techniques-part-1/18663/4</link>
        <pubDate>Sun, 19 Jan 2020 10:05:43 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-18663-4</guid>
        <source url="https://0x00sec.org/t/analyzing-modern-malware-techniques-part-1/18663.rss">Analyzing Modern Malware Techniques - Part 1</source>
      </item>
      <item>
        <title>Analyzing Modern Malware Techniques - Part 1</title>
        <dc:creator><![CDATA[Danus]]></dc:creator>
        <description><![CDATA[
            <p>Yes, but it depends on what you want to research because the malware field is very broad.</p>
          <p><a href="https://0x00sec.org/t/analyzing-modern-malware-techniques-part-1/18663/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/analyzing-modern-malware-techniques-part-1/18663/3</link>
        <pubDate>Sat, 18 Jan 2020 19:30:55 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-18663-3</guid>
        <source url="https://0x00sec.org/t/analyzing-modern-malware-techniques-part-1/18663.rss">Analyzing Modern Malware Techniques - Part 1</source>
      </item>
      <item>
        <title>Analyzing Modern Malware Techniques - Part 1</title>
        <dc:creator><![CDATA[CyborgHawk]]></dc:creator>
        <description><![CDATA[
            <p>Dear Sir,<br>
I am a final year student of Software Engineering degree. So, I have to submit a grand final project to complete my degree. Do you have any projects ideas related to this? If so, please give me some suggestions regarding final project.<br>
Thank You</p>
          <p><a href="https://0x00sec.org/t/analyzing-modern-malware-techniques-part-1/18663/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/analyzing-modern-malware-techniques-part-1/18663/2</link>
        <pubDate>Sat, 18 Jan 2020 17:19:25 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-18663-2</guid>
        <source url="https://0x00sec.org/t/analyzing-modern-malware-techniques-part-1/18663.rss">Analyzing Modern Malware Techniques - Part 1</source>
      </item>
      <item>
        <title>Analyzing Modern Malware Techniques - Part 1</title>
        <dc:creator><![CDATA[Danus]]></dc:creator>
        <description><![CDATA[
            <p><strong>Analyzing Modern Malware Techniques</strong></p>
<p>Fileless malware - Self Loading Technique</p>
<p>Fileless malware is nothing new, but is very much used today. The idea is to load a payload into memory and to leave as much as little evidence as possible on the hard drive of the computer. This can be achieve by various techniques such as:</p>
<ol>
<li>Using PowerShell to further infection in the machine.</li>
<li>Using the Registry to save malicious payloads without dropping them on disk.</li>
<li>Using WMI(Windows Management Instrumentation) to collect data about the computer.</li>
</ol>
<p>These techniques go under a category called “Living Off the Land” which means the malware authors utilize Windows tools to exploit and manipulate them for malicious activities.</p>
<p>Today we’re gonna look at <a href="https://www.trendmicro.com/vinfo/us/security/news/cybercrime-and-digital-threats/kovter-an-evolving-malware-gone-fileless" rel="noopener nofollow ugc">Kovter</a>, a click-fraud malware, it’s file-less payload is a bit different from the techniques mentioned above. I will be looking at its unique way of loading its payload without dropping a single file on disk, I’ll be exploring a sample to show how it actually achieves this.</p>
<p><strong>Recommended background required:</strong></p>
<ol>
<li>Knowledge in C and WIN API</li>
<li>Knowledge in x86 Assembly and basic usage of IDA PRO</li>
<li>Basic understanding of the PE File format</li>
</ol>
<p><strong>Tools used for the article:</strong></p>
<ol>
<li>IDA PRO 7.0</li>
<li>x64dbg</li>
<li>PEBear</li>
<li>Resource Hacker</li>
<li>VMWare Workstation 14.0</li>
</ol>
<p><strong>Samples used:</strong></p>
<p><a href="https://malshare.com/sample.php?action=detail&amp;hash=4160d0e5938b2ff29347476788f3810e" rel="noopener nofollow ugc">4160d0e5938b2ff29347476788f3810e </a></p>
<p><strong>Setting up some goals:</strong></p>
<p>I found this sample in a <a href="https://blog.malwarebytes.com/threat-analysis/2016/07/untangling-kovter/" rel="noopener nofollow ugc">malwarebytes blog post</a>, Where the author goes into a brief mentioning that the sample loads an encrypted PE file from the resource section. It maps the file inside its own memory and dynamically resolves it completely, without dropping it on disk. It is then mentioned that the mapped payload lives off the loader host, it depends on it and without it, it cannot work.</p>
<p><strong>So we’re gonna be looking for:</strong></p>
<ol>
<li>Resource section handling API(ResourceSize, ResourceLock, ResourceLoad).</li>
<li>Any memory allocating API(HeapAlloc, VirtualAlloc).</li>
<li>Reference to any PE File format structures.</li>
<li>API Resolving API’s(LoadLibrary, GetProcAddress).</li>
</ol>
<p>We know the payload is encrypted so we don’t want to dig in looking into how the file is decrypted, we want to find it decrypted.</p>
<p><strong>Static Analysis:</strong></p>
<p>I decided to first load the file in IDA and scan for strings or valuable imports:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/7/7c9fc208e10718c5a098d00988a5fe421959dd31.png" data-download-href="/uploads/short-url/hMtu8NHeUPCFX64Z3Hh83hONIpX.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/7/7c9fc208e10718c5a098d00988a5fe421959dd31_2_432x340.png" alt="" data-base62-sha1="hMtu8NHeUPCFX64Z3Hh83hONIpX" width="432" height="340" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/7/7c9fc208e10718c5a098d00988a5fe421959dd31_2_432x340.png, https://0x00sec.s3.amazonaws.com/optimized/2X/7/7c9fc208e10718c5a098d00988a5fe421959dd31_2_648x510.png 1.5x, /uploads/default/original/2X/7/7c9fc208e10718c5a098d00988a5fe421959dd31.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/7/7c9fc208e10718c5a098d00988a5fe421959dd31_2_10x10.png"></a></div><p></p>
<p>This is incredible - we find everything we need off the spot. Calls to HeapAlloc, VirtualAlloc, LoadLibrary, GetProcAddress and resource related functions.</p>
<p>Let’s look at the entry point of the binary:<br>
We’re presented with a long list of functions being called in a linear order… not really helpful.</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="image" data-orig-src="upload://9TPYx4tpT7ZJB9i3dOYl5hSONEA.png" width="120" height="432"></p>
<p>Before I dissect the malware further I decide to look into the resource section using Resource Hacker:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/0/01c6c8d1d4375334321079a68d42a3d3fe7170a3.png" data-download-href="/uploads/short-url/fIn0RWDhZef4JxCzc2T6PIn2F5.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/0/01c6c8d1d4375334321079a68d42a3d3fe7170a3_2_479x232.png" alt="" data-base62-sha1="fIn0RWDhZef4JxCzc2T6PIn2F5" width="479" height="232" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/0/01c6c8d1d4375334321079a68d42a3d3fe7170a3_2_479x232.png, https://0x00sec.s3.amazonaws.com/optimized/2X/0/01c6c8d1d4375334321079a68d42a3d3fe7170a3_2_718x348.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/2X/0/01c6c8d1d4375334321079a68d42a3d3fe7170a3_2_958x464.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/0/01c6c8d1d4375334321079a68d42a3d3fe7170a3_2_10x10.png"></a></div><p></p>
<p>A resource, it’s called <strong>DATA</strong> and its encrypted. So let’s be on the lookup for any reference to the string “<strong>DATA</strong>” in memory.</p>
<p>Back in IDA, it’s really hard to realize what’s going on if we go free diving in the binary. It’s better off to start at the bottom so first let’s explore the areas that are of value.</p>
<p>We’ll start off with the Resource API calls:</p>
<p>A call to <strong>FindResourceW</strong> is referenced at <strong>00402B0E</strong>:</p>
<p><img src="/uploads/default/original/2X/a/a889ff386610810836eab5c1396e9286f0825f87.png" alt="" data-base62-sha1="o2XS4wW8nijnAF7uOLlOY5x7DYH" width="311" height="287"></p>
<p>We can easily map out the local Variables <strong>var_8</strong> and <strong>var_C</strong> and <strong>ESI</strong>, We know that by stdcall convention, the return value is passed into eax from each function.</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-findresourcea" rel="noopener nofollow ugc">FindResourceW </a>returns a handle of type of HRSR(Handle to a resource information block) is passed inside esi.</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-sizeofresource" rel="noopener nofollow ugc">SizeOfResource</a> returns a DWORD which represents the size of the resource in bytes, this goes into var_C</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadresource" rel="noopener nofollow ugc">LoadResource </a>returns a handle of type HGLOBAL which represents a handle to the source, it is directly passed into LockResource</p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-lockresource" rel="noopener nofollow ugc">LoackResource </a>returns a pointer to the first byte in the resource, this goes into var_8.</p>
<p>Let’s rename everything in IDA so we’ll have a more clear view of things:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/2/20fcfb184b7d5d7d1985c03578b98ee483b1dcd8.png" data-download-href="/uploads/short-url/4HPhR5dYWIX4gz8NikQ8uLdKhra.png?dl=1" title=""><img src="/uploads/default/original/2X/2/20fcfb184b7d5d7d1985c03578b98ee483b1dcd8.png" alt="" data-base62-sha1="4HPhR5dYWIX4gz8NikQ8uLdKhra" width="341" height="329" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/2/20fcfb184b7d5d7d1985c03578b98ee483b1dcd8_2_10x10.png"></a></div><p></p>
<p>Cool, now lets rename the function to something more valuable for us, so we can find it later(<strong>sub_00402AD0</strong> -&gt; <strong>LoadResourceFromMemory</strong>)</p>
<p>Next let’s look at <strong>VirtualAlloc</strong>, we’ll use the xrefs from the Import view in IDA to look up the <strong>VirtualAlloc</strong> API Call(can be found at <strong>0x4029F0</strong>):</p>
<p><img src="/uploads/default/original/2X/6/68d4b7a325f64ee05f603f272acdeccd4fa2dde7.png" alt="" data-base62-sha1="eXnoUb1FpqGwO8IcPUbrOD7yBwj" width="388" height="243"></p>
<p>We can map <strong>var_34</strong>, which will point to the first byte of the allocated space, it is used a lot during the program so lets rename it right now to <strong>lpvoidPointerToAllocatedSpace</strong></p>
<p>the instruction sequence:</p>
<p><img src="/uploads/default/original/2X/b/b67ed4dafe3ed5d19be2b30d9fb1dd98518e9ba9.png" alt="" data-base62-sha1="q2qDm7bGwNJ6l9vAlOe8wlzFpRD" width="303" height="74"></p>
<p>is this an entry inside a structure or an array? I cannot tell for sure at this point.<br>
If we scroll down, we can see <strong>LoadLibrary</strong> and <strong>GetProcAddress</strong> are being called in a loop fashion:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/6/6f1156487622297eabd0d4e03caf573c446d3590.png" data-download-href="/uploads/short-url/fQy8Uf2H4wsuP4ju0YuOk5wuY0M.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/6/6f1156487622297eabd0d4e03caf573c446d3590_2_602x253.png" alt="" data-base62-sha1="fQy8Uf2H4wsuP4ju0YuOk5wuY0M" width="602" height="253" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/6/6f1156487622297eabd0d4e03caf573c446d3590_2_602x253.png, https://0x00sec.s3.amazonaws.com/optimized/2X/6/6f1156487622297eabd0d4e03caf573c446d3590_2_903x379.png 1.5x, /uploads/default/original/2X/6/6f1156487622297eabd0d4e03caf573c446d3590.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/6/6f1156487622297eabd0d4e03caf573c446d3590_2_10x10.png"></a></div><br>
<div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/6/678b6bdf0546a700267a6f9bf116493614423ab2.png" data-download-href="/uploads/short-url/eLZT4SSRDrsCZSZ2kyHvBwLoeDo.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/6/678b6bdf0546a700267a6f9bf116493614423ab2_2_602x408.png" alt="" data-base62-sha1="eLZT4SSRDrsCZSZ2kyHvBwLoeDo" width="602" height="408" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/6/678b6bdf0546a700267a6f9bf116493614423ab2_2_602x408.png, /uploads/default/original/2X/6/678b6bdf0546a700267a6f9bf116493614423ab2.png 1.5x, /uploads/default/original/2X/6/678b6bdf0546a700267a6f9bf116493614423ab2.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/6/678b6bdf0546a700267a6f9bf116493614423ab2_2_10x10.png"></a></div><p></p>
<p>Let’s start from the top(code block <strong>0x4029C2</strong>): If <strong>EDI</strong> is not empty, a DLLs base address will be resolved using <strong>LoadLibraryA</strong>. That address will be saved in <strong>EBX</strong>, which we can clearly see is being passed to <strong>GetProcAddress</strong> to get a base address of an API(code block <strong>0x40299C</strong>). When resolved, it’s then saved inside [<strong>EDX</strong>].</p>
<p>then at location <strong>loc_4029AE</strong> two local variables are incremented by four which can be represented as an indexers inside an array of pointers.</p>
<p>At first glance, I instantly thought about one thing, the binary is attempting to resolve the Import Address Table of another binary. but it’s really too early to make such assumptions.</p>
<p>Lets give this function a name(<strong>sub_40274C</strong> -&gt; <strong>ExecuteNewResolvedPEinResources</strong>)<br>
Now let’s check who called <strong>ExecuteNewResolvedPEinResources</strong>, it’s <strong>sub_402C58</strong>. Hmm… Interesting this function also calls <strong>LoadResourceFromMemory</strong>.</p>
<p>The caller of this function(<strong>sub_402C58</strong>) is the <strong>start</strong> function which is the entry point of the program. In addition <strong>sub_402C58</strong> is also the last function being called before the loader binary shuts itself down. Great! We know where to stop and what to look out for!</p>
<p><img src="/uploads/default/original/2X/9/90e5d31df9a935377be0a02380b710d7188a28f6.png" alt="" data-base62-sha1="kFP9twCgzwRPa8ZsKRu3qlt6hMi" width="346" height="111"></p>
<p><strong>Dynamic Analysis</strong>:</p>
<p>Breakpoints to set before execution:</p>
<ol>
<li>LoadResourceFromMemory(<strong>00402CA5</strong>)</li>
<li>ExecuteNewResolvedPEinResources(<strong>00402D7F</strong>)</li>
<li>VirtualAlloc(<strong>00402807</strong>)</li>
<li>LoadLibraryA(<strong>00402941</strong>)</li>
<li>sub_402C58(<strong>00402C58</strong>)</li>
</ol>
<p>Right so upon execution we should directly land at <strong>sub_402C58</strong>.</p>
<p>before entering <strong>LoadResourceFromMemory</strong>(<strong>0x402CA5</strong>), we can see “<strong>DATA</strong>” is being passed into <strong>EAX</strong> which is the name of the resource we saw before.<br>
</p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/c/c2b4d1e514dbacee88af9e483d3128018f6893d8.png" data-download-href="/uploads/short-url/rMs279JDUctXssLetFKFuQvqRi8.png?dl=1" title=""><img src="/uploads/default/original/2X/c/c2b4d1e514dbacee88af9e483d3128018f6893d8.png" alt="" data-base62-sha1="rMs279JDUctXssLetFKFuQvqRi8" width="602" height="41" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/c/c2b4d1e514dbacee88af9e483d3128018f6893d8_2_10x10.png"></a></div><br>
Then we can see that the pointer to the first byte in the loaded resource is being passed into <strong>var_8</strong>(<strong>ebp-8</strong>).<p></p>
<p><img src="/uploads/default/original/2X/6/6be465edba4e2035474c932b5629c83a767032ac.png" alt="" data-base62-sha1="fosqFrvkGqPfTab3RvFETkbZEVS" width="582" height="68"></p>
<p>but as we exit the function, we lose all reference to it, we just know its located at <strong>0x00407064</strong>(the resource is still encrypted.)</p>
<p>Looking at the code following that function, we just see a huge linear code block - calling various functions. We could go scanning these functions, but this might go into a rabbit hole I wish not enter. I’m working on the assumption that as soon as the file is going to be mapped into memory, it’s going to be mapped in its decrypted form. I decide to step over most of these calls.</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="image" data-orig-src="upload://syPPoIIoG9FHqHsGfLdD47ci1ym.png" width="293" height="500"></p>
<p>And what do you know - if we continue skipping these functions we’ll start seeing the string MZP being shown in the debugger. first its referenced as “M8Z” and finally before entering <strong>ExecuteNewResolvedPEinResources</strong> (<strong>0x402D7E</strong>)  We get a valid PE file header!</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/9/92ea919d8e9b69b64cd760a67c0559fdc4c63c63.png" data-download-href="/uploads/short-url/kXGgRJHJGVuIppRviEonpnyY7d1.png?dl=1" title=""><img src="/uploads/default/original/2X/9/92ea919d8e9b69b64cd760a67c0559fdc4c63c63.png" alt="" data-base62-sha1="kXGgRJHJGVuIppRviEonpnyY7d1" width="602" height="37" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/9/92ea919d8e9b69b64cd760a67c0559fdc4c63c63_2_10x10.png"></a></div><p></p>
<p><img src="/uploads/default/original/2X/3/3b5d54aa6606f9cae3fd43c657ef52d4dc82069e.png" alt="" data-base62-sha1="8ta87eaXiZlb7klUPIQkOHr10Au" width="596" height="164"></p>
<p><strong>EDX</strong> contains a pointer to the decrypted file, <strong>EAX</strong> contains the path string to the location of the loader binary and <strong>ECX</strong> contains value <strong>0x00066A00</strong>.</p>
<p>So let’s go into <strong>ExecuteNewResolvedPEinResources</strong> in IDA and see if we can map this data out(yes we can!)</p>
<p><img src="/uploads/default/original/2X/a/a2dc39fa53d7fd701420721a11e4312cb3e0e2e2.png" alt="" data-base62-sha1="neJbmsjPVz8zfhEVECbtqHPnpqq" width="561" height="122"></p>
<p>If we keep on going, nothing really happens until we hit the code block at <strong>loc_4027BB</strong>:</p>
<p><img src="/uploads/default/original/2X/1/17e3dfe3770fcb7faec00c50a3d58952ba2070c1.png" alt="" data-base62-sha1="3plcrXOUGSxUT5ckMRCCHpjlt4J" width="455" height="94"></p>
<p><strong>var_38</strong> passed by <strong>EBX</strong> is now a pointer to a newly allocated PE File, after calling the function(<strong>0x4027BE</strong>) in the block it returns that pointer into <strong>EAX</strong>.</p>
<p>If we do decide to enter that function(<strong>0x4027BE</strong>), it leads to a rabbit hole of more functions. I decided not to get into it(If we resolve the location of the calls to HeapAlloc, this function might eventually call it. I speculate that this function has something to do with either confusing the analyst or it attempts to map out different sections of the PE, either way it has not much value to us anyway).</p>
<p><strong>EAX</strong> assigns this new pointer into <strong>var_10</strong> and <strong>var_18</strong> and then something interesting happens - the binary attempts to check if [<strong>EAX</strong>] contains the string “<strong>ZM</strong>”(0x5A4D). I input the data I collected inside IDA:</p>
<p><img src="/uploads/default/original/2X/2/20df478e048fd2ea5aef22f00e3caf4d3e18556a.png" alt="" data-base62-sha1="4GNEuTQ1WKBIxIBqspEiar6C68i" width="452" height="225"></p>
<p>I decide to conclude that <strong>var_18</strong> is actually a pointer to <strong>IMAGE_DOS_HEADER</strong>, well see if this assumption is correct.</p>
<p>At the next code block, the code loads the address of the <strong>IMAGE_DOS_HEADER</strong> and adds <strong>0x3C</strong> to it and attempts to compare it to “<strong>EP</strong>”( 0x4550).</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/b/bf67c20dc1fba1e4829b2cf2aa4768715d51dbce.png" data-download-href="/uploads/short-url/rjfuPYOE2CymNZvSDjqbwAOw3Yq.png?dl=1" title=""><img src="/uploads/default/original/2X/b/bf67c20dc1fba1e4829b2cf2aa4768715d51dbce.png" alt="" data-base62-sha1="rjfuPYOE2CymNZvSDjqbwAOw3Yq" width="602" height="77" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/b/bf67c20dc1fba1e4829b2cf2aa4768715d51dbce_2_10x10.png"></a></div><p></p>
<p><strong>e_lfanew</strong> is the last field in the <strong>IMAGE_DOS_HEADER</strong> and contains a the offset of the IMAGE_NT_HEADERS structure in the file, “<strong>PE</strong>” is the the value of the first field located inside <strong>IMAGE_NT_HEADERS</strong>, <strong>Signature</strong>:</p>
<p><img src="/uploads/default/original/2X/7/78ecf778c15c54b2ebc8497fdf1c05936b062f39.png" alt="" data-base62-sha1="hfKZHH376vPPAF0W0TR5TVUjELL" width="453" height="166"></p>
<p>The next code block calls <strong>VirtualAlloc</strong>. I decide to map my assumptions into IDA:</p>
<p><img src="/uploads/default/original/2X/4/4163e68cd1d2b0d390fef8e4f1f19876e8e38aa7.png" alt="" data-base62-sha1="9kt4rdPfsWqRkGG3F0Jug7UqpD1" width="585" height="244"><br>
<strong>SizeOfImage</strong> field located inside the <strong>OptionalHeader</strong> represents the size of the binary in bytes. <strong>EAX</strong> plus <strong>EAX</strong> will contain double that size. so its for two binaries.</p>
<p>At this point, there is too much evidence to conclude that the loader binary is loading and mapping out the file located in the resource section “DATA”.</p>
<p>The next code block contains the following instructions:</p>
<p><img src="/uploads/default/original/2X/a/a557ebd65c7380588a3849902e3ac4073d948293.png" alt="" data-base62-sha1="nAH9uaRWxVrcmBFFsnOq49y8eeT" width="602" height="137"></p>
<p>if we look through the entire block <strong>var_14</strong> is almost always passed in <strong>EDX</strong>, and looking inside the function <strong>sub_4022B4</strong> we can see that both <strong>EAX</strong> and <strong>EDX</strong> are being used. <strong>EAX</strong> when passed to this function will point past the entire size of the PE file. while <strong>EDX</strong> will contain random data. If we’ll dig even deeper inside <strong>sub_4022B4</strong>. we can see the data contained in <strong>EDX</strong> is being written on the boundary allocated previously for the second PE file! so let’s rename everything:</p>
<p><img src="/uploads/default/original/2X/2/2237d0154c7bbc2706d8e3689e030476b908a753.png" alt="" data-base62-sha1="4SHOmWKunjS7G6nkukZCTCEpj9x" width="489" height="119"></p>
<p>If we keep reversing this entire code block, the main conclusion is the code block is copying the first resource binary we found to <strong>lpvoidPointedToNewAllocatedAreaForImage</strong>+<strong>SizeOfImage</strong>+4. then at <strong>0x0040287D</strong>, the resource binary is being copied again to <strong>lpvoidPointedToNewAllocatedAreaForImage</strong>.</p>
<p>These two binaries are separated by a boundary contained in the variable <strong>lpvoidDataToPopulate</strong>( contains the value <strong>0x66A00</strong>)<br>
We rename sub_4022B4 to <strong>MapMemoryData</strong>, and var_14 will be renamed to <strong>lpvoidDataToPopulate</strong>.</p>
<p>Re-mapped view of IDA:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/4/4e8553e7e595f529b1b3dcb503f1c53063e798b1.png" data-download-href="/uploads/short-url/bcCTyB6QGyNowTRAnxKIrxbBE3L.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/4/4e8553e7e595f529b1b3dcb503f1c53063e798b1_2_388x500.png" alt="" data-base62-sha1="bcCTyB6QGyNowTRAnxKIrxbBE3L" width="388" height="500" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/4/4e8553e7e595f529b1b3dcb503f1c53063e798b1_2_388x500.png, /uploads/default/original/2X/4/4e8553e7e595f529b1b3dcb503f1c53063e798b1.png 1.5x, /uploads/default/original/2X/4/4e8553e7e595f529b1b3dcb503f1c53063e798b1.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/4/4e8553e7e595f529b1b3dcb503f1c53063e798b1_2_10x10.png"></a></div><p></p>
<p>Boundary value:</p>
<p><img src="/uploads/default/original/2X/6/64a6a9cf3210a0f969f10601885b486376eb99b3.png" alt="" data-base62-sha1="emoOW3UJ55f8sUElj7EYLBWrgHx" width="592" height="49"></p>
<p>we move on to the code block located at <strong>0x00402891</strong>:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/a/a75d45483ac2bbb76933d572dfdaea3ff957317e.png" data-download-href="/uploads/short-url/nSzzh8LN2gIIXmguWuNb7dB7X3w.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/a/a75d45483ac2bbb76933d572dfdaea3ff957317e_2_602x217.png" alt="" data-base62-sha1="nSzzh8LN2gIIXmguWuNb7dB7X3w" width="602" height="217" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/a/a75d45483ac2bbb76933d572dfdaea3ff957317e_2_602x217.png, https://0x00sec.s3.amazonaws.com/optimized/2X/a/a75d45483ac2bbb76933d572dfdaea3ff957317e_2_903x325.png 1.5x, /uploads/default/original/2X/a/a75d45483ac2bbb76933d572dfdaea3ff957317e.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/a/a75d45483ac2bbb76933d572dfdaea3ff957317e_2_10x10.png"></a></div><p></p>
<p>This loop goes through all the sections located within the resource and maps them into the newly allocated memory.</p>
<p><img src="/uploads/default/original/2X/e/e2b1045f78ac5319e0cee7fe31c14d0520f1ce50.png" alt="" data-base62-sha1="wlpagPOK7xr5NQzfYdVMd29xbj2" width="460" height="428"></p>
<p>This can be observed in the debugger if we access and view the dump of <strong>EAX</strong> before call to <strong>MapMemoryData</strong> and after the call. it should be noted that the sections are being mapped into the first memory area allocated for the PE from the resource sections and not the second.<br>
</p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/9/971cba092b26193a9b6e5dbd4e848a9d3efa70b0.png" data-download-href="/uploads/short-url/lyNDYhmtZZD67qwOzWiGgoPanyU.png?dl=1" title=""><img src="/uploads/default/original/2X/9/971cba092b26193a9b6e5dbd4e848a9d3efa70b0.png" alt="" data-base62-sha1="lyNDYhmtZZD67qwOzWiGgoPanyU" width="602" height="99" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/9/971cba092b26193a9b6e5dbd4e848a9d3efa70b0_2_10x10.png"></a></div><br>
At <strong>0x4028EC</strong>, we can see that the ImageBase of the resource binary in memory is being changed, this field located in IMAGE_OPTIONAL_HEADER is usually set for 0x400000 for binaries but it’s being changed, to point to the memory pointed by the new allocated memory for the binary.<p></p>
<p><img src="/uploads/default/original/2X/a/ab5e13b3cd7ca9d625af7ade2c595b0c061a443b.png" alt="" data-base62-sha1="orZcNr2sAcSlVda5HR6SPFZNRHl" width="579" height="191"></p>
<p>In the next block it gets really interesting(<strong>0x4029B6</strong>):</p>
<p>A loop begins to resolve the IAT, of the second area allocated for the binary mapped into memory. I will not bother explaining this in depth but this entire thing occurs in this loop which is described in this diagram:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/e/e4809a9848e368dedd71b78983331e56d82f7b9f.png" data-download-href="/uploads/short-url/wBqoxwsyA2OWor5uk9qQJDRIcBF.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/e/e4809a9848e368dedd71b78983331e56d82f7b9f_2_602x284.png" alt="" data-base62-sha1="wBqoxwsyA2OWor5uk9qQJDRIcBF" width="602" height="284" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/e/e4809a9848e368dedd71b78983331e56d82f7b9f_2_602x284.png, https://0x00sec.s3.amazonaws.com/optimized/2X/e/e4809a9848e368dedd71b78983331e56d82f7b9f_2_903x426.png 1.5x, /uploads/default/original/2X/e/e4809a9848e368dedd71b78983331e56d82f7b9f.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/e/e4809a9848e368dedd71b78983331e56d82f7b9f_2_10x10.png"></a></div><br>
<div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/6/6654833e3d03f1b717835923a48652586a02b915.png" data-download-href="/uploads/short-url/eBfLI7BCMSo3d8nypRqeoAqiSzP.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/6/6654833e3d03f1b717835923a48652586a02b915_2_602x497.png" alt="" data-base62-sha1="eBfLI7BCMSo3d8nypRqeoAqiSzP" width="602" height="497" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/6/6654833e3d03f1b717835923a48652586a02b915_2_602x497.png, /uploads/default/original/2X/6/6654833e3d03f1b717835923a48652586a02b915.png 1.5x, /uploads/default/original/2X/6/6654833e3d03f1b717835923a48652586a02b915.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/6/6654833e3d03f1b717835923a48652586a02b915_2_10x10.png"></a></div><p></p>
<p>And now finally, after iterating resolving the IAT we jump into <strong>loc_4029D0</strong>.</p>
<p><img src="/uploads/default/original/2X/b/b386531c29f60cdb86d0db9ea8dc80d602cd79e9.png" alt="" data-base62-sha1="pC9fTLqModat4BdZ8sZQoTwov4l" width="534" height="246"></p>
<p>The address of the entry point of the binary is passed into <strong>var_8</strong>, and then it is called. the two loaded binaries depending on each other to execute, one is going to execute its code and the other contains resolved IAT addresses.</p>
<p>Lets create a diagram detailing how this loader operates so it would be more clear what just happened and it would also be easier for us to understand the loading of payload.</p>
<p><img src="/uploads/default/original/2X/2/20181e0942a50748b555442d3a678e872a143fcd.png" alt="" data-base62-sha1="4zUWUxBmdizUgL06d3dC7pJnnQx" width="551" height="302"></p>
<p><strong>Conclusion</strong>:<br>
In this article, I demonstrated how a malware might hide itself in memory by loading its encrypted payload into itself, thus attempting to stay undetectable and to avoid dropping files on disk.</p>
<p>In the next part of this series we’ll be exploring how malware might use PowerShell and the Registry to execute a File-less attack.</p>
<p><strong>Resources used:</strong><br>
<a href="http://www.openrce.org/reference_library/files/reference/PE%20Format.pdf" rel="noopener nofollow ugc">PE File Format</a><br>
<a href="https://blog.malwarebytes.com/threat-analysis/2016/07/untangling-kovter/" rel="noopener nofollow ugc">Untangling Kovter’s persistence methods</a></p>
          <p><a href="https://0x00sec.org/t/analyzing-modern-malware-techniques-part-1/18663/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/analyzing-modern-malware-techniques-part-1/18663/1</link>
        <pubDate>Sat, 18 Jan 2020 15:14:47 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-18663-1</guid>
        <source url="https://0x00sec.org/t/analyzing-modern-malware-techniques-part-1/18663.rss">Analyzing Modern Malware Techniques - Part 1</source>
      </item>
  </channel>
</rss>
