<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>A Simple Demonstration on Malware Analysis</title>
    <link>https://0x00sec.org/t/a-simple-demonstration-on-malware-analysis/994</link>
    <description>What&#39;s good, peeps? Initially, I was going to do a write up on an approach to programming an executable file infector (AKA a virus) however, I thought that it would be more interesting if we reversed and analyzed one. Throughout my journey with malware, I&#39;ve never been _quite_ able to grasp the mechanism in which parasitic file infectors employ - some reasons being that executables require the parsing of the [import table](https://en.wikipedia.org/wiki/Portable_Executable#Import_Table) for calling WinAPI functions, or perhaps the task of writing an executable which was entirely independent and was able to write its own entire self into another such that it would not destructively disrupt its flow of execution. Of course, as my journey continued, pieces of the puzzle were coming together, for example, learning and understanding the [PE file format](https://msdn.microsoft.com/en-au/library/ms809762.aspx) and ([N](http://www.nasm.us/))[ASM](https://en.wikipedia.org/wiki/Assembly_language) ((Netwide) Assembler) enabled me to make sense of such intricacies which will be explained further into this example.

Pre-requisites for this material:
```makefile
Knowledge of the WinAPI
Knowledge of the PE file format (optional)
Knowledge of Windows memory (optional)
Basic knowledge of C/C++
Basic knowledge of x86 Intel Assembly
```
If you do not have such pre-requisites, I will attempt to explain the content as clearly as possible but if there is any confusion, do not hesitate to leave a question in the comments. I will try to answer them as well as I can (if I can).


----------
## What is a Virus?
The most basic (and only) requirement for a _virus_ is that it must be able to replicate. Special programs which can replicate itself without human intervention are called _worms_, otherwise, we identify them as a _virus_. Most people who come across malware will instantly associate it as a virus, however, not all malware are viruses and also, not all viruses may be malware (not malicious) but the main purpose of such a design is for malicious intent (at least it is in the modern day).

There are many designs of viruses as they have evolved throughout the age of computers. Evolution which is necessary in nature purely because of the need to survive and flourish, as we would discover with biological viruses or rather, anything biological. The constant battle between virus authors and the antivirus industry has lead to the continuous engineering and reverse engineering of such software, resulting in different techniques to obscure or hide from their analyst predators while wreaking havoc to its prey as effectively as possible. Some examples of infection methods include overwriting entire victim files, appending and prepending, writing into code caves and EPO (entry-point obscuring) which are used, for example, to prevent damaging the host file, prevent detection, prevent disinfection or all of these mentioned (and possibly more). For more information, please refer to this paper by ir3t: [Introduction to Various File Infection Techniques](https://repo.zenk-security.com/Virus-Infections-Detections-Preventions/Introduction%20to%20various%20file%20infection%20techniques.pdf).

----------
## Malware Analysis

### Quick Dynamic Analysis

Let&#39;s finally begin analyzing the virus which I have obtained. I will not be starting off with the original virus program, instead, I will be using an already-infected file from which I will extract the viral code.

First things first, let&#39;s run the infected file so we can gather some quick intel on what or how the virus impacts the program. If you&#39;re doing this, remember to do so only in a protected and controlled environment.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/1X/7c00af497dd6f28b77e97814baad7840944b0d98.PNG&quot; width=&quot;439&quot; height=&quot;81&quot;&gt;

Before running the infected file, we can already see a difference between the original and the infected simply by observing the file size difference. This is already an issue for the author however, it was not programmed for the purpose of stealth so we will let it slide. Let&#39;s continue to running the infected program.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/1X/ed8e0ab42f302f8e4b7acae71e48e800d09886a5.PNG&quot; width=&quot;672&quot; height=&quot;337&quot;&gt;

Here, we see the console for the application and then we are instantly greeted with a message box from the author and...

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/1X/196e1069d5501354d211004156d2cb035f5f5ce9.PNG&quot; width=&quot;404&quot; height=&quot;78&quot;&gt;

...now we see that our other executable is also infected, again, through the observation of an altered file size. Pressing OK on the message box to continue execution of our infected file gives us the rest of the program.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/1X/ebd04e89f7c2c4e2b43495f88b91b57336261760.PNG&quot; width=&quot;671&quot; height=&quot;336&quot;&gt;

### File Analysis
What we can do now is perform static analysis on the infected file. Notice that the infection occurred before the main execution of the program. From this, we can conclude that the virus code must have preceded the main function somehow (obviously). How can such a thing happen? Well, if you&#39;ve read over my [PE File Infection](https://0x00sec.org/t/pe-file-infection/401) paper, there is a simple way to do this. If you don&#39;t remember or you haven&#39;t read it, the method is simply just modifying the PE header&#39;s `AddressOfEntryPoint` value listed in `IMAGE_NT_HEADERS.IMAGE_OPTIONAL_HEADER.AddressOfEntryPoint`. Microsoft defines the `IMAGE_NT_HEADERS` [struct](https://msdn.microsoft.com/en-us/library/windows/desktop/ms680336(v=vs.85).aspx) like so:

```cpp
typedef struct _IMAGE_NT_HEADERS {
  DWORD                 Signature;
  IMAGE_FILE_HEADER     FileHeader;
  IMAGE_OPTIONAL_HEADER OptionalHeader;   &lt;---
} IMAGE_NT_HEADERS, *PIMAGE_NT_HEADERS;
```
and the `IMAGE_OPTIONAL_HEADER` [struct](https://msdn.microsoft.com/en-us/library/windows/desktop/ms680339(v=vs.85).aspx):
```cpp
typedef struct _IMAGE_OPTIONAL_HEADER {
  // unnecessary members omitted
  DWORD                AddressOfEntryPoint;   &lt;--- this is the offset from the base
  DWORD                BaseOfCode;
  DWORD                BaseOfData;
  DWORD                ImageBase;   &lt;--- we need this as a base address
  // unnecessary members omitted
  IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER, *PIMAGE_OPTIONAL_HEADER;
```
The modified `AddressOfEntryPoint` defines the address of where the program will begin execution so we may find the start of the virus code in the infected file instead. Let&#39;s open up the infected file in [PEview](http://wjradburn.com/software/) and see what we can find.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/1X/f7a06fba802efe87af385e4f1c536647fc69f855.PNG&quot; width=&quot;690&quot; height=&quot;160&quot;&gt;

We can see in the relevant members of the structs that the `AddressOfEntryPoint` is `0x00010020` and `ImageBase` is `0x04000000`, so by adding these two values, we get the address of memory where the virus code may be located. Note that the values on the very left labeled under `VA` are the Virtual Addresses, i.e. the addresses in **memory**, not as a file. With these values, we will navigate to `0x00410020` for further investigation.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/1X/86e78c2b83bc22324b5b6b01836ba1a1b982de0b.PNG&quot; width=&quot;646&quot; height=&quot;500&quot;&gt;

Usually, under normal circumstances, the value should exist somewhere within the `.text` or `.code` section but we find that the address is in the `.tls` ([Thread Local Storage](https://msdn.microsoft.com/en-us/library/windows/desktop/ms686749(v=vs.85).aspx)) section instead which may mean that it _could_ be exploiting a multithreading procedure, but from what we have gathered in the initial run of the infected file, we had to process the message box first before the main function executed (message boxes are synchronous objects). So we can rule out such a possibility for now and probably assume that the virus just infects the last section of its host. We will be able to confirm our assumptions when we analyze the virus code itself. Currently, we cannot see anything obvious that might hint that this is the virus code but let&#39;s see all of it before we jump to any conclusions.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/1X/d2c670d9401b0aaea8f2f90860dd2a833724aba6.PNG&quot; width=&quot;565&quot; height=&quot;500&quot;&gt;

Scrolling down to the bottom, we can see the strings which were found in the greeting of the message box which means that this area of binary may very well be the virus code itself. Let&#39;s continue onto a deeper level of analysis by using a disassembler to try to translate the binary form into a more readable assembly form.

### Disassembly

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/1X/8173a08996cbf5ba88b8e8f81ef6550b3b0839a8.PNG&quot; width=&quot;485&quot; height=&quot;180&quot;&gt;

Opening up our infected file in [OllyDbg](http://ollydbg.de/), we are instantly greeted with information telling us that the `AddressOfEntryPoint` contains a value outside of the code segment. Thanks for that, but we&#39;ve already established this! Let&#39;s navigate to the Memory Map window (left) and open up the `.tls` section to examine the disassembly as a memory dump (right).

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/1X/a5121625304c58f9b62cc34b9aa4dcc54def77db.PNG&quot; width=&quot;690&quot; height=&quot;396&quot;&gt;

We see that the disassembler has incorrectly aligned the bytes at the address we want at `0x00410020` so it has also obscured the disassembled mnemonics on the right. So let&#39;s fix this by right-clicking and selecting **Go to address** and then entering in what we require.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/1X/b884b94aa48bc86a8a7b0e568a34f22234ac47fb.PNG&quot; width=&quot;374&quot; height=&quot;500&quot;&gt;

A quick inspection shows that this is proper code. Notice that the instructions are all simple and proper (`mov`, `add`, `push`, `call`, `lea`) and the numbers are nice and small, nothing incredibly large and obscure. Also, it&#39;s popular to use the `pushad` instruction to save the state of the program (by pushing all the registers) to then later call `popad` to recover it. In between these are possibly the instructions of either malicious code or some sort of (de)compression or de/encryption.

So the sensible thing to do here is to upload this to an antivirus scanner and we could try to dump the binary into a file here but there is a _slight_ problem. This is just raw data with no (PE file format) structure whatsoever therefore it would not be detected as anything malicious (trust me, I&#39;ve tried it). Instead, what we will have to reconstruct the program by using the hexadecimal values. First, highlight all the instructions within the memory dump, right-click, select **Binary** and then **Binary copy**. We&#39;ll paste this into a text editor and then trim some junk bytes from the top and bottom.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/1X/1bd46d053540899fd04b28d297bcb38a9ca85cff.PNG&quot; width=&quot;690&quot; height=&quot;440&quot;&gt;

We&#39;ll then need to transform this into a string of hexadecimal data so we can place it into an array in a C program. Using the Linux command line, `cat dump.bin | tr &#39;\n&#39; &#39; &#39; | sed &#39;s/ /\\x/g/&#39; | sed &#39;s/\\x$//g&#39; &gt;dump.bin` (that&#39;s right, this Windows kid knows how to use the Linux command line) and then manually add a `\x` at the start of the string. Now we can whip up a magical C program to execute the shellcode and hence replicate the virus.
```c
unsigned char VirusShellcode[] = &quot;\x60\xE8\x00\x00\x00\x00\x5D\x81\xED ...&quot;;

int main(void) {
    // declare function pointer
    void (*pVirusPtr)(void);
    // point to the address of VirusShellcode
    pVirusPtr = VirusShellcode;

    // execute VirusShellcode
    pVirusPtr();

    return 0;
}
```
Compile it and then we can now upload it to a scanner such as [NoDistribute](http://nodistribute.com/result/EiHe8YA4GbJUy5nIxKZOoDpTN1) or [Majyx](https://scan.majyx.net/scans/result/cd9b8312e253973e6a5a29d17f2fbb4cb98087e3) which both show the same result anyway (AFAIK they both, if not all non-distributing scanners, use the same engine): detection rate 1/35; Kaspersky Antivirus: `HEUR:Virus.Win32.Infector`. Note that since this is _not_ the original virus, it may have different results. Just to show that it works:

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/1X/1146937da55e68a3f427d76d3c89f39d798dd42e.PNG&quot; width=&quot;690&quot; height=&quot;441&quot;&gt;

But hold on a second... Does this mean we can do this with any program? Can we just extract the code section of X program, place it into a buffer of a C program and execute it like we did above? Well... the answer is no. No we can&#39;t. There&#39;s a bit more to it than that, I&#39;m afraid but don&#39;t worry, if you&#39;re itching to find out why it works in _this_ scenario and why we can&#39;t emulate it for any other typical program, I will explain it to you (just not here).


----------

## Conclusion

Now that we&#39;ve identified the threat, disinfection is probably trivial here. Removing the binary starting from `0x00410020` and then fixing the `.tls` section header to match the changed size should prove to be sufficient. That&#39;s great and all but what I&#39;m more interested in is _how_ this virus achieves its goal however, since this article was purposed for a malware analysis demonstration, I will end it here for now and do a separate one to detail a reverse engineering.

Hope you&#39;ve learned something from this!

_-- dtm_

P.S. I almost forgot, here is the source code to the virus: [Rohitab - [NASM] Simple Win32 Virus](http://www.rohitab.com/discuss/topic/38786-nasm-simple-win32-virus/). Enjoy!</description>
    
    <lastBuildDate>Mon, 29 Aug 2016 16:04:26 +0000</lastBuildDate>
    <category>Malware</category>
    <atom:link href="https://0x00sec.org/t/a-simple-demonstration-on-malware-analysis/994.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>A Simple Demonstration on Malware Analysis</title>
        <dc:creator><![CDATA[dtm]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 30 days. New replies are no longer allowed.</p>
          <p><a href="https://0x00sec.org/t/a-simple-demonstration-on-malware-analysis/994/4">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/a-simple-demonstration-on-malware-analysis/994/4</link>
        <pubDate>Sun, 21 Jan 2018 00:42:20 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-994-4</guid>
        <source url="https://0x00sec.org/t/a-simple-demonstration-on-malware-analysis/994.rss">A Simple Demonstration on Malware Analysis</source>
      </item>
      <item>
        <title>A Simple Demonstration on Malware Analysis</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>Great post mate! Awesome</p>
          <p><a href="https://0x00sec.org/t/a-simple-demonstration-on-malware-analysis/994/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/a-simple-demonstration-on-malware-analysis/994/3</link>
        <pubDate>Mon, 29 Aug 2016 16:04:26 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-994-3</guid>
        <source url="https://0x00sec.org/t/a-simple-demonstration-on-malware-analysis/994.rss">A Simple Demonstration on Malware Analysis</source>
      </item>
      <item>
        <title>A Simple Demonstration on Malware Analysis</title>
        <dc:creator><![CDATA[afiskon]]></dc:creator>
        <description><![CDATA[
            <p>Nice article. Thanks for a good reading!</p>
          <p><a href="https://0x00sec.org/t/a-simple-demonstration-on-malware-analysis/994/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/a-simple-demonstration-on-malware-analysis/994/2</link>
        <pubDate>Mon, 29 Aug 2016 12:00:53 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-994-2</guid>
        <source url="https://0x00sec.org/t/a-simple-demonstration-on-malware-analysis/994.rss">A Simple Demonstration on Malware Analysis</source>
      </item>
      <item>
        <title>A Simple Demonstration on Malware Analysis</title>
        <dc:creator><![CDATA[dtm]]></dc:creator>
        <description><![CDATA[
            <p>What’s good, peeps? Initially, I was going to do a write up on an approach to programming an executable file infector (AKA a virus) however, I thought that it would be more interesting if we reversed and analyzed one. Throughout my journey with malware, I’ve never been <em>quite</em> able to grasp the mechanism in which parasitic file infectors employ - some reasons being that executables require the parsing of the <a href="https://en.wikipedia.org/wiki/Portable_Executable#Import_Table">import table</a> for calling WinAPI functions, or perhaps the task of writing an executable which was entirely independent and was able to write its own entire self into another such that it would not destructively disrupt its flow of execution. Of course, as my journey continued, pieces of the puzzle were coming together, for example, learning and understanding the <a href="https://msdn.microsoft.com/en-au/library/ms809762.aspx">PE file format</a> and (<a href="http://www.nasm.us/">N</a>)<a href="https://en.wikipedia.org/wiki/Assembly_language">ASM</a> ((Netwide) Assembler) enabled me to make sense of such intricacies which will be explained further into this example.</p>
<p>Pre-requisites for this material:</p>
<pre><code class="lang-makefile">Knowledge of the WinAPI
Knowledge of the PE file format (optional)
Knowledge of Windows memory (optional)
Basic knowledge of C/C++
Basic knowledge of x86 Intel Assembly
</code></pre>
<p>If you do not have such pre-requisites, I will attempt to explain the content as clearly as possible but if there is any confusion, do not hesitate to leave a question in the comments. I will try to answer them as well as I can (if I can).</p>
<hr>
<h2>What is a Virus?</h2>
<p>The most basic (and only) requirement for a <em>virus</em> is that it must be able to replicate. Special programs which can replicate itself without human intervention are called <em>worms</em>, otherwise, we identify them as a <em>virus</em>. Most people who come across malware will instantly associate it as a virus, however, not all malware are viruses and also, not all viruses may be malware (not malicious) but the main purpose of such a design is for malicious intent (at least it is in the modern day).</p>
<p>There are many designs of viruses as they have evolved throughout the age of computers. Evolution which is necessary in nature purely because of the need to survive and flourish, as we would discover with biological viruses or rather, anything biological. The constant battle between virus authors and the antivirus industry has lead to the continuous engineering and reverse engineering of such software, resulting in different techniques to obscure or hide from their analyst predators while wreaking havoc to its prey as effectively as possible. Some examples of infection methods include overwriting entire victim files, appending and prepending, writing into code caves and EPO (entry-point obscuring) which are used, for example, to prevent damaging the host file, prevent detection, prevent disinfection or all of these mentioned (and possibly more). For more information, please refer to this paper by ir3t: <a href="https://repo.zenk-security.com/Virus-Infections-Detections-Preventions/Introduction%20to%20various%20file%20infection%20techniques.pdf">Introduction to Various File Infection Techniques</a>.</p>
<hr>
<h2>Malware Analysis</h2>
<h3>Quick Dynamic Analysis</h3>
<p>Let’s finally begin analyzing the virus which I have obtained. I will not be starting off with the original virus program, instead, I will be using an already-infected file from which I will extract the viral code.</p>
<p>First things first, let’s run the infected file so we can gather some quick intel on what or how the virus impacts the program. If you’re doing this, remember to do so only in a protected and controlled environment.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/1X/7c00af497dd6f28b77e97814baad7840944b0d98.PNG" width="439" height="81"></p>
<p>Before running the infected file, we can already see a difference between the original and the infected simply by observing the file size difference. This is already an issue for the author however, it was not programmed for the purpose of stealth so we will let it slide. Let’s continue to running the infected program.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/1X/ed8e0ab42f302f8e4b7acae71e48e800d09886a5.PNG" width="672" height="337"></p>
<p>Here, we see the console for the application and then we are instantly greeted with a message box from the author and…</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/1X/196e1069d5501354d211004156d2cb035f5f5ce9.PNG" width="404" height="78"></p>
<p>…now we see that our other executable is also infected, again, through the observation of an altered file size. Pressing OK on the message box to continue execution of our infected file gives us the rest of the program.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/1X/ebd04e89f7c2c4e2b43495f88b91b57336261760.PNG" width="671" height="336"></p>
<h3>File Analysis</h3>
<p>What we can do now is perform static analysis on the infected file. Notice that the infection occurred before the main execution of the program. From this, we can conclude that the virus code must have preceded the main function somehow (obviously). How can such a thing happen? Well, if you’ve read over my <a href="https://0x00sec.org/t/pe-file-infection/401">PE File Infection</a> paper, there is a simple way to do this. If you don’t remember or you haven’t read it, the method is simply just modifying the PE header’s <code>AddressOfEntryPoint</code> value listed in <code>IMAGE_NT_HEADERS.IMAGE_OPTIONAL_HEADER.AddressOfEntryPoint</code>. Microsoft defines the <code>IMAGE_NT_HEADERS</code> <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms680336(v=vs.85).aspx">struct</a> like so:</p>
<pre><code class="lang-cpp">typedef struct _IMAGE_NT_HEADERS {
  DWORD                 Signature;
  IMAGE_FILE_HEADER     FileHeader;
  IMAGE_OPTIONAL_HEADER OptionalHeader;   &lt;---
} IMAGE_NT_HEADERS, *PIMAGE_NT_HEADERS;
</code></pre>
<p>and the <code>IMAGE_OPTIONAL_HEADER</code> <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms680339(v=vs.85).aspx">struct</a>:</p>
<pre><code class="lang-cpp">typedef struct _IMAGE_OPTIONAL_HEADER {
  // unnecessary members omitted
  DWORD                AddressOfEntryPoint;   &lt;--- this is the offset from the base
  DWORD                BaseOfCode;
  DWORD                BaseOfData;
  DWORD                ImageBase;   &lt;--- we need this as a base address
  // unnecessary members omitted
  IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER, *PIMAGE_OPTIONAL_HEADER;
</code></pre>
<p>The modified <code>AddressOfEntryPoint</code> defines the address of where the program will begin execution so we may find the start of the virus code in the infected file instead. Let’s open up the infected file in <a href="http://wjradburn.com/software/">PEview</a> and see what we can find.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/1X/f7a06fba802efe87af385e4f1c536647fc69f855.PNG" width="690" height="160"></p>
<p>We can see in the relevant members of the structs that the <code>AddressOfEntryPoint</code> is <code>0x00010020</code> and <code>ImageBase</code> is <code>0x04000000</code>, so by adding these two values, we get the address of memory where the virus code may be located. Note that the values on the very left labeled under <code>VA</code> are the Virtual Addresses, i.e. the addresses in <strong>memory</strong>, not as a file. With these values, we will navigate to <code>0x00410020</code> for further investigation.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/1X/86e78c2b83bc22324b5b6b01836ba1a1b982de0b.PNG" width="646" height="500"></p>
<p>Usually, under normal circumstances, the value should exist somewhere within the <code>.text</code> or <code>.code</code> section but we find that the address is in the <code>.tls</code> (<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms686749(v=vs.85).aspx">Thread Local Storage</a>) section instead which may mean that it <em>could</em> be exploiting a multithreading procedure, but from what we have gathered in the initial run of the infected file, we had to process the message box first before the main function executed (message boxes are synchronous objects). So we can rule out such a possibility for now and probably assume that the virus just infects the last section of its host. We will be able to confirm our assumptions when we analyze the virus code itself. Currently, we cannot see anything obvious that might hint that this is the virus code but let’s see all of it before we jump to any conclusions.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/1X/d2c670d9401b0aaea8f2f90860dd2a833724aba6.PNG" width="565" height="500"></p>
<p>Scrolling down to the bottom, we can see the strings which were found in the greeting of the message box which means that this area of binary may very well be the virus code itself. Let’s continue onto a deeper level of analysis by using a disassembler to try to translate the binary form into a more readable assembly form.</p>
<h3>Disassembly</h3>
<p><img src="//0x00sec.s3.amazonaws.com/original/1X/8173a08996cbf5ba88b8e8f81ef6550b3b0839a8.PNG" width="485" height="180"></p>
<p>Opening up our infected file in <a href="http://ollydbg.de/">OllyDbg</a>, we are instantly greeted with information telling us that the <code>AddressOfEntryPoint</code> contains a value outside of the code segment. Thanks for that, but we’ve already established this! Let’s navigate to the Memory Map window (left) and open up the <code>.tls</code> section to examine the disassembly as a memory dump (right).</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/1X/a5121625304c58f9b62cc34b9aa4dcc54def77db.PNG" width="690" height="396"></p>
<p>We see that the disassembler has incorrectly aligned the bytes at the address we want at <code>0x00410020</code> so it has also obscured the disassembled mnemonics on the right. So let’s fix this by right-clicking and selecting <strong>Go to address</strong> and then entering in what we require.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/1X/b884b94aa48bc86a8a7b0e568a34f22234ac47fb.PNG" width="374" height="500"></p>
<p>A quick inspection shows that this is proper code. Notice that the instructions are all simple and proper (<code>mov</code>, <code>add</code>, <code>push</code>, <code>call</code>, <code>lea</code>) and the numbers are nice and small, nothing incredibly large and obscure. Also, it’s popular to use the <code>pushad</code> instruction to save the state of the program (by pushing all the registers) to then later call <code>popad</code> to recover it. In between these are possibly the instructions of either malicious code or some sort of (de)compression or de/encryption.</p>
<p>So the sensible thing to do here is to upload this to an antivirus scanner and we could try to dump the binary into a file here but there is a <em>slight</em> problem. This is just raw data with no (PE file format) structure whatsoever therefore it would not be detected as anything malicious (trust me, I’ve tried it). Instead, what we will have to reconstruct the program by using the hexadecimal values. First, highlight all the instructions within the memory dump, right-click, select <strong>Binary</strong> and then <strong>Binary copy</strong>. We’ll paste this into a text editor and then trim some junk bytes from the top and bottom.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/1X/1bd46d053540899fd04b28d297bcb38a9ca85cff.PNG" width="690" height="440"></p>
<p>We’ll then need to transform this into a string of hexadecimal data so we can place it into an array in a C program. Using the Linux command line, <code>cat dump.bin | tr '\n' ' ' | sed 's/ /\\x/g/' | sed 's/\\x$//g' &gt;dump.bin</code> (that’s right, this Windows kid knows how to use the Linux command line) and then manually add a <code>\x</code> at the start of the string. Now we can whip up a magical C program to execute the shellcode and hence replicate the virus.</p>
<pre><code class="lang-auto">unsigned char VirusShellcode[] = "\x60\xE8\x00\x00\x00\x00\x5D\x81\xED ...";

int main(void) {
    // declare function pointer
    void (*pVirusPtr)(void);
    // point to the address of VirusShellcode
    pVirusPtr = VirusShellcode;

    // execute VirusShellcode
    pVirusPtr();

    return 0;
}
</code></pre>
<p>Compile it and then we can now upload it to a scanner such as <a href="http://nodistribute.com/result/EiHe8YA4GbJUy5nIxKZOoDpTN1">NoDistribute</a> or <a href="https://scan.majyx.net/scans/result/cd9b8312e253973e6a5a29d17f2fbb4cb98087e3">Majyx</a> which both show the same result anyway (AFAIK they both, if not all non-distributing scanners, use the same engine): detection rate 1/35; Kaspersky Antivirus: <code>HEUR:Virus.Win32.Infector</code>. Note that since this is <em>not</em> the original virus, it may have different results. Just to show that it works:</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/1X/1146937da55e68a3f427d76d3c89f39d798dd42e.PNG" width="690" height="441"></p>
<p>But hold on a second… Does this mean we can do this with any program? Can we just extract the code section of X program, place it into a buffer of a C program and execute it like we did above? Well… the answer is no. No we can’t. There’s a bit more to it than that, I’m afraid but don’t worry, if you’re itching to find out why it works in <em>this</em> scenario and why we can’t emulate it for any other typical program, I will explain it to you (just not here).</p>
<hr>
<h2>Conclusion</h2>
<p>Now that we’ve identified the threat, disinfection is probably trivial here. Removing the binary starting from <code>0x00410020</code> and then fixing the <code>.tls</code> section header to match the changed size should prove to be sufficient. That’s great and all but what I’m more interested in is <em>how</em> this virus achieves its goal however, since this article was purposed for a malware analysis demonstration, I will end it here for now and do a separate one to detail a reverse engineering.</p>
<p>Hope you’ve learned something from this!</p>
<p><em>– dtm</em></p>
<p>P.S. I almost forgot, here is the source code to the virus: <a href="http://www.rohitab.com/discuss/topic/38786-nasm-simple-win32-virus/">Rohitab - [NASM] Simple Win32 Virus</a>. Enjoy!</p>
          <p><a href="https://0x00sec.org/t/a-simple-demonstration-on-malware-analysis/994/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/a-simple-demonstration-on-malware-analysis/994/1</link>
        <pubDate>Mon, 29 Aug 2016 11:33:29 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-994-1</guid>
        <source url="https://0x00sec.org/t/a-simple-demonstration-on-malware-analysis/994.rss">A Simple Demonstration on Malware Analysis</source>
      </item>
  </channel>
</rss>
