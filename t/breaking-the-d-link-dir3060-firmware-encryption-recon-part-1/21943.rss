<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Breaking the D-Link DIR3060 Firmware Encryption - Recon - Part 1</title>
    <link>https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/21943</link>
    <description>![bb|682x500](upload://eMZfDkg9YsQ6a9ys3DkxEtsRfme.png) 

Recently we came across some firmware samples from D-Link routers that we were unable to unpack properly. Luckily we got our hands on an older, cheaper but similar device (DIR882) that we were able to analyze more closely. The goal is to find a way to mitigate the firmware encryption that was put in place to prevent tampering and static analysis. This series highlights the results and necessary steps to write a custom decryption routine that actually works for a bunch of other models as well but more about that later on. First let&#39;s take a look at the problem.

### Table of Contents


- [The Problem](#heading--the-problem)
- [The Attempt](#heading--the-attempt)
- [The Solution](#heading--the-solution)
  - [Binary Reconnaissence](#heading--binary-recon)
- [Intermediate Summary](#heading--inter-sum)
- [Primer on MIPS32 disassembly](#heading--mips-primer)
  - [Registers](#heading--mips-regs)
  - [Common Operations](#heading--mips-common)
- [References](#heading--refs)

-----

&lt;h2 id=&quot;heading--the-problem&quot;&gt;The Problem: &lt;/h2&gt;

The latest D-Link 3060 firmware (as of time of writing) can be downloaded from [here](https://support.dlink.com/productinfo.aspx?m=DIR-3060-US). I&#39;ll be examining *v1.02B03*, which was released on 10/22/19. A brief initial analysis shows the following:

```
&gt; md5sum DIR-3060_RevA_Firmware111B01.bin
86e3f7baebf4178920c767611ec2ba50  DIR3060A1_FW102B03.bin

&gt; file DIR-3060_RevA_Firmware111B01.bin
DIR3060A1_FW102B03.bin: data

&gt; binwalk DIR-3060_RevA_Firmware111B01.bin

DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------

&gt; hd -n 128 DIR-3060_RevA_Firmware111B01.bin
00000000  53 48 52 53 01 13 1f 9e  01 13 1f a0 67 c6 69 73  |SHRS........g.is|
00000010  51 ff 4a ec 29 cd ba ab  f2 fb e3 46 2e 97 e7 b1  |Q.J.)......F....|
00000020  56 90 b9 16 f8 0c 77 b8  bf 13 17 46 7b e3 c5 9c  |V.....w....F{...|
00000030  39 b5 59 6b 75 8d b8 b0  a3 1d 28 84 33 13 65 04  |9.Yku.....(.3.e.|
00000040  61 de 2d 56 6f 38 d7 eb  43 9d d9 10 eb 38 20 88  |a.-Vo8..C....8 .|
00000050  1f 21 0e 41 88 ff ee aa  85 46 0e ee d7 f6 23 04  |.!.A.....F....#.|
00000060  fa 29 db 31 9c 5f 55 68  12 2e 32 c3 14 5c 0a 53  |.).1._Uh..2..\.S|
00000070  ed 18 24 d0 a6 59 c0 de  1c f3 8b 67 1d e6 31 36  |..$..Y.....g..16|
00000080
```

So all we got from the file command is that we have some form of (binary) data file at hand, which is not very useful. Our goto choice for initial recon: binwalk is also unable to identify any file sections within the firmware image, noteven any false positives. Lastly the hex dump of the first 128 bytes shows seemingly random data right from offset 0x0. All of these are indicators of an encrypted image, which an entropy analysis can confirm:

```
&gt; binwalk -E DIR-3060_RevA_Firmware111B01.bin

DECIMAL       HEXADECIMAL     ENTROPY
--------------------------------------------------------------------------------
0             0x0             Rising entropy edge (0.978280)
```

![init_Entropy](upload://yeo7D2bEvDgC3oVC2PNAxL77JwW.png)

There&#39;s not a single drop in the entropy curve leaving no room for us to extract any kind of information about the target...


&lt;h2 id=&quot;heading--the-attempt&quot;&gt;The Attempt: &lt;/h2&gt;


As we were reluctant to buy the [D-Link DIR 3060](https://www.dlink.com/en/products/dir-3060-exo-ac3000-smart-mesh-wi-fi-router) for around ~$200 we checked similar models from D-Link that were on the cheaper side with the goal to find at least one alternative that deploys the same encryption scheme. In the end we came across the [D-Link DIR 882](https://www.dlink.com/en/products/dir-882-exo-ac2600-mu-mimo-wi-fi-router), which was considerable cheaper.

On a side note, even when we weren&#39;t able to find a similar encryption scheme looking at different firmware headers could have provided some hints on what their goto mechanic to *&#39;secure&#39;* their firmware looks like.

As we stumbled upon the DIR 882, we checked the firmware v1.30B10 that was released on 02/20/20 and it shows the same behavior as the one from the big brother the DIR3060, including the constant entropy of nearly 1. One thing that the invested reader might notice is the same 4-byte sequence at the start &quot;SHRS&quot;. We will come to that one later.

```
&gt; md5sum DIR_882_FW120B06.BIN
89a80526d68842531fe29170cbd596c3  DIR_882_FW120B06.BIN

&gt; file DIR_882_FW120B06.BIN
DIR_882_FW120B06.BIN: data

&gt; binwalk DIR_882_FW120B06.BIN

DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------

&gt; hd -n 128 DIR_882_FW120B06.BIN
00000000  53 48 52 53 00 d1 d9 a6  00 d1 d9 b0 67 c6 69 73  |SHRS........g.is|
00000010  51 ff 4a ec 29 cd ba ab  f2 fb e3 46 fd a7 4d 06  |Q.J.)......F..M.|
00000020  a4 66 e6 ad bf c4 9d 13  f3 f7 d1 12 98 6b 2a 35  |.f...........k*5|
00000030  1d 0e 90 85 b7 83 f7 4d  3a 2a 25 5a b8 13 0c fb  |.......M:*%Z....|
00000040  2a 17 7a b2 99 04 60 66  eb c2 58 98 82 74 08 e3  |*.z...`f..X..t..|
00000050  54 1e e2 51 44 42 e8 d6  8e 46 6e 2c 16 57 d3 0b  |T..QDB...Fn,.W..|
00000060  07 d7 7c 9e 11 ec 72 1d  fb 87 a2 5b 18 ec 53 82  |..|...r....[..S.|
00000070  85 b9 84 39 b6 b4 dd 85  de f0 28 3d 36 0e be aa  |...9......(=6...|
00000080
```

![dir882_entropy](upload://fdfRnddfZeblJAgBO6ix7y2TQUf.png)

Another thing this firmware confirms for us is that the same crypto scheme is still used in early 2020.


&lt;h2 id=&quot;heading--the-solution&quot;&gt;The Solution: &lt;/h2&gt;

Once we acquired the DIR882 we were able to enter a serial console on the device and look around the file systems for any clues and candidates that handles the en-/decryption of firmware updates (Attaching to the UART console is out of scope for this article and not particular interesting as it involves no &#39;hardware hacking&#39; besides attaching 4 cables..) We quickly were able to identify a suitable candidate:

```
&gt; file imgdecrypt
imgdecrypt: ELF 32-bit LSB executable, MIPS, MIPS32 rel2 version 1 (SYSV), dynamically linked, interpreter /lib/ld-, stripped

&gt; md5sum imgdecrypt
a5474af860606f035e4b84bd31fc17a1  imgdecrypt
```
As we were just interested in this particular binary we dumped it the cruelest way possible:

```
&gt; base64 &lt; imgdecrypt
```

After copying the output to our local machine and converting the base64 back to binary we can start taking a closer look!


&lt;h3 id=&quot;heading--binary-recon&quot;&gt;Binary Reconnaissance: &lt;/h3&gt;



We have already seen above that we&#39;re dealing with a 32-bit ELF binary for MIPS, which is dynamically linked (as expected) and stripped. Let&#39;s see what good old `strings` can do for us here:

```
&gt; strings -n 10 imgdecrypt | uniq
/lib/ld-uClibc.so.0
[...]
SHA512_Init
SHA512_Update
SHA512_Final
RSA_verify
AES_set_encrypt_key
AES_cbc_encrypt
AES_set_decrypt_key
PEM_write_RSAPublicKey
OPENSSL_add_all_algorithms_noconf
PEM_read_RSAPublicKey
PEM_read_RSAPrivateKey
RSA_generate_key
EVP_aes_256_cbc
PEM_write_RSAPrivateKey
decrypt_firmare
encrypt_firmare
[...]
libcrypto.so.1.0.0
[...]
no image matic found
check SHA512 post failed
check SHA512 before failed %d %d
check SHA512 vendor failed
static const char *pubkey_n = &quot;%s&quot;;
static const char *pubkey_e = &quot;%s&quot;;
Read RSA private key failed, maybe the key password is incorrect
/etc_ro/public.pem
%s &lt;sourceFile&gt;
/tmp/.firmware.orig
0123456789ABCDEF
%s sourceFile destFile
[...]
```

Sweet! There is still a lot of useful stuff in there. I just removed the garbage lines indicated by the &quot;[...]&quot;. Most note-worthy are the following things:

 * Uses uClibc and libcrypto
 * Calculates/Checks SHA512 hash digests
 * Uses AES_CBC mode to en-/decrypt things
 * Has an RSA certificate check with the certificate path pinned to /etc_ro/public.pem
 * The RSA private key is protected by a password
 * /tmp/.firmware.orig could be a hint towards where things get temporarily decrypted to
 * General usage of imgdecrypt binary


&lt;h2 id=&quot;heading--inter-sum&quot;&gt;Intermediate Summary: &lt;/h2&gt;

So far we already learned multiple interesting things that should help us further down the road!

 1. D-Link probably re-uses the same encryption scheme across multiple devices.
 2. These devices are based on the MIPS32 architecture
 3. (Access to a UART serial console on the DIR 882 is doable without a problem)
 4. Linked against uClibc and libcrypto
     4.1 Potential usage of AES, RSA, and SHA512 routines
 5. Binary seems to be responsible for both en- and decryption
 6. There is a public certificate
 7. The usage of imgdecrypt seems to be ./imgdecrypt myInFile
 8. Usage of a /tmp/ path for storing results?


Next up we will dive into the static analysis of the `imgdecrypt` binary to understand how firmware updates are controlled! But before that for those of you who feel a bit rusty/are new to MIPS32 assembly language here is a short primer on it.

&lt;h2 id=&quot;heading--mips-primer&quot;&gt;Primer on MIPS32 disassembly: &lt;/h2&gt;


Most of you are most likely familiar with x86/x86_64 disassembly so here are a few general rules on how MIPS does things and how its different from the x86 world. First there are two calling conventions (O32 vs N32/N64). I&#39;ll be discussing the O32 one as it seems to be the most common one around. Discussing all of these in depths would be out of scope for this article!

&lt;h3 id=&quot;heading--mips-regs&quot;&gt;Registers&lt;/h3&gt;

In MIPS32 there are 32 registers you can use. The O32 calling convention defines them as follows:

```
+---------+-----------+------------------------------------------------+
|   Name  |   Number  |                  Usage                         |
+----------------------------------------------------------------------+
|  $zero  |  $0       |  Is always 0, writes to it are discarded.      |
+----------------------------------------------------------------------+
|  $at    |  $1       |  Assembler temporary register (pseudo instr.)  |
+----------------------------------------------------------------------+
| $v0─$v1 |  $2─$3    |  Function returns/expression evaluation        |
+----------------------------------------------------------------------+
| $a0─$a3 |  $4─$7    |  Function arguments, remaining are in stack    |
+----------------------------------------------------------------------+
| $t0─$t7 |  $8─$15   |  Temporary registers                           |
+----------------------------------------------------------------------+
| $s0─$s7 |  $16─$23  |  Saved temporary registers                     |
+----------------------------------------------------------------------+
| $t8─$t9 |  $24─$25  |  Temporary registers                           |
+----------------------------------------------------------------------+
| $k0─$k1 |  $26─$27  |  Reserved for kernel                           |
+----------------------------------------------------------------------+
|  $gp    |  $28      |  Global pointer                                |
+----------------------------------------------------------------------+
|  $sp    |  $29      |  Stack pointer                                 |
+----------------------------------------------------------------------+
|  $fp    |  $30      |  Frame pointer                                 |
+----------------------------------------------------------------------+
|  $ra    |  $31      |  Return address                                |
+---------+-----------+------------------------------------------------+
```

The most important things to remember are:

* First four function arguments are moved into `$a0 - $a3` while the remaining are placed on top of the stack
* Function returns are placed in `$v0` and eventually in `$v1` when there is a second return value
* Return addresses is stored in the `$ra` register when a function call is executed via jump and link (JAL) or jump and link register (JALR)
* `$sX` registers are preserved across procedure calls (subroutine can use them but has to restore them before returning)
* `$gp` points to the middle of the 64k block of memory in the static data segment
* `$sp` points to the last location of the stack
* Distinction between *leaf* vs *nonleaf* subroutines:
  * Leaf: Do not call any other subroutines and do not use any memory space on the stack. As a result they don&#39;t build up a stack frame (and hence dont need to change `$sp`)
  * Leaf with data: Same as leaf but they require stack space, e.g.: for local variables. They will push a stack frame but can omit stack frame sections they do not need
  * Nonleaf: Those will call other subroutines. These one will most likely have a full fledged stack frame
* On Linux with PIC `$t9` is supposed to contain the address of the called function

```
              +                 +-------------------+  +-+
              |                 |                   |    |
              |                 +-------------------+    |
              |                 |                   |    |   Previous
              |                 +-------------------+    +-&gt; Stack
              |                 |                   |    |   Frame
              |                 +-------------------+    |
              |                 |                   |    |
              |                 +-------------------+  +-+
              |                 |  local data x─1   |  +-+
              |                 +-------------------+    |
              |                 |                   |    |
              |                 +-------------------+    |
              |                 |  local data 0     |    |
              |                 +-------------------+    |
              |                 |  empty            |    |
    Stack     |                 +-------------------+    |
    Growth    |                 |  return value     |    |
    Direction |                 +-------------------+    |
              |                 |  saved reg k─1    |    |
              |                 +-------------------+    |   Current
              |                 |                   |    +-&gt; Stack
              |                 +-------------------+    |   Frame
              |                 |  saved reg 0      |    |
              |                 +-------------------+    |
              |                 |  arg n─1          |    |
              |                 +-------------------+    |
              |                 |                   |    |
              |                 +-------------------+    |
              |                 |  arg 4            |    |
              |                 +-------------------+    |
              |                 |  arg 3            |    |
              |                 +-------------------+    |
              |                 |  arg 2            |    |
              |                 +-------------------+    |
              |                 |  arg 1            |    |
              |                 +-------------------+    |
              |                 |  arg 0            |    |
              v                 +-------------------+  +-+
                                          |
                                          |
                                          v

```

&lt;h3 id=&quot;heading--mips-common&quot;&gt;Common Operations &lt;/h3&gt;

### 

There are a bunch of very common operations and if you&#39;re already familiar with other assembly languages you&#39;ll catch on quickly. Here are a selected few to give you a head start for part 2 of this series:

```
+------------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
|  Mnemonic        |  Full name                                         |  Syntax                 |  Operation                                               |
+------------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
|  ADD             |  Add (with overflow)                               |  add $a, $b, $c         |  $a = $b + $c                                            |
+---+--------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
    |  ADDI        |  Add immediate (with overflow)                     |  addi $a, $b, imm       |  $a = $b + imm                                           |
    +--------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
    |  ADDIU       |  Add immediate unsigned (no overflow)              |  addiu $a, $b, imm      |  see ADDI                                                |
    +--------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
    |  ADDU        |  Add unsigned (no overflow)                        |  addu $a, $b, $c        |  see ADD                                                 |
+---+--------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
|  AND*            |  Bitwise and                                       |  and $a, $b, $c         |  $a = $b &amp; $c                                            |
+------------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
|  B**             |  Branch to offset unconditionally                  |  b offset               |  goto offset                                             |
+---+--------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
    |  BEQ         |  Branch on equal                                   |  beq $a, $b, offset     |  if $a == $t goto offset                                 |
    +---+----------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
        |  BEQZ    |  Branch on equal to zero                           |  beqz $a, offset        |  if $a == 0 goto offset                                  |
    +---+----------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
    |  BGEZ        |  Branch on greater than or equal to zero           |  bgez $a, offset        |  if $a &gt;= 0 goto offset                                  |
    +---+----------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
        |  BGEZAL  |  Branch on greater than or equal to zero and link  |  bgezal $a, offset      |  if $a &gt;= 0: $ra = PC+8 and goto offset                  |
    +---+----------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
    |  BAL         |  Branch and link                                   |  bal offset             |  $ra=PC+8 and goto offset                                |
    +--------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
    |  BNE         |   Branch on not equal                              |  bne $a, $b, offset     |  if $a != $b: goto offset                                |
+---+--------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
|  DIV(U)          |  Divide (unsigned)                                 |  div $a, $b             |  $LO = $s/$t, $HI = $s%$t (LO/HI are special registers)  |
+------------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
|  J**             |  Jump                                              |  j target               |  PC=target                                               |
+---+--------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
    |  JR          |  Jump register                                     |  jr target              |  PC=$register                                            |
    +--------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
    |  JALR        |  Jump and link register                            |  jalr target            |  $ra=PC+8, PC=$register                                  |
+---+--------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
|  L(B/W)          |   Load (byte/word)                                 |  l(b/w) $a, offset($b)  |  $a = memory[$b + offset]                                |
+---+--------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
    |  LWL         |  Load word left                                    |  lwl $a, offset(base)   |                                                          |
    +--------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
    |  LWR         |  Load word right                                   |  lwr $a, offset(base)   |                                                          |
+---+--------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
|  OR*             |  Bitewise or                                       |  or $a, $b, $c          |  $a = $b|$c                                              |
+------------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
|  S(B/W)          |  Store (byte/word)                                 |  s(w/b) $a, offset($b)  |  memory[$b + offset] = $a                                |
+------------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
|  SLL**           |  Shift left logical                                |  sll $a, $b, h          |  $a = $b &lt;&lt; h                                            |
+------------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
|  SRL**           |  Shift right logical                               |   srl $a, $b, h         |  $a = $b &gt;&gt; h                                            |
+------------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
| SYSCALL          |  System call                                       |  syscall                |  PC+=4                                                   |
+------------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
|  XOR*            |  Bitwise exclusive or                              |  xor $a, $b, $c         |  $a = $b^$c                                              |
+------------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
```

*Note*: Those who do not explicitly state a change in PC can be assumed to have PC+=4 upon execution.
*Note1*: Those marked with an asterisk (*) also have at least one immediate version.
*Note2*: Those marked with a double asterisk (**) have a multitude of other variants!
*Note4*: The `ADD` variants only have `SUB(U)` as a counterpart!
*Note5*: The `DIV` variants have a `MULT(U)` counterpart.
*Note6*: The general difference between `j` and `b` instructions is that branching uses PC-relative displacements, whereas jumps use absolute addresses. This is rather important when you consider PIC.


Okay now that I lost all of you we&#39;ll end it here with the initial somewhat dry recon phase. However, it is a necessary evil to learn more about our target. Finally, keep in mind that the above MIPS32 assembly table is only a superset of all available instructions. However, even if you are not familiar with MIPS assembly the table above should be enough to follow along in part 2!
See you in part 2 where we will deep dive into the `imgdecrypt` binary in IDA :).

~~Stay tuned.. Part 2 will be linked here once its available.~~

## &gt;&gt; [Part 2 is available as of now!](https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-static-analysis-of-the-decryption-routine-part-2-1)


&lt;h2 id=&quot;heading--refs&quot;&gt;References &lt;/h2&gt;


* [MIPS® Architecture for Programmers Volume II-A: The MIPS32® Instruction Set Manual](https://s3-eu-west-1.amazonaws.com/downloads-mips/documents/MD00086-2B-MIPS32BIS-AFP-6.06.pdf)
* [MIPS32® Instruction Set Quick Reference](https://s3-eu-west-1.amazonaws.com/downloads-mips/documents/MD00565-2B-MIPS32-QRC-01.01.pdf)
* [MIPS Instruction Reference](http://www.mrc.uidaho.edu/mrc/people/jff/digital/MIPSir.html)
* [MIPS Architecture and Assembly Language Overview](https://minnie.tuhs.org/CompArch/Resources/mips_quick_tutorial.html)</description>
    
    <lastBuildDate>Mon, 06 Jul 2020 13:40:23 +0000</lastBuildDate>
    <category>Reverse Engineering</category>
    <atom:link href="https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/21943.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Breaking the D-Link DIR3060 Firmware Encryption - Recon - Part 1</title>
        <dc:creator><![CDATA[ricksanchez]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 121 days. New replies are no longer allowed.</p>
          <p><a href="https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/21943/11">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/21943/11</link>
        <pubDate>Sun, 25 Oct 2020 22:40:45 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-21943-11</guid>
        <source url="https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/21943.rss">Breaking the D-Link DIR3060 Firmware Encryption - Recon - Part 1</source>
      </item>
      <item>
        <title>Breaking the D-Link DIR3060 Firmware Encryption - Recon - Part 1</title>
        <dc:creator><![CDATA[messede]]></dc:creator>
        <description><![CDATA[
            <p>thanks for the heads up</p>
          <p><a href="https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/21943/10">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/21943/10</link>
        <pubDate>Mon, 06 Jul 2020 13:40:23 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-21943-10</guid>
        <source url="https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/21943.rss">Breaking the D-Link DIR3060 Firmware Encryption - Recon - Part 1</source>
      </item>
      <item>
        <title>Breaking the D-Link DIR3060 Firmware Encryption - Recon - Part 1</title>
        <dc:creator><![CDATA[ricksanchez]]></dc:creator>
        <description><![CDATA[
            <p>Part 2.1 is online <a class="mention" href="https://0x00sec.org/u/messede">@messede</a> <a class="mention" href="https://0x00sec.org/u/printf">@printf</a>  <a class="mention" href="https://0x00sec.org/u/statusredox">@statusredox</a> <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
          <p><a href="https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/21943/9">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/21943/9</link>
        <pubDate>Mon, 06 Jul 2020 11:37:38 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-21943-9</guid>
        <source url="https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/21943.rss">Breaking the D-Link DIR3060 Firmware Encryption - Recon - Part 1</source>
      </item>
      <item>
        <title>Breaking the D-Link DIR3060 Firmware Encryption - Recon - Part 1</title>
        <dc:creator><![CDATA[printf]]></dc:creator>
        <description><![CDATA[
            <p>Thanks for sharing, great article</p>
          <p><a href="https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/21943/8">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/21943/8</link>
        <pubDate>Thu, 02 Jul 2020 07:17:25 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-21943-8</guid>
        <source url="https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/21943.rss">Breaking the D-Link DIR3060 Firmware Encryption - Recon - Part 1</source>
      </item>
      <item>
        <title>Breaking the D-Link DIR3060 Firmware Encryption - Recon - Part 1</title>
        <dc:creator><![CDATA[messede]]></dc:creator>
        <description><![CDATA[
            <p>yea man i can’t wait for part 2</p>
          <p><a href="https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/21943/7">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/21943/7</link>
        <pubDate>Thu, 02 Jul 2020 04:08:31 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-21943-7</guid>
        <source url="https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/21943.rss">Breaking the D-Link DIR3060 Firmware Encryption - Recon - Part 1</source>
      </item>
      <item>
        <title>Breaking the D-Link DIR3060 Firmware Encryption - Recon - Part 1</title>
        <dc:creator><![CDATA[ricksanchez]]></dc:creator>
        <description><![CDATA[
            <p>Thanks! Part 2 is on the way and should be available shortly. Just finishing things up <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
          <p><a href="https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/21943/6">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/21943/6</link>
        <pubDate>Wed, 01 Jul 2020 10:47:31 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-21943-6</guid>
        <source url="https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/21943.rss">Breaking the D-Link DIR3060 Firmware Encryption - Recon - Part 1</source>
      </item>
      <item>
        <title>Breaking the D-Link DIR3060 Firmware Encryption - Recon - Part 1</title>
        <dc:creator><![CDATA[statusredox]]></dc:creator>
        <description><![CDATA[
            <p>Was really nice to read this! Waiting for part 2.</p>
          <p><a href="https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/21943/5">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/21943/5</link>
        <pubDate>Wed, 01 Jul 2020 10:27:35 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-21943-5</guid>
        <source url="https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/21943.rss">Breaking the D-Link DIR3060 Firmware Encryption - Recon - Part 1</source>
      </item>
      <item>
        <title>Breaking the D-Link DIR3060 Firmware Encryption - Recon - Part 1</title>
        <dc:creator><![CDATA[c0z]]></dc:creator>
        <description><![CDATA[
            <p>Reading this is so much more entertaining than listening to a broken English webcast of a virtual talk that talked about SS7 which was already discussed here. Thank god for 0x00sec</p>
          <p><a href="https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/21943/4">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/21943/4</link>
        <pubDate>Sat, 27 Jun 2020 20:24:16 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-21943-4</guid>
        <source url="https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/21943.rss">Breaking the D-Link DIR3060 Firmware Encryption - Recon - Part 1</source>
      </item>
      <item>
        <title>Breaking the D-Link DIR3060 Firmware Encryption - Recon - Part 1</title>
        <dc:creator><![CDATA[ricksanchez]]></dc:creator>
        <description><![CDATA[
            <p>Wait for part 2 in a few days. I’ll push everything to a repo <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
          <p><a href="https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/21943/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/21943/3</link>
        <pubDate>Fri, 26 Jun 2020 15:18:55 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-21943-3</guid>
        <source url="https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/21943.rss">Breaking the D-Link DIR3060 Firmware Encryption - Recon - Part 1</source>
      </item>
      <item>
        <title>Breaking the D-Link DIR3060 Firmware Encryption - Recon - Part 1</title>
        <dc:creator><![CDATA[messede]]></dc:creator>
        <description><![CDATA[
            <p>Could  you Please share   the imgdecrypt binary <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
          <p><a href="https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/21943/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/21943/2</link>
        <pubDate>Fri, 26 Jun 2020 14:12:16 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-21943-2</guid>
        <source url="https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/21943.rss">Breaking the D-Link DIR3060 Firmware Encryption - Recon - Part 1</source>
      </item>
      <item>
        <title>Breaking the D-Link DIR3060 Firmware Encryption - Recon - Part 1</title>
        <dc:creator><![CDATA[ricksanchez]]></dc:creator>
        <description><![CDATA[
            <p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/6/67a8100e33e070430b0696386abfe334a5312196.png" data-download-href="/uploads/short-url/eMZfDkg9YsQ6a9ys3DkxEtsRfme.png?dl=1" title="bb"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/6/67a8100e33e070430b0696386abfe334a5312196_2_682x500.png" alt="bb" data-base62-sha1="eMZfDkg9YsQ6a9ys3DkxEtsRfme" width="682" height="500" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/6/67a8100e33e070430b0696386abfe334a5312196_2_682x500.png, /uploads/default/original/2X/6/67a8100e33e070430b0696386abfe334a5312196.png 1.5x, /uploads/default/original/2X/6/67a8100e33e070430b0696386abfe334a5312196.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/6/67a8100e33e070430b0696386abfe334a5312196_2_10x10.png"></a></div><p></p>
<p>Recently we came across some firmware samples from D-Link routers that we were unable to unpack properly. Luckily we got our hands on an older, cheaper but similar device (DIR882) that we were able to analyze more closely. The goal is to find a way to mitigate the firmware encryption that was put in place to prevent tampering and static analysis. This series highlights the results and necessary steps to write a custom decryption routine that actually works for a bunch of other models as well but more about that later on. First let’s take a look at the problem.</p>
<h3>Table of Contents</h3>
<ul>
<li><a href="https://0x00sec.org#heading--the-problem">The Problem</a></li>
<li><a href="https://0x00sec.org#heading--the-attempt">The Attempt</a></li>
<li>
<a href="https://0x00sec.org#heading--the-solution">The Solution</a>
<ul>
<li><a href="https://0x00sec.org#heading--binary-recon">Binary Reconnaissence</a></li>
</ul>
</li>
<li><a href="https://0x00sec.org#heading--inter-sum">Intermediate Summary</a></li>
<li>
<a href="https://0x00sec.org#heading--mips-primer">Primer on MIPS32 disassembly</a>
<ul>
<li><a href="https://0x00sec.org#heading--mips-regs">Registers</a></li>
<li><a href="https://0x00sec.org#heading--mips-common">Common Operations</a></li>
</ul>
</li>
<li><a href="https://0x00sec.org#heading--refs">References</a></li>
</ul>
<hr>
<h2 id="heading--the-problem">The Problem: </h2>
<p>The latest D-Link 3060 firmware (as of time of writing) can be downloaded from <a href="https://support.dlink.com/productinfo.aspx?m=DIR-3060-US">here</a>. I’ll be examining <em>v1.02B03</em>, which was released on 10/22/19. A brief initial analysis shows the following:</p>
<pre><code class="lang-auto">&gt; md5sum DIR-3060_RevA_Firmware111B01.bin
86e3f7baebf4178920c767611ec2ba50  DIR3060A1_FW102B03.bin

&gt; file DIR-3060_RevA_Firmware111B01.bin
DIR3060A1_FW102B03.bin: data

&gt; binwalk DIR-3060_RevA_Firmware111B01.bin

DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------

&gt; hd -n 128 DIR-3060_RevA_Firmware111B01.bin
00000000  53 48 52 53 01 13 1f 9e  01 13 1f a0 67 c6 69 73  |SHRS........g.is|
00000010  51 ff 4a ec 29 cd ba ab  f2 fb e3 46 2e 97 e7 b1  |Q.J.)......F....|
00000020  56 90 b9 16 f8 0c 77 b8  bf 13 17 46 7b e3 c5 9c  |V.....w....F{...|
00000030  39 b5 59 6b 75 8d b8 b0  a3 1d 28 84 33 13 65 04  |9.Yku.....(.3.e.|
00000040  61 de 2d 56 6f 38 d7 eb  43 9d d9 10 eb 38 20 88  |a.-Vo8..C....8 .|
00000050  1f 21 0e 41 88 ff ee aa  85 46 0e ee d7 f6 23 04  |.!.A.....F....#.|
00000060  fa 29 db 31 9c 5f 55 68  12 2e 32 c3 14 5c 0a 53  |.).1._Uh..2..\.S|
00000070  ed 18 24 d0 a6 59 c0 de  1c f3 8b 67 1d e6 31 36  |..$..Y.....g..16|
00000080
</code></pre>
<p>So all we got from the file command is that we have some form of (binary) data file at hand, which is not very useful. Our goto choice for initial recon: binwalk is also unable to identify any file sections within the firmware image, noteven any false positives. Lastly the hex dump of the first 128 bytes shows seemingly random data right from offset 0x0. All of these are indicators of an encrypted image, which an entropy analysis can confirm:</p>
<pre><code class="lang-auto">&gt; binwalk -E DIR-3060_RevA_Firmware111B01.bin

DECIMAL       HEXADECIMAL     ENTROPY
--------------------------------------------------------------------------------
0             0x0             Rising entropy edge (0.978280)
</code></pre>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/e/efea4f73701711a5db4d8ef33c8d39ccbf4c4846.png" alt="init_Entropy" data-base62-sha1="yeo7D2bEvDgC3oVC2PNAxL77JwW" width="" height=""></p>
<p>There’s not a single drop in the entropy curve leaving no room for us to extract any kind of information about the target…</p>
<h2 id="heading--the-attempt">The Attempt: </h2>
<p>As we were reluctant to buy the <a href="https://www.dlink.com/en/products/dir-3060-exo-ac3000-smart-mesh-wi-fi-router">D-Link DIR 3060</a> for around ~$200 we checked similar models from D-Link that were on the cheaper side with the goal to find at least one alternative that deploys the same encryption scheme. In the end we came across the <a href="https://www.dlink.com/en/products/dir-882-exo-ac2600-mu-mimo-wi-fi-router">D-Link DIR 882</a>, which was considerable cheaper.</p>
<p>On a side note, even when we weren’t able to find a similar encryption scheme looking at different firmware headers could have provided some hints on what their goto mechanic to <em>‘secure’</em> their firmware looks like.</p>
<p>As we stumbled upon the DIR 882, we checked the firmware v1.30B10 that was released on 02/20/20 and it shows the same behavior as the one from the big brother the DIR3060, including the constant entropy of nearly 1. One thing that the invested reader might notice is the same 4-byte sequence at the start “SHRS”. We will come to that one later.</p>
<pre><code class="lang-auto">&gt; md5sum DIR_882_FW120B06.BIN
89a80526d68842531fe29170cbd596c3  DIR_882_FW120B06.BIN

&gt; file DIR_882_FW120B06.BIN
DIR_882_FW120B06.BIN: data

&gt; binwalk DIR_882_FW120B06.BIN

DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------

&gt; hd -n 128 DIR_882_FW120B06.BIN
00000000  53 48 52 53 00 d1 d9 a6  00 d1 d9 b0 67 c6 69 73  |SHRS........g.is|
00000010  51 ff 4a ec 29 cd ba ab  f2 fb e3 46 fd a7 4d 06  |Q.J.)......F..M.|
00000020  a4 66 e6 ad bf c4 9d 13  f3 f7 d1 12 98 6b 2a 35  |.f...........k*5|
00000030  1d 0e 90 85 b7 83 f7 4d  3a 2a 25 5a b8 13 0c fb  |.......M:*%Z....|
00000040  2a 17 7a b2 99 04 60 66  eb c2 58 98 82 74 08 e3  |*.z...`f..X..t..|
00000050  54 1e e2 51 44 42 e8 d6  8e 46 6e 2c 16 57 d3 0b  |T..QDB...Fn,.W..|
00000060  07 d7 7c 9e 11 ec 72 1d  fb 87 a2 5b 18 ec 53 82  |..|...r....[..S.|
00000070  85 b9 84 39 b6 b4 dd 85  de f0 28 3d 36 0e be aa  |...9......(=6...|
00000080
</code></pre>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/6/6aa035d6fddfcea00b291058dc04ebeda99328d7.png" alt="dir882_entropy" data-base62-sha1="fdfRnddfZeblJAgBO6ix7y2TQUf" width="" height=""></p>
<p>Another thing this firmware confirms for us is that the same crypto scheme is still used in early 2020.</p>
<h2 id="heading--the-solution">The Solution: </h2>
<p>Once we acquired the DIR882 we were able to enter a serial console on the device and look around the file systems for any clues and candidates that handles the en-/decryption of firmware updates (Attaching to the UART console is out of scope for this article and not particular interesting as it involves no ‘hardware hacking’ besides attaching 4 cables…) We quickly were able to identify a suitable candidate:</p>
<pre><code class="lang-auto">&gt; file imgdecrypt
imgdecrypt: ELF 32-bit LSB executable, MIPS, MIPS32 rel2 version 1 (SYSV), dynamically linked, interpreter /lib/ld-, stripped

&gt; md5sum imgdecrypt
a5474af860606f035e4b84bd31fc17a1  imgdecrypt
</code></pre>
<p>As we were just interested in this particular binary we dumped it the cruelest way possible:</p>
<pre><code class="lang-auto">&gt; base64 &lt; imgdecrypt
</code></pre>
<p>After copying the output to our local machine and converting the base64 back to binary we can start taking a closer look!</p>
<h3 id="heading--binary-recon">Binary Reconnaissance: </h3>
<p>We have already seen above that we’re dealing with a 32-bit ELF binary for MIPS, which is dynamically linked (as expected) and stripped. Let’s see what good old <code>strings</code> can do for us here:</p>
<pre><code class="lang-auto">&gt; strings -n 10 imgdecrypt | uniq
/lib/ld-uClibc.so.0
[...]
SHA512_Init
SHA512_Update
SHA512_Final
RSA_verify
AES_set_encrypt_key
AES_cbc_encrypt
AES_set_decrypt_key
PEM_write_RSAPublicKey
OPENSSL_add_all_algorithms_noconf
PEM_read_RSAPublicKey
PEM_read_RSAPrivateKey
RSA_generate_key
EVP_aes_256_cbc
PEM_write_RSAPrivateKey
decrypt_firmare
encrypt_firmare
[...]
libcrypto.so.1.0.0
[...]
no image matic found
check SHA512 post failed
check SHA512 before failed %d %d
check SHA512 vendor failed
static const char *pubkey_n = "%s";
static const char *pubkey_e = "%s";
Read RSA private key failed, maybe the key password is incorrect
/etc_ro/public.pem
%s &lt;sourceFile&gt;
/tmp/.firmware.orig
0123456789ABCDEF
%s sourceFile destFile
[...]
</code></pre>
<p>Sweet! There is still a lot of useful stuff in there. I just removed the garbage lines indicated by the “[…]”. Most note-worthy are the following things:</p>
<ul>
<li>Uses uClibc and libcrypto</li>
<li>Calculates/Checks SHA512 hash digests</li>
<li>Uses AES_CBC mode to en-/decrypt things</li>
<li>Has an RSA certificate check with the certificate path pinned to /etc_ro/public.pem</li>
<li>The RSA private key is protected by a password</li>
<li>/tmp/.firmware.orig could be a hint towards where things get temporarily decrypted to</li>
<li>General usage of imgdecrypt binary</li>
</ul>
<h2 id="heading--inter-sum">Intermediate Summary: </h2>
<p>So far we already learned multiple interesting things that should help us further down the road!</p>
<ol>
<li>D-Link probably re-uses the same encryption scheme across multiple devices.</li>
<li>These devices are based on the MIPS32 architecture</li>
<li>(Access to a UART serial console on the DIR 882 is doable without a problem)</li>
<li>Linked against uClibc and libcrypto<br>
4.1 Potential usage of AES, RSA, and SHA512 routines</li>
<li>Binary seems to be responsible for both en- and decryption</li>
<li>There is a public certificate</li>
<li>The usage of imgdecrypt seems to be ./imgdecrypt myInFile</li>
<li>Usage of a /tmp/ path for storing results?</li>
</ol>
<p>Next up we will dive into the static analysis of the <code>imgdecrypt</code> binary to understand how firmware updates are controlled! But before that for those of you who feel a bit rusty/are new to MIPS32 assembly language here is a short primer on it.</p>
<h2 id="heading--mips-primer">Primer on MIPS32 disassembly: </h2>
<p>Most of you are most likely familiar with x86/x86_64 disassembly so here are a few general rules on how MIPS does things and how its different from the x86 world. First there are two calling conventions (O32 vs N32/N64). I’ll be discussing the O32 one as it seems to be the most common one around. Discussing all of these in depths would be out of scope for this article!</p>
<h3 id="heading--mips-regs">Registers</h3>
<p>In MIPS32 there are 32 registers you can use. The O32 calling convention defines them as follows:</p>
<pre><code class="lang-auto">+---------+-----------+------------------------------------------------+
|   Name  |   Number  |                  Usage                         |
+----------------------------------------------------------------------+
|  $zero  |  $0       |  Is always 0, writes to it are discarded.      |
+----------------------------------------------------------------------+
|  $at    |  $1       |  Assembler temporary register (pseudo instr.)  |
+----------------------------------------------------------------------+
| $v0─$v1 |  $2─$3    |  Function returns/expression evaluation        |
+----------------------------------------------------------------------+
| $a0─$a3 |  $4─$7    |  Function arguments, remaining are in stack    |
+----------------------------------------------------------------------+
| $t0─$t7 |  $8─$15   |  Temporary registers                           |
+----------------------------------------------------------------------+
| $s0─$s7 |  $16─$23  |  Saved temporary registers                     |
+----------------------------------------------------------------------+
| $t8─$t9 |  $24─$25  |  Temporary registers                           |
+----------------------------------------------------------------------+
| $k0─$k1 |  $26─$27  |  Reserved for kernel                           |
+----------------------------------------------------------------------+
|  $gp    |  $28      |  Global pointer                                |
+----------------------------------------------------------------------+
|  $sp    |  $29      |  Stack pointer                                 |
+----------------------------------------------------------------------+
|  $fp    |  $30      |  Frame pointer                                 |
+----------------------------------------------------------------------+
|  $ra    |  $31      |  Return address                                |
+---------+-----------+------------------------------------------------+
</code></pre>
<p>The most important things to remember are:</p>
<ul>
<li>First four function arguments are moved into <code>$a0 - $a3</code> while the remaining are placed on top of the stack</li>
<li>Function returns are placed in <code>$v0</code> and eventually in <code>$v1</code> when there is a second return value</li>
<li>Return addresses is stored in the <code>$ra</code> register when a function call is executed via jump and link (JAL) or jump and link register (JALR)</li>
<li>
<code>$sX</code> registers are preserved across procedure calls (subroutine can use them but has to restore them before returning)</li>
<li>
<code>$gp</code> points to the middle of the 64k block of memory in the static data segment</li>
<li>
<code>$sp</code> points to the last location of the stack</li>
<li>Distinction between <em>leaf</em> vs <em>nonleaf</em> subroutines:
<ul>
<li>Leaf: Do not call any other subroutines and do not use any memory space on the stack. As a result they don’t build up a stack frame (and hence dont need to change <code>$sp</code>)</li>
<li>Leaf with data: Same as leaf but they require stack space, e.g.: for local variables. They will push a stack frame but can omit stack frame sections they do not need</li>
<li>Nonleaf: Those will call other subroutines. These one will most likely have a full fledged stack frame</li>
</ul>
</li>
<li>On Linux with PIC <code>$t9</code> is supposed to contain the address of the called function</li>
</ul>
<pre><code class="lang-auto">              +                 +-------------------+  +-+
              |                 |                   |    |
              |                 +-------------------+    |
              |                 |                   |    |   Previous
              |                 +-------------------+    +-&gt; Stack
              |                 |                   |    |   Frame
              |                 +-------------------+    |
              |                 |                   |    |
              |                 +-------------------+  +-+
              |                 |  local data x─1   |  +-+
              |                 +-------------------+    |
              |                 |                   |    |
              |                 +-------------------+    |
              |                 |  local data 0     |    |
              |                 +-------------------+    |
              |                 |  empty            |    |
    Stack     |                 +-------------------+    |
    Growth    |                 |  return value     |    |
    Direction |                 +-------------------+    |
              |                 |  saved reg k─1    |    |
              |                 +-------------------+    |   Current
              |                 |                   |    +-&gt; Stack
              |                 +-------------------+    |   Frame
              |                 |  saved reg 0      |    |
              |                 +-------------------+    |
              |                 |  arg n─1          |    |
              |                 +-------------------+    |
              |                 |                   |    |
              |                 +-------------------+    |
              |                 |  arg 4            |    |
              |                 +-------------------+    |
              |                 |  arg 3            |    |
              |                 +-------------------+    |
              |                 |  arg 2            |    |
              |                 +-------------------+    |
              |                 |  arg 1            |    |
              |                 +-------------------+    |
              |                 |  arg 0            |    |
              v                 +-------------------+  +-+
                                          |
                                          |
                                          v

</code></pre>
<h3 id="heading--mips-common">Common Operations </h3>
<h3></h3>
<p>There are a bunch of very common operations and if you’re already familiar with other assembly languages you’ll catch on quickly. Here are a selected few to give you a head start for part 2 of this series:</p>
<pre><code class="lang-auto">+------------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
|  Mnemonic        |  Full name                                         |  Syntax                 |  Operation                                               |
+------------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
|  ADD             |  Add (with overflow)                               |  add $a, $b, $c         |  $a = $b + $c                                            |
+---+--------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
    |  ADDI        |  Add immediate (with overflow)                     |  addi $a, $b, imm       |  $a = $b + imm                                           |
    +--------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
    |  ADDIU       |  Add immediate unsigned (no overflow)              |  addiu $a, $b, imm      |  see ADDI                                                |
    +--------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
    |  ADDU        |  Add unsigned (no overflow)                        |  addu $a, $b, $c        |  see ADD                                                 |
+---+--------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
|  AND*            |  Bitwise and                                       |  and $a, $b, $c         |  $a = $b &amp; $c                                            |
+------------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
|  B**             |  Branch to offset unconditionally                  |  b offset               |  goto offset                                             |
+---+--------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
    |  BEQ         |  Branch on equal                                   |  beq $a, $b, offset     |  if $a == $t goto offset                                 |
    +---+----------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
        |  BEQZ    |  Branch on equal to zero                           |  beqz $a, offset        |  if $a == 0 goto offset                                  |
    +---+----------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
    |  BGEZ        |  Branch on greater than or equal to zero           |  bgez $a, offset        |  if $a &gt;= 0 goto offset                                  |
    +---+----------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
        |  BGEZAL  |  Branch on greater than or equal to zero and link  |  bgezal $a, offset      |  if $a &gt;= 0: $ra = PC+8 and goto offset                  |
    +---+----------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
    |  BAL         |  Branch and link                                   |  bal offset             |  $ra=PC+8 and goto offset                                |
    +--------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
    |  BNE         |   Branch on not equal                              |  bne $a, $b, offset     |  if $a != $b: goto offset                                |
+---+--------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
|  DIV(U)          |  Divide (unsigned)                                 |  div $a, $b             |  $LO = $s/$t, $HI = $s%$t (LO/HI are special registers)  |
+------------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
|  J**             |  Jump                                              |  j target               |  PC=target                                               |
+---+--------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
    |  JR          |  Jump register                                     |  jr target              |  PC=$register                                            |
    +--------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
    |  JALR        |  Jump and link register                            |  jalr target            |  $ra=PC+8, PC=$register                                  |
+---+--------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
|  L(B/W)          |   Load (byte/word)                                 |  l(b/w) $a, offset($b)  |  $a = memory[$b + offset]                                |
+---+--------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
    |  LWL         |  Load word left                                    |  lwl $a, offset(base)   |                                                          |
    +--------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
    |  LWR         |  Load word right                                   |  lwr $a, offset(base)   |                                                          |
+---+--------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
|  OR*             |  Bitewise or                                       |  or $a, $b, $c          |  $a = $b|$c                                              |
+------------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
|  S(B/W)          |  Store (byte/word)                                 |  s(w/b) $a, offset($b)  |  memory[$b + offset] = $a                                |
+------------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
|  SLL**           |  Shift left logical                                |  sll $a, $b, h          |  $a = $b &lt;&lt; h                                            |
+------------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
|  SRL**           |  Shift right logical                               |   srl $a, $b, h         |  $a = $b &gt;&gt; h                                            |
+------------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
| SYSCALL          |  System call                                       |  syscall                |  PC+=4                                                   |
+------------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
|  XOR*            |  Bitwise exclusive or                              |  xor $a, $b, $c         |  $a = $b^$c                                              |
+------------------+----------------------------------------------------+-------------------------+----------------------------------------------------------+
</code></pre>
<p><em>Note</em>: Those who do not explicitly state a change in PC can be assumed to have PC+=4 upon execution.<br>
<em>Note1</em>: Those marked with an asterisk (*) also have at least one immediate version.<br>
<em>Note2</em>: Those marked with a double asterisk (**) have a multitude of other variants!<br>
<em>Note4</em>: The <code>ADD</code> variants only have <code>SUB(U)</code> as a counterpart!<br>
<em>Note5</em>: The <code>DIV</code> variants have a <code>MULT(U)</code> counterpart.<br>
<em>Note6</em>: The general difference between <code>j</code> and <code>b</code> instructions is that branching uses PC-relative displacements, whereas jumps use absolute addresses. This is rather important when you consider PIC.</p>
<p>Okay now that I lost all of you we’ll end it here with the initial somewhat dry recon phase. However, it is a necessary evil to learn more about our target. Finally, keep in mind that the above MIPS32 assembly table is only a superset of all available instructions. However, even if you are not familiar with MIPS assembly the table above should be enough to follow along in part 2!<br>
See you in part 2 where we will deep dive into the <code>imgdecrypt</code> binary in IDA :).</p>
<p><s>Stay tuned… Part 2 will be linked here once its available.</s></p>
<h2>&gt;&gt; <a href="https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-static-analysis-of-the-decryption-routine-part-2-1">Part 2 is available as of now!</a>
</h2>
<h2 id="heading--refs">References </h2>
<ul>
<li><a href="https://s3-eu-west-1.amazonaws.com/downloads-mips/documents/MD00086-2B-MIPS32BIS-AFP-6.06.pdf">MIPS® Architecture for Programmers Volume II-A: The MIPS32® Instruction Set Manual</a></li>
<li><a href="https://s3-eu-west-1.amazonaws.com/downloads-mips/documents/MD00565-2B-MIPS32-QRC-01.01.pdf">MIPS32® Instruction Set Quick Reference</a></li>
<li><a href="http://www.mrc.uidaho.edu/mrc/people/jff/digital/MIPSir.html">MIPS Instruction Reference</a></li>
<li><a href="https://minnie.tuhs.org/CompArch/Resources/mips_quick_tutorial.html">MIPS Architecture and Assembly Language Overview</a></li>
</ul>
          <p><a href="https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/21943/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/21943/1</link>
        <pubDate>Fri, 26 Jun 2020 06:29:33 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-21943-1</guid>
        <source url="https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/21943.rss">Breaking the D-Link DIR3060 Firmware Encryption - Recon - Part 1</source>
      </item>
  </channel>
</rss>
