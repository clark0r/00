<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Game Hacking: WinXP Minesweeper</title>
    <link>https://0x00sec.org/t/game-hacking-winxp-minesweeper/1266</link>
    <description>What&#39;s good, peeps? Before I start this topic, I&#39;d like to sincerely apologise for the _huge_ delay. At the time (before my exams started), I was hyped to deliver a second instalment of game hacking to the forums but I had lost interest due to the exhaustion gathered from exam preparation and participation.  Let&#39;s finally get this topic started.

Welcome to my second topic on game hacking where I will be discussing how to hack Windows XP&#39;s Minesweeper. The Windows XP version I will be using is SP3 which (starting with SP2) includes [DEP](https://en.wikipedia.org/wiki/Executable_space_protection#Windows). On the contrary, Windows XP does not support [ASLR](https://en.wikipedia.org/wiki/Address_space_layout_randomization#Microsoft_Windows) which was only introduced in Vista. The addresses I will be using will be hardcoded so keep in mind that this may not work in environments where ASLR is enabled. In those situations, dynamically retrieving the process&#39;s module base is a necessity but I will not be covering in this paper, but will do so if I ever present another game hacking write up.


### Pre-requisites and Recommendations

For those who are seeking an introduction to game hacking and wish to follow through and understand the paper, it is recommended that they be familiar with the assembly language (preferably x86 Intel) and a high level language which is able to access and manipulate memory such as C or C++. Unlike the first game hacking topic, this will include source code (written in MSVC++) to apply the hacks on demand so knowledge of the [WinAPI](https://msdn.microsoft.com/en-us/library/windows/desktop/ff818516(v=vs.85).aspx) is also recommended.

For everyone else, all that&#39;s required is some time to dedicate and a curious mind.


----------

## Freezing the Timer

### Debugging and Disassembly: Locating the Time

For those who are familiar with Minesweeper, the high scores are determined by the _fastest_ sweep time so, clearly the timer is definitely something we want to target. First of all, we need to fire up our trusty Cheat Engine (CE) (mine is version 6.6 but that shouldn&#39;t matter) and Minesweeper. In CE, go to `File -&gt; Open Process`, select the `winmine.exe` process from the list and press `Open`.

Now that Minesweeper is open and is loaded into CE, to be able to modify the time(r), we must locate where the value exists in memory. To do this, we have to let the timer run, then using CE, we attempt to find the value of the time by scanning the Minesweeper&#39;s process&#39;s memory. Start the game by pressing one of the cells and let it run until the time of, say `13` and while we wait, switch to CE and under `First Scan`, enter `13` into the edit box and prepare to press `First Scan` when the game&#39;s timer hits `13`. After first scanning, a list of address and their values will flood the left panel with the value of `13`, these are all of the existing values of `13` (of 4 bytes) in the process at the moment of scanning. If we scroll down a bit while the timer continues, we can see one of the addresses with red text.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/8/89010709fe05f00507e3afdc2009e9d4a1d0651d.JPG&quot; width=&quot;690&quot; height=&quot;292&quot;&gt;

The `Value` value is the same as the timer with a `Previous` value of what we first scanned. And still, while the timer on Minesweeper keeps increasing, so does the `Value` of address `0x0100579C`. We don&#39;t see any other addresses with the same property so we can safely assume that this is the address of where the time is stored. If we want to modify this time value, we have to open it up for debugging. Right-click the line and select `Find out what writes to this address`, agree to open the debugger and we will see one instruction `inc [0x0100579C]` in a new window. Select the line and click `Show disassembler` and we&#39;ll see the instructions at (and around) the address of where it is located in memory (`0x01002FF5`) in another new window. At the bottom, we can see the value of the time in a memory dump at `0x0100579C`.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/4/4a9a7c1c31b6670876721e292cbb361c4cb3e300.JPG&quot; width=&quot;690&quot; height=&quot;397&quot;&gt;

If we want to freeze the timer, we can right-click the highlighted line and select `Replace with code that does nothing`, AKA `nop`ing the instruction. At this point, the timer in the Minesweeper window will immediately freeze. If we wanted to restore the instruction, right-click the first `nop` and select `Restore with original code` and the timer will start incrementing again. From here, we can do whatever we wanted. We can set it to decrement the value by right-clicking, selecting `Assemble` and replacing `inc` with `dec` or change it directly in the memory dump to `42`, `69`, `420`, or whatever other significant integer in human history that lies between `0` and `999` inclusive.

### Coding the Hack

Before we can implement the hack, we need to be able to write to the process&#39;s memory. To write to a process, its handle must be obtained to enable [`WriteProcessMemory`](https://msdn.microsoft.com/en-us/library/windows/desktop/ms681674.aspx) but there are a few different ways of doing this. The method I chose retrieves the process handle through finding the window&#39;s handle which seemed to be a bit more simpler and appropriate so I opted for that instead of the standard process list enumeration.

```c
HANDLE GetWindowProcessHandle(LPWSTR lpWindowName, DWORD dwDesiredAccess) {
	DWORD dwProcessId = 0;
	HWND hFindWnd = FindWindow(NULL, lpWindowName);
	if (hFindWnd == NULL)
		return NULL;
	GetWindowThreadProcessId(hFindWnd, &amp;dwProcessId);
	return OpenProcess(dwDesiredAccess, FALSE, dwProcessId);
}
```
Now that we can get the process&#39;s handle, we can write to it using `WriteProcessMemory`:
```cpp
BOOL WriteMemory(LPVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize) {
	HANDLE hWinMineProc = GetWindowProcessHandle(L&quot;Minesweeper&quot;, PROCESS_VM_WRITE | PROCESS_VM_READ | PROCESS_VM_OPERATION);
	if (hWinMineProc == NULL)
		return Error(L&quot;Find Minesweeper window&quot;), FALSE;

	DWORD dwWritten = 0;
	BOOL bRet = WriteProcessMemory(hWinMineProc, lpBaseAddress, lpBuffer, nSize, &amp;dwWritten);

	CloseHandle(hWinMineProc);

	return bRet;
}
```
We have everything we need to write our time-freezing function which should be pretty simple. All we have to do is overwrite the instruction at `0x01002FF5` with `nop`s.
```cpp
#define ADDR_TIMER 0x1002FF5

__declspec(naked) VOID FreezeTimerShellcodeStart(VOID) {
	__asm {
		nop
		nop
		nop
		nop
		nop
		nop
	}
}

BOOL FreezeTimer(BOOL bFreeze) {
	DWORD dwShellcodeSize = 6;
	LPBYTE lpShellcode = malloc(dwShellcodeSize);
    if (lpShellcode == NULL)
        return FALSE;

	if (bFreeze == TRUE)
		memcpy(lpShellcode, FreezeTimerShellCodeStart, dwShellcodeSize);
	else
		memcpy(lpShellcode, UnfreezeTimerShellcodeStart, dwShellcodeSize);

	BOOL bSuccess = WriteMemory((LPVOID)ADDR_TIMER, lpShellcode, dwShellcodeSize);
	if (bSuccess == FALSE)
		Error(L&quot;Inject timer shellcode&quot;);

	free(lpShellcode);

	return bSuccess;
}
```
If we want to restore the instruction, all we have to do is rewrite the original opcodes back into the same memory address:
```cpp
#define db(x) __emit(x)

__declspec(naked) VOID UnfreezeTimerShellcodeStart(VOID) {
    // MSVC++ producing incorrect opcodes
    // so I hardcoded the original bytes
	__asm {
		db(0xFF)
		db(0x05)
		db(0x9C)
		db(0x57)
		db(0x00)
		db(0x01)
	}
}
```


----------

## Exposing the Mine Field

### Debugging and Disassembly: Locating the Mine Field

The main goal of this game is to utilize hints to seek out and seek out all of the _safe_ cells on the given field. While these hints are great and all that, let&#39;s make our _own_ hints. This one requires a little bit more effort to trace and locate since it is not as straight-forward as the previous hack and needs a little knowledge of the WinAPI.

To start things off, CE might not be able to help us out in this situation so we need a proper debugger for this job. I&#39;ll be using Ollydbg but any debugger should be fine. Open up the `winmine.exe` in the debugger, place a breakpoint at the entry point, run it until it hits the breakpoint. When an application wants to draw and use graphics, it must use the `User32.dll` along with the [`Windows GDI (GDI32.dll)`](https://msdn.microsoft.com/en-us/library/windows/desktop/dd145203(v=vs.85).aspx) both which export functions to enable such tasks. One of these functions is [`BeginPaint`](https://msdn.microsoft.com/en-us/library/windows/desktop/dd183362(v=vs.85).aspx) which sets up a particular window for painting. We know that Minesweeper has to draw something so let&#39;s search for the function in the imports list (`Ctrl+N` on Ollydbg) and find references to `BeginPaint` (right-click and select `Find references`). Select the line and set a breakpoint on it so the debugger will stop when the game starts to lay out its graphical components.

Run the program and the debugger will pause with the Minesweeper showing a blank window. Now, we should follow a typical reverse engineering approach to swiftly find the set of procedures which draw out the cells. Carefully begin to step _over_ each instruction until we see something occur on the application, in our case, when we see the cells start to or have already been drawn out, stop stepping, place a breakpoint on the function call which produced the outcome, remove the previous breakpoint and restart the application, this time, stepping _into_ the function with the new breakpoint. Repeat this process until we pinpoint the location of what we want.

Here is the result:

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/4/440d161a043df3702f8aa4c8aedeab38c5117321.JPG&quot; width=&quot;690&quot; height=&quot;407&quot;&gt;

The [`BitBlt`](https://msdn.microsoft.com/en-us/library/windows/desktop/dd183370(v=vs.85).aspx) function is what draws out each cell of the mine field. If we analyze this set of instructions, we will see that it looks like some form of while loop where `esi` is a counter starting at `0` and `ebx` is the array beginning at `0x1005340`. It also seems like the cell&#39;s source image (a blank cell, a flag, a mine, etx.) is dependent on the value at `ds:[ebx+esi]`.

To satisfy our hypotheses, we will continue running the game normally and this time, we will dump the memory starting at `0x1005340` and see what it looks like.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/8/8ac0d770830cabd92f0f6af8a4fe679ead32514a.JPG&quot; width=&quot;670&quot; height=&quot;358&quot;&gt;

Clearly, there is a very similar layout in the game and in the memory dump. We can match the `1`s with the `41`s and the flag with the `8E`. There&#39;s a bit of an issue with correctly formatting width the dump because we can slightly recognize that the border of the mine field is represented by the `10`s and the empty/unused cells are `0F`s.

### Coding the Hack

In the previous hack, we learned how to write to the process, but this time, we need to read from the process in order to get the information about the array. There is a reading counterpart called [`ReadProcessMemory`](https://msdn.microsoft.com/en-us/library/windows/desktop/ms680553(v=vs.85).aspx) that we can use for this job and it is used exactly the same way we used `WriteProcessMemory`.
```cpp
BOOL ReadMemory(LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize) {
	HANDLE hWinMineProc = GetWindowProcessHandle(L&quot;Minesweeper&quot;, PROCESS_VM_READ);
	if (hWinMineProc == NULL)
		return Error(L&quot;Find Minesweeper window&quot;), FALSE;

	DWORD dwRead = 0;
	BOOL bRet = ReadProcessMemory(hWinMineProc, lpBaseAddress, lpBuffer, nSize, &amp;dwRead);
	
	CloseHandle(hWinMineProc);

	return bRet;
}
```
It is now just a simple matter of looping and reading the memory of Minesweeper and printing it out with some nice visual formatting. Keep in mind that whenever a cell is activated, its value in memory will change so the loop must be continuous to update these values.
```cpp
#define CELL_EMPTY L&quot; &quot;
#define CELL_NOT_MINE L&quot;o&quot;
#define CELL_MINE L&quot;x&quot;
#define CELL_FLAG L&quot;!&quot;
#define CELL_UNKNOWN L&quot;?&quot;
#define CELL_BORDER L&quot;*&quot;

// console colors
#define CELL_DIGIT_COLOUR FOREGROUND_GREEN | FOREGROUND_INTENSITY
#define CELL_NOT_MINE_COLOUR FOREGROUND_GREEN
#define CELL_MINE_COLOUR FOREGROUND_RED | FOREGROUND_INTENSITY
#define CELL_FLAG_COLOUR FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY
#define CELL_UNKNOWN_COLOUR FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_INTENSITY
#define CELL_BORDER_COLOUR FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY

VOID PrintDigit(int nDigit) {
	CONSOLE_SCREEN_BUFFER_INFO csbi;
	GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &amp;csbi);
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), CELL_DIGIT_COLOUR);

	wprintf(L&quot;%d&quot;, nDigit);

	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), csbi.wAttributes);
}

VOID PrintCell(LPWSTR c, WORD wAttributes) {
	CONSOLE_SCREEN_BUFFER_INFO csbi;
	GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &amp;csbi);
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), wAttributes);

	wprintf(L&quot;%s&quot;, c);

	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), csbi.wAttributes);
}

VOID PrintMineField(VOID) {
	BYTE bCell = 0;
	DWORD dwMineFieldSize = ADDR_MINE_FIELD_END - ADDR_MINE_FIELD_START;
	LPBYTE lpMineFieldBuffer = malloc(dwMineFieldSize);
	if (lpMineFieldBuffer == NULL)
	    return;
	    
    // I have opted to threading this function
    // since my hacktool includes a GUI
	while (bThreadActive == TRUE) {
		BOOL bSuccess = ReadMemory((LPVOID)ADDR_MINE_FIELD_START, lpMineFieldBuffer, dwMineFieldSize);
		if (bSuccess == FALSE) {
            // ignore this, this is also part of the GUI
			SendMessage(hWnd, WM_COMMAND, ID_HIDE_MINES, 0);
			return;
		}

		for (DWORD j = 0, i = 0, bCell = lpMineFieldBuffer[i]; i &lt; dwMineFieldSize; i++, j++, bCell = lpMineFieldBuffer[i]) {
            // new line on the mine field
			if (j == 0x20) {
				wprintf(L&quot;\n&quot;);
				j = 0;
			}

            // these are most (if not all) of the values of the cells
			int nDigit = bCell &amp; 0x1F;
			if (bCell == 0x8F || bCell == 0x8D)
				PrintCell(CELL_MINE, CELL_MINE_COLOUR);
			else if (bCell == 0x10)
				PrintCell(CELL_BORDER, CELL_BORDER_COLOUR);
			else if (bCell == 0x8E || bCell == 0x0E)
				PrintCell(CELL_FLAG, CELL_FLAG_COLOUR);
			else if (bCell == 0x0D)
				PrintCell(CELL_UNKNOWN, CELL_UNKNOWN_COLOUR);
			else if (nDigit == 0x0)
				PrintCell(CELL_EMPTY, CELL_NOT_MINE_COLOUR);
			else if (nDigit &gt;= 0x1 &amp;&amp; nDigit &lt;= 0x9)
				PrintDigit(nDigit);
			else
				PrintCell(CELL_NOT_MINE, CELL_NOT_MINE_COLOUR);
		}

		Sleep(1000);
		///////////////////////////////
		///////    YUCK!!!!    ////////
		///////////////////////////////
		system(&quot;cls&quot;);
	}

	free(lpMineFieldBuffer);
}
```
Here is an example of what it should look like:

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/e/e8b1716d88d2bcdcf4626b474ccea5e4e25515ed.JPG&quot; width=&quot;675&quot; height=&quot;378&quot;&gt;



----------
## Challenge

I have provided the basic fundamentals on how to hack a game such as memory scanning with CE and reading from and writing to an external process so for those who want in, see if you can mess around with the number of flags and implement it into your own hacktool. Be creative.



----------
## Conclusion

From what we&#39;ve seen, game hacking is on par with reverse engineering. In fact, I think of it as a subcategory of reverse engineering as it exercises the same skillset and mindset (also see [previous game hacking topic](https://0x00sec.org/t/game-hacking-3d-pinball-space-cadet/1232)). In contrast, game hacking is probably more fun than just the typical reverse engineering crackme because we get to physically play around with our hacks even _after_ successfully breaking open the innards. It is truly an amusing and satisfying feeling.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/d/d4085ec135b5461f1ab956ccccac9ad22a5419e6.JPG&quot; width=&quot;511&quot; height=&quot;499&quot;&gt;
\#nohacks \#legit \#minesweepergod

Complete source code on [GitLab](https://git.0x00sec.org/93aef0ce4dd141ece6f5/0x00sec-code-dump/blob/master/MineHack3r/src/minehack3r.c) or [GitHub](https://github.com/NtRaiseHardError/MineHack3r) (includes spoilers to the challenge!).
``
``
_-- dtm_</description>
    
    <lastBuildDate>Mon, 11 Dec 2017 19:13:23 +0000</lastBuildDate>
    <category>Reverse Engineering</category>
    <atom:link href="https://0x00sec.org/t/game-hacking-winxp-minesweeper/1266.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Game Hacking: WinXP Minesweeper</title>
        <dc:creator><![CDATA[_py]]></dc:creator>
        <description><![CDATA[
            
          <p><a href="https://0x00sec.org/t/game-hacking-winxp-minesweeper/1266/7">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/game-hacking-winxp-minesweeper/1266/7</link>
        <pubDate>Tue, 12 Dec 2017 21:03:14 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1266-7</guid>
        <source url="https://0x00sec.org/t/game-hacking-winxp-minesweeper/1266.rss">Game Hacking: WinXP Minesweeper</source>
      </item>
      <item>
        <title>Game Hacking: WinXP Minesweeper</title>
        <dc:creator><![CDATA[AquilaXP]]></dc:creator>
        <description><![CDATA[
            <p>Hi dtm,</p>
<p>Can you RE Internet Games MSN Gaming Zone from Windows XP to work also in Windows 8, 8.1 and 10 32-bit and 64-bit version?</p>
<p>I want to get old-fashioned but familiar Windows XP games working on Windows 10.<br>
I’m not referring to FreeCell, Hearts, Minesweeper, Solitaire, Spider Solitaire and Microsoft 3D Pinball - Space Cadet 1.0 Games from Windows XP that require no patch (can be easily ported to Windows 7, 8, 8.1, &amp; 10).</p>
<p>The versions that I’m interested are these ones:</p>
<ul>
<li>Internet Backgammon</li>
<li>Internet Checkers</li>
<li>Internet Hearts</li>
<li>Internet Reversi</li>
<li>Internet Spades.</li>
</ul>
<p>I found out how to get MSN Gaming Zone from Win XP working on Win7 from this post here:<br>
</p><aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="http://cafeauaneagra.blogspot.com/favicon.ico" class="site-icon" width="16" height="16">
      <a href="http://cafeauaneagra.blogspot.com/2012/04/reversi-strategia-instalarii-pe-windows.html" target="_blank" rel="noopener nofollow ugc">cafeauaneagra.blogspot.com</a>
  </header>
  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:556/292;"><img src="https://0x00sec.s3.amazonaws.com/original/2X/5/5d705541fa3ea1d17740f13b58d3b223e92bd012.png" class="thumbnail" width="556" height="292"></div>

<h3><a href="http://cafeauaneagra.blogspot.com/2012/04/reversi-strategia-instalarii-pe-windows.html" target="_blank" rel="noopener nofollow ugc">Reversi - Strategia instalarii pe Windows 7</a></h3>

<p>Decizia companiei Microsoft de a elimina Reversi din setul de jocuri  on-line care se pot instala pe Windows 7,&nbsp; nu cred ca a adus cine stie...</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>
<p></p>
<p>The XP Internet Games works on Windows Vista, 7 and Windows Server 2008, but not on Windows 8 or 10.</p>
<p>When I’m trying to run “Internet Backgammon” executable from WinXP, I get this message: “Backgammon is unable to start. Close some other programs and try again, or try reinstalling Backgammon using Add/Remove Programs in the Control Panel.”</p>
<p>Can you patch (bypass OS restriction of) the Internet Games MSN Gaming Zone from Windows XP to work also in Windows 8, 8.1 and 10 32-bit and 64-bit versions?<br>
Maybe you will found a way to remove the version checking and patch these files.</p>
<p>Please let me know if you are interested in this project.</p>
          <p><a href="https://0x00sec.org/t/game-hacking-winxp-minesweeper/1266/6">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/game-hacking-winxp-minesweeper/1266/6</link>
        <pubDate>Mon, 11 Dec 2017 19:13:23 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1266-6</guid>
        <source url="https://0x00sec.org/t/game-hacking-winxp-minesweeper/1266.rss">Game Hacking: WinXP Minesweeper</source>
      </item>
      <item>
        <title>Game Hacking: WinXP Minesweeper</title>
        <dc:creator><![CDATA[dtm]]></dc:creator>
        <description><![CDATA[
            <p>It’ll be out in this or next week.</p>
          <p><a href="https://0x00sec.org/t/game-hacking-winxp-minesweeper/1266/4">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/game-hacking-winxp-minesweeper/1266/4</link>
        <pubDate>Mon, 23 Jan 2017 17:16:20 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1266-4</guid>
        <source url="https://0x00sec.org/t/game-hacking-winxp-minesweeper/1266.rss">Game Hacking: WinXP Minesweeper</source>
      </item>
      <item>
        <title>Game Hacking: WinXP Minesweeper</title>
        <dc:creator><![CDATA[SmartOne]]></dc:creator>
        <description><![CDATA[
            <p><a class="mention" href="https://0x00sec.org/u/dtm">@dtm</a> When will this be out? Waiting for it <img src="https://0x00sec.org/images/emoji/twitter/stuck_out_tongue.png?v=9" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:"></p>
          <p><a href="https://0x00sec.org/t/game-hacking-winxp-minesweeper/1266/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/game-hacking-winxp-minesweeper/1266/3</link>
        <pubDate>Mon, 23 Jan 2017 13:18:58 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1266-3</guid>
        <source url="https://0x00sec.org/t/game-hacking-winxp-minesweeper/1266.rss">Game Hacking: WinXP Minesweeper</source>
      </item>
      <item>
        <title>Game Hacking: WinXP Minesweeper</title>
        <dc:creator><![CDATA[dtm]]></dc:creator>
        <description><![CDATA[
            <p>Bump. Updated. WOOP.</p>
          <p><a href="https://0x00sec.org/t/game-hacking-winxp-minesweeper/1266/5">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/game-hacking-winxp-minesweeper/1266/5</link>
        <pubDate>Fri, 20 Jan 2017 03:28:27 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1266-5</guid>
        <source url="https://0x00sec.org/t/game-hacking-winxp-minesweeper/1266.rss">Game Hacking: WinXP Minesweeper</source>
      </item>
      <item>
        <title>Game Hacking: WinXP Minesweeper</title>
        <dc:creator><![CDATA[Luigi]]></dc:creator>
        <description><![CDATA[
            <p>You sir will destroy my childhood hahaha<br>
Waiting for the full topic</p>
          <p><a href="https://0x00sec.org/t/game-hacking-winxp-minesweeper/1266/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/game-hacking-winxp-minesweeper/1266/2</link>
        <pubDate>Tue, 17 Jan 2017 20:22:09 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1266-2</guid>
        <source url="https://0x00sec.org/t/game-hacking-winxp-minesweeper/1266.rss">Game Hacking: WinXP Minesweeper</source>
      </item>
      <item>
        <title>Game Hacking: WinXP Minesweeper</title>
        <dc:creator><![CDATA[dtm]]></dc:creator>
        <description><![CDATA[
            <p>What’s good, peeps? Before I start this topic, I’d like to sincerely apologise for the <em>huge</em> delay. At the time (before my exams started), I was hyped to deliver a second instalment of game hacking to the forums but I had lost interest due to the exhaustion gathered from exam preparation and participation.  Let’s finally get this topic started.</p>
<p>Welcome to my second topic on game hacking where I will be discussing how to hack Windows XP’s Minesweeper. The Windows XP version I will be using is SP3 which (starting with SP2) includes <a href="https://en.wikipedia.org/wiki/Executable_space_protection#Windows">DEP</a>. On the contrary, Windows XP does not support <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization#Microsoft_Windows">ASLR</a> which was only introduced in Vista. The addresses I will be using will be hardcoded so keep in mind that this may not work in environments where ASLR is enabled. In those situations, dynamically retrieving the process’s module base is a necessity but I will not be covering in this paper, but will do so if I ever present another game hacking write up.</p>
<h3>Pre-requisites and Recommendations</h3>
<p>For those who are seeking an introduction to game hacking and wish to follow through and understand the paper, it is recommended that they be familiar with the assembly language (preferably x86 Intel) and a high level language which is able to access and manipulate memory such as C or C++. Unlike the first game hacking topic, this will include source code (written in MSVC++) to apply the hacks on demand so knowledge of the <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ff818516(v=vs.85).aspx">WinAPI</a> is also recommended.</p>
<p>For everyone else, all that’s required is some time to dedicate and a curious mind.</p>
<hr>
<h2>Freezing the Timer</h2>
<h3>Debugging and Disassembly: Locating the Time</h3>
<p>For those who are familiar with Minesweeper, the high scores are determined by the <em>fastest</em> sweep time so, clearly the timer is definitely something we want to target. First of all, we need to fire up our trusty Cheat Engine (CE) (mine is version 6.6 but that shouldn’t matter) and Minesweeper. In CE, go to <code>File -&gt; Open Process</code>, select the <code>winmine.exe</code> process from the list and press <code>Open</code>.</p>
<p>Now that Minesweeper is open and is loaded into CE, to be able to modify the time®, we must locate where the value exists in memory. To do this, we have to let the timer run, then using CE, we attempt to find the value of the time by scanning the Minesweeper’s process’s memory. Start the game by pressing one of the cells and let it run until the time of, say <code>13</code> and while we wait, switch to CE and under <code>First Scan</code>, enter <code>13</code> into the edit box and prepare to press <code>First Scan</code> when the game’s timer hits <code>13</code>. After first scanning, a list of address and their values will flood the left panel with the value of <code>13</code>, these are all of the existing values of <code>13</code> (of 4 bytes) in the process at the moment of scanning. If we scroll down a bit while the timer continues, we can see one of the addresses with red text.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/8/89010709fe05f00507e3afdc2009e9d4a1d0651d.JPG" width="690" height="292"></p>
<p>The <code>Value</code> value is the same as the timer with a <code>Previous</code> value of what we first scanned. And still, while the timer on Minesweeper keeps increasing, so does the <code>Value</code> of address <code>0x0100579C</code>. We don’t see any other addresses with the same property so we can safely assume that this is the address of where the time is stored. If we want to modify this time value, we have to open it up for debugging. Right-click the line and select <code>Find out what writes to this address</code>, agree to open the debugger and we will see one instruction <code>inc [0x0100579C]</code> in a new window. Select the line and click <code>Show disassembler</code> and we’ll see the instructions at (and around) the address of where it is located in memory (<code>0x01002FF5</code>) in another new window. At the bottom, we can see the value of the time in a memory dump at <code>0x0100579C</code>.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/4/4a9a7c1c31b6670876721e292cbb361c4cb3e300.JPG" width="690" height="397"></p>
<p>If we want to freeze the timer, we can right-click the highlighted line and select <code>Replace with code that does nothing</code>, AKA <code>nop</code>ing the instruction. At this point, the timer in the Minesweeper window will immediately freeze. If we wanted to restore the instruction, right-click the first <code>nop</code> and select <code>Restore with original code</code> and the timer will start incrementing again. From here, we can do whatever we wanted. We can set it to decrement the value by right-clicking, selecting <code>Assemble</code> and replacing <code>inc</code> with <code>dec</code> or change it directly in the memory dump to <code>42</code>, <code>69</code>, <code>420</code>, or whatever other significant integer in human history that lies between <code>0</code> and <code>999</code> inclusive.</p>
<h3>Coding the Hack</h3>
<p>Before we can implement the hack, we need to be able to write to the process’s memory. To write to a process, its handle must be obtained to enable <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms681674.aspx"><code>WriteProcessMemory</code></a> but there are a few different ways of doing this. The method I chose retrieves the process handle through finding the window’s handle which seemed to be a bit more simpler and appropriate so I opted for that instead of the standard process list enumeration.</p>
<pre><code class="lang-auto">HANDLE GetWindowProcessHandle(LPWSTR lpWindowName, DWORD dwDesiredAccess) {
	DWORD dwProcessId = 0;
	HWND hFindWnd = FindWindow(NULL, lpWindowName);
	if (hFindWnd == NULL)
		return NULL;
	GetWindowThreadProcessId(hFindWnd, &amp;dwProcessId);
	return OpenProcess(dwDesiredAccess, FALSE, dwProcessId);
}
</code></pre>
<p>Now that we can get the process’s handle, we can write to it using <code>WriteProcessMemory</code>:</p>
<pre><code class="lang-cpp">BOOL WriteMemory(LPVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize) {
	HANDLE hWinMineProc = GetWindowProcessHandle(L"Minesweeper", PROCESS_VM_WRITE | PROCESS_VM_READ | PROCESS_VM_OPERATION);
	if (hWinMineProc == NULL)
		return Error(L"Find Minesweeper window"), FALSE;

	DWORD dwWritten = 0;
	BOOL bRet = WriteProcessMemory(hWinMineProc, lpBaseAddress, lpBuffer, nSize, &amp;dwWritten);

	CloseHandle(hWinMineProc);

	return bRet;
}
</code></pre>
<p>We have everything we need to write our time-freezing function which should be pretty simple. All we have to do is overwrite the instruction at <code>0x01002FF5</code> with <code>nop</code>s.</p>
<pre><code class="lang-cpp">#define ADDR_TIMER 0x1002FF5

__declspec(naked) VOID FreezeTimerShellcodeStart(VOID) {
	__asm {
		nop
		nop
		nop
		nop
		nop
		nop
	}
}

BOOL FreezeTimer(BOOL bFreeze) {
	DWORD dwShellcodeSize = 6;
	LPBYTE lpShellcode = malloc(dwShellcodeSize);
    if (lpShellcode == NULL)
        return FALSE;

	if (bFreeze == TRUE)
		memcpy(lpShellcode, FreezeTimerShellCodeStart, dwShellcodeSize);
	else
		memcpy(lpShellcode, UnfreezeTimerShellcodeStart, dwShellcodeSize);

	BOOL bSuccess = WriteMemory((LPVOID)ADDR_TIMER, lpShellcode, dwShellcodeSize);
	if (bSuccess == FALSE)
		Error(L"Inject timer shellcode");

	free(lpShellcode);

	return bSuccess;
}
</code></pre>
<p>If we want to restore the instruction, all we have to do is rewrite the original opcodes back into the same memory address:</p>
<pre><code class="lang-cpp">#define db(x) __emit(x)

__declspec(naked) VOID UnfreezeTimerShellcodeStart(VOID) {
    // MSVC++ producing incorrect opcodes
    // so I hardcoded the original bytes
	__asm {
		db(0xFF)
		db(0x05)
		db(0x9C)
		db(0x57)
		db(0x00)
		db(0x01)
	}
}
</code></pre>
<hr>
<h2>Exposing the Mine Field</h2>
<h3>Debugging and Disassembly: Locating the Mine Field</h3>
<p>The main goal of this game is to utilize hints to seek out and seek out all of the <em>safe</em> cells on the given field. While these hints are great and all that, let’s make our <em>own</em> hints. This one requires a little bit more effort to trace and locate since it is not as straight-forward as the previous hack and needs a little knowledge of the WinAPI.</p>
<p>To start things off, CE might not be able to help us out in this situation so we need a proper debugger for this job. I’ll be using Ollydbg but any debugger should be fine. Open up the <code>winmine.exe</code> in the debugger, place a breakpoint at the entry point, run it until it hits the breakpoint. When an application wants to draw and use graphics, it must use the <code>User32.dll</code> along with the <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd145203(v=vs.85).aspx"><code>Windows GDI (GDI32.dll)</code></a> both which export functions to enable such tasks. One of these functions is <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd183362(v=vs.85).aspx"><code>BeginPaint</code></a> which sets up a particular window for painting. We know that Minesweeper has to draw something so let’s search for the function in the imports list (<code>Ctrl+N</code> on Ollydbg) and find references to <code>BeginPaint</code> (right-click and select <code>Find references</code>). Select the line and set a breakpoint on it so the debugger will stop when the game starts to lay out its graphical components.</p>
<p>Run the program and the debugger will pause with the Minesweeper showing a blank window. Now, we should follow a typical reverse engineering approach to swiftly find the set of procedures which draw out the cells. Carefully begin to step <em>over</em> each instruction until we see something occur on the application, in our case, when we see the cells start to or have already been drawn out, stop stepping, place a breakpoint on the function call which produced the outcome, remove the previous breakpoint and restart the application, this time, stepping <em>into</em> the function with the new breakpoint. Repeat this process until we pinpoint the location of what we want.</p>
<p>Here is the result:</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/4/440d161a043df3702f8aa4c8aedeab38c5117321.JPG" width="690" height="407"></p>
<p>The <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd183370(v=vs.85).aspx"><code>BitBlt</code></a> function is what draws out each cell of the mine field. If we analyze this set of instructions, we will see that it looks like some form of while loop where <code>esi</code> is a counter starting at <code>0</code> and <code>ebx</code> is the array beginning at <code>0x1005340</code>. It also seems like the cell’s source image (a blank cell, a flag, a mine, etx.) is dependent on the value at <code>ds:[ebx+esi]</code>.</p>
<p>To satisfy our hypotheses, we will continue running the game normally and this time, we will dump the memory starting at <code>0x1005340</code> and see what it looks like.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/8/8ac0d770830cabd92f0f6af8a4fe679ead32514a.JPG" width="670" height="358"></p>
<p>Clearly, there is a very similar layout in the game and in the memory dump. We can match the <code>1</code>s with the <code>41</code>s and the flag with the <code>8E</code>. There’s a bit of an issue with correctly formatting width the dump because we can slightly recognize that the border of the mine field is represented by the <code>10</code>s and the empty/unused cells are <code>0F</code>s.</p>
<h3>Coding the Hack</h3>
<p>In the previous hack, we learned how to write to the process, but this time, we need to read from the process in order to get the information about the array. There is a reading counterpart called <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms680553(v=vs.85).aspx"><code>ReadProcessMemory</code></a> that we can use for this job and it is used exactly the same way we used <code>WriteProcessMemory</code>.</p>
<pre><code class="lang-cpp">BOOL ReadMemory(LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize) {
	HANDLE hWinMineProc = GetWindowProcessHandle(L"Minesweeper", PROCESS_VM_READ);
	if (hWinMineProc == NULL)
		return Error(L"Find Minesweeper window"), FALSE;

	DWORD dwRead = 0;
	BOOL bRet = ReadProcessMemory(hWinMineProc, lpBaseAddress, lpBuffer, nSize, &amp;dwRead);
	
	CloseHandle(hWinMineProc);

	return bRet;
}
</code></pre>
<p>It is now just a simple matter of looping and reading the memory of Minesweeper and printing it out with some nice visual formatting. Keep in mind that whenever a cell is activated, its value in memory will change so the loop must be continuous to update these values.</p>
<pre><code class="lang-cpp">#define CELL_EMPTY L" "
#define CELL_NOT_MINE L"o"
#define CELL_MINE L"x"
#define CELL_FLAG L"!"
#define CELL_UNKNOWN L"?"
#define CELL_BORDER L"*"

// console colors
#define CELL_DIGIT_COLOUR FOREGROUND_GREEN | FOREGROUND_INTENSITY
#define CELL_NOT_MINE_COLOUR FOREGROUND_GREEN
#define CELL_MINE_COLOUR FOREGROUND_RED | FOREGROUND_INTENSITY
#define CELL_FLAG_COLOUR FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY
#define CELL_UNKNOWN_COLOUR FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_INTENSITY
#define CELL_BORDER_COLOUR FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY

VOID PrintDigit(int nDigit) {
	CONSOLE_SCREEN_BUFFER_INFO csbi;
	GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &amp;csbi);
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), CELL_DIGIT_COLOUR);

	wprintf(L"%d", nDigit);

	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), csbi.wAttributes);
}

VOID PrintCell(LPWSTR c, WORD wAttributes) {
	CONSOLE_SCREEN_BUFFER_INFO csbi;
	GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &amp;csbi);
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), wAttributes);

	wprintf(L"%s", c);

	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), csbi.wAttributes);
}

VOID PrintMineField(VOID) {
	BYTE bCell = 0;
	DWORD dwMineFieldSize = ADDR_MINE_FIELD_END - ADDR_MINE_FIELD_START;
	LPBYTE lpMineFieldBuffer = malloc(dwMineFieldSize);
	if (lpMineFieldBuffer == NULL)
	    return;
	    
    // I have opted to threading this function
    // since my hacktool includes a GUI
	while (bThreadActive == TRUE) {
		BOOL bSuccess = ReadMemory((LPVOID)ADDR_MINE_FIELD_START, lpMineFieldBuffer, dwMineFieldSize);
		if (bSuccess == FALSE) {
            // ignore this, this is also part of the GUI
			SendMessage(hWnd, WM_COMMAND, ID_HIDE_MINES, 0);
			return;
		}

		for (DWORD j = 0, i = 0, bCell = lpMineFieldBuffer[i]; i &lt; dwMineFieldSize; i++, j++, bCell = lpMineFieldBuffer[i]) {
            // new line on the mine field
			if (j == 0x20) {
				wprintf(L"\n");
				j = 0;
			}

            // these are most (if not all) of the values of the cells
			int nDigit = bCell &amp; 0x1F;
			if (bCell == 0x8F || bCell == 0x8D)
				PrintCell(CELL_MINE, CELL_MINE_COLOUR);
			else if (bCell == 0x10)
				PrintCell(CELL_BORDER, CELL_BORDER_COLOUR);
			else if (bCell == 0x8E || bCell == 0x0E)
				PrintCell(CELL_FLAG, CELL_FLAG_COLOUR);
			else if (bCell == 0x0D)
				PrintCell(CELL_UNKNOWN, CELL_UNKNOWN_COLOUR);
			else if (nDigit == 0x0)
				PrintCell(CELL_EMPTY, CELL_NOT_MINE_COLOUR);
			else if (nDigit &gt;= 0x1 &amp;&amp; nDigit &lt;= 0x9)
				PrintDigit(nDigit);
			else
				PrintCell(CELL_NOT_MINE, CELL_NOT_MINE_COLOUR);
		}

		Sleep(1000);
		///////////////////////////////
		///////    YUCK!!!!    ////////
		///////////////////////////////
		system("cls");
	}

	free(lpMineFieldBuffer);
}
</code></pre>
<p>Here is an example of what it should look like:</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/e/e8b1716d88d2bcdcf4626b474ccea5e4e25515ed.JPG" width="675" height="378"></p>
<hr>
<h2>Challenge</h2>
<p>I have provided the basic fundamentals on how to hack a game such as memory scanning with CE and reading from and writing to an external process so for those who want in, see if you can mess around with the number of flags and implement it into your own hacktool. Be creative.</p>
<hr>
<h2>Conclusion</h2>
<p>From what we’ve seen, game hacking is on par with reverse engineering. In fact, I think of it as a subcategory of reverse engineering as it exercises the same skillset and mindset (also see <a href="https://0x00sec.org/t/game-hacking-3d-pinball-space-cadet/1232">previous game hacking topic</a>). In contrast, game hacking is probably more fun than just the typical reverse engineering crackme because we get to physically play around with our hacks even <em>after</em> successfully breaking open the innards. It is truly an amusing and satisfying feeling.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/d/d4085ec135b5461f1ab956ccccac9ad22a5419e6.JPG" width="511" height="499"></p>
<p><span class="hashtag">#nohacks</span> <span class="hashtag">#legit</span> <span class="hashtag">#minesweepergod</span></p>
<p>Complete source code on <a href="https://git.0x00sec.org/93aef0ce4dd141ece6f5/0x00sec-code-dump/blob/master/MineHack3r/src/minehack3r.c">GitLab</a> or <a href="https://github.com/NtRaiseHardError/MineHack3r">GitHub</a> (includes spoilers to the challenge!).<br>
<code> </code><br>
<em>– dtm</em></p>
          <p><a href="https://0x00sec.org/t/game-hacking-winxp-minesweeper/1266/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/game-hacking-winxp-minesweeper/1266/1</link>
        <pubDate>Tue, 17 Jan 2017 05:00:00 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1266-1</guid>
        <source url="https://0x00sec.org/t/game-hacking-winxp-minesweeper/1266.rss">Game Hacking: WinXP Minesweeper</source>
      </item>
  </channel>
</rss>
