<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>[Quickie] Zero2Auto Malware Course Homework</title>
    <link>https://0x00sec.org/t/quickie-zero2auto-malware-course-homework/21616</link>
    <description>### Zero2Auto – Deep Dive into Netwalker

## Preface

Recently, I’ve joined @[VK](https://twitter.com/VK_Intel) and @[0verflows](https://twitter.com/0verfl0w_) advanced malware analysis course called “[Zero2Auto](https://courses.zero2auto.com/)”. The first lesson was about algorithms in malware; compression, hashing and encryption. The first lesson was supplied with a PDF which is now released as a [post by Vitaly](https://zero2auto.com/2020/05/19/netwalker-re/) based on another post about the [Netwalker sample](https://blog.trendmicro.com/trendlabs-security-intelligence/netwalker-fileless-ransomware-injected-via-reflective-loading/). I was thinking on how I could practice this lesson, and I concluded that a simple thing I could do is expand upon these two posts as they were not detailed enough for most beginner reverse engineers. My main goal would be to prove the assumed findings in Vitaly’s post by expanding on the mechanisms detailed within it and to detail new findings that might relate to the lessons subject which is how to recognize known encoding algorithms and automate them.

***

### Required prior knowledge:

* X86 Assembly
* IDA Pro and x64dbg Knowledge
* Basic Powershell skills

*** 

### Dealing with the first stage PowerShell

The first thing we’ll do is download the sample referenced in both blog posts mentioned above:

SHA-256 hash of the sample: [f4656a9af30e98ed2103194f798fa00fd1686618e3e62fba6b15c9959135b7be](https://any.run/report/f4656a9af30e98ed2103194f798fa00fd1686618e3e62fba6b15c9959135b7be/ca44ad38-0e46-455e-8cfd-42fb53d41a1d)

This is a very long and obfuscated **PowerShell** script, it’s so long that I couldn&#39;t even load it into my VM’s PowerShell ISE without it crashing, so I decided that I can circumvent this by loading the script into Sublime(which is the best text editor on earth).

![|624x112](upload://suXOr6y3Ski2DsH7UjcyOq6iots.png)

The script might be long and scary but do not fear, for all we need to do is examine the first line of the code:

![|624x17](upload://g7OsGXsQNxMd5i9DdMCbHxwb5dd.png)

The first command “Invoke Expression” will simply run the command wrapped inside “$()”, within this statement we can see that the statement will perform base64 decoding. So to decode the first stage obfuscation, we can simply remove the Invoke expression command and pipe the entire decoded string to a text file using **“| Out-File -FilePath .\Process.txt”** and this would result in the following decode payload. The second stage payload is nothing but the same scary mess, but this time a long bytearray is being decrypted within a loop, it simply **XORs** each byte within that array with 0x47.

Again, all I decide to do is to pipe the final product to a text file:

![|580x29](upload://e4YINPyIXzJGrZ5Zu6qF2WQ4vdj.png)

We reach the second stage payload, which contains 2 long bytearrays – which as stated within the blog posts are two DLL files representing **x86** and **x64** versions of the malware DLL that would be loaded into the memory of **explorer.exe**. I’m merely interested in the bytearray representing the x86 DLL. Using sublime text I can click **cntrl+shift+l** and click on the last line of the first byte array – I’ll copy this bytearray to another script file, then I’ll simply invoke a PowerShell command to write this byte array to a file. It’s worth noting that for some reason sublime text appended newline characters at the last character in each line so running this script wont work unless you replace all new line characters within the script.

![|556x72](upload://zOas6mGwtM83RvvNHELhQ660u3m.png)

### Reversing the Netwalker x86 DLL:

Let’s throw the file in **PEBear** and see if we can find anything interesting:

![|516x164](upload://1V1TAIk01fOivLILx7TwYusuBqu.png)

What is this? Ah yes, do not worry the malware author corrupted the PE File header and replaced the “MZ” characters with the header with a word value 0xDEAD (remember this).

What I’ll do, is replace this value using **HxD** to a proper PE header so we could examine it within IDA and Resource Hacker:

![|624x214](upload://nk47UEseJlr5EYC62sEsuTcS2Lr.png)

Much better!

Usually, upon reaching this point I would perform basic static analysis by examining the file’s strings, view any anomalies within its header and examine its resources. Then I would perform basic dynamic analysis by running the sample and monitor it, but we must remember our initial goal – we must expand upon Vitaly’s findings and find any worthwhile material we can explore ourselves. So first let’s examine Vitaly’s first mention of CRC32:

![|508x677](upload://hbmwJIs190ILzmIcHMPGtEwyRGN.png)

How did Vitaly know this is indeed a **CRC32** hashing algorithm? Well lets start by utilizing the KANAL plugin within PEid, I’ll load the malware into **PEid** and launch the **KANAL** tool:

![|372x172](upload://qZvb5h1gbNpS0D7urigpJzo2s6A.png)

![|377x60](upload://1QFZOw1fK5VadXO7j5hPjUBl2zY.png)

As we can see, KANAL recognizes that there is a reference for the CRC32 algorithm within a lot of locations but what exactly did it find there? Let’s jump to 0x1000424F

![173x475](upload://upOG8Sq4gIc37yMER0g5hEmzDBN.png)

![|221x72](upload://8BpGQYkVGLXhuNqM6DW8YbWROrl.png)

What is this constant? Let’s google it:

![|402x290](upload://5sJlZ6jCyFM7NAFTqysgmO5luEL.png)

Aha, alright – even if one would view how [crc2 checksum is calculated](https://stackoverflow.com/questions/2587766/how-is-a-crc32-checksum-calculated) one could quickly see the recognizable division flow at 0x1000421C.

When dynamically analyzing the file, at location **0x10001A59** one can see that the value **0x3e006b7a** is resolved as **FindResourceA**.

![|695x39](upload://hLrc8vxGCDBi6n13JZdS9olO9uy.png)

![|442x54](upload://j9QlcyfibrfKqIEuLrDfAQk93yP.png)

How NetWalker utilizes **PE** Header stomping to break analysis

Let’s examine the following assumption made in Vitaly’s blog:

![|624x301](upload://AsP10S0oobcBdiaEVKFwT5C3AYf.png)

At location **0x1000A0B0** one can find the **API** resolving function:

![|521x188](upload://fPvs6niCu6gpeivcRSi3rSHRYI4.png)

So, I assumed Vitaly is referencing the content with **sub_1003710**

![|285x445](upload://9xtaGP7TPxeRGI5aExvDwCnEWez.png)

And indeed, he was, how ever by simply breaking on this location and running the sample it would crash. I decided to attempt to understand why this was happening. First attempted to skip the call at **0x1000371E** which I renamed to **func_checkValidHeader** but I this function crashed the sample every time with a access violation exception, so lets take a look at it.

![|204x265](upload://noHGXHV8r7aQZcxLmGPzW6JwJmk.png)

First, it loads the offset of the current function into **EAX** and **ANDs** it with **0xFFFF000**. It would then begin to iterate through a loop, subtracting **0x800** from **EAX** and attempting to locate the value **0xDEAD** within the address referenced in **EAX**. Sounds familiar? Sure does – as we recall the DLL PE header was stomped with **0xDEAD**, this code routine is attempting to validate that no one tampered with the sample.

![|514x63](upload://sx98AzlaOcV6SLHniih5bu7vvwd.png)

Since I modified the header, the sample would get stuck in an infinite loop until **EAX** would point to an invalid memory location resulting an access violation exception – to add to this finding if we go to address **0x1000372D** the sample attempts to fix the stomped header using the value returned by **func_checkValidHeader** which should point to the base address of the DLL. It would then replace **0xDEAD** with “MZ” thus fixing the header.

![|601x153](upload://eeFsIYR9ulgJhpi7B2UtdXx3eMQ.png)

![|126x22](upload://2qqaN10C7E9iZRt0hMEMDidMQJc.png)

To quickly solve this issue, I just patched the binary by removing the header patcher and that solved the problem.

![|617x210](upload://tmKaZLmF9c9kVgcl9n8rYEygGVe.png)

We can indeed verify Vitay’s findings after this as the sample doesn’t crash. First the sample loads the resource, locks it.

![|285x422](upload://89CLZFvFZ9lJy7amFGdebNbGgzs.png)

The malware then loads the resources size and allocates a buffer within the heap to load the resource into it using **memcpy**.

![|384x302](upload://82gwq4RHZlKVXwqNy44H4jsIgli.png)

The malware then loads the key length and the key itself and saves it to a stack variable

![|398x96](upload://6XjZSSKWDuTx2cch87uIVlJ50Bs.png)

Copied key:

![|169x19](upload://8hcTVgytYNzVigFucsborh6uTNY.png)

Afterwards the key value, size and a pointer to the heap buffer containing the resource are saved and pushed into a function I renamed **func_RC4Decrypt**:

![|267x340](upload://5IniKZYQwkf9JJ9XvyMqsvhlHEq.png)

Vitaly assumes this within the blog:

![|624x240](upload://e9yf5QCNWY1d9XseQ77A8iboqVw.png)

If one followed the lesson in the course carefully one knows that one of the recognizable features of **RC4 KSA** is a loop flow iterating **256** times:

![|548x173](upload://u29DW70G6eodJ039S53bQKXdDrS.png)

and if we examine the function located at **0x10009210** we can confirm an example for this at **0x10009281** and at **0x100092CF**:

![|287x253](upload://a6FxlTXwFXWiH3kJjqVrE6SvlVN.png)

**EBP** is being loaded with **256** as a preparation of the second **KSA** iteration:

![|263x46](upload://zzVEwEPAsXQ4u0qKgPuQTxHKqNx.png)

![|262x210](upload://hqdy4nrkmmPreYVYcemzeqf15JX.png)

***

### Decryption process as seen within the debugger:

![|624x47](upload://b96rtD2gGvbGXpcT9OBo6caSjsL.png)

Size(red), key(blue), resource(rest)

![|594x165](upload://yf2sRrqwog55xhcmPyP4HGdVowC.png)

After the function decryption is finished:

![|596x165](upload://1IEpmvEm2Nturn759nR5H4V6kyN.png)

Finally, at location **0x10003832** the sample restores the Netwalker header back to **0xDEAD**.

![|329x143](upload://nzHLfxlpC9BXT8jrrHk7AxGo9TZ.png)

I wonder if **0xDEAD** is a cross binary constant across all Netwalker samples ;)

Sources:

https://zero2auto.com/2020/05/19/netwalker-re/

https://blog.trendmicro.com/trendlabs-security-intelligence/netwalker-fileless-ransomware-injected-via-reflective-loading/

https://any.run/report/f4656a9af30e98ed2103194f798fa00fd1686618e3e62fba6b15c9959135b7be/ca44ad38-0e46-455e-8cfd-42fb53d41a1d</description>
    
    <lastBuildDate>Fri, 05 Jun 2020 16:13:23 +0000</lastBuildDate>
    <category>Malware</category>
    <atom:link href="https://0x00sec.org/t/quickie-zero2auto-malware-course-homework/21616.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>[Quickie] Zero2Auto Malware Course Homework</title>
        <dc:creator><![CDATA[system]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 121 days. New replies are no longer allowed.</p>
          <p><a href="https://0x00sec.org/t/quickie-zero2auto-malware-course-homework/21616/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/quickie-zero2auto-malware-course-homework/21616/2</link>
        <pubDate>Mon, 05 Oct 2020 04:03:48 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-21616-2</guid>
        <source url="https://0x00sec.org/t/quickie-zero2auto-malware-course-homework/21616.rss">[Quickie] Zero2Auto Malware Course Homework</source>
      </item>
      <item>
        <title>[Quickie] Zero2Auto Malware Course Homework</title>
        <dc:creator><![CDATA[Danus]]></dc:creator>
        <description><![CDATA[
            <h3>Zero2Auto – Deep Dive into Netwalker</h3>
<h2>Preface</h2>
<p>Recently, I’ve joined @<a href="https://twitter.com/VK_Intel" rel="noopener nofollow ugc">VK</a> and @<a href="https://twitter.com/0verfl0w_" rel="noopener nofollow ugc">0verflows</a> advanced malware analysis course called “<a href="https://courses.zero2auto.com/" rel="noopener nofollow ugc">Zero2Auto</a>”. The first lesson was about algorithms in malware; compression, hashing and encryption. The first lesson was supplied with a PDF which is now released as a <a href="https://zero2auto.com/2020/05/19/netwalker-re/" rel="noopener nofollow ugc">post by Vitaly</a> based on another post about the <a href="https://blog.trendmicro.com/trendlabs-security-intelligence/netwalker-fileless-ransomware-injected-via-reflective-loading/" rel="noopener nofollow ugc">Netwalker sample</a>. I was thinking on how I could practice this lesson, and I concluded that a simple thing I could do is expand upon these two posts as they were not detailed enough for most beginner reverse engineers. My main goal would be to prove the assumed findings in Vitaly’s post by expanding on the mechanisms detailed within it and to detail new findings that might relate to the lessons subject which is how to recognize known encoding algorithms and automate them.</p>
<hr>
<h3>Required prior knowledge:</h3>
<ul>
<li>X86 Assembly</li>
<li>IDA Pro and x64dbg Knowledge</li>
<li>Basic Powershell skills</li>
</ul>
<hr>
<h3>Dealing with the first stage PowerShell</h3>
<p>The first thing we’ll do is download the sample referenced in both blog posts mentioned above:</p>
<p>SHA-256 hash of the sample: <a href="https://any.run/report/f4656a9af30e98ed2103194f798fa00fd1686618e3e62fba6b15c9959135b7be/ca44ad38-0e46-455e-8cfd-42fb53d41a1d" rel="noopener nofollow ugc">f4656a9af30e98ed2103194f798fa00fd1686618e3e62fba6b15c9959135b7be</a></p>
<p>This is a very long and obfuscated <strong>PowerShell</strong> script, it’s so long that I couldn’t even load it into my VM’s PowerShell ISE without it crashing, so I decided that I can circumvent this by loading the script into Sublime(which is the best text editor on earth).</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/c/c7bcf004cbfeb2ca11d0a933d3a5b731bf897392.png" alt="" data-base62-sha1="suXOr6y3Ski2DsH7UjcyOq6iots" width="624" height="112"></p>
<p>The script might be long and scary but do not fear, for all we need to do is examine the first line of the code:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/7/7104e7a552fc995dfda3849de798dccd8604780f.png" alt="" data-base62-sha1="g7OsGXsQNxMd5i9DdMCbHxwb5dd" width="624" height="17"></p>
<p>The first command “Invoke Expression” will simply run the command wrapped inside “$()”, within this statement we can see that the statement will perform base64 decoding. So to decode the first stage obfuscation, we can simply remove the Invoke expression command and pipe the entire decoded string to a text file using <strong>“| Out-File -FilePath .\Process.txt”</strong> and this would result in the following decode payload. The second stage payload is nothing but the same scary mess, but this time a long bytearray is being decrypted within a loop, it simply <strong>XORs</strong> each byte within that array with 0x47.</p>
<p>Again, all I decide to do is to pipe the final product to a text file:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/6/62ae87e331fa3a358ce55ebe33e8dfc92ce94e95.png" alt="" data-base62-sha1="e4YINPyIXzJGrZ5Zu6qF2WQ4vdj" width="580" height="29"></p>
<p>We reach the second stage payload, which contains 2 long bytearrays – which as stated within the blog posts are two DLL files representing <strong>x86</strong> and <strong>x64</strong> versions of the malware DLL that would be loaded into the memory of <strong>explorer.exe</strong>. I’m merely interested in the bytearray representing the x86 DLL. Using sublime text I can click <strong>cntrl+shift+l</strong> and click on the last line of the first byte array – I’ll copy this bytearray to another script file, then I’ll simply invoke a PowerShell command to write this byte array to a file. It’s worth noting that for some reason sublime text appended newline characters at the last character in each line so running this script wont work unless you replace all new line characters within the script.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/f/faf7e1e6ece4d7a1e9c38682fbdbf20253049268.png" alt="" data-base62-sha1="zOas6mGwtM83RvvNHELhQ660u3m" width="556" height="72"></p>
<h3>Reversing the Netwalker x86 DLL:</h3>
<p>Let’s throw the file in <strong>PEBear</strong> and see if we can find anything interesting:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/0/0d748aafa61973ec15ab4d328bb7c4c0f473150e.png" alt="" data-base62-sha1="1V1TAIk01fOivLILx7TwYusuBqu" width="516" height="164"></p>
<p>What is this? Ah yes, do not worry the malware author corrupted the PE File header and replaced the “MZ” characters with the header with a word value 0xDEAD (remember this).</p>
<p>What I’ll do, is replace this value using <strong>HxD</strong> to a proper PE header so we could examine it within IDA and Resource Hacker:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/a/a376b1929b5838c661d93f56c4d191c20d0e3135.png" alt="" data-base62-sha1="nk47UEseJlr5EYC62sEsuTcS2Lr" width="624" height="214"></p>
<p>Much better!</p>
<p>Usually, upon reaching this point I would perform basic static analysis by examining the file’s strings, view any anomalies within its header and examine its resources. Then I would perform basic dynamic analysis by running the sample and monitor it, but we must remember our initial goal – we must expand upon Vitaly’s findings and find any worthwhile material we can explore ourselves. So first let’s examine Vitaly’s first mention of CRC32:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/7/786dcb253e35be9db36c2028fc0a2ad3c73c2961.png" alt="" data-base62-sha1="hbmwJIs190ILzmIcHMPGtEwyRGN" width="375" height="500"></p>
<p>How did Vitaly know this is indeed a <strong>CRC32</strong> hashing algorithm? Well lets start by utilizing the KANAL plugin within PEid, I’ll load the malware into <strong>PEid</strong> and launch the <strong>KANAL</strong> tool:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/b/bd2c4fbc31233ed73ccb02f19092d896880ddbd8.png" alt="" data-base62-sha1="qZvb5h1gbNpS0D7urigpJzo2s6A" width="372" height="172"></p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/0/0cf6912718ec7f6d1cd03a325d2458d5dd1e3ea6.png" alt="" data-base62-sha1="1QFZOw1fK5VadXO7j5hPjUBl2zY" width="377" height="60"></p>
<p>As we can see, KANAL recognizes that there is a reference for the CRC32 algorithm within a lot of locations but what exactly did it find there? Let’s jump to 0x1000424F</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/d/d52c54b61b6d7bec7f358fd956323f64d512accb.png" alt="" data-base62-sha1="upOG8Sq4gIc37yMER0g5hEmzDBN" width="173" height="475"></p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/3/3c4c19898b4ee525fef4c3e6ffcf62a6b3a8cfff.png" alt="" data-base62-sha1="8BpGQYkVGLXhuNqM6DW8YbWROrl" width="221" height="72"></p>
<p>What is this constant? Let’s google it:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/2/264a4fa21fdd2e549bf72e59f5e4d60c6b7b1a3f.png" alt="" data-base62-sha1="5sJlZ6jCyFM7NAFTqysgmO5luEL" width="402" height="290"></p>
<p>Aha, alright – even if one would view how <a href="https://stackoverflow.com/questions/2587766/how-is-a-crc32-checksum-calculated" rel="noopener nofollow ugc">crc2 checksum is calculated</a> one could quickly see the recognizable division flow at 0x1000421C.</p>
<p>When dynamically analyzing the file, at location <strong>0x10001A59</strong> one can see that the value <strong>0x3e006b7a</strong> is resolved as <strong>FindResourceA</strong>.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/7/7c81c028c89b018df3b101448524dde108950f8a.png" alt="" data-base62-sha1="hLrc8vxGCDBi6n13JZdS9olO9uy" width="690" height="38"></p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/8/86462e32687373031baf2c13c11e89bf447a2973.png" alt="" data-base62-sha1="j9QlcyfibrfKqIEuLrDfAQk93yP" width="442" height="54"></p>
<p>How NetWalker utilizes <strong>PE</strong> Header stomping to break analysis</p>
<p>Let’s examine the following assumption made in Vitaly’s blog:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/f/ff9058c1b80ec12f25929c6dea702b9d391f088f.png" alt="" data-base62-sha1="AsP10S0oobcBdiaEVKFwT5C3AYf" width="624" height="301"></p>
<p>At location <strong>0x1000A0B0</strong> one can find the <strong>API</strong> resolving function:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/6/6ef3249d172a2ab7611d3dff103871cae7d23824.png" alt="" data-base62-sha1="fPvs6niCu6gpeivcRSi3rSHRYI4" width="521" height="188"></p>
<p>So, I assumed Vitaly is referencing the content with <strong>sub_1003710</strong></p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/4/42dc253a11b742c6b8c118f4e7b294407a84df5f.png" alt="" data-base62-sha1="9xtaGP7TPxeRGI5aExvDwCnEWez" width="285" height="445"></p>
<p>And indeed, he was, how ever by simply breaking on this location and running the sample it would crash. I decided to attempt to understand why this was happening. First attempted to skip the call at <strong>0x1000371E</strong> which I renamed to <strong>func_checkValidHeader</strong> but I this function crashed the sample every time with a access violation exception, so lets take a look at it.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/a/a3fce9ed50fb1723e25d673342739ca5dcef162c.png" alt="" data-base62-sha1="noHGXHV8r7aQZcxLmGPzW6JwJmk" width="204" height="265"></p>
<p>First, it loads the offset of the current function into <strong>EAX</strong> and <strong>ANDs</strong> it with <strong>0xFFFF000</strong>. It would then begin to iterate through a loop, subtracting <strong>0x800</strong> from <strong>EAX</strong> and attempting to locate the value <strong>0xDEAD</strong> within the address referenced in <strong>EAX</strong>. Sounds familiar? Sure does – as we recall the DLL PE header was stomped with <strong>0xDEAD</strong>, this code routine is attempting to validate that no one tampered with the sample.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/c/c7fc199eb8d0c8f8d6a1b95eb95abb0d39da9f41.png" alt="" data-base62-sha1="sx98AzlaOcV6SLHniih5bu7vvwd" width="514" height="63"></p>
<p>Since I modified the header, the sample would get stuck in an infinite loop until <strong>EAX</strong> would point to an invalid memory location resulting an access violation exception – to add to this finding if we go to address <strong>0x1000372D</strong> the sample attempts to fix the stomped header using the value returned by <strong>func_checkValidHeader</strong> which should point to the base address of the DLL. It would then replace <strong>0xDEAD</strong> with “MZ” thus fixing the header.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/6/63c6ecaaf28926f83971f59a415c0f0dceebda64.png" alt="" data-base62-sha1="eeFsIYR9ulgJhpi7B2UtdXx3eMQ" width="601" height="153"></p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/1/1100f5ca50d6e15f11f699a7ea19bee7a6c44292.png" alt="" data-base62-sha1="2qqaN10C7E9iZRt0hMEMDidMQJc" width="126" height="22"></p>
<p>To quickly solve this issue, I just patched the binary by removing the header patcher and that solved the problem.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/c/cdd13d97e5d37c9190f0580d549cb7ba95b568a4.png" alt="" data-base62-sha1="tmKaZLmF9c9kVgcl9n8rYEygGVe" width="617" height="210"></p>
<p>We can indeed verify Vitay’s findings after this as the sample doesn’t crash. First the sample loads the resource, locks it.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/3/3927ef1d6cd247a612c1f84ef4fa87a46888a4d6.png" alt="" data-base62-sha1="89CLZFvFZ9lJy7amFGdebNbGgzs" width="285" height="422"></p>
<p>The malware then loads the resources size and allocates a buffer within the heap to load the resource into it using <strong>memcpy</strong>.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/3/3852faf7dae9a6ac314899af4179ef5881916ae8.png" alt="" data-base62-sha1="82gwq4RHZlKVXwqNy44H4jsIgli" width="384" height="302"></p>
<p>The malware then loads the key length and the key itself and saves it to a stack variable</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/3/30c1bcaac60dcdd0d7255f95c35386cf892f245a.png" alt="" data-base62-sha1="6XjZSSKWDuTx2cch87uIVlJ50Bs" width="398" height="96"></p>
<p>Copied key:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/3/3a035d591053dee59325599bf4d251917b8a8f06.png" alt="" data-base62-sha1="8hcTVgytYNzVigFucsborh6uTNY" width="169" height="19"></p>
<p>Afterwards the key value, size and a pointer to the heap buffer containing the resource are saved and pushed into a function I renamed <strong>func_RC4Decrypt</strong>:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/2/280f07ee77566a3dab1e8d25d8bac1c5684328fe.png" alt="" data-base62-sha1="5IniKZYQwkf9JJ9XvyMqsvhlHEq" width="267" height="340"></p>
<p>Vitaly assumes this within the blog:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/6/6332dcfa09971e964b33f26ded9e1c3c2d78d306.png" alt="" data-base62-sha1="e9yf5QCNWY1d9XseQ77A8iboqVw" width="624" height="240"></p>
<p>If one followed the lesson in the course carefully one knows that one of the recognizable features of <strong>RC4 KSA</strong> is a loop flow iterating <strong>256</strong> times:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/d/d27f98d6576ba60a8f813ae77aa1d18c48ada564.png" alt="" data-base62-sha1="u29DW70G6eodJ039S53bQKXdDrS" width="548" height="173"></p>
<p>and if we examine the function located at <strong>0x10009210</strong> we can confirm an example for this at <strong>0x10009281</strong> and at <strong>0x100092CF</strong>:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/4/46d6c1d322476e9771b6ef284bd7c439b9a9257b.png" alt="" data-base62-sha1="a6FxlTXwFXWiH3kJjqVrE6SvlVN" width="287" height="253"></p>
<p><strong>EBP</strong> is being loaded with <strong>256</strong> as a preparation of the second <strong>KSA</strong> iteration:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/f/f95bd6b54b1ab918bf05c8dec1464c9b1d756147.png" alt="" data-base62-sha1="zzVEwEPAsXQ4u0qKgPuQTxHKqNx" width="263" height="46"></p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/7/7a1bad5d17e2a77f5525f91c5cfc2c97086382dd.png" alt="" data-base62-sha1="hqdy4nrkmmPreYVYcemzeqf15JX" width="262" height="210"></p>
<hr>
<h3>Decryption process as seen within the debugger:</h3>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/4/4e1f5d983afd6f8d2ff2b697b53348d7d4168633.png" alt="" data-base62-sha1="b96rtD2gGvbGXpcT9OBo6caSjsL" width="624" height="47"></p>
<p>Size(red), key(blue), resource(rest)</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/e/effd23db01b1f0131a4e17976ea9fef1c2b5b8ce.png" alt="" data-base62-sha1="yf2sRrqwog55xhcmPyP4HGdVowC" width="594" height="165"></p>
<p>After the function decryption is finished:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/0/0c0e51cc4189649ec9c940a98358382d63a94cdd.png" alt="" data-base62-sha1="1IEpmvEm2Nturn759nR5H4V6kyN" width="596" height="165"></p>
<p>Finally, at location <strong>0x10003832</strong> the sample restores the Netwalker header back to <strong>0xDEAD</strong>.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/a/a53b446a09ab2e2248ef63d0099b954c5e3ef5f3.png" alt="" data-base62-sha1="nzHLfxlpC9BXT8jrrHk7AxGo9TZ" width="329" height="143"></p>
<p>I wonder if <strong>0xDEAD</strong> is a cross binary constant across all Netwalker samples <img src="https://0x00sec.org/images/emoji/twitter/wink.png?v=9" title=":wink:" class="emoji" alt=":wink:"></p>
<p>Sources:</p>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="/uploads/default/original/2X/2/2cd17a874defe1c35c781d668d0a02cad5a9bf72.jpeg" class="site-icon" width="32" height="32">
      <a href="https://zero2auto.com/2020/05/19/netwalker-re/" target="_blank" rel="noopener nofollow ugc" title="01:03AM - 19 May 2020">Zero2Automated Blog – 19 May 20</a>
  </header>
  <article class="onebox-body">
    <img src="https://0x00sec.s3.amazonaws.com/original/2X/0/02e82ec3e37d65de457b2d72511faac0322820ab.png" class="thumbnail" width="" height="">

<h3><a href="https://zero2auto.com/2020/05/19/netwalker-re/" target="_blank" rel="noopener nofollow ugc">Netwalker Ransomware – From Static Reverse Engineering to Automatic Extraction</a></h3>

<p>Author: Zero2Automated Course Team (preview from courses.zero2auto.com) Netwalker ransomware has been around since at least 2019* and has recently been in the news from a TrendMicro report detailin…</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://0x00sec.s3.amazonaws.com/original/2X/d/d9521d1e8cb48525a863bcf9ccc65fd70769036d.png" class="site-icon" width="" height="">
      <a href="https://www.trendmicro.com/en_us/research/20/e/netwalker-fileless-ransomware-injected-via-reflective-loading.html" target="_blank" rel="noopener nofollow ugc">Trend Micro</a>
  </header>
  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:641/350;"><img src="https://0x00sec.s3.amazonaws.com/original/3X/6/7/677046b257f90fcae993ac62541ac9da84c382d6.jpeg" class="thumbnail" width="641" height="350"></div>

<h3><a href="https://www.trendmicro.com/en_us/research/20/e/netwalker-fileless-ransomware-injected-via-reflective-loading.html" target="_blank" rel="noopener nofollow ugc">Reflective Loading Runs Netwalker Fileless Ransomware</a></h3>

<p>Ransomware in itself poses a formidable threat for organizations. As a fileless threat, the risk is increased as it can more effectively evade detection. We discuss how Netwalker ransomware is deployed filelessly through reflective DLL injection.</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p><a href="https://any.run/report/f4656a9af30e98ed2103194f798fa00fd1686618e3e62fba6b15c9959135b7be/ca44ad38-0e46-455e-8cfd-42fb53d41a1d" class="onebox" target="_blank" rel="noopener nofollow ugc">https://any.run/report/f4656a9af30e98ed2103194f798fa00fd1686618e3e62fba6b15c9959135b7be/ca44ad38-0e46-455e-8cfd-42fb53d41a1d</a></p>
          <p><a href="https://0x00sec.org/t/quickie-zero2auto-malware-course-homework/21616/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/quickie-zero2auto-malware-course-homework/21616/1</link>
        <pubDate>Fri, 05 Jun 2020 11:49:37 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-21616-1</guid>
        <source url="https://0x00sec.org/t/quickie-zero2auto-malware-course-homework/21616.rss">[Quickie] Zero2Auto Malware Course Homework</source>
      </item>
  </channel>
</rss>
