<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Linux Internals - The Art Of Symbol Resolution</title>
    <link>https://0x00sec.org/t/linux-internals-the-art-of-symbol-resolution/1488</link>
    <description>Hello peeps! Been a while. I hope you&#39;re all doing great. This write-up was supposed to be up way sooner to be honest. Recently, @oaktree coded an IRC bot with dynamic linking features which motivated me to finally take the initiative and finish this god damn paper. So without further ado, @oaktree and the rest, let&#39;s get right into it.

Today we are continuing our journey towards the in-depth understanding of our binaries. If this is the first write-up you are reading regarding my series on Linux Internals, I suggest you going through my [Dynamic Linking Wizardry](https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082) post before you keep on reading. The aforementioned article wasn&#39;t too &quot;practical&quot; for my standards so let&#39;s dive deeper this time with some PoC. 

Enjoy! 

---
### `Introduction`
Right, firstly, let&#39;s simplify and visualize some terms because those damn Computer Scientists love making our life hard by creating all kinds of confusing name conventions. **_Symbol_** is a fancy term to describe mainly functions, objects, variables. In reality, a symbol is just an address / offset. &quot; But what do you mean by that @_py? &quot; Glad you asked. 

Below is a disassembly snippet of one of the PoC binaries I&#39;ll be using for today.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/4/4f307627778c1c3473c628f4809049bce670ea13.png&quot; width=&quot;598&quot; height=&quot;169&quot;&gt;

Even if you never attempted to disassembly a function, it&#39;s crystal clear that this is the disassembly of our **_main_** fuction (shown at the top-left corner of the image). But what else do you see? You see some weird number ( 0x80484a4 ) next to its name. This is its starting address ( in hex ). Meaning, main is practically a bunch of instructions ( 0s and 1s) at a certain offset in our address space. That simple.

The above explanation wasn&#39;t really necessary for the completeness of this article but I always believed that the best way to solidify a concept, is by simplifying it as much as possible. In my opinion, If there is something to take away from this article is this:

---
**_Everything is 0s and 1s ( or for the hardware guys, high voltage-low voltage) . What makes your computer do what it does is the context in which is seeing those 0s and 1s_.**

---

Phew, after this small break, let&#39;s get back to business.

**_Note_**: _I&#39;ll be referring to variables, functions as objects from time to time for generality purposes_.

### `Symbol Resolution`

You can think of symbol resolution as the DNS of binaries. Simply put, it&#39;s a process of mapping and finding objects in the address space. A curious person would ask &quot; why the hell do we need any of it in the first place? &quot; Well, let me show you.

**_Note_**: _I&#39;ll start by covering the 32-bit version and gradually move to the 64-bit one_.

This is our source code (32-bit):

```c
int var = 12;

int func (int b)
{
	return var + b;
}
```

We will compile the above code into a shared library / object (.so) by using the _-fpic_ and _-shared_ flags ([how-to](http://www.cprogramming.com/tutorial/shared-libraries-linux-gcc.html) ). If you don&#39;t know what shared libraries are, google it, it&#39;s quite simple. It&#39;s practically a bunch of function , variable, object declarations / definitions which you can embed in your main binary&#39;s address space and refer to them &quot;as if&quot; they were defined in your executable&#39;s source file. Anyway, the point I want to prove with the above source code is this:

Our func() function returns a sum. This sum refers to an object outside of the function scope (var in our case), right? It somehow needs to find its location ( address / offset ) in order to read its value before the addition can take place. Which proves my point at the beginning of this article. &quot;var&quot; is practically an address / offset which contains a value. Let&#39;s investigate how this is being accomplished. At start, it might seem weird but while we uncover it gradually you&#39;ll realize that it&#39;s actually quite trivial.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/a/ad31451e5421a873da3422523e62e7b0758dc6a9.png&quot; width=&quot;647&quot; height=&quot;254&quot;&gt;

The most interesting part of the above snippet is at offset **_0x42f_**. Let&#39;s have a closer look at the function being called.

```asm
mov ecx, DWORD PTR [esp]
ret
```
The low-level veterans probably already see where this is going but let&#39;s walk through it together.


Func() calls **&lt;__i686.get_pc_thunk.cx&gt;** which in return places the _return address_ from the stack into the ecx register. Let&#39;s have a stack-calling-convention crash course for the newbie ones so you can be able to make sense out of the rest of this write-up.

---
### `Stack Calling Convention Crash Course `

```makefile
 
                           +--------------+
                           |     ...      |
                           |     args     |
                           | func() vars  |
                           +--------------+
                           |  return addr | &lt;-- func() pushes the address 
                           +--------------+     of the next instruction on the stack.
                           |     ...      |
                           |     args     |
                           |thunk.cx vars |
                           +--------------+
```
So, what&#39;s really going on? The above masterpiece is an  overly-simplified image of the stack **RIGHT** when the call instruction happened. I&#39;ve precluded some info such as local variable allocation, but it&#39;s not interesting to us at the moment. 

Let&#39;s think of it logically. func() is just an address in memory and you want to call a function ( jump to a different address in memory ). Wouldn&#39;t you want to know the way back to func() once you are done with the call to thunk.cx()? Well, that&#39;s how computers do it: They push the address of the next instruction of the _caller_ ( func ) on the stack so as once the _callee_ ( thunk.cx ) is done, the execution can resume at the address of the _caller_ ( func ). Simple and genius.

---

Let&#39;s go back to our scenario. 

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/7/77a3a1e9b2a608de055829ed06f88e828f96ee98.png&quot; width=&quot;647&quot; height=&quot;254&quot;&gt;

_ECX_ contains the address of the **next** instruction once thunk.cx() has returned. Then, an interesting addition is going on. Hm, an offset is being added to ecx. But why? Well, this is where the one and only Global Offset Table, aka GOT, joins the party. GOT is one of the most fundamental pieces in ELF binaries and I&#39;ve written extensively about it [here](https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082) and there is more on google. Basically, it&#39;s an array of symbol addresses.

The secret behind the offset addition is:

---
_**The offset between the text segment ( machine instructions ) and data segment ( global / static variables ) is known at link-time.**_

---

What does that practically mean? Well, the linker ( the one responsible for symbol resolution ) knows during run-time the location of every section / segment. Meaning, while we are executing the func()&#39;s instructions ( stored in the text segment ) and we try to refer to an object further away ( recall from our example the &quot;var&quot; global variable which is stored in the data segment ), the linker will add a known offset to the address being executed and resolve the symbol&#39;s offset. Right, all this might sound fancy and crazy but let&#39;s draw it out, shall we?
```makefile
    +--------------------+   var
    |     Data Segment   | &lt;-----
    |.data, .got, .symtab|      |
    |       ....         |      |
    +--------------------+      |
    |       ....         |     +0x1bc0 = offset
    |       ....         |      |
    +--------------------+      |
    |     Text Segment   |      | 
    |   .text, .rodata   |  ---------&gt; return var + b;
    | func() refs &quot;var&quot;  |
    +--------------------+
```
So the offset addition makes ecx point to the area where &quot;var&quot; can be found, aka GOT. Let&#39;s construct a PoC and prove it to ourselves. Remember, the assembly never lies. Here is our tiny main binary which will be linked against the shared library we created before.

```c
int main()
{
	func(2);
	return 6;
}
```

Now let&#39;s fire up GDB.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/c/ca2dd0e1fe58c6b24c2e38e9b541038d59b12047.png&quot; width=&quot;348&quot; height=&quot;90&quot;&gt;

Let&#39;s inspect the assembly.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/0/094d4bd1c8879c3a640321fda7d113d00e220b04.png&quot; width=&quot;630&quot; height=&quot;191&quot;&gt;

Let&#39;s make some notes for the above image:

* The address we are at during the breakpoint is _0xb7fd843a_, which is a classic offset for a shared library&#39;s code and text segment.
* thunk.cx is being called and does its magic as we said before
* The known offset is being added to ecx and now ecx points to the GOT, which is where the &quot;var&quot; reference can be found.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/6/69a40cecbd95777762fc201387b5e558f1f4cc85.png&quot; width=&quot;385&quot; height=&quot;53&quot;&gt;

As you can see, ecx hold the address 0xb7fd9ff4, which should be a GOT address. Let&#39;s find it out.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/b/bca3cbe5bb5bff468b740646ad3bfb7fa9e8f370.png&quot; width=&quot;690&quot; height=&quot;46&quot;&gt;

The column on the right of &quot;PROGBITS&quot; is the offset of GOT&#39;s address ( _0xb7fd1fe4_ ) from the base address of our shared library. In case you didn&#39;t notice it, ecx points a couple bytes after GOT&#39;s base address. In particular, it points to _0xb7fd9ff4_, which looks identical to .got.plt&#39;s offset. Damn! Did @_py lose his mind? Well, stay with me. Let&#39;s dissect the disassembly.

```asm
mov   eax,DWORD PTR [ecx-0xc]  &lt;-$pc
mov   eax,DWORD PTR [eax]

```
The program counter ( PC ) points to the next instruction that is about to be executed right after the breakpoint. The first instruction will do the following:

* 0xc will be subtracted from the value of ecx. Thus, 0xb7fd9ff4 - 0xc = 0xb7fd9fe8.
* Read the address stored at address 0xb7fd9fe8.
* Dereference the address and store its content in eax.

Another drawing incoming:
```makefile
    GOT: 0xb7fd1fe4  +-----------------+   
                     |   dynamic ptr   |
                     +-----------------+
                     | link_map* struct|
                     +-----------------+
                     |   dl_resolve()  |
                     +-----------------+
                     |      ....       |
                     +-----------------+
                     |      ....       |
                     +-----------------+
                     |    var&#39;s addr   |    &lt;-------- new ecx 
                     +-----------------+       |
                     |      ....       |      (-) 0xc
                     +-----------------+       |
                     |      ....       |   &lt;---- ecx after addition
                     +-----------------+

```
I want to believe it&#39;s clearer now. The GOT as I said before is an array of pointers. One of its indices contains the address of var ( ignore the dl_resolve() and link_map info ).The 2nd instruction will dereference var&#39;s address and place its content ( 12 in our case ) into eax. Nice and easy. For clarity purposes, let&#39;s see what GDB has to say about that.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/a/ad8d15213aee91c36d6dc2f28a63ff3375bcf593.png&quot; width=&quot;235&quot; height=&quot;69&quot;&gt;

Looks like var&#39;s address is _0xb7fda00c_ and it&#39;s stored at address _0xb7fd9fe8_! Hmm, but is it?

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/a/abcce8057e574158e9ac270f693db99eb50c38e9.png&quot; width=&quot;485&quot; height=&quot;34&quot;&gt;

Ofcourse it is! What the above relocation ( R_386_GLOB_DAT ) is telling us loud and clear is &quot; find the address of var and place it at the offset _0x1fe8_, which is the GOT address _0xb7fd9fe8_. &quot; 

---

### `Function Resolution `

Now that we know how to reference variables through the help of GOT, it&#39;s time to move on to function resolution, which is pure orgasm. Let&#39;s create our new source files.

_Shared Library:_

```c
int var = 12;

int func_PLT () {
	return var;
}

int func() {
	int a = func_PLT();
	return 0;
}

```
_Main binary:_

```c
int main(void)
{
	printf(&quot;Shared library mode on.\n&quot;);
	func();
	return 0;
}

```
Bla bla linking process etc. Off to the meat of our scenario. Let&#39;s have a look at the disassembly.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/c/ceb2e53e3e2d97035e23398ae15584828d22d2c4.png&quot; width=&quot;519&quot; height=&quot;204&quot;&gt;

The first instructions are boring and meaningless to us right now so let&#39;s zoom in to:

```asm
call   0x8048410 &lt;func@plt&gt;
```
The above instruction is all the money. It&#39;s where all the magic takes place and let me note that it&#39;s being heavily abused for exploitation purposes. Apparently, we are jumping to address **_0x8048410_** in order to execute our shared library&#39;s func() code. Let&#39;s see what&#39;s hiding behind that address.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/8/8360e63f02d9b4a0ec67b18b7f1cea4230d15cab.png&quot; width=&quot;480&quot; height=&quot;85&quot;&gt;

Hm, another jump to a different address? What the hell is going on @_py? Alright, alright, let&#39;s take a step back and rewind.

--- 
### `PLT &amp; GOT Bromance`

The Procedure Linkage Table, aka PLT, is a section within the text segment which contains executable code. To be exact, it&#39;s an array and each entry contains surgically picked instructions in order to make dynamic linking possible. For instance, 99% of Linux binaries refer to functions that belong to the libc shared library. Each function that you call from libc has a PLT entry with instructions that will help the dynamic linker find their address. But, enough of words, let&#39;s get a pen and draw it out. 

This is how memory looks like when func() is about to get called _**for the 1st time**_:
```makefile
          --&lt;  +--------------+
     main |    |     ...      |
          |    | jmp func@plt | _ _
          |    |     ...      |     \                     PLT
          --&lt;  +--------------+      \             +-----------------+
                                      \            |     PLT stub:   |
                                       \           |  push link_map* |  &lt;-
                                        \          | jmp dl_resolve()|     \
                                         \         +-----------------+      |
                                          \        |       ...       |      |
                                           \       |       ...       |      |
                                            \      |       ...       |      |
                                             \     +-----------------+      |
                                              ---&gt; |    PLT[func]    |      |
                                                 _ |0:jmp *GOT[func] |      |
                     GOT                       /   |1:push rel_index |      |
                +-------------+               /    |     jmp stub    |   _ /
                | .dynamicptr |              /     +-----------------+
                +-------------+             /                               
                | link_map ptr|            /
                +-------------+           /    
                | dl_resolve()|          /
                +-------------+         /
                |     ...     |        /
                +-------------+       /
                |  GOT[func]  |      / 
                |    PLT :1   |  &lt;---
                +-------------+  
```

Let&#39;s analyze the above snippet with the help of assembly. As we saw before, the PLT entry of func() contains the following machine instructions:

```
/*
      Jump to the address contained in 0x804a00c 
      which can be found at the data segment (ds).
      0x804a00c is a GOT address.
*/
jmp    DWORD PTR ds:0x804a00c 
/* Push .rel.plt relocation offset (will be explained shortly). */
push   0x18
/* Jump to the PLT stub code. */
jmp    80483d0 
```
When our main function calls func(), it executes the following instructions:

1. Jump to the PLT entry of func().
2. The PLT entry instructs an indirect jump to a the func()&#39;s GOT entry. 
3. The GOT entry points back to func()&#39;s PLT code which in return pushes a relocation offset.
4. PLT transfers control to the stub, a special PLT entry which pushes a link_map pointer on the stack before calling the dynamic linker for symbol resolution.
5. Dynamic linker resolves func()&#39;s address and patches the GOT entry for future references.

Before I explain a little bit more about step #3 and #4, let me prove to you step #2.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/6/6bede06b8f64983a166dd2556ab3e28e8addcfa2.png&quot; width=&quot;485&quot; height=&quot;133&quot;&gt;

As promised, step #2 will jump to the address contained in **_0x80400c_** which is by no suprise, **_0x08048416_**, aka func()&#39;s PLT code ( push 0x18 ).

---

### `link_map Structure`

This is a really interesting structure, especially from an exploit dev perspective. Let&#39;s have a look at its members.

```c
struct link_map
{
   /* Shared library&#39;s load address. */
   ElfW(Addr) l_addr;                 
   /* Pointer to library&#39;s name in the string table. */                                 
   char *l_name;    
   /* 
        Dynamic section of the shared object.
        Includes dynamic linking info etc.
        Not interesting to us.  
   */                   
   ElfW(Dyn) *l_ld;   
   /* Pointer to previous and next link_map node. */                 
   struct link_map *l_next, *l_prev;   
};
```
Pretty fun stuff eh? Let&#39;s rewind. As I mentioned before at step #4, the PLT entry will push a link_map struct pointer on the stack and then call the dynamic linker. Since we are working on 32-bit binaries, that can only mean one thing. The link_map pointer is one of the arguments ( the second one is the relocation offset which I&#39;ll describe right after ) the dynamic linker needs ( keep in mind that function arguments on 32-bit binaries are passed through the stack ) in order to resolve func()&#39;s address. In practice, its members will be populated at **_run-time_** with the appropriate info ( the shared library in which func() belongs to, the shared library&#39;s address etc ). 

---

### `Extra PoC`
Even though a PoC isn&#39;t a must for our case, I&#39;ll add it for the low-level guys.

**Note**: _I&#39;ve used the objdump utility to find the GOT&#39;s address so I will not include that in the PoC._

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/f/f9cfbc53ddf10557ef001e7daca4e657e439e4a9.png&quot; width=&quot;690&quot; height=&quot;189&quot;&gt;

Aye! We did it! All you need to do in order to understand what just happened is a look at the link_map&#39;s struct members and GOT&#39;s address space which I drew in a quite detailed manner for you. If any of you have questions on how I did it, feel free to comment it down below and I&#39;ll gladly explain it to you. It&#39;s just that it&#39;s not really important in order to grasp the concept of symbol resolution.

---

### `Relocation Entries`

Even though I&#39;ve briefly explained relocations in the past, it&#39;s about time we get reminded of them. Let&#39;s study the format of those relocations:

**_Note_**: _This is a &quot;pseudo&quot; version of the official 64-bit relocation structure specification. They don&#39;t differ in anything, but the one below will make much more sense, you&#39;ll see why I did that shortly_. _And yes, I know, we are talking about 32-bit binaries while the structure is the 64-bit one, but they aren&#39;t any different so why not_. 

```c
     typedef struct {
            /*
              Absolute address in memory where the address
              of the symbol should be written to.
 
              The r_offset value is mostly a GOT address.
              What else could it be.

            */
            long r_offset;
            /* 
                 Relocation type &amp; symbol table index. 

                 The relocation type is a pseudo mathematical
                 formula in order to computer the offset.

                 The symbol table index is basically 
                 an offset in an array of Elf_Symbol structs.
                 
                 In reality, r_info is:
                 long type:32,
                 long symbol:32;
                   _ _ _ _ _ r_info _ _ _ _ _ _
                 |                              |
                       type           symbol
                 |--------------||--------------|
                        32              32

                 The three least significant bytes are 
                 used as an index in the .dynsym 
                 and it&#39;s calculated through the below macro:
                 #define ELF64_R_SYM(info)  ((info)&gt;&gt;32)
                 
            */
            long r_info;
            /* Boring. */
            long addend;
      } Elf_Rel;
```

This is the format of a relocation entry. Makes no sense for now but stay with me. Let&#39;s have a flashback.

```asm
/* Push .rel.plt relocation offset. */
push   0x18
```
In case you forgot, that is one of the instructions in the func()&#39;s PLT entry. What does it really do though? 0x18 is an **_offset_** inside the .rel.plt section. You can think of .rel.plt as an array of Elf_Rel structures and each one of them describes a different function. 0x18 is practically saying &quot;add 0x18 to the address of the .rel.plt section - &gt; read the relocation entry fields that describe func()  - &gt; and pass them to the dynamic linker&#39;s function so he can patch the desired address.

As I mentioned above, the result of the  **#define ELF64_R_SYM(info)  ((info)&gt;&gt;32)** macro is an index into the the dynamic symbol table. An ELF binary has a symbol table and a dynamic symbol table. The latter refers to imported functions and the first one to symbols defined by the us, the programmer. Both tables are populated with the same Elf_Sym structure. Let&#39;s have a look at a pseudo version of it as well.

```c
typedef struct {
      /* 
           Offset into the string table that points to the 
           null-terminated string of the symbol.
      */    
      int name;
      /*
           The info field is split up into 2 parts as well.

            _ _ _ _ _ _ _ info _ _ _ _ _ _ _
           |                                |
                 type           binding
           |---------------||---------------|
                  4                 4
           Type: Function or data ( 4 bits )
           Binding: Local or global ( 4 bits )
        
           There are defined macros in order to calculate
           the above values as well but we already
           saw too much for today.
      */
      unsigned char info;
      /* Unused. */
      char reserved;
      /* Section header index. */
      short section;
      /* Section offset / absolute address */
      long value;
      /* Symbol&#39;s size in bytes. */
      long size;
} Elf_Sym
```
Let&#39;s recap:

---
**_When we import a function from a shared library, our binary&#39;s address space is being populated with a bunch of arrays of structures in order to make dynamic linker&#39;s life easier. In particular, there will be a null-terminated string in the dynamic string table section, a Symbol structure describing some of the symbol&#39;s attributes and finally a few relocation instances in the .rel.plt section pointing to those symbol structures._**

---

I don&#39;t know if you noticed it, but if you actually write down the process, it makes so much sense. What do I mean by that? The linker will need a few vital info in order to resolve the symbol&#39;s address and it gets those through the aforementioned structures.


1. Symbol&#39;s relocation offset.
2. The section where the symbol is defined.
3. Symbol&#39;s type.
4. Symbol&#39;s name.

Sweet! Ezpz m8! Let&#39;s revise the steps of the symbol resolution process:


1. Jump to the PLT entry of our symbol.
2. Jump to the GOT entry of our symbol.
3. Jump back to the PLT entry and push an offset on the stack. That offset is actually an Elf_Rel structure describing how to patch the symbol.
4. Jump to the PLT stub entry.
5. Push a pointer to a link_map structure in order for the linker to find in which library the symbol belongs to.
6. Call the dynamic linker.
7. Patch the GOT entry.
---

### `Memory Image After Patching`

One more drawing to go! Oh boy!

```makefile
          --&lt;  +--------------+
     main |    |     ...      |
          |    | jmp func@plt | _ _
          |    |     ...      |     \                     PLT
          --&lt;  +--------------+      \             +-----------------+
                                      \            |     PLT stub:   |
                                       \           |  push link_map* |  &lt;-
                                        \          | jmp dl_resolve()|     \
                                         \         +-----------------+      |
                                          \        |       ...       |      |
                                           \       |       ...       |      |
                                            \      |       ...       |      |
                                             \     +-----------------+      |
                                              ---&gt; |    PLT[func]    |      |
                                                 _ |0:jmp *GOT[func] |      |
                     GOT                       /   |1:push rel_index |      |
                +-------------+               /    |     jmp stub    |   _ /
                | .dynamicptr |              /     +-----------------+
                +-------------+             /                               
                | link_map ptr|            /
                +-------------+           /    
                | dl_resolve()|          /
                +-------------+         /
                |     ...     |        /
                +-------------+       /
                |  GOT[func]  |      / 
                |   func()    |  &lt;-------
                +-------------+           \
                                           \
                                            \
                                             -----&gt;      Shared Library
                                                    +----------------------+
                                                    | func() code:         |
                                                    |      mov dis, dat    |
                                                    |           ...        |
                                                    +----------------------+
```

The only difference now is that the func()&#39;s GOT entry doesn&#39;t contain an address of the PLT entry anymore, but the address in the shared library where the func() instructions begin. Let&#39;s prove it to ourselves with GDB.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/b/be3857835e3f6928606fa30b1a67bc4395b114cf.png&quot; width=&quot;571&quot; height=&quot;415&quot;&gt;

I set a breakpoint right before the func() call and inspected its GOT entry, which includes by no surprise, as we noticed earlier, the address of its PLT entry. Let&#39;s move to the next instruction and have a look at the GOT entry again.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/d/d768bb12324bc01e164f3ea3ce9c8be6e4b0d374.png&quot; width=&quot;525&quot; height=&quot;443&quot;&gt;

Voila! The GOT entry is fully patched and it contains our function&#39;s address! Meaning, the next time func() will be called, there won&#39;t be any back and forth jumping between PLT and GOT.

---
### `Conclusion`

If you are reading this sentence, you are a true champ. A couple of notes:

* I&#39;m not a native english speaker and this write-up was quite lengthy. Meaning, the more words I write, the bigger the chance for grammatical and vocabulary mistakes. I&#39;ll try to correct them asap if there are any.

* I decided not to include the 64-bit version since this post will end up being a book. It&#39;s also the same process with one minor difference. If you really can&#39;t figure out the differences, feel free to request a version for it in the comments. The most important part was to understand the relationship between PLT, GOT and the ELF structures.

If you have any questions, please don&#39;t hesitate asking me. I&#39;d like to thank you for taking the time to read my paper and have an awesome day.

Peace,
@_py</description>
    
    <lastBuildDate>Wed, 10 May 2017 15:36:35 +0000</lastBuildDate>
    <category>Linux</category>
    <atom:link href="https://0x00sec.org/t/linux-internals-the-art-of-symbol-resolution/1488.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Linux Internals - The Art Of Symbol Resolution</title>
        <dc:creator><![CDATA[_py]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 30 days. New replies are no longer allowed.</p>
          <p><a href="https://0x00sec.org/t/linux-internals-the-art-of-symbol-resolution/1488/8">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/linux-internals-the-art-of-symbol-resolution/1488/8</link>
        <pubDate>Sun, 21 Jan 2018 00:36:56 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1488-8</guid>
        <source url="https://0x00sec.org/t/linux-internals-the-art-of-symbol-resolution/1488.rss">Linux Internals - The Art Of Symbol Resolution</source>
      </item>
      <item>
        <title>Linux Internals - The Art Of Symbol Resolution</title>
        <dc:creator><![CDATA[_py]]></dc:creator>
        <description><![CDATA[
            <p>Thank you for the feedback! I can relate to you since it took me a while to grasp such a technical concept but after a while it all makes sense and I’m glad it did for you as well.</p>
<p>As for your suggestion, I see your point. But, there’s a reason I did not analyze <strong>at that part</strong> the sentence you suggested. I wanted to dedicate a section of the paper to explain the relocation offset and its use so that the reader won’t get confused with all the ELF terms. Which I did if you noticed.</p>
<blockquote>
<p>In case you forgot, that is one of the instructions in the func()'s PLT entry. What does it really do though? 0x18 is an offset inside the .rel.plt section. You can think of .rel.plt as an array of Elf_Rel structures and each one of them describes a different function. 0x18 is practically saying "add 0x18 to the address of the .rel.plt section - &gt; read the relocation entry fields that describe func() - &gt; and pass them to the dynamic linker’s function so he can patch the desired address.</p>
</blockquote>
<p>As for the below part you suggested:</p>
<blockquote>
<p>The GOT entry points back to func()'s PLT code. This is only for the first time because the address in GOT entry isn’t patched yet with the real address of func().</p>
</blockquote>
<p>I believe the ascii arts and the GDB snippets illustrate exactly that. But I can add it in a text form as well I guess. Though an image is much more comprehensive imo.</p>
<p>Thank you for taking the time to read my write-up.</p>
<p>Cheers!</p>
<p>P.S I mentioned in this post that I explained GOT/PLT in the past (though not as such technical level). You might want to take a look at it as well. It’s more theoretical but who knows, it may help you understand it even more. The more resources, the better.</p>
<aside class="quote quote-modified" data-post="1" data-topic="1082">
  <div class="title">
    <div class="quote-controls"></div>
    <img alt="" width="20" height="20" src="/user_avatar/0x00sec.org/_py/40/4275_2.png" class="avatar">
    <a href="https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082">Linux Internals ~ Dynamic Linking Wizardry</a> <a class="badge-wrapper  bullet" href="https://0x00sec.org/c/linux/64"><span class="badge-category-bg" style="background-color: #283890;"></span><span style="" data-drop-close="true" class="badge-category clear-badge">Linux</span></a>
  </div>
  <blockquote>
    UPDATE: Please refer to <a href="https://0x00sec.org/t/linux-internals-the-art-of-symbol-resolution/1488">Linux Internals - The Art Of Symbol Resolution</a> for a more detailed and updated analysis of the concept. 
Hey peeps! I hope you’re all doing great. It’s been a long time since my last post. Anyway, today I present to you something completely different from what you’ve been used to seeing from me. This is more a self-research/study material. I’m nowhere close to being an expert on this subject but I busted my ass off trying to understand the inner workings of Linux executab…
  </blockquote>
</aside>

          <p><a href="https://0x00sec.org/t/linux-internals-the-art-of-symbol-resolution/1488/7">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/linux-internals-the-art-of-symbol-resolution/1488/7</link>
        <pubDate>Wed, 10 May 2017 06:17:03 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1488-7</guid>
        <source url="https://0x00sec.org/t/linux-internals-the-art-of-symbol-resolution/1488.rss">Linux Internals - The Art Of Symbol Resolution</source>
      </item>
      <item>
        <title>Linux Internals - The Art Of Symbol Resolution</title>
        <dc:creator><![CDATA[shahril]]></dc:creator>
        <description><![CDATA[
            <p>This is a pure gold man.</p>
<p>Sincerely the first time I read it doesn’t make any sense until I got to the “memory image after patching”. Re-reading again and it starts to make sense!</p>
<p>Thanks for the paper, and the ASCII drawing. <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<p><strong><em>Edit:</em></strong></p>
<p>I have a minor suggestion for your paper, for this section:</p>
<p>“3. The GOT entry points back to func()'s PLT code which in return pushes a relocation offset.”</p>
<p>It is wise to change it into more descriptive manner, such as</p>
<p>“3. The GOT entry points back to func()'s PLT code. This is only for the first time because the address in GOT entry isn’t patched yet with the real address of func().<br>
4. After transfer control back to the func()'s PLT code, the first instruction is to <code>push 0x18</code>. This is a relocation offset for dynamic linker in order to resolve real func()'s address (which will be explained more below).”</p>
          <p><a href="https://0x00sec.org/t/linux-internals-the-art-of-symbol-resolution/1488/6">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/linux-internals-the-art-of-symbol-resolution/1488/6</link>
        <pubDate>Tue, 09 May 2017 23:30:01 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1488-6</guid>
        <source url="https://0x00sec.org/t/linux-internals-the-art-of-symbol-resolution/1488.rss">Linux Internals - The Art Of Symbol Resolution</source>
      </item>
      <item>
        <title>Linux Internals - The Art Of Symbol Resolution</title>
        <dc:creator><![CDATA[_py]]></dc:creator>
        <description><![CDATA[
            <p><a class="mention" href="https://0x00sec.org/u/pry0cc">@pry0cc</a>: I’m not a crypto guy. Can you be more descriptive about your intentions and thoughts?</p>
          <p><a href="https://0x00sec.org/t/linux-internals-the-art-of-symbol-resolution/1488/5">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/linux-internals-the-art-of-symbol-resolution/1488/5</link>
        <pubDate>Fri, 10 Feb 2017 10:00:41 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1488-5</guid>
        <source url="https://0x00sec.org/t/linux-internals-the-art-of-symbol-resolution/1488.rss">Linux Internals - The Art Of Symbol Resolution</source>
      </item>
      <item>
        <title>Linux Internals - The Art Of Symbol Resolution</title>
        <dc:creator><![CDATA[pry0cc]]></dc:creator>
        <description><![CDATA[
            <p>Would utilising something like this</p>
<p><a href="http://www.boost.org/doc/libs/1_63_0/doc/html/boost/dll/shared_library.html" class="onebox" target="_blank">http://www.boost.org/doc/libs/1_63_0/doc/html/boost/dll/shared_library.html</a></p>
<p>do the same job?</p>
          <p><a href="https://0x00sec.org/t/linux-internals-the-art-of-symbol-resolution/1488/4">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/linux-internals-the-art-of-symbol-resolution/1488/4</link>
        <pubDate>Fri, 10 Feb 2017 09:24:08 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1488-4</guid>
        <source url="https://0x00sec.org/t/linux-internals-the-art-of-symbol-resolution/1488.rss">Linux Internals - The Art Of Symbol Resolution</source>
      </item>
      <item>
        <title>Linux Internals - The Art Of Symbol Resolution</title>
        <dc:creator><![CDATA[_py]]></dc:creator>
        <description><![CDATA[
            <p><a class="mention" href="https://0x00sec.org/u/oaktree">@oaktree</a>: You are right. This is just an implementation. Surely you can create your own, but you have to be hardcore as you can see. I mean, just look at the detail and precision. This is no game.</p>
<p>Just imagine this:</p>
<p>Creating a malware with your own compiler and linker. Scary man.</p>
          <p><a href="https://0x00sec.org/t/linux-internals-the-art-of-symbol-resolution/1488/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/linux-internals-the-art-of-symbol-resolution/1488/3</link>
        <pubDate>Thu, 26 Jan 2017 01:10:10 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1488-3</guid>
        <source url="https://0x00sec.org/t/linux-internals-the-art-of-symbol-resolution/1488.rss">Linux Internals - The Art Of Symbol Resolution</source>
      </item>
      <item>
        <title>Linux Internals - The Art Of Symbol Resolution</title>
        <dc:creator><![CDATA[oaktree]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="_py" data-post="1" data-topic="1488">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://0x00sec.org/user_avatar/0x00sec.org/_py/40/4275_2.png" class="avatar"> _py:</div>
<blockquote>
<p>Recently, <a class="mention" href="https://0x00sec.org/u/oaktree">@oaktree</a> coded an IRC bot with dynamic linking features which motivated me to finally take the initiative and finish this god damn paper. So without further ado, <a class="mention" href="https://0x00sec.org/u/oaktree">@oaktree</a> and the rest, let’s get right into it.</p>
</blockquote>
</aside>
<p>Wow. A lot more goes into this than I’d thought. I guess I’ve been taking it all for granted…</p>
<p>Sooo the assembly stuff is just some standard, right? Because there are probably other ways to do symbol resolution if you wanted to and you wrote your own compiler. Right?</p>
          <p><a href="https://0x00sec.org/t/linux-internals-the-art-of-symbol-resolution/1488/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/linux-internals-the-art-of-symbol-resolution/1488/2</link>
        <pubDate>Thu, 26 Jan 2017 01:04:33 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1488-2</guid>
        <source url="https://0x00sec.org/t/linux-internals-the-art-of-symbol-resolution/1488.rss">Linux Internals - The Art Of Symbol Resolution</source>
      </item>
      <item>
        <title>Linux Internals - The Art Of Symbol Resolution</title>
        <dc:creator><![CDATA[_py]]></dc:creator>
        <description><![CDATA[
            <p>Hello peeps! Been a while. I hope you’re all doing great. This write-up was supposed to be up way sooner to be honest. Recently, <a class="mention" href="https://0x00sec.org/u/oaktree">@oaktree</a> coded an IRC bot with dynamic linking features which motivated me to finally take the initiative and finish this god damn paper. So without further ado, <a class="mention" href="https://0x00sec.org/u/oaktree">@oaktree</a> and the rest, let’s get right into it.</p>
<p>Today we are continuing our journey towards the in-depth understanding of our binaries. If this is the first write-up you are reading regarding my series on Linux Internals, I suggest you going through my <a href="https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082">Dynamic Linking Wizardry</a> post before you keep on reading. The aforementioned article wasn’t too “practical” for my standards so let’s dive deeper this time with some PoC.</p>
<p>Enjoy!</p>
<hr>
<h3><code>Introduction</code></h3>
<p>Right, firstly, let’s simplify and visualize some terms because those damn Computer Scientists love making our life hard by creating all kinds of confusing name conventions. <strong><em>Symbol</em></strong> is a fancy term to describe mainly functions, objects, variables. In reality, a symbol is just an address / offset. " But what do you mean by that <a class="mention" href="https://0x00sec.org/u/_py">@_py</a>? " Glad you asked.</p>
<p>Below is a disassembly snippet of one of the PoC binaries I’ll be using for today.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/4/4f307627778c1c3473c628f4809049bce670ea13.png" width="598" height="169"></p>
<p>Even if you never attempted to disassembly a function, it’s crystal clear that this is the disassembly of our <strong><em>main</em></strong> fuction (shown at the top-left corner of the image). But what else do you see? You see some weird number ( 0x80484a4 ) next to its name. This is its starting address ( in hex ). Meaning, main is practically a bunch of instructions ( 0s and 1s) at a certain offset in our address space. That simple.</p>
<p>The above explanation wasn’t really necessary for the completeness of this article but I always believed that the best way to solidify a concept, is by simplifying it as much as possible. In my opinion, If there is something to take away from this article is this:</p>
<hr>
<p><strong><em>Everything is 0s and 1s ( or for the hardware guys, high voltage-low voltage) . What makes your computer do what it does is the context in which is seeing those 0s and 1s</em>.</strong></p>
<hr>
<p>Phew, after this small break, let’s get back to business.</p>
<p><strong><em>Note</em></strong>: <em>I’ll be referring to variables, functions as objects from time to time for generality purposes</em>.</p>
<h3><code>Symbol Resolution</code></h3>
<p>You can think of symbol resolution as the DNS of binaries. Simply put, it’s a process of mapping and finding objects in the address space. A curious person would ask " why the hell do we need any of it in the first place? " Well, let me show you.</p>
<p><strong><em>Note</em></strong>: <em>I’ll start by covering the 32-bit version and gradually move to the 64-bit one</em>.</p>
<p>This is our source code (32-bit):</p>
<pre><code class="lang-auto">int var = 12;

int func (int b)
{
	return var + b;
}
</code></pre>
<p>We will compile the above code into a shared library / object (.so) by using the <em>-fpic</em> and <em>-shared</em> flags (<a href="http://www.cprogramming.com/tutorial/shared-libraries-linux-gcc.html" rel="noopener nofollow ugc">how-to</a> ). If you don’t know what shared libraries are, google it, it’s quite simple. It’s practically a bunch of function , variable, object declarations / definitions which you can embed in your main binary’s address space and refer to them “as if” they were defined in your executable’s source file. Anyway, the point I want to prove with the above source code is this:</p>
<p>Our func() function returns a sum. This sum refers to an object outside of the function scope (var in our case), right? It somehow needs to find its location ( address / offset ) in order to read its value before the addition can take place. Which proves my point at the beginning of this article. “var” is practically an address / offset which contains a value. Let’s investigate how this is being accomplished. At start, it might seem weird but while we uncover it gradually you’ll realize that it’s actually quite trivial.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/a/ad31451e5421a873da3422523e62e7b0758dc6a9.png" width="647" height="254"></p>
<p>The most interesting part of the above snippet is at offset <strong><em>0x42f</em></strong>. Let’s have a closer look at the function being called.</p>
<pre><code class="lang-auto">mov ecx, DWORD PTR [esp]
ret
</code></pre>
<p>The low-level veterans probably already see where this is going but let’s walk through it together.</p>
<p>Func() calls <strong>&lt;__i686.get_pc_thunk.cx&gt;</strong> which in return places the <em>return address</em> from the stack into the ecx register. Let’s have a stack-calling-convention crash course for the newbie ones so you can be able to make sense out of the rest of this write-up.</p>
<hr>
<h3><code>Stack Calling Convention Crash Course </code></h3>
<pre><code class="lang-makefile"> 
                           +--------------+
                           |     ...      |
                           |     args     |
                           | func() vars  |
                           +--------------+
                           |  return addr | &lt;-- func() pushes the address 
                           +--------------+     of the next instruction on the stack.
                           |     ...      |
                           |     args     |
                           |thunk.cx vars |
                           +--------------+
</code></pre>
<p>So, what’s really going on? The above masterpiece is an  overly-simplified image of the stack <strong>RIGHT</strong> when the call instruction happened. I’ve precluded some info such as local variable allocation, but it’s not interesting to us at the moment.</p>
<p>Let’s think of it logically. func() is just an address in memory and you want to call a function ( jump to a different address in memory ). Wouldn’t you want to know the way back to func() once you are done with the call to thunk.cx()? Well, that’s how computers do it: They push the address of the next instruction of the <em>caller</em> ( func ) on the stack so as once the <em>callee</em> ( thunk.cx ) is done, the execution can resume at the address of the <em>caller</em> ( func ). Simple and genius.</p>
<hr>
<p>Let’s go back to our scenario.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/7/77a3a1e9b2a608de055829ed06f88e828f96ee98.png" width="647" height="254"></p>
<p><em>ECX</em> contains the address of the <strong>next</strong> instruction once thunk.cx() has returned. Then, an interesting addition is going on. Hm, an offset is being added to ecx. But why? Well, this is where the one and only Global Offset Table, aka GOT, joins the party. GOT is one of the most fundamental pieces in ELF binaries and I’ve written extensively about it <a href="https://0x00sec.org/t/linux-internals-dynamic-linking-wizardry/1082">here</a> and there is more on google. Basically, it’s an array of symbol addresses.</p>
<p>The secret behind the offset addition is:</p>
<hr>
<p><em><strong>The offset between the text segment ( machine instructions ) and data segment ( global / static variables ) is known at link-time.</strong></em></p>
<hr>
<p>What does that practically mean? Well, the linker ( the one responsible for symbol resolution ) knows during run-time the location of every section / segment. Meaning, while we are executing the func()'s instructions ( stored in the text segment ) and we try to refer to an object further away ( recall from our example the “var” global variable which is stored in the data segment ), the linker will add a known offset to the address being executed and resolve the symbol’s offset. Right, all this might sound fancy and crazy but let’s draw it out, shall we?</p>
<pre><code class="lang-makefile">    +--------------------+   var
    |     Data Segment   | &lt;-----
    |.data, .got, .symtab|      |
    |       ....         |      |
    +--------------------+      |
    |       ....         |     +0x1bc0 = offset
    |       ....         |      |
    +--------------------+      |
    |     Text Segment   |      | 
    |   .text, .rodata   |  ---------&gt; return var + b;
    | func() refs "var"  |
    +--------------------+
</code></pre>
<p>So the offset addition makes ecx point to the area where “var” can be found, aka GOT. Let’s construct a PoC and prove it to ourselves. Remember, the assembly never lies. Here is our tiny main binary which will be linked against the shared library we created before.</p>
<pre><code class="lang-auto">int main()
{
	func(2);
	return 6;
}
</code></pre>
<p>Now let’s fire up GDB.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/c/ca2dd0e1fe58c6b24c2e38e9b541038d59b12047.png" width="348" height="90"></p>
<p>Let’s inspect the assembly.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/0/094d4bd1c8879c3a640321fda7d113d00e220b04.png" width="630" height="191"></p>
<p>Let’s make some notes for the above image:</p>
<ul>
<li>The address we are at during the breakpoint is <em>0xb7fd843a</em>, which is a classic offset for a shared library’s code and text segment.</li>
<li>thunk.cx is being called and does its magic as we said before</li>
<li>The known offset is being added to ecx and now ecx points to the GOT, which is where the “var” reference can be found.</li>
</ul>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/6/69a40cecbd95777762fc201387b5e558f1f4cc85.png" width="385" height="53"></p>
<p>As you can see, ecx hold the address 0xb7fd9ff4, which should be a GOT address. Let’s find it out.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/b/bca3cbe5bb5bff468b740646ad3bfb7fa9e8f370.png" width="690" height="46"></p>
<p>The column on the right of “PROGBITS” is the offset of GOT’s address ( <em>0xb7fd1fe4</em> ) from the base address of our shared library. In case you didn’t notice it, ecx points a couple bytes after GOT’s base address. In particular, it points to <em>0xb7fd9ff4</em>, which looks identical to .got.plt’s offset. Damn! Did <a class="mention" href="https://0x00sec.org/u/_py">@_py</a> lose his mind? Well, stay with me. Let’s dissect the disassembly.</p>
<pre><code class="lang-auto">mov   eax,DWORD PTR [ecx-0xc]  &lt;-$pc
mov   eax,DWORD PTR [eax]

</code></pre>
<p>The program counter ( PC ) points to the next instruction that is about to be executed right after the breakpoint. The first instruction will do the following:</p>
<ul>
<li>0xc will be subtracted from the value of ecx. Thus, 0xb7fd9ff4 - 0xc = 0xb7fd9fe8.</li>
<li>Read the address stored at address 0xb7fd9fe8.</li>
<li>Dereference the address and store its content in eax.</li>
</ul>
<p>Another drawing incoming:</p>
<pre><code class="lang-makefile">    GOT: 0xb7fd1fe4  +-----------------+   
                     |   dynamic ptr   |
                     +-----------------+
                     | link_map* struct|
                     +-----------------+
                     |   dl_resolve()  |
                     +-----------------+
                     |      ....       |
                     +-----------------+
                     |      ....       |
                     +-----------------+
                     |    var's addr   |    &lt;-------- new ecx 
                     +-----------------+       |
                     |      ....       |      (-) 0xc
                     +-----------------+       |
                     |      ....       |   &lt;---- ecx after addition
                     +-----------------+

</code></pre>
<p>I want to believe it’s clearer now. The GOT as I said before is an array of pointers. One of its indices contains the address of var ( ignore the dl_resolve() and link_map info ).The 2nd instruction will dereference var’s address and place its content ( 12 in our case ) into eax. Nice and easy. For clarity purposes, let’s see what GDB has to say about that.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/a/ad8d15213aee91c36d6dc2f28a63ff3375bcf593.png" width="235" height="69"></p>
<p>Looks like var’s address is <em>0xb7fda00c</em> and it’s stored at address <em>0xb7fd9fe8</em>! Hmm, but is it?</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/a/abcce8057e574158e9ac270f693db99eb50c38e9.png" width="485" height="34"></p>
<p>Ofcourse it is! What the above relocation ( R_386_GLOB_DAT ) is telling us loud and clear is " find the address of var and place it at the offset <em>0x1fe8</em>, which is the GOT address <em>0xb7fd9fe8</em>. "</p>
<hr>
<h3><code>Function Resolution </code></h3>
<p>Now that we know how to reference variables through the help of GOT, it’s time to move on to function resolution, which is pure orgasm. Let’s create our new source files.</p>
<p><em>Shared Library:</em></p>
<pre><code class="lang-auto">int var = 12;

int func_PLT () {
	return var;
}

int func() {
	int a = func_PLT();
	return 0;
}

</code></pre>
<p><em>Main binary:</em></p>
<pre><code class="lang-auto">int main(void)
{
	printf("Shared library mode on.\n");
	func();
	return 0;
}

</code></pre>
<p>Bla bla linking process etc. Off to the meat of our scenario. Let’s have a look at the disassembly.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/c/ceb2e53e3e2d97035e23398ae15584828d22d2c4.png" width="519" height="204"></p>
<p>The first instructions are boring and meaningless to us right now so let’s zoom in to:</p>
<pre><code class="lang-auto">call   0x8048410 &lt;func@plt&gt;
</code></pre>
<p>The above instruction is all the money. It’s where all the magic takes place and let me note that it’s being heavily abused for exploitation purposes. Apparently, we are jumping to address <strong><em>0x8048410</em></strong> in order to execute our shared library’s func() code. Let’s see what’s hiding behind that address.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/8/8360e63f02d9b4a0ec67b18b7f1cea4230d15cab.png" width="480" height="85"></p>
<p>Hm, another jump to a different address? What the hell is going on <a class="mention" href="https://0x00sec.org/u/_py">@_py</a>? Alright, alright, let’s take a step back and rewind.</p>
<hr>
<h3><code>PLT &amp; GOT Bromance</code></h3>
<p>The Procedure Linkage Table, aka PLT, is a section within the text segment which contains executable code. To be exact, it’s an array and each entry contains surgically picked instructions in order to make dynamic linking possible. For instance, 99% of Linux binaries refer to functions that belong to the libc shared library. Each function that you call from libc has a PLT entry with instructions that will help the dynamic linker find their address. But, enough of words, let’s get a pen and draw it out.</p>
<p>This is how memory looks like when func() is about to get called <em><strong>for the 1st time</strong></em>:</p>
<pre><code class="lang-makefile">          --&lt;  +--------------+
     main |    |     ...      |
          |    | jmp func@plt | _ _
          |    |     ...      |     \                     PLT
          --&lt;  +--------------+      \             +-----------------+
                                      \            |     PLT stub:   |
                                       \           |  push link_map* |  &lt;-
                                        \          | jmp dl_resolve()|     \
                                         \         +-----------------+      |
                                          \        |       ...       |      |
                                           \       |       ...       |      |
                                            \      |       ...       |      |
                                             \     +-----------------+      |
                                              ---&gt; |    PLT[func]    |      |
                                                 _ |0:jmp *GOT[func] |      |
                     GOT                       /   |1:push rel_index |      |
                +-------------+               /    |     jmp stub    |   _ /
                | .dynamicptr |              /     +-----------------+
                +-------------+             /                               
                | link_map ptr|            /
                +-------------+           /    
                | dl_resolve()|          /
                +-------------+         /
                |     ...     |        /
                +-------------+       /
                |  GOT[func]  |      / 
                |    PLT :1   |  &lt;---
                +-------------+  
</code></pre>
<p>Let’s analyze the above snippet with the help of assembly. As we saw before, the PLT entry of func() contains the following machine instructions:</p>
<pre><code class="lang-auto">/*
      Jump to the address contained in 0x804a00c 
      which can be found at the data segment (ds).
      0x804a00c is a GOT address.
*/
jmp    DWORD PTR ds:0x804a00c 
/* Push .rel.plt relocation offset (will be explained shortly). */
push   0x18
/* Jump to the PLT stub code. */
jmp    80483d0 
</code></pre>
<p>When our main function calls func(), it executes the following instructions:</p>
<ol>
<li>Jump to the PLT entry of func().</li>
<li>The PLT entry instructs an indirect jump to a the func()'s GOT entry.</li>
<li>The GOT entry points back to func()'s PLT code which in return pushes a relocation offset.</li>
<li>PLT transfers control to the stub, a special PLT entry which pushes a link_map pointer on the stack before calling the dynamic linker for symbol resolution.</li>
<li>Dynamic linker resolves func()'s address and patches the GOT entry for future references.</li>
</ol>
<p>Before I explain a little bit more about step <span class="hashtag">#3</span> and <span class="hashtag">#4</span>, let me prove to you step <span class="hashtag">#2</span>.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/6/6bede06b8f64983a166dd2556ab3e28e8addcfa2.png" width="485" height="133"></p>
<p>As promised, step <span class="hashtag">#2</span> will jump to the address contained in <strong><em>0x80400c</em></strong> which is by no suprise, <strong><em>0x08048416</em></strong>, aka func()'s PLT code ( push 0x18 ).</p>
<hr>
<h3><code>link_map Structure</code></h3>
<p>This is a really interesting structure, especially from an exploit dev perspective. Let’s have a look at its members.</p>
<pre><code class="lang-auto">struct link_map
{
   /* Shared library's load address. */
   ElfW(Addr) l_addr;                 
   /* Pointer to library's name in the string table. */                                 
   char *l_name;    
   /* 
        Dynamic section of the shared object.
        Includes dynamic linking info etc.
        Not interesting to us.  
   */                   
   ElfW(Dyn) *l_ld;   
   /* Pointer to previous and next link_map node. */                 
   struct link_map *l_next, *l_prev;   
};
</code></pre>
<p>Pretty fun stuff eh? Let’s rewind. As I mentioned before at step <span class="hashtag">#4</span>, the PLT entry will push a link_map struct pointer on the stack and then call the dynamic linker. Since we are working on 32-bit binaries, that can only mean one thing. The link_map pointer is one of the arguments ( the second one is the relocation offset which I’ll describe right after ) the dynamic linker needs ( keep in mind that function arguments on 32-bit binaries are passed through the stack ) in order to resolve func()'s address. In practice, its members will be populated at <strong><em>run-time</em></strong> with the appropriate info ( the shared library in which func() belongs to, the shared library’s address etc ).</p>
<hr>
<h3><code>Extra PoC</code></h3>
<p>Even though a PoC isn’t a must for our case, I’ll add it for the low-level guys.</p>
<p><strong>Note</strong>: <em>I’ve used the objdump utility to find the GOT’s address so I will not include that in the PoC.</em></p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/f/f9cfbc53ddf10557ef001e7daca4e657e439e4a9.png" width="690" height="189"></p>
<p>Aye! We did it! All you need to do in order to understand what just happened is a look at the link_map’s struct members and GOT’s address space which I drew in a quite detailed manner for you. If any of you have questions on how I did it, feel free to comment it down below and I’ll gladly explain it to you. It’s just that it’s not really important in order to grasp the concept of symbol resolution.</p>
<hr>
<h3><code>Relocation Entries</code></h3>
<p>Even though I’ve briefly explained relocations in the past, it’s about time we get reminded of them. Let’s study the format of those relocations:</p>
<p><strong><em>Note</em></strong>: <em>This is a “pseudo” version of the official 64-bit relocation structure specification. They don’t differ in anything, but the one below will make much more sense, you’ll see why I did that shortly</em>. <em>And yes, I know, we are talking about 32-bit binaries while the structure is the 64-bit one, but they aren’t any different so why not</em>.</p>
<pre><code class="lang-auto">     typedef struct {
            /*
              Absolute address in memory where the address
              of the symbol should be written to.
 
              The r_offset value is mostly a GOT address.
              What else could it be.

            */
            long r_offset;
            /* 
                 Relocation type &amp; symbol table index. 

                 The relocation type is a pseudo mathematical
                 formula in order to computer the offset.

                 The symbol table index is basically 
                 an offset in an array of Elf_Symbol structs.
                 
                 In reality, r_info is:
                 long type:32,
                 long symbol:32;
                   _ _ _ _ _ r_info _ _ _ _ _ _
                 |                              |
                       type           symbol
                 |--------------||--------------|
                        32              32

                 The three least significant bytes are 
                 used as an index in the .dynsym 
                 and it's calculated through the below macro:
                 #define ELF64_R_SYM(info)  ((info)&gt;&gt;32)
                 
            */
            long r_info;
            /* Boring. */
            long addend;
      } Elf_Rel;
</code></pre>
<p>This is the format of a relocation entry. Makes no sense for now but stay with me. Let’s have a flashback.</p>
<pre><code class="lang-auto">/* Push .rel.plt relocation offset. */
push   0x18
</code></pre>
<p>In case you forgot, that is one of the instructions in the func()'s PLT entry. What does it really do though? 0x18 is an <strong><em>offset</em></strong> inside the .rel.plt section. You can think of .rel.plt as an array of Elf_Rel structures and each one of them describes a different function. 0x18 is practically saying "add 0x18 to the address of the .rel.plt section - &gt; read the relocation entry fields that describe func()  - &gt; and pass them to the dynamic linker’s function so he can patch the desired address.</p>
<p>As I mentioned above, the result of the  <strong><span class="hashtag">#define</span> ELF64_R_SYM(info)  ((info)&gt;&gt;32)</strong> macro is an index into the the dynamic symbol table. An ELF binary has a symbol table and a dynamic symbol table. The latter refers to imported functions and the first one to symbols defined by the us, the programmer. Both tables are populated with the same Elf_Sym structure. Let’s have a look at a pseudo version of it as well.</p>
<pre><code class="lang-auto">typedef struct {
      /* 
           Offset into the string table that points to the 
           null-terminated string of the symbol.
      */    
      int name;
      /*
           The info field is split up into 2 parts as well.

            _ _ _ _ _ _ _ info _ _ _ _ _ _ _
           |                                |
                 type           binding
           |---------------||---------------|
                  4                 4
           Type: Function or data ( 4 bits )
           Binding: Local or global ( 4 bits )
        
           There are defined macros in order to calculate
           the above values as well but we already
           saw too much for today.
      */
      unsigned char info;
      /* Unused. */
      char reserved;
      /* Section header index. */
      short section;
      /* Section offset / absolute address */
      long value;
      /* Symbol's size in bytes. */
      long size;
} Elf_Sym
</code></pre>
<p>Let’s recap:</p>
<hr>
<p><strong><em>When we import a function from a shared library, our binary’s address space is being populated with a bunch of arrays of structures in order to make dynamic linker’s life easier. In particular, there will be a null-terminated string in the dynamic string table section, a Symbol structure describing some of the symbol’s attributes and finally a few relocation instances in the .rel.plt section pointing to those symbol structures.</em></strong></p>
<hr>
<p>I don’t know if you noticed it, but if you actually write down the process, it makes so much sense. What do I mean by that? The linker will need a few vital info in order to resolve the symbol’s address and it gets those through the aforementioned structures.</p>
<ol>
<li>Symbol’s relocation offset.</li>
<li>The section where the symbol is defined.</li>
<li>Symbol’s type.</li>
<li>Symbol’s name.</li>
</ol>
<p>Sweet! Ezpz m8! Let’s revise the steps of the symbol resolution process:</p>
<ol>
<li>Jump to the PLT entry of our symbol.</li>
<li>Jump to the GOT entry of our symbol.</li>
<li>Jump back to the PLT entry and push an offset on the stack. That offset is actually an Elf_Rel structure describing how to patch the symbol.</li>
<li>Jump to the PLT stub entry.</li>
<li>Push a pointer to a link_map structure in order for the linker to find in which library the symbol belongs to.</li>
<li>Call the dynamic linker.</li>
<li>Patch the GOT entry.</li>
</ol>
<hr>
<h3><code>Memory Image After Patching</code></h3>
<p>One more drawing to go! Oh boy!</p>
<pre><code class="lang-makefile">          --&lt;  +--------------+
     main |    |     ...      |
          |    | jmp func@plt | _ _
          |    |     ...      |     \                     PLT
          --&lt;  +--------------+      \             +-----------------+
                                      \            |     PLT stub:   |
                                       \           |  push link_map* |  &lt;-
                                        \          | jmp dl_resolve()|     \
                                         \         +-----------------+      |
                                          \        |       ...       |      |
                                           \       |       ...       |      |
                                            \      |       ...       |      |
                                             \     +-----------------+      |
                                              ---&gt; |    PLT[func]    |      |
                                                 _ |0:jmp *GOT[func] |      |
                     GOT                       /   |1:push rel_index |      |
                +-------------+               /    |     jmp stub    |   _ /
                | .dynamicptr |              /     +-----------------+
                +-------------+             /                               
                | link_map ptr|            /
                +-------------+           /    
                | dl_resolve()|          /
                +-------------+         /
                |     ...     |        /
                +-------------+       /
                |  GOT[func]  |      / 
                |   func()    |  &lt;-------
                +-------------+           \
                                           \
                                            \
                                             -----&gt;      Shared Library
                                                    +----------------------+
                                                    | func() code:         |
                                                    |      mov dis, dat    |
                                                    |           ...        |
                                                    +----------------------+
</code></pre>
<p>The only difference now is that the func()'s GOT entry doesn’t contain an address of the PLT entry anymore, but the address in the shared library where the func() instructions begin. Let’s prove it to ourselves with GDB.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/b/be3857835e3f6928606fa30b1a67bc4395b114cf.png" width="571" height="415"></p>
<p>I set a breakpoint right before the func() call and inspected its GOT entry, which includes by no surprise, as we noticed earlier, the address of its PLT entry. Let’s move to the next instruction and have a look at the GOT entry again.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/d/d768bb12324bc01e164f3ea3ce9c8be6e4b0d374.png" width="525" height="443"></p>
<p>Voila! The GOT entry is fully patched and it contains our function’s address! Meaning, the next time func() will be called, there won’t be any back and forth jumping between PLT and GOT.</p>
<hr>
<h3><code>Conclusion</code></h3>
<p>If you are reading this sentence, you are a true champ. A couple of notes:</p>
<ul>
<li>
<p>I’m not a native english speaker and this write-up was quite lengthy. Meaning, the more words I write, the bigger the chance for grammatical and vocabulary mistakes. I’ll try to correct them asap if there are any.</p>
</li>
<li>
<p>I decided not to include the 64-bit version since this post will end up being a book. It’s also the same process with one minor difference. If you really can’t figure out the differences, feel free to request a version for it in the comments. The most important part was to understand the relationship between PLT, GOT and the ELF structures.</p>
</li>
</ul>
<p>If you have any questions, please don’t hesitate asking me. I’d like to thank you for taking the time to read my paper and have an awesome day.</p>
<p>Peace,<br>
<a class="mention" href="https://0x00sec.org/u/_py">@_py</a></p>
          <p><a href="https://0x00sec.org/t/linux-internals-the-art-of-symbol-resolution/1488/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/linux-internals-the-art-of-symbol-resolution/1488/1</link>
        <pubDate>Wed, 25 Jan 2017 21:24:56 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1488-1</guid>
        <source url="https://0x00sec.org/t/linux-internals-the-art-of-symbol-resolution/1488.rss">Linux Internals - The Art Of Symbol Resolution</source>
      </item>
  </channel>
</rss>
