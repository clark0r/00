<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>How can I rewrite this project using C#? - Programming - 0x00sec - The Home of the Hacker</title>
<meta name="description" content="I want to implement a way to copy Chrome’s Cookies file to a specific directory, but the Cookies file will be occupied by Chrome making it impossible to copy it, I have learned that I can find the handles that occupy thi&amp;hellip;">
<meta name="generator" content="Discourse 3.1.0.beta6 - https://github.com/discourse/discourse version 80a1709965fa59da824b2e3392976fc6fc898f80">
<link rel="icon" type="image/png" href="../../uploads/default/optimized/2X/3/30c4e7d76acf879a124fdfe4d8d126afe628c189_2_32x32.png">
<link rel="apple-touch-icon" type="image/png" href="../../uploads/default/optimized/2X/c/c5e37f667fd0fe006ffa67653c662fb64fec597e_2_180x180.png">
<meta name="theme-color" media="all" content="#171616">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, user-scalable=yes, viewport-fit=cover">
<link rel="canonical" href="38510.html" />
<link rel="search" type="application/opensearchdescription+xml" href="../../opensearch.xml" title="0x00sec - The Home of the Hacker Search">
<link href="../../stylesheets/color_definitions_0x00sec-v2_15_57_a5ef387651921c3e4c7aa1108536015ba8299efb.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" class="light-scheme" />
<link href="../../stylesheets/desktop_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="desktop" />
<link href="../../stylesheets/chat_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="chat" />
<link href="../../stylesheets/discourse-details_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-details" />
<link href="../../stylesheets/discourse-lazy-videos_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-lazy-videos" />
<link href="../../stylesheets/discourse-local-dates_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-local-dates" />
<link href="../../stylesheets/discourse-narrative-bot_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-narrative-bot" />
<link href="../../stylesheets/discourse-presence_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-presence" />
<link href="../../stylesheets/discourse-spoiler-alert_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-spoiler-alert" />
<link href="../../stylesheets/docker_manager_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="docker_manager" />
<link href="../../stylesheets/poll_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="poll" />
<link href="../../stylesheets/chat_desktop_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="chat_desktop" />
<link href="../../stylesheets/poll_desktop_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="poll_desktop" />
<link href="../../stylesheets/desktop_theme_46_f36ade55bf80933494fe3b5fab518f477de3bd4e.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="desktop_theme" data-theme-id="46" data-theme-name="header links v2" />
<link href="../../stylesheets/desktop_theme_57_8c0e890a61cdb4c5833a9f9c96664ed164e7d645.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="desktop_theme" data-theme-id="57" data-theme-name="0x00sec-v2" />
<link rel="stylesheet" href="https://s3.amazonaws.com/0x00sec/monokai-sublime.css">
<script src="https://s3.amazonaws.com/0x00sec/highlight.pack.js"></script>
<link rel="preload" href="../../theme-javascripts/440fd21108f5ba9e5dfe06cca9fc842569d5a874.js%3F__ws=0x00sec.org" as="script">
<script defer src="../../theme-javascripts/440fd21108f5ba9e5dfe06cca9fc842569d5a874.js%3F__ws=0x00sec.org" data-theme-id="40"></script>
<link rel="alternate nofollow" type="application/rss+xml" title="RSS feed of &#39;How can I rewrite this project using C#?&#39;" href="38510.rss" />
<meta property="og:site_name" content="0x00sec - The Home of the Hacker" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://0x00sec.org/uploads/default/original/2X/2/27a5373af868edade07624e8205c46e79c247445.jpeg" />
<meta property="og:image" content="https://0x00sec.org/uploads/default/original/2X/2/27a5373af868edade07624e8205c46e79c247445.jpeg" />
<meta property="og:url" content="https://0x00sec.org/t/how-can-i-rewrite-this-project-using-c/38510" />
<meta name="twitter:url" content="https://0x00sec.org/t/how-can-i-rewrite-this-project-using-c/38510" />
<meta property="og:title" content="How can I rewrite this project using C#?" />
<meta name="twitter:title" content="How can I rewrite this project using C#?" />
<meta property="og:description" content="I want to implement a way to copy Chrome’s Cookies file to a specific directory, but the Cookies file will be occupied by Chrome making it impossible to copy it, I have learned that I can find the handles that occupy this file by traversing all the process handles and shutting them down so that I can copy the Cookies file without shutting down Chrome, but I only I found sample code written in C++, I tried to implement it in C#, but it didn’t close all handles successfully. How can I implement th..." />
<meta name="twitter:description" content="I want to implement a way to copy Chrome’s Cookies file to a specific directory, but the Cookies file will be occupied by Chrome making it impossible to copy it, I have learned that I can find the handles that occupy this file by traversing all the process handles and shutting them down so that I can copy the Cookies file without shutting down Chrome, but I only I found sample code written in C++, I tried to implement it in C#, but it didn’t close all handles successfully. How can I implement th..." />
<meta property="og:article:section" content="Programming" />
<meta property="og:article:section:color" content="92278F" />
<meta property="article:published_time" content="2023-12-27T06:05:13+00:00" />
<meta property="og:ignore_canonical" content="true" />
</head>
<body class="crawler ">
<div id="top-navbar" class="container">
<span id="top-navbar-links" style="display:none;">

<a href="https://init.0x00sec.org" class="dow-menu">Init</a>
<a href="https://discord.gg/c6BHVfn" class="dow-menu">Discord</a>
<a href="https://init.0x00sec.org/?partners" class="dow-menu">Partners</a>
</span>
</div>
<header>
<a href="../../index.html">
0x00sec - The Home of the Hacker
</a>
</header>
<div id="main-outlet" class="wrap" role="main">
<div id="topic-title">
<h1>
<a href="38510.html">How can I rewrite this project using C#?</a>
</h1>
<div class="topic-category" itemscope itemtype="http://schema.org/BreadcrumbList">
<span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
<a href="../../c/programming/61.html" class="badge-wrapper bullet" itemprop="item">
<span class="badge-category-bg" style="background-color: #92278F"></span>
<span class="badge-category clear-badge">
<span class="category-name" itemprop="name">Programming</span>
</span>
</a>
<meta itemprop="position" content="1" />
</span>
</div>
</div>
<div itemscope itemtype="http://schema.org/DiscussionForumPosting">
<meta itemprop="headline" content="How can I rewrite this project using C#?">
<meta itemprop="articleSection" content="Programming">
<meta itemprop="keywords" content>
<div itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
<meta itemprop="name" content="0x00sec - The Home of the Hacker">
<div itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
<meta itemprop="url" content="https://0x00sec.org/uploads/default/original/2X/c/c5e37f667fd0fe006ffa67653c662fb64fec597e.png">
</div>
</div>
<div id="post_1" class="topic-body crawler-post">
<div class="crawler-post-meta">
<span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a itemprop="url" href="https://0x00sec.org/u/pryoc110"><span itemprop="name">pryoc110</span></a>
(pryoc110)
</span>
<link itemprop="mainEntityOfPage" href="38510.html">
<span class="crawler-post-infos">
<time itemprop="datePublished" datetime="2023-12-27T06:05:13Z" class="post-time">
December 27, 2023, 6:05am
</time>
<meta itemprop="dateModified" content="2023-12-27T06:05:13Z">
<span itemprop="position">1</span>
</span>
</div>
<div class="post" itemprop="articleBody">
<p>I want to implement a way to copy Chrome’s Cookies file to a specific directory, but the Cookies file will be occupied by Chrome making it impossible to copy it, I have learned that I can find the handles that occupy this file by traversing all the process handles and shutting them down so that I can copy the Cookies file without shutting down Chrome, but I only I found sample code written in C++, I tried to implement it in C#, but it didn’t close all handles successfully. How can I implement this C++ project completely using C#? Project address:<br>
<a href="https://www.dima.to/blog/how-to-enumerate-all-open-handles-for-all-processes-on-a-windows-machine/" class="onebox" target="_blank" rel="noopener nofollow ugc">https://www.dima.to/blog/how-to-enumerate-all-open-handles-for-all-processes-on-a-windows-machine/</a><br>
<img src="../../images/emoji/twitter/grinning.png%3Fv=12" title=":grinning:" class="emoji only-emoji" alt=":grinning:" loading="lazy" width="20" height="20"></p>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/LikeAction" />
<meta itemprop="userInteractionCount" content="0" />
<span class="post-likes"></span>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/CommentAction" />
<meta itemprop="userInteractionCount" content="0" />
</div>
</div>
<div id="post_2" itemprop="comment" itemscope itemtype="http://schema.org/Comment" class="topic-body crawler-post">
<div class="crawler-post-meta">
<span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a itemprop="url" href="https://0x00sec.org/u/pryoc110"><span itemprop="name">pryoc110</span></a>
(pryoc110)
</span>
<link itemprop="mainEntityOfPage" href="38510.html">
<span class="crawler-post-infos">
<time itemprop="datePublished" datetime="2023-12-27T06:07:59Z" class="post-time">
December 27, 2023, 6:07am
</time>
<meta itemprop="dateModified" content="2023-12-27T06:07:59Z">
<span itemprop="position">2</span>
</span>
</div>
<div class="post" itemprop="text">
<p>program.cs</p>
<pre><code class="lang-auto">using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.IO;
using System.Threading.Tasks;
using static ConsoleApp1.Win32;

namespace ConsoleApp1
{
    class Program
    {
		static string fullPath = @"C:\\Users\\admin\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Network\\Cookies";
		static string destinationPath = @"C:\\Temp\\Cookies";
		static void Main(string[] args)
        {
			
			//Unlock(sourcePath);

			

			ListProcesses();

            try
            {
                CopyFile(fullPath, destinationPath);
                Console.WriteLine("Successful");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"error：{ex.Message}");
            }


        }

		static void ListProcesses()
		{
			Process[] processCollection = Process.GetProcesses();
			foreach (Process p in processCollection)
			{

				if (p.ProcessName == "chrome")
				{
					Console.WriteLine($"ProcessName={p.ProcessName}   ProcessID={p.Id}");

					var hCurrentProcess = Process.GetCurrentProcess().Handle;

					uint targetProcessId = (uint)p.Id;

					
					var hProcess = OpenProcess(OpenProcessDesiredAccess.ProcessDupHandle, false, targetProcessId);
					if (hProcess == IntPtr.Zero)
					{
						throw new UnauthorizedAccessException();  
					}
					var handles = SearchFileHandles(targetProcessId, hProcess, fullPath);  
					foreach (var handle in handles)
					{
						
						DuplicateHandle(hProcess, handle, hCurrentProcess, out var duplicatedHandle, 0, false, 1);
						
						CloseHandle(duplicatedHandle);
					}
					

				}


			}
		}


		static void CopyFile(string sourcePath, string destinationPath)
		{
			
			if (!File.Exists(sourcePath))
			{
				throw new FileNotFoundException("FileNotFound", sourcePath);
			}

			try
			{
				
				File.Copy(sourcePath, destinationPath, true);
			}
			catch (Exception ex)
			{
				
				throw new Exception($"{ex.Message}");
			}
		}


		public static List&lt;IntPtr&gt; SearchFileHandles(uint targetPid, IntPtr hProcess, string fullPath, uint bufSize = 0x8000, uint maxRetry = 8)
		{

			var diskDosName = Marshal.AllocHGlobal(120);
			//if (QueryDosDevice(fullPath[..2], diskDosName, 120) == 0)
			if (QueryDosDevice(fullPath.Substring(0, 2), diskDosName, 120) == 0)
			{
				Marshal.FreeHGlobal(diskDosName);
				throw new Win32Exception();
			}
			var dosPath = Marshal.PtrToStringUni(diskDosName) + fullPath.Substring(0, 2);
			Marshal.FreeHGlobal(diskDosName);
			var currentHandle = Process.GetCurrentProcess().Handle;
			var pHandle = Marshal.AllocHGlobal((int)bufSize);
			var length = 0U;
			for (var i = 0; i &lt; maxRetry; i++)
			{
				if (ZwQuerySystemInformation(SystemInformationClass.SystemExtendedHandleInformation, pHandle, bufSize, ref length) == 0)
				{
					var result = new List&lt;IntPtr&gt;();

					var nInfos = Marshal.ReadInt64(pHandle);
					pHandle += 0x10;

					var objTypeInfo = Marshal.AllocHGlobal(128);
					var objNameInfo = Marshal.AllocHGlobal(1024);
					for (var j = 0; j &lt; nInfos; j++)
					{
						//var ptr = pHandle + Marshal.SizeOf&lt;SystemHandleTableEntryInfoEx&gt;() * j;
						SystemHandleTableEntryInfoEx dummyInstance = new SystemHandleTableEntryInfoEx(); 
						var ptr = pHandle + Marshal.SizeOf(dummyInstance) * j;
						var pid = (uint)Marshal.ReadInt32(ptr + sizeof(ulong));
						if (pid == targetPid)
						{
							var sourceHandle = Marshal.ReadIntPtr(ptr + 2 * sizeof(ulong));
							if (!DuplicateHandle(hProcess, sourceHandle, currentHandle, out var duplicatedHandle, 0, false, 2))
							{
								continue;
							}
							Task.Run(() =&gt; {
								if (ZwQueryObject(duplicatedHandle, ObjectInformationClass.ObjectTypeInformation, objTypeInfo, 128, IntPtr.Zero) != 0)
								{
									return;
								}
								
								unsafe
								{
									if (*(short*)objTypeInfo == 0)
									{
										return;
									}
									var typePtr = *(byte**)(objTypeInfo + 8);
									// File ASCII
									if (*typePtr != 70 || *(typePtr + 2) != 105 || *(typePtr + 4) != 108 || *(typePtr + 6) != 101)
									{
										return;
									}
								}
								if (ZwQueryObject(duplicatedHandle, ObjectInformationClass.ObjectNameInformation, objNameInfo, 1024, IntPtr.Zero) != 0)
								{
									return;
								}
								var strLength = Marshal.ReadInt16(objNameInfo);
								if (strLength == 0)
								{
									return;
								}
								var str = Marshal.PtrToStringUni(objNameInfo + 16, strLength / 2);

								if (str == dosPath)
								{
									result.Add(sourceHandle);
								}
								CloseHandle(duplicatedHandle);
							}).Wait(10);
						}
					}

					Marshal.FreeHGlobal(objTypeInfo);
					Marshal.FreeHGlobal(objNameInfo);

					Marshal.FreeHGlobal(pHandle - 0x10);
					return result;
				}
				bufSize = length + 1024;  
				pHandle = Marshal.ReAllocHGlobal(pHandle, new IntPtr(bufSize));
			}
			throw new Win32Exception();
		}




		public static uint[]? GetFileOccupiedPidList(params string[] fullPaths)
		{
			uint[]? pidList = null;

			var res = RmStartSession(out var handle, 0, Guid.NewGuid().ToString());

			if (res != 0)
			{
				throw new Exception("Could not begin restart session. Unable to determine file locker.");
			}

			try
			{
				uint pnProcInfo = 0, rebootReasons = 0;

				res = RmRegisterResources(handle, (uint)fullPaths.Length, fullPaths, 0, null, 0, null);

				if (res != 0)
				{
					throw new Exception("Could not register resource.");
				}

				//Note: there's a race condition here -- the first call to RmGetList() returns
				//      the total number of process. However, when we call RmGetList() again to get
				//      the actual processes this number may have increased.
				res = RmGetList(handle, out var pnProcInfoNeeded, ref pnProcInfo, null, ref rebootReasons);

				if (res == 234)
				{  // ErrorMoreData
				   // Create an array to store the process results
					var processInfo = new RmProcessInfo[pnProcInfoNeeded];
					pnProcInfo = pnProcInfoNeeded;

					// Get the list
					res = RmGetList(handle, out pnProcInfoNeeded, ref pnProcInfo, processInfo, ref rebootReasons);

					if (res == 0)
					{
						pidList = new uint[pnProcInfo];

						// Enumerate all of the results and add them to the 
						// list to be returned
						for (var i = 0; i &lt; pnProcInfo; i++)
						{
							pidList[i] = processInfo[i].Process.dwProcessId;
						}
					}
					else
					{
						throw new Exception("Could not list processes locking resource.");
					}
				}
				else if (res != 0)
				{
					throw new Exception("Could not list processes locking resource. Failed to get size of result.");
				}
			}
			finally
			{
				RmEndSession(handle);
			}

			return pidList;
		}

		public static void Unlock(string fullPath)
		{
			
			var pidList = GetFileOccupiedPidList(fullPath);
			if (pidList == null)
			{
				return;
			}
			var hCurrentProcess = Process.GetCurrentProcess().Handle;
			foreach (var pid in pidList)
			{
				
				var hProcess = OpenProcess(OpenProcessDesiredAccess.ProcessDupHandle, false, pid);
				if (hProcess == IntPtr.Zero)
				{
					throw new UnauthorizedAccessException();  
				}
				var handles = SearchFileHandles(pid, hProcess, fullPath);  
				foreach (var handle in handles)
				{
					
					DuplicateHandle(hProcess, handle, hCurrentProcess, out var duplicatedHandle, 0, false, 1);
					
					CloseHandle(duplicatedHandle);
				}
			}
		}
	}
}

</code></pre>
<p>win32.cs</p>
<pre><code class="lang-auto">using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleApp1
{
	public static class Win32
	{
		private const string Gdi32 = "gdi32.dll";
		private const string User32 = "user32.dll";
		private const string Kernel32 = "kernel32.dll";

		private const string Ntdll = "ntdll.dll";
		private const string Dwmapi = "dwmapi.dll";
		private const string Rstrtmgr = "rstrtmgr.dll";



		[DllImport(Rstrtmgr, CharSet = CharSet.Unicode)]
		public static extern int RmRegisterResources(uint pSessionHandle, uint nFiles, string[] rgsFilenames, uint nApplications, [In] RmUniqueProcess[]? rgApplications, uint nServices, string[]? rgsServiceNames);

		[DllImport(Rstrtmgr, CharSet = CharSet.Auto)]
		public static extern int RmStartSession(out uint pSessionHandle, int dwSessionFlags, string strSessionKey);

		[DllImport(Rstrtmgr)]
		public static extern int RmEndSession(uint pSessionHandle);

		[DllImport(Rstrtmgr)]
		public static extern int RmGetList(uint dwSessionHandle, out uint pnProcInfoNeeded, ref uint pnProcInfo, [In, Out] RmProcessInfo[]? rgAffectedApps, ref uint lpdwRebootReasons);

		[DllImport(Ntdll)]
		public static extern uint NtQueryInformationProcess(IntPtr ProcessHandle, uint ProcessInformationClass, IntPtr ProcessInformation, uint ProcessInformationLength, out uint ReturnLength);

		[DllImport(Kernel32)]
		public static extern IntPtr OpenProcess(OpenProcessDesiredAccess dwDesiredAccess, [MarshalAs(UnmanagedType.Bool)] bool bInheritHandle, uint dwProcessId);

		[DllImport(Kernel32)]
		public static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, IntPtr lpBuffer, uint nSize, out uint lpNumberOfBytesRead);


		/// &lt;summary&gt;
		/// https://docs.microsoft.com/en-us/windows/win32/sysinfo/zwquerysysteminformation
		/// &lt;/summary&gt;
		/// &lt;param name="SystemInformationClass"&gt;&lt;/param&gt;
		/// &lt;param name="SystemInformation"&gt;&lt;/param&gt;
		/// &lt;param name="SystemInformationLength"&gt;&lt;/param&gt;
		/// &lt;param name="ReturnLength"&gt;&lt;/param&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		[DllImport(Ntdll)]
		public static extern uint ZwQuerySystemInformation(SystemInformationClass SystemInformationClass, IntPtr SystemInformation, uint SystemInformationLength, ref uint ReturnLength);


		[DllImport(Ntdll)]
		public static extern uint ZwQueryObject(IntPtr Handle, ObjectInformationClass ObjectInformationClass, IntPtr ObjectInformation, uint ObjectInformationLength, IntPtr ReturnLength);

		[DllImport(Kernel32, SetLastError = true)]
		public static extern bool DuplicateHandle(IntPtr hSourceProcessHandle, IntPtr hSourceHandle, IntPtr hTargetProcessHandle, out IntPtr lpTargetHandle, uint dwDesiredAccess, bool bInheritHandle, uint dwOptions);

		[DllImport(Kernel32, CharSet = CharSet.Unicode)]
		public static extern uint QueryDosDevice(string deviceName, IntPtr targetPath, uint chMax);

		[DllImport(Kernel32)]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool CloseHandle(IntPtr handle);

		[StructLayout(LayoutKind.Sequential)]
		public struct RmUniqueProcess
		{
			public uint dwProcessId;
			public System.Runtime.InteropServices.ComTypes.FILETIME ProcessStartTime;
		}

		[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
		public struct RmProcessInfo
		{
			public RmUniqueProcess Process;

			[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]
			public string strAppName;

			[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 64)]
			public string strServiceShortName;

			public RmAppType ApplicationType;
			public uint AppStatus;
			public uint TSSessionId;
			[MarshalAs(UnmanagedType.Bool)]
			public bool bRestartable;
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct SystemHandleTableEntryInfoEx
		{
			public ulong Object;

			public ulong UniqueProcessId;
	
			public ulong HandleValue;
			public uint GrantedAccess;
			public ushort CreatorBackTraceIndex;
			public ushort ObjectTypeIndex;
			public uint HandleAttributes;
			public uint Reserved;
		}
		public enum RmAppType
		{
			RmUnknownApp = 0,
			RmMainWindow = 1,
			RmOtherWindow = 2,
			RmService = 3,
			RmExplorer = 4,
			RmConsole = 5,
			RmCritical = 1000
		}




		[Flags]
		public enum OpenProcessDesiredAccess : uint
		{
			VmRead = 0x0010,
			ProcessDupHandle = 0x0040,
			QueryInformation = 0x0400,
			QueryLimitedInformation = 0x1000
		}

		public enum ObjectInformationClass
		{
			ObjectBasicInformation,
			ObjectNameInformation,
			ObjectTypeInformation
		}


		public enum SystemInformationClass
		{
			SystemExtendedHandleInformation = 64
		}

	}
}

</code></pre>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/LikeAction" />
<meta itemprop="userInteractionCount" content="0" />
<span class="post-likes"></span>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/CommentAction" />
<meta itemprop="userInteractionCount" content="1" />
</div>
</div>
<div id="post_3" itemprop="comment" itemscope itemtype="http://schema.org/Comment" class="topic-body crawler-post">
<div class="crawler-post-meta">
<span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a itemprop="url" href="https://0x00sec.org/u/kakekl99"><span itemprop="name">kakekl99</span></a>
(kakekl99)
</span>
<link itemprop="mainEntityOfPage" href="38510.html">
<span class="crawler-post-infos">
<time itemprop="datePublished" datetime="2024-01-10T19:31:58Z" class="post-time">
January 10, 2024, 7:31pm
</time>
<meta itemprop="dateModified" content="2024-01-10T19:31:58Z">
<span itemprop="position">3</span>
</span>
</div>
<div class="post" itemprop="text">
<aside class="quote no-group" data-username="pryoc110" data-post="2" data-topic="38510">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt width="24" height="24" src="../../letter_avatar_proxy/v4/letter/p/e47774/48.png" class="avatar"> pryoc110:</div>
<blockquote>
<pre><code class="lang-auto">using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.IO;
using System.Threading.Tasks;
using static ConsoleApp1.Win32;

namespace ConsoleApp1
{
    class Program
    {
		static string fullPath = @"C:\\Users\\admin\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Network\\Cookies";
		static string destinationPath = @"C:\\Temp\\Cookies";
		static void Main(string[] args)
        {
			
			//Unlock(sourcePath);

			

			ListProcesses();

            try
            {
                CopyFile(fullPath, destinationPath);
                Console.WriteLine("Successful");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"error：{ex.Message}");
            }


        }

		static void ListProcesses()
		{
			Process[] processCollection = Process.GetProcesses();
			foreach (Process p in processCollection)
			{

				if (p.ProcessName == "chrome")
				{
					Console.WriteLine($"ProcessName={p.ProcessName}   ProcessID={p.Id}");

					var hCurrentProcess = Process.GetCurrentProcess().Handle;

					uint targetProcessId = (uint)p.Id;

					
					var hProcess = OpenProcess(OpenProcessDesiredAccess.ProcessDupHandle, false, targetProcessId);
					if (hProcess == IntPtr.Zero)
					{
						throw new UnauthorizedAccessException();  
					}
					var handles = SearchFileHandles(targetProcessId, hProcess, fullPath);  
					foreach (var handle in handles)
					{
						
						DuplicateHandle(hProcess, handle, hCurrentProcess, out var duplicatedHandle, 0, false, 1);
						
						CloseHandle(duplicatedHandle);
					}
					

				}


			}
		}


		static void CopyFile(string sourcePath, string destinationPath)
		{
			
			if (!File.Exists(sourcePath))
			{
				throw new FileNotFoundException("FileNotFound", sourcePath);
			}

			try
			{
				
				File.Copy(sourcePath, destinationPath, true);
			}
			catch (Exception ex)
			{
				
				throw new Exception($"{ex.Message}");
			}
		}


		public static List&lt;IntPtr&gt; SearchFileHandles(uint targetPid, IntPtr hProcess, string fullPath, uint bufSize = 0x8000, uint maxRetry = 8)
		{

			var diskDosName = Marshal.AllocHGlobal(120);
			//if (QueryDosDevice(fullPath[..2], diskDosName, 120) == 0)
			if (QueryDosDevice(fullPath.Substring(0, 2), diskDosName, 120) == 0)
			{
				Marshal.FreeHGlobal(diskDosName);
				throw new Win32Exception();
			}
			var dosPath = Marshal.PtrToStringUni(diskDosName) + fullPath.Substring(0, 2);
			Marshal.FreeHGlobal(diskDosName);
			var currentHandle = Process.GetCurrentProcess().Handle;
			var pHandle = Marshal.AllocHGlobal((int)bufSize);
			var length = 0U;
			for (var i = 0; i &lt; maxRetry; i++)
			{
				if (ZwQuerySystemInformation(SystemInformationClass.SystemExtendedHandleInformation, pHandle, bufSize, ref length) == 0)
				{
					var result = new List&lt;IntPtr&gt;();

					var nInfos = Marshal.ReadInt64(pHandle);
					pHandle += 0x10;

					var objTypeInfo = Marshal.AllocHGlobal(128);
					var objNameInfo = Marshal.AllocHGlobal(1024);
					for (var j = 0; j &lt; nInfos; j++)
					{
						//var ptr = pHandle + Marshal.SizeOf&lt;SystemHandleTableEntryInfoEx&gt;() * j;
						SystemHandleTableEntryInfoEx dummyInstance = new SystemHandleTableEntryInfoEx(); 
						var ptr = pHandle + Marshal.SizeOf(dummyInstance) * j;
						var pid = (uint)Marshal.ReadInt32(ptr + sizeof(ulong));
						if (pid == targetPid)
						{
							var sourceHandle = Marshal.ReadIntPtr(ptr + 2 * sizeof(ulong));
							if (!DuplicateHandle(hProcess, sourceHandle, currentHandle, out var duplicatedHandle, 0, false, 2))
							{
								continue;
							}
							Task.Run(() =&gt; {
								if (ZwQueryObject(duplicatedHandle, ObjectInformationClass.ObjectTypeInformation, objTypeInfo, 128, IntPtr.Zero) != 0)
								{
									return;
								}
								
								unsafe
								{
									if (*(short*)objTypeInfo == 0)
									{
										return;
									}
									var typePtr = *(byte**)(objTypeInfo + 8);
									// File ASCII
									if (*typePtr != 70 || *(typePtr + 2) != 105 || *(typePtr + 4) != 108 || *(typePtr + 6) != 101)
									{
										return;
									}
								}
								if (ZwQueryObject(duplicatedHandle, ObjectInformationClass.ObjectNameInformation, objNameInfo, 1024, IntPtr.Zero) != 0)
								{
									return;
								}
								var strLength = Marshal.ReadInt16(objNameInfo);
								if (strLength == 0)
								{
									return;
								}
								var str = Marshal.PtrToStringUni(objNameInfo + 16, strLength / 2);

								if (str == dosPath)
								{
									result.Add(sourceHandle);
								}
								CloseHandle(duplicatedHandle);
							}).Wait(10);
						}
					}

					Marshal.FreeHGlobal(objTypeInfo);
					Marshal.FreeHGlobal(objNameInfo);

					Marshal.FreeHGlobal(pHandle - 0x10);
					return result;
				}
				bufSize = length + 1024;  
				pHandle = Marshal.ReAllocHGlobal(pHandle, new IntPtr(bufSize));
			}
			throw new Win32Exception();
		}




		public static uint[]? GetFileOccupiedPidList(params string[] fullPaths)
		{
			uint[]? pidList = null;

			var res = RmStartSession(out var handle, 0, Guid.NewGuid().ToString());

			if (res != 0)
			{
				throw new Exception("Could not begin restart session. Unable to determine file locker.");
			}

			try
			{
				uint pnProcInfo = 0, rebootReasons = 0;

				res = RmRegisterResources(handle, (uint)fullPaths.Length, fullPaths, 0, null, 0, null);

				if (res != 0)
				{
					throw new Exception("Could not register resource.");
				}

				//Note: there's a race condition here -- the first call to RmGetList() returns
				//      the total number of process. However, when we call RmGetList() again to get
				//      the actual processes this number may have increased.
				res = RmGetList(handle, out var pnProcInfoNeeded, ref pnProcInfo, null, ref rebootReasons);

				if (res == 234)
				{  // ErrorMoreData
				   // Create an array to store the process results
					var processInfo = new RmProcessInfo[pnProcInfoNeeded];
					pnProcInfo = pnProcInfoNeeded;

					// Get the list
					res = RmGetList(handle, out pnProcInfoNeeded, ref pnProcInfo, processInfo, ref rebootReasons);

					if (res == 0)
					{
						pidList = new uint[pnProcInfo];

						// Enumerate all of the results and add them to the 
						// list to be returned
						for (var i = 0; i &lt; pnProcInfo; i++)
						{
							pidList[i] = processInfo[i].Process.dwProcessId;
						}
					}
					else
					{
						throw new Exception("Could not list processes locking resource.");
					}
				}
				else if (res != 0)
				{
					throw new Exception("Could not list processes locking resource. Failed to get size of result.");
				}
			}
			finally
			{
				RmEndSession(handle);
			}

			return pidList;
		}

		public static void Unlock(string fullPath)
		{
			
			var pidList = GetFileOccupiedPidList(fullPath);
			if (pidList == null)
			{
				return;
			}
			var hCurrentProcess = Process.GetCurrentProcess().Handle;
			foreach (var pid in pidList)
			{
				
				var hProcess = OpenProcess(OpenProcessDesiredAccess.ProcessDupHandle, false, pid);
				if (hProcess == IntPtr.Zero)
				{
					throw new UnauthorizedAccessException();  
				}
				var handles = SearchFileHandles(pid, hProcess, fullPath);  
				foreach (var handle in handles)
				{
					
					DuplicateHandle(hProcess, handle, hCurrentProcess, out var duplicatedHandle, 0, false, 1);
					
					CloseHandle(duplicatedHandle);
				}
			}
		}
	}
}
</code></pre>
</blockquote>
</aside>
<p>win32</p>
<pre data-code-wrap="using"><code class="lang-plaintext">using System.Runtime.InteropServices;
using System.Runtime.InteropServices.ComTypes;

namespace ConsoleApp1
{
    public static class Win32
    {
        private const string Gdi32 = "gdi32.dll";
        private const string User32 = "user32.dll";
        private const string Kernel32 = "kernel32.dll";

        private const string Ntdll = "ntdll.dll";
        private const string Dwmapi = "dwmapi.dll";
        private const string Rstrtmgr = "rstrtmgr.dll";

        [DllImport(Rstrtmgr, CharSet = CharSet.Unicode)]
        public static extern int RmRegisterResources(uint pSessionHandle, uint nFiles, string[] rgsFilenames, uint nApplications, [In] RmUniqueProcess[]? rgApplications, uint nServices, string[]? rgsServiceNames);

        [DllImport(Rstrtmgr, CharSet = CharSet.Auto)]
        public static extern int RmStartSession(out uint pSessionHandle, int dwSessionFlags, string strSessionKey);

        [DllImport(Rstrtmgr)]
        public static extern int RmEndSession(uint pSessionHandle);

        [DllImport(Rstrtmgr)]
        public static extern int RmGetList(uint dwSessionHandle, out uint pnProcInfoNeeded, ref uint pnProcInfo, [In, Out] RmProcessInfo[]? rgAffectedApps, ref uint lpdwRebootReasons);

        [DllImport(Ntdll)]
        public static extern uint NtQueryInformationProcess(IntPtr ProcessHandle, uint ProcessInformationClass, IntPtr ProcessInformation, uint ProcessInformationLength, out uint ReturnLength);

        [DllImport(Kernel32)]
        public static extern IntPtr OpenProcess(OpenProcessDesiredAccess dwDesiredAccess, [MarshalAs(UnmanagedType.Bool)] bool bInheritHandle, uint dwProcessId);

        [DllImport(Kernel32)]
        public static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, IntPtr lpBuffer, uint nSize, out uint lpNumberOfBytesRead);

        [DllImport(Ntdll)]
        public static extern uint ZwQuerySystemInformation(SystemInformationClass SystemInformationClass, IntPtr SystemInformation, uint SystemInformationLength, ref uint ReturnLength);

        [DllImport(Ntdll)]
        public static extern uint ZwQueryObject(IntPtr Handle, ObjectInformationClass ObjectInformationClass, IntPtr ObjectInformation, uint ObjectInformationLength, IntPtr ReturnLength);

        [DllImport(Kernel32, SetLastError = true)]
        public static extern bool DuplicateHandle(IntPtr hSourceProcessHandle, IntPtr hSourceHandle, IntPtr hTargetProcessHandle, out IntPtr lpTargetHandle, uint dwDesiredAccess, bool bInheritHandle, uint dwOptions);

        [DllImport(Kernel32, CharSet = CharSet.Unicode)]
        public static extern uint QueryDosDevice(string deviceName, IntPtr targetPath, uint chMax);

        [DllImport(Kernel32)]
        [return: MarshalAs(UnmanagedType.Bool)]
        public static extern bool CloseHandle(IntPtr handle);

        [StructLayout(LayoutKind.Sequential)]
        public struct RmUniqueProcess
        {
            public uint dwProcessId;
            public FILETIME ProcessStartTime;
        }

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct RmProcessInfo
        {
            public RmUniqueProcess Process;

            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]
            public string strAppName;

            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 64)]
            public string strServiceShortName;

            public RmAppType ApplicationType;
            public uint AppStatus;
            public uint TSSessionId;
            [MarshalAs(UnmanagedType.Bool)]
            public bool bRestartable;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct SystemHandleTableEntryInfoEx
        {
            public ulong Object;
            public ulong UniqueProcessId;
            public ulong HandleValue;
            public uint GrantedAccess;
            public ushort CreatorBackTraceIndex;
            public ushort ObjectTypeIndex;
            public uint HandleAttributes;
            public uint Reserved;
        }

        public enum RmAppType
        {
            RmUnknownApp = 0,
            RmMainWindow = 1,
            RmOtherWindow = 2,
            RmService = 3,
            RmExplorer = 4,
            RmConsole = 5,
            RmCritical = 1000
        }

        [Flags]
        public enum OpenProcessDesiredAccess : uint
        {
            VmRead = 0x0010,
            ProcessDupHandle = 0x0040,
            QueryInformation = 0x0400,
            QueryLimitedInformation = 0x1000
        }

        public enum ObjectInformationClass
        {
            ObjectBasicInformation,
            ObjectNameInformation,
            ObjectTypeInformation
        }

        public enum SystemInformationClass
        {
            SystemExtendedHandleInformation = 64
        }
    }
}
</code></pre>
<p>Program</p>
<pre data-code-wrap="using"><code class="lang-plaintext">using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using System.Threading.Tasks;
using static ConsoleApp1.Win32;

namespace ConsoleApp1
{
    class Program
    {
        static string fullPath = @"C:\\Users\\admin\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Network\\Cookies";
        static string destinationPath = @"C:\\Temp\\Cookies";
        static void Main(string[] args)
        {

            //Unlock(sourcePath);

            ListProcesses();

            try
            {
                CopyFile(fullPath, destinationPath);
                Console.WriteLine("Successful");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"error: {ex.Message}");
            }
        }

        static void ListProcesses()
        {
            Process[] processCollection = Process.GetProcesses();
            foreach (Process p in processCollection)
            {
                if (p.ProcessName == "chrome")
                {
                    Console.WriteLine($"ProcessName={p.ProcessName}   ProcessID={p.Id}");

                    var hCurrentProcess = Process.GetCurrentProcess().Handle;

                    uint targetProcessId = (uint)p.Id;

                    var hProcess = OpenProcess(OpenProcessDesiredAccess.ProcessDupHandle, false, targetProcessId);
                    if (hProcess == IntPtr.Zero)
                    {
                        throw new UnauthorizedAccessException();
                    }
                    var handles = SearchFileHandles(targetProcessId, hProcess, fullPath);
                    foreach (var handle in handles)
                    {
                        DuplicateHandle(hProcess, handle, hCurrentProcess, out var duplicatedHandle, 0, false, 1);
                        CloseHandle(duplicatedHandle);
                    }
                }
            }
        }

        static void CopyFile(string sourcePath, string destinationPath)
        {
            if (!File.Exists(sourcePath))
            {
                throw new FileNotFoundException("FileNotFound", sourcePath);
            }

            try
            {
                File.Copy(sourcePath, destinationPath, true);
            }
            catch (Exception ex)
            {
                throw new Exception($"{ex.Message}");
            }
        }

        public static List&lt;IntPtr&gt; SearchFileHandles(uint targetPid, IntPtr hProcess, string fullPath, uint bufSize = 0x8000, uint maxRetry = 8)
        {
            var diskDosName = Marshal.AllocHGlobal(120);
            if (QueryDosDevice(fullPath.Substring(0, 2), diskDosName, 120) == 0)
            {
                Marshal.FreeHGlobal(diskDosName);
                throw new Win32Exception();
            }
            var dosPath = Marshal.PtrToStringUni(diskDosName) + fullPath.Substring(0, 2);
            Marshal.FreeHGlobal(diskDosName);
            var currentHandle = Process.GetCurrentProcess().Handle;
            var pHandle = Marshal.AllocHGlobal((int)bufSize);
            var length = 0U;
            for (var i = 0; i &lt; maxRetry; i++)
            {
                if (ZwQuerySystemInformation(SystemInformationClass.SystemExtendedHandleInformation, pHandle, bufSize, ref length) == 0)
                {
                    var result = new List&lt;IntPtr&gt;();

                    var nInfos = Marshal.ReadInt64(pHandle);
                    pHandle += 0x10;

                    var objTypeInfo = Marshal.AllocHGlobal(128);
                    var objNameInfo = Marshal.AllocHGlobal(1024);
                    for (var j = 0; j &lt; nInfos; j++)
                    {
                        SystemHandleTableEntryInfoEx dummyInstance = new SystemHandleTableEntryInfoEx();
                        var ptr = pHandle + Marshal.SizeOf(dummyInstance) * j;
                        var pid = (uint)Marshal.ReadInt32(ptr + sizeof(ulong));
                        if (pid == targetPid)
                        {
                            var sourceHandle = Marshal.ReadIntPtr(ptr + 2 * sizeof(ulong));
                            if (!DuplicateHandle(hProcess, sourceHandle, currentHandle, out var duplicatedHandle, 0, false, 2))
                            {
                                continue;
                            }
                            Task.Run(() =&gt; {
                                if (ZwQueryObject(duplicatedHandle, ObjectInformationClass.ObjectTypeInformation, objTypeInfo, 128, IntPtr.Zero) != 0)
                                {
                                    return;
                                }

                                unsafe
                                {
                                    if (*(short*)objTypeInfo == 0)
                                    {
                                        return;
                                    }
                                    var typePtr = *(byte**)(objTypeInfo + 8);
                                    // File ASCII
                                    if (*typePtr != 70 || *(typePtr + 2) != 105 || *(typePtr + 4) != 108 || *(typePtr + 6) != 101)
                                    {
                                        return;
                                    }
                                }
                                if (ZwQueryObject(duplicatedHandle, ObjectInformationClass.ObjectNameInformation, objNameInfo, 1024, IntPtr.Zero) != 0)
                                {
                                    return;
                                }
                                var strLength = Marshal.ReadInt16(objNameInfo);
                                if (strLength == 0)
                                {
                                    return;
                                }
                                var str = Marshal.PtrToStringUni(objNameInfo + 16, strLength / 2);

                                if (str == dosPath)
                                {
                                    result.Add(sourceHandle);
                                }
                                CloseHandle(duplicatedHandle);
                            }).Wait(10);
                        }
                    }

                    Marshal.FreeHGlobal(objTypeInfo);
                    Marshal.FreeHGlobal(objNameInfo);

                    Marshal.FreeHGlobal(pHandle - 0x10);
                    return result;
                }
                bufSize = length + 1024;
                pHandle = Marshal.ReAllocHGlobal(pHandle, new IntPtr(bufSize));
            }
            throw new Win32Exception();
        }

        public static uint[]? GetFileOccupiedPidList(params string[] fullPaths)
        {
            uint[]? pidList = null;

            var res = RmStartSession(out var handle, 0, Guid.NewGuid().ToString());

            if (res != 0)
            {
                throw new Exception("Could not begin restart session. Unable to determine file locker.");
            }

            try
            {
                uint pnProcInfo = 0, rebootReasons = 0;

                res = RmRegisterResources(handle, (uint)fullPaths.Length, fullPaths, 0, null, 0, null);

                if (res != 0)
                {
                    throw new Exception("Could not register resource.");
                }

                res = RmGetList(handle, out var pnProcInfoNeeded, ref pnProcInfo, null, ref rebootReasons);

                if (res == 234)
                {
                    var processInfo = new RmProcessInfo[pnProcInfoNeeded];
                    pnProcInfo = pnProcInfoNeeded;

                    res = RmGetList(handle, out pnProcInfoNeeded, ref pnProcInfo, processInfo, ref rebootReasons);

                    if (res == 0)
                    {
                        pidList = new uint[pnProcInfo];

                        for (var i = 0; i &lt; pnProcInfo; i++)
                        {
                            pidList[i] = processInfo[i].Process.dwProcessId;
                        }
                    }
                    else
                    {
                        throw new Exception("Could not list processes locking resource.");
                    }
                }
                else if (res != 0)
                {
                    throw new Exception("Could not list processes locking resource. Failed to get size of result.");
                }
            }
            finally
            {
                RmEndSession(handle);
            }

            return pidList;
        }

        public static void Unlock(string fullPath)
        {
            var pidList = GetFileOccupiedPidList(fullPath);
            if (pidList == null)
            {
                return;
            }
            var hCurrentProcess = Process.GetCurrentProcess().Handle;
            foreach (var pid in pidList)
            {
                var hProcess = OpenProcess(OpenProcessDesiredAccess.ProcessDupHandle, false, pid);
                if (hProcess == IntPtr.Zero)
                {
                    throw new UnauthorizedAccessException();
                }
                var handles = SearchFileHandles(pid, hProcess, fullPath);
                foreach (var handle in handles)
                {
                    DuplicateHandle(hProcess, handle, hCurrentProcess, out var duplicatedHandle, 0, false, 1);
                    CloseHandle(duplicatedHandle);
                }
            }
        }
    }
}
</code></pre>
<p>Use AI <img src="../../images/emoji/twitter/smiley.png%3Fv=12" title=":smiley:" class="emoji" alt=":smiley:" loading="lazy" width="20" height="20"></p>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/LikeAction" />
<meta itemprop="userInteractionCount" content="0" />
<span class="post-likes"></span>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/CommentAction" />
<meta itemprop="userInteractionCount" content="0" />
</div>
</div>
<div id="post_4" itemprop="comment" itemscope itemtype="http://schema.org/Comment" class="topic-body crawler-post">
<div class="crawler-post-meta">
<span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a itemprop="url" href="https://0x00sec.org/u/system"><span itemprop="name">system</span></a>
(system)
Closed
</span>
<link itemprop="mainEntityOfPage" href="38510.html">
<span class="crawler-post-infos">
<time itemprop="datePublished" datetime="2024-04-26T22:05:26Z" class="post-time">
April 26, 2024, 10:05pm
</time>
<meta itemprop="dateModified" content="2024-04-26T22:05:26Z">
<span itemprop="position">4</span>
</span>
</div>
<div class="post" itemprop="text">
<p>This topic was automatically closed after 121 days. New replies are no longer allowed.</p>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/LikeAction" />
<meta itemprop="userInteractionCount" content="0" />
<span class="post-likes"></span>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/CommentAction" />
<meta itemprop="userInteractionCount" content="0" />
</div>
</div>
</div>
</div>
<footer class="container wrap">
<nav class="crawler-nav">
<ul>
<li itemscope itemtype="http://schema.org/SiteNavigationElement">
<span itemprop="name">
<a href="../../index.html" itemprop="url">Home </a>
</span>
</li>
<li itemscope itemtype="http://schema.org/SiteNavigationElement">
<span itemprop="name">
<a href="../../categories.html" itemprop="url">Categories </a>
</span>
</li>
<li itemscope itemtype="http://schema.org/SiteNavigationElement">
<span itemprop="name">
<a href="https://0x00sec.org/guidelines" itemprop="url">FAQ/Guidelines </a>
</span>
</li>
<li itemscope itemtype="http://schema.org/SiteNavigationElement">
<span itemprop="name">
<a href="../../tos.html" itemprop="url">Terms of Service </a>
</span>
</li>
<li itemscope itemtype="http://schema.org/SiteNavigationElement">
<span itemprop="name">
<a href="../../privacy.html" itemprop="url">Privacy Policy </a>
</span>
</li>
</ul>
</nav>
<p class="powered-by-link">Powered by <a href="https://www.discourse.org">Discourse</a>, best viewed with JavaScript enabled</p>
</footer>
<script src="https://instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>
</body>
</html>
