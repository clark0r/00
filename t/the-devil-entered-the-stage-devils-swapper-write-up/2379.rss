<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>The devil entered the stage - Devil&#39;s swapper write-up</title>
    <link>https://0x00sec.org/t/the-devil-entered-the-stage-devils-swapper-write-up/2379</link>
    <description>This is a write-up for solving the [devils-swapper RE challenge](https://0x00sec.org/t/challenge-devils-swapper/2225).‌‌ It was mostly intended for my personal archive but since it may be interesting to all of you. This especially applies if you&#39;re still rather new to the whole RE world as the write-up turned out to be quite verbose. I hope it is still formatted in a clear and concise way to be able to follow along my thought process easily. If there are any open questions left feel free to ask :)!

### The binary

Copied from the challenge linked above and pasted below for people who want to follow what I did:

#### Building:

```
cat textfile | base64 -d | gunzip &gt; challenge &amp;&amp; chmod +x challenge
```

#### Challenge:

```
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
```

## First examination

First let&#39;s run the file to see what it&#39;s throwing at us:

![](upload://weHQkqRrn2jyForFSESVXmclG68.png)

Well what did I expect :)? Running the file will only reveal that it is somehow not working as intended... So let&#39;s check what&#39;s wrong with the binary and what it may expect as input. `file` has to say the following about the binary:

![](upload://kvZdd1FotjsgoUd7JWS7AzaExiW.png)

So we got a stripped 64-bit ELF binary at our disposal. The challenge dictates us that we have to find a *secret key* and the *secret message* . We do not know anything about what is meant exactly and how key and message are connected with that hint at this point. Let&#39;s continue with checking for strings within the binary:

![](upload://5oZyk5Lf50Th3t7hyIQIqVEgzFE.png)

There is one particular string in there which could hide some valuable information or hints! I&#39;m talking about this one: *Purpx qq pbai bcgvbaf* !

No question some kind of cipher.. Since @0x00pf said it would be a &quot;simple&quot; challenge I assumed some form of [caesars ciphers](https://learncryptography.com/classical-encryption/caesar-cipher). After trying for a while I found out it was indeed a caesars code with a key length of *k=13* . Exactly this kind of cipher is known under a different name as well: [ROT13](https://en.wikipedia.org/wiki/ROT13):

![](upload://uj4qkItzkOnBcf8vaaxqnukkX2c.png)

So here is the portion of interest of the [dd man page](http://man7.org/linux/man-pages/man1/dd.1.html). Let&#39;s look at the possible *conv* flags:

![](upload://jc7O14yGT5iQTV0vhkbDmsXJiAA.png)

Now one could try to associate the name of the challenge with one of the flags. But just swapping every pair of input bytes with `dd if=binary of=binary2 conv=swab` would not make much sense, would it?

![](upload://sew2DfS0EY0qBvmqbexdQVkCghK.png)

Does not seem to be as easy as that. But if it were where would be the fun in that challenge! To recap: We have a valid (read it as &quot;running&quot;) ELF64 binary right of the bat. However, applying the first hint we got does not yield any meaningful results yet.

## Closer look at the binary

To see what roadblock lies in front of us I&#39;ll be using IDA to statically analyze the binary.

![](upload://rnUSm7k5o4dNDI3w1RlkaoSe5Z3.png)

The `main` function is easily located as its quite short and shows the 2 known string constants we&#39;ve been seeing when executing the binary. `sub_4001D0` is an interesting little fellow as its setting the `al` portion in `rax` to 1 followed by jump in the middle of another function:

![](upload://At7pPAwpV9EwdoqanoapV5Pr6ZT.png)

We&#39;ll take a closer at that part later. First I want to know why the `cmp` followed by a `jnz` at `main+17` is defaulting to the bad route in the original challenge. The comparison takes whatever is in the data segment (c *s:XXX* ) and silently subtracts it from the hard coded value of `0x2ba5441` , meaning the result is not stored in one of the base registers, but the zero flag is set when both values are equal. Hence, the *jump if not zero* ( `jnz` ) is only not taken in the case we fix the comparison to be equal! So let&#39;s check what is being stored in that identified segment.

![](upload://qst7qpaKcxIXBSe7bTK7fWkHYDp.png)

The data starting at address `0x40051d` looks garbled and does not make much sense. However, that first dword of `0x0ba024154` looks oddly familiar, doesn&#39;t it? It&#39;s like a badly shuffled version of that hard coded value from that comparison in `main+17` ! At a second glance if you swap positions of the upper two bytes and the lower two bytes you get exactly that value from the comparison! This is the time to recall the hint about looking at the *conv* flags of the UNIX `dd` utility! So let&#39;s calculate the bounds on where to partially apply that *swab* option:

![](upload://e7i7BrCZ9aSQekX151Sz8WviFSF.png)

Alternatively we could have also extracted the size and offset from our trusty pal readelf!

![](upload://jTo4EECPiVsGQOarcJxNqiXycbY.png)

When looking at the readelf output above we see yet another weird occurrence! The .data section should hold data like variables or global tables. It should certainly **not** be marked as executable! So either the flags are wrong or it actually holds binary data! Let&#39;s load the executable back into IDA and see how the disassembly changed now that we have applied the dd treatment :).

![](upload://tTCN0xXZr27ThtixzuWAEOeBJE0.png)

We&#39;ve got a lot of new code that needs reversing! On top of that the at first shuffled address was also corrected and matches the hard coded address value from the *main* function! We should be able to pass that comparison now and not run into the bad ending again.

### Running the new binary

To verify our assumption from above let&#39;s execute our &quot;new&quot; binary:

![](upload://8ipudqBM1fYazNu96VtLGkfrEpJ.png)

Wonderful we are getting greeted by the usual but this time we get a little extra too! A brand new shell prompt that&#39;s awaiting some user input!

## Finding the flag

![](upload://zL5oWrqFPeX6JBj7c0myQJJpE1a.png)

#### Observation

* **Only the first character** of the input seems to be accepted. There seems to be a different output of different lengths for each character. Also, the output behavior is **deterministic** , meaning the same input always yields the same output. Assumption: The different lengths of the observed outputs could be due to unprintable values that are being calculated.
* After getting a (broken?) return value our binary terminates and our normal terminal emulator tries to execute the rest of the input as a system utility as the binary exits before handling the remaining input.

### First attempt to get the secret message

So to find the flag one could brute force their way through now.‌‌ Only one character input gets seemingly validated or at least looked at.‌‌ The amount of printable user input characters is very limited to roughly 100 possibilities (s. [ASCII table](https://www.asciitable.com/)). ‌‌ We can easily brute force our way in if our assumptions still hold true... However, there is still one catch: We do **not** know what the behavior of the binary for the correct flag looks like yet so lets dig deeper into that next!

### Dumb brute force solution (up to here)

```python
#!/usr/bin/env python3

from pwn import *
import string
import sys

exe = &quot;./challenge&quot;

def main():
    for char in string.printable:
        p = process(exe)
        p.recvuntil(b&quot;$&quot;)
        p.sendline(char)
        # This is the line we have no knowledge about
        if ??? not in p.recvall():
            continue
        else:
            print(f&quot;Correct input is: {char}&quot;)
            sys.exit()

if __name__ == &#39;__main__&#39;:
    main()
```

This could be one way to brute force the solution if we would know what the expected behavior (in this case the correct deciphered message) looks like. We obviously could just try every possibility and print out the potentially deciphered message into the terminal each time and look for what input is the correct one based on the produced output. This may be a legitimate solution if you just wanted to bypass this deciphering to get deeper into the binary. However, this part where we&#39;re currently stuck at is the whole exercise for this RE challenge. So let&#39;s continue doing that!

### Part 1 of newly discovered code - Init phase

![](upload://bBbDhp0RJtDbdR4A6y3XamnTHrb.png)

The first block is where we left of the last time. `0x2ba5441` is the destination we wanted to jump to from the `main` function. To fully understand what&#39;s going on next we first need to understand that the disassembly shown here by IDA is not completely correct. That seemingly &quot;magic value&quot; we jump to is not just an address but actual code that is being executed and translates to: `push r12; mov edx, 0x2` .

In the second part marked as blue, we first have to understand what `sub_4001d0` does before talking about the setup steps prior to the function call. We mentioned this particular function right at the beginning when talking about the `main` function too:

![](upload://ji2bGFnOXK9wHv4gvg9Ew6xQ3q5.png)

This fella is really just prepping the `al` portion of the `rax` register before doing a direct jump into another code section:
![](upload://7kZVG2JgjKI8rWCYx4fq0vrGlot.png)

We can directly see that the jump happens in the middle of a function. We can also see that the `rax` register undergoes some more prepping before a **syscall** is issued. IDA falsely mislabels this as a `sys_read` syscall, which holds true when only looking at this function as an isolated code snippet. IDAs assumption is based on the fact that on an ELF-64 bit binary the ABI dictates that `rax` holds the syscall number, which corresponds to the functionality that is being executed. In this function `rax` looks like this:

```
0. rax - 0x????????????????
1. rax - 0x??????????????3c
2. rax - 0x????????????003c
3. rax - 0x????????0000003c
```

This yields 2 problems:

1. There is no guarantee about what the upper 32-bit of `rax` hold.
2. The syscall number `0x3c` does **not** correspond to `sys_read` !


![](upload://8x5KeuUw9PHaqHxTE7k0lP0v2Ru.png)

This brings up 2 new questions:

1. The heck is `sys_quotactl` ? If you&#39;re interested check the [manpage, but](https://manned.org/sys_quotactl/ba7dc951) it doesn&#39;t quite matter for the challenge!
2. Why is IDA labeling as `sys_read` ? Honestly, I&#39;m not sure. It might have been the result of one of IDAs binary analysis passes.

Both questions can be easily ignored, because when we back paddle a bit to the second code snippet marked with the blue box earlier, we can see there is a `xor eax, eax` that zeroes out the register. And that register is not modified before taking the direct jump to the helper function that sets it again to 1. Now we could question why we do not have a `xor rax, rax` instead, as only this instruction would zero out the upper 32-bit too. This must be due to the fact that the compiler knows at compile-time that these bits were never set and hence are already 0. Using a `xor eax, eax` in this case saves us 1 byte:

```
xor eax, eax --- &quot;\x31\xc0&quot;
xor rax, rax --- &quot;\x48\x31\xc0&quot;
```

So that mystery is solved and caused by compiler optimizations. Now remember why we tried to figure that out in the first place! It leaves us with the following:

```
0. rax - 0x00000000??????01
1. rax - 0x00000000????0001
3. rax - 0x0000000000000001
```

Meaning that `rax` holds 1, which in turn results in the syscall `sys_write` ! This clears up most of the confusion for the first snippet:

![](upload://6a5jMH0cdzkwm8YLXbGkLBqFb3f.png)![](upload://pa3Htwa6XmC2TPeUOiqe30xAP4F.png)

The remaining parameters of interest are the buffer with the contents to write in `rsi` (&quot;$ &quot;), the buffer length in `rdx` (0x2) and the file descriptor to write to in `rdi` (0x1 == stdout). So all this snippet does is presenting the user with a shell prompt character on stdout. Besides that this snippet also contains saving register values on the stack (2 x `push` ) and preparing the stack for what is about to come next `sub rsp, 0x410` ).

Now that we have talked about the second snippet (blue box) the third one (green box) will be dealt with fast, as its pretty much the same functionality with one different function call.

![](upload://gvcD0gAv0auxn0trC6o2wYaREWP.png)![](upload://jDqyfb0MfKn8tV8ViFxvVyDvhPG.png)

When following along until here you should recognize what is going on. In `sub_4001c9` we&#39;re setting the `al` portion in `rax` to 0 instead of setting it to 1 as before. The direct jump that follows is to the exact same location as before, meaning another syscall is being executed here! Syscall number 0x0 corresponds to `sys_read` . So when putting it all together we can annotate the disassembly in IDA as follows:

![](upload://1bqmYbKLgzzg5uoyGZ0aSAvMEmI.png)
We&#39;ve seen this exact behavior we just annotated in the disassembly when running the binary after using the `dd` trick on it! The next part (pink) finishes the setup phase that is being done :

![](upload://hdzbIF2TBFD84A1GFJJW5PzFmtL.png)

This one effectively does 3 things in total:

1. `rsp+0x0f` holds the 1 byte buffer for the user input. Whatever character the user entered 0x20 is subtracted from its ASCII value ( e.g. &quot;A&quot; == 0x41 - 0x20 = 0x21 == &quot;!&quot;).
2. The next part up to (and including the `rep stosd` ) is equal to a `void *memset(void *b, int c, size_t len)` operation with len ( `rcx` ), c ( `rax` ), and *b ( `rdi` ). This initializes a 256 byte buffer to 0. Alternatively this pattern of `rep stosX` can also be encountered on `void *memcpy(void *dest, const void *src, size_t n);` operations.
3. Finally, 3 4-byte values are put one after another into that zero-initialized buffer, which if you look closely is right in front of the single user byte input buffer! On top of that when looking at those values we can uncover that most of those hex values are either in ASCII range (0x20 - 0x7e) or are located very close to that. This gives us access to the assumption that this is the secret message we&#39;re looking for. Decoding this as is doesn&#39;t yield anything useful though:

![](upload://hMtouwc0qVIQCn2Mzm3Sxz5JnTw.png)![](upload://xyNaROAAe3IccNGv4F7zzOAtaKf.png)

This is the end of the data preperation in this part of the binary. We encountered the exact code we have been seeing when executing the binary in our very brief *dynamic analysis* part earlier! These are namely the &quot;shell prompt&quot; and the possibility for a 1 byte user input. Next we&#39;ll take a look at the actual deciphering scheme to find the secret message!

### Part 2 of newly discovered code - Deciphering

Similar to Part 1 this stage consists of 3 large blocks that we&#39;ll discuss here. Below you can find the bare unannotated IDA dissassembly:

![](upload://vp6T5QoaQj6b86FUOSUXO1evxWf.png)

When first reaching the code at adress `0x40057f` `rbx` still points to `rsp+0x10` , which corresponds to the beginning of the 12 byte cipher. Hence, as we&#39;re on 64-Bit the contents of `rbx` at this very point in time: `[rbx] == 0x7a7c5631787f7746` . This results in the `jz` failing at first, but in combination with the fact that `0x40057f` is also the jump target from `0x4005b5` we have a clear loop exit condition showcasing that eventually we should reach a NULL pointer condition to not enter the loop body again. Right after we access the ciper at index 4 and copy the value into `rbp` (during the first iteration this means `rbp` points to `0x1e3233747a7c5631` ), which corresponds to the latter 2 4-byte values in the very first iteration. Finally, another pointer to the cipher ( `rbx` ) is copied into `rsi` . To summarize that chaos: We have a loop exit condition and if that one doesn&#39;t hold true we update two pointers with different indices into the cipher message.

![](upload://zqIvXxxWG6G2N9m7u9P3c2Q7keI.png)![](upload://bnUIPtzavDtaJku8W2zRUmiOoYt.png)

Above we can see a recap of the cipher message being stored in memory and the actual memory layout in GDB when debugging after the three `mov` instructions have been executed.

In the next block (green box) the &quot;magic&quot; of the binary happens. A strong very first indicator for that is the already labeled `sysWrite_Init` function call we already encountered and understood before. Meaning we&#39;re definitely gonna print to *stdout* here! We seen in our dynamic analysis that the only thing written back to stdout is the seemingly scrambled message! So let&#39;s try to figure out what kind of algorithm that is munching on the bits and bytes there :)! A quick first disassembly annotation of the code snippet may look like this:

![](upload://okEw8v4QFkZCy8UOGWT32ZKhBpk.png)

But that still looks rather gnarly and confusing doesn&#39;t it? There are a few key takeawys in the block besides the obvious write to *stdout* . The decryption routine makes use of addition, subtraction and XOR. The inner loop handles the actual decrypting and printing while the outer loop only occurs every 4 iterations (when `r12` == `rbp` ) to advance the pointer stored in `rbp` .

### Reimplementing the decryption routine

Let&#39;s try re-implementing that above shown behavior! I used Python for a quick and dirty prototype. As the challenge is a statically linked binary and makes use of constant pointer values in its decryption we need to consider this as well and implement a little memory map.

```python
#!/usr/bin/env python3

import sys
from ctypes import *

# MMAP
mapping = {
    0: (0x00007FFFFFFFDAA0, 0x46),
    1: (0x00007FFFFFFFDAA1, 0x77),
    2: (0x00007FFFFFFFDAA2, 0x7F),
    3: (0x00007FFFFFFFDAA3, 0x78),
    4: (0x00007FFFFFFFDAA4, 0x31),
    5: (0x00007FFFFFFFDAA5, 0x56),
    6: (0x00007FFFFFFFDAA6, 0x7C),
    7: (0x00007FFFFFFFDAA7, 0x7A),
    8: (0x00007FFFFFFFDAA8, 0x74),
    9: (0x00007FFFFFFFDAA9, 0x33),
    10: (0x00007FFFFFFFDAAA, 0x32),
    11: (0x00007FFFFFFFDAAB, 0x1E),
    12: (0x00007FFFFFFFDAAC, 0x00),
    13: (0x00007FFFFFFFDAAD, 0x00),
    14: (0x00007FFFFFFFDAAE, 0x00),
    15: (0x00007FFFFFFFDAAF, 0x00),
    16: (0x00007FFFFFFFDAB0, 0x00),
    16: (0x00007FFFFFFFDAB1, 0x00),
    17: (0x00007FFFFFFFDAB2, 0x00),
    18: (0x00007FFFFFFFDAB3, 0x00),
    19: (0x00007FFFFFFFDAB4, 0x00),
    20: (0x00007FFFFFFFDAB5, 0x00),
}


def shifter(idx: int) -&gt; int:
    tmp = 0
    for i in range(idx, 8 + idx):
        tmp |= mapping[i][1] &lt;&lt; i * 8
    return tmp &gt;&gt; idx * 8


def decrypt(usr_in: str):
    mod_usr = ord(usr_in) - 0x20
    print(f&quot;Modified user input: {hex(mod_usr)}&quot;)

    j = 0
    res = &quot;&quot;
    for i, v in mapping.items():
        al = v[0] &amp; 0xFF
        if j % 4 == 0:
            idx = int(j / 4) * 4
            ebx = mapping.get(idx)[0]
        al_ebx = c_int32(al).value - c_int32(ebx).value
        al_ebx_w_usr = al_ebx + mod_usr
        val = shifter(i)
        xor = c_int64(val).value ^ (al_ebx_w_usr &amp; 0xFF)
        # print(f&quot;al_ebx: {hex(al_ebx)}, al_ebx_w_usr: {hex(al_ebx_w_usr)}, val: {hex(val)}, xor: {hex(xor)}&quot;)
        res += chr(xor &amp; 0xFF)
        j += 1
        if j == 12:
            print(f&quot;[+] Decrypted: {res}&quot;)
            sys.exit(0)


def main():
    if len(sys.argv) != 2:
        print(f&quot;Usage: {sys.argv[0]} &lt;usr_byte&gt;!&quot;)
        exit()
    decrypt(sys.argv[1])


if __name__ == &quot;__main__&quot;:
    main()
```

Now running this script proves it&#39;s working as intended. The input-output-pairs below are identical with the values we were getting in the original binary (as seen in the beginning!):

![](upload://oGgfQN3R9VN0WCMisSWMb3bBOLx.png)

If the annotated disassembly or the python code are still confusing for you take a look at this debug output below that visualizes the algorithm quite nicely! The value in a *l_ebx* actually always hovers around `0x2600` to `0x2603` . This value is independent of any user interaction and stays &quot;constant&quot; across all invocations! The second value marked with green changes across invocation but that&#39;s only due to the modified user input ( `usr_in` - `0x20` ) being added to *al_ebx.* As our input changed across the 3 runs that value changed accordingly too. However, it follows the same pattern. The value repeats itself every 4 iterations! Second to last the large, but shrinking hex value is the access into the hard coded cipher. If you look closely, we can observe the 1-byte right shift to access the next cipher portion in the iterations. Last but not least, the least significant byte in the *xor* result is the byte that is getting printed to stdout.

![](upload://y58yGF6pXqagbZs9wnrbffsGiUf.png)

At this point, one dumb bruteforce method that we could apply now is iterating over the whole possible input space and save those inputs where the output only contains lower- and upper-case ASCII characters, numerals, a space and maybe possible puncutations. This would weed out some garbage inputs as we&#39;re expecting a &quot;secret message&quot;. We could refine this approach even further with the aim that the output closely represent the structure of a sentence/message. We can achieve that by specifiying that our decrypted results has to start with letters, continue with whatever in the middle and have to end with some punctuation characters. On top of all of that we could also check if the *n-th* , *n-th+4* , and the **n-th+8** entry in the decrypted cipher are always in that &quot;valid&quot; ASCII range we defined earlier. We can do this as one component that is being used within the *xor* repeats itself every 4 iterations (see in the screenshot above, e.g. iteration 0, 4, and 9!). Putting it all together leaves us with this.

### Dumb brute force solution (completed)

```python
#!/usr/bin/env python3

import string
import sys
from ctypes import *
from typing import List

ALPHABET = [x for x in (string.ascii_letters + string.digits + &quot;!?_ &quot;)]

# MMAP
mapping = {
    0: (0x00007FFFFFFFDAA0, 0x46),
    1: (0x00007FFFFFFFDAA1, 0x77),
    2: (0x00007FFFFFFFDAA2, 0x7F),
    3: (0x00007FFFFFFFDAA3, 0x78),
    4: (0x00007FFFFFFFDAA4, 0x31),
    5: (0x00007FFFFFFFDAA5, 0x56),
    6: (0x00007FFFFFFFDAA6, 0x7C),
    7: (0x00007FFFFFFFDAA7, 0x7A),
    8: (0x00007FFFFFFFDAA8, 0x74),
    9: (0x00007FFFFFFFDAA9, 0x33),
    10: (0x00007FFFFFFFDAAA, 0x32),
    11: (0x00007FFFFFFFDAAB, 0x1E),
    12: (0x00007FFFFFFFDAAC, 0x00),
    13: (0x00007FFFFFFFDAAD, 0x00),
    14: (0x00007FFFFFFFDAAE, 0x00),
    15: (0x00007FFFFFFFDAAF, 0x00),
    16: (0x00007FFFFFFFDAB0, 0x00),
    16: (0x00007FFFFFFFDAB1, 0x00),
    17: (0x00007FFFFFFFDAB2, 0x00),
    18: (0x00007FFFFFFFDAB3, 0x00),
    19: (0x00007FFFFFFFDAB4, 0x0),
    20: (0x00007FFFFFFFDAB5, 0x00),
}


def shifter(idx: int) -&gt; int:
    tmp = 0
    for i in range(idx, 8 + idx):
        tmp |= mapping[i][1] &lt;&lt; i * 8
    return tmp &gt;&gt; idx * 8


def calc(idx: int, al_ebx_w_usr: int, res: List[chr], j: int) -&gt; (List[chr], int):
    val = shifter(idx)
    xor = chr((c_int64(val).value ^ (al_ebx_w_usr &amp; 0xFF)) &amp; 0xFF)
    res.append((idx, xor))
    if xor in ALPHABET:
        j += 1
    return res, j


def decrypt():
    j = 0
    pos_sol = []
    for k in ALPHABET:
        # print(f&quot;Trying {k} as input&quot;)
        for i in range(4):
            al = mapping.get(i)[0] &amp; 0xFF
            ebx = mapping.get(0)[0]
            al_ebx = c_int32(al).value - c_int32(ebx).value
            al_ebx_w_usr = al_ebx + ord(k) - 0x20
            for l in [0, 4, 8]:
                pos_sol, j = calc(i + l, al_ebx_w_usr, pos_sol, j)
        if j == 11:
            dec = &quot;&quot;.join(x[1] for x in sorted(pos_sol, key=lambda k: k[0]))
            print(f&quot;Possible solution candidate: {k}\n  --&gt; Yields decrypted cipher: {dec}&quot;)
            sys.exit()
        j = 0
        pos_sol.clear()


def main():
    decrypt()


if __name__ == &quot;__main__&quot;:
    main()

```

This script will stop running at the first occurence where all above made assumptions are met. If our scope for a valid decryption was perfectly executed our script should always return the same correct solution.

![](upload://lXnWg98ULDIjE6VL0YPl6bdHR3r.png)

Nice! We seem to have solved this challenge now as the decrypted cipher text looks pretty darn good. Last but not least let&#39;s confirm this solution in the original challege:

![](upload://p1lqR3a4XTRVf7VdpsCEr5mQaln.png)

# Conclusion

This small challenge was really fun diving into.‌‌ For people wanting to try out all of this I have a few closing words.‌‌ Just do it! I learned a tad more about the ELF executable format, dd and static analysis in general :).‌‌ Knowledge that I can use and apply for my next binary I want to investigate or reverse engineer!‌‌ So just bring some time and don&#39;t give up easily :).‌‌ Doing this is like puzzling for grown-ups with a much higher frustration but also rewarding factor!

If you have read until here thank you very much and I really hope you enjoyed that little write-up in addition to maybe having learned a thing or two!</description>
    
    <lastBuildDate>Mon, 08 Feb 2021 14:07:19 +0000</lastBuildDate>
    <category>Challenges</category>
    <atom:link href="https://0x00sec.org/t/the-devil-entered-the-stage-devils-swapper-write-up/2379.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>The devil entered the stage - Devil&#39;s swapper write-up</title>
        <dc:creator><![CDATA[3vn2odzn]]></dc:creator>
        <description><![CDATA[
            <p>Thank you!  I wish you continued success. An excellent post.</p>
          <p><a href="https://0x00sec.org/t/the-devil-entered-the-stage-devils-swapper-write-up/2379/12">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/the-devil-entered-the-stage-devils-swapper-write-up/2379/12</link>
        <pubDate>Mon, 08 Feb 2021 14:07:19 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-2379-12</guid>
        <source url="https://0x00sec.org/t/the-devil-entered-the-stage-devils-swapper-write-up/2379.rss">The devil entered the stage - Devil&#39;s swapper write-up</source>
      </item>
      <item>
        <title>The devil entered the stage - Devil&#39;s swapper write-up</title>
        <dc:creator><![CDATA[ricksanchez]]></dc:creator>
        <description><![CDATA[
            <p><strong>Important note:</strong> This write-up got a complete overhaul on 03.02.2021 as the old write-up was lost during a data outage. The new write-up is far more detailed and extensive and should clear up this challenge completely. For anyone stumbling in here I hope the new write-up was to your liking. I’d appreciate any feedback <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
          <p><a href="https://0x00sec.org/t/the-devil-entered-the-stage-devils-swapper-write-up/2379/10">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/the-devil-entered-the-stage-devils-swapper-write-up/2379/10</link>
        <pubDate>Wed, 03 Feb 2021 09:23:41 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-2379-10</guid>
        <source url="https://0x00sec.org/t/the-devil-entered-the-stage-devils-swapper-write-up/2379.rss">The devil entered the stage - Devil&#39;s swapper write-up</source>
      </item>
      <item>
        <title>The devil entered the stage - Devil&#39;s swapper write-up</title>
        <dc:creator><![CDATA[ricksanchez]]></dc:creator>
        <description><![CDATA[
            <p><a class="mention" href="https://0x00sec.org/u/neolex">@neolex</a> yeah when reading a write-up it always looks like a piece of cake. I know that feeling <img src="https://0x00sec.org/images/emoji/twitter/smiley.png?v=9" title=":smiley:" class="emoji" alt=":smiley:"> .<br>
And you’re welcome <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
          <p><a href="https://0x00sec.org/t/the-devil-entered-the-stage-devils-swapper-write-up/2379/8">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/the-devil-entered-the-stage-devils-swapper-write-up/2379/8</link>
        <pubDate>Wed, 14 Jun 2017 16:45:19 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-2379-8</guid>
        <source url="https://0x00sec.org/t/the-devil-entered-the-stage-devils-swapper-write-up/2379.rss">The devil entered the stage - Devil&#39;s swapper write-up</source>
      </item>
      <item>
        <title>The devil entered the stage - Devil&#39;s swapper write-up</title>
        <dc:creator><![CDATA[neolex]]></dc:creator>
        <description><![CDATA[
            <p>Oh I was pretty close … It looks ovbious when you read the write up ahah<br>
Thanks <a class="mention" href="https://0x00sec.org/u/ricksanchez">@ricksanchez</a>  for yourwrite up ! And thanks <a class="mention" href="https://0x00sec.org/u/0x00pf">@0x00pf</a> for the challenge ! <img src="https://0x00sec.org/images/emoji/twitter/smiley.png?v=9" title=":smiley:" class="emoji" alt=":smiley:"></p>
          <p><a href="https://0x00sec.org/t/the-devil-entered-the-stage-devils-swapper-write-up/2379/7">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/the-devil-entered-the-stage-devils-swapper-write-up/2379/7</link>
        <pubDate>Wed, 14 Jun 2017 16:35:03 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-2379-7</guid>
        <source url="https://0x00sec.org/t/the-devil-entered-the-stage-devils-swapper-write-up/2379.rss">The devil entered the stage - Devil&#39;s swapper write-up</source>
      </item>
      <item>
        <title>The devil entered the stage - Devil&#39;s swapper write-up</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p><a class="mention" href="https://0x00sec.org/u/ricksanchez">@ricksanchez</a> very nice write-up!</p>
<p>And congrats for the solution. I would expect people to reverse the final password (it was a reverse engineering challenge after all) but brute forcing it is also fine.</p>
<aside class="quote group-VIP" data-username="ricksanchez" data-post="1" data-topic="2379">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://0x00sec.org/user_avatar/0x00sec.org/ricksanchez/40/4625_2.png" class="avatar"> ricksanchez:</div>
<blockquote>
<p>Keep them coming. I will be here. I will be ready. I will try to solve them all…</p>
</blockquote>
</aside>
<p><img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"> I will have to go hard core for the next one !!</p>
          <p><a href="https://0x00sec.org/t/the-devil-entered-the-stage-devils-swapper-write-up/2379/5">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/the-devil-entered-the-stage-devils-swapper-write-up/2379/5</link>
        <pubDate>Wed, 14 Jun 2017 16:08:56 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-2379-5</guid>
        <source url="https://0x00sec.org/t/the-devil-entered-the-stage-devils-swapper-write-up/2379.rss">The devil entered the stage - Devil&#39;s swapper write-up</source>
      </item>
      <item>
        <title>The devil entered the stage - Devil&#39;s swapper write-up</title>
        <dc:creator><![CDATA[twyK]]></dc:creator>
        <description><![CDATA[
            <p>The second part was quite difficult for me so I gave up, but I’m happy that you completed this!</p>
<p>Good Job ^-^</p>
          <p><a href="https://0x00sec.org/t/the-devil-entered-the-stage-devils-swapper-write-up/2379/4">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/the-devil-entered-the-stage-devils-swapper-write-up/2379/4</link>
        <pubDate>Wed, 14 Jun 2017 15:48:19 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-2379-4</guid>
        <source url="https://0x00sec.org/t/the-devil-entered-the-stage-devils-swapper-write-up/2379.rss">The devil entered the stage - Devil&#39;s swapper write-up</source>
      </item>
      <item>
        <title>The devil entered the stage - Devil&#39;s swapper write-up</title>
        <dc:creator><![CDATA[ricksanchez]]></dc:creator>
        <description><![CDATA[
            <p>Thank you <a class="mention" href="https://0x00sec.org/u/dagonchu">@DAGONCHU</a> .<br>
If it helped you you I’m happy <img src="https://0x00sec.org/images/emoji/twitter/smile.png?v=9" title=":smile:" class="emoji" alt=":smile:"></p>
          <p><a href="https://0x00sec.org/t/the-devil-entered-the-stage-devils-swapper-write-up/2379/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/the-devil-entered-the-stage-devils-swapper-write-up/2379/3</link>
        <pubDate>Wed, 14 Jun 2017 12:50:16 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-2379-3</guid>
        <source url="https://0x00sec.org/t/the-devil-entered-the-stage-devils-swapper-write-up/2379.rss">The devil entered the stage - Devil&#39;s swapper write-up</source>
      </item>
      <item>
        <title>The devil entered the stage - Devil&#39;s swapper write-up</title>
        <dc:creator><![CDATA[DAGONCHU]]></dc:creator>
        <description><![CDATA[
            <p><em>Nice write-up!</em><br>
<img src="https://0x00sec.org/images/emoji/twitter/+1.png?v=9" title=":+1:" class="emoji only-emoji" alt=":+1:"></p>
          <p><a href="https://0x00sec.org/t/the-devil-entered-the-stage-devils-swapper-write-up/2379/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/the-devil-entered-the-stage-devils-swapper-write-up/2379/2</link>
        <pubDate>Wed, 14 Jun 2017 09:34:29 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-2379-2</guid>
        <source url="https://0x00sec.org/t/the-devil-entered-the-stage-devils-swapper-write-up/2379.rss">The devil entered the stage - Devil&#39;s swapper write-up</source>
      </item>
      <item>
        <title>The devil entered the stage - Devil&#39;s swapper write-up</title>
        <dc:creator><![CDATA[ricksanchez]]></dc:creator>
        <description><![CDATA[
            <p>This is a write-up for solving the <a href="https://0x00sec.org/t/challenge-devils-swapper/2225">devils-swapper RE challenge</a>.‌‌ It was mostly intended for my personal archive but since it may be interesting to all of you. This especially applies if you’re still rather new to the whole RE world as the write-up turned out to be quite verbose. I hope it is still formatted in a clear and concise way to be able to follow along my thought process easily. If there are any open questions left feel free to ask :)!</p>
<h3>The binary</h3>
<p>Copied from the challenge linked above and pasted below for people who want to follow what I did:</p>
<h4>Building:</h4>
<pre><code class="lang-auto">cat textfile | base64 -d | gunzip &gt; challenge &amp;&amp; chmod +x challenge
</code></pre>
<h4>Challenge:</h4>
<pre><code class="lang-auto">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
</code></pre>
<h2>First examination</h2>
<p>First let’s run the file to see what it’s throwing at us:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/3X/e/1/e1ef2ac7da57b32f16d968a6f1ec7d6979f864bc.png" alt="" data-base62-sha1="weHQkqRrn2jyForFSESVXmclG68" width="662" height="210"></p>
<p>Well what did I expect :)? Running the file will only reveal that it is somehow not working as intended… So let’s check what’s wrong with the binary and what it may expect as input. <code>file</code> has to say the following about the binary:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/8/f/8fc9232996c547893e2a8349cef7b7bc180ab69a.png" data-download-href="/uploads/short-url/kvZdd1FotjsgoUd7JWS7AzaExiW.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/8/f/8fc9232996c547893e2a8349cef7b7bc180ab69a_2_690x70.png" alt="" data-base62-sha1="kvZdd1FotjsgoUd7JWS7AzaExiW" width="690" height="70" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/8/f/8fc9232996c547893e2a8349cef7b7bc180ab69a_2_690x70.png, https://0x00sec.s3.amazonaws.com/optimized/3X/8/f/8fc9232996c547893e2a8349cef7b7bc180ab69a_2_1035x105.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/3X/8/f/8fc9232996c547893e2a8349cef7b7bc180ab69a_2_1380x140.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/3X/8/f/8fc9232996c547893e2a8349cef7b7bc180ab69a_2_10x10.png"></a></div><p></p>
<p>So we got a stripped 64-bit ELF binary at our disposal. The challenge dictates us that we have to find a <em>secret key</em> and the <em>secret message</em> . We do not know anything about what is meant exactly and how key and message are connected with that hint at this point. Let’s continue with checking for strings within the binary:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/2/5/25de1e65cd6e57eac2e8b18d8bd937bc130eb302.png" data-download-href="/uploads/short-url/5oZyk5Lf50Th3t7hyIQIqVEgzFE.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/2/5/25de1e65cd6e57eac2e8b18d8bd937bc130eb302_2_534x500.png" alt="" data-base62-sha1="5oZyk5Lf50Th3t7hyIQIqVEgzFE" width="534" height="500" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/2/5/25de1e65cd6e57eac2e8b18d8bd937bc130eb302_2_534x500.png, https://0x00sec.s3.amazonaws.com/optimized/3X/2/5/25de1e65cd6e57eac2e8b18d8bd937bc130eb302_2_801x750.png 1.5x, https://0x00sec.s3.amazonaws.com/original/3X/2/5/25de1e65cd6e57eac2e8b18d8bd937bc130eb302.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/3X/2/5/25de1e65cd6e57eac2e8b18d8bd937bc130eb302_2_10x10.png"></a></div><p></p>
<p>There is one particular string in there which could hide some valuable information or hints! I’m talking about this one: <em>Purpx qq pbai bcgvbaf</em> !</p>
<p>No question some kind of cipher… Since <a class="mention" href="https://0x00sec.org/u/0x00pf">@0x00pf</a> said it would be a “simple” challenge I assumed some form of <a href="https://learncryptography.com/classical-encryption/caesar-cipher">caesars ciphers</a>. After trying for a while I found out it was indeed a caesars code with a key length of <em>k=13</em> . Exactly this kind of cipher is known under a different name as well: <a href="https://en.wikipedia.org/wiki/ROT13">ROT13</a>:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/d/4/d4691c9f6c4eedfaf673547722f6afa9f7dfcd14.png" data-download-href="/uploads/short-url/uj4qkItzkOnBcf8vaaxqnukkX2c.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/d/4/d4691c9f6c4eedfaf673547722f6afa9f7dfcd14_2_690x98.png" alt="" data-base62-sha1="uj4qkItzkOnBcf8vaaxqnukkX2c" width="690" height="98" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/d/4/d4691c9f6c4eedfaf673547722f6afa9f7dfcd14_2_690x98.png, https://0x00sec.s3.amazonaws.com/optimized/3X/d/4/d4691c9f6c4eedfaf673547722f6afa9f7dfcd14_2_1035x147.png 1.5x, https://0x00sec.s3.amazonaws.com/original/3X/d/4/d4691c9f6c4eedfaf673547722f6afa9f7dfcd14.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/3X/d/4/d4691c9f6c4eedfaf673547722f6afa9f7dfcd14_2_10x10.png"></a></div><p></p>
<p>So here is the portion of interest of the <a href="http://man7.org/linux/man-pages/man1/dd.1.html">dd man page</a>. Let’s look at the possible <em>conv</em> flags:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/8/6/8688356a3543de4403936f08e55ebbdde6c845ec.png" data-download-href="/uploads/short-url/jc7O14yGT5iQTV0vhkbDmsXJiAA.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/8/6/8688356a3543de4403936f08e55ebbdde6c845ec_2_525x500.png" alt="" data-base62-sha1="jc7O14yGT5iQTV0vhkbDmsXJiAA" width="525" height="500" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/8/6/8688356a3543de4403936f08e55ebbdde6c845ec_2_525x500.png, https://0x00sec.s3.amazonaws.com/optimized/3X/8/6/8688356a3543de4403936f08e55ebbdde6c845ec_2_787x750.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/3X/8/6/8688356a3543de4403936f08e55ebbdde6c845ec_2_1050x1000.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/3X/8/6/8688356a3543de4403936f08e55ebbdde6c845ec_2_10x10.png"></a></div><p></p>
<p>Now one could try to associate the name of the challenge with one of the flags. But just swapping every pair of input bytes with <code>dd if=binary of=binary2 conv=swab</code> would not make much sense, would it?</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/c/5/c5e0f680a9042369965fb9db4fc68bdbb5e88afc.png" data-download-href="/uploads/short-url/sew2DfS0EY0qBvmqbexdQVkCghK.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/c/5/c5e0f680a9042369965fb9db4fc68bdbb5e88afc_2_690x142.png" alt="" data-base62-sha1="sew2DfS0EY0qBvmqbexdQVkCghK" width="690" height="142" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/c/5/c5e0f680a9042369965fb9db4fc68bdbb5e88afc_2_690x142.png, https://0x00sec.s3.amazonaws.com/optimized/3X/c/5/c5e0f680a9042369965fb9db4fc68bdbb5e88afc_2_1035x213.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/3X/c/5/c5e0f680a9042369965fb9db4fc68bdbb5e88afc_2_1380x284.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/3X/c/5/c5e0f680a9042369965fb9db4fc68bdbb5e88afc_2_10x10.png"></a></div><p></p>
<p>Does not seem to be as easy as that. But if it were where would be the fun in that challenge! To recap: We have a valid (read it as “running”) ELF64 binary right of the bat. However, applying the first hint we got does not yield any meaningful results yet.</p>
<h2>Closer look at the binary</h2>
<p>To see what roadblock lies in front of us I’ll be using IDA to statically analyze the binary.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/b/f/bfeed328e63a0cac86398bde8be827c450ce2b4d.png" data-download-href="/uploads/short-url/rnUSm7k5o4dNDI3w1RlkaoSe5Z3.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/b/f/bfeed328e63a0cac86398bde8be827c450ce2b4d_2_690x387.png" alt="" data-base62-sha1="rnUSm7k5o4dNDI3w1RlkaoSe5Z3" width="690" height="387" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/b/f/bfeed328e63a0cac86398bde8be827c450ce2b4d_2_690x387.png, https://0x00sec.s3.amazonaws.com/optimized/3X/b/f/bfeed328e63a0cac86398bde8be827c450ce2b4d_2_1035x580.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/3X/b/f/bfeed328e63a0cac86398bde8be827c450ce2b4d_2_1380x774.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/3X/b/f/bfeed328e63a0cac86398bde8be827c450ce2b4d_2_10x10.png"></a></div><p></p>
<p>The <code>main</code> function is easily located as its quite short and shows the 2 known string constants we’ve been seeing when executing the binary. <code>sub_4001D0</code> is an interesting little fellow as its setting the <code>al</code> portion in <code>rax</code> to 1 followed by jump in the middle of another function:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/3X/f/f/ff98ef5acd8a3f0b7603597cae92f7c35d2cef8d.png" alt="" data-base62-sha1="At7pPAwpV9EwdoqanoapV5Pr6ZT" width="650" height="212"></p>
<p>We’ll take a closer at that part later. First I want to know why the <code>cmp</code> followed by a <code>jnz</code> at <code>main+17</code> is defaulting to the bad route in the original challenge. The comparison takes whatever is in the data segment (c <em>s:XXX</em> ) and silently subtracts it from the hard coded value of <code>0x2ba5441</code> , meaning the result is not stored in one of the base registers, but the zero flag is set when both values are equal. Hence, the <em>jump if not zero</em> ( <code>jnz</code> ) is only not taken in the case we fix the comparison to be equal! So let’s check what is being stored in that identified segment.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/b/9/b97063095578e23f269eda50eac26d5cdb666463.png" data-download-href="/uploads/short-url/qst7qpaKcxIXBSe7bTK7fWkHYDp.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/b/9/b97063095578e23f269eda50eac26d5cdb666463_2_690x203.png" alt="" data-base62-sha1="qst7qpaKcxIXBSe7bTK7fWkHYDp" width="690" height="203" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/b/9/b97063095578e23f269eda50eac26d5cdb666463_2_690x203.png, https://0x00sec.s3.amazonaws.com/optimized/3X/b/9/b97063095578e23f269eda50eac26d5cdb666463_2_1035x304.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/3X/b/9/b97063095578e23f269eda50eac26d5cdb666463_2_1380x406.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/3X/b/9/b97063095578e23f269eda50eac26d5cdb666463_2_10x10.png"></a></div><p></p>
<p>The data starting at address <code>0x40051d</code> looks garbled and does not make much sense. However, that first dword of <code>0x0ba024154</code> looks oddly familiar, doesn’t it? It’s like a badly shuffled version of that hard coded value from that comparison in <code>main+17</code> ! At a second glance if you swap positions of the upper two bytes and the lower two bytes you get exactly that value from the comparison! This is the time to recall the hint about looking at the <em>conv</em> flags of the UNIX <code>dd</code> utility! So let’s calculate the bounds on where to partially apply that <em>swab</em> option:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/6/2/62f17657b928f7992706b2b9e548c148255ae581.png" data-download-href="/uploads/short-url/e7i7BrCZ9aSQekX151Sz8WviFSF.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/6/2/62f17657b928f7992706b2b9e548c148255ae581_2_690x112.png" alt="" data-base62-sha1="e7i7BrCZ9aSQekX151Sz8WviFSF" width="690" height="112" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/6/2/62f17657b928f7992706b2b9e548c148255ae581_2_690x112.png, https://0x00sec.s3.amazonaws.com/optimized/3X/6/2/62f17657b928f7992706b2b9e548c148255ae581_2_1035x168.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/3X/6/2/62f17657b928f7992706b2b9e548c148255ae581_2_1380x224.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/3X/6/2/62f17657b928f7992706b2b9e548c148255ae581_2_10x10.png"></a></div><p></p>
<p>Alternatively we could have also extracted the size and offset from our trusty pal readelf!</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/8/b/8b6c25f81607a5c1e6082305c5c0e9df4d8baa76.png" data-download-href="/uploads/short-url/jTo4EECPiVsGQOarcJxNqiXycbY.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/8/b/8b6c25f81607a5c1e6082305c5c0e9df4d8baa76_2_566x500.png" alt="" data-base62-sha1="jTo4EECPiVsGQOarcJxNqiXycbY" width="566" height="500" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/8/b/8b6c25f81607a5c1e6082305c5c0e9df4d8baa76_2_566x500.png, https://0x00sec.s3.amazonaws.com/optimized/3X/8/b/8b6c25f81607a5c1e6082305c5c0e9df4d8baa76_2_849x750.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/3X/8/b/8b6c25f81607a5c1e6082305c5c0e9df4d8baa76_2_1132x1000.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/3X/8/b/8b6c25f81607a5c1e6082305c5c0e9df4d8baa76_2_10x10.png"></a></div><p></p>
<p>When looking at the readelf output above we see yet another weird occurrence! The .data section should hold data like variables or global tables. It should certainly <strong>not</strong> be marked as executable! So either the flags are wrong or it actually holds binary data! Let’s load the executable back into IDA and see how the disassembly changed now that we have applied the dd treatment :).</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/d/1/d188c1a08a94b486d4c8a53131040ba89de627dc.png" data-download-href="/uploads/short-url/tTCN0xXZr27ThtixzuWAEOeBJE0.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/d/1/d188c1a08a94b486d4c8a53131040ba89de627dc_2_678x500.png" alt="" data-base62-sha1="tTCN0xXZr27ThtixzuWAEOeBJE0" width="678" height="500" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/d/1/d188c1a08a94b486d4c8a53131040ba89de627dc_2_678x500.png, https://0x00sec.s3.amazonaws.com/optimized/3X/d/1/d188c1a08a94b486d4c8a53131040ba89de627dc_2_1017x750.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/3X/d/1/d188c1a08a94b486d4c8a53131040ba89de627dc_2_1356x1000.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/3X/d/1/d188c1a08a94b486d4c8a53131040ba89de627dc_2_10x10.png"></a></div><p></p>
<p>We’ve got a lot of new code that needs reversing! On top of that the at first shuffled address was also corrected and matches the hard coded address value from the <em>main</em> function! We should be able to pass that comparison now and not run into the bad ending again.</p>
<h3>Running the new binary</h3>
<p>To verify our assumption from above let’s execute our “new” binary:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/3X/3/a/3a262d5701515c7f20ef70e641921bb2b6e20373.png" alt="" data-base62-sha1="8ipudqBM1fYazNu96VtLGkfrEpJ" width="604" height="202"></p>
<p>Wonderful we are getting greeted by the usual but this time we get a little extra too! A brand new shell prompt that’s awaiting some user input!</p>
<h2>Finding the flag</h2>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/f/a/fa9eb5c50bd28d5b7e4856b623a7389f3b8dd650.png" data-download-href="/uploads/short-url/zL5oWrqFPeX6JBj7c0myQJJpE1a.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/f/a/fa9eb5c50bd28d5b7e4856b623a7389f3b8dd650_2_278x500.png" alt="" data-base62-sha1="zL5oWrqFPeX6JBj7c0myQJJpE1a" width="278" height="500" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/f/a/fa9eb5c50bd28d5b7e4856b623a7389f3b8dd650_2_278x500.png, https://0x00sec.s3.amazonaws.com/optimized/3X/f/a/fa9eb5c50bd28d5b7e4856b623a7389f3b8dd650_2_417x750.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/3X/f/a/fa9eb5c50bd28d5b7e4856b623a7389f3b8dd650_2_556x1000.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/3X/f/a/fa9eb5c50bd28d5b7e4856b623a7389f3b8dd650_2_10x10.png"></a></div><p></p>
<h4>Observation</h4>
<ul>
<li>
<strong>Only the first character</strong> of the input seems to be accepted. There seems to be a different output of different lengths for each character. Also, the output behavior is <strong>deterministic</strong> , meaning the same input always yields the same output. Assumption: The different lengths of the observed outputs could be due to unprintable values that are being calculated.</li>
<li>After getting a (broken?) return value our binary terminates and our normal terminal emulator tries to execute the rest of the input as a system utility as the binary exits before handling the remaining input.</li>
</ul>
<h3>First attempt to get the secret message</h3>
<p>So to find the flag one could brute force their way through now.‌‌ Only one character input gets seemingly validated or at least looked at.‌‌ The amount of printable user input characters is very limited to roughly 100 possibilities (s. <a href="https://www.asciitable.com/">ASCII table</a>). ‌‌ We can easily brute force our way in if our assumptions still hold true… However, there is still one catch: We do <strong>not</strong> know what the behavior of the binary for the correct flag looks like yet so lets dig deeper into that next!</p>
<h3>Dumb brute force solution (up to here)</h3>
<pre><code class="lang-python">#!/usr/bin/env python3

from pwn import *
import string
import sys

exe = "./challenge"

def main():
    for char in string.printable:
        p = process(exe)
        p.recvuntil(b"$")
        p.sendline(char)
        # This is the line we have no knowledge about
        if ??? not in p.recvall():
            continue
        else:
            print(f"Correct input is: {char}")
            sys.exit()

if __name__ == '__main__':
    main()
</code></pre>
<p>This could be one way to brute force the solution if we would know what the expected behavior (in this case the correct deciphered message) looks like. We obviously could just try every possibility and print out the potentially deciphered message into the terminal each time and look for what input is the correct one based on the produced output. This may be a legitimate solution if you just wanted to bypass this deciphering to get deeper into the binary. However, this part where we’re currently stuck at is the whole exercise for this RE challenge. So let’s continue doing that!</p>
<h3>Part 1 of newly discovered code - Init phase</h3>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/5/1/514c0f70310ff13897fe4288d0ed8f7a0e9a7a39.png" data-download-href="/uploads/short-url/bBbDhp0RJtDbdR4A6y3XamnTHrb.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/5/1/514c0f70310ff13897fe4288d0ed8f7a0e9a7a39_2_690x432.png" alt="" data-base62-sha1="bBbDhp0RJtDbdR4A6y3XamnTHrb" width="690" height="432" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/5/1/514c0f70310ff13897fe4288d0ed8f7a0e9a7a39_2_690x432.png, https://0x00sec.s3.amazonaws.com/optimized/3X/5/1/514c0f70310ff13897fe4288d0ed8f7a0e9a7a39_2_1035x648.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/3X/5/1/514c0f70310ff13897fe4288d0ed8f7a0e9a7a39_2_1380x864.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/3X/5/1/514c0f70310ff13897fe4288d0ed8f7a0e9a7a39_2_10x10.png"></a></div><p></p>
<p>The first block is where we left of the last time. <code>0x2ba5441</code> is the destination we wanted to jump to from the <code>main</code> function. To fully understand what’s going on next we first need to understand that the disassembly shown here by IDA is not completely correct. That seemingly “magic value” we jump to is not just an address but actual code that is being executed and translates to: <code>push r12; mov edx, 0x2</code> .</p>
<p>In the second part marked as blue, we first have to understand what <code>sub_4001d0</code> does before talking about the setup steps prior to the function call. We mentioned this particular function right at the beginning when talking about the <code>main</code> function too:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/3X/8/7/87333752f3748e06707330533b4461a13c07b80d.png" alt="" data-base62-sha1="ji2bGFnOXK9wHv4gvg9Ew6xQ3q5" width="344" height="328"></p>
<p>This fella is really just prepping the <code>al</code> portion of the <code>rax</code> register before doing a direct jump into another code section:<br>
</p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/3/3/336ee3ab4e0f1458d3a2aa6ffc4034bf1049edc1.png" data-download-href="/uploads/short-url/7kZVG2JgjKI8rWCYx4fq0vrGlot.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/3/3/336ee3ab4e0f1458d3a2aa6ffc4034bf1049edc1_2_690x488.png" alt="" data-base62-sha1="7kZVG2JgjKI8rWCYx4fq0vrGlot" width="690" height="488" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/3/3/336ee3ab4e0f1458d3a2aa6ffc4034bf1049edc1_2_690x488.png, https://0x00sec.s3.amazonaws.com/optimized/3X/3/3/336ee3ab4e0f1458d3a2aa6ffc4034bf1049edc1_2_1035x732.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/3X/3/3/336ee3ab4e0f1458d3a2aa6ffc4034bf1049edc1_2_1380x976.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/3X/3/3/336ee3ab4e0f1458d3a2aa6ffc4034bf1049edc1_2_10x10.png"></a></div><p></p>
<p>We can directly see that the jump happens in the middle of a function. We can also see that the <code>rax</code> register undergoes some more prepping before a <strong>syscall</strong> is issued. IDA falsely mislabels this as a <code>sys_read</code> syscall, which holds true when only looking at this function as an isolated code snippet. IDAs assumption is based on the fact that on an ELF-64 bit binary the ABI dictates that <code>rax</code> holds the syscall number, which corresponds to the functionality that is being executed. In this function <code>rax</code> looks like this:</p>
<pre><code class="lang-auto">0. rax - 0x????????????????
1. rax - 0x??????????????3c
2. rax - 0x????????????003c
3. rax - 0x????????0000003c
</code></pre>
<p>This yields 2 problems:</p>
<ol>
<li>There is no guarantee about what the upper 32-bit of <code>rax</code> hold.</li>
<li>The syscall number <code>0x3c</code> does <strong>not</strong> correspond to <code>sys_read</code> !</li>
</ol>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/3/b/3bcf097faee1bc50f357e266649715fd43e7cfe4.png" data-download-href="/uploads/short-url/8x5KeuUw9PHaqHxTE7k0lP0v2Ru.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/3/b/3bcf097faee1bc50f357e266649715fd43e7cfe4_2_690x154.png" alt="" data-base62-sha1="8x5KeuUw9PHaqHxTE7k0lP0v2Ru" width="690" height="154" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/3/b/3bcf097faee1bc50f357e266649715fd43e7cfe4_2_690x154.png, https://0x00sec.s3.amazonaws.com/optimized/3X/3/b/3bcf097faee1bc50f357e266649715fd43e7cfe4_2_1035x231.png 1.5x, https://0x00sec.s3.amazonaws.com/original/3X/3/b/3bcf097faee1bc50f357e266649715fd43e7cfe4.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/3X/3/b/3bcf097faee1bc50f357e266649715fd43e7cfe4_2_10x10.png"></a></div><p></p>
<p>This brings up 2 new questions:</p>
<ol>
<li>The heck is <code>sys_quotactl</code> ? If you’re interested check the <a href="https://manned.org/sys_quotactl/ba7dc951">manpage, but</a> it doesn’t quite matter for the challenge!</li>
<li>Why is IDA labeling as <code>sys_read</code> ? Honestly, I’m not sure. It might have been the result of one of IDAs binary analysis passes.</li>
</ol>
<p>Both questions can be easily ignored, because when we back paddle a bit to the second code snippet marked with the blue box earlier, we can see there is a <code>xor eax, eax</code> that zeroes out the register. And that register is not modified before taking the direct jump to the helper function that sets it again to 1. Now we could question why we do not have a <code>xor rax, rax</code> instead, as only this instruction would zero out the upper 32-bit too. This must be due to the fact that the compiler knows at compile-time that these bits were never set and hence are already 0. Using a <code>xor eax, eax</code> in this case saves us 1 byte:</p>
<pre><code class="lang-auto">xor eax, eax --- "\x31\xc0"
xor rax, rax --- "\x48\x31\xc0"
</code></pre>
<p>So that mystery is solved and caused by compiler optimizations. Now remember why we tried to figure that out in the first place! It leaves us with the following:</p>
<pre><code class="lang-auto">0. rax - 0x00000000??????01
1. rax - 0x00000000????0001
3. rax - 0x0000000000000001
</code></pre>
<p>Meaning that <code>rax</code> holds 1, which in turn results in the syscall <code>sys_write</code> ! This clears up most of the confusion for the first snippet:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/2/b/2b30e8cdef19fe098813988643ff18d1c8554a6d.png" data-download-href="/uploads/short-url/6a5jMH0cdzkwm8YLXbGkLBqFb3f.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/2/b/2b30e8cdef19fe098813988643ff18d1c8554a6d_2_690x54.png" alt="" data-base62-sha1="6a5jMH0cdzkwm8YLXbGkLBqFb3f" width="690" height="54" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/2/b/2b30e8cdef19fe098813988643ff18d1c8554a6d_2_690x54.png, https://0x00sec.s3.amazonaws.com/optimized/3X/2/b/2b30e8cdef19fe098813988643ff18d1c8554a6d_2_1035x81.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/3X/2/b/2b30e8cdef19fe098813988643ff18d1c8554a6d_2_1380x108.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/3X/2/b/2b30e8cdef19fe098813988643ff18d1c8554a6d_2_10x10.png"></a></div><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/b/0/b05975ac002495abaa16235b9f497d24d731ab9d.png" data-download-href="/uploads/short-url/pa3Htwa6XmC2TPeUOiqe30xAP4F.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/b/0/b05975ac002495abaa16235b9f497d24d731ab9d_2_690x189.png" alt="" data-base62-sha1="pa3Htwa6XmC2TPeUOiqe30xAP4F" width="690" height="189" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/b/0/b05975ac002495abaa16235b9f497d24d731ab9d_2_690x189.png, https://0x00sec.s3.amazonaws.com/optimized/3X/b/0/b05975ac002495abaa16235b9f497d24d731ab9d_2_1035x283.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/3X/b/0/b05975ac002495abaa16235b9f497d24d731ab9d_2_1380x378.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/3X/b/0/b05975ac002495abaa16235b9f497d24d731ab9d_2_10x10.png"></a></div><p></p>
<p>The remaining parameters of interest are the buffer with the contents to write in <code>rsi</code> ("$ "), the buffer length in <code>rdx</code> (0x2) and the file descriptor to write to in <code>rdi</code> (0x1 == stdout). So all this snippet does is presenting the user with a shell prompt character on stdout. Besides that this snippet also contains saving register values on the stack (2 x <code>push</code> ) and preparing the stack for what is about to come next <code>sub rsp, 0x410</code> ).</p>
<p>Now that we have talked about the second snippet (blue box) the third one (green box) will be dealt with fast, as its pretty much the same functionality with one different function call.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/7/3/73a9c3dc17b636a023904b72fc6223402342c057.png" data-download-href="/uploads/short-url/gvcD0gAv0auxn0trC6o2wYaREWP.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/original/3X/7/3/73a9c3dc17b636a023904b72fc6223402342c057.png" alt="" data-base62-sha1="gvcD0gAv0auxn0trC6o2wYaREWP" width="690" height="100" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/3X/7/3/73a9c3dc17b636a023904b72fc6223402342c057_2_10x10.png"></a></div><img src="https://0x00sec.s3.amazonaws.com/original/3X/8/9/899e4abb8efb2bab0f18f0fe3c8c345c0bc1c3c0.png" alt="" data-base62-sha1="jDqyfb0MfKn8tV8ViFxvVyDvhPG" width="464" height="352"><p></p>
<p>When following along until here you should recognize what is going on. In <code>sub_4001c9</code> we’re setting the <code>al</code> portion in <code>rax</code> to 0 instead of setting it to 1 as before. The direct jump that follows is to the exact same location as before, meaning another syscall is being executed here! Syscall number 0x0 corresponds to <code>sys_read</code> . So when putting it all together we can annotate the disassembly in IDA as follows:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/0/8/084ccdb1f8ce62bcc77f5be836266a2fae3de890.png" data-download-href="/uploads/short-url/1bqmYbKLgzzg5uoyGZ0aSAvMEmI.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/0/8/084ccdb1f8ce62bcc77f5be836266a2fae3de890_2_690x216.png" alt="" data-base62-sha1="1bqmYbKLgzzg5uoyGZ0aSAvMEmI" width="690" height="216" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/0/8/084ccdb1f8ce62bcc77f5be836266a2fae3de890_2_690x216.png, https://0x00sec.s3.amazonaws.com/optimized/3X/0/8/084ccdb1f8ce62bcc77f5be836266a2fae3de890_2_1035x324.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/3X/0/8/084ccdb1f8ce62bcc77f5be836266a2fae3de890_2_1380x432.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/3X/0/8/084ccdb1f8ce62bcc77f5be836266a2fae3de890_2_10x10.png"></a></div><br>
We’ve seen this exact behavior we just annotated in the disassembly when running the binary after using the <code>dd</code> trick on it! The next part (pink) finishes the setup phase that is being done :<p></p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/7/8/78ad9460db62f6bd719365e549d1d442bce81655.png" data-download-href="/uploads/short-url/hdzbIF2TBFD84A1GFJJW5PzFmtL.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/7/8/78ad9460db62f6bd719365e549d1d442bce81655_2_690x119.png" alt="" data-base62-sha1="hdzbIF2TBFD84A1GFJJW5PzFmtL" width="690" height="119" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/7/8/78ad9460db62f6bd719365e549d1d442bce81655_2_690x119.png, https://0x00sec.s3.amazonaws.com/optimized/3X/7/8/78ad9460db62f6bd719365e549d1d442bce81655_2_1035x178.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/3X/7/8/78ad9460db62f6bd719365e549d1d442bce81655_2_1380x238.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/3X/7/8/78ad9460db62f6bd719365e549d1d442bce81655_2_10x10.png"></a></div><p></p>
<p>This one effectively does 3 things in total:</p>
<ol>
<li>
<code>rsp+0x0f</code> holds the 1 byte buffer for the user input. Whatever character the user entered 0x20 is subtracted from its ASCII value ( e.g. “A” == 0x41 - 0x20 = 0x21 == “!”).</li>
<li>The next part up to (and including the <code>rep stosd</code> ) is equal to a <code>void *memset(void *b, int c, size_t len)</code> operation with len ( <code>rcx</code> ), c ( <code>rax</code> ), and *b ( <code>rdi</code> ). This initializes a 256 byte buffer to 0. Alternatively this pattern of <code>rep stosX</code> can also be encountered on <code>void *memcpy(void *dest, const void *src, size_t n);</code> operations.</li>
<li>Finally, 3 4-byte values are put one after another into that zero-initialized buffer, which if you look closely is right in front of the single user byte input buffer! On top of that when looking at those values we can uncover that most of those hex values are either in ASCII range (0x20 - 0x7e) or are located very close to that. This gives us access to the assumption that this is the secret message we’re looking for. Decoding this as is doesn’t yield anything useful though:</li>
</ol>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/7/c/7c9fb72580242f4ecccee160a6c92f0fa61d9c96.png" data-download-href="/uploads/short-url/hMtouwc0qVIQCn2Mzm3Sxz5JnTw.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/7/c/7c9fb72580242f4ecccee160a6c92f0fa61d9c96_2_690x99.png" alt="" data-base62-sha1="hMtouwc0qVIQCn2Mzm3Sxz5JnTw" width="690" height="99" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/7/c/7c9fb72580242f4ecccee160a6c92f0fa61d9c96_2_690x99.png, https://0x00sec.s3.amazonaws.com/original/3X/7/c/7c9fb72580242f4ecccee160a6c92f0fa61d9c96.png 1.5x, https://0x00sec.s3.amazonaws.com/original/3X/7/c/7c9fb72580242f4ecccee160a6c92f0fa61d9c96.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/3X/7/c/7c9fb72580242f4ecccee160a6c92f0fa61d9c96_2_10x10.png"></a></div><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/e/b/eb369860cf10eb614e8e450dfc5d9bdfdb611fb3.png" data-download-href="/uploads/short-url/xyNaROAAe3IccNGv4F7zzOAtaKf.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/e/b/eb369860cf10eb614e8e450dfc5d9bdfdb611fb3_2_690x290.png" alt="" data-base62-sha1="xyNaROAAe3IccNGv4F7zzOAtaKf" width="690" height="290" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/e/b/eb369860cf10eb614e8e450dfc5d9bdfdb611fb3_2_690x290.png, https://0x00sec.s3.amazonaws.com/optimized/3X/e/b/eb369860cf10eb614e8e450dfc5d9bdfdb611fb3_2_1035x435.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/3X/e/b/eb369860cf10eb614e8e450dfc5d9bdfdb611fb3_2_1380x580.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/3X/e/b/eb369860cf10eb614e8e450dfc5d9bdfdb611fb3_2_10x10.png"></a></div><p></p>
<p>This is the end of the data preperation in this part of the binary. We encountered the exact code we have been seeing when executing the binary in our very brief <em>dynamic analysis</em> part earlier! These are namely the “shell prompt” and the possibility for a 1 byte user input. Next we’ll take a look at the actual deciphering scheme to find the secret message!</p>
<h3>Part 2 of newly discovered code - Deciphering</h3>
<p>Similar to Part 1 this stage consists of 3 large blocks that we’ll discuss here. Below you can find the bare unannotated IDA dissassembly:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/d/c/dc1a10c5e73027f8c16a11e3f9e68017358f6167.png" data-download-href="/uploads/short-url/vp6T5QoaQj6b86FUOSUXO1evxWf.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/d/c/dc1a10c5e73027f8c16a11e3f9e68017358f6167_2_690x490.png" alt="" data-base62-sha1="vp6T5QoaQj6b86FUOSUXO1evxWf" width="690" height="490" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/d/c/dc1a10c5e73027f8c16a11e3f9e68017358f6167_2_690x490.png, https://0x00sec.s3.amazonaws.com/optimized/3X/d/c/dc1a10c5e73027f8c16a11e3f9e68017358f6167_2_1035x735.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/3X/d/c/dc1a10c5e73027f8c16a11e3f9e68017358f6167_2_1380x980.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/3X/d/c/dc1a10c5e73027f8c16a11e3f9e68017358f6167_2_10x10.png"></a></div><p></p>
<p>When first reaching the code at adress <code>0x40057f</code> <code>rbx</code> still points to <code>rsp+0x10</code> , which corresponds to the beginning of the 12 byte cipher. Hence, as we’re on 64-Bit the contents of <code>rbx</code> at this very point in time: <code>[rbx] == 0x7a7c5631787f7746</code> . This results in the <code>jz</code> failing at first, but in combination with the fact that <code>0x40057f</code> is also the jump target from <code>0x4005b5</code> we have a clear loop exit condition showcasing that eventually we should reach a NULL pointer condition to not enter the loop body again. Right after we access the ciper at index 4 and copy the value into <code>rbp</code> (during the first iteration this means <code>rbp</code> points to <code>0x1e3233747a7c5631</code> ), which corresponds to the latter 2 4-byte values in the very first iteration. Finally, another pointer to the cipher ( <code>rbx</code> ) is copied into <code>rsi</code> . To summarize that chaos: We have a loop exit condition and if that one doesn’t hold true we update two pointers with different indices into the cipher message.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/f/8/f851430be267139fd0af5aa17ec83ac440806228.png" data-download-href="/uploads/short-url/zqIvXxxWG6G2N9m7u9P3c2Q7keI.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/original/3X/f/8/f851430be267139fd0af5aa17ec83ac440806228.png" alt="" data-base62-sha1="zqIvXxxWG6G2N9m7u9P3c2Q7keI" width="690" height="58" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/3X/f/8/f851430be267139fd0af5aa17ec83ac440806228_2_10x10.png"></a></div><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/4/f/4fcbf83942fc9a387c08df03ad33cdb54390fc55.png" data-download-href="/uploads/short-url/bnUIPtzavDtaJku8W2zRUmiOoYt.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/4/f/4fcbf83942fc9a387c08df03ad33cdb54390fc55_2_690x339.png" alt="" data-base62-sha1="bnUIPtzavDtaJku8W2zRUmiOoYt" width="690" height="339" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/4/f/4fcbf83942fc9a387c08df03ad33cdb54390fc55_2_690x339.png, https://0x00sec.s3.amazonaws.com/optimized/3X/4/f/4fcbf83942fc9a387c08df03ad33cdb54390fc55_2_1035x508.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/3X/4/f/4fcbf83942fc9a387c08df03ad33cdb54390fc55_2_1380x678.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/3X/4/f/4fcbf83942fc9a387c08df03ad33cdb54390fc55_2_10x10.png"></a></div><p></p>
<p>Above we can see a recap of the cipher message being stored in memory and the actual memory layout in GDB when debugging after the three <code>mov</code> instructions have been executed.</p>
<p>In the next block (green box) the “magic” of the binary happens. A strong very first indicator for that is the already labeled <code>sysWrite_Init</code> function call we already encountered and understood before. Meaning we’re definitely gonna print to <em>stdout</em> here! We seen in our dynamic analysis that the only thing written back to stdout is the seemingly scrambled message! So let’s try to figure out what kind of algorithm that is munching on the bits and bytes there :)! A quick first disassembly annotation of the code snippet may look like this:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/a/a/aa89da543b99f67056afffb6422ca19681f79d6e.png" data-download-href="/uploads/short-url/okEw8v4QFkZCy8UOGWT32ZKhBpk.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/a/a/aa89da543b99f67056afffb6422ca19681f79d6e_2_690x242.png" alt="" data-base62-sha1="okEw8v4QFkZCy8UOGWT32ZKhBpk" width="690" height="242" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/a/a/aa89da543b99f67056afffb6422ca19681f79d6e_2_690x242.png, https://0x00sec.s3.amazonaws.com/optimized/3X/a/a/aa89da543b99f67056afffb6422ca19681f79d6e_2_1035x363.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/3X/a/a/aa89da543b99f67056afffb6422ca19681f79d6e_2_1380x484.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/3X/a/a/aa89da543b99f67056afffb6422ca19681f79d6e_2_10x10.png"></a></div><p></p>
<p>But that still looks rather gnarly and confusing doesn’t it? There are a few key takeawys in the block besides the obvious write to <em>stdout</em> . The decryption routine makes use of addition, subtraction and XOR. The inner loop handles the actual decrypting and printing while the outer loop only occurs every 4 iterations (when <code>r12</code> == <code>rbp</code> ) to advance the pointer stored in <code>rbp</code> .</p>
<h3>Reimplementing the decryption routine</h3>
<p>Let’s try re-implementing that above shown behavior! I used Python for a quick and dirty prototype. As the challenge is a statically linked binary and makes use of constant pointer values in its decryption we need to consider this as well and implement a little memory map.</p>
<pre><code class="lang-python">#!/usr/bin/env python3

import sys
from ctypes import *

# MMAP
mapping = {
    0: (0x00007FFFFFFFDAA0, 0x46),
    1: (0x00007FFFFFFFDAA1, 0x77),
    2: (0x00007FFFFFFFDAA2, 0x7F),
    3: (0x00007FFFFFFFDAA3, 0x78),
    4: (0x00007FFFFFFFDAA4, 0x31),
    5: (0x00007FFFFFFFDAA5, 0x56),
    6: (0x00007FFFFFFFDAA6, 0x7C),
    7: (0x00007FFFFFFFDAA7, 0x7A),
    8: (0x00007FFFFFFFDAA8, 0x74),
    9: (0x00007FFFFFFFDAA9, 0x33),
    10: (0x00007FFFFFFFDAAA, 0x32),
    11: (0x00007FFFFFFFDAAB, 0x1E),
    12: (0x00007FFFFFFFDAAC, 0x00),
    13: (0x00007FFFFFFFDAAD, 0x00),
    14: (0x00007FFFFFFFDAAE, 0x00),
    15: (0x00007FFFFFFFDAAF, 0x00),
    16: (0x00007FFFFFFFDAB0, 0x00),
    16: (0x00007FFFFFFFDAB1, 0x00),
    17: (0x00007FFFFFFFDAB2, 0x00),
    18: (0x00007FFFFFFFDAB3, 0x00),
    19: (0x00007FFFFFFFDAB4, 0x00),
    20: (0x00007FFFFFFFDAB5, 0x00),
}


def shifter(idx: int) -&gt; int:
    tmp = 0
    for i in range(idx, 8 + idx):
        tmp |= mapping[i][1] &lt;&lt; i * 8
    return tmp &gt;&gt; idx * 8


def decrypt(usr_in: str):
    mod_usr = ord(usr_in) - 0x20
    print(f"Modified user input: {hex(mod_usr)}")

    j = 0
    res = ""
    for i, v in mapping.items():
        al = v[0] &amp; 0xFF
        if j % 4 == 0:
            idx = int(j / 4) * 4
            ebx = mapping.get(idx)[0]
        al_ebx = c_int32(al).value - c_int32(ebx).value
        al_ebx_w_usr = al_ebx + mod_usr
        val = shifter(i)
        xor = c_int64(val).value ^ (al_ebx_w_usr &amp; 0xFF)
        # print(f"al_ebx: {hex(al_ebx)}, al_ebx_w_usr: {hex(al_ebx_w_usr)}, val: {hex(val)}, xor: {hex(xor)}")
        res += chr(xor &amp; 0xFF)
        j += 1
        if j == 12:
            print(f"[+] Decrypted: {res}")
            sys.exit(0)


def main():
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} &lt;usr_byte&gt;!")
        exit()
    decrypt(sys.argv[1])


if __name__ == "__main__":
    main()
</code></pre>
<p>Now running this script proves it’s working as intended. The input-output-pairs below are identical with the values we were getting in the original binary (as seen in the beginning!):</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/a/c/acfb2bb343678cd5bd0a90b16be87fd8556bb533.png" data-download-href="/uploads/short-url/oGgfQN3R9VN0WCMisSWMb3bBOLx.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/a/c/acfb2bb343678cd5bd0a90b16be87fd8556bb533_2_690x300.png" alt="" data-base62-sha1="oGgfQN3R9VN0WCMisSWMb3bBOLx" width="690" height="300" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/a/c/acfb2bb343678cd5bd0a90b16be87fd8556bb533_2_690x300.png, https://0x00sec.s3.amazonaws.com/original/3X/a/c/acfb2bb343678cd5bd0a90b16be87fd8556bb533.png 1.5x, https://0x00sec.s3.amazonaws.com/original/3X/a/c/acfb2bb343678cd5bd0a90b16be87fd8556bb533.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/3X/a/c/acfb2bb343678cd5bd0a90b16be87fd8556bb533_2_10x10.png"></a></div><p></p>
<p>If the annotated disassembly or the python code are still confusing for you take a look at this debug output below that visualizes the algorithm quite nicely! The value in a <em>l_ebx</em> actually always hovers around <code>0x2600</code> to <code>0x2603</code> . This value is independent of any user interaction and stays “constant” across all invocations! The second value marked with green changes across invocation but that’s only due to the modified user input ( <code>usr_in</code> - <code>0x20</code> ) being added to <em>al_ebx.</em> As our input changed across the 3 runs that value changed accordingly too. However, it follows the same pattern. The value repeats itself every 4 iterations! Second to last the large, but shrinking hex value is the access into the hard coded cipher. If you look closely, we can observe the 1-byte right shift to access the next cipher portion in the iterations. Last but not least, the least significant byte in the <em>xor</em> result is the byte that is getting printed to stdout.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/e/e/eede99fc0b68dd587a0bd999c364a5c6ed3ce7b7.png" data-download-href="/uploads/short-url/y58yGF6pXqagbZs9wnrbffsGiUf.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/e/e/eede99fc0b68dd587a0bd999c364a5c6ed3ce7b7_2_476x500.png" alt="" data-base62-sha1="y58yGF6pXqagbZs9wnrbffsGiUf" width="476" height="500" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/e/e/eede99fc0b68dd587a0bd999c364a5c6ed3ce7b7_2_476x500.png, https://0x00sec.s3.amazonaws.com/optimized/3X/e/e/eede99fc0b68dd587a0bd999c364a5c6ed3ce7b7_2_714x750.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/3X/e/e/eede99fc0b68dd587a0bd999c364a5c6ed3ce7b7_2_952x1000.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/3X/e/e/eede99fc0b68dd587a0bd999c364a5c6ed3ce7b7_2_10x10.png"></a></div><p></p>
<p>At this point, one dumb bruteforce method that we could apply now is iterating over the whole possible input space and save those inputs where the output only contains lower- and upper-case ASCII characters, numerals, a space and maybe possible puncutations. This would weed out some garbage inputs as we’re expecting a “secret message”. We could refine this approach even further with the aim that the output closely represent the structure of a sentence/message. We can achieve that by specifiying that our decrypted results has to start with letters, continue with whatever in the middle and have to end with some punctuation characters. On top of all of that we could also check if the <em>n-th</em> , <em>n-th+4</em> , and the <strong>n-th+8</strong> entry in the decrypted cipher are always in that “valid” ASCII range we defined earlier. We can do this as one component that is being used within the <em>xor</em> repeats itself every 4 iterations (see in the screenshot above, e.g. iteration 0, 4, and 9!). Putting it all together leaves us with this.</p>
<h3>Dumb brute force solution (completed)</h3>
<pre><code class="lang-python">#!/usr/bin/env python3

import string
import sys
from ctypes import *
from typing import List

ALPHABET = [x for x in (string.ascii_letters + string.digits + "!?_ ")]

# MMAP
mapping = {
    0: (0x00007FFFFFFFDAA0, 0x46),
    1: (0x00007FFFFFFFDAA1, 0x77),
    2: (0x00007FFFFFFFDAA2, 0x7F),
    3: (0x00007FFFFFFFDAA3, 0x78),
    4: (0x00007FFFFFFFDAA4, 0x31),
    5: (0x00007FFFFFFFDAA5, 0x56),
    6: (0x00007FFFFFFFDAA6, 0x7C),
    7: (0x00007FFFFFFFDAA7, 0x7A),
    8: (0x00007FFFFFFFDAA8, 0x74),
    9: (0x00007FFFFFFFDAA9, 0x33),
    10: (0x00007FFFFFFFDAAA, 0x32),
    11: (0x00007FFFFFFFDAAB, 0x1E),
    12: (0x00007FFFFFFFDAAC, 0x00),
    13: (0x00007FFFFFFFDAAD, 0x00),
    14: (0x00007FFFFFFFDAAE, 0x00),
    15: (0x00007FFFFFFFDAAF, 0x00),
    16: (0x00007FFFFFFFDAB0, 0x00),
    16: (0x00007FFFFFFFDAB1, 0x00),
    17: (0x00007FFFFFFFDAB2, 0x00),
    18: (0x00007FFFFFFFDAB3, 0x00),
    19: (0x00007FFFFFFFDAB4, 0x0),
    20: (0x00007FFFFFFFDAB5, 0x00),
}


def shifter(idx: int) -&gt; int:
    tmp = 0
    for i in range(idx, 8 + idx):
        tmp |= mapping[i][1] &lt;&lt; i * 8
    return tmp &gt;&gt; idx * 8


def calc(idx: int, al_ebx_w_usr: int, res: List[chr], j: int) -&gt; (List[chr], int):
    val = shifter(idx)
    xor = chr((c_int64(val).value ^ (al_ebx_w_usr &amp; 0xFF)) &amp; 0xFF)
    res.append((idx, xor))
    if xor in ALPHABET:
        j += 1
    return res, j


def decrypt():
    j = 0
    pos_sol = []
    for k in ALPHABET:
        # print(f"Trying {k} as input")
        for i in range(4):
            al = mapping.get(i)[0] &amp; 0xFF
            ebx = mapping.get(0)[0]
            al_ebx = c_int32(al).value - c_int32(ebx).value
            al_ebx_w_usr = al_ebx + ord(k) - 0x20
            for l in [0, 4, 8]:
                pos_sol, j = calc(i + l, al_ebx_w_usr, pos_sol, j)
        if j == 11:
            dec = "".join(x[1] for x in sorted(pos_sol, key=lambda k: k[0]))
            print(f"Possible solution candidate: {k}\n  --&gt; Yields decrypted cipher: {dec}")
            sys.exit()
        j = 0
        pos_sol.clear()


def main():
    decrypt()


if __name__ == "__main__":
    main()

</code></pre>
<p>This script will stop running at the first occurence where all above made assumptions are met. If our scope for a valid decryption was perfectly executed our script should always return the same correct solution.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/9/9/99e42faba1b593cab854bd787c5baeba222109c1.png" data-download-href="/uploads/short-url/lXnWg98ULDIjE6VL0YPl6bdHR3r.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/9/9/99e42faba1b593cab854bd787c5baeba222109c1_2_690x172.png" alt="" data-base62-sha1="lXnWg98ULDIjE6VL0YPl6bdHR3r" width="690" height="172" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/9/9/99e42faba1b593cab854bd787c5baeba222109c1_2_690x172.png, https://0x00sec.s3.amazonaws.com/original/3X/9/9/99e42faba1b593cab854bd787c5baeba222109c1.png 1.5x, https://0x00sec.s3.amazonaws.com/original/3X/9/9/99e42faba1b593cab854bd787c5baeba222109c1.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/3X/9/9/99e42faba1b593cab854bd787c5baeba222109c1_2_10x10.png"></a></div><p></p>
<p>Nice! We seem to have solved this challenge now as the decrypted cipher text looks pretty darn good. Last but not least let’s confirm this solution in the original challege:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/3X/a/f/af5d4a96e204dd2b58a14b6129a9a5217f22a735.png" alt="" data-base62-sha1="p1lqR3a4XTRVf7VdpsCEr5mQaln" width="394" height="304"></p>
<h1>Conclusion</h1>
<p>This small challenge was really fun diving into.‌‌ For people wanting to try out all of this I have a few closing words.‌‌ Just do it! I learned a tad more about the ELF executable format, dd and static analysis in general :).‌‌ Knowledge that I can use and apply for my next binary I want to investigate or reverse engineer!‌‌ So just bring some time and don’t give up easily :).‌‌ Doing this is like puzzling for grown-ups with a much higher frustration but also rewarding factor!</p>
<p>If you have read until here thank you very much and I really hope you enjoyed that little write-up in addition to maybe having learned a thing or two!</p>
          <p><a href="https://0x00sec.org/t/the-devil-entered-the-stage-devils-swapper-write-up/2379/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/the-devil-entered-the-stage-devils-swapper-write-up/2379/1</link>
        <pubDate>Wed, 14 Jun 2017 08:28:07 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-2379-1</guid>
        <source url="https://0x00sec.org/t/the-devil-entered-the-stage-devils-swapper-write-up/2379.rss">The devil entered the stage - Devil&#39;s swapper write-up</source>
      </item>
  </channel>
</rss>
