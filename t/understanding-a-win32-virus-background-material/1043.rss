<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Understanding a Win32 Virus: Background Material</title>
    <link>https://0x00sec.org/t/understanding-a-win32-virus-background-material/1043</link>
    <description>In my previous article, [A Simple Demonstration on Malware Analysis](https://0x00sec.org/t/a-simple-demonstration-on-malware-analysis/994), we dissected an infected program to locate and extract the file infector. To follow up from before, I said that we will be reversing the infector to find out what mechanisms have been included to allow it to perform its task, but instead of going through the raw assembly from what we gathered, we will be looking directly at the source code (which is still assembly) as I&#39;ve yet to learn and recognize a variety of different code constructs and algorithms and I won&#39;t pretend that I know everything. It&#39;s also much easier on the eyes of a beginner due to commenting. Again, the original source code can be found at [Rohitab - [NASM] Simple Win32 Virus](http://www.rohitab.com/discuss/topic/38786-nasm-simple-win32-virus/) and there is also a corresponding tutorial on a majority of its non-viral code at [Rohitab - [Quick tutorial] Finding Kernel32 Base and walking its export table.](http://www.rohitab.com/discuss/topic/38717-quick-tutorial-finding-kernel32-base-and-walking-its-export-table/) but I feel that it&#39;s a bit lacking in detail or that some of the information is a bit confusing so I&#39;ll try to deliver the explanation in a way that I feel is more satisfactory.

### Who Can Benefit From This?

Obviously malware authors or analysts can benefit from the content in this article but also those interested in shellcode and exploit development may find this interesting. Perhaps it may give an insight into how executables and DLLs interact with each other or possibly gain something about the memory or processes within Windows.

Pre-requisites for this material:
```makefile
Knowledge of the WinAPI
Knowledge of the PE file format
Knowledge of Windows memory
Knowledge of Windows processes
Basic knowledge of x86 Intel assembly
```

If you do not have such pre-requisites, I will attempt to explain the content as clearly as possible but if here is any confusion, do not hesitate to leave a question in the comments. I will try to answer them as well as I can (if I can).

**Disclaimer**: The  background content may be long and probably boring (like most theory) but it is necessary in understanding the inner workings of this virus. I can&#39;t force you to read it but it would help a lot if you don&#39;t already know how things work in low level Windows.


----------
## Contents:
```makefile
1. Dynamic Link Libraries and Exported Functions
 (i)   What is a Dynamic Link Library?
 (ii)  Exported Functions Example
 (iii) Export Table
 (iv)  Kernel32.dll
 (v)   Dynamically Loading DLLs
2. The Process Environment Block
 (i)   What is the Process Environment Block?
 (ii)  Motivation
 (iii) Retrieving kernel32 Module&#39;s Base Address
 (iv)  Locating the Export Table
 (v)   Obtaining Exported Functions
```
Feel free to skip ahead if you are already familiar with anything.

## Dynamic Link Libraries and Exported Functions

### What is a Dynamic Link Library?

Dynamic Link Libraries, or DLLs for short, are objects which are described, by [MSDN - What is a DLL?](https://support.microsoft.com/en-au/kb/815065), to &quot;promote modularization of  code, code reuse, efficient memory usage, and reduced disk space. Therefore,  the operating system and the programs load faster, run faster, and take less disk space on the computer.&quot; What this implies is that DLLs provide (usually a (large) collection of) _exported_ functions with which programs can _import_ for use.

Imagine designing a function for a program that you are writing, but instead of having that function in that program, you relocate it to a separate file, a DLL, such that your program _depends_ on the DLL file to provide the functionality to it. For example, an analogy would be moving a program off your computer&#39;s hard drive and then placing it inside an external hard drive. Now when you want to run the program, you will have to _depend_ on your hard drive to provide that program to you, that is, you will need to locate to your hard drive&#39;s storage, find the program and then execute it (while it&#39;s still there). Following this analogy, imported and exported functions basically mean that your computer has the location of where the program is stored and that your hard drive exposes the program to the outside world for usage. Naturally, whenever the program needs to use a function exported by a DLL, it must exist and be loaded into its memory space for it to work, let alone be loaded into memory and executed properly.

### Exported Functions Example

A DLL actually follows the same format as executables, i.e. it has a PE file format, and can also be developed in the same manner. For example, if I wanted to export a function to add two numbers, it can be written like so:
```c
// MyDLL.c

#define DllExport __declspec(dllexport)

DllExport int AddTwoNumbers(int a, int b) {
    return a + b;
}
```
Let&#39;s examine what this DLL&#39;s exported function looks like in PEview.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/e/e79b2117889351f5195c1aa15a467ad9efe7635e.PNG&quot; width=&quot;690&quot; height=&quot;473&quot;&gt;

It looks almost exactly the same as an executable file, with the exception that it has DLL values. What we&#39;re mainly interested here is the export table as highlighted at the bottom. We&#39;ll follow the value in the data column to RVA `0x00002420`, or VA `0x10002420` (RVA + `ImageBase`).

### Export Table

The `IMAGE_EXPORT_DIRECTORY` struct is defined like so:
```c
typedef struct _IMAGE_EXPORT_DIRECTORY {
    DWORD Charcteristics;           // offset 0; size 4
    DWORD TimeDateStamp;            // offset 4; size 4
    WORD MajorVersion;              // offset 8; size 2
    WORD MinorVersion;              // offset 10; size 2
    DWORD Name;                     // offset 12; size 4
    DWORD Base;                     // offset 16; size 4
    DWORD NumberOfFunctions;        // offset 20; size 4
    DWORD NumberOfNames;            // offset 24; size 4
    DWORD AddressOfFunctions;       // offset 28; size 4
    DWORD AddressOfNames;           // offset 32; size 4
    DWORD AddressOfNameOrdinals;    // offset 36; size 4
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;
```
Our DLL&#39;s export table looks like this:

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/8/8813b2c0fee91bb091ad29a1d40d168d9fe238cd.PNG&quot; width=&quot;530&quot; height=&quot;228&quot;&gt;

The highlighted is what we are interested in looking at so let&#39;s start with the first one. The Address Table or the `AddressOfFunctions` member, contains the address of a list of where the exported functions exist in memory. Let&#39;s follow the address and see what we have.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/0/0b1997f1f9e77629b0b018856a5aa8040ddd9882.PNG&quot; width=&quot;449&quot; height=&quot;40&quot;&gt;

So we can see in the Data column that our function `AddTwoNumbers` lies at RVA `0x00001000`, or VA `0x10001000`. Let&#39;s check with OllyDbg.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/b/bbe877b2103bc800b2dc864ecc15210c8c4c0d56.PNG&quot; width=&quot;690&quot; height=&quot;166&quot;&gt;

Our DLL was loaded into the address starting with base `0x6C730000` (left) and now we need to navigate to RVA `0x00001000` or VA `0x6C731000` (right) and we can see our disassembled `AddTwoNumbers` at the top:
```makefile
; AddTwoNumbers function
push    ebp             ; create new function stack
mov     ebp, esp        ; adjust stack pointer
mov     eax, [ebp+8]    ; eax = a (compiled with cdecl)
add     eax, [ebp+C]    ; eax += b
pop     ebp             ; destroy function stack
ret                     ; return a + b (in eax)
```
Let&#39;s now have a look at the `AddressOfNames` member which contains the address of the list of function names at `0x0000244C`:

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/1/120213037f7411e95793619e250d3532d8e039e4.PNG&quot; width=&quot;457&quot; height=&quot;44&quot;&gt;

Just our one function here. Nothing special. And finally, the `AddressOfNameOrdinals` is simply:

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/f/fe17c3122d70e953078c078a5dacfe0bad73e8c7.PNG&quot; width=&quot;452&quot; height=&quot;47&quot;&gt;

...with an ordinal number of `0x0000`. Most of the time, importing functions are done by name but it is possible to import by ordinal number. Note how the ordinal numbers start at 0.

### Kernel32.dll

Now that we know a bit about DLLs using the simple example above, let&#39;s take a quick look at a system DLL. The `kernel32` module is a special DLL, in fact, it&#39;s so special that it is loaded with _every_ executable, even if it has no imported functions from it. Let&#39;s define a bare minimum executable:
```
; empty.asm

global _main

section .text
_main:
    ret
```
And let&#39;s view it in PEview:

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/4/4c05db97f625cf053c29c2e61f20d9c7e6663cba.PNG&quot; width=&quot;690&quot; height=&quot;484&quot;&gt;

So it does have an import table, but let&#39;s check the data inside.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/7/7757e27715cb03e98bf5fa1917f5cf97acd205a6.PNG&quot; width=&quot;667&quot; height=&quot;248&quot;&gt;

Nothing. No data, just an empty table. Let&#39;s now examine its modules in memory with OllyDbg.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/b/b278f92e3017ba485c20dddd14a49c15a0b4276b.PNG&quot; width=&quot;421&quot; height=&quot;430&quot;&gt;

As I&#39;ve previously stated, `kernel32.dll` has been loaded into memory at base address `0x75F40000`. Why is it loaded every time? I actually don&#39;t know... But if you do know, please do share! Anyway, let&#39;s perform the same analysis on this DLL as we did with the previous one. Let&#39;s open PEview again and locate the export table offset.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/b/bbe692d2b52a12b8b59537b1f68403a13419619c.PNG&quot; width=&quot;690&quot; height=&quot;150&quot;&gt;

Export table:

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/e/e3e87ead5c4ec116b2368313fd8ffb2a42190022.PNG&quot; width=&quot;521&quot; height=&quot;223&quot;&gt;

This time, we&#39;re only interested in the `AddressOfNames` and `AddressOfNameOrdinals` members. Here is the list of function names:

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/a/a556be8e1aba39efc598a6e13cd6412f8a1a2c13.PNG&quot; width=&quot;432&quot; height=&quot;500&quot;&gt;

Here is the list of ordinals:

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/8/82c1645e80de7c30c779e6d6c2cc7cee997888b7.PNG&quot; width=&quot;441&quot; height=&quot;500&quot;&gt;

### Dynamically Loading DLLs

Besides having the Windows loader (the applications which load and set up executables in memory) supply the DLLs on execution, a program is able to _dynamically_ load a DLL, i.e. _during_ runtime with a special function called [LoadLibrary](https://msdn.microsoft.com/en-au/library/windows/desktop/ms684175(v=vs.85).aspx). This function takes in a single file name parameter to locate the module to be loaded and mapped into the executable&#39;s address space. Often combined with [GetProcAddress](https://msdn.microsoft.com/en-us/library/windows/desktop/ms683212(v=vs.85).aspx), the program is capable of retrieving functions from the loaded module for use. Both of these functions are provided directly by the `kernel32` module which means that a program can potentially use any function from any DLL whenever it wants to, even if the DLL was not initially mapped by the Windows loader.

Great! You&#39;ve survived a crash course for DLLs and their exported functions! Let&#39;s combine what we&#39;ve learned with the next topic.


----------

## The Process Environment Block

### What is the Process Environment Block?

The [Process Environment Block](https://en.wikipedia.org/wiki/Process_Environment_Block), or PEB for short, is a &quot;data structure that is used by the operating system internally, most of whose fields are not intended for use by anything other than the operating system&quot; and contains information about the process in question. How do we access the PEB? It&#39;s located at `fs:[30h]`. The [PEB struct](https://msdn.microsoft.com/en-us/library/windows/desktop/aa813706(v=vs.85).aspx) is defined by Microsoft as so:
```c
typedef struct _PEB {
    BYTE Reserved[2];      // offset 0; size 2
    BYTE BeingDebugged;    // offset 2; size 1
    BYTE Reserved2[1];     // offset 3; size 1
    PVOID Reserved3[2];    // offset 4; size 8
    PPEB_LDR_DATA Ldr;     // offset 12
    // unnecessary members omitted
} PEB, *PPEB;
```

### Motivation

You may be wondering what this has to do with anything so let me give some motivation. We&#39;ve established that the `kernel32` module is always loaded into every process and because of this, it&#39;s a common feature across _every_ loaded executable. Using the two functions mentioned previously to be able to load any function from any DLL on a system, a malicious piece of code will be able to utilize this method to gain **maximum** power with **minimal dependencies**, that is, it is _purely_ standalone and independent of anything yet it can still access its tools to perform its operation successfully. Through the PEB, the malware will be able to programmatically locate the `kernel32` module to get what it needs. Let&#39;s find out how we can do this.

### Retrieving `kernel32` Module&#39;s Base Address

We&#39;re interested in the `Ldr` member of this struct as it &quot;contains information about the loaded modules for the process.&quot; Let&#39;s follow and examine the `PPEB_LDR_DATA` [struct](https://msdn.microsoft.com/en-us/library/windows/desktop/aa813708(v=vs.85).aspx).
```c
typedef struct _PEB_LDR_DATA {
    BYTE Reserved1[8];                     // offset 0; size 8
    PVOID Reserved2[3];                    // offset 8; size 12
    LIST_ENTRY InMemoryOrderModuleList;    // offset 20
} PEB_LDR_DATA, *PPEB_LDR_DATA;
```
The `InMemoryOrderModuleList` is a struct of a doubly linked list of the modules defined as so:
```cpp
typedef struct _LIST_ENTRY {
    struct _LIST_ENTRY *Flink;    // points to next module
    struct _LIST_ENTRY *Blink;    // points to previous module
} LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;
```
The `kernel32` module is located as the third node (first being the executable itself, second being `ntdll`) in the list so we will have to enumerate `InMemoryOrderModuleList-&gt;Flink` two times. After doing this, we will need to look at one final structure to retrieve the base address of the module: [LDR_DATA_TABLE_ENTRY](https://msdn.microsoft.com/en-us/library/windows/desktop/aa813708(v=vs.85).aspx).
```c
typedef struct _LDR_DATA_TABLE_ENTRY {
    // unnecessary members omitted
    LIST_ENTRY InMemoryOrderLinks;    // offset 0; size 8
    PVOID Reserved2[2];               // offset 8; size 8
    PVOID DllBase;                    // offset 16
    // unnecessary members omitted
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;
```
MSDN states that &quot;each [`InMemoryOrderModuleList`] item in the list is a pointer to an LDR_DATA_TABLE_ENTRY structure&quot; (above). That means to get to the `DllBase` member, we add 16 bytes to the third `InMemoryOrderModuleList-&gt;Flink` item.

### Locating the Export Table

Now that we&#39;ve got the base address, we need to find the export table where all the information on functions are stored. To do so, we&#39;ll need to know where the `IMAGE_NT_HEADERS` structure lives. The first structure of the PE file is the `IMAGE_DOS_HEADER` and is defined as such:
```c
typedef struct _IMAGE_DOS_HEADER {
    WORD e_magic;     // &#39;MZ&#39;
    // unnecessary members omitted
    LONG e_lfanew;    // offset 60; contains offset to IMAGE_NT_HEADERS
} IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;
```
It contains the offset to the IMAGE_NT_HEADERS, AKA the PE header which is where the export table can be found, i.e. at offset 78 bytes from the header. 

### Obtaining Exported Functions

What we can do now is get the offset of the `AddressOfNames`, enumerate it until we get a match with the `LoadLibrary` and `GetProcAddress` strings, retrieve the ordinal number with the `AddressOfNameOrdinals` (since the two tables are exactly the same, the offsets are the same) and with that, we can obtain the function address with the `AddressOfFunctions` by using the ordinal number multiplied by four for the correct offset as the addresses are 4 bytes each. It would go something like this as a C representation:
```c
// get function name offset
int i = 0;
for (i = 0; strcmp(szFunctionName, &quot;GetProcAddress&quot;) != 0; i++) {
    CHAR *szFunctionName = ExportTable.AddressOfNames[i];
}
// get ordinal using i as an offset
// ExportTable.AddressOfNameOrdinals[0] + i*2;
int ordinal = ExportTable.AddressOfNameOrdinals[i];
// get address of function using the ordinal as an offset
// ExportTable.AddressOfFunctions[0] + ordinal*4;
LPVOID FunctionAddress = ExportTable.AddressOfFunctions[ordinal];
```
Once we have `GetProcAddress`, we can find `LoadLibrary` in `kernel32` (without repeating the above process) and then have access to all of the WinAPI functions.

Okay, we&#39;ve covered a fair bit so now we are able to start the main course. I&#39;ve separated the code analysis since it was too much to fit into a single article so join me over in the [next segment](https://0x00sec.org/t/understanding-a-win32-virus-code-analysis/1069).

_-- dtm_</description>
    
    <lastBuildDate>Sun, 04 Sep 2016 10:14:55 +0000</lastBuildDate>
    <category>Malware</category>
    <atom:link href="https://0x00sec.org/t/understanding-a-win32-virus-background-material/1043.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Understanding a Win32 Virus: Background Material</title>
        <dc:creator><![CDATA[dtm]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 30 days. New replies are no longer allowed.</p>
          <p><a href="https://0x00sec.org/t/understanding-a-win32-virus-background-material/1043/8">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/understanding-a-win32-virus-background-material/1043/8</link>
        <pubDate>Sun, 21 Jan 2018 00:42:07 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1043-8</guid>
        <source url="https://0x00sec.org/t/understanding-a-win32-virus-background-material/1043.rss">Understanding a Win32 Virus: Background Material</source>
      </item>
      <item>
        <title>Understanding a Win32 Virus: Background Material</title>
        <dc:creator><![CDATA[dtm]]></dc:creator>
        <description><![CDATA[
            <p>What video???</p>
          <p><a href="https://0x00sec.org/t/understanding-a-win32-virus-background-material/1043/7">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/understanding-a-win32-virus-background-material/1043/7</link>
        <pubDate>Sun, 04 Sep 2016 10:14:55 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1043-7</guid>
        <source url="https://0x00sec.org/t/understanding-a-win32-virus-background-material/1043.rss">Understanding a Win32 Virus: Background Material</source>
      </item>
      <item>
        <title>Understanding a Win32 Virus: Background Material</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>Sure. I’m looking forward to the complete analysis of the virus. <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<p>Update: Sorry about the lapsus.</p>
          <p><a href="https://0x00sec.org/t/understanding-a-win32-virus-background-material/1043/6">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/understanding-a-win32-virus-background-material/1043/6</link>
        <pubDate>Sun, 04 Sep 2016 08:19:26 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1043-6</guid>
        <source url="https://0x00sec.org/t/understanding-a-win32-virus-background-material/1043.rss">Understanding a Win32 Virus: Background Material</source>
      </item>
      <item>
        <title>Understanding a Win32 Virus: Background Material</title>
        <dc:creator><![CDATA[dtm]]></dc:creator>
        <description><![CDATA[
            <p>Thanks. If you’re still interested, I’m not finished yet. Just publishing the additions in case I accidentally lose them again.</p>
          <p><a href="https://0x00sec.org/t/understanding-a-win32-virus-background-material/1043/5">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/understanding-a-win32-virus-background-material/1043/5</link>
        <pubDate>Sun, 04 Sep 2016 04:52:47 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1043-5</guid>
        <source url="https://0x00sec.org/t/understanding-a-win32-virus-background-material/1043.rss">Understanding a Win32 Virus: Background Material</source>
      </item>
      <item>
        <title>Understanding a Win32 Virus: Background Material</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>Great post mate… I almost missed the last part. Just realized you updated it but chance.</p>
<p>Congrats!</p>
          <p><a href="https://0x00sec.org/t/understanding-a-win32-virus-background-material/1043/4">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/understanding-a-win32-virus-background-material/1043/4</link>
        <pubDate>Sat, 03 Sep 2016 19:23:42 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1043-4</guid>
        <source url="https://0x00sec.org/t/understanding-a-win32-virus-background-material/1043.rss">Understanding a Win32 Virus: Background Material</source>
      </item>
      <item>
        <title>Understanding a Win32 Virus: Background Material</title>
        <dc:creator><![CDATA[root_haxor]]></dc:creator>
        <description><![CDATA[
            <p>Make Video it will be easy to learn</p>
          <p><a href="https://0x00sec.org/t/understanding-a-win32-virus-background-material/1043/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/understanding-a-win32-virus-background-material/1043/3</link>
        <pubDate>Sat, 03 Sep 2016 18:34:01 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1043-3</guid>
        <source url="https://0x00sec.org/t/understanding-a-win32-virus-background-material/1043.rss">Understanding a Win32 Virus: Background Material</source>
      </item>
      <item>
        <title>Understanding a Win32 Virus: Background Material</title>
        <dc:creator><![CDATA[spylegion]]></dc:creator>
        <description><![CDATA[
            <p>Great thread buddy, keep it up <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
          <p><a href="https://0x00sec.org/t/understanding-a-win32-virus-background-material/1043/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/understanding-a-win32-virus-background-material/1043/2</link>
        <pubDate>Sat, 03 Sep 2016 18:26:03 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1043-2</guid>
        <source url="https://0x00sec.org/t/understanding-a-win32-virus-background-material/1043.rss">Understanding a Win32 Virus: Background Material</source>
      </item>
      <item>
        <title>Understanding a Win32 Virus: Background Material</title>
        <dc:creator><![CDATA[dtm]]></dc:creator>
        <description><![CDATA[
            <p>In my previous article, <a href="https://0x00sec.org/t/a-simple-demonstration-on-malware-analysis/994">A Simple Demonstration on Malware Analysis</a>, we dissected an infected program to locate and extract the file infector. To follow up from before, I said that we will be reversing the infector to find out what mechanisms have been included to allow it to perform its task, but instead of going through the raw assembly from what we gathered, we will be looking directly at the source code (which is still assembly) as I’ve yet to learn and recognize a variety of different code constructs and algorithms and I won’t pretend that I know everything. It’s also much easier on the eyes of a beginner due to commenting. Again, the original source code can be found at <a href="http://www.rohitab.com/discuss/topic/38786-nasm-simple-win32-virus/">Rohitab - [NASM] Simple Win32 Virus</a> and there is also a corresponding tutorial on a majority of its non-viral code at <a href="http://www.rohitab.com/discuss/topic/38717-quick-tutorial-finding-kernel32-base-and-walking-its-export-table/">Rohitab - [Quick tutorial] Finding Kernel32 Base and walking its export table.</a> but I feel that it’s a bit lacking in detail or that some of the information is a bit confusing so I’ll try to deliver the explanation in a way that I feel is more satisfactory.</p>
<h3>Who Can Benefit From This?</h3>
<p>Obviously malware authors or analysts can benefit from the content in this article but also those interested in shellcode and exploit development may find this interesting. Perhaps it may give an insight into how executables and DLLs interact with each other or possibly gain something about the memory or processes within Windows.</p>
<p>Pre-requisites for this material:</p>
<pre><code class="lang-makefile">Knowledge of the WinAPI
Knowledge of the PE file format
Knowledge of Windows memory
Knowledge of Windows processes
Basic knowledge of x86 Intel assembly
</code></pre>
<p>If you do not have such pre-requisites, I will attempt to explain the content as clearly as possible but if here is any confusion, do not hesitate to leave a question in the comments. I will try to answer them as well as I can (if I can).</p>
<p><strong>Disclaimer</strong>: The  background content may be long and probably boring (like most theory) but it is necessary in understanding the inner workings of this virus. I can’t force you to read it but it would help a lot if you don’t already know how things work in low level Windows.</p>
<hr>
<h2>Contents:</h2>
<pre><code class="lang-makefile">1. Dynamic Link Libraries and Exported Functions
 (i)   What is a Dynamic Link Library?
 (ii)  Exported Functions Example
 (iii) Export Table
 (iv)  Kernel32.dll
 (v)   Dynamically Loading DLLs
2. The Process Environment Block
 (i)   What is the Process Environment Block?
 (ii)  Motivation
 (iii) Retrieving kernel32 Module's Base Address
 (iv)  Locating the Export Table
 (v)   Obtaining Exported Functions
</code></pre>
<p>Feel free to skip ahead if you are already familiar with anything.</p>
<h2>Dynamic Link Libraries and Exported Functions</h2>
<h3>What is a Dynamic Link Library?</h3>
<p>Dynamic Link Libraries, or DLLs for short, are objects which are described, by <a href="https://support.microsoft.com/en-au/kb/815065">MSDN - What is a DLL?</a>, to “promote modularization of  code, code reuse, efficient memory usage, and reduced disk space. Therefore,  the operating system and the programs load faster, run faster, and take less disk space on the computer.” What this implies is that DLLs provide (usually a (large) collection of) <em>exported</em> functions with which programs can <em>import</em> for use.</p>
<p>Imagine designing a function for a program that you are writing, but instead of having that function in that program, you relocate it to a separate file, a DLL, such that your program <em>depends</em> on the DLL file to provide the functionality to it. For example, an analogy would be moving a program off your computer’s hard drive and then placing it inside an external hard drive. Now when you want to run the program, you will have to <em>depend</em> on your hard drive to provide that program to you, that is, you will need to locate to your hard drive’s storage, find the program and then execute it (while it’s still there). Following this analogy, imported and exported functions basically mean that your computer has the location of where the program is stored and that your hard drive exposes the program to the outside world for usage. Naturally, whenever the program needs to use a function exported by a DLL, it must exist and be loaded into its memory space for it to work, let alone be loaded into memory and executed properly.</p>
<h3>Exported Functions Example</h3>
<p>A DLL actually follows the same format as executables, i.e. it has a PE file format, and can also be developed in the same manner. For example, if I wanted to export a function to add two numbers, it can be written like so:</p>
<pre><code class="lang-auto">// MyDLL.c

#define DllExport __declspec(dllexport)

DllExport int AddTwoNumbers(int a, int b) {
    return a + b;
}
</code></pre>
<p>Let’s examine what this DLL’s exported function looks like in PEview.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/e/e79b2117889351f5195c1aa15a467ad9efe7635e.PNG" width="690" height="473"></p>
<p>It looks almost exactly the same as an executable file, with the exception that it has DLL values. What we’re mainly interested here is the export table as highlighted at the bottom. We’ll follow the value in the data column to RVA <code>0x00002420</code>, or VA <code>0x10002420</code> (RVA + <code>ImageBase</code>).</p>
<h3>Export Table</h3>
<p>The <code>IMAGE_EXPORT_DIRECTORY</code> struct is defined like so:</p>
<pre><code class="lang-auto">typedef struct _IMAGE_EXPORT_DIRECTORY {
    DWORD Charcteristics;           // offset 0; size 4
    DWORD TimeDateStamp;            // offset 4; size 4
    WORD MajorVersion;              // offset 8; size 2
    WORD MinorVersion;              // offset 10; size 2
    DWORD Name;                     // offset 12; size 4
    DWORD Base;                     // offset 16; size 4
    DWORD NumberOfFunctions;        // offset 20; size 4
    DWORD NumberOfNames;            // offset 24; size 4
    DWORD AddressOfFunctions;       // offset 28; size 4
    DWORD AddressOfNames;           // offset 32; size 4
    DWORD AddressOfNameOrdinals;    // offset 36; size 4
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;
</code></pre>
<p>Our DLL’s export table looks like this:</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/8/8813b2c0fee91bb091ad29a1d40d168d9fe238cd.PNG" width="530" height="228"></p>
<p>The highlighted is what we are interested in looking at so let’s start with the first one. The Address Table or the <code>AddressOfFunctions</code> member, contains the address of a list of where the exported functions exist in memory. Let’s follow the address and see what we have.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/0/0b1997f1f9e77629b0b018856a5aa8040ddd9882.PNG" width="449" height="40"></p>
<p>So we can see in the Data column that our function <code>AddTwoNumbers</code> lies at RVA <code>0x00001000</code>, or VA <code>0x10001000</code>. Let’s check with OllyDbg.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/b/bbe877b2103bc800b2dc864ecc15210c8c4c0d56.PNG" width="690" height="166"></p>
<p>Our DLL was loaded into the address starting with base <code>0x6C730000</code> (left) and now we need to navigate to RVA <code>0x00001000</code> or VA <code>0x6C731000</code> (right) and we can see our disassembled <code>AddTwoNumbers</code> at the top:</p>
<pre><code class="lang-makefile">; AddTwoNumbers function
push    ebp             ; create new function stack
mov     ebp, esp        ; adjust stack pointer
mov     eax, [ebp+8]    ; eax = a (compiled with cdecl)
add     eax, [ebp+C]    ; eax += b
pop     ebp             ; destroy function stack
ret                     ; return a + b (in eax)
</code></pre>
<p>Let’s now have a look at the <code>AddressOfNames</code> member which contains the address of the list of function names at <code>0x0000244C</code>:</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/1/120213037f7411e95793619e250d3532d8e039e4.PNG" width="457" height="44"></p>
<p>Just our one function here. Nothing special. And finally, the <code>AddressOfNameOrdinals</code> is simply:</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/f/fe17c3122d70e953078c078a5dacfe0bad73e8c7.PNG" width="452" height="47"></p>
<p>…with an ordinal number of <code>0x0000</code>. Most of the time, importing functions are done by name but it is possible to import by ordinal number. Note how the ordinal numbers start at 0.</p>
<h3>Kernel32.dll</h3>
<p>Now that we know a bit about DLLs using the simple example above, let’s take a quick look at a system DLL. The <code>kernel32</code> module is a special DLL, in fact, it’s so special that it is loaded with <em>every</em> executable, even if it has no imported functions from it. Let’s define a bare minimum executable:</p>
<pre><code class="lang-auto">; empty.asm

global _main

section .text
_main:
    ret
</code></pre>
<p>And let’s view it in PEview:</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/4/4c05db97f625cf053c29c2e61f20d9c7e6663cba.PNG" width="690" height="484"></p>
<p>So it does have an import table, but let’s check the data inside.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/7/7757e27715cb03e98bf5fa1917f5cf97acd205a6.PNG" width="667" height="248"></p>
<p>Nothing. No data, just an empty table. Let’s now examine its modules in memory with OllyDbg.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/b/b278f92e3017ba485c20dddd14a49c15a0b4276b.PNG" width="421" height="430"></p>
<p>As I’ve previously stated, <code>kernel32.dll</code> has been loaded into memory at base address <code>0x75F40000</code>. Why is it loaded every time? I actually don’t know… But if you do know, please do share! Anyway, let’s perform the same analysis on this DLL as we did with the previous one. Let’s open PEview again and locate the export table offset.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/b/bbe692d2b52a12b8b59537b1f68403a13419619c.PNG" width="690" height="150"></p>
<p>Export table:</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/e/e3e87ead5c4ec116b2368313fd8ffb2a42190022.PNG" width="521" height="223"></p>
<p>This time, we’re only interested in the <code>AddressOfNames</code> and <code>AddressOfNameOrdinals</code> members. Here is the list of function names:</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/a/a556be8e1aba39efc598a6e13cd6412f8a1a2c13.PNG" width="432" height="500"></p>
<p>Here is the list of ordinals:</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/8/82c1645e80de7c30c779e6d6c2cc7cee997888b7.PNG" width="441" height="500"></p>
<h3>Dynamically Loading DLLs</h3>
<p>Besides having the Windows loader (the applications which load and set up executables in memory) supply the DLLs on execution, a program is able to <em>dynamically</em> load a DLL, i.e. <em>during</em> runtime with a special function called <a href="https://msdn.microsoft.com/en-au/library/windows/desktop/ms684175(v=vs.85).aspx">LoadLibrary</a>. This function takes in a single file name parameter to locate the module to be loaded and mapped into the executable’s address space. Often combined with <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms683212(v=vs.85).aspx">GetProcAddress</a>, the program is capable of retrieving functions from the loaded module for use. Both of these functions are provided directly by the <code>kernel32</code> module which means that a program can potentially use any function from any DLL whenever it wants to, even if the DLL was not initially mapped by the Windows loader.</p>
<p>Great! You’ve survived a crash course for DLLs and their exported functions! Let’s combine what we’ve learned with the next topic.</p>
<hr>
<h2>The Process Environment Block</h2>
<h3>What is the Process Environment Block?</h3>
<p>The <a href="https://en.wikipedia.org/wiki/Process_Environment_Block">Process Environment Block</a>, or PEB for short, is a “data structure that is used by the operating system internally, most of whose fields are not intended for use by anything other than the operating system” and contains information about the process in question. How do we access the PEB? It’s located at <code>fs:[30h]</code>. The <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa813706(v=vs.85).aspx">PEB struct</a> is defined by Microsoft as so:</p>
<pre><code class="lang-auto">typedef struct _PEB {
    BYTE Reserved[2];      // offset 0; size 2
    BYTE BeingDebugged;    // offset 2; size 1
    BYTE Reserved2[1];     // offset 3; size 1
    PVOID Reserved3[2];    // offset 4; size 8
    PPEB_LDR_DATA Ldr;     // offset 12
    // unnecessary members omitted
} PEB, *PPEB;
</code></pre>
<h3>Motivation</h3>
<p>You may be wondering what this has to do with anything so let me give some motivation. We’ve established that the <code>kernel32</code> module is always loaded into every process and because of this, it’s a common feature across <em>every</em> loaded executable. Using the two functions mentioned previously to be able to load any function from any DLL on a system, a malicious piece of code will be able to utilize this method to gain <strong>maximum</strong> power with <strong>minimal dependencies</strong>, that is, it is <em>purely</em> standalone and independent of anything yet it can still access its tools to perform its operation successfully. Through the PEB, the malware will be able to programmatically locate the <code>kernel32</code> module to get what it needs. Let’s find out how we can do this.</p>
<h3>Retrieving <code>kernel32</code> Module’s Base Address</h3>
<p>We’re interested in the <code>Ldr</code> member of this struct as it “contains information about the loaded modules for the process.” Let’s follow and examine the <code>PPEB_LDR_DATA</code> <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa813708(v=vs.85).aspx">struct</a>.</p>
<pre><code class="lang-auto">typedef struct _PEB_LDR_DATA {
    BYTE Reserved1[8];                     // offset 0; size 8
    PVOID Reserved2[3];                    // offset 8; size 12
    LIST_ENTRY InMemoryOrderModuleList;    // offset 20
} PEB_LDR_DATA, *PPEB_LDR_DATA;
</code></pre>
<p>The <code>InMemoryOrderModuleList</code> is a struct of a doubly linked list of the modules defined as so:</p>
<pre><code class="lang-cpp">typedef struct _LIST_ENTRY {
    struct _LIST_ENTRY *Flink;    // points to next module
    struct _LIST_ENTRY *Blink;    // points to previous module
} LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;
</code></pre>
<p>The <code>kernel32</code> module is located as the third node (first being the executable itself, second being <code>ntdll</code>) in the list so we will have to enumerate <code>InMemoryOrderModuleList-&gt;Flink</code> two times. After doing this, we will need to look at one final structure to retrieve the base address of the module: <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa813708(v=vs.85).aspx">LDR_DATA_TABLE_ENTRY</a>.</p>
<pre><code class="lang-auto">typedef struct _LDR_DATA_TABLE_ENTRY {
    // unnecessary members omitted
    LIST_ENTRY InMemoryOrderLinks;    // offset 0; size 8
    PVOID Reserved2[2];               // offset 8; size 8
    PVOID DllBase;                    // offset 16
    // unnecessary members omitted
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;
</code></pre>
<p>MSDN states that “each [<code>InMemoryOrderModuleList</code>] item in the list is a pointer to an LDR_DATA_TABLE_ENTRY structure” (above). That means to get to the <code>DllBase</code> member, we add 16 bytes to the third <code>InMemoryOrderModuleList-&gt;Flink</code> item.</p>
<h3>Locating the Export Table</h3>
<p>Now that we’ve got the base address, we need to find the export table where all the information on functions are stored. To do so, we’ll need to know where the <code>IMAGE_NT_HEADERS</code> structure lives. The first structure of the PE file is the <code>IMAGE_DOS_HEADER</code> and is defined as such:</p>
<pre><code class="lang-auto">typedef struct _IMAGE_DOS_HEADER {
    WORD e_magic;     // 'MZ'
    // unnecessary members omitted
    LONG e_lfanew;    // offset 60; contains offset to IMAGE_NT_HEADERS
} IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;
</code></pre>
<p>It contains the offset to the IMAGE_NT_HEADERS, AKA the PE header which is where the export table can be found, i.e. at offset 78 bytes from the header.</p>
<h3>Obtaining Exported Functions</h3>
<p>What we can do now is get the offset of the <code>AddressOfNames</code>, enumerate it until we get a match with the <code>LoadLibrary</code> and <code>GetProcAddress</code> strings, retrieve the ordinal number with the <code>AddressOfNameOrdinals</code> (since the two tables are exactly the same, the offsets are the same) and with that, we can obtain the function address with the <code>AddressOfFunctions</code> by using the ordinal number multiplied by four for the correct offset as the addresses are 4 bytes each. It would go something like this as a C representation:</p>
<pre><code class="lang-auto">// get function name offset
int i = 0;
for (i = 0; strcmp(szFunctionName, "GetProcAddress") != 0; i++) {
    CHAR *szFunctionName = ExportTable.AddressOfNames[i];
}
// get ordinal using i as an offset
// ExportTable.AddressOfNameOrdinals[0] + i*2;
int ordinal = ExportTable.AddressOfNameOrdinals[i];
// get address of function using the ordinal as an offset
// ExportTable.AddressOfFunctions[0] + ordinal*4;
LPVOID FunctionAddress = ExportTable.AddressOfFunctions[ordinal];
</code></pre>
<p>Once we have <code>GetProcAddress</code>, we can find <code>LoadLibrary</code> in <code>kernel32</code> (without repeating the above process) and then have access to all of the WinAPI functions.</p>
<p>Okay, we’ve covered a fair bit so now we are able to start the main course. I’ve separated the code analysis since it was too much to fit into a single article so join me over in the <a href="https://0x00sec.org/t/understanding-a-win32-virus-code-analysis/1069">next segment</a>.</p>
<p><em>– dtm</em></p>
          <p><a href="https://0x00sec.org/t/understanding-a-win32-virus-background-material/1043/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/understanding-a-win32-virus-background-material/1043/1</link>
        <pubDate>Sat, 03 Sep 2016 04:10:17 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1043-1</guid>
        <source url="https://0x00sec.org/t/understanding-a-win32-virus-background-material/1043.rss">Understanding a Win32 Virus: Background Material</source>
      </item>
  </channel>
</rss>
