<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Game Hacking: Hack, Slash, Loot</title>
    <link>https://0x00sec.org/t/game-hacking-hack-slash-loot/3711</link>
    <description>So recently I&#39;ve been re-motivated to do some more game hacking and I thought that I&#39;d do another article to introduce more aspects on top of what I&#39;ve already shown from my previous ones. In the following document, I&#39;ll be detailing the usage of DLL injection and its advantages, a fundamental concept of how games may store specific data and how to identify them. Along the way, I will be talking about the ASLR environment and how to adapt code to such scenarios. Finally, I will be discussing how to code a [trainer](https://en.wikipedia.org/wiki/Trainer_(games)) in the form of a DLL.

The game that we will be using to demonstrate these ideas is _[Hack, Slash, Loot](http://www.hackslashloot.com/)_ which has a demo version that you can download if you wish to follow along. 

#### Author Assigned Level: Newbie

#### Community Assigned Level:
[poll type=regular]
* Newbie
* Wannabe
* Hacker
* Wizard
* Guru
[/poll]

#### Assumed Knowledge

* Windows API
* C++
* x86 Intel Assembly
* Basic Cheat Engine usage
* Virtual memory
* DLL injection
* Data Execution Prevention (DEP)
 
#### Expected Outcomes

* Understand the advantages of using DLL injection over external process data manipulation
* Understand the basic concept of data structures in games
* Learn how to adapt code in an ASLR environment
* Learn how to modify assembly inline
* Learn how to program a basic trainer in C++


#### Disclaimer
This information is based on the information that I have researched myself and is therefore subject to the possibility of providing incorrect data. If such incorrect data exists, please notify me and I will fix it when I am available.

-----
# DLL Injection

I&#39;ve covered DLL injection in previous articles but just for completeness, I will give a brief overview of it. DLL injection is simply the act of forcing a process to load a DLL. There are many different ways to perform this but the most common and easiest method is to call `LoadLibrary` from within the target process and passing the full path of the DLL as a parameter. Here is some sample code that represents the procedure.

```cpp
    // Get size of the full DLL path
	DWORD dwDllPathLen = strlen(lpszDllPath);
    // Allocate space for the DLL string
	LPVOID lpDllPathString = VirtualAllocEx(hProcess, NULL, dwDllPathLen, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    // Write the DLL string into the allocated space
	SIZE_T dwWritten = 0;
	WriteProcessMemory(hProcess, lpBaseAddress, lpszDllPath, dwDllPathLen, &amp;dwWritten);
    // Get handle to the module which has LoadLibrary
	HMODULE hModule = GetModuleHandle(&quot;kernel32.dll&quot;);
    // Get address of LoadLibrary
	LPVOID lpLoadLibrary = GetProcAddress(hModule, &quot;LoadLibraryA&quot;);
    // Execute LoadLibrary with the DLL string as the parameter
	CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)lpLoadLibrary, lpDllPathString, 0, NULL);
```

Space will first be allocated for the _full_ path of the DLL in the target process as a parameter for `LoadLibrary`. Once space has been allocated, the path string will be written using `WriteProcessMemory`. The `LoadLibrary` address will be retrieved using `GetModuleHandle` with the `kernel32.dll` parameter and `GetProcAddress`. Now that we have `LoadLibrary` and the DLL path string, we simply execute a thread in the target process at `LoadLibrary` using `CreateRemoteThread`, passing the DLL path string as a parameter.

In summary, we are forcing the target process to execute 

```cpp
    LoadLibrary(&quot;DLL&#39;s full path string&quot;);
```

### DLL Injection vs External Process Data Manipulation

So just some motivation, we want to be able to modify data within a process to be able to force it to do what we want. This can be done in two ways, the first I call _external process data manipulation_, I&#39;ve already covered in previous game hacking articles. Essentially, it uses the `ReadProcessMemory` and `WriteProcessMemory` functions to query and change data given a specified process handle. But constantly calling these functions is a bit awkward and wouldn&#39;t it be a bit better if we could just modify it by simply assigning it like a normal variable, i.e. `player.health = 9999`?

DLL injection offers the solution to this problem. In the context of an injected DLL, the target process&#39;s data in memory is treated like normal meaning that we can read and write data by reading an address and then assigning it a value using the assignment operator.

```cpp
   int *health = (int *)ADDR_HEALTH_VALUE;
   *health = 9999;
```

So obviously, it is more favourable to be in this situation purely due to its simplicity.


----------

# Finding Values

Since basic use of Cheat Engine is assumed knowledge, we will skip the setup and dive straight into scanning for values of interest. So boot up the game and CE and let&#39;s first find the address of the health. Here I&#39;ve found mine and have modified it to confirm that it&#39;s correct.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/1/16ea1261a05917f93767f2a6fee6f36e7110aa8b.JPG&quot; width=&quot;690&quot; height=&quot;435&quot;&gt;

Cool. So I can change my health to whatever I want but that&#39;s easy and not very exciting. Let&#39;s go a bit further and identify the underlying assembly which changes our health value by right-clicking the address and then selecting `Find out what writes to this address`. It will ask if you want to attach a debugger so just confirm that you want to and then it will open up a window. Simply trigger your health value so that CE can detect the instruction(s). When it shows up, select it and click `Show disassembler` on the right.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/9/92c6748727c5c88931d12027b3119ae7d5caf34c.JPG&quot; width=&quot;690&quot; height=&quot;365&quot;&gt;

### Identifying Data Structures

Immediately we can deduce that the `sub` instruction is where the program decreases our health value where `eax` holds the value of the amount and directly after it, there is a `cmp` instruction with 0 which is very likely where it checks if we are dead. Note down the address of the `sub` instruction as we will be using it later in our trainer. What&#39;s interesting to note is that the health value is obtained with an offset from `ebx` because that is exactly what it would look like if it was referencing some sort of data structure like an array or a struct. To examine what `ebx` is, let&#39;s place a breakpoint (F5) and then re-trigger our health.

As the breakpoint is hit, it will show us the value of `ebx`. Let&#39;s use CE to examine this data structure by going to the `Tools` menu of the disassembler, then selecting `Dissect data/structures`. Plug in the value of `ebx` in the edit box labelled `Group 1` then go to the `Structures` menu and select `Define new structure`. Leave everything as default and let CE do all the heavy lifting and it will present a list of values at different offsets.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/4/415ca1399dfc8c5b619bbdb355d4dc150b2520dc.JPG&quot; width=&quot;690&quot; height=&quot;373&quot;&gt;

Notice that at offset 50, we can see our health. But what are all these other values? Let&#39;s head back to the game and see if we can find out. Actually, there is a sort of _slight_ matching of values.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/0/07a0adf92bf32dae070fba38b5fcb3454de85af0.JPG&quot; width=&quot;603&quot; height=&quot;500&quot;&gt;

Let&#39;s confirm it by modifying the values in the struct and see if it is reflected in the game...

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/8/8f0e28cf85a433ca42e57a071634501a51929b94.JPG&quot; width=&quot;597&quot; height=&quot;500&quot;&gt;

Neat stuff! We can spend hours trying to decipher the structure members but I will leave that up to you if you wish to do it.

The final task that we need to do before moving onto coding the trainer is to know where we can find the address of the player struct. Luckily, this is easy for us to do. Return back to the main CE window and scan for the address of the player struct (make sure the hex checkbox is ticked) and we will be given an address in green text. This means that this is a _static_ address and will never change.

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/5/5dbbea0b95357605824c4bd9a76d852713a34f68.JPG&quot; width=&quot;609&quot; height=&quot;500&quot;&gt;

----------

# Programming a Trainer

### Dealing with ASLR

Before we start coding the trainer, I&#39;d like to bring up the concept of [Address Space Layout Randomisation](https://en.wikipedia.org/wiki/Address_space_layout_randomization) (ASLR). ASLR is a technique used by the operating system as a security measure to counteract exploitation methods like buffer overflows. The idea is to have the process&#39;s addresses randomised so that it would be impossible to tell where certain data existed. 

What&#39;s relevant to game hacking is the randomisation of the process&#39;s base address and it needs to be understood so that it&#39;s possible to adapt our code to such a volatile environment. Do not worry, the solution is pretty simple, at least for what we are doing. All we need is the _offset_ of a certain address and then dynamically calculate the address in accordance to the base address. How do we get the offset of a target address? Simply subtract the base address of the process from it: `offset = targetAddress - baseAddress`. How do we dynamically calculate the new address in an ASLR&#39;d process? `targetAddress = getBaseAddress() + offset`. Easy!

We can see here that the process was loaded at address `0x400000` which means that we can calculate the offsets of certain addresses of interests, namely the address which has the instruction to subtract our health (`0x547D6E`) and the address which holds the address of the player struct (`0xBA6140`).

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/7/7810095b62001fc87805fd980b9bd0dd55027e5c.JPG&quot; width=&quot;690&quot; height=&quot;439&quot;&gt;

### Programming the Trainer

We&#39;ll start off by creating a `Trainer` class where we will define the player struct and the methods we want. I&#39;ve already gone ahead and deciphered some other members of the struct.

**Trainer.h**

```cpp
#ifndef __TRAINER_H__
#define __TRAINER_H__

#define ADDR_OFFSET_PLAYER_STRUCT 0x7A6140
#define ADDR_OFFSET_SUBTRACT_HEALTH 0x147D6E

typedef struct _player {
	void *unknown1;
	int unknown2;
	void *unknown3;
	void *unknown4;
	int unknown5;
	int unknown6;
	int unknown7;
	int unknown8;
	int unknown9;
	void *unknown10;
	int unknown11;
	unsigned int faceDirection;	// 1 (right) or 0xFFFFFFFF (left)
	int unknown12;
	int baseMeleeAttack;	// accuracy
	int baseRangedAttack;
	int baseMagicAttack;
	int baseArmour;
	int baseMeleeDamage;
	int baseRangedDamage;
	int baseMagicDamage;
	int health;
	int resistance;
	int vulnerability;
	int unknown14;
} player;

class Trainer {
	private:
	unsigned int baseAddress;
	player *p;
	bool isGodmode;
	static Trainer *t_instance;    // Singleton; ignore

	Trainer();
	~Trainer();
	Trainer(Trainer&amp; other) {}    // Singleton; ignore
	Trainer&amp; operator=(Trainer&amp; other) {}    // Singleton; ignore

	public:
	static const int MELEE = 0;
	static const int RANGED = 1;
	static const int MAGIC = 2;
	static Trainer *instance();    // Singleton; ignore
	void Reset();
	void ModifyHealth(int health);
	void EnableGodmode(bool enable);
	void ModifyArmour(int armour);
	void ModifyAttack(int type, int attack);
	void ModifyDamage(int type, int damage);
	bool IsGodmode();
};

#endif // !__TRAINER_H__
```

I&#39;ve defined this class as a _Singleton_ meaning that it will only allow a single instance of this player class to exist at any given time since this is a single-player game. This is an optional trait so ignore this if it complicates things.

When defining the player struct, it is important that we replicate the members exactly in terms of order and data type however, it is possible to truncate it if we do not know any other further details. At the top, I&#39;ve defined some offset values for the location of the player struct and the instruction that subtracts health. Do you understand how I calculated those values?

Let&#39;s now define the methods.

```cpp
#include &lt;Windows.h&gt;

#include &quot;Trainer.h&quot;

// initialise trainer instance
Trainer *Trainer::t_instance = 0;    // Singleton; ignore

/*
 * Initialise the base address and obtain the 
 * address of the player struct. Default disable
 * godmode.
 *
 * Note that we must start a new game before 
 * applying any h4x otherwise the address will
 * not contain a valid player struct.
 */
Trainer::Trainer() {
	// player struct at 00BA6140
	this-&gt;baseAddress = reinterpret_cast&lt;unsigned int&gt;(::GetModuleHandle(TEXT(&quot;HackSlashLoot.exe&quot;)));
	this-&gt;p = reinterpret_cast&lt;player *&gt;(*reinterpret_cast&lt;unsigned int *&gt;(this-&gt;baseAddress + ADDR_OFFSET_PLAYER_STRUCT));
	this-&gt;isGodmode = false;
}

Trainer::~Trainer() {
}

/*
 * Return the existing instance of the Trainer
 */
Trainer * Trainer::instance() {
	if (!t_instance)
		t_instance = new Trainer();
	return t_instance;
}

/*
 * In case we retrieve the player struct 
 * before starting a new game.
 */
void Trainer::Reset() {
	this-&gt;p = reinterpret_cast&lt;player *&gt;(*reinterpret_cast&lt;unsigned int *&gt;(this-&gt;baseAddress + ADDR_OFFSET_PLAYER_STRUCT));
}

/*
 * Change the health of the player.
 * Param : new health
 */
void Trainer::ModifyHealth(int health) {
	this-&gt;p-&gt;health = health;
}

/*
 * Change the player&#39;s base armour.
 * Param : new armour
 */
void Trainer::ModifyArmour(int armour) {
	this-&gt;p-&gt;baseArmour = armour;
}

/*
 * Change the attack (accuracy) value.
 * Param : type of attack
 * Param : new attack value
 */
void Trainer::ModifyAttack(int type, int attack) {
	if (type == Trainer::MELEE)
		this-&gt;p-&gt;baseMeleeAttack = attack;
	else if (type == Trainer::RANGED)
		this-&gt;p-&gt;baseRangedAttack = attack;
	else if (type == Trainer::MAGIC)
		this-&gt;p-&gt;baseMagicAttack = attack;
}

/*
* Change the damage value.
* Param : type of damage
* Param : new damage value
*/
void Trainer::ModifyDamage(int type, int damage) {
	if (type == Trainer::MELEE)
		this-&gt;p-&gt;baseMeleeDamage = damage;
	else if (type == Trainer::RANGED)
		this-&gt;p-&gt;baseRangedDamage = damage;
	else if (type == Trainer::MAGIC)
		this-&gt;p-&gt;baseMagicDamage = damage;
}

/*
 * Enables or disables godmode.
 * Param : true to enable, false to disable
 */
void Trainer::EnableGodmode(bool enable) {
	this-&gt;isGodmode = enable;
	void *takeDamageAddr = reinterpret_cast&lt;void *&gt;(this-&gt;baseAddress + ADDR_OFFSET_SUBTRACT_HEALTH);
	DWORD flOldProtect = 0;
	::VirtualProtect(takeDamageAddr, 3, PAGE_EXECUTE_READWRITE, &amp;flOldProtect);
	if (this-&gt;isGodmode) {
		*reinterpret_cast&lt;unsigned char *&gt;(takeDamageAddr) = 0x90;
		*(reinterpret_cast&lt;unsigned char *&gt;(takeDamageAddr) + 1) = 0x90;
		*(reinterpret_cast&lt;unsigned char *&gt;(takeDamageAddr) + 2) = 0x90;
	} else {
		*reinterpret_cast&lt;unsigned char *&gt;(takeDamageAddr) = 0x29;
		*(reinterpret_cast&lt;unsigned char *&gt;(takeDamageAddr) + 1) = 0x43;
		*(reinterpret_cast&lt;unsigned char *&gt;(takeDamageAddr) + 2) = 0x50;
	}
	::VirtualProtect(takeDamageAddr, 3, flOldProtect, &amp;flOldProtect);
}

/*
 * Returns true if godmode is enabled, otherwise false.
 */
bool Trainer::IsGodmode() {
	return this-&gt;isGodmode;
}
```

Most of these methods are self-explanatory and you can see that they modify values using the assignment operator because the DLL will be under the same context as the game&#39;s process.

The first important thing I want to cover is the `baseAddress` field which is initialised in `Trainer`&#39;s constructor. Using `GetModuleHandle` with the string of the process&#39;s executable module, we can dynamically retrieve the base address which we can then use to dynamically calculate specific addresses. Directly underneath, the line of code utilises the `baseAddress` field is to calculate the address that stores the player struct.

The second important thing is the `EnableGodmode` method. Note how I&#39;ve used `VirtualProtect` to allow write access of the address where the instruction to subtract health exists. This is due to DEP which I&#39;ve covered previously. To apply godmode, we can just `nop` the subtraction and then we can restore the original bytes to disable it.

### Coding the DLL

The DLL is not much different than coding a standard executable. Instead of using `main` or `WinMain`, we use the `DllMain` entry point.

```cpp
BOOL APIENTRY DllMain(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved) {
	switch (fdwReason) {
		case DLL_PROCESS_ATTACH:
			::CreateThread(NULL, 0, reinterpret_cast&lt;LPTHREAD_START_ROUTINE&gt;(StartInterface), reinterpret_cast&lt;LPVOID&gt;(hInstDll), 0, NULL);
			break;
	}

	return TRUE;
}
```

The only major difference here is the `fdwReason` parameter which defines the circumstances under which the entry point is called. There are four of them but we will only focus on when the DLL is initially attached to the target process, AKA `DLL_PROCESS_ATTACH`. Once the DLL has been injected, it will call `DllMain` with the `DLL_PROCESS_ATTACH` reason and execute our code. Since I wish to persist the interface to allow the user to continuously access the trainer, I must use the `CreateThread` function to start another function to handle it, otherwise the main application will hang. Finally, we _must_ return `TRUE` else the DLL will be detached from the process as a result. I will leave the interface for you to design; it may be a console or graphical interface, or perhaps you could set global hotkeys or hook the keyboard. The choice is yours.

### Injecting the DLL

Thankfully, we do not need to download any DLL injectors because CE comes with one! To access it, open the memory viewer (or disassembler/debugger), then go to the `Tools` menu and select `Inject DLL`, then proceed to locate your DLL and press `Open` in the dialog. Here is what mine looks like:

&lt;img src=&quot;//0x00sec.s3.amazonaws.com/original/2X/e/ef97c21ef667069173fe50fbf1481d6829a60d87.JPG&quot; width=&quot;551&quot; height=&quot;320&quot;&gt;


----------

# Conclusions

So what have we (hopefully) learned? 

* DLL injection has a significant advantage over the usage of `ReadProcessMemory` and `WriteProcessMemory` because of the simplicity it provides
* We&#39;ve also identified a member of a data structure which we then looked further to locate the entire struct and then played around with to see what would be reflected in the game, then translated this structure into our own trainer so that we can change them on demand
* Understanding how to dynamically calculate addresses using offsets and the process&#39;s base address will enable us to handle ASLR environments
* Modifying assembly inline and how to bypass DEP by using `VirtualProtect`

As usual, you can find my code on the [GitLab](https://gitlab.s-3.tech/93aef0ce4dd141ece6f5/0x00sec-code-dump/tree/master/HSLTrainer) or [GitHub](https://github.com/NtRaiseHardError/HSLTrainer).

Thanks for the read!

-- _dtm_</description>
    
    <lastBuildDate>Thu, 05 Oct 2017 23:00:58 +0000</lastBuildDate>
    <category>Reverse Engineering</category>
    <atom:link href="https://0x00sec.org/t/game-hacking-hack-slash-loot/3711.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Game Hacking: Hack, Slash, Loot</title>
        <dc:creator><![CDATA[dtm]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 30 days. New replies are no longer allowed.</p>
          <p><a href="https://0x00sec.org/t/game-hacking-hack-slash-loot/3711/10">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/game-hacking-hack-slash-loot/3711/10</link>
        <pubDate>Sat, 16 Dec 2017 04:10:08 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3711-10</guid>
        <source url="https://0x00sec.org/t/game-hacking-hack-slash-loot/3711.rss">Game Hacking: Hack, Slash, Loot</source>
      </item>
      <item>
        <title>Game Hacking: Hack, Slash, Loot</title>
        <dc:creator><![CDATA[udha]]></dc:creator>
        <description><![CDATA[
            <p>Loving the article, it will help me refresh myself on cheat engine <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"> - but just a tip, if possible please use PNG images for screenshots rather than JPEG. Because PNG uses a lossless compression, the images stay clean and crisp around text and sharp pixel-perfect details; unlike a lossy compression such as JPEG. For screenshots especially PNG will typically result in smaller file sizes too!</p>
          <p><a href="https://0x00sec.org/t/game-hacking-hack-slash-loot/3711/9">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/game-hacking-hack-slash-loot/3711/9</link>
        <pubDate>Thu, 05 Oct 2017 23:00:58 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3711-9</guid>
        <source url="https://0x00sec.org/t/game-hacking-hack-slash-loot/3711.rss">Game Hacking: Hack, Slash, Loot</source>
      </item>
      <item>
        <title>Game Hacking: Hack, Slash, Loot</title>
        <dc:creator><![CDATA[jtara]]></dc:creator>
        <description><![CDATA[
            <p>Thanks, I got it working with</p>
<pre><code>void StartInterface(LPVOID lpParam) {
	Trainer::instance()-&gt;ModifyAttack(0, 999);
	Trainer::instance()-&gt;ModifyDamage(0, 123);
	Trainer::instance()-&gt;ModifyHealth(456);
}
</code></pre>
<ol>
<li>
<p>I had to figure out which static address was needed for player struct and health as there were several for each. I attached a debugger to find out what writes to this other address whose value is health (usually) which changed the value of the incorrect static addresses.</p>
</li>
<li>
<p>Got the correct offsets, then had to clean, rebuild and compile the solution / project in Visual Studio to get the dll to inject.</p>
</li>
</ol>
          <p><a href="https://0x00sec.org/t/game-hacking-hack-slash-loot/3711/8">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/game-hacking-hack-slash-loot/3711/8</link>
        <pubDate>Wed, 27 Sep 2017 00:21:54 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3711-8</guid>
        <source url="https://0x00sec.org/t/game-hacking-hack-slash-loot/3711.rss">Game Hacking: Hack, Slash, Loot</source>
      </item>
      <item>
        <title>Game Hacking: Hack, Slash, Loot</title>
        <dc:creator><![CDATA[dtm]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="jtara" data-post="6" data-topic="3711">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://0x00sec.org/letter_avatar_proxy/v4/letter/j/71c47a/40.png" class="avatar"> jtara:</div>
<blockquote>
<p>Why is the base address of the process of the game consistently 0x400000</p>
</blockquote>
</aside>
<p>The developer may not have enabled dynamic base addressing when compiling it.</p>
<aside class="quote no-group" data-username="jtara" data-post="6" data-topic="3711">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://0x00sec.org/letter_avatar_proxy/v4/letter/j/71c47a/40.png" class="avatar"> jtara:</div>
<blockquote>
<p>Just to test my offsets I calculated, I should be able to dissect data/structures using the address (baseAddress + offset) right? Well, this isn’t giving me the expected player struct.</p>
</blockquote>
</aside>
<p>Did you leave all the values as default? It should look something like this:</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/f/f38127bdf2a7f7d4861c22619f66fa6707157255.JPG" width="673" height="499"></p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/b/bce6511034c3fdd02ca3cb73325203f0a37ac20a.JPG" width="678" height="500"></p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/e/ef7a1025be3dcc8c8ef60c671f726f457f5f4b23.JPG" width="690" height="459"></p>
          <p><a href="https://0x00sec.org/t/game-hacking-hack-slash-loot/3711/7">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/game-hacking-hack-slash-loot/3711/7</link>
        <pubDate>Tue, 26 Sep 2017 23:06:21 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3711-7</guid>
        <source url="https://0x00sec.org/t/game-hacking-hack-slash-loot/3711.rss">Game Hacking: Hack, Slash, Loot</source>
      </item>
      <item>
        <title>Game Hacking: Hack, Slash, Loot</title>
        <dc:creator><![CDATA[jtara]]></dc:creator>
        <description><![CDATA[
            <p>I couldn’t get this to work.</p>
<p>Why is the base address of the process of the game consistently 0x400000 ?</p>
<p>Just to test my offsets I calculated, I should be able to dissect data/structures using the address (baseAddress + offset) right? Well, this isn’t giving me the expected player struct.</p>
          <p><a href="https://0x00sec.org/t/game-hacking-hack-slash-loot/3711/6">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/game-hacking-hack-slash-loot/3711/6</link>
        <pubDate>Tue, 26 Sep 2017 22:53:28 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3711-6</guid>
        <source url="https://0x00sec.org/t/game-hacking-hack-slash-loot/3711.rss">Game Hacking: Hack, Slash, Loot</source>
      </item>
      <item>
        <title>Game Hacking: Hack, Slash, Loot</title>
        <dc:creator><![CDATA[dtm]]></dc:creator>
        <description><![CDATA[
            <p>This is pure Win32, I used the resource editor in Visual Studio for the GUI. If you’re talking about the different looking “skin”, it’s a theme I use.</p>
<p><a class="mention" href="https://0x00sec.org/u/jtara">@jtara</a> Thanks for spotting that!</p>
          <p><a href="https://0x00sec.org/t/game-hacking-hack-slash-loot/3711/5">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/game-hacking-hack-slash-loot/3711/5</link>
        <pubDate>Tue, 26 Sep 2017 22:37:01 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3711-5</guid>
        <source url="https://0x00sec.org/t/game-hacking-hack-slash-loot/3711.rss">Game Hacking: Hack, Slash, Loot</source>
      </item>
      <item>
        <title>Game Hacking: Hack, Slash, Loot</title>
        <dc:creator><![CDATA[lantern-shadowclaw]]></dc:creator>
        <description><![CDATA[
            <p>0x00sec’s gitlab go to init and you can navigate to the gitlab and setup an account</p>
          <p><a href="https://0x00sec.org/t/game-hacking-hack-slash-loot/3711/4">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/game-hacking-hack-slash-loot/3711/4</link>
        <pubDate>Tue, 26 Sep 2017 21:16:05 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3711-4</guid>
        <source url="https://0x00sec.org/t/game-hacking-hack-slash-loot/3711.rss">Game Hacking: Hack, Slash, Loot</source>
      </item>
      <item>
        <title>Game Hacking: Hack, Slash, Loot</title>
        <dc:creator><![CDATA[jtara]]></dc:creator>
        <description><![CDATA[
            <p>There’s a typo between <code>Trainer.cpp</code> and <code>Trainer.h</code>. Rename variable in <code>_player</code> struct in <code>Trainer.h</code> from <code>baseArmour</code> to <code>baseArmor</code>. I was going to make pull req. to fix, but idk what this <a href="https://gitlab.s-3.tech" rel="nofollow noopener">https://gitlab.s-3.tech</a> thing is.</p>
<p>edit: looks like this was fixed, if not, errors read through IDE should make it easy to fix</p>
          <p><a href="https://0x00sec.org/t/game-hacking-hack-slash-loot/3711/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/game-hacking-hack-slash-loot/3711/3</link>
        <pubDate>Tue, 26 Sep 2017 21:10:53 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3711-3</guid>
        <source url="https://0x00sec.org/t/game-hacking-hack-slash-loot/3711.rss">Game Hacking: Hack, Slash, Loot</source>
      </item>
      <item>
        <title>Game Hacking: Hack, Slash, Loot</title>
        <dc:creator><![CDATA[kl0wny]]></dc:creator>
        <description><![CDATA[
            <p>Did you use a special library for the interface you made? Or just win32?</p>
          <p><a href="https://0x00sec.org/t/game-hacking-hack-slash-loot/3711/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/game-hacking-hack-slash-loot/3711/2</link>
        <pubDate>Tue, 26 Sep 2017 20:59:43 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3711-2</guid>
        <source url="https://0x00sec.org/t/game-hacking-hack-slash-loot/3711.rss">Game Hacking: Hack, Slash, Loot</source>
      </item>
      <item>
        <title>Game Hacking: Hack, Slash, Loot</title>
        <dc:creator><![CDATA[dtm]]></dc:creator>
        <description><![CDATA[
            <p>So recently I’ve been re-motivated to do some more game hacking and I thought that I’d do another article to introduce more aspects on top of what I’ve already shown from my previous ones. In the following document, I’ll be detailing the usage of DLL injection and its advantages, a fundamental concept of how games may store specific data and how to identify them. Along the way, I will be talking about the ASLR environment and how to adapt code to such scenarios. Finally, I will be discussing how to code a <a href="https://en.wikipedia.org/wiki/Trainer_(games)">trainer</a> in the form of a DLL.</p>
<p>The game that we will be using to demonstrate these ideas is <em><a href="http://www.hackslashloot.com/">Hack, Slash, Loot</a></em> which has a demo version that you can download if you wish to follow along.</p>
<h4>Author Assigned Level: Newbie</h4>
<h4>Community Assigned Level:</h4>
<p><a href="https://0x00sec.org/t/game-hacking-hack-slash-loot/3711/1">Click to view the poll.</a></p>
<h4>Assumed Knowledge</h4>
<ul>
<li>Windows API</li>
<li>C++</li>
<li>x86 Intel Assembly</li>
<li>Basic Cheat Engine usage</li>
<li>Virtual memory</li>
<li>DLL injection</li>
<li>Data Execution Prevention (DEP)</li>
</ul>
<h4>Expected Outcomes</h4>
<ul>
<li>Understand the advantages of using DLL injection over external process data manipulation</li>
<li>Understand the basic concept of data structures in games</li>
<li>Learn how to adapt code in an ASLR environment</li>
<li>Learn how to modify assembly inline</li>
<li>Learn how to program a basic trainer in C++</li>
</ul>
<h4>Disclaimer</h4>
<p>This information is based on the information that I have researched myself and is therefore subject to the possibility of providing incorrect data. If such incorrect data exists, please notify me and I will fix it when I am available.</p>
<hr>
<h1>DLL Injection</h1>
<p>I’ve covered DLL injection in previous articles but just for completeness, I will give a brief overview of it. DLL injection is simply the act of forcing a process to load a DLL. There are many different ways to perform this but the most common and easiest method is to call <code>LoadLibrary</code> from within the target process and passing the full path of the DLL as a parameter. Here is some sample code that represents the procedure.</p>
<pre><code class="lang-cpp">    // Get size of the full DLL path
	DWORD dwDllPathLen = strlen(lpszDllPath);
    // Allocate space for the DLL string
	LPVOID lpDllPathString = VirtualAllocEx(hProcess, NULL, dwDllPathLen, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    // Write the DLL string into the allocated space
	SIZE_T dwWritten = 0;
	WriteProcessMemory(hProcess, lpBaseAddress, lpszDllPath, dwDllPathLen, &amp;dwWritten);
    // Get handle to the module which has LoadLibrary
	HMODULE hModule = GetModuleHandle("kernel32.dll");
    // Get address of LoadLibrary
	LPVOID lpLoadLibrary = GetProcAddress(hModule, "LoadLibraryA");
    // Execute LoadLibrary with the DLL string as the parameter
	CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)lpLoadLibrary, lpDllPathString, 0, NULL);
</code></pre>
<p>Space will first be allocated for the <em>full</em> path of the DLL in the target process as a parameter for <code>LoadLibrary</code>. Once space has been allocated, the path string will be written using <code>WriteProcessMemory</code>. The <code>LoadLibrary</code> address will be retrieved using <code>GetModuleHandle</code> with the <code>kernel32.dll</code> parameter and <code>GetProcAddress</code>. Now that we have <code>LoadLibrary</code> and the DLL path string, we simply execute a thread in the target process at <code>LoadLibrary</code> using <code>CreateRemoteThread</code>, passing the DLL path string as a parameter.</p>
<p>In summary, we are forcing the target process to execute</p>
<pre><code class="lang-cpp">    LoadLibrary("DLL's full path string");
</code></pre>
<h3>DLL Injection vs External Process Data Manipulation</h3>
<p>So just some motivation, we want to be able to modify data within a process to be able to force it to do what we want. This can be done in two ways, the first I call <em>external process data manipulation</em>, I’ve already covered in previous game hacking articles. Essentially, it uses the <code>ReadProcessMemory</code> and <code>WriteProcessMemory</code> functions to query and change data given a specified process handle. But constantly calling these functions is a bit awkward and wouldn’t it be a bit better if we could just modify it by simply assigning it like a normal variable, i.e. <code>player.health = 9999</code>?</p>
<p>DLL injection offers the solution to this problem. In the context of an injected DLL, the target process’s data in memory is treated like normal meaning that we can read and write data by reading an address and then assigning it a value using the assignment operator.</p>
<pre><code class="lang-cpp">   int *health = (int *)ADDR_HEALTH_VALUE;
   *health = 9999;
</code></pre>
<p>So obviously, it is more favourable to be in this situation purely due to its simplicity.</p>
<hr>
<h1>Finding Values</h1>
<p>Since basic use of Cheat Engine is assumed knowledge, we will skip the setup and dive straight into scanning for values of interest. So boot up the game and CE and let’s first find the address of the health. Here I’ve found mine and have modified it to confirm that it’s correct.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/1/16ea1261a05917f93767f2a6fee6f36e7110aa8b.JPG" width="690" height="435"></p>
<p>Cool. So I can change my health to whatever I want but that’s easy and not very exciting. Let’s go a bit further and identify the underlying assembly which changes our health value by right-clicking the address and then selecting <code>Find out what writes to this address</code>. It will ask if you want to attach a debugger so just confirm that you want to and then it will open up a window. Simply trigger your health value so that CE can detect the instruction(s). When it shows up, select it and click <code>Show disassembler</code> on the right.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/9/92c6748727c5c88931d12027b3119ae7d5caf34c.JPG" width="690" height="365"></p>
<h3>Identifying Data Structures</h3>
<p>Immediately we can deduce that the <code>sub</code> instruction is where the program decreases our health value where <code>eax</code> holds the value of the amount and directly after it, there is a <code>cmp</code> instruction with 0 which is very likely where it checks if we are dead. Note down the address of the <code>sub</code> instruction as we will be using it later in our trainer. What’s interesting to note is that the health value is obtained with an offset from <code>ebx</code> because that is exactly what it would look like if it was referencing some sort of data structure like an array or a struct. To examine what <code>ebx</code> is, let’s place a breakpoint (F5) and then re-trigger our health.</p>
<p>As the breakpoint is hit, it will show us the value of <code>ebx</code>. Let’s use CE to examine this data structure by going to the <code>Tools</code> menu of the disassembler, then selecting <code>Dissect data/structures</code>. Plug in the value of <code>ebx</code> in the edit box labelled <code>Group 1</code> then go to the <code>Structures</code> menu and select <code>Define new structure</code>. Leave everything as default and let CE do all the heavy lifting and it will present a list of values at different offsets.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/4/415ca1399dfc8c5b619bbdb355d4dc150b2520dc.JPG" width="690" height="373"></p>
<p>Notice that at offset 50, we can see our health. But what are all these other values? Let’s head back to the game and see if we can find out. Actually, there is a sort of <em>slight</em> matching of values.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/0/07a0adf92bf32dae070fba38b5fcb3454de85af0.JPG" width="603" height="500"></p>
<p>Let’s confirm it by modifying the values in the struct and see if it is reflected in the game…</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/8/8f0e28cf85a433ca42e57a071634501a51929b94.JPG" width="597" height="500"></p>
<p>Neat stuff! We can spend hours trying to decipher the structure members but I will leave that up to you if you wish to do it.</p>
<p>The final task that we need to do before moving onto coding the trainer is to know where we can find the address of the player struct. Luckily, this is easy for us to do. Return back to the main CE window and scan for the address of the player struct (make sure the hex checkbox is ticked) and we will be given an address in green text. This means that this is a <em>static</em> address and will never change.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/5/5dbbea0b95357605824c4bd9a76d852713a34f68.JPG" width="609" height="500"></p>
<hr>
<h1>Programming a Trainer</h1>
<h3>Dealing with ASLR</h3>
<p>Before we start coding the trainer, I’d like to bring up the concept of <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">Address Space Layout Randomisation</a> (ASLR). ASLR is a technique used by the operating system as a security measure to counteract exploitation methods like buffer overflows. The idea is to have the process’s addresses randomised so that it would be impossible to tell where certain data existed.</p>
<p>What’s relevant to game hacking is the randomisation of the process’s base address and it needs to be understood so that it’s possible to adapt our code to such a volatile environment. Do not worry, the solution is pretty simple, at least for what we are doing. All we need is the <em>offset</em> of a certain address and then dynamically calculate the address in accordance to the base address. How do we get the offset of a target address? Simply subtract the base address of the process from it: <code>offset = targetAddress - baseAddress</code>. How do we dynamically calculate the new address in an ASLR’d process? <code>targetAddress = getBaseAddress() + offset</code>. Easy!</p>
<p>We can see here that the process was loaded at address <code>0x400000</code> which means that we can calculate the offsets of certain addresses of interests, namely the address which has the instruction to subtract our health (<code>0x547D6E</code>) and the address which holds the address of the player struct (<code>0xBA6140</code>).</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/7/7810095b62001fc87805fd980b9bd0dd55027e5c.JPG" width="690" height="439"></p>
<h3>Programming the Trainer</h3>
<p>We’ll start off by creating a <code>Trainer</code> class where we will define the player struct and the methods we want. I’ve already gone ahead and deciphered some other members of the struct.</p>
<p><strong>Trainer.h</strong></p>
<pre><code class="lang-cpp">#ifndef __TRAINER_H__
#define __TRAINER_H__

#define ADDR_OFFSET_PLAYER_STRUCT 0x7A6140
#define ADDR_OFFSET_SUBTRACT_HEALTH 0x147D6E

typedef struct _player {
	void *unknown1;
	int unknown2;
	void *unknown3;
	void *unknown4;
	int unknown5;
	int unknown6;
	int unknown7;
	int unknown8;
	int unknown9;
	void *unknown10;
	int unknown11;
	unsigned int faceDirection;	// 1 (right) or 0xFFFFFFFF (left)
	int unknown12;
	int baseMeleeAttack;	// accuracy
	int baseRangedAttack;
	int baseMagicAttack;
	int baseArmour;
	int baseMeleeDamage;
	int baseRangedDamage;
	int baseMagicDamage;
	int health;
	int resistance;
	int vulnerability;
	int unknown14;
} player;

class Trainer {
	private:
	unsigned int baseAddress;
	player *p;
	bool isGodmode;
	static Trainer *t_instance;    // Singleton; ignore

	Trainer();
	~Trainer();
	Trainer(Trainer&amp; other) {}    // Singleton; ignore
	Trainer&amp; operator=(Trainer&amp; other) {}    // Singleton; ignore

	public:
	static const int MELEE = 0;
	static const int RANGED = 1;
	static const int MAGIC = 2;
	static Trainer *instance();    // Singleton; ignore
	void Reset();
	void ModifyHealth(int health);
	void EnableGodmode(bool enable);
	void ModifyArmour(int armour);
	void ModifyAttack(int type, int attack);
	void ModifyDamage(int type, int damage);
	bool IsGodmode();
};

#endif // !__TRAINER_H__
</code></pre>
<p>I’ve defined this class as a <em>Singleton</em> meaning that it will only allow a single instance of this player class to exist at any given time since this is a single-player game. This is an optional trait so ignore this if it complicates things.</p>
<p>When defining the player struct, it is important that we replicate the members exactly in terms of order and data type however, it is possible to truncate it if we do not know any other further details. At the top, I’ve defined some offset values for the location of the player struct and the instruction that subtracts health. Do you understand how I calculated those values?</p>
<p>Let’s now define the methods.</p>
<pre><code class="lang-cpp">#include &lt;Windows.h&gt;

#include "Trainer.h"

// initialise trainer instance
Trainer *Trainer::t_instance = 0;    // Singleton; ignore

/*
 * Initialise the base address and obtain the 
 * address of the player struct. Default disable
 * godmode.
 *
 * Note that we must start a new game before 
 * applying any h4x otherwise the address will
 * not contain a valid player struct.
 */
Trainer::Trainer() {
	// player struct at 00BA6140
	this-&gt;baseAddress = reinterpret_cast&lt;unsigned int&gt;(::GetModuleHandle(TEXT("HackSlashLoot.exe")));
	this-&gt;p = reinterpret_cast&lt;player *&gt;(*reinterpret_cast&lt;unsigned int *&gt;(this-&gt;baseAddress + ADDR_OFFSET_PLAYER_STRUCT));
	this-&gt;isGodmode = false;
}

Trainer::~Trainer() {
}

/*
 * Return the existing instance of the Trainer
 */
Trainer * Trainer::instance() {
	if (!t_instance)
		t_instance = new Trainer();
	return t_instance;
}

/*
 * In case we retrieve the player struct 
 * before starting a new game.
 */
void Trainer::Reset() {
	this-&gt;p = reinterpret_cast&lt;player *&gt;(*reinterpret_cast&lt;unsigned int *&gt;(this-&gt;baseAddress + ADDR_OFFSET_PLAYER_STRUCT));
}

/*
 * Change the health of the player.
 * Param : new health
 */
void Trainer::ModifyHealth(int health) {
	this-&gt;p-&gt;health = health;
}

/*
 * Change the player's base armour.
 * Param : new armour
 */
void Trainer::ModifyArmour(int armour) {
	this-&gt;p-&gt;baseArmour = armour;
}

/*
 * Change the attack (accuracy) value.
 * Param : type of attack
 * Param : new attack value
 */
void Trainer::ModifyAttack(int type, int attack) {
	if (type == Trainer::MELEE)
		this-&gt;p-&gt;baseMeleeAttack = attack;
	else if (type == Trainer::RANGED)
		this-&gt;p-&gt;baseRangedAttack = attack;
	else if (type == Trainer::MAGIC)
		this-&gt;p-&gt;baseMagicAttack = attack;
}

/*
* Change the damage value.
* Param : type of damage
* Param : new damage value
*/
void Trainer::ModifyDamage(int type, int damage) {
	if (type == Trainer::MELEE)
		this-&gt;p-&gt;baseMeleeDamage = damage;
	else if (type == Trainer::RANGED)
		this-&gt;p-&gt;baseRangedDamage = damage;
	else if (type == Trainer::MAGIC)
		this-&gt;p-&gt;baseMagicDamage = damage;
}

/*
 * Enables or disables godmode.
 * Param : true to enable, false to disable
 */
void Trainer::EnableGodmode(bool enable) {
	this-&gt;isGodmode = enable;
	void *takeDamageAddr = reinterpret_cast&lt;void *&gt;(this-&gt;baseAddress + ADDR_OFFSET_SUBTRACT_HEALTH);
	DWORD flOldProtect = 0;
	::VirtualProtect(takeDamageAddr, 3, PAGE_EXECUTE_READWRITE, &amp;flOldProtect);
	if (this-&gt;isGodmode) {
		*reinterpret_cast&lt;unsigned char *&gt;(takeDamageAddr) = 0x90;
		*(reinterpret_cast&lt;unsigned char *&gt;(takeDamageAddr) + 1) = 0x90;
		*(reinterpret_cast&lt;unsigned char *&gt;(takeDamageAddr) + 2) = 0x90;
	} else {
		*reinterpret_cast&lt;unsigned char *&gt;(takeDamageAddr) = 0x29;
		*(reinterpret_cast&lt;unsigned char *&gt;(takeDamageAddr) + 1) = 0x43;
		*(reinterpret_cast&lt;unsigned char *&gt;(takeDamageAddr) + 2) = 0x50;
	}
	::VirtualProtect(takeDamageAddr, 3, flOldProtect, &amp;flOldProtect);
}

/*
 * Returns true if godmode is enabled, otherwise false.
 */
bool Trainer::IsGodmode() {
	return this-&gt;isGodmode;
}
</code></pre>
<p>Most of these methods are self-explanatory and you can see that they modify values using the assignment operator because the DLL will be under the same context as the game’s process.</p>
<p>The first important thing I want to cover is the <code>baseAddress</code> field which is initialised in <code>Trainer</code>'s constructor. Using <code>GetModuleHandle</code> with the string of the process’s executable module, we can dynamically retrieve the base address which we can then use to dynamically calculate specific addresses. Directly underneath, the line of code utilises the <code>baseAddress</code> field is to calculate the address that stores the player struct.</p>
<p>The second important thing is the <code>EnableGodmode</code> method. Note how I’ve used <code>VirtualProtect</code> to allow write access of the address where the instruction to subtract health exists. This is due to DEP which I’ve covered previously. To apply godmode, we can just <code>nop</code> the subtraction and then we can restore the original bytes to disable it.</p>
<h3>Coding the DLL</h3>
<p>The DLL is not much different than coding a standard executable. Instead of using <code>main</code> or <code>WinMain</code>, we use the <code>DllMain</code> entry point.</p>
<pre><code class="lang-cpp">BOOL APIENTRY DllMain(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved) {
	switch (fdwReason) {
		case DLL_PROCESS_ATTACH:
			::CreateThread(NULL, 0, reinterpret_cast&lt;LPTHREAD_START_ROUTINE&gt;(StartInterface), reinterpret_cast&lt;LPVOID&gt;(hInstDll), 0, NULL);
			break;
	}

	return TRUE;
}
</code></pre>
<p>The only major difference here is the <code>fdwReason</code> parameter which defines the circumstances under which the entry point is called. There are four of them but we will only focus on when the DLL is initially attached to the target process, AKA <code>DLL_PROCESS_ATTACH</code>. Once the DLL has been injected, it will call <code>DllMain</code> with the <code>DLL_PROCESS_ATTACH</code> reason and execute our code. Since I wish to persist the interface to allow the user to continuously access the trainer, I must use the <code>CreateThread</code> function to start another function to handle it, otherwise the main application will hang. Finally, we <em>must</em> return <code>TRUE</code> else the DLL will be detached from the process as a result. I will leave the interface for you to design; it may be a console or graphical interface, or perhaps you could set global hotkeys or hook the keyboard. The choice is yours.</p>
<h3>Injecting the DLL</h3>
<p>Thankfully, we do not need to download any DLL injectors because CE comes with one! To access it, open the memory viewer (or disassembler/debugger), then go to the <code>Tools</code> menu and select <code>Inject DLL</code>, then proceed to locate your DLL and press <code>Open</code> in the dialog. Here is what mine looks like:</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/e/ef97c21ef667069173fe50fbf1481d6829a60d87.JPG" width="551" height="320"></p>
<hr>
<h1>Conclusions</h1>
<p>So what have we (hopefully) learned?</p>
<ul>
<li>DLL injection has a significant advantage over the usage of <code>ReadProcessMemory</code> and <code>WriteProcessMemory</code> because of the simplicity it provides</li>
<li>We’ve also identified a member of a data structure which we then looked further to locate the entire struct and then played around with to see what would be reflected in the game, then translated this structure into our own trainer so that we can change them on demand</li>
<li>Understanding how to dynamically calculate addresses using offsets and the process’s base address will enable us to handle ASLR environments</li>
<li>Modifying assembly inline and how to bypass DEP by using <code>VirtualProtect</code>
</li>
</ul>
<p>As usual, you can find my code on the <a href="https://gitlab.s-3.tech/93aef0ce4dd141ece6f5/0x00sec-code-dump/tree/master/HSLTrainer">GitLab</a> or <a href="https://github.com/NtRaiseHardError/HSLTrainer">GitHub</a>.</p>
<p>Thanks for the read!</p>
<p>– <em>dtm</em></p>
          <p><a href="https://0x00sec.org/t/game-hacking-hack-slash-loot/3711/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/game-hacking-hack-slash-loot/3711/1</link>
        <pubDate>Mon, 25 Sep 2017 10:40:09 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3711-1</guid>
        <source url="https://0x00sec.org/t/game-hacking-hack-slash-loot/3711.rss">Game Hacking: Hack, Slash, Loot</source>
      </item>
  </channel>
</rss>
