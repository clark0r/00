<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Breaking the D-Link DIR3060 Firmware Encryption - Static analysis of the decryption routine - Part 2.1</title>
    <link>https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-static-analysis-of-the-decryption-routine-part-2-1/22099</link>
    <description>![](upload://bA7vKk0BmuESXFfqJ6nYJFGTPkV.jpeg)

Welcome back to part 2 of this series! If you have not checked out [part 1](https://0x434b.dev/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/) yet please do so first as it highlights important reconnaissance steps!

## ToC

- [Loading the binary into IDA](#heading--starting-with-ida)
- [decrypt_firmware](#heading--decrypt-firmware)
  - [check_cert](#heading--check-cert)
  - [call_aes_cbc_encrypt](#heading--call-aes-cbc-encrypt)
  - [aes_cbc_encrypt](#heading--aes-cbc-encrypt)
  - [decrypt_firmware: debug print](#heading--df-debug)
  - [actual_decryption](#heading--actual-decryption)
- [Intermediate summary](#heading--inter-summ)

&lt;h2 id=&quot;heading--starting-with-ida&quot;&gt;Loading the binary into IDA:&lt;/h2&gt;

 So let us dive right into the IDA adventure to get a better look at how `imgdecrypt` operates to secure firmware integrity of recent router models.

‌Note: If you have trouble reading the IDA screenshots here I recommend [reading the mirror on my blog](https://0x434b.dev/breaking-the-d-link-dir3060-firmware-encryption-static-analysis-of-the-decryption-routine-part-2-1/) where these screenshots scale better!

![](upload://5kmzlUXvZk9bIzmuvsyAv7Fivz1.png)
Right when loading the binary into IDA we&#39;re greeted with a function list which is far from bad for us. Remember? In part 1 we found out the binary is supposed to be stripped from any debug symbols, which should make it tough to debug the whole thing but in the way IDA is presenting it to us it is rather nice:


![](upload://dij6IpsP4DfHplwMFb9yCWuBum3.png)



1. Overall 104 recognized functions.
2. Only 16 functions that are not matched against any library function (or similar). These most likely contain the custom de-/encryption routines produced by D-Link.
3. Even though the binary is called `img` **`de`** `crypt` the main entry point reveals that apparently is also has encryption capabilities!

As we&#39;re interested in the decryption for now how do we get there? Quickly annotating the main functions here leaves us with this:


![](upload://fXk8cWhp6aIPbE6IiTQ1Ybrb7Z3.png)

The gist here is that for us to enter the decryption part of the binary our `**argv` argument list has to include the substring *&quot;decrypt&quot;* . If that is not the case `char *strstr(const char *haystack, const char *needle)` returns `NULL` as it could not find the *needle* (&quot;decrypt&quot;) in the *haystack* (argv[0] == &quot;imgdecrypt\0&quot;). If `NULL` is returned the `beqz  $v0, loc_402AE0` instruction will evaluate to true and control flow is redirected to `loc_402AE0` , which is the encryption part of the binary. If you do not understand why I heavily recommend to read part 1 of this series carefully and review the MIPS32 ABI.

Since the binary we&#39;re analyzing is called `imgdecrypt` and the fact that we&#39;re searching from the start of the *argv* space we will always hit the correct condition to enter the decryption routine. To be able to enter the *encryption* routine us renaming of the binary is necessary.

So now we know how to reach the basic block that houses `decrypt_firmware` . Before entering, we should take a closer look at whether the function takes any arguments and if yes which. As you can see from the annotated version `argc` is loaded into `$a0` and `argv` is loaded into `$a1` , which according to the MIPS32 ABI are the registers to hold the first two function arguments! With that out of the way lets rock on!


&lt;h2 id=&quot;heading--decrypt-firmware&quot;&gt;decrypt_firmware:&lt;/h2&gt;

‌
![](upload://fydz2UwupbmKNkb9wINPVyhsiK5.png)

After entering the `decrypt_firmware` function right from how IDA groups the basic blocks in the graph view we know two things for sure:

1. There are two obvious paths we do not want to take to continue decrypting
2. There is some kind of loop in place.

Let&#39;s take a look at the first part:


![](upload://qZUYcwqqdTk6iDsvRMDZNQ5RTQa.png)



I already annotated most of the interesting parts. The handful of `lw` and `sw` instructions at the beginning are setting up the stack frame and function arguments in appropriate places. The invested reader will remember the `/etc_ro/public.pem` from [part 1](https://0x434b.dev/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/). Here in the function prologue the certificate is also set up for later usage. Besides that, there&#39;s only one interesting check at the end where `argc` is loaded into `$v0` and then compared against 2 via `slti $v0, 2` , which in combination with the next instruction of `beqz $v0, loc_402670` translates to the following C-style code snippet:



```
if(argc &lt; 2) {
  ...
} else {
  goto loc_402670
}
```
This means to properly invoke `imgdecrypt` we need at least one more argument (as `./imgdecrypt` already means that *argc* is 1). This totally makes sense as we would not gain anything from invoking this binary without supplying at least an encrypted firmware image! Let&#39;s check what the bad path we would want to avoid holds in store for us first:


![](upload://u0Z9ehJBSdV8bqm3xNZnXZcGQSI.png)

As expected the binary takes an input file, which they denote as *sourceFile.* This makes sense as the *mode* this binary operates in can either be decryption OR encryption. So back to the control flow we would want to follow. Once we made sure our *argc* is at least 2 there is another check against *argc* :


```
lw  $v0, 0x34+argc($sp)
nop
slti  $v0, 3
bnez  $v0, loc_402698
```

This directly translates to:

```
 if(argc &lt; 3) {
   // $v0 == 1
   goto loc_402698
 } else {
   // $v0 == 0
   goto loadUserPem
 }
```


What I called `loadUserPem` allows a user to provide a custom `certificate.pem` upon invocation as it is then stored at the memory location where the default `/etc_ro/public.pem` would have been. As this is none of our concern for now we can happily ignore this part and move on to `loc_402698` . There we directly set up a function call to something I renamed to `check_cert` . As usual arguments are loaded into `$a0` and `$a1` respectively: `check_cert(pemFile, 0)`


&lt;h3 id=&quot;heading--check-cert&quot;&gt;check_cert:&lt;/h3&gt;

This one is pretty straightforward as it just utilizes a bunch of library functionality.

![](upload://qdAm0aTe8J2oYlXsrlZ1AjJrQyF.png)

After setting up the stack frame is done it is being checked whether the provided certificate location is valid by doing a `FILE *fopen(const char *pathname, const char *mode)` , which returns a `NULL` pointer when it fails. If that would be the case the `beqz  $v0, early_return` would evaluate to *true* and control flow would take the *early_return* path, which ultimately would end up in returning `-1` from the function as `lw $v0, RSA_cert; beqz  $v0, bad_end` would evaluate to *true* as the *RSA_cert* is not yet initialized to the point that it holds any data to pass the check against *0* .

In the case, when opening the file is successful `RSA *RSA_new(void)` and `RSA *PEM_read_RSAPublicKey(FILE fp, RSA **x, pem_password_cb *cb, void *u)`  are used to fill the `RSA *RSA_struct` . This struct has the following field members:


```
struct {
       BIGNUM *n;              // public modulus
       BIGNUM *e;              // public exponent
       BIGNUM *d;              // private exponent
       BIGNUM *p;              // secret prime factor
       BIGNUM *q;              // secret prime factor
       BIGNUM *dmp1;           // d mod (p-1)
       BIGNUM *dmq1;           // d mod (q-1)
       BIGNUM *iqmp;           // q^-1 mod p
       // ...
       }; RSA
// In public keys, the private exponent and the related secret values are NULL. 
```

Finally, these values (aka the public key) are stored in `RSA_cert` in memory via the `sw $v1, RSA_cert` instruction. Following that is only the function tear down and once the comparison in `early_return` yields a value != 0 our function return value in set to 0 in the `good_end` basic block: `move  $v0, $zero` .

----

Back in `decrypt_firmware` the return value of `check_cert` is placed into memory (something I re-labeled as `loop_ctr` as it is reused later) and compared against 0. Only if that condition is met control flow will continue deeper into the program to `check_Cert_succ` . In here we directly redirect control flow to `call_aes_cbc_encrypt()` with `key_0` as its first argument.

![](upload://A0QKnYSLhOJCcSKGvUqUeWCmKjf.png)

&lt;h3 id=&quot;heading--call-aes-cbc-encrypt&quot;&gt; call_aes_cbc_encrypt:&lt;/h3&gt;

The function itself only acts as a wrapper, as it directly calls `aes_cbc_encrypt()` with 5 arguments, with the first four in registers `$a0 - $a3` and the 5th one on the stack. 

![](upload://sBuXcYz7KTGjjfd6mH4crWfZ5kc.png)

Four of the five arguments are hard coded into this binary and loaded from memory via multiple: load memory base address ( `lw  $v0, offset_crypto_material` ) and add an offset to it ( `addiu  $a0, $v0, offset` ) operations as they are placed directly one after another:

* `offset_crypto_material + 0x20` → `C8D32F409CACB347C8D26FDCB9090B3C` (in)
* `offset_crypto_material + 0x10` → `358790034519F8C8235DB6492839A73F` (userKey)
* `offset_crypto_material` → `98C9D8F0133D0695E2A709C8B69682D4` (ivec)
* `0x10` → key length

This basically translates to a function call with the following signature: `aes_cbc_encrypt(*ptrTo_C8D32F409CACB347C8D26FDCB9090B3C, 0x10, *ptrTo_358790034519F8C8235DB6492839A73F, *ptrTo_98C9D8F0133D0695E2A709C8B69682D4, *key_copy_stack` ). That said I should have renamed *key_copy_stack* a tad better as in reality it&#39;s just a 16-byte buffer so just try to keep that in mind.


&lt;h3 id=&quot;heading--aes-cbc-encrypt&quot;&gt;aes_cbc_encrypt:&lt;/h3&gt;


The first third of this function is the usual stack frame setup as it needs to properly process 5 function arguments.

![](upload://iIPQLN8pa6Hrnlv7QSg0KKEJa77.png)

‌Additionally, an `AES_KEY` struct that looks as follows is defined:

```
#define AES_MAXNR 14
// [...]
struct aes_key_st {
#ifdef AES_LONG
    unsigned long rd_key[4 *(AES_MAXNR + 1)];
#else
    unsigned int rd_key[4 *(AES_MAXNR + 1)];
#endif
    int rounds;
};
typedef struct aes_key_st AES_KEY;
```
This is needed for the first library call to `AES_set_decrypt_key(const unsigned char *userKey, const int bits, AES_KEY *key)` , which configures `key` to decrypt `userKey` with the `bits` -bit key. In this particular case the key has a size of 0x80 (128 bit == 16 byte). Finally, `AES_cbc_encrypt(const uint8_t *in, uint8_t *out, size_t len, const AES_KEY *key, uint8_t *ivec, const int enc)` is called. This function encrypts (or decrypts, if `enc == 0` ) `len` bytes from `in` to `out` . As `out` was an externally supplied memory address ( `key_copy_stack` aka the 16 byte buffer) from `call_aes_cbc_encrypt` the result from `AES_cbc_encrypt` is directly stored in memory and not used as a dedicated return value of this function. `move  $v0, $zero` is returned instead.

*Note:* For anyone wondering what these `lwl` and `lwr` do there... They indicate unaligned memory access and it looks like `ivec` is being accessed like an array but never used after.

Anyhow, what this function essentially does is setting the decryption key from hard coded components. As a result the &#39; *generated&#39;* decryption key is the same every time. We can easily script this behavior:

```
from Crypto.Cipher import AES
from binascii import b2a_hex

inFile = bytes.fromhex(&#39;C8D32F409CACB347C8D26FDCB9090B3C&#39;)
userKey = bytes.fromhex(&#39;358790034519F8C8235DB6492839A73F&#39;)
ivec = bytes.fromhex(&#39;98C9D8F0133D0695E2A709C8B69682D4&#39;)
cipher = AES.new(userKey, AES.MODE_CBC, ivec)
b2a_hex(cipher.decrypt(inFile)).upper()

# b&#39;C05FBF1936C99429CE2A0781F08D6AD8&#39;
```
Once again we are now back in `decrypt_firmware` with fresh knowledge about having a static decryption key:

&lt;h3 id=&quot;heading--df-debug&quot;&gt;decrypt_firmware: debug print:&lt;/h3&gt;

‌![](upload://dIZUrwK4JP4w3OSqw2y2VUeeFU3.png)

Now its getting funky. For whatever reason the binary now enters a loop construct that prints out the previously calculated decryption key. The green marked basic blocks roughly translate to the following C code snippet:

```
int ctr = 0;
while(ctr &lt;= 0x10 ) {
  printf(&quot;%02X&quot;, *(key + ctr));
  ctr += 1;
}
```
My assumption is that it may be used for internal debugging so when they e.g. change the `ivec` they can still quickly get their hands on the new decryption key... Once printing the decryption key to *stdout* is over the loop condition redirects control flow to the basic block labeled as `path_to_dec` where a function call to `actual_decryption(argv[1], &quot;/tmp/.firmware.orig&quot;, *key)` is being prepared.

With that over and done with control flow and arguments are being prepared for a function call to something I labelled as `actual_decryption` .


&lt;h3 id=&quot;heading--actual-decryption&quot;&gt;actual_decryption:&lt;/h3&gt;


This function is the meat holding this decryption scheme together.

![](upload://zQACN6mW6hUVVWwPE516fTECks0.png)

This first part prepares two memory locations by initializing them with all 0s via `void *memset(void *s, int c, size_t n)` . I denoted these areas as `buf[68]` and `buf[0x98]` `statbuf_[98]` . Directly after, the function checks if the provided *sourceFile* in *argv[1]* actually exists via a call to `int stat(const char *pathname, struct stat *statbuf)` . The result of that one is stored within a stat struct that looks as follows:

```
struct stat {
    dev_t st_dev;         /* ID of device containing file */
    ino_t st_ino;         /* Inode number */
    mode_t st_mode;        /* File type and mode */
    nlink_t st_nlink;       /* Number of hard links */
    uid_t st_uid;         /* User ID of owner */
    gid_t st_gid;         /* Group ID of owner */
    dev_t st_rdev;        /* Device ID (if special file) */
    off_t st_size;        /* Total size, in bytes */
    blksize_t st_blksize;     /* Block size for filesystem I/O */
    blkcnt_t st_blocks;      /* Number of 512B blocks allocated */

    /* Since Linux 2.6, the kernel supports nanosecond
        precision for the following timestamp fields.
        For the details before Linux 2.6, see NOTES. */

    struct timespec st_atim;  /* Time of last access */
    struct timespec st_mtim;  /* Time of last modification */
    struct timespec st_ctim;  /* Time of last status change */

#define st_atime st_atim.tv_sec      /* Backward compatibility */
#define st_mtime st_mtim.tv_sec
#define st_ctime st_ctim.tv_sec
};
```
On success (meaning *pathname* exists) `stat` returns 0.  So on failure that `bnez $v0, stat_fail` would follow the branch to `stat_fail` . So we want to make sure `$v0` is 0 to continue normally. The desired control flow continues here:

![](upload://ggmld1ZUPwB9rX00Q2XjcCIHHmE.png)

Here, besides some local variable saving the *sourceFile* is opened in read-only mode, indicated by the `0x0` flag provided to the `open(const char *pathname, int flags)` . The result/returned file descriptor of that call is saved to `0x128+fd_enc` . Similar to the *stat* routine before it is being checked whether `open(sourceFile, O_RDONLY)` is successful as indicated by *`bltz  $v0, open_enc_fail` .* The branch to `open_enc_fail` is only taken if `$v0 &lt; 0` , which is only the case when the call to open fails ( `-1` is returned in this case). So assuming the open call succeeds we get to the next part with `$v0` holding the open file descriptor:

![](upload://782IBLkK457O2U3ppbw482iItx4.png)

This basically attempts to use `void mmap(void addr, size_t length, int prot, int flags, int fd, off_t offset)` to map the just opened file into a kernel chosen memory region ( indicated by `*addr == 0` ) that is shared but read-only.

Such flags can easily be extracted from the header files on any system as follows:

```
&gt; egrep -i &#39;(PROT_|MAP_)&#39; /usr/include/x86_64-linux-gnu/bits/mman-linux.h
   implementation does not necessarily support PROT_EXEC or PROT_WRITE
   without PROT_READ.  The only guarantees are that no writing will be
   allowed without PROT_WRITE and no access will be allowed for PROT_NONE. */
#define PROT_READ	0x1		/* Page can be read.  */
#define PROT_WRITE	0x2		/* Page can be written.  */
#define PROT_EXEC	0x4		/* Page can be executed.  */
#define PROT_NONE	0x0		/* Page can not be accessed.  */
#define PROT_GROWSDOWN	0x01000000	/* Extend change to start of
#define PROT_GROWSUP	0x02000000	/* Extend change to start of
#define MAP_SHARED	0x01		/* Share changes.  */
#define MAP_PRIVATE	0x02		/* Changes are private.  */
# define MAP_SHARED_VALIDATE	0x03	/* Share changes and validate
# define MAP_TYPE	0x0f		/* Mask for type of mapping.  */
#define MAP_FIXED	0x10		/* Interpret addr exactly.  */
# define MAP_FILE	0
# ifdef __MAP_ANONYMOUS
#  define MAP_ANONYMOUS	__MAP_ANONYMOUS	/* Don&#39;t use a file.  */
#  define MAP_ANONYMOUS	0x20		/* Don&#39;t use a file.  */
# define MAP_ANON	MAP_ANONYMOUS
/* When MAP_HUGETLB is set bits [26:31] encode the log2 of the huge page size.  */
# define MAP_HUGE_SHIFT	26
# define MAP_HUGE_MASK	0x3f
```

In this case the *stat* call from earlier comes in handy once again as it is not just used to verify whether the provided file in *argv[1]* actually exists but the *statStruct* also contains the struct member `st_blocks` which can be used to fill in the required `size_t length` argument in *mmap* ! The return value of *mmap* is stored in `0x128+mmap_enc_fw($sp)` . Once again we have another &#39;if&#39; condition type branching to check whether the memory mapping was successful. On success, *mmap* returns a pointer to the mapped area and branching on `beqz  $v0, mmap_fail` does not take places since `$v0` holds a value != 0. Following this is a final call to open:

![](upload://tArnJeJ9vGK66raP8eoKtEz1IyI.png)

This only tries to open the predefined path ( *&quot;/tmp/.firmware.orig&quot;* ) as read+write with the new file descriptor being saved in `0x128+fd_tmp($sp)` . As usual, if the open fails branch to the fail portion of this function. On success this leads us to the final preparation step:

![](upload://98DR075nLwrWbd1ganKkfuqek68.png)

1. Here we&#39;re preparing to set the correct size of the freshly opened file in the */tmp/* location by first seeking to offset `stat.st_blocks -1` by invoking `lseek(fd_tmp, stat.st_blocks -1)` . 
2. When the *lseek* succeeds we write a single 0 to the file at said offset. This allows us to easily and quickly create an &quot; *empty* &quot; file without having to write *N* bytes in total (where N== desired file size in bytes). Finally, we close, re-open and re-map the file with new permissions.

*Side note* : We do not need all these if-condition like checks realized through `beqz, bnez, ...` as we already know for sure the file exists by now...

&lt;h2 id=&quot;heading--inter-summ&quot;&gt;Intermediate Summary:&lt;/h2&gt;


So far we didn&#39;t manage to dig any deeper into the decryption routine because of all this file preparation stuff. Luckily, I can tease you as much as that we&#39;re done with that now. As we have already roughly met the 15 minute mark for the reading time I&#39;ll stop here. The very soon upcoming 2nd part of this write-up will solely focus on the cryptographic aspects of the scheme D-Link utilizes.

If, for any reason, you weren&#39;t able to follow properly until here you can find the whole source code up to this point below. You should be able to compile it with *clang* / *gcc* via `clang/gcc -o imgdecrypt imgdecrypt.c -L/usr/local/lib -lssl -lcrypto -s` on any recent Debian based system. This in particular comes in handy if you&#39;re new to MIPS and would much more prefer looking at x86 disassembly. The x86 reversing experience should be close to the original MIPS one only with some minor deviations due to platform differences.

```
#include &lt;arpa/inet.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;openssl/aes.h&gt;
#include &lt;openssl/pem.h&gt;
#include &lt;openssl/rsa.h&gt;
#include &lt;stddef.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

static RSA *grsa_struct = NULL;
static unsigned char iv[] = {0x98, 0xC9, 0xD8, 0xF0, 0x13, 0x3D, 0x06, 0x95,
                             0xE2, 0xA7, 0x09, 0xC8, 0xB6, 0x96, 0x82, 0xD4};
static unsigned char aes_in[] = {0xC8, 0xD3, 0x2F, 0x40, 0x9C, 0xAC,
                                 0xB3, 0x47, 0xC8, 0xD2, 0x6F, 0xDC,
                                 0xB9, 0x09, 0x0B, 0x3C};
static unsigned char aes_key[] = {0x35, 0x87, 0x90, 0x03, 0x45, 0x19,
                                  0xF8, 0xC8, 0x23, 0x5D, 0xB6, 0x49,
                                  0x28, 0x39, 0xA7, 0x3F};

unsigned char out[] = {0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
                       0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46};

int check_cert(char *pem, void *n) {
  OPENSSL_add_all_algorithms_noconf();

  FILE *pem_fd = fopen(pem, &quot;r&quot;);
  if (pem_fd != NULL) {
    RSA *lrsa_struct[2];
    *lrsa_struct = RSA_new();
    if (!PEM_read_RSAPublicKey(pem_fd, lrsa_struct, NULL, n)) {
      RSA_free(*lrsa_struct);
      puts(&quot;Read RSA private key failed, maybe the password is incorrect.&quot;);
    } else {
      grsa_struct = *lrsa_struct;
    }
    fclose(pem_fd);
  }
  if (grsa_struct != NULL) {
    return 0;
  } else {
    return -1;
  }
}

int aes_cbc_encrypt(size_t length, unsigned char *key) {
  AES_KEY dec_key;
  AES_set_decrypt_key(aes_key, sizeof(aes_key) * 8, &amp;dec_key);
  AES_cbc_encrypt(aes_in, key, length, &amp;dec_key, iv, AES_DECRYPT);
  return 0;
}

int call_aes_cbc_encrypt(unsigned char *key) {
  aes_cbc_encrypt(0x10, key);
  return 0;
}

int actual_decryption(char *sourceFile, char *tmpDecPath, unsigned char *key) {
  int ret_val = -1;
  size_t st_blocks = -1;
  struct stat statStruct;
  int fd = -1;
  int fd2 = -1;
  void *ROM = 0;
  int *RWMEM;
  off_t seek_off;
  unsigned char buf_68[68];
  int st;

  memset(&amp;buf_68, 0, 0x40);
  memset(&amp;statStruct, 0, 0x90);
  st = stat(sourceFile, &amp;statStruct);
  if (st == 0) {
    fd = open(sourceFile, O_RDONLY);
    st_blocks = statStruct.st_blocks;
    if (((-1 &lt; fd) &amp;&amp;
         (ROM = mmap(0, statStruct.st_blocks, 1, MAP_SHARED, fd, 0),
          ROM != 0)) &amp;&amp;
        (fd2 = open(tmpDecPath, O_RDWR | O_NOCTTY, 0x180), -1 &lt; fd2)) {
      seek_off = lseek(fd2, statStruct.st_blocks - 1, 0);
      if (seek_off == statStruct.st_blocks - 1) {
        write(fd2, 0, 1);
        close(fd2);
        fd2 = open(tmpDecPath, O_RDWR | O_NOCTTY, 0x180);
        RWMEM = mmap(0, statStruct.st_blocks, PROT_EXEC | PROT_WRITE,
                     MAP_SHARED, fd2, 0);
        if (RWMEM != NULL) {
          ret_val = 0;
        }
      }
    }
  }
  puts(&quot;EOF part 2.1!\n&quot;);
  return ret_val;
}

int decrypt_firmware(int argc, char **argv) {
  int ret;
  unsigned char key[] = {0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
                         0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46};
  char *ppem = &quot;/tmp/public.pem&quot;;
  int loopCtr = 0;
  if (argc &lt; 2) {
    printf(&quot;%s &lt;sourceFile&gt;\r\n&quot;, argv[0]);
    ret = -1;
  } else {
    if (2 &lt; argc) {
      ppem = (char *)argv[2];
    }
    int cc = check_cert(ppem, (void *)0);
    if (cc == 0) {
      call_aes_cbc_encrypt((unsigned char *)&amp;key);

      printf(&quot;key: &quot;);
      while (loopCtr &lt; 0x10) {
        printf(&quot;%02X&quot;, *(key + loopCtr) &amp; 0xff);
        loopCtr += 1;
      }
      puts(&quot;\r&quot;);
      ret = actual_decryption((char *)argv[1], &quot;/tmp/.firmware.orig&quot;,
                              (unsigned char *)&amp;key);

      if (ret == 0) {
        unlink(argv[1]);
        rename(&quot;/tmp/.firmware.orig&quot;, argv[1]);
      }
      RSA_free(grsa_struct);
    } else {
      ret = -1;
    }
  }
  return ret;
}

int encrypt_firmware(int argc, char **argv) { return 0; }

int main(int argc, char **argv) {
  int ret;
  char *str_f = strstr(*argv, &quot;decrypt&quot;);

  if (str_f != NULL) {
    ret = decrypt_firmware(argc, argv);

  } else {
    ret = encrypt_firmware(argc, argv);
  }

  return ret;
}
```
‌

```
&gt; ./imgdecrypt
./imgdecrypt &lt;sourceFile&gt;
&gt; ./imgdecrypt testFile
key: C05FBF1936C99429CE2A0781F08D6AD8
EOF part 2.1!
```

The next part 2.2 will be online shortly and linked here as soon as it is available.
Thanks for reading and if you have any questions or remarks feel free to hit me up :)!

Note: If you have trouble reading the IDA screenshots here I recommend [reading the mirror on my blog](https://0x434b.dev/breaking-the-d-link-dir3060-firmware-encryption-static-analysis-of-the-decryption-routine-part-2-1/) where these screenshots scale better!



## &lt;&lt; [Part 1](https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/21943/)
## &gt;&gt; [Part 2.2](https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-static-analysis-of-the-decryption-routine-part-2-2/22260)</description>
    
    <lastBuildDate>Sat, 27 Mar 2021 11:37:56 +0000</lastBuildDate>
    <category>Reverse Engineering</category>
    <atom:link href="https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-static-analysis-of-the-decryption-routine-part-2-1/22099.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Breaking the D-Link DIR3060 Firmware Encryption - Static analysis of the decryption routine - Part 2.1</title>
        <dc:creator><![CDATA[messede]]></dc:creator>
        <description><![CDATA[
            <p>Thanks for fixing all the screenshots , all those older post are a mess since we had that backup issue</p>
          <p><a href="https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-static-analysis-of-the-decryption-routine-part-2-1/22099/7">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-static-analysis-of-the-decryption-routine-part-2-1/22099/7</link>
        <pubDate>Sat, 27 Mar 2021 11:37:56 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-22099-7</guid>
        <source url="https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-static-analysis-of-the-decryption-routine-part-2-1/22099.rss">Breaking the D-Link DIR3060 Firmware Encryption - Static analysis of the decryption routine - Part 2.1</source>
      </item>
      <item>
        <title>Breaking the D-Link DIR3060 Firmware Encryption - Static analysis of the decryption routine - Part 2.1</title>
        <dc:creator><![CDATA[black_bit]]></dc:creator>
        <description><![CDATA[
            <p>fucking awsome Although I did not understand half <img src="https://0x00sec.org/images/emoji/twitter/stuck_out_tongue.png?v=9" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:"></p>
          <p><a href="https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-static-analysis-of-the-decryption-routine-part-2-1/22099/6">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-static-analysis-of-the-decryption-routine-part-2-1/22099/6</link>
        <pubDate>Tue, 28 Jul 2020 21:52:58 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-22099-6</guid>
        <source url="https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-static-analysis-of-the-decryption-routine-part-2-1/22099.rss">Breaking the D-Link DIR3060 Firmware Encryption - Static analysis of the decryption routine - Part 2.1</source>
      </item>
      <item>
        <title>Breaking the D-Link DIR3060 Firmware Encryption - Static analysis of the decryption routine - Part 2.1</title>
        <dc:creator><![CDATA[ricksanchez]]></dc:creator>
        <description><![CDATA[
            <p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/5/512d32c4cd79025a18a5375600e910d6f296a3e5.jpeg" data-download-href="/uploads/short-url/bA7vKk0BmuESXFfqJ6nYJFGTPkV.jpeg?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/5/512d32c4cd79025a18a5375600e910d6f296a3e5_2_690x387.jpeg" alt="" data-base62-sha1="bA7vKk0BmuESXFfqJ6nYJFGTPkV" width="690" height="387" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/5/512d32c4cd79025a18a5375600e910d6f296a3e5_2_690x387.jpeg, https://0x00sec.s3.amazonaws.com/optimized/2X/5/512d32c4cd79025a18a5375600e910d6f296a3e5_2_1035x580.jpeg 1.5x, https://0x00sec.s3.amazonaws.com/optimized/2X/5/512d32c4cd79025a18a5375600e910d6f296a3e5_2_1380x774.jpeg 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/5/512d32c4cd79025a18a5375600e910d6f296a3e5_2_10x10.png"></a></div><p></p>
<p>Welcome back to part 2 of this series! If you have not checked out <a href="https://0x434b.dev/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/">part 1</a> yet please do so first as it highlights important reconnaissance steps!</p>
<h2>ToC</h2>
<ul>
<li><a href="https://0x00sec.org#heading--starting-with-ida">Loading the binary into IDA</a></li>
<li>
<a href="https://0x00sec.org#heading--decrypt-firmware">decrypt_firmware</a>
<ul>
<li><a href="https://0x00sec.org#heading--check-cert">check_cert</a></li>
<li><a href="https://0x00sec.org#heading--call-aes-cbc-encrypt">call_aes_cbc_encrypt</a></li>
<li><a href="https://0x00sec.org#heading--aes-cbc-encrypt">aes_cbc_encrypt</a></li>
<li><a href="https://0x00sec.org#heading--df-debug">decrypt_firmware: debug print</a></li>
<li><a href="https://0x00sec.org#heading--actual-decryption">actual_decryption</a></li>
</ul>
</li>
<li><a href="https://0x00sec.org#heading--inter-summ">Intermediate summary</a></li>
</ul>
<h2 id="heading--starting-with-ida">Loading the binary into IDA:</h2>
<p>So let us dive right into the IDA adventure to get a better look at how <code>imgdecrypt</code> operates to secure firmware integrity of recent router models.</p>
<p>‌Note: If you have trouble reading the IDA screenshots here I recommend <a href="https://0x434b.dev/breaking-the-d-link-dir3060-firmware-encryption-static-analysis-of-the-decryption-routine-part-2-1/">reading the mirror on my blog</a> where these screenshots scale better!</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/2/25582b931f7f069e344b38b8179ef735ae96f0d7.png" data-download-href="/uploads/short-url/5kmzlUXvZk9bIzmuvsyAv7Fivz1.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/2/25582b931f7f069e344b38b8179ef735ae96f0d7_2_690x325.png" alt="" data-base62-sha1="5kmzlUXvZk9bIzmuvsyAv7Fivz1" width="690" height="325" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/2/25582b931f7f069e344b38b8179ef735ae96f0d7_2_690x325.png, https://0x00sec.s3.amazonaws.com/original/2X/2/25582b931f7f069e344b38b8179ef735ae96f0d7.png 1.5x, https://0x00sec.s3.amazonaws.com/original/2X/2/25582b931f7f069e344b38b8179ef735ae96f0d7.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/2/25582b931f7f069e344b38b8179ef735ae96f0d7_2_10x10.png"></a></div><br>
Right when loading the binary into IDA we’re greeted with a function list which is far from bad for us. Remember? In part 1 we found out the binary is supposed to be stripped from any debug symbols, which should make it tough to debug the whole thing but in the way IDA is presenting it to us it is rather nice:<p></p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/5/5d2e11cea43a20b189bb4a51fb84c8f2eca397c7.png" data-download-href="/uploads/short-url/dij6IpsP4DfHplwMFb9yCWuBum3.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/5/5d2e11cea43a20b189bb4a51fb84c8f2eca397c7_2_690x466.png" alt="" data-base62-sha1="dij6IpsP4DfHplwMFb9yCWuBum3" width="690" height="466" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/5/5d2e11cea43a20b189bb4a51fb84c8f2eca397c7_2_690x466.png, https://0x00sec.s3.amazonaws.com/optimized/2X/5/5d2e11cea43a20b189bb4a51fb84c8f2eca397c7_2_1035x699.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/2X/5/5d2e11cea43a20b189bb4a51fb84c8f2eca397c7_2_1380x932.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/5/5d2e11cea43a20b189bb4a51fb84c8f2eca397c7_2_10x10.png"></a></div><p></p>
<ol>
<li>Overall 104 recognized functions.</li>
<li>Only 16 functions that are not matched against any library function (or similar). These most likely contain the custom de-/encryption routines produced by D-Link.</li>
<li>Even though the binary is called <code>img</code> <strong><code>de</code></strong> <code>crypt</code> the main entry point reveals that apparently is also has encryption capabilities!</li>
</ol>
<p>As we’re interested in the decryption for now how do we get there? Quickly annotating the main functions here leaves us with this:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/6/6fd55d885483efe0103107ed861d661a23a6495d.png" data-download-href="/uploads/short-url/fXk8cWhp6aIPbE6IiTQ1Ybrb7Z3.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/6/6fd55d885483efe0103107ed861d661a23a6495d_2_541x500.png" alt="" data-base62-sha1="fXk8cWhp6aIPbE6IiTQ1Ybrb7Z3" width="541" height="500" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/6/6fd55d885483efe0103107ed861d661a23a6495d_2_541x500.png, https://0x00sec.s3.amazonaws.com/optimized/2X/6/6fd55d885483efe0103107ed861d661a23a6495d_2_811x750.png 1.5x, https://0x00sec.s3.amazonaws.com/original/2X/6/6fd55d885483efe0103107ed861d661a23a6495d.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/6/6fd55d885483efe0103107ed861d661a23a6495d_2_10x10.png"></a></div><p></p>
<p>The gist here is that for us to enter the decryption part of the binary our <code>**argv</code> argument list has to include the substring <em>“decrypt”</em> . If that is not the case <code>char *strstr(const char *haystack, const char *needle)</code> returns <code>NULL</code> as it could not find the <em>needle</em> (“decrypt”) in the <em>haystack</em> (argv[0] == “imgdecrypt\0”). If <code>NULL</code> is returned the <code>beqz  $v0, loc_402AE0</code> instruction will evaluate to true and control flow is redirected to <code>loc_402AE0</code> , which is the encryption part of the binary. If you do not understand why I heavily recommend to read part 1 of this series carefully and review the MIPS32 ABI.</p>
<p>Since the binary we’re analyzing is called <code>imgdecrypt</code> and the fact that we’re searching from the start of the <em>argv</em> space we will always hit the correct condition to enter the decryption routine. To be able to enter the <em>encryption</em> routine us renaming of the binary is necessary.</p>
<p>So now we know how to reach the basic block that houses <code>decrypt_firmware</code> . Before entering, we should take a closer look at whether the function takes any arguments and if yes which. As you can see from the annotated version <code>argc</code> is loaded into <code>$a0</code> and <code>argv</code> is loaded into <code>$a1</code> , which according to the MIPS32 ABI are the registers to hold the first two function arguments! With that out of the way lets rock on!</p>
<h2 id="heading--decrypt-firmware">decrypt_firmware:</h2>
<p>‌<br>
</p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/6/6cfed7ca6f32a55d7c4cfbd654bbc83272219f21.png" data-download-href="/uploads/short-url/fydz2UwupbmKNkb9wINPVyhsiK5.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/6/6cfed7ca6f32a55d7c4cfbd654bbc83272219f21_2_353x500.png" alt="" data-base62-sha1="fydz2UwupbmKNkb9wINPVyhsiK5" width="353" height="500" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/6/6cfed7ca6f32a55d7c4cfbd654bbc83272219f21_2_353x500.png, https://0x00sec.s3.amazonaws.com/optimized/2X/6/6cfed7ca6f32a55d7c4cfbd654bbc83272219f21_2_529x750.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/2X/6/6cfed7ca6f32a55d7c4cfbd654bbc83272219f21_2_706x1000.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/6/6cfed7ca6f32a55d7c4cfbd654bbc83272219f21_2_10x10.png"></a></div><p></p>
<p>After entering the <code>decrypt_firmware</code> function right from how IDA groups the basic blocks in the graph view we know two things for sure:</p>
<ol>
<li>There are two obvious paths we do not want to take to continue decrypting</li>
<li>There is some kind of loop in place.</li>
</ol>
<p>Let’s take a look at the first part:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/b/bd38599276706dde66a89f03470bb6cba4ded666.png" data-download-href="/uploads/short-url/qZUYcwqqdTk6iDsvRMDZNQ5RTQa.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/b/bd38599276706dde66a89f03470bb6cba4ded666_2_431x500.png" alt="" data-base62-sha1="qZUYcwqqdTk6iDsvRMDZNQ5RTQa" width="431" height="500" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/b/bd38599276706dde66a89f03470bb6cba4ded666_2_431x500.png, https://0x00sec.s3.amazonaws.com/optimized/2X/b/bd38599276706dde66a89f03470bb6cba4ded666_2_646x750.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/2X/b/bd38599276706dde66a89f03470bb6cba4ded666_2_862x1000.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/b/bd38599276706dde66a89f03470bb6cba4ded666_2_10x10.png"></a></div><p></p>
<p>I already annotated most of the interesting parts. The handful of <code>lw</code> and <code>sw</code> instructions at the beginning are setting up the stack frame and function arguments in appropriate places. The invested reader will remember the <code>/etc_ro/public.pem</code> from <a href="https://0x434b.dev/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/">part 1</a>. Here in the function prologue the certificate is also set up for later usage. Besides that, there’s only one interesting check at the end where <code>argc</code> is loaded into <code>$v0</code> and then compared against 2 via <code>slti $v0, 2</code> , which in combination with the next instruction of <code>beqz $v0, loc_402670</code> translates to the following C-style code snippet:</p>
<pre><code class="lang-auto">if(argc &lt; 2) {
  ...
} else {
  goto loc_402670
}
</code></pre>
<p>This means to properly invoke <code>imgdecrypt</code> we need at least one more argument (as <code>./imgdecrypt</code> already means that <em>argc</em> is 1). This totally makes sense as we would not gain anything from invoking this binary without supplying at least an encrypted firmware image! Let’s check what the bad path we would want to avoid holds in store for us first:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/d/d25dc295c7c6fff885cc2a8e182af33691a09e20.png" alt="" data-base62-sha1="u0Z9ehJBSdV8bqm3xNZnXZcGQSI" width="601" height="311"></p>
<p>As expected the binary takes an input file, which they denote as <em>sourceFile.</em> This makes sense as the <em>mode</em> this binary operates in can either be decryption OR encryption. So back to the control flow we would want to follow. Once we made sure our <em>argc</em> is at least 2 there is another check against <em>argc</em> :</p>
<pre><code class="lang-auto">lw  $v0, 0x34+argc($sp)
nop
slti  $v0, 3
bnez  $v0, loc_402698
</code></pre>
<p>This directly translates to:</p>
<pre><code class="lang-auto"> if(argc &lt; 3) {
   // $v0 == 1
   goto loc_402698
 } else {
   // $v0 == 0
   goto loadUserPem
 }
</code></pre>
<p>What I called <code>loadUserPem</code> allows a user to provide a custom <code>certificate.pem</code> upon invocation as it is then stored at the memory location where the default <code>/etc_ro/public.pem</code> would have been. As this is none of our concern for now we can happily ignore this part and move on to <code>loc_402698</code> . There we directly set up a function call to something I renamed to <code>check_cert</code> . As usual arguments are loaded into <code>$a0</code> and <code>$a1</code> respectively: <code>check_cert(pemFile, 0)</code></p>
<h3 id="heading--check-cert">check_cert:</h3>
<p>This one is pretty straightforward as it just utilizes a bunch of library functionality.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/b/b7c1b0819d321b40a037165a360ddc07349c814d.png" data-download-href="/uploads/short-url/qdAm0aTe8J2oYlXsrlZ1AjJrQyF.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/b/b7c1b0819d321b40a037165a360ddc07349c814d_2_356x500.png" alt="" data-base62-sha1="qdAm0aTe8J2oYlXsrlZ1AjJrQyF" width="356" height="500" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/b/b7c1b0819d321b40a037165a360ddc07349c814d_2_356x500.png, https://0x00sec.s3.amazonaws.com/optimized/2X/b/b7c1b0819d321b40a037165a360ddc07349c814d_2_534x750.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/2X/b/b7c1b0819d321b40a037165a360ddc07349c814d_2_712x1000.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/b/b7c1b0819d321b40a037165a360ddc07349c814d_2_10x10.png"></a></div><p></p>
<p>After setting up the stack frame is done it is being checked whether the provided certificate location is valid by doing a <code>FILE *fopen(const char *pathname, const char *mode)</code> , which returns a <code>NULL</code> pointer when it fails. If that would be the case the <code>beqz  $v0, early_return</code> would evaluate to <em>true</em> and control flow would take the <em>early_return</em> path, which ultimately would end up in returning <code>-1</code> from the function as <code>lw $v0, RSA_cert; beqz  $v0, bad_end</code> would evaluate to <em>true</em> as the <em>RSA_cert</em> is not yet initialized to the point that it holds any data to pass the check against <em>0</em> .</p>
<p>In the case, when opening the file is successful <code>RSA *RSA_new(void)</code> and <code>RSA *PEM_read_RSAPublicKey(FILE fp, RSA **x, pem_password_cb *cb, void *u)</code>  are used to fill the <code>RSA *RSA_struct</code> . This struct has the following field members:</p>
<pre><code class="lang-auto">struct {
       BIGNUM *n;              // public modulus
       BIGNUM *e;              // public exponent
       BIGNUM *d;              // private exponent
       BIGNUM *p;              // secret prime factor
       BIGNUM *q;              // secret prime factor
       BIGNUM *dmp1;           // d mod (p-1)
       BIGNUM *dmq1;           // d mod (q-1)
       BIGNUM *iqmp;           // q^-1 mod p
       // ...
       }; RSA
// In public keys, the private exponent and the related secret values are NULL. 
</code></pre>
<p>Finally, these values (aka the public key) are stored in <code>RSA_cert</code> in memory via the <code>sw $v1, RSA_cert</code> instruction. Following that is only the function tear down and once the comparison in <code>early_return</code> yields a value != 0 our function return value in set to 0 in the <code>good_end</code> basic block: <code>move  $v0, $zero</code> .</p>
<hr>
<p>Back in <code>decrypt_firmware</code> the return value of <code>check_cert</code> is placed into memory (something I re-labeled as <code>loop_ctr</code> as it is reused later) and compared against 0. Only if that condition is met control flow will continue deeper into the program to <code>check_Cert_succ</code> . In here we directly redirect control flow to <code>call_aes_cbc_encrypt()</code> with <code>key_0</code> as its first argument.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/f/fc66e2067baa0d45fd61455cc580791a31b3c951.png" data-download-href="/uploads/short-url/A0QKnYSLhOJCcSKGvUqUeWCmKjf.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/f/fc66e2067baa0d45fd61455cc580791a31b3c951_2_690x240.png" alt="" data-base62-sha1="A0QKnYSLhOJCcSKGvUqUeWCmKjf" width="690" height="240" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/f/fc66e2067baa0d45fd61455cc580791a31b3c951_2_690x240.png, https://0x00sec.s3.amazonaws.com/optimized/2X/f/fc66e2067baa0d45fd61455cc580791a31b3c951_2_1035x360.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/2X/f/fc66e2067baa0d45fd61455cc580791a31b3c951_2_1380x480.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/f/fc66e2067baa0d45fd61455cc580791a31b3c951_2_10x10.png"></a></div><p></p>
<h3 id="heading--call-aes-cbc-encrypt"> call_aes_cbc_encrypt:</h3>
<p>The function itself only acts as a wrapper, as it directly calls <code>aes_cbc_encrypt()</code> with 5 arguments, with the first four in registers <code>$a0 - $a3</code> and the 5th one on the stack.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/c/c87a093686929f436aa24d603320bd081d7ea580.png" data-download-href="/uploads/short-url/sBuXcYz7KTGjjfd6mH4crWfZ5kc.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/c/c87a093686929f436aa24d603320bd081d7ea580_2_544x500.png" alt="" data-base62-sha1="sBuXcYz7KTGjjfd6mH4crWfZ5kc" width="544" height="500" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/c/c87a093686929f436aa24d603320bd081d7ea580_2_544x500.png, https://0x00sec.s3.amazonaws.com/original/2X/c/c87a093686929f436aa24d603320bd081d7ea580.png 1.5x, https://0x00sec.s3.amazonaws.com/original/2X/c/c87a093686929f436aa24d603320bd081d7ea580.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/c/c87a093686929f436aa24d603320bd081d7ea580_2_10x10.png"></a></div><p></p>
<p>Four of the five arguments are hard coded into this binary and loaded from memory via multiple: load memory base address ( <code>lw  $v0, offset_crypto_material</code> ) and add an offset to it ( <code>addiu  $a0, $v0, offset</code> ) operations as they are placed directly one after another:</p>
<ul>
<li>
<code>offset_crypto_material + 0x20</code> → <code>C8D32F409CACB347C8D26FDCB9090B3C</code> (in)</li>
<li>
<code>offset_crypto_material + 0x10</code> → <code>358790034519F8C8235DB6492839A73F</code> (userKey)</li>
<li>
<code>offset_crypto_material</code> → <code>98C9D8F0133D0695E2A709C8B69682D4</code> (ivec)</li>
<li>
<code>0x10</code> → key length</li>
</ul>
<p>This basically translates to a function call with the following signature: <code>aes_cbc_encrypt(*ptrTo_C8D32F409CACB347C8D26FDCB9090B3C, 0x10, *ptrTo_358790034519F8C8235DB6492839A73F, *ptrTo_98C9D8F0133D0695E2A709C8B69682D4, *key_copy_stack</code> ). That said I should have renamed <em>key_copy_stack</em> a tad better as in reality it’s just a 16-byte buffer so just try to keep that in mind.</p>
<h3 id="heading--aes-cbc-encrypt">aes_cbc_encrypt:</h3>
<p>The first third of this function is the usual stack frame setup as it needs to properly process 5 function arguments.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/8/83389e16e9de97d0b90f71d2c089063416ab49b9.png" data-download-href="/uploads/short-url/iIPQLN8pa6Hrnlv7QSg0KKEJa77.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/8/83389e16e9de97d0b90f71d2c089063416ab49b9_2_229x500.png" alt="" data-base62-sha1="iIPQLN8pa6Hrnlv7QSg0KKEJa77" width="229" height="500" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/8/83389e16e9de97d0b90f71d2c089063416ab49b9_2_229x500.png, https://0x00sec.s3.amazonaws.com/optimized/2X/8/83389e16e9de97d0b90f71d2c089063416ab49b9_2_343x750.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/2X/8/83389e16e9de97d0b90f71d2c089063416ab49b9_2_458x1000.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/8/83389e16e9de97d0b90f71d2c089063416ab49b9_2_10x10.png"></a></div><p></p>
<p>‌Additionally, an <code>AES_KEY</code> struct that looks as follows is defined:</p>
<pre><code class="lang-auto">#define AES_MAXNR 14
// [...]
struct aes_key_st {
#ifdef AES_LONG
    unsigned long rd_key[4 *(AES_MAXNR + 1)];
#else
    unsigned int rd_key[4 *(AES_MAXNR + 1)];
#endif
    int rounds;
};
typedef struct aes_key_st AES_KEY;
</code></pre>
<p>This is needed for the first library call to <code>AES_set_decrypt_key(const unsigned char *userKey, const int bits, AES_KEY *key)</code> , which configures <code>key</code> to decrypt <code>userKey</code> with the <code>bits</code> -bit key. In this particular case the key has a size of 0x80 (128 bit == 16 byte). Finally, <code>AES_cbc_encrypt(const uint8_t *in, uint8_t *out, size_t len, const AES_KEY *key, uint8_t *ivec, const int enc)</code> is called. This function encrypts (or decrypts, if <code>enc == 0</code> ) <code>len</code> bytes from <code>in</code> to <code>out</code> . As <code>out</code> was an externally supplied memory address ( <code>key_copy_stack</code> aka the 16 byte buffer) from <code>call_aes_cbc_encrypt</code> the result from <code>AES_cbc_encrypt</code> is directly stored in memory and not used as a dedicated return value of this function. <code>move  $v0, $zero</code> is returned instead.</p>
<p><em>Note:</em> For anyone wondering what these <code>lwl</code> and <code>lwr</code> do there… They indicate unaligned memory access and it looks like <code>ivec</code> is being accessed like an array but never used after.</p>
<p>Anyhow, what this function essentially does is setting the decryption key from hard coded components. As a result the ’ <em>generated’</em> decryption key is the same every time. We can easily script this behavior:</p>
<pre><code class="lang-auto">from Crypto.Cipher import AES
from binascii import b2a_hex

inFile = bytes.fromhex('C8D32F409CACB347C8D26FDCB9090B3C')
userKey = bytes.fromhex('358790034519F8C8235DB6492839A73F')
ivec = bytes.fromhex('98C9D8F0133D0695E2A709C8B69682D4')
cipher = AES.new(userKey, AES.MODE_CBC, ivec)
b2a_hex(cipher.decrypt(inFile)).upper()

# b'C05FBF1936C99429CE2A0781F08D6AD8'
</code></pre>
<p>Once again we are now back in <code>decrypt_firmware</code> with fresh knowledge about having a static decryption key:</p>
<h3 id="heading--df-debug">decrypt_firmware: debug print:</h3>
<p>‌</p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/6/6032715c0ed804ed06c4f08979b04afac6f7b3e7.png" data-download-href="/uploads/short-url/dIZUrwK4JP4w3OSqw2y2VUeeFU3.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/6/6032715c0ed804ed06c4f08979b04afac6f7b3e7_2_690x436.png" alt="" data-base62-sha1="dIZUrwK4JP4w3OSqw2y2VUeeFU3" width="690" height="436" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/6/6032715c0ed804ed06c4f08979b04afac6f7b3e7_2_690x436.png, https://0x00sec.s3.amazonaws.com/optimized/2X/6/6032715c0ed804ed06c4f08979b04afac6f7b3e7_2_1035x654.png 1.5x, https://0x00sec.s3.amazonaws.com/original/2X/6/6032715c0ed804ed06c4f08979b04afac6f7b3e7.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/6/6032715c0ed804ed06c4f08979b04afac6f7b3e7_2_10x10.png"></a></div><p></p>
<p>Now its getting funky. For whatever reason the binary now enters a loop construct that prints out the previously calculated decryption key. The green marked basic blocks roughly translate to the following C code snippet:</p>
<pre><code class="lang-auto">int ctr = 0;
while(ctr &lt;= 0x10 ) {
  printf("%02X", *(key + ctr));
  ctr += 1;
}
</code></pre>
<p>My assumption is that it may be used for internal debugging so when they e.g. change the <code>ivec</code> they can still quickly get their hands on the new decryption key… Once printing the decryption key to <em>stdout</em> is over the loop condition redirects control flow to the basic block labeled as <code>path_to_dec</code> where a function call to <code>actual_decryption(argv[1], "/tmp/.firmware.orig", *key)</code> is being prepared.</p>
<p>With that over and done with control flow and arguments are being prepared for a function call to something I labelled as <code>actual_decryption</code> .</p>
<h3 id="heading--actual-decryption">actual_decryption:</h3>
<p>This function is the meat holding this decryption scheme together.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/f/fb3df9928aba6ce7a94d887f112616a2fcd0fb48.png" data-download-href="/uploads/short-url/zQACN6mW6hUVVWwPE516fTECks0.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/f/fb3df9928aba6ce7a94d887f112616a2fcd0fb48_2_225x500.png" alt="" data-base62-sha1="zQACN6mW6hUVVWwPE516fTECks0" width="225" height="500" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/f/fb3df9928aba6ce7a94d887f112616a2fcd0fb48_2_225x500.png, https://0x00sec.s3.amazonaws.com/optimized/2X/f/fb3df9928aba6ce7a94d887f112616a2fcd0fb48_2_337x750.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/2X/f/fb3df9928aba6ce7a94d887f112616a2fcd0fb48_2_450x1000.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/f/fb3df9928aba6ce7a94d887f112616a2fcd0fb48_2_10x10.png"></a></div><p></p>
<p>This first part prepares two memory locations by initializing them with all 0s via <code>void *memset(void *s, int c, size_t n)</code> . I denoted these areas as <code>buf[68]</code> and <code>buf[0x98]</code> <code>statbuf_[98]</code> . Directly after, the function checks if the provided <em>sourceFile</em> in <em>argv[1]</em> actually exists via a call to <code>int stat(const char *pathname, struct stat *statbuf)</code> . The result of that one is stored within a stat struct that looks as follows:</p>
<pre><code class="lang-auto">struct stat {
    dev_t st_dev;         /* ID of device containing file */
    ino_t st_ino;         /* Inode number */
    mode_t st_mode;        /* File type and mode */
    nlink_t st_nlink;       /* Number of hard links */
    uid_t st_uid;         /* User ID of owner */
    gid_t st_gid;         /* Group ID of owner */
    dev_t st_rdev;        /* Device ID (if special file) */
    off_t st_size;        /* Total size, in bytes */
    blksize_t st_blksize;     /* Block size for filesystem I/O */
    blkcnt_t st_blocks;      /* Number of 512B blocks allocated */

    /* Since Linux 2.6, the kernel supports nanosecond
        precision for the following timestamp fields.
        For the details before Linux 2.6, see NOTES. */

    struct timespec st_atim;  /* Time of last access */
    struct timespec st_mtim;  /* Time of last modification */
    struct timespec st_ctim;  /* Time of last status change */

#define st_atime st_atim.tv_sec      /* Backward compatibility */
#define st_mtime st_mtim.tv_sec
#define st_ctime st_ctim.tv_sec
};
</code></pre>
<p>On success (meaning <em>pathname</em> exists) <code>stat</code> returns 0.  So on failure that <code>bnez $v0, stat_fail</code> would follow the branch to <code>stat_fail</code> . So we want to make sure <code>$v0</code> is 0 to continue normally. The desired control flow continues here:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/7/71fc3967b56f795efee35933c74f0c7817cef150.png" data-download-href="/uploads/short-url/ggmld1ZUPwB9rX00Q2XjcCIHHmE.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/7/71fc3967b56f795efee35933c74f0c7817cef150_2_690x359.png" alt="" data-base62-sha1="ggmld1ZUPwB9rX00Q2XjcCIHHmE" width="690" height="359" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/7/71fc3967b56f795efee35933c74f0c7817cef150_2_690x359.png, https://0x00sec.s3.amazonaws.com/original/2X/7/71fc3967b56f795efee35933c74f0c7817cef150.png 1.5x, https://0x00sec.s3.amazonaws.com/original/2X/7/71fc3967b56f795efee35933c74f0c7817cef150.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/7/71fc3967b56f795efee35933c74f0c7817cef150_2_10x10.png"></a></div><p></p>
<p>Here, besides some local variable saving the <em>sourceFile</em> is opened in read-only mode, indicated by the <code>0x0</code> flag provided to the <code>open(const char *pathname, int flags)</code> . The result/returned file descriptor of that call is saved to <code>0x128+fd_enc</code> . Similar to the <em>stat</em> routine before it is being checked whether <code>open(sourceFile, O_RDONLY)</code> is successful as indicated by <em><code>bltz  $v0, open_enc_fail</code> .</em> The branch to <code>open_enc_fail</code> is only taken if <code>$v0 &lt; 0</code> , which is only the case when the call to open fails ( <code>-1</code> is returned in this case). So assuming the open call succeeds we get to the next part with <code>$v0</code> holding the open file descriptor:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/3/31f7fe50b26077fb04d33fa06f57c411c216acf6.png" data-download-href="/uploads/short-url/782IBLkK457O2U3ppbw482iItx4.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/3/31f7fe50b26077fb04d33fa06f57c411c216acf6_2_690x277.png" alt="" data-base62-sha1="782IBLkK457O2U3ppbw482iItx4" width="690" height="277" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/3/31f7fe50b26077fb04d33fa06f57c411c216acf6_2_690x277.png, https://0x00sec.s3.amazonaws.com/optimized/2X/3/31f7fe50b26077fb04d33fa06f57c411c216acf6_2_1035x415.png 1.5x, https://0x00sec.s3.amazonaws.com/original/2X/3/31f7fe50b26077fb04d33fa06f57c411c216acf6.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/3/31f7fe50b26077fb04d33fa06f57c411c216acf6_2_10x10.png"></a></div><p></p>
<p>This basically attempts to use <code>void mmap(void addr, size_t length, int prot, int flags, int fd, off_t offset)</code> to map the just opened file into a kernel chosen memory region ( indicated by <code>*addr == 0</code> ) that is shared but read-only.</p>
<p>Such flags can easily be extracted from the header files on any system as follows:</p>
<pre><code class="lang-auto">&gt; egrep -i '(PROT_|MAP_)' /usr/include/x86_64-linux-gnu/bits/mman-linux.h
   implementation does not necessarily support PROT_EXEC or PROT_WRITE
   without PROT_READ.  The only guarantees are that no writing will be
   allowed without PROT_WRITE and no access will be allowed for PROT_NONE. */
#define PROT_READ	0x1		/* Page can be read.  */
#define PROT_WRITE	0x2		/* Page can be written.  */
#define PROT_EXEC	0x4		/* Page can be executed.  */
#define PROT_NONE	0x0		/* Page can not be accessed.  */
#define PROT_GROWSDOWN	0x01000000	/* Extend change to start of
#define PROT_GROWSUP	0x02000000	/* Extend change to start of
#define MAP_SHARED	0x01		/* Share changes.  */
#define MAP_PRIVATE	0x02		/* Changes are private.  */
# define MAP_SHARED_VALIDATE	0x03	/* Share changes and validate
# define MAP_TYPE	0x0f		/* Mask for type of mapping.  */
#define MAP_FIXED	0x10		/* Interpret addr exactly.  */
# define MAP_FILE	0
# ifdef __MAP_ANONYMOUS
#  define MAP_ANONYMOUS	__MAP_ANONYMOUS	/* Don't use a file.  */
#  define MAP_ANONYMOUS	0x20		/* Don't use a file.  */
# define MAP_ANON	MAP_ANONYMOUS
/* When MAP_HUGETLB is set bits [26:31] encode the log2 of the huge page size.  */
# define MAP_HUGE_SHIFT	26
# define MAP_HUGE_MASK	0x3f
</code></pre>
<p>In this case the <em>stat</em> call from earlier comes in handy once again as it is not just used to verify whether the provided file in <em>argv[1]</em> actually exists but the <em>statStruct</em> also contains the struct member <code>st_blocks</code> which can be used to fill in the required <code>size_t length</code> argument in <em>mmap</em> ! The return value of <em>mmap</em> is stored in <code>0x128+mmap_enc_fw($sp)</code> . Once again we have another ‘if’ condition type branching to check whether the memory mapping was successful. On success, <em>mmap</em> returns a pointer to the mapped area and branching on <code>beqz  $v0, mmap_fail</code> does not take places since <code>$v0</code> holds a value != 0. Following this is a final call to open:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/c/cf5d9ab566fc89a4ae299240d316e8dfe7df2980.png" data-download-href="/uploads/short-url/tArnJeJ9vGK66raP8eoKtEz1IyI.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/c/cf5d9ab566fc89a4ae299240d316e8dfe7df2980_2_690x316.png" alt="" data-base62-sha1="tArnJeJ9vGK66raP8eoKtEz1IyI" width="690" height="316" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/c/cf5d9ab566fc89a4ae299240d316e8dfe7df2980_2_690x316.png, https://0x00sec.s3.amazonaws.com/original/2X/c/cf5d9ab566fc89a4ae299240d316e8dfe7df2980.png 1.5x, https://0x00sec.s3.amazonaws.com/original/2X/c/cf5d9ab566fc89a4ae299240d316e8dfe7df2980.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/c/cf5d9ab566fc89a4ae299240d316e8dfe7df2980_2_10x10.png"></a></div><p></p>
<p>This only tries to open the predefined path ( <em>“/tmp/.firmware.orig”</em> ) as read+write with the new file descriptor being saved in <code>0x128+fd_tmp($sp)</code> . As usual, if the open fails branch to the fail portion of this function. On success this leads us to the final preparation step:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/4/400dac95f6eb268551955eec3b5b144af7981efc.png" data-download-href="/uploads/short-url/98DR075nLwrWbd1ganKkfuqek68.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/4/400dac95f6eb268551955eec3b5b144af7981efc_2_690x423.png" alt="" data-base62-sha1="98DR075nLwrWbd1ganKkfuqek68" width="690" height="423" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/4/400dac95f6eb268551955eec3b5b144af7981efc_2_690x423.png, https://0x00sec.s3.amazonaws.com/optimized/2X/4/400dac95f6eb268551955eec3b5b144af7981efc_2_1035x634.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/2X/4/400dac95f6eb268551955eec3b5b144af7981efc_2_1380x846.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/4/400dac95f6eb268551955eec3b5b144af7981efc_2_10x10.png"></a></div><p></p>
<ol>
<li>Here we’re preparing to set the correct size of the freshly opened file in the <em>/tmp/</em> location by first seeking to offset <code>stat.st_blocks -1</code> by invoking <code>lseek(fd_tmp, stat.st_blocks -1)</code> .</li>
<li>When the <em>lseek</em> succeeds we write a single 0 to the file at said offset. This allows us to easily and quickly create an " <em>empty</em> " file without having to write <em>N</em> bytes in total (where N== desired file size in bytes). Finally, we close, re-open and re-map the file with new permissions.</li>
</ol>
<p><em>Side note</em> : We do not need all these if-condition like checks realized through <code>beqz, bnez, ...</code> as we already know for sure the file exists by now…</p>
<h2 id="heading--inter-summ">Intermediate Summary:</h2>
<p>So far we didn’t manage to dig any deeper into the decryption routine because of all this file preparation stuff. Luckily, I can tease you as much as that we’re done with that now. As we have already roughly met the 15 minute mark for the reading time I’ll stop here. The very soon upcoming 2nd part of this write-up will solely focus on the cryptographic aspects of the scheme D-Link utilizes.</p>
<p>If, for any reason, you weren’t able to follow properly until here you can find the whole source code up to this point below. You should be able to compile it with <em>clang</em> / <em>gcc</em> via <code>clang/gcc -o imgdecrypt imgdecrypt.c -L/usr/local/lib -lssl -lcrypto -s</code> on any recent Debian based system. This in particular comes in handy if you’re new to MIPS and would much more prefer looking at x86 disassembly. The x86 reversing experience should be close to the original MIPS one only with some minor deviations due to platform differences.</p>
<pre><code class="lang-auto">#include &lt;arpa/inet.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;openssl/aes.h&gt;
#include &lt;openssl/pem.h&gt;
#include &lt;openssl/rsa.h&gt;
#include &lt;stddef.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

static RSA *grsa_struct = NULL;
static unsigned char iv[] = {0x98, 0xC9, 0xD8, 0xF0, 0x13, 0x3D, 0x06, 0x95,
                             0xE2, 0xA7, 0x09, 0xC8, 0xB6, 0x96, 0x82, 0xD4};
static unsigned char aes_in[] = {0xC8, 0xD3, 0x2F, 0x40, 0x9C, 0xAC,
                                 0xB3, 0x47, 0xC8, 0xD2, 0x6F, 0xDC,
                                 0xB9, 0x09, 0x0B, 0x3C};
static unsigned char aes_key[] = {0x35, 0x87, 0x90, 0x03, 0x45, 0x19,
                                  0xF8, 0xC8, 0x23, 0x5D, 0xB6, 0x49,
                                  0x28, 0x39, 0xA7, 0x3F};

unsigned char out[] = {0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
                       0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46};

int check_cert(char *pem, void *n) {
  OPENSSL_add_all_algorithms_noconf();

  FILE *pem_fd = fopen(pem, "r");
  if (pem_fd != NULL) {
    RSA *lrsa_struct[2];
    *lrsa_struct = RSA_new();
    if (!PEM_read_RSAPublicKey(pem_fd, lrsa_struct, NULL, n)) {
      RSA_free(*lrsa_struct);
      puts("Read RSA private key failed, maybe the password is incorrect.");
    } else {
      grsa_struct = *lrsa_struct;
    }
    fclose(pem_fd);
  }
  if (grsa_struct != NULL) {
    return 0;
  } else {
    return -1;
  }
}

int aes_cbc_encrypt(size_t length, unsigned char *key) {
  AES_KEY dec_key;
  AES_set_decrypt_key(aes_key, sizeof(aes_key) * 8, &amp;dec_key);
  AES_cbc_encrypt(aes_in, key, length, &amp;dec_key, iv, AES_DECRYPT);
  return 0;
}

int call_aes_cbc_encrypt(unsigned char *key) {
  aes_cbc_encrypt(0x10, key);
  return 0;
}

int actual_decryption(char *sourceFile, char *tmpDecPath, unsigned char *key) {
  int ret_val = -1;
  size_t st_blocks = -1;
  struct stat statStruct;
  int fd = -1;
  int fd2 = -1;
  void *ROM = 0;
  int *RWMEM;
  off_t seek_off;
  unsigned char buf_68[68];
  int st;

  memset(&amp;buf_68, 0, 0x40);
  memset(&amp;statStruct, 0, 0x90);
  st = stat(sourceFile, &amp;statStruct);
  if (st == 0) {
    fd = open(sourceFile, O_RDONLY);
    st_blocks = statStruct.st_blocks;
    if (((-1 &lt; fd) &amp;&amp;
         (ROM = mmap(0, statStruct.st_blocks, 1, MAP_SHARED, fd, 0),
          ROM != 0)) &amp;&amp;
        (fd2 = open(tmpDecPath, O_RDWR | O_NOCTTY, 0x180), -1 &lt; fd2)) {
      seek_off = lseek(fd2, statStruct.st_blocks - 1, 0);
      if (seek_off == statStruct.st_blocks - 1) {
        write(fd2, 0, 1);
        close(fd2);
        fd2 = open(tmpDecPath, O_RDWR | O_NOCTTY, 0x180);
        RWMEM = mmap(0, statStruct.st_blocks, PROT_EXEC | PROT_WRITE,
                     MAP_SHARED, fd2, 0);
        if (RWMEM != NULL) {
          ret_val = 0;
        }
      }
    }
  }
  puts("EOF part 2.1!\n");
  return ret_val;
}

int decrypt_firmware(int argc, char **argv) {
  int ret;
  unsigned char key[] = {0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
                         0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46};
  char *ppem = "/tmp/public.pem";
  int loopCtr = 0;
  if (argc &lt; 2) {
    printf("%s &lt;sourceFile&gt;\r\n", argv[0]);
    ret = -1;
  } else {
    if (2 &lt; argc) {
      ppem = (char *)argv[2];
    }
    int cc = check_cert(ppem, (void *)0);
    if (cc == 0) {
      call_aes_cbc_encrypt((unsigned char *)&amp;key);

      printf("key: ");
      while (loopCtr &lt; 0x10) {
        printf("%02X", *(key + loopCtr) &amp; 0xff);
        loopCtr += 1;
      }
      puts("\r");
      ret = actual_decryption((char *)argv[1], "/tmp/.firmware.orig",
                              (unsigned char *)&amp;key);

      if (ret == 0) {
        unlink(argv[1]);
        rename("/tmp/.firmware.orig", argv[1]);
      }
      RSA_free(grsa_struct);
    } else {
      ret = -1;
    }
  }
  return ret;
}

int encrypt_firmware(int argc, char **argv) { return 0; }

int main(int argc, char **argv) {
  int ret;
  char *str_f = strstr(*argv, "decrypt");

  if (str_f != NULL) {
    ret = decrypt_firmware(argc, argv);

  } else {
    ret = encrypt_firmware(argc, argv);
  }

  return ret;
}
</code></pre>
<p>‌</p>
<pre><code class="lang-auto">&gt; ./imgdecrypt
./imgdecrypt &lt;sourceFile&gt;
&gt; ./imgdecrypt testFile
key: C05FBF1936C99429CE2A0781F08D6AD8
EOF part 2.1!
</code></pre>
<p>The next part 2.2 will be online shortly and linked here as soon as it is available.<br>
Thanks for reading and if you have any questions or remarks feel free to hit me up :)!</p>
<p>Note: If you have trouble reading the IDA screenshots here I recommend <a href="https://0x434b.dev/breaking-the-d-link-dir3060-firmware-encryption-static-analysis-of-the-decryption-routine-part-2-1/">reading the mirror on my blog</a> where these screenshots scale better!</p>
<h2>&lt;&lt; <a href="https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-recon-part-1/21943/">Part 1</a>
</h2>
<h2>&gt;&gt; <a href="https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-static-analysis-of-the-decryption-routine-part-2-2/22260">Part 2.2</a>
</h2>
          <p><a href="https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-static-analysis-of-the-decryption-routine-part-2-1/22099/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-static-analysis-of-the-decryption-routine-part-2-1/22099/1</link>
        <pubDate>Mon, 06 Jul 2020 10:42:23 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-22099-1</guid>
        <source url="https://0x00sec.org/t/breaking-the-d-link-dir3060-firmware-encryption-static-analysis-of-the-decryption-routine-part-2-1/22099.rss">Breaking the D-Link DIR3060 Firmware Encryption - Static analysis of the decryption routine - Part 2.1</source>
      </item>
  </channel>
</rss>
