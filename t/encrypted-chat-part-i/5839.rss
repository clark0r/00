<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Encrypted Chat: Part I</title>
    <link>https://0x00sec.org/t/encrypted-chat-part-i/5839</link>
    <description>The Project
=========
I started programming an encrypted chat client and server to learn more about encryption and how it&#39;s implemented in network protocols (e.g. [SSH](https://en.wikipedia.org/wiki/Secure_Shell) or [HTTPs](https://en.wikipedia.org/wiki/HTTPS) over [TLS](https://en.wikipedia.org/wiki/Transport_Layer_Security)). Now that it&#39;s almost complete, I wanted to share what I learned with you.

I&#39;m splitting up this series into two posts. The first, a.k.a. this one, will cover the concepts needed to understand how the program works. The second will dive into the code and connect these concepts with what the program is actually doing. Props to @oaktree for suggesting this format.

Let&#39;s get started. 

Part One: The Conceptual Overview
------------------------------------------

&gt; The objective is to establish a shared key for encrypting and decrypting messages sent between a client and a server.

To set up a chat room, a client must be able to securely send messages to a server—and vice versa. [Symmetric encryption](https://en.wikipedia.org/wiki/Symmetric-key_algorithm), which uses the same key for encrypting and decrypting messages, is a really good candidate for this task. However, to do so, the two parties must agree upon a key.

_**Remember: encryption keys are just really big numbers_

So how can we get two computers to have the same big number? We can&#39;t just send it over the wire... that would defeat the purpose of encrypting in the first place, since an eavesdropper could just steal the key and decrypt everything. Instead, we&#39;ll use something called the [Diffie-Hellman Key Exchange](https://en.wikipedia.org/wiki/Diffie–Hellman_key_exchange).

Step 1: Diffie-Hellman Key Exchange
-------------------------------------------------
_A really clever way of generating a shared key._

Diffie-Hellman (or DH for short) uses finite cyclic groups to have two entities come to the same number without ever explicitly sharing it. Many implementations use the multiplicative group of integers modulo _p_, where _p_ is a prime number, for their finite cyclic group. However, other options such as elliptic curves also exist (you&#39;re using one right now to view this webpage!).

Crazy maths aside, the actual concept behind the exchange isn&#39;t all that hard to grasp, and the mathmatical operations necessary to perform it are grade-level too. Here&#39;s the diagram listed on Wikipedia:

&gt; Illustration of the idea behind Diffie-Hellman Key Exchange

![](upload://3t485Do7kYfAw6HMsMv5klePtsq.png)

In our case, the &quot;common paint&quot; is a really large prime modulus _p_ (at least 2048-bit) and prime base _g_. These values can be publicly shared without threatening our security. The &quot;secret colors&quot; are just random numbers generated by each participant and kept private. The whole thing works because of the following:

&gt; (g^a % p)^b % p = (g^b % p)^a % p

Where _a_ and _b_ are the &quot;secret colors&quot; and % is the modulus operator (which is just dividing and returning the remainder). Why are these expressions equal, you ask? I am not qualified to tell you. I suppose it&#39;s sort of like asking why 2 + 2 = 4, except much harder to wrap your head around—it&#39;s just the way it is. If anyone knows of a good explanation of this equation, please leave a comment as I&#39;d love to understand it better myself. I haven&#39;t studied group theory yet, but maybe someone who has can step in here.

It&#39;s okay if you don&#39;t fully understand conceptually what&#39;s happening here, I&#39;ll go over it in more detail when we look at the code. The important thing is we now have the same number: once we have that, we can move on to the next step.

Step 2: AES Encryption
-------------------------------

_The Advanced Encryption Standard_

[AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard) is a widely used symmetric encryption algorithm for its speed and security. Unless a system using it is leaking data (e.g. through a poor implementation), the only way to crack it is via brute force. We&#39;ll be using AES-256 in [Cipher Block Chaining](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_Block_Chaining_(CBC)) mode, which relies on a 256-bit key (which is also why you&#39;ll see we&#39;ll be passing our shared big number through SHA-256 to standardize it to 256 bits in length) and causes each block in the series to rely on the previous one.

![AES-SubBytes|690x357](upload://iHVi5ZOw6KTnixLvoQ86ZCgIK8A.png)

In this mode, we&#39;ll have to start our messages with an [initialization vector](https://en.wikipedia.org/wiki/Initialization_vector) which serves as a starting block in our chain to scramble each successive block. 

&gt; In CBC mode, each block of plaintext is XORed with the previous ciphertext block before being encrypted. This way, each ciphertext block depends on all plaintext blocks processed up to that point.
&gt; _This is what the IV is for, as you cannot XOR a previous cipher-text if you haven’t even started ciphering_

(Thanks to @pry0cc for this clarification)

Unlike the encryption key, this value can be shared publicly. It&#39;s used to make reverse-engineering the key basically impossible, as encrypting &quot;hello&quot; twice with the same key but two different initialization vectors will come out completely different. But we have to be careful, reusing the same IV can degrade the security of our communications. See [WEP](https://en.wikipedia.org/wiki/Wired_Equivalent_Privacy) for how this can go wrong.

We also need to add in some extra characters, or &quot;padding&quot;, so that our message is a multiple of the AES block size in length. Tagging on spaces to the end of the message is easy to strip on the other end, so we&#39;ll use that. Thus, the first block will be our IV and each successive block will belong to our message, including any padding.

**That&#39;s it!** We can now send encrypted messages back and forth between the server and the client. The client will submit encrypted chat messages to the server, which will then decrypt the messages and re-encrypt them with each client&#39;s key that it will broadcast to. To anyone eavesdropping over the network, each message will look entirely different and none of the contents will be decipherable.

Wrapping It Up
--------------------
I hope you enjoyed this conceptual overview of my encrypted chat program. Join me next time when we look over some key points of the code and see exactly how these concepts were implemented. The post should be up soon, but for now you&#39;re welcome to take a sneak peek at the source on GitHub: [https://github.com/spec-sec/SecureChat](https://github.com/spec-sec/SecureChat). If you have any suggestions or clarifications, please leave a comment. Thanks for reading!

~ spec

_Next: [Part II](https://0x00sec.org/t/encrypted-chat-part-ii/5958)_</description>
    
    <lastBuildDate>Mon, 19 Mar 2018 18:01:51 +0000</lastBuildDate>
    <category>Programming</category>
    <atom:link href="https://0x00sec.org/t/encrypted-chat-part-i/5839.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Encrypted Chat: Part I</title>
        <dc:creator><![CDATA[system]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 30 days. New replies are no longer allowed.</p>
          <p><a href="https://0x00sec.org/t/encrypted-chat-part-i/5839/8">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/encrypted-chat-part-i/5839/8</link>
        <pubDate>Fri, 13 Apr 2018 05:09:16 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-5839-8</guid>
        <source url="https://0x00sec.org/t/encrypted-chat-part-i/5839.rss">Encrypted Chat: Part I</source>
      </item>
      <item>
        <title>Encrypted Chat: Part I</title>
        <dc:creator><![CDATA[spec]]></dc:creator>
        <description><![CDATA[
            <p>Thank you for elaborating on that, it’s a crucial part of understanding why the IV is necessary. Can’t wait to get the next post out, you have some great insight.</p>
          <p><a href="https://0x00sec.org/t/encrypted-chat-part-i/5839/7">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/encrypted-chat-part-i/5839/7</link>
        <pubDate>Mon, 19 Mar 2018 18:01:51 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-5839-7</guid>
        <source url="https://0x00sec.org/t/encrypted-chat-part-i/5839.rss">Encrypted Chat: Part I</source>
      </item>
      <item>
        <title>Encrypted Chat: Part I</title>
        <dc:creator><![CDATA[pry0cc]]></dc:creator>
        <description><![CDATA[
            <p>I am loving this series.</p>
<p>Diffie-Hellman was quite straightforward to understand, especially with that diagram. However I got a little lost with the cipher block chaining concept. After reading the wikipedia article, it makes a lot more sense. To anybody that got lost in that bit, it works by:</p>
<aside class="quote no-group">
<blockquote>
<p>In CBC mode, each block of plaintext is XORed with the previous ciphertext block before being encrypted. This way, each ciphertext block depends on all plaintext blocks processed up to that point.</p>
</blockquote>
</aside>
<p>This is what the IV is for, you cannot XOR a previous ciphertext, if you haven’t even started ciphering yet, right?</p>
<p>This is a banging article <a class="mention" href="https://0x00sec.org/u/spec">@spec</a>, good job! I am looking forward to seeing how this works in code. Turning math into code always makes things easier to understand IMO. Coding really is just practical mathematics.</p>
          <p><a href="https://0x00sec.org/t/encrypted-chat-part-i/5839/6">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/encrypted-chat-part-i/5839/6</link>
        <pubDate>Mon, 19 Mar 2018 11:14:02 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-5839-6</guid>
        <source url="https://0x00sec.org/t/encrypted-chat-part-i/5839.rss">Encrypted Chat: Part I</source>
      </item>
      <item>
        <title>Encrypted Chat: Part I</title>
        <dc:creator><![CDATA[dtm]]></dc:creator>
        <description><![CDATA[
            <p>Would that require a <em>signed</em> certificate? Is it possible that a MitM send you their false, unsigned certificate to pretend to be the server? Unless you know 100% what the legitimate certificate looks like.</p>
          <p><a href="https://0x00sec.org/t/encrypted-chat-part-i/5839/5">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/encrypted-chat-part-i/5839/5</link>
        <pubDate>Thu, 15 Mar 2018 01:00:02 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-5839-5</guid>
        <source url="https://0x00sec.org/t/encrypted-chat-part-i/5839.rss">Encrypted Chat: Part I</source>
      </item>
      <item>
        <title>Encrypted Chat: Part I</title>
        <dc:creator><![CDATA[Joe_Schmoe]]></dc:creator>
        <description><![CDATA[
            <p>Kind of? The ability to check if you are connected to the correct server and people you are talking to would be nice.</p>
          <p><a href="https://0x00sec.org/t/encrypted-chat-part-i/5839/4">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/encrypted-chat-part-i/5839/4</link>
        <pubDate>Wed, 14 Mar 2018 18:21:22 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-5839-4</guid>
        <source url="https://0x00sec.org/t/encrypted-chat-part-i/5839.rss">Encrypted Chat: Part I</source>
      </item>
      <item>
        <title>Encrypted Chat: Part I</title>
        <dc:creator><![CDATA[oaktree]]></dc:creator>
        <description><![CDATA[
            <p>Is that like fingerprinting or something?</p>
          <p><a href="https://0x00sec.org/t/encrypted-chat-part-i/5839/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/encrypted-chat-part-i/5839/3</link>
        <pubDate>Wed, 14 Mar 2018 15:49:49 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-5839-3</guid>
        <source url="https://0x00sec.org/t/encrypted-chat-part-i/5839.rss">Encrypted Chat: Part I</source>
      </item>
      <item>
        <title>Encrypted Chat: Part I</title>
        <dc:creator><![CDATA[Joe_Schmoe]]></dc:creator>
        <description><![CDATA[
            <p>Nice project. I’d suggest adding a way to verify the identity of people you are chatting with, something like SSL certificates.</p>
          <p><a href="https://0x00sec.org/t/encrypted-chat-part-i/5839/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/encrypted-chat-part-i/5839/2</link>
        <pubDate>Wed, 14 Mar 2018 13:51:37 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-5839-2</guid>
        <source url="https://0x00sec.org/t/encrypted-chat-part-i/5839.rss">Encrypted Chat: Part I</source>
      </item>
      <item>
        <title>Encrypted Chat: Part I</title>
        <dc:creator><![CDATA[spec]]></dc:creator>
        <description><![CDATA[
            <h1>The Project</h1>
<p>I started programming an encrypted chat client and server to learn more about encryption and how it’s implemented in network protocols (e.g. <a href="https://en.wikipedia.org/wiki/Secure_Shell" rel="noopener nofollow ugc">SSH</a> or <a href="https://en.wikipedia.org/wiki/HTTPS" rel="noopener nofollow ugc">HTTPs</a> over <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security" rel="noopener nofollow ugc">TLS</a>). Now that it’s almost complete, I wanted to share what I learned with you.</p>
<p>I’m splitting up this series into two posts. The first, a.k.a. this one, will cover the concepts needed to understand how the program works. The second will dive into the code and connect these concepts with what the program is actually doing. Props to <a class="mention" href="https://0x00sec.org/u/oaktree">@oaktree</a> for suggesting this format.</p>
<p>Let’s get started.</p>
<h2>Part One: The Conceptual Overview</h2>
<blockquote>
<p>The objective is to establish a shared key for encrypting and decrypting messages sent between a client and a server.</p>
</blockquote>
<p>To set up a chat room, a client must be able to securely send messages to a server—and vice versa. <a href="https://en.wikipedia.org/wiki/Symmetric-key_algorithm" rel="noopener nofollow ugc">Symmetric encryption</a>, which uses the same key for encrypting and decrypting messages, is a really good candidate for this task. However, to do so, the two parties must agree upon a key.</p>
<p><em>**Remember: encryption keys are just really big numbers</em></p>
<p>So how can we get two computers to have the same big number? We can’t just send it over the wire… that would defeat the purpose of encrypting in the first place, since an eavesdropper could just steal the key and decrypt everything. Instead, we’ll use something called the <a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange" rel="noopener nofollow ugc">Diffie-Hellman Key Exchange</a>.</p>
<h2>Step 1: Diffie-Hellman Key Exchange</h2>
<p><em>A really clever way of generating a shared key.</em></p>
<p>Diffie-Hellman (or DH for short) uses finite cyclic groups to have two entities come to the same number without ever explicitly sharing it. Many implementations use the multiplicative group of integers modulo <em>p</em>, where <em>p</em> is a prime number, for their finite cyclic group. However, other options such as elliptic curves also exist (you’re using one right now to view this webpage!).</p>
<p>Crazy maths aside, the actual concept behind the exchange isn’t all that hard to grasp, and the mathmatical operations necessary to perform it are grade-level too. Here’s the diagram listed on Wikipedia:</p>
<blockquote>
<p>Illustration of the idea behind Diffie-Hellman Key Exchange</p>
</blockquote>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/1/184fa9035c24ffa1250e324b61acaa3915f7757e.png" data-download-href="/uploads/short-url/3t485Do7kYfAw6HMsMv5klePtsq.png?dl=1" title="" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/1/184fa9035c24ffa1250e324b61acaa3915f7757e_2_345x500.png" alt="" data-base62-sha1="3t485Do7kYfAw6HMsMv5klePtsq" width="345" height="500" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/1/184fa9035c24ffa1250e324b61acaa3915f7757e_2_345x500.png, https://0x00sec.s3.amazonaws.com/original/2X/1/184fa9035c24ffa1250e324b61acaa3915f7757e.png 1.5x, https://0x00sec.s3.amazonaws.com/original/2X/1/184fa9035c24ffa1250e324b61acaa3915f7757e.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/1/184fa9035c24ffa1250e324b61acaa3915f7757e_2_10x10.png"></a></div><p></p>
<p>In our case, the “common paint” is a really large prime modulus <em>p</em> (at least 2048-bit) and prime base <em>g</em>. These values can be publicly shared without threatening our security. The “secret colors” are just random numbers generated by each participant and kept private. The whole thing works because of the following:</p>
<blockquote>
<p>(g^a % p)^b % p = (g^b % p)^a % p</p>
</blockquote>
<p>Where <em>a</em> and <em>b</em> are the “secret colors” and % is the modulus operator (which is just dividing and returning the remainder). Why are these expressions equal, you ask? I am not qualified to tell you. I suppose it’s sort of like asking why 2 + 2 = 4, except much harder to wrap your head around—it’s just the way it is. If anyone knows of a good explanation of this equation, please leave a comment as I’d love to understand it better myself. I haven’t studied group theory yet, but maybe someone who has can step in here.</p>
<p>It’s okay if you don’t fully understand conceptually what’s happening here, I’ll go over it in more detail when we look at the code. The important thing is we now have the same number: once we have that, we can move on to the next step.</p>
<h2>Step 2: AES Encryption</h2>
<p><em>The Advanced Encryption Standard</em></p>
<p><a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard" rel="noopener nofollow ugc">AES</a> is a widely used symmetric encryption algorithm for its speed and security. Unless a system using it is leaking data (e.g. through a poor implementation), the only way to crack it is via brute force. We’ll be using AES-256 in <a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_Block_Chaining_(CBC)" rel="noopener nofollow ugc">Cipher Block Chaining</a> mode, which relies on a 256-bit key (which is also why you’ll see we’ll be passing our shared big number through SHA-256 to standardize it to 256 bits in length) and causes each block in the series to rely on the previous one.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/8/831e37fc58c74011056a37a2b8261483f29d3fec.png" alt="AES-SubBytes" data-base62-sha1="iHVi5ZOw6KTnixLvoQ86ZCgIK8A" width="690" height="357"></p>
<p>In this mode, we’ll have to start our messages with an <a href="https://en.wikipedia.org/wiki/Initialization_vector" rel="noopener nofollow ugc">initialization vector</a> which serves as a starting block in our chain to scramble each successive block.</p>
<blockquote>
<p>In CBC mode, each block of plaintext is XORed with the previous ciphertext block before being encrypted. This way, each ciphertext block depends on all plaintext blocks processed up to that point.<br>
<em>This is what the IV is for, as you cannot XOR a previous cipher-text if you haven’t even started ciphering</em></p>
</blockquote>
<p>(Thanks to <a class="mention" href="https://0x00sec.org/u/pry0cc">@pry0cc</a> for this clarification)</p>
<p>Unlike the encryption key, this value can be shared publicly. It’s used to make reverse-engineering the key basically impossible, as encrypting “hello” twice with the same key but two different initialization vectors will come out completely different. But we have to be careful, reusing the same IV can degrade the security of our communications. See <a href="https://en.wikipedia.org/wiki/Wired_Equivalent_Privacy" rel="noopener nofollow ugc">WEP</a> for how this can go wrong.</p>
<p>We also need to add in some extra characters, or “padding”, so that our message is a multiple of the AES block size in length. Tagging on spaces to the end of the message is easy to strip on the other end, so we’ll use that. Thus, the first block will be our IV and each successive block will belong to our message, including any padding.</p>
<p><strong>That’s it!</strong> We can now send encrypted messages back and forth between the server and the client. The client will submit encrypted chat messages to the server, which will then decrypt the messages and re-encrypt them with each client’s key that it will broadcast to. To anyone eavesdropping over the network, each message will look entirely different and none of the contents will be decipherable.</p>
<h2>Wrapping It Up</h2>
<p>I hope you enjoyed this conceptual overview of my encrypted chat program. Join me next time when we look over some key points of the code and see exactly how these concepts were implemented. The post should be up soon, but for now you’re welcome to take a sneak peek at the source on GitHub: <a href="https://github.com/spec-sec/SecureChat" rel="noopener nofollow ugc">https://github.com/spec-sec/SecureChat</a>. If you have any suggestions or clarifications, please leave a comment. Thanks for reading!</p>
<p>~ spec</p>
<p><em>Next: <a href="https://0x00sec.org/t/encrypted-chat-part-ii/5958">Part II</a></em></p>
          <p><a href="https://0x00sec.org/t/encrypted-chat-part-i/5839/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/encrypted-chat-part-i/5839/1</link>
        <pubDate>Wed, 14 Mar 2018 05:09:14 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-5839-1</guid>
        <source url="https://0x00sec.org/t/encrypted-chat-part-i/5839.rss">Encrypted Chat: Part I</source>
      </item>
  </channel>
</rss>
