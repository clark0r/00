<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Anti-virus Exploitation: Malwarebytes 4.0.4 - Protection Not Found - Hijacking Malwarebytes via COM IPC</title>
    <link>https://0x00sec.org/t/anti-virus-exploitation-malwarebytes-4-0-4-protection-not-found-hijacking-malwarebytes-via-com-ipc/18766</link>
    <description># Hijacking Malwarebytes via COM IPC

[Attacking K7 Security](https://0x00sec.org/t/anti-virus-exploitation-local-privilege-escalation-in-k7-security-cve-2019-16897/17655) was my first attempt at discovering, analysing, and exploiting software at the protocol level. It made me curious as to how other vendors designed and developed their inter-process communication (IPC) methods between the untrusted client (the user-controlled software; usually the GUI) and the high integrity service process. Here is the diagram that shows the interaction between these two components again, for completeness:

https://0x00sec.s3.amazonaws.com/original/2X/6/6a53340a79f1f087af9d10f11f8a81408927a8f0.jpeg

This article will be about diving into reverse engineering the communication protocol used in Malwarebytes and the issues that I identified as a result of bypassing the intended (and assumed?) approach towards controlling functionality.

**Disclaimer**: I do not claim to know everything on the topics discussed here as fact, this is purely what I have inferred from my research. Especially if the COM information is inaccurate in any way, shape or form, please let me know and I will fix it as soon as possible. PoC code snippets has been withheld until the vendor applies a patch or until a reasonable amount of time has passed.

## Recommended Pre-requisite Knowledge
* Windows API
* C/C++ and Intel Assembly
* Inter-process communication
    * Named Pipes
    * Component Object Model (COM)

----

## Discovering IPC Methods

There are [multiple ways with which software can perform IPC](https://docs.microsoft.com/en-us/windows/win32/ipc/interprocess-communications). How do we figure out which ones Malwabytes uses? Let&#39;s start with analysing the imported functions of the GUI and service executables in IDA. Starting with the service executable, `MBAMService.exe`, we can identify named pipe functions: 

![Named Pipe API|643x99, 100%](upload://mj2OA9PXpyvsKLXdIH4NFrD0wRm.png) 

While we&#39;re here, let&#39;s see if we can extract the pipe name. [`CreateNamedPipe` ](https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea) is documented to receive the name of the pipe:

![CreateNamedPipe doc|575x500](upload://eiKtb86A3aXYCXASFKhobq8RYyy.png) 

Following the references of `CreateNamedPipeW` will lead us to:

![Named pipe name|488x355](upload://xk5li1epKsokXLCgiEjT7pXyrAn.png) 

But what does `MBLG` mean...? If we take a look at the `ConnectNamedPipe` references, there are strings which will give us a hint:

![MBLG hint?|690x438](upload://x9qGLt979LxmR34jnBDpEVIhFrS.png) 

Perhaps _MalwareBytes License Generator_? Nevertheless, we&#39;ve identified one of the IPC techniques. 

In the documentation for the available IPC methods, it states that &quot;the foundation of OLE is the Component Object Model (COM)&quot;. If we look into the `ole32` library imports, we can see this:

![COM imports|542x303](upload://elEShS3TVmVvmxHCwHuNy4Y30FC.png) 

The [`CoInitializeEx`](https://docs.microsoft.com/en-us/windows/win32/api/combaseapi/nf-combaseapi-coinitializeex) documentation states:

[quote=&quot;MSDN&quot;]
Initializes the COM library for use by the calling thread...
[/quote]

This verifies that the service process also uses COM IPC.

What about the GUI executable, `mbam.exe`? Let&#39;s look for the same IPC methods beginning with named pipes:

![Named pipe imports|501x62](upload://ckIC6HHWJO5tmmKlNsqNUigo1EG.png) 

[`CallNamedPipe`](https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-callnamedpipea) is documented to receive the target pipe name:

![CallNamedPipe docs|677x454](upload://bP8p0KXQhKL6exjQptdkRU2ASgG.png) 

Again, we will follow the reference to that function and again, we&#39;ll see the `\\.\pipe\MBLG` string:

![Named pipe name|416x343](upload://l9Bny2KuV7GT0J1rjbiYR628JjQ.png) 

This time, it&#39;s accompanied with another string `NeedAKey` which is passed into the input buffer for the service process.

`mbam.exe` also imports the COM functions from the `ole32` library:

![COM imports|502x350](upload://A3vOZ7dhjjEbn2lYL1hD2RMk3lN.png) 

## Reverse Engineering the COM Protocol

One of the many amazing tools released by [James Foreshaw](https://twitter.com/tiraniddo) is [OleViewDotNet](https://github.com/tyranid/oleviewdotnet). Using this, we can discover COM objects available on a system.

Firing up OleViewDotNet, we can list all the [COM classes exposed through their CLSIDs](https://docs.microsoft.com/en-us/windows/win32/com/com-class-objects-and-clsids). Filtering by servers, we can see that the `MBAMService.exe` executable is packaged with [type libraries](https://docs.microsoft.com/en-us/windows/win32/midl/com-dcom-and-type-libraries) that define protocol information in human-readable and code form.

Here is the `RTPController` interface:

![RTPController interface|690x348](upload://uiw92dlVbNCVf5MqAFX2Lh3fqvC.png) 

and here is the `LicenseController` interface:

![LicenseController interface|660x500](upload://aSHxhlPhNdeLpfLglKjTVs3aaGP.png) 

How can we extract this information so we can use it? The OleViewDotNet tool is based on Microsoft&#39;s OleView which can pull the type library information into a compilable [Interface Definition Language](https://docs.microsoft.com/en-us/windows/win32/midl/interface-definition-idl-file) (IDL) file.

![AEController IDL file|536x500](upload://c4QxV6eBOFq2lIP4sf07tKn4itW.png) 

Notice that at the top of the generated IDL file there is a `typelib filename: 12` which probably indicates that there are _at least_ 12 type libraries. After extracting all of the IDL files, we should have fourteen files:

![All IDL files|173x302](upload://2S89u9hIXnS0dxLuTKgciAAGiJv.png) 

## Compiling IDL Files

To compile these into code, we can use Microsoft&#39;s `midl.exe` utility like so:

```makefile
midl /out &lt;output directory path&gt; /header &lt;header output file path&gt; &lt;path to IDL file&gt;
```

But we have to do this is a specific order. Looking back at the generated `AEControllerCOMLib` IDL file in `OleView`, there are dependencies specified with `importlib(&quot;&lt;file&gt;&quot;)`. These are the other compiled IDL files used by Malwarebytes. We must first find and compile the IDL file with none of these dependencies and then gradually work our way up until we have all of the dependencies required to compile all of the other IDL files. Let&#39;s take a brief look at an example.

The first file we need to compile is the `LogController`. We can see that it only has the `stdole2.tlb` type library as its dependency which is provided by Microsoft.

![LogController IDL file|556x499](upload://oSNisuWFwpOV2SMWcwS024iJ7z8.png) 

If we compile this using `midl`, we&#39;ll get three files (depending on how you named them on the command line):

```makefile
LogController.h
LogController.tlb
LogController_i.c
```

The header file will contain the definition of all of the enums, structs, and class methods for the COM object:

![LogController.h|378x500](upload://9R2luho8LqCUdeQzExDGnd94Om5.png) 

 The C file will contain the [interface identifiers](https://docs.microsoft.com/en-us/office/client-developer/outlook/mapi/iid) (IID) and CLSIDs to query and use the COM object:

![LogController_i.c|541x500](upload://tIeFESRmbAg8zIul9k3ouIonEcE.png) 

 The type library (`tlb`) file is required for dependencies to compile the other IDL files. This file name should correspond with what&#39;s specified in the IDL file&#39;s `typelib filename` - in this case, it&#39;s just `2`.

The next IDL to be compiled is the `PoliciesController`. The IDL file states that its dependencies are `stdole2.tlb` and `2`, both of which we have.

![PoliciesController IDL file|559x500](upload://fZVw8V8J532qRWCQFqiAsP4ZXRo.png) 

Now we just repeat the steps as before with the `LogController` and the rest of the other IDL files.

## Querying Malwarebytes&#39; COM Object Classes

To figure out how we can interact with the COM classes, we can look at how `mbam.exe` does it using [Rohitab&#39;s API Monitor](http://www.rohitab.com/downloads#API_Monitor_v2_Alpha). With this information, hopefully we can re-implement it ourselves. We&#39;ll set the filter to monitor for COM and Pipe API calls only in the `mbam.exe` module and it should look like this when monitoring the startup of the application:

![API Monitor|690x364](upload://ybunjjcg8BhNWEFaUyww4ZReVIP.png)  

Let&#39;s ignore the first call to `CoCreateInstance`, because it fails, and move onto `CallNamedPipeW`. We saw this call earlier with the `NeedAKey` string in the input buffer. Here is what the output buffer contains:

![CallNamedPipeW|690x203](upload://m12QhYXLFA1D6Zf2YzHYqP9VzSO.png) 

Looks like a randomly-generated sequence of wide ASCII characters (we&#39;ll call this the &quot;license string&quot;), and we can see it used in calls to [`SysAllocStringLen`](https://docs.microsoft.com/en-us/windows/win32/api/oleauto/nf-oleauto-sysallocstringlen) and [`SysFreeString`](https://docs.microsoft.com/en-us/windows/win32/api/oleauto/nf-oleauto-sysfreestring) which returns a [`BSTR`](https://docs.microsoft.com/en-us/cpp/atl-mfc-shared/allocating-and-releasing-memory-for-a-bstr?view=vs-2019) type of the input string and frees it, respectively. The `BSTR` type is used in passing data in COM objects. The license string is also used in [`IClassFactory2::CreateInstanceLic`](https://docs.microsoft.com/en-us/windows/win32/api/ocidl/nf-ocidl-iclassfactory2-createinstancelic) which is documented as so:

[quote=&quot;MSDN&quot;]
Creates an instance of the licensed object for the specified license key. This method is the only possible means to create an object on an otherwise unlicensed machine.
[/quote]

That&#39;s good to know! But how do we get here and what is this `IClassFactory2` used for? Let&#39;s jump back to the call to [`CoGetClassObject`](https://docs.microsoft.com/en-us/windows/win32/api/combaseapi/nf-combaseapi-cogetclassobject) and its arguments. The `MBAMServiceController` CLSID is specified to retrieve its corresponding pointer to its object which is returned as an [`IClassFactory`](https://docs.microsoft.com/en-us/windows/win32/api/unknwn/nn-unknwn-iclassfactory). The [`IClassFactory::QueryInterface`](https://docs.microsoft.com/en-us/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(q)) method is then used to obtain the `IClassFactory2` interface. But what&#39;s the point in all of this? As it turns out - after a lot of experimentation - that the `IClassFactory2::CreateInstanceLic` interface can be used to acquire a pointer to the `IMBAMServiceController` interface. Using this interface, we can gain access to the COM object classes exposed by Malwarebytes, i.e. the `RTPController` class, the `LicenseController` class, etc. So just to summarise this section, here is what the flow looks like:

```makefile
1. Get a license string with CallNamedPipe(&quot;NeedAKey&quot;),
2. Get an IClassFactory interface with CoGetClassObject(CLSID_MBAMServiceControllerClass)
3. Get an IClassFactory2 interface with IClassFactory::QueryInterface(IID_IClassFactory2),
4. Get a BSTR for the license string with SysAllocStringLen(&quot;LicenseKey&quot;), 
5. Get an IMBAMServiceController interface with IClassFactory2::CreateInstanceLic(&quot;BSTR_LicenseString&quot;),
6. Get the desired MBAM COM class&#39;s interface with the IMBAMServiceController interface.
```

## Bypassing Security Checks

Of course it wouldn&#39;t be so easy. Malwarebytes&#39; service implements some verification on the process that requests a license string on `ConnectNamedPipe`:

![Verification|425x400](upload://1eCEtxpIVIuzXfH6o4tdpXiv4VW.png) 

We can see it in log files too:

![Verification logs|690x204](upload://c5Ku5za8PZZt4CMv4JzvrlRZtoy.png) 

To use my time effectively, I opted to try a few methods to try to bypass the verification checks before digging into the assembly. I&#39;ve seen these problems exist in other products so I had a few ideas. The immediate method that came into my head was to do process hollowing on `mbam.exe`. However, I don&#39;t believe I can get that to work on the 64-bit architecture since I had never gotten it to work before. Perhaps it could work in the case of 32-bit? The next method was to append the signature using [SigThief](https://github.com/secretsquirrel/SigThief). Unfortunately, that did not work:

![SigThief fail|689x60](upload://gQoDSyB6pN7rYrk9kewbjx47xED.png) 

The last technique involves injecting shellcode into a `mbam.exe` process. Though this requires a fair bit of work to generate the shellcode, it was what ended up working. The shellcode can be generated through the compiler, thanks to [Matt Graeber](https://twitter.com/mattifestation)&#39;s excellent post on [_Writing Optimized Windows Shellcode in C_](http://www.exploit-monday.com/2013/08/writing-optimized-windows-shellcode-in-c.html). Once the binary is compiled, simply extract the code from the `.text` section and copy it into another project that performs basic shellcode injection into a target process. Personally, I just used the classic [`CreateRemoteThread`](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread) method.

There are also two other security measures that I have not mentioned yet. The first is the _User access_ option which, when set, requires a password to modify any selected settings. The second is a UAC prompt for when a non-administrative user tries to change critical settings such as self-protection or real-time protection. As I&#39;ve discovered, directly interacting with the settings through the COM classes entirely bypasses these two security components.

## Demonstration

![](upload://wcMXceUPTuDmMBEbURIcAdh5DgU.gif)

----

# Conclusion

This post shows yet another example of attacking security products via their communication channels. Although there were layers of protection for preventing unauthorised access, the trust granted in the verification procedure was subverted using trivial impersonation that has impacted other products in the past and present. Perhaps the self-protection was insufficient and needs to extend to all of the Malwarebytes processes. This could stop the shellcode injection and therefore, this attack vector.

As always, the PoC code (currently withheld) can be found on my [Antimalware-Research GitHub](https://github.com/NtRaiseHardError/Antimalware-Research/tree/master/Malwarebytes/v4.0.4.49).

Thanks for reading and I hope you learned something!

_-- dtm_</description>
    
    <lastBuildDate>Fri, 24 Jan 2020 07:15:02 +0000</lastBuildDate>
    <category>Reverse Engineering</category>
    <atom:link href="https://0x00sec.org/t/anti-virus-exploitation-malwarebytes-4-0-4-protection-not-found-hijacking-malwarebytes-via-com-ipc/18766.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Anti-virus Exploitation: Malwarebytes 4.0.4 - Protection Not Found - Hijacking Malwarebytes via COM IPC</title>
        <dc:creator><![CDATA[dtm]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 121 days. New replies are no longer allowed.</p>
          <p><a href="https://0x00sec.org/t/anti-virus-exploitation-malwarebytes-4-0-4-protection-not-found-hijacking-malwarebytes-via-com-ipc/18766/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/anti-virus-exploitation-malwarebytes-4-0-4-protection-not-found-hijacking-malwarebytes-via-com-ipc/18766/2</link>
        <pubDate>Sun, 24 May 2020 13:09:50 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-18766-2</guid>
        <source url="https://0x00sec.org/t/anti-virus-exploitation-malwarebytes-4-0-4-protection-not-found-hijacking-malwarebytes-via-com-ipc/18766.rss">Anti-virus Exploitation: Malwarebytes 4.0.4 - Protection Not Found - Hijacking Malwarebytes via COM IPC</source>
      </item>
      <item>
        <title>Anti-virus Exploitation: Malwarebytes 4.0.4 - Protection Not Found - Hijacking Malwarebytes via COM IPC</title>
        <dc:creator><![CDATA[dtm]]></dc:creator>
        <description><![CDATA[
            <h1>Hijacking Malwarebytes via COM IPC</h1>
<p><a href="https://0x00sec.org/t/anti-virus-exploitation-local-privilege-escalation-in-k7-security-cve-2019-16897/17655">Attacking K7 Security</a> was my first attempt at discovering, analysing, and exploiting software at the protocol level. It made me curious as to how other vendors designed and developed their inter-process communication (IPC) methods between the untrusted client (the user-controlled software; usually the GUI) and the high integrity service process. Here is the diagram that shows the interaction between these two components again, for completeness:</p>
<p><a href="https://0x00sec.s3.amazonaws.com/original/2X/6/6a53340a79f1f087af9d10f11f8a81408927a8f0.jpeg" class="onebox" target="_blank" rel="noopener">https://0x00sec.s3.amazonaws.com/original/2X/6/6a53340a79f1f087af9d10f11f8a81408927a8f0.jpeg</a></p>
<p>This article will be about diving into reverse engineering the communication protocol used in Malwarebytes and the issues that I identified as a result of bypassing the intended (and assumed?) approach towards controlling functionality.</p>
<p><strong>Disclaimer</strong>: I do not claim to know everything on the topics discussed here as fact, this is purely what I have inferred from my research. Especially if the COM information is inaccurate in any way, shape or form, please let me know and I will fix it as soon as possible. PoC code snippets has been withheld until the vendor applies a patch or until a reasonable amount of time has passed.</p>
<h2>Recommended Pre-requisite Knowledge</h2>
<ul>
<li>Windows API</li>
<li>C/C++ and Intel Assembly</li>
<li>Inter-process communication
<ul>
<li>Named Pipes</li>
<li>Component Object Model (COM)</li>
</ul>
</li>
</ul>
<hr>
<h2>Discovering IPC Methods</h2>
<p>There are <a href="https://docs.microsoft.com/en-us/windows/win32/ipc/interprocess-communications">multiple ways with which software can perform IPC</a>. How do we figure out which ones Malwabytes uses? Let’s start with analysing the imported functions of the GUI and service executables in IDA. Starting with the service executable, <code>MBAMService.exe</code>, we can identify named pipe functions:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="Named Pipe API" data-orig-src="upload://mj2OA9PXpyvsKLXdIH4NFrD0wRm.png" width="643" height="99"></p>
<p>While we’re here, let’s see if we can extract the pipe name. <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea"><code>CreateNamedPipe</code> </a> is documented to receive the name of the pipe:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="CreateNamedPipe doc" data-orig-src="upload://eiKtb86A3aXYCXASFKhobq8RYyy.png" width="575" height="500"></p>
<p>Following the references of <code>CreateNamedPipeW</code> will lead us to:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="Named pipe name" data-orig-src="upload://xk5li1epKsokXLCgiEjT7pXyrAn.png" width="488" height="355"></p>
<p>But what does <code>MBLG</code> mean…? If we take a look at the <code>ConnectNamedPipe</code> references, there are strings which will give us a hint:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="MBLG hint?" data-orig-src="upload://x9qGLt979LxmR34jnBDpEVIhFrS.png" width="690" height="438"></p>
<p>Perhaps <em>MalwareBytes License Generator</em>? Nevertheless, we’ve identified one of the IPC techniques.</p>
<p>In the documentation for the available IPC methods, it states that “the foundation of OLE is the Component Object Model (COM)”. If we look into the <code>ole32</code> library imports, we can see this:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="COM imports" data-orig-src="upload://elEShS3TVmVvmxHCwHuNy4Y30FC.png" width="542" height="303"></p>
<p>The <a href="https://docs.microsoft.com/en-us/windows/win32/api/combaseapi/nf-combaseapi-coinitializeex"><code>CoInitializeEx</code></a> documentation states:</p>
<aside class="quote no-group" data-username="MSDN">
<div class="title">
<div class="quote-controls"></div>
 MSDN:</div>
<blockquote>
<p>Initializes the COM library for use by the calling thread…</p>
</blockquote>
</aside>
<p>This verifies that the service process also uses COM IPC.</p>
<p>What about the GUI executable, <code>mbam.exe</code>? Let’s look for the same IPC methods beginning with named pipes:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="Named pipe imports" data-orig-src="upload://ckIC6HHWJO5tmmKlNsqNUigo1EG.png" width="501" height="62"></p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-callnamedpipea"><code>CallNamedPipe</code></a> is documented to receive the target pipe name:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="CallNamedPipe docs" data-orig-src="upload://bP8p0KXQhKL6exjQptdkRU2ASgG.png" width="677" height="454"></p>
<p>Again, we will follow the reference to that function and again, we’ll see the <code>\\.\pipe\MBLG</code> string:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="Named pipe name" data-orig-src="upload://l9Bny2KuV7GT0J1rjbiYR628JjQ.png" width="416" height="343"></p>
<p>This time, it’s accompanied with another string <code>NeedAKey</code> which is passed into the input buffer for the service process.</p>
<p><code>mbam.exe</code> also imports the COM functions from the <code>ole32</code> library:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="COM imports" data-orig-src="upload://A3vOZ7dhjjEbn2lYL1hD2RMk3lN.png" width="502" height="350"></p>
<h2>Reverse Engineering the COM Protocol</h2>
<p>One of the many amazing tools released by <a href="https://twitter.com/tiraniddo">James Foreshaw</a> is <a href="https://github.com/tyranid/oleviewdotnet">OleViewDotNet</a>. Using this, we can discover COM objects available on a system.</p>
<p>Firing up OleViewDotNet, we can list all the <a href="https://docs.microsoft.com/en-us/windows/win32/com/com-class-objects-and-clsids">COM classes exposed through their CLSIDs</a>. Filtering by servers, we can see that the <code>MBAMService.exe</code> executable is packaged with <a href="https://docs.microsoft.com/en-us/windows/win32/midl/com-dcom-and-type-libraries">type libraries</a> that define protocol information in human-readable and code form.</p>
<p>Here is the <code>RTPController</code> interface:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="RTPController interface" data-orig-src="upload://uiw92dlVbNCVf5MqAFX2Lh3fqvC.png" width="690" height="348"></p>
<p>and here is the <code>LicenseController</code> interface:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="LicenseController interface" data-orig-src="upload://aSHxhlPhNdeLpfLglKjTVs3aaGP.png" width="660" height="500"></p>
<p>How can we extract this information so we can use it? The OleViewDotNet tool is based on Microsoft’s OleView which can pull the type library information into a compilable <a href="https://docs.microsoft.com/en-us/windows/win32/midl/interface-definition-idl-file">Interface Definition Language</a> (IDL) file.</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="AEController IDL file" data-orig-src="upload://c4QxV6eBOFq2lIP4sf07tKn4itW.png" width="536" height="500"></p>
<p>Notice that at the top of the generated IDL file there is a <code>typelib filename: 12</code> which probably indicates that there are <em>at least</em> 12 type libraries. After extracting all of the IDL files, we should have fourteen files:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="All IDL files" data-orig-src="upload://2S89u9hIXnS0dxLuTKgciAAGiJv.png" width="173" height="302"></p>
<h2>Compiling IDL Files</h2>
<p>To compile these into code, we can use Microsoft’s <code>midl.exe</code> utility like so:</p>
<pre><code class="lang-makefile">midl /out &lt;output directory path&gt; /header &lt;header output file path&gt; &lt;path to IDL file&gt;
</code></pre>
<p>But we have to do this is a specific order. Looking back at the generated <code>AEControllerCOMLib</code> IDL file in <code>OleView</code>, there are dependencies specified with <code>importlib("&lt;file&gt;")</code>. These are the other compiled IDL files used by Malwarebytes. We must first find and compile the IDL file with none of these dependencies and then gradually work our way up until we have all of the dependencies required to compile all of the other IDL files. Let’s take a brief look at an example.</p>
<p>The first file we need to compile is the <code>LogController</code>. We can see that it only has the <code>stdole2.tlb</code> type library as its dependency which is provided by Microsoft.</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="LogController IDL file" data-orig-src="upload://oSNisuWFwpOV2SMWcwS024iJ7z8.png" width="556" height="499"></p>
<p>If we compile this using <code>midl</code>, we’ll get three files (depending on how you named them on the command line):</p>
<pre><code class="lang-makefile">LogController.h
LogController.tlb
LogController_i.c
</code></pre>
<p>The header file will contain the definition of all of the enums, structs, and class methods for the COM object:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="LogController.h" data-orig-src="upload://9R2luho8LqCUdeQzExDGnd94Om5.png" width="378" height="500"></p>
<p>The C file will contain the <a href="https://docs.microsoft.com/en-us/office/client-developer/outlook/mapi/iid">interface identifiers</a> (IID) and CLSIDs to query and use the COM object:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="LogController_i.c" data-orig-src="upload://tIeFESRmbAg8zIul9k3ouIonEcE.png" width="541" height="500"></p>
<p>The type library (<code>tlb</code>) file is required for dependencies to compile the other IDL files. This file name should correspond with what’s specified in the IDL file’s <code>typelib filename</code> - in this case, it’s just <code>2</code>.</p>
<p>The next IDL to be compiled is the <code>PoliciesController</code>. The IDL file states that its dependencies are <code>stdole2.tlb</code> and <code>2</code>, both of which we have.</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="PoliciesController IDL file" data-orig-src="upload://fZVw8V8J532qRWCQFqiAsP4ZXRo.png" width="559" height="500"></p>
<p>Now we just repeat the steps as before with the <code>LogController</code> and the rest of the other IDL files.</p>
<h2>Querying Malwarebytes’ COM Object Classes</h2>
<p>To figure out how we can interact with the COM classes, we can look at how <code>mbam.exe</code> does it using <a href="http://www.rohitab.com/downloads#API_Monitor_v2_Alpha">Rohitab’s API Monitor</a>. With this information, hopefully we can re-implement it ourselves. We’ll set the filter to monitor for COM and Pipe API calls only in the <code>mbam.exe</code> module and it should look like this when monitoring the startup of the application:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="API Monitor" data-orig-src="upload://ybunjjcg8BhNWEFaUyww4ZReVIP.png" width="690" height="364"></p>
<p>Let’s ignore the first call to <code>CoCreateInstance</code>, because it fails, and move onto <code>CallNamedPipeW</code>. We saw this call earlier with the <code>NeedAKey</code> string in the input buffer. Here is what the output buffer contains:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="CallNamedPipeW" data-orig-src="upload://m12QhYXLFA1D6Zf2YzHYqP9VzSO.png" width="690" height="203"></p>
<p>Looks like a randomly-generated sequence of wide ASCII characters (we’ll call this the “license string”), and we can see it used in calls to <a href="https://docs.microsoft.com/en-us/windows/win32/api/oleauto/nf-oleauto-sysallocstringlen"><code>SysAllocStringLen</code></a> and <a href="https://docs.microsoft.com/en-us/windows/win32/api/oleauto/nf-oleauto-sysfreestring"><code>SysFreeString</code></a> which returns a <a href="https://docs.microsoft.com/en-us/cpp/atl-mfc-shared/allocating-and-releasing-memory-for-a-bstr?view=vs-2019"><code>BSTR</code></a> type of the input string and frees it, respectively. The <code>BSTR</code> type is used in passing data in COM objects. The license string is also used in <a href="https://docs.microsoft.com/en-us/windows/win32/api/ocidl/nf-ocidl-iclassfactory2-createinstancelic"><code>IClassFactory2::CreateInstanceLic</code></a> which is documented as so:</p>
<aside class="quote no-group" data-username="MSDN">
<div class="title">
<div class="quote-controls"></div>
 MSDN:</div>
<blockquote>
<p>Creates an instance of the licensed object for the specified license key. This method is the only possible means to create an object on an otherwise unlicensed machine.</p>
</blockquote>
</aside>
<p>That’s good to know! But how do we get here and what is this <code>IClassFactory2</code> used for? Let’s jump back to the call to <a href="https://docs.microsoft.com/en-us/windows/win32/api/combaseapi/nf-combaseapi-cogetclassobject"><code>CoGetClassObject</code></a> and its arguments. The <code>MBAMServiceController</code> CLSID is specified to retrieve its corresponding pointer to its object which is returned as an <a href="https://docs.microsoft.com/en-us/windows/win32/api/unknwn/nn-unknwn-iclassfactory"><code>IClassFactory</code></a>. The <a href="https://docs.microsoft.com/en-us/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(q)"><code>IClassFactory::QueryInterface</code></a> method is then used to obtain the <code>IClassFactory2</code> interface. But what’s the point in all of this? As it turns out - after a lot of experimentation - that the <code>IClassFactory2::CreateInstanceLic</code> interface can be used to acquire a pointer to the <code>IMBAMServiceController</code> interface. Using this interface, we can gain access to the COM object classes exposed by Malwarebytes, i.e. the <code>RTPController</code> class, the <code>LicenseController</code> class, etc. So just to summarise this section, here is what the flow looks like:</p>
<pre><code class="lang-makefile">1. Get a license string with CallNamedPipe("NeedAKey"),
2. Get an IClassFactory interface with CoGetClassObject(CLSID_MBAMServiceControllerClass)
3. Get an IClassFactory2 interface with IClassFactory::QueryInterface(IID_IClassFactory2),
4. Get a BSTR for the license string with SysAllocStringLen("LicenseKey"), 
5. Get an IMBAMServiceController interface with IClassFactory2::CreateInstanceLic("BSTR_LicenseString"),
6. Get the desired MBAM COM class's interface with the IMBAMServiceController interface.
</code></pre>
<h2>Bypassing Security Checks</h2>
<p>Of course it wouldn’t be so easy. Malwarebytes’ service implements some verification on the process that requests a license string on <code>ConnectNamedPipe</code>:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="Verification" data-orig-src="upload://1eCEtxpIVIuzXfH6o4tdpXiv4VW.png" width="425" height="400"></p>
<p>We can see it in log files too:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="Verification logs" data-orig-src="upload://c5Ku5za8PZZt4CMv4JzvrlRZtoy.png" width="690" height="204"></p>
<p>To use my time effectively, I opted to try a few methods to try to bypass the verification checks before digging into the assembly. I’ve seen these problems exist in other products so I had a few ideas. The immediate method that came into my head was to do process hollowing on <code>mbam.exe</code>. However, I don’t believe I can get that to work on the 64-bit architecture since I had never gotten it to work before. Perhaps it could work in the case of 32-bit? The next method was to append the signature using <a href="https://github.com/secretsquirrel/SigThief">SigThief</a>. Unfortunately, that did not work:</p>
<p><img src="https://0x00sec.org/images/transparent.png" alt="SigThief fail" data-orig-src="upload://gQoDSyB6pN7rYrk9kewbjx47xED.png" width="689" height="60"></p>
<p>The last technique involves injecting shellcode into a <code>mbam.exe</code> process. Though this requires a fair bit of work to generate the shellcode, it was what ended up working. The shellcode can be generated through the compiler, thanks to <a href="https://twitter.com/mattifestation">Matt Graeber</a>’s excellent post on <a href="http://www.exploit-monday.com/2013/08/writing-optimized-windows-shellcode-in-c.html"><em>Writing Optimized Windows Shellcode in C</em></a>. Once the binary is compiled, simply extract the code from the <code>.text</code> section and copy it into another project that performs basic shellcode injection into a target process. Personally, I just used the classic <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread"><code>CreateRemoteThread</code></a> method.</p>
<p>There are also two other security measures that I have not mentioned yet. The first is the <em>User access</em> option which, when set, requires a password to modify any selected settings. The second is a UAC prompt for when a non-administrative user tries to change critical settings such as self-protection or real-time protection. As I’ve discovered, directly interacting with the settings through the COM classes entirely bypasses these two security components.</p>
<h2>Demonstration</h2>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/e/e1b7ad0c3a9cb5e5a2dde4ca74c5d17fc78e64fc.gif" data-download-href="/uploads/short-url/wcMXceUPTuDmMBEbURIcAdh5DgU.gif?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/e/e1b7ad0c3a9cb5e5a2dde4ca74c5d17fc78e64fc_2_690x388.gif" alt="" data-base62-sha1="wcMXceUPTuDmMBEbURIcAdh5DgU" width="690" height="388" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/e/e1b7ad0c3a9cb5e5a2dde4ca74c5d17fc78e64fc_2_10x10.png"></a></div><p></p>
<hr>
<h1>Conclusion</h1>
<p>This post shows yet another example of attacking security products via their communication channels. Although there were layers of protection for preventing unauthorised access, the trust granted in the verification procedure was subverted using trivial impersonation that has impacted other products in the past and present. Perhaps the self-protection was insufficient and needs to extend to all of the Malwarebytes processes. This could stop the shellcode injection and therefore, this attack vector.</p>
<p>As always, the PoC code (currently withheld) can be found on my <a href="https://github.com/NtRaiseHardError/Antimalware-Research/tree/master/Malwarebytes/v4.0.4.49">Antimalware-Research GitHub</a>.</p>
<p>Thanks for reading and I hope you learned something!</p>
<p><em>– dtm</em></p>
          <p><a href="https://0x00sec.org/t/anti-virus-exploitation-malwarebytes-4-0-4-protection-not-found-hijacking-malwarebytes-via-com-ipc/18766/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/anti-virus-exploitation-malwarebytes-4-0-4-protection-not-found-hijacking-malwarebytes-via-com-ipc/18766/1</link>
        <pubDate>Thu, 23 Jan 2020 21:09:50 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-18766-1</guid>
        <source url="https://0x00sec.org/t/anti-virus-exploitation-malwarebytes-4-0-4-protection-not-found-hijacking-malwarebytes-via-com-ipc/18766.rss">Anti-virus Exploitation: Malwarebytes 4.0.4 - Protection Not Found - Hijacking Malwarebytes via COM IPC</source>
      </item>
  </channel>
</rss>
