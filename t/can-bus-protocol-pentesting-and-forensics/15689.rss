<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>CAN-bus protocol pentesting and forensics</title>
    <link>https://0x00sec.org/t/can-bus-protocol-pentesting-and-forensics/15689</link>
    <description>![](upload://b0z8eaoNby9L2StFZfLzEgF4jc4.png)

## Introduction

CAN (Controller Area Network) is a vehicle bus protocol standard which allows microcontrollers and ECU (electronic control units) to communicate which each other without a host computer. It is a message-based protocol, designed originally for multiplex electrical wiring within automobiles to save on copper, but can also be used in many other contexts. But why CAN you may ask, because it’s low-cost error less since via single CAN interface ECU can communicate with each through the centralized system with less wiring involved and data is transferred over digital signal instead of analog so it reduces chances of error occurrence. Also, it’s a tolerant system against electromagnetic noise which makes it best fit for vehicle electronics system.

There is another protocol which works on top of CAN called OBD (On-board diagnostics). OBD adds up the transport layer for CAN.

![CAN vs. OBD vs. OSI layers](https://cjhackerz.net/img/canbusVobdVsosi.svg)

*CAN vs. OBD vs. OSI layers*

For physical layer CAN have two major standards to transmit data over a physical medium (wires)

* High Speed CAN Signaling. ISO 11898-2 (frequent error occurrence)
* Low-Speed Fault Tolerant CAN Network. ISO 11898-3 (less error occurrence)

![CAN node](upload://xxh17m60sRa0jR81LnoZTYhX7D2.png)

*CAN node layout*

I won’t provide more details of the standards above, because as IoT security researchers Data Link and Network layers are what we should be interested in. Let’s have look at standard CAN message frame format which gets transmitted over network.

![CAN message frame](upload://piKmgpAyc5tbLLQAoGj422VzT71.png)

* **SOF (Start of Frame):**  Tells other ECUs that message is incoming
* **CAN-ID:**  Contains priority bits for message along with functional address of ECU (in terms of networking CAN-ID is like mac address, but not same thing)
* **RTR:**  Remote transmission requests allows ECU to request messages from other active ECUs on network
* **CONTROL:**  Informs length of the data in bytes
* **DATA:**  Contains data values to be transmitted over protocol
* **CRC:**  Cyclic Redudancy Values for error correction and data integrity
* **ACK:**  It indicates status of CRC process
* **EOF** : End of frame marks the end of CAN message frame

Now for network packet forseics we only need to worry about  **CAN-ID** ,  **CONTROL**  and  **DATA**

![CAN traffic wireshark](upload://fBK8WUCgufRs7QMkg91BGWUD0mg.png)

*CAN-bus traffic in wireshark*

As we can see in wireshark CAN-bus is event driven, when the data is generated by ECU via certain action (such as changing gears, indicators on/off, door lock/unlock etc.) it’s gets instantly broadcasted on network without any message sorting. So if we are looking for CAN-ID of specific ECU it becomes very hard to look through noise of data generated by other active ECUs in system. Thankfully linux got open source software suite called [can-utils](https://github.com/linux-can/can-utils.git) which allows us to create network interface for CAN traffic processing and sniffing. It has utility called candump which can display, filter and log CAN data to files.

## Setting up virtual CAN network for experimentation and fun

So most of us are not brave enough to go out hook some hardware and mess around with actual vehicle but still want to know how CAN traffic acts in real time. Solution is [ICSim](https://github.com/zombieCraig/ICSim.git) (Instrument Cluster Simulator for SocketCAN) is simulator of vehicle Dashboard data over virtual CAN network.

### Steps to compile ICSim

```
git clone https://github.com/zombieCraig/ICSim.git
```

```
apt-get install libsdl2-dev libsdl2-image-dev can-utils
```

```
cd ICSim &amp;&amp; make &amp;&amp; ./setup_vcan.sh
```

To start ICSim with default hardcoded CAN-IDs

```
./icsim vcan0
```
```
 ./controls vcan0
```

Now shorting changing data according to CAN-ID

```
cansniffer vcan0 #Any CAN interface of your choice
```
Select control window and press Up arrow key to increase speed, you will notice CAN-ID in cansniffer output changing value alot so that CAN-ID is for your vechicle speed data transmitted by engine ECU. You can also capture that traffic in wireshark and save it for further analysis. According to source code file icsim.c default arbitration/CAN-ID for speed data is 0x244.

Scapy recently added support for CAN protocol layer, so now you can all kind of data analysis in python. The basic script below saves all hex values from CAN-ID in array and finds of minimum and maximum speed. The more cool things can be done with matplotlib to create graph for speed data to know how many times vehicle got slow down due to road traffic.

```
from scapy.all import *
import struct

load_layer(&quot;can&quot;) #Allows us to work with CAN-bus network layer please note that it only works with latest veersion of ScaPy library

can_packets = rdpcap(&#39;canbus-traffic-capture.pcap&#39;)

CAN_ID = #Your desired CAN-ID for vehicle speed data in hex format
raw_data = []

for x in can_packets:
        if x[&quot;CAN&quot;].identifier == int(CAN_ID, 16):
            data = x[&quot;CAN&quot;].data.hex()
            raw_data.append(data[10:]) #From traffic analysis we know that speed data only 4-bit long out of 14-bit hex string

raw_data = list(set(raw_data))

print(&quot;Raw RPM data in hex: &quot; + str(raw_data))

delta_rpm = []

for y in raw_data:
    delta_rpm.append(int(y, 16))


print(&quot;Maximum RPM is: &quot; + str(max(delta_rpm)))
print(&quot;Minimum RPM is: &quot; + str(min(delta_rpm)))
```

There are more features in ICSim which allows you to increase difficulty with -r (randomized CAN-IDs) and -l options for learning. Since ScapPy supports CAN you can also write your own ICSim kind of utility in python as well. Check out ScaPy docs for CAN [here](https://scapy.readthedocs.io/en/latest/layers/automotive.html).

For pentesting with external hardware such as [RaspberryPi](https://www.raspberrypi.org/forums/viewtopic.php?f=44&amp;t=141052) and Arduino you can order shield with [MCP2515 controller](https://www.sparkfun.com/products/13262)

For more on IoT security checkout my personal blog here: [cjhackerz.net](https://cjhackerz.net)</description>
    
    <lastBuildDate>Tue, 27 Aug 2019 03:50:53 +0000</lastBuildDate>
    <category>Networking</category>
    <atom:link href="https://0x00sec.org/t/can-bus-protocol-pentesting-and-forensics/15689.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>CAN-bus protocol pentesting and forensics</title>
        <dc:creator><![CDATA[system]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 30 days. New replies are no longer allowed.</p>
          <p><a href="https://0x00sec.org/t/can-bus-protocol-pentesting-and-forensics/15689/6">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/can-bus-protocol-pentesting-and-forensics/15689/6</link>
        <pubDate>Tue, 17 Sep 2019 15:36:56 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-15689-6</guid>
        <source url="https://0x00sec.org/t/can-bus-protocol-pentesting-and-forensics/15689.rss">CAN-bus protocol pentesting and forensics</source>
      </item>
      <item>
        <title>CAN-bus protocol pentesting and forensics</title>
        <dc:creator><![CDATA[petruknisme]]></dc:creator>
        <description><![CDATA[
            <p>For real case scenario, What are the hardware recommendations for capturing CAN packets?</p>
          <p><a href="https://0x00sec.org/t/can-bus-protocol-pentesting-and-forensics/15689/5">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/can-bus-protocol-pentesting-and-forensics/15689/5</link>
        <pubDate>Tue, 27 Aug 2019 03:50:53 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-15689-5</guid>
        <source url="https://0x00sec.org/t/can-bus-protocol-pentesting-and-forensics/15689.rss">CAN-bus protocol pentesting and forensics</source>
      </item>
      <item>
        <title>CAN-bus protocol pentesting and forensics</title>
        <dc:creator><![CDATA[Nekiruy]]></dc:creator>
        <description><![CDATA[
            <p>Awesome intro, thank you for sharing that. It will provide a nice jumping off point for the folks wanting to dip their toes in to the world of CAN research.</p>
          <p><a href="https://0x00sec.org/t/can-bus-protocol-pentesting-and-forensics/15689/4">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/can-bus-protocol-pentesting-and-forensics/15689/4</link>
        <pubDate>Tue, 20 Aug 2019 10:30:44 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-15689-4</guid>
        <source url="https://0x00sec.org/t/can-bus-protocol-pentesting-and-forensics/15689.rss">CAN-bus protocol pentesting and forensics</source>
      </item>
      <item>
        <title>CAN-bus protocol pentesting and forensics</title>
        <dc:creator><![CDATA[pry0cc]]></dc:creator>
        <description><![CDATA[
            
          <p><a href="https://0x00sec.org/t/can-bus-protocol-pentesting-and-forensics/15689/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/can-bus-protocol-pentesting-and-forensics/15689/3</link>
        <pubDate>Sun, 18 Aug 2019 16:06:46 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-15689-3</guid>
        <source url="https://0x00sec.org/t/can-bus-protocol-pentesting-and-forensics/15689.rss">CAN-bus protocol pentesting and forensics</source>
      </item>
      <item>
        <title>CAN-bus protocol pentesting and forensics</title>
        <dc:creator><![CDATA[cjhackerz]]></dc:creator>
        <description><![CDATA[
            <p><img src="https://0x00sec.s3.amazonaws.com/original/2X/4/4d284fcdd9107c0376be06138af8742cf6207a28.png" alt="" data-base62-sha1="b0z8eaoNby9L2StFZfLzEgF4jc4" width="559" height="200"></p>
<h2>Introduction</h2>
<p>CAN (Controller Area Network) is a vehicle bus protocol standard which allows microcontrollers and ECU (electronic control units) to communicate which each other without a host computer. It is a message-based protocol, designed originally for multiplex electrical wiring within automobiles to save on copper, but can also be used in many other contexts. But why CAN you may ask, because it’s low-cost error less since via single CAN interface ECU can communicate with each through the centralized system with less wiring involved and data is transferred over digital signal instead of analog so it reduces chances of error occurrence. Also, it’s a tolerant system against electromagnetic noise which makes it best fit for vehicle electronics system.</p>
<p>There is another protocol which works on top of CAN called OBD (On-board diagnostics). OBD adds up the transport layer for CAN.</p>
<p><img src="https://cjhackerz.net/img/canbusVobdVsosi.svg" alt="CAN vs. OBD vs. OSI layers" width="531" height="455"></p>
<p><em>CAN vs. OBD vs. OSI layers</em></p>
<p>For physical layer CAN have two major standards to transmit data over a physical medium (wires)</p>
<ul>
<li>High Speed CAN Signaling. ISO 11898-2 (frequent error occurrence)</li>
<li>Low-Speed Fault Tolerant CAN Network. ISO 11898-3 (less error occurrence)</li>
</ul>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/e/eb0aa5cc76280e0b879ab0743d1b798b49bef088.png" data-download-href="/uploads/short-url/xxh17m60sRa0jR81LnoZTYhX7D2.png?dl=1" title="CAN node" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/e/eb0aa5cc76280e0b879ab0743d1b798b49bef088_2_546x499.png" alt="CAN node" data-base62-sha1="xxh17m60sRa0jR81LnoZTYhX7D2" width="546" height="499" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/e/eb0aa5cc76280e0b879ab0743d1b798b49bef088_2_546x499.png, https://0x00sec.s3.amazonaws.com/optimized/2X/e/eb0aa5cc76280e0b879ab0743d1b798b49bef088_2_819x748.png 1.5x, https://0x00sec.s3.amazonaws.com/original/2X/e/eb0aa5cc76280e0b879ab0743d1b798b49bef088.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/e/eb0aa5cc76280e0b879ab0743d1b798b49bef088_2_10x10.png"></a></div><p></p>
<p><em>CAN node layout</em></p>
<p>I won’t provide more details of the standards above, because as IoT security researchers Data Link and Network layers are what we should be interested in. Let’s have look at standard CAN message frame format which gets transmitted over network.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/b/b154e05b767a613fe0666ab627401ba808d4e447.png" alt="CAN message frame" data-base62-sha1="piKmgpAyc5tbLLQAoGj422VzT71" width="571" height="201"></p>
<ul>
<li>
<strong>SOF (Start of Frame):</strong>  Tells other ECUs that message is incoming</li>
<li>
<strong>CAN-ID:</strong>  Contains priority bits for message along with functional address of ECU (in terms of networking CAN-ID is like mac address, but not same thing)</li>
<li>
<strong>RTR:</strong>  Remote transmission requests allows ECU to request messages from other active ECUs on network</li>
<li>
<strong>CONTROL:</strong>  Informs length of the data in bytes</li>
<li>
<strong>DATA:</strong>  Contains data values to be transmitted over protocol</li>
<li>
<strong>CRC:</strong>  Cyclic Redudancy Values for error correction and data integrity</li>
<li>
<strong>ACK:</strong>  It indicates status of CRC process</li>
<li>
<strong>EOF</strong> : End of frame marks the end of CAN message frame</li>
</ul>
<p>Now for network packet forseics we only need to worry about  <strong>CAN-ID</strong> ,  <strong>CONTROL</strong>  and  <strong>DATA</strong></p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/6/6d64dd2dc1ca3a622cc9c8d4bcf8590a267cf46c.png" data-download-href="/uploads/short-url/fBK8WUCgufRs7QMkg91BGWUD0mg.png?dl=1" title="CAN traffic wireshark" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/6/6d64dd2dc1ca3a622cc9c8d4bcf8590a267cf46c_2_690x376.png" alt="CAN traffic wireshark" data-base62-sha1="fBK8WUCgufRs7QMkg91BGWUD0mg" width="690" height="376" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/6/6d64dd2dc1ca3a622cc9c8d4bcf8590a267cf46c_2_690x376.png, https://0x00sec.s3.amazonaws.com/optimized/2X/6/6d64dd2dc1ca3a622cc9c8d4bcf8590a267cf46c_2_1035x564.png 1.5x, https://0x00sec.s3.amazonaws.com/optimized/2X/6/6d64dd2dc1ca3a622cc9c8d4bcf8590a267cf46c_2_1380x752.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/6/6d64dd2dc1ca3a622cc9c8d4bcf8590a267cf46c_2_10x10.png"></a></div><p></p>
<p><em>CAN-bus traffic in wireshark</em></p>
<p>As we can see in wireshark CAN-bus is event driven, when the data is generated by ECU via certain action (such as changing gears, indicators on/off, door lock/unlock etc.) it’s gets instantly broadcasted on network without any message sorting. So if we are looking for CAN-ID of specific ECU it becomes very hard to look through noise of data generated by other active ECUs in system. Thankfully linux got open source software suite called <a href="https://github.com/linux-can/can-utils.git" rel="noopener nofollow ugc">can-utils</a> which allows us to create network interface for CAN traffic processing and sniffing. It has utility called candump which can display, filter and log CAN data to files.</p>
<h2>Setting up virtual CAN network for experimentation and fun</h2>
<p>So most of us are not brave enough to go out hook some hardware and mess around with actual vehicle but still want to know how CAN traffic acts in real time. Solution is <a href="https://github.com/zombieCraig/ICSim.git" rel="noopener nofollow ugc">ICSim</a> (Instrument Cluster Simulator for SocketCAN) is simulator of vehicle Dashboard data over virtual CAN network.</p>
<h3>Steps to compile ICSim</h3>
<pre><code class="lang-auto">git clone https://github.com/zombieCraig/ICSim.git
</code></pre>
<pre><code class="lang-auto">apt-get install libsdl2-dev libsdl2-image-dev can-utils
</code></pre>
<pre><code class="lang-auto">cd ICSim &amp;&amp; make &amp;&amp; ./setup_vcan.sh
</code></pre>
<p>To start ICSim with default hardcoded CAN-IDs</p>
<pre><code class="lang-auto">./icsim vcan0
</code></pre>
<pre><code class="lang-auto"> ./controls vcan0
</code></pre>
<p>Now shorting changing data according to CAN-ID</p>
<pre><code class="lang-auto">cansniffer vcan0 #Any CAN interface of your choice
</code></pre>
<p>Select control window and press Up arrow key to increase speed, you will notice CAN-ID in cansniffer output changing value alot so that CAN-ID is for your vechicle speed data transmitted by engine ECU. You can also capture that traffic in wireshark and save it for further analysis. According to source code file icsim.c default arbitration/CAN-ID for speed data is 0x244.</p>
<p>Scapy recently added support for CAN protocol layer, so now you can all kind of data analysis in python. The basic script below saves all hex values from CAN-ID in array and finds of minimum and maximum speed. The more cool things can be done with matplotlib to create graph for speed data to know how many times vehicle got slow down due to road traffic.</p>
<pre><code class="lang-auto">from scapy.all import *
import struct

load_layer("can") #Allows us to work with CAN-bus network layer please note that it only works with latest veersion of ScaPy library

can_packets = rdpcap('canbus-traffic-capture.pcap')

CAN_ID = #Your desired CAN-ID for vehicle speed data in hex format
raw_data = []

for x in can_packets:
        if x["CAN"].identifier == int(CAN_ID, 16):
            data = x["CAN"].data.hex()
            raw_data.append(data[10:]) #From traffic analysis we know that speed data only 4-bit long out of 14-bit hex string

raw_data = list(set(raw_data))

print("Raw RPM data in hex: " + str(raw_data))

delta_rpm = []

for y in raw_data:
    delta_rpm.append(int(y, 16))


print("Maximum RPM is: " + str(max(delta_rpm)))
print("Minimum RPM is: " + str(min(delta_rpm)))
</code></pre>
<p>There are more features in ICSim which allows you to increase difficulty with -r (randomized CAN-IDs) and -l options for learning. Since ScapPy supports CAN you can also write your own ICSim kind of utility in python as well. Check out ScaPy docs for CAN <a href="https://scapy.readthedocs.io/en/latest/layers/automotive.html" rel="noopener nofollow ugc">here</a>.</p>
<p>For pentesting with external hardware such as <a href="https://www.raspberrypi.org/forums/viewtopic.php?f=44&amp;t=141052" rel="noopener nofollow ugc">RaspberryPi</a> and Arduino you can order shield with <a href="https://www.sparkfun.com/products/13262" rel="noopener nofollow ugc">MCP2515 controller</a></p>
<p>For more on IoT security checkout my personal blog here: <a href="https://cjhackerz.net" rel="noopener nofollow ugc">cjhackerz.net</a></p>
          <p><a href="https://0x00sec.org/t/can-bus-protocol-pentesting-and-forensics/15689/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/can-bus-protocol-pentesting-and-forensics/15689/1</link>
        <pubDate>Sun, 18 Aug 2019 15:36:51 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-15689-1</guid>
        <source url="https://0x00sec.org/t/can-bus-protocol-pentesting-and-forensics/15689.rss">CAN-bus protocol pentesting and forensics</source>
      </item>
  </channel>
</rss>
