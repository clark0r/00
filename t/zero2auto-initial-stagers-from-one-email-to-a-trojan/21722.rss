<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>[Zero2Auto] – Initial Stagers - From one Email to a Trojan</title>
    <link>https://0x00sec.org/t/zero2auto-initial-stagers-from-one-email-to-a-trojan/21722</link>
    <description># Zero2Auto – Initial Stagers - From one Email to a Trojan

## Preface
This week we have discussed deobfuscating initial stagers and how to unpack their executable payloads. 
And what I’ve decided to do, to practice this week lesson is to find actual malware on any.run and unpack its entire initial stage. 

**Setting up goals:**

1. I’ll choose an infected document from any.run, then I’ll deobfuscate it and extract its payload
2. I’ll take the payload and unpack it from memory, showcasing how to unmap a dumped PE 
3. I’ll attempt to practice the first lesson by finding identifying encryption schemes or known algorithms within the payload.

**Required background:**

1. Knowledge in reversing VBA code
2. Knowledge in reversing PowerShell code
3. Knowledge in various analysis utilities (Process Hacker, PEBear, PEStudio, PEId)
4. Knowledge in IDA Pro
5. Knowledge in x64dbg
6. Basic understanding of stack overflow exploits and how to debug shellcode
***

## &lt;span style=&quot;text-decoration:underline;&quot;&gt;Choosing a Target:&lt;/span&gt;

I decide to go on any.run to find an interesting sample – I have experience in macro deobfuscation so I decide to look for a infected document hosting an exploit which delivers a payload.

I decide to filter MS Office files with an exploit tag, and quickly find a huge batch of files:

![624x295](upload://zR9Dn3Cg5BEOHVSpuOB9TOdKqHf.png)

Its valuable to mention that **CVE-2017-11882**([you can read about it here](https://unit42.paloaltonetworks.com/unit42-analysis-of-cve-2017-11882-exploit-in-the-wild/)) is the same exploit used in the Zero2Auto lesson and it seems as it’s the most used exploit when delivering malicious docs. I’ve also observed that the exploit is sometimes leveraged that attacks the Outlook app directly when I filtered for email message file types:

![624x294](upload://3TssfKSwLYsN4MN6J0ktHOfsJPj.png)

I have chosen the following sample: 

[https://app.any.run/tasks/fce8f628-52cf-4f5d-968c-ab59ddeaabda/](https://app.any.run/tasks/fce8f628-52cf-4f5d-968c-ab59ddeaabda/) and the reason for that mainly is because the infection chain is long, contains a wsf script, a vbs script and finally an EXE payload thus it could give me a lot of room to practice my knowledge. 

***

## &lt;span style=&quot;text-decoration:underline;&quot;&gt;From an email lure to an exploit:&lt;/span&gt;

![624x336](upload://6843p6aLdpZWOZEhE2DpFWKY8ZJ.png)

I decide to extract the excel document and inspect it(SHA-256 97CC9023C114013326A97E946B0CA71BB641952208B5BA04463F1DAF15E1A5B5). 

**&lt;span style=&quot;text-decoration:underline;&quot;&gt;Method 1 – Examining the document by opening it&lt;/span&gt;**

The first method is rather, not very safe to say the least but you should be fine if you have macros disabled by default, so I open up the Excel document and I’m met with the following:

![624x286](upload://Od1j3FeuaEwMjbwsJww1Th2V2H.png)

I’m definitely not going to enable macros but before I review the macros I decided to check out the rest of the sheets. Sheet number 2 has a very interesting object within it:

![195x101](upload://PRJz2MgXwkMdDmiti9k20ScEGE.png)

And if you double click it:

![624x201](upload://l9T7jFloi34h8VakFTJOWRTn6Yq.png)

This is an equation editor object that was embedded within the document, as I’m running on a fairly new MS Office version and this exploit was long ago mitigated on new versions I would expect I’d run into problems in performing this exploit but I bet I can do some stuff with the shellcode itself if we find it. Let’s continue to Sheet3:

![143x193](upload://kT3L7PzFTltvQlsUa8OmLydIKCb.png)

An observant person like myself (flex much danus?) noticed this two little square and if we double click them, we’ll see that they are actually objects embedded within this document

![518x462](upload://uKB62PZ8a2iCQE5G79e0Qg4BAW3.png)

These can also be seen being launched in the any.run view:

![624x331](upload://puNv4kUI5ljZ2YWVfWYOy5pbaXI.png)

What was interesting that if we decide to the view the locations of these embedded objects 

![466x184](upload://8iV6WqjIIMjBCK8iYUt5Qso3HuC.png)

They are located within the Temp folder, but I never downloaded them.

To be honest, at this point we can stop the analyzes and simply dump these objects but I would like to review the actual shellcode of the exploit itself just to analyze it. So, I decided to enter the macro editor, and would you like at what I’ve found:

![377x101](upload://o9vWrD0sfaZrWVhwlo57oyZx7bv.png)

**Auto_Open** is great news for us!

![624x219](upload://jOPeKuo7LVDKPtJvWr5PmoztY1I.png)

I’ve decided to remove the macro deobfuscation from the scope of this blog because it’s pretty straight forward, so I’ll summarize it. This first stage macro contains another macro within itself, it copies this macro inside C:/Programdata/asc.txt and then it runs the newly written macro. There is one problem with this method though, this xlsm file is trashed and I can&#39;t modify it. It means that every time I want to edit the xlsm, I have to run the malicious macro.

![624x227](upload://kbG1TMCcLkKOsf0Uyqnw5zX15mc.png)

The second script is odd to say the least, it includes a lot of documentation for some reason and a lot of nonsense comments and text. I found one valuable text though:

![624x62](upload://qBhstfn91sWj7MMLxF2NvVZSUJX.png)

Jokes aside this new macro is extremely obfuscated to the point where I could not use Daniels method of manual deobfuscation, so I decided to look for any valuable info. 

![624x212](upload://35P7Fkuezq9Fv7zN4GNLPGHPjlM.png)

One of the functions had Http function references and direct calls to some variable called myURL. The final function which I renamed to **DownloadFile** contains these references to the myURL Variable. Alas tho, this concluded with more confusing VBS code that I could not debug, for two reasons – being that this xlsm file is completely broken and I cant save it which doesn’t allow me to edit and debug the code properly and this method is also extremely dangerous as I couldn’t edit the malicious macro I kept executing the malware each time I opened the excel file. I had two more tools in my arsenal, one was to extract the two VBS files I’ve located within the excel and this can be done by manually opening the excel or using OLETools and honestly it’s a lot more safer to use OLETools so I set off to do just that.

**&lt;span style=&quot;text-decoration:underline;&quot;&gt;Method 2 – Using OLETools to examine the excel&lt;/span&gt;**

We know that there are embedded objects with the excel because we saw them and we know they are automatically saved inside the Temp folder as we opened the excel even if Macros are disabled and indeed it was true I found the files in the temp folder but if we want to extract the files safely we should use OLETools for that. I decided to use OLEVba first on the macro itself to see if it can extract anything meaningful from the macro, we located

![624x271](upload://iyPU62fuQybTrnxj5pZghtflE2h.png)

Thankfully OLEVba did a lot of the work for us! By detecting the location of the exe payload. I also noticed that there are 4 OLE objects embedded within the xlsm. As we recall we found the Equation Editor, xx, mm so let’s try extracting them.

![624x75](upload://qrE5yMg6NIintwmfrc14nI0835v.png)

Let’s use OLEDump to view the files embedded with in the script:

![624x377](upload://iUUQhKqv4v9EOngFmS068nimKGV.png)

So the M signifies macro, we know that Module2 contains the Auto_Run macro, and from what I can tell there are 3 interesting files:

**B, C, D** I think the sub numerators to each character represent data within these objects. We know that xx, mm and the equation editor are embedded within this excel and because D3 I’d be assuming that object D is the vulnerable equation editor file. I suspect that since Microsoft mitigated the EQ3 exploit the attacker embedded it inside the excel and one of the macros somehow executes it. Well let’s see:

![624x456](upload://cEU2859yGofeB6ptJ3jHmkiWa6K.png)

Alright, so this **mm** it looks like java script, interesting. 

I decided to view the **C2** stream which looks like the second stage vbs I found by viewing the excel manually it just looks... less obfuscated?

![624x385](upload://kxR6uRrlgvpFMn03t7wFpbr43JR.png)

The one I viewed looked very similar, after further inspection I realized this is the same script I saw before with less obfuscation. 

Alright, now lets view the final stream which is **D3**

![624x54](upload://tLESQZbF8OGTlWRva0KaFUImgcN.png)

As it looks like, this is the stack overflow implementation of the equation editor. The reason I assume this is because the long stream of bytes after the cmd shell string, also it looks very similar to the example POC given in the article I linked above regarding the CVE. I’ll dump this one as well.

![430x28](upload://g4QM3cixSCYvg3lEa4AqA8wLEK9.png)

All this does is rename the mm script to be named v, and then it executes. 

So, lets summarize our findings:

1. By examining the excel we know that a macro exists within it that loads another macro, we’ll call them first_stage and second_stage respectively 
2. We also know that there inside the excel file, there are 3 objects embedded within them:
    1. **xx**
    2. **mm**
    3. **E3shellcode**

By examining the E3shellcode we can safely assume its meant to exploit the equation editor, which does not exist in my excel version but we can assume that it is true because if we look inside the any.run flow  
![624x127](upload://oUABs0woY7iBDhdfCWWfehnzlnM.png)

We can see that EQNEDT32.EXE is calling that exact same shellcode, which is supposed to execute **mm**.

![624x263](upload://wtEYke3UAaxH3YWhqjvmAvyMfLa.png)

All mm does is execute **xx** and since we have vba script **xx **in its kinda deobfsucated form, so this time I’m really forced to analyze it. But one question arises? Why is there an exploit embedded within this excel AND a malicious macro that directly invokes **xx.vbs**? The answer for this is simple, since Microsoft mitigated the exploit in newer office versions the exploit will not work and why count on that? The threat actor dealt with that problem by additionally including a macro that would run the malware anyway. 

**&lt;span style=&quot;text-decoration:underline;&quot;&gt;Dealing with long, obfuscated, annoying and blinding VBA:&lt;/span&gt;**

We already kinda know that this VBA script is responsible for downloading a file off the internet and executing it but for the sake of practice, I wanted to try and debug this code myself. I started up by cleaning up trash code, giving variables meaningful names and finally cleaning up string fragmentation. 

The first two function called ase64Decode tse ase64Decode decodes base 64 code:

![624x702](upload://4zspUMlgruu7gtGeJUyOs3nlDTW.png)

It’s easy to tell because of the name and because it accepts strings as parameters and additionally we see a call to both of these functions passing two strings with comments next to them:

![469x36](upload://uny5kQiMQRWh6zwnuFGJevL7wsz.png)

“filestring” and “linkstring”, huh I wonder...

![444x515](upload://g4GJ8T8zFlYJLEqY4pY3xEIE7hb.png)

We found the payload location which will be downloaded, then the file would be saved in some location under name putty.exe, then a function called **KTx34hygf37it35hyr** which I renamed to **DownloadFile** downloads the payload to disk, how do I assume this? It’s literally documented within the macro.

![624x120](upload://5wUKoB6nQflm6f1tdmk6cKY5opz.png)

Then the file is saved into C:\ProgramData\ and executed:

![624x88](upload://mGZhg4IVIgmxdYkFJWXhWbvf9YV.png)

Awesome! One problem tho, if we try to access to the location of the malware we get:

![624x128](upload://iSOlTDq6YYvszJy4bb4bjVhHFwo.png)

God damnit, we’ll have to find this file manually online! But I have one more trick up my sleeve, what If I just try to access the website as is, without trying to access the sub domain:

![483x287](upload://a5ScOJakgqwbno7zwcNndYF9Acx.png)

It’s an open directory! Hosting files called **june11n** and **june11o**! I’m writing this as of date 2020 June 11&lt;sup&gt;th&lt;/sup&gt;, so the dates match but the document was viewing now as uploaded at 10&lt;sup&gt;th&lt;/sup&gt;! 

After downloading both files, I saw that june11n.exe is a zip file containing an email, and the other file was a regular exe file. I instantly assumed that this is the file that was missing holy.exe but further examining their hashes proved me wrong, but still it might be just packed differently but the final payload would be the same. For that I would need to further analyze the files.

***

## &lt;span style=&quot;text-decoration:underline;&quot;&gt;Initial Stagers Part 1 Summary:&lt;/span&gt;

**Holy.exe** –

Status: Packed 

SHA-256 - 29503feaa5debe98241301a773875a564f67a4183ed681bc90b582824de6944c

[https://bazaar.abuse.ch/sample/29503feaa5debe98241301a773875a564f67a4183ed681bc90b582824de6944c/](https://bazaar.abuse.ch/sample/29503feaa5debe98241301a773875a564f67a4183ed681bc90b582824de6944c/)

[https://www.virustotal.com/gui/file/29503feaa5debe98241301a773875a564f67a4183ed681bc90b582824de6944c/community](https://www.virustotal.com/gui/file/29503feaa5debe98241301a773875a564f67a4183ed681bc90b582824de6944c/community)

[https://analyze.intezer.com/#/analyses/c5194671-cc42-4f93-bdd9-bc8e8b575bd3/sub/78d7877a-362a-46d1-a1ae-0381d7fbbc5b](https://analyze.intezer.com/#/analyses/c5194671-cc42-4f93-bdd9-bc8e8b575bd3/sub/78d7877a-362a-46d1-a1ae-0381d7fbbc5b)

**June11o.exe** – 

Status: Packed

SHA-256 - B539A1F17ED0C58D80F9088A7AC9985454C4922C0126FFBA86A2B0F5C42D9599 

[https://www.virustotal.com/gui/file/b539a1f17ed0c58d80f9088a7ac9985454c4922c0126ffba86a2b0f5c42d9599/detection](https://www.virustotal.com/gui/file/b539a1f17ed0c58d80f9088a7ac9985454c4922c0126ffba86a2b0f5c42d9599/detection)

[https://analyze.intezer.com/#/analyses/eeef3469-99ef-440f-8956-ccb288cb801d/sub/8e9324ce-a470-46ee-abd2-d655e657e5da](https://analyze.intezer.com/%23/analyses/eeef3469-99ef-440f-8956-ccb288cb801d/sub/8e9324ce-a470-46ee-abd2-d655e657e5da)

**boasteel.us** -

[https://whois.domaintools.com/boasteel.us](https://whois.domaintools.com/boasteel.us)

[https://urlhaus.abuse.ch/browse.php?search=boasteel](https://urlhaus.abuse.ch/browse.php?search=boasteel)

***

## &lt;span style=&quot;text-decoration:underline;&quot;&gt;Dealing with Delphi Packers&lt;/span&gt;

In this section, I’ll be unpacking our malware. Dealing with SHA-256: 29503feaa5debe98241301a773875a564f67a4183ed681bc90b582824de6944c. I would not be performing a full malware analysis scenario, which means I would solely attempt to unpack the sample as is. 

**&lt;span style=&quot;text-decoration:underline;&quot;&gt;Static Analysis &lt;/span&gt;**

**&lt;span style=&quot;text-decoration:underline;&quot;&gt;PEStudio Artifacts:&lt;/span&gt;**

Entropy: 7.16, very high 

**PE Type**: PE32

**Compiler Type**: Borland Delphi

**Suspicious Resources:**

![624x183](upload://vdCawiCJhyEzRmVQ8t5B58kSdji.png)

![624x175](upload://isgZN0laQx5WrCTpee2IiQjJ9G1.png)

![624x166](upload://3t2tRue8zMxuLmsZUTMZtgKIKb0.png)

**&lt;span style=&quot;text-decoration:underline;&quot;&gt;IDA Artifacts:&lt;/span&gt;**

**Meaningful strings**: None

**Meaningful Imports**:

*   Resource Imports
*   VirtualAlloc
*   Create File
*   Write File
*   CreateThread

**&lt;span style=&quot;text-decoration:underline;&quot;&gt;Dynamic Analysis&lt;/span&gt;**

I decide by setting a break point on:

*   All the resource APIs
*   VirtualAlloc
*   VirtualProtect
*   CreateThread
*   WriteFile
*   CreateFile
*   CreateProcessInternalW

Additionally, to deal with Anti-RE I load Syclla-Hide.

I immediately break inside **VirtualAlloc** but only manage to get the allocated memory on the second time I hit **VirtualAlloc**. I decide to set up an hardware breakpoint on the first block of memory allocated and to break the debugger when it&#39;s hit.

![512x487](upload://lZrZpCMJTKXZKF3oqey83TTspxg.png)

But nothing interesting happens, I continue execution and land on **LockResource** twice, which means I’m accessing two of the resources but for some reason I did not break on **FindResource** which should be run before. Finally, after a few useless calls that lead to no where I landed on **FindResourceA** which passed the handle returned from it to **LockResource** and finally I got a handle to resource **1033:**

![624x81](upload://osSHgnJ8XceRaJ1igajy9cU0poZ.png)

Then the resource is copied to a different location using **VirtualAlloc**:

![590x160](upload://qQHwcebEJ1xoS49sJ95plVjpcMB.png)

I noticed the malware kept calling more resources again and again, without using strings to access the resource but with a unique ID and when I examined the resource section again I noticed over 200 resources that are trash:

![174x396](upload://qONcprKIOyP6DNc3qhO4VNOx2cN.png)

And the packer was just iterating through all of them. I thought that I can just stop debugging the APIs and see if I can somehow exit this loop. I returned from the call to **FindResource**, and returned back to the sample execution and then I thought that if I’d simply look up my location in IDA I could quickly analyze the loop but then I realized:

![624x262](upload://vgje9P1djI2pFds4nox8kCCc6Kz.png)

The sample decrypted itself, so I had to dump the PE and give it a look in IDA again:

![288x547](upload://6vddIauGNGw9jyPQPZSQZFhJV9G.png)

This little function kept calling itself, and I could assume these four blocks simply call FindResource-&gt;LockResource-&gt;-VirtualAlloc-&gt; memcpy, when I tried to access the functions there were calling this one and view them I got even more confused since the disassembly was completely obfuscated and trashed. I decided to take my chances, remove the breakpoints set on the resources functions and continue execution hoping that **VirtualProtect** would eventually be hit and attempt to change some shellcode or a copied .**text** section to executable. 

![624x120](upload://cZRdgL6GgNqHZvRIQX5Wr2lPxFk.png)

But instead I hit **CreateProcessInternalW**, this API was attempting to relaunch the malware in a suspended state:

![142x79](upload://yncrFIluw15SENV9LyrC3fxOMLe.png)

![624x34](upload://aaVkqVB65eRjDAWHp1SGhtoxeUw.png)

I decided to return set the breakpoints again on **VirtualAlloc** and **WriteProcessMemory**. I hit run and crashed!

Alright at least I know where I’m crashing, I restarted the sample and waiting till I hit **CreateProcessInternal**. After I hit it, I returned out of the API and kept stepping until I hit a suspicious functions:

![624x78](upload://4dUko8AAdgVRTLL98ChYsQyT3nT.png)

I decided not to skip it and examined the registers and I noticed one of them was pointing to a string with the value **“PE”**. PE Is the value of the Signature filed inside the IMAGE_NT_HEADERS. I quickly examined where the register was pointing at:

![595x166](upload://zcqHV5f7PfejQaGn1614QCTPtKx.png)

It’s a valid PE file! Alright so before I jump into my suspicious function I decide to dump this memory region:

![453x24](upload://wkDdqK2qFjWHlijgeXvmxXArZ0I.png)

As we can see it is still not executable so perhaps its also unmapped:

![624x184](upload://waTXmmC4lkhnjKGxGZhJBVY3aRJ.png)

The file is UPX packed! Alright so I can assume this is the second stage packing but before I confirm this I want to know where does my suspicious function lead.

![621x24](upload://rChgLUMEpkMAdwfMOUdsUbTGUWl.png)

Our function calls **ZwCreationSection**, which is usually for me the first indicator of process hollowing, it does so for the new process we spawned. Then on the function calls **ZwMapViewOfSection** on new section, next the malware calls **ZwMapViewOfSection** on itself, which means its going to map the **ImageBase.**

![223x115](upload://3Jtkm7w7uSJn0ZAM0l1gOCRYDnz.png) 

![170x18](upload://xrBYo4unjyVf9KF19IuWqbvB1R2.png)

![624x18](upload://csdVhoA5Wr0ARA8O4xGKh14o1oj.png)

Then the malware does something interesting:

![624x83](upload://4dRDQtbZ8og075Jr2EZtZA9ZBYD.png)

It enters a loop, where it begins to copy the new UPX file we dumped, byte by byte into the new section we created until eventually: 

![583x150](upload://qCeLjrPnXFXaVMNvlRn1FlPzNkh.png)

The malware copies the entire new file into this section. After the copying is complete, the malware attempts to get the context of the main thread of the new sub process, how do I know this? First let’s look at the stack before the **GetThreadContext**:

![338x44](upload://seGGupXREozAeYVeJPcrT0gUGTI.png)

![624x17](upload://wpdMTBvTZLaeLEz2hoATWNv6fcP.png)

This thread handle belongs to PID **EF4**:

![380x46](upload://qXYuo1hPqKhg1VUFTjKkApb8ahi.png)

![157x77](upload://hPZoHgyiW6mHfsZgTx00UaugU9Z.png)

It changes the process thread context to a new thread, which will execute the new file and invokes **NtResumeThread** to continue execution of the new subprocess:

![572x35](upload://p9A6A5crTse3GQnzhsOWJFVR5JB.png)

Let’s prove this hypothesis. Let’s access the new sub process in process hacker and view its memory:

![624x32](upload://iB3ZGG05U9lZcTUavlcNI44jUmR.png)

And dump it.

Let’s examine our mapped PE: 

![624x190](upload://ohf1LIbCbdKDLKMXPvXwqRYLFc4.png)

   
It matches our dumped PE exactly; the only difference is that its mapped to memory. So essentially what happened is very simple, our packed malware started a new sub process of itself, it mapped the original old **ImageBase** to memory and it mapped the other embedded **UPX** PE into memory. then it took the **UPX** PE memory and simply overwritten the new sub processes memory. after it completed it simply returns execution on the new PE. This is classic Process Hollowing. The PE seems unmapped so we can simply dump it.

I’ve used CFF Explorer to unpack it, upon viewing it seems it’s just a launcher. Its code section is small, containing two .text sections, The WinMain function is very linear. Usually there is a PE embedded within such a launcher that is executed in various techniques and if we examine the resource section

![624x125](upload://a6BIaVAWhftPifo5MBS5tSP6PmS.png)

Well, this isn’t very stealthy… ahaha alright let’s dump this out.

![516x273](upload://aCdORVmVLmJgpV6bSYkyygP6ZrT.png)

I suspect this is the final payload, as this a .NET file and the verdict on malware bazaar was Agent Tesla. Let’s look this file up in **VirusTotal and Intezer:**

![624x221](upload://fLLysSwCTfeO29aqCQBS0K1MbHx.png)

![624x255](upload://1mmaN4fNsDW9hfijsDqxFvoJV0d.png)

The verdict is clear, it’s Agent Tesla packed with **ConfuserEx**. We can use de4dot to deobfuscate **ConfuserEx** and continue analysis but that is beyond the scope of this post.

I hope you guys enjoyed this one :slight_smile: 

&lt;span style=&quot;text-decoration:underline;&quot;&gt;https://analyze.intezer.com/?utm_campaign=website%20to%20community&amp;utm_source=GetStarted%20#/analyses/f704c668-999c-4c7c-9941-9c19a8fb60de/sub/3f32622a-8f38-485a-9add-eea25f2beede&lt;/span&gt;

*** 

## &lt;span style=&quot;text-decoration:underline;&quot;&gt;Unpacking Delphi PE Summary:&lt;/span&gt;

**Packed SHA-256:**

29503FEAA5DEBE98241301A773875A564F67A4183ED681BC90B582824DE6944C

**Unpacked SHA-256(UPX PE):**

F3112BD51886FB705F33BEA0DDFA708AE6BABAB6F93162ABFDB931095EC6D116

**Unpacked UPX SHA-256:**

09A21333C61AA0DE5148E97AA238B8F8295E100891AA6A4F1F1108B27752FAD3

**Unpacked Resource SHA-256:**

c9b206aeded0795594a450b5717e65ba934c0dfab6005a8c696bd991ba96db15</description>
    
    <lastBuildDate>Sat, 13 Jun 2020 18:54:54 +0000</lastBuildDate>
    <category>Malware</category>
    <atom:link href="https://0x00sec.org/t/zero2auto-initial-stagers-from-one-email-to-a-trojan/21722.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>[Zero2Auto] – Initial Stagers - From one Email to a Trojan</title>
        <dc:creator><![CDATA[system]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 121 days. New replies are no longer allowed.</p>
          <p><a href="https://0x00sec.org/t/zero2auto-initial-stagers-from-one-email-to-a-trojan/21722/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/zero2auto-initial-stagers-from-one-email-to-a-trojan/21722/3</link>
        <pubDate>Sun, 11 Oct 2020 09:15:09 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-21722-3</guid>
        <source url="https://0x00sec.org/t/zero2auto-initial-stagers-from-one-email-to-a-trojan/21722.rss">[Zero2Auto] – Initial Stagers - From one Email to a Trojan</source>
      </item>
      <item>
        <title>[Zero2Auto] – Initial Stagers - From one Email to a Trojan</title>
        <dc:creator><![CDATA[pry0cc]]></dc:creator>
        <description><![CDATA[
            <p>This is a fantastic article I read the other day, I just remembered now to comment!</p>
<p>It was crazy how it went down that rabbit-hole, brilliant reversing dude!</p>
          <p><a href="https://0x00sec.org/t/zero2auto-initial-stagers-from-one-email-to-a-trojan/21722/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/zero2auto-initial-stagers-from-one-email-to-a-trojan/21722/2</link>
        <pubDate>Sat, 13 Jun 2020 18:54:54 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-21722-2</guid>
        <source url="https://0x00sec.org/t/zero2auto-initial-stagers-from-one-email-to-a-trojan/21722.rss">[Zero2Auto] – Initial Stagers - From one Email to a Trojan</source>
      </item>
      <item>
        <title>[Zero2Auto] – Initial Stagers - From one Email to a Trojan</title>
        <dc:creator><![CDATA[Danus]]></dc:creator>
        <description><![CDATA[
            <h1>Zero2Auto – Initial Stagers - From one Email to a Trojan</h1>
<h2>Preface</h2>
<p>This week we have discussed deobfuscating initial stagers and how to unpack their executable payloads.<br>
And what I’ve decided to do, to practice this week lesson is to find actual malware on any.run and unpack its entire initial stage.</p>
<p><strong>Setting up goals:</strong></p>
<ol>
<li>I’ll choose an infected document from any.run, then I’ll deobfuscate it and extract its payload</li>
<li>I’ll take the payload and unpack it from memory, showcasing how to unmap a dumped PE</li>
<li>I’ll attempt to practice the first lesson by finding identifying encryption schemes or known algorithms within the payload.</li>
</ol>
<p><strong>Required background:</strong></p>
<ol>
<li>Knowledge in reversing VBA code</li>
<li>Knowledge in reversing PowerShell code</li>
<li>Knowledge in various analysis utilities (Process Hacker, PEBear, PEStudio, PEId)</li>
<li>Knowledge in IDA Pro</li>
<li>Knowledge in x64dbg</li>
<li>Basic understanding of stack overflow exploits and how to debug shellcode</li>
</ol>
<hr>
<h2><span>Choosing a Target:</span></h2>
<p>I decide to go on any.run to find an interesting sample – I have experience in macro deobfuscation so I decide to look for a infected document hosting an exploit which delivers a payload.</p>
<p>I decide to filter MS Office files with an exploit tag, and quickly find a huge batch of files:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/f/fb4e50bd5d0cc4c701f56b0adedba214790a6e41.png" alt="" data-base62-sha1="zR9Dn3Cg5BEOHVSpuOB9TOdKqHf" width="624" height="295"></p>
<p>Its valuable to mention that <strong>CVE-2017-11882</strong>(<a href="https://unit42.paloaltonetworks.com/unit42-analysis-of-cve-2017-11882-exploit-in-the-wild/" rel="noopener nofollow ugc">you can read about it here</a>) is the same exploit used in the Zero2Auto lesson and it seems as it’s the most used exploit when delivering malicious docs. I’ve also observed that the exploit is sometimes leveraged that attacks the Outlook app directly when I filtered for email message file types:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/1/1b4b68d1f708f80e85bd179b8ce578a7b1cb3231.png" alt="" data-base62-sha1="3TssfKSwLYsN4MN6J0ktHOfsJPj" width="624" height="294"></p>
<p>I have chosen the following sample:</p>
<p><a href="https://app.any.run/tasks/fce8f628-52cf-4f5d-968c-ab59ddeaabda/" rel="noopener nofollow ugc">https://app.any.run/tasks/fce8f628-52cf-4f5d-968c-ab59ddeaabda/</a> and the reason for that mainly is because the infection chain is long, contains a wsf script, a vbs script and finally an EXE payload thus it could give me a lot of room to practice my knowledge.</p>
<hr>
<h2><span>From an email lure to an exploit:</span></h2>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/2/2af671581864080fc73ea5e6e68e688205072593.png" alt="" data-base62-sha1="6843p6aLdpZWOZEhE2DpFWKY8ZJ" width="624" height="336"></p>
<p>I decide to extract the excel document and inspect it(SHA-256 97CC9023C114013326A97E946B0CA71BB641952208B5BA04463F1DAF15E1A5B5).</p>
<p><strong><span>Method 1 – Examining the document by opening it</span></strong></p>
<p>The first method is rather, not very safe to say the least but you should be fine if you have macros disabled by default, so I open up the Excel document and I’m met with the following:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/0/05acfdf64a38e7877f2bcad6b4eb551e704462eb.png" alt="" data-base62-sha1="Od1j3FeuaEwMjbwsJww1Th2V2H" width="624" height="286"></p>
<p>I’m definitely not going to enable macros but before I review the macros I decided to check out the rest of the sheets. Sheet number 2 has a very interesting object within it:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/0/05dceef19af70508319bc020dfd22c6e77c3b974.png" alt="" data-base62-sha1="PRJz2MgXwkMdDmiti9k20ScEGE" width="195" height="101"></p>
<p>And if you double click it:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/9/944bd2f8763d7fdfbebb536d2fb24241e6576e52.png" alt="" data-base62-sha1="l9T7jFloi34h8VakFTJOWRTn6Yq" width="624" height="201"></p>
<p>This is an equation editor object that was embedded within the document, as I’m running on a fairly new MS Office version and this exploit was long ago mitigated on new versions I would expect I’d run into problems in performing this exploit but I bet I can do some stuff with the shellcode itself if we find it. Let’s continue to Sheet3:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/9/9264d7200b0dd23514a0f544162a3ffbe7b075e7.png" alt="" data-base62-sha1="kT3L7PzFTltvQlsUa8OmLydIKCb" width="143" height="193"></p>
<p>An observant person like myself (flex much danus?) noticed this two little square and if we double click them, we’ll see that they are actually objects embedded within this document</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/d/d785b20eaf6ab9e40cb0faf9d9eae183a4c57bb7.png" alt="" data-base62-sha1="uKB62PZ8a2iCQE5G79e0Qg4BAW3" width="518" height="462"></p>
<p>These can also be seen being launched in the any.run view:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/b/b2b19a36ed270f5141cfeecb9273dfee8b960db6.png" alt="" data-base62-sha1="puNv4kUI5ljZ2YWVfWYOy5pbaXI" width="624" height="331"></p>
<p>What was interesting that if we decide to the view the locations of these embedded objects</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/3/3a34f012da7e305a94d2417e102c6f0038d12b7e.png" alt="" data-base62-sha1="8iV6WqjIIMjBCK8iYUt5Qso3HuC" width="466" height="184"></p>
<p>They are located within the Temp folder, but I never downloaded them.</p>
<p>To be honest, at this point we can stop the analyzes and simply dump these objects but I would like to review the actual shellcode of the exploit itself just to analyze it. So, I decided to enter the macro editor, and would you like at what I’ve found:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/a/a947876c3beb639b283595e0fb7f5e8ba1fe58ed.png" alt="" data-base62-sha1="o9vWrD0sfaZrWVhwlo57oyZx7bv" width="377" height="101"></p>
<p><strong>Auto_Open</strong> is great news for us!</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/8/8ae822906db56871d854325e92b0f50baaeccda2.png" alt="" data-base62-sha1="jOPeKuo7LVDKPtJvWr5PmoztY1I" width="624" height="219"></p>
<p>I’ve decided to remove the macro deobfuscation from the scope of this blog because it’s pretty straight forward, so I’ll summarize it. This first stage macro contains another macro within itself, it copies this macro inside C:/Programdata/asc.txt and then it runs the newly written macro. There is one problem with this method though, this xlsm file is trashed and I can’t modify it. It means that every time I want to edit the xlsm, I have to run the malicious macro.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/8/8d7d6b10ca879fe28563b9264a8c7e95bfb0a2fc.png" alt="" data-base62-sha1="kbG1TMCcLkKOsf0Uyqnw5zX15mc" width="624" height="227"></p>
<p>The second script is odd to say the least, it includes a lot of documentation for some reason and a lot of nonsense comments and text. I found one valuable text though:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/b/ba6f63920648616dfbd1f6d2d6e0df83edcb8841.png" alt="" data-base62-sha1="qBhstfn91sWj7MMLxF2NvVZSUJX" width="624" height="62"></p>
<p>Jokes aside this new macro is extremely obfuscated to the point where I could not use Daniels method of manual deobfuscation, so I decided to look for any valuable info.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/1/15af133cee9c6ea8f305fb44006b80b2e2e971aa.png" alt="" data-base62-sha1="35P7Fkuezq9Fv7zN4GNLPGHPjlM" width="624" height="212"></p>
<p>One of the functions had Http function references and direct calls to some variable called myURL. The final function which I renamed to <strong>DownloadFile</strong> contains these references to the myURL Variable. Alas tho, this concluded with more confusing VBS code that I could not debug, for two reasons – being that this xlsm file is completely broken and I cant save it which doesn’t allow me to edit and debug the code properly and this method is also extremely dangerous as I couldn’t edit the malicious macro I kept executing the malware each time I opened the excel file. I had two more tools in my arsenal, one was to extract the two VBS files I’ve located within the excel and this can be done by manually opening the excel or using OLETools and honestly it’s a lot more safer to use OLETools so I set off to do just that.</p>
<p><strong><span>Method 2 – Using OLETools to examine the excel</span></strong></p>
<p>We know that there are embedded objects with the excel because we saw them and we know they are automatically saved inside the Temp folder as we opened the excel even if Macros are disabled and indeed it was true I found the files in the temp folder but if we want to extract the files safely we should use OLETools for that. I decided to use OLEVba first on the macro itself to see if it can extract anything meaningful from the macro, we located</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/8/8217427a7c4f485fd2fd6f6f4bd41f9628c10415.png" alt="" data-base62-sha1="iyPU62fuQybTrnxj5pZghtflE2h" width="624" height="271"></p>
<p>Thankfully OLEVba did a lot of the work for us! By detecting the location of the exe payload. I also noticed that there are 4 OLE objects embedded within the xlsm. As we recall we found the Equation Editor, xx, mm so let’s try extracting them.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/b/b95891993a26d291409231eee90ae4f24d822161.png" alt="" data-base62-sha1="qrE5yMg6NIintwmfrc14nI0835v" width="624" height="75"></p>
<p>Let’s use OLEDump to view the files embedded with in the script:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://0x00sec.s3.amazonaws.com/original/2X/8/8496350482858e65f57d462eaec49db1b4abdbad.png" data-download-href="/uploads/short-url/iUUQhKqv4v9EOngFmS068nimKGV.png?dl=1" title="" rel="noopener nofollow ugc"><img src="https://0x00sec.s3.amazonaws.com/original/2X/8/8496350482858e65f57d462eaec49db1b4abdbad.png" alt="" data-base62-sha1="iUUQhKqv4v9EOngFmS068nimKGV" width="624" height="377" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/8/8496350482858e65f57d462eaec49db1b4abdbad_2_10x10.png"></a></div><p></p>
<p>So the M signifies macro, we know that Module2 contains the Auto_Run macro, and from what I can tell there are 3 interesting files:</p>
<p><strong>B, C, D</strong> I think the sub numerators to each character represent data within these objects. We know that xx, mm and the equation editor are embedded within this excel and because D3 I’d be assuming that object D is the vulnerable equation editor file. I suspect that since Microsoft mitigated the EQ3 exploit the attacker embedded it inside the excel and one of the macros somehow executes it. Well let’s see:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/5/58b9c5e7bf4c7a2d56970ddb648554eb8a81cb9a.png" alt="" data-base62-sha1="cEU2859yGofeB6ptJ3jHmkiWa6K" width="624" height="456"></p>
<p>Alright, so this <strong>mm</strong> it looks like java script, interesting.</p>
<p>I decided to view the <strong>C2</strong> stream which looks like the second stage vbs I found by viewing the excel manually it just looks… less obfuscated?</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/8/8fff3abbd32c55aeaacb9fcc1b8cf09913ee4817.png" alt="" data-base62-sha1="kxR6uRrlgvpFMn03t7wFpbr43JR" width="624" height="385"></p>
<p>The one I viewed looked very similar, after further inspection I realized this is the same script I saw before with less obfuscation.</p>
<p>Alright, now lets view the final stream which is <strong>D3</strong></p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/d/d0a23a3ff9ac022751419040434a376b4c95d3a9.png" alt="" data-base62-sha1="tLESQZbF8OGTlWRva0KaFUImgcN" width="624" height="54"></p>
<p>As it looks like, this is the stack overflow implementation of the equation editor. The reason I assume this is because the long stream of bytes after the cmd shell string, also it looks very similar to the example POC given in the article I linked above regarding the CVE. I’ll dump this one as well.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/7/70af2b5260d8a362ee8da3796760777be5a50055.png" alt="" data-base62-sha1="g4QM3cixSCYvg3lEa4AqA8wLEK9" width="430" height="28"></p>
<p>All this does is rename the mm script to be named v, and then it executes.</p>
<p>So, lets summarize our findings:</p>
<ol>
<li>By examining the excel we know that a macro exists within it that loads another macro, we’ll call them first_stage and second_stage respectively</li>
<li>We also know that there inside the excel file, there are 3 objects embedded within them:
<ol>
<li><strong>xx</strong></li>
<li><strong>mm</strong></li>
<li><strong>E3shellcode</strong></li>
</ol>
</li>
</ol>
<p>By examining the E3shellcode we can safely assume its meant to exploit the equation editor, which does not exist in my excel version but we can assume that it is true because if we look inside the any.run flow<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/a/ae99cde6e3e2d462c9733267de01246cc283e64e.png" alt="" data-base62-sha1="oUABs0woY7iBDhdfCWWfehnzlnM" width="624" height="127"></p>
<p>We can see that EQNEDT32.EXE is calling that exact same shellcode, which is supposed to execute <strong>mm</strong>.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/e/e39fe6c372a76f7dbf121e17b919a9eb2994ac68.png" alt="" data-base62-sha1="wtEYke3UAaxH3YWhqjvmAvyMfLa" width="624" height="263"></p>
<p>All mm does is execute <strong>xx</strong> and since we have vba script **xx **in its kinda deobfsucated form, so this time I’m really forced to analyze it. But one question arises? Why is there an exploit embedded within this excel AND a malicious macro that directly invokes <strong>xx.vbs</strong>? The answer for this is simple, since Microsoft mitigated the exploit in newer office versions the exploit will not work and why count on that? The threat actor dealt with that problem by additionally including a macro that would run the malware anyway.</p>
<p><strong><span>Dealing with long, obfuscated, annoying and blinding VBA:</span></strong></p>
<p>We already kinda know that this VBA script is responsible for downloading a file off the internet and executing it but for the sake of practice, I wanted to try and debug this code myself. I started up by cleaning up trash code, giving variables meaningful names and finally cleaning up string fragmentation.</p>
<p>The first two function called ase64Decode tse ase64Decode decodes base 64 code:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/2/200accce4db322e9d44dc8bebe1f48155848be90.png" alt="" data-base62-sha1="4zspUMlgruu7gtGeJUyOs3nlDTW" width="444" height="500"></p>
<p>It’s easy to tell because of the name and because it accepts strings as parameters and additionally we see a call to both of these functions passing two strings with comments next to them:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/d/d4eab593f568cbee9032e9b5afaf2e65f7844443.png" alt="" data-base62-sha1="uny5kQiMQRWh6zwnuFGJevL7wsz" width="469" height="36"></p>
<p>“filestring” and “linkstring”, huh I wonder…</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/7/70aa7ad881d69c7aace2c08c0564ab0b27542285.png" alt="" data-base62-sha1="g4GJ8T8zFlYJLEqY4pY3xEIE7hb" width="431" height="500"></p>
<p>We found the payload location which will be downloaded, then the file would be saved in some location under name putty.exe, then a function called <strong>KTx34hygf37it35hyr</strong> which I renamed to <strong>DownloadFile</strong> downloads the payload to disk, how do I assume this? It’s literally documented within the macro.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/2/26c361d89d367be24e804536c6ae8b2079441769.png" alt="" data-base62-sha1="5wUKoB6nQflm6f1tdmk6cKY5opz" width="624" height="120"></p>
<p>Then the file is saved into C:\ProgramData\ and executed:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/9/9f0bd64325acafb6de1996513467a1b50a0a4ffd.png" alt="" data-base62-sha1="mGZhg4IVIgmxdYkFJWXhWbvf9YV" width="624" height="88"></p>
<p>Awesome! One problem tho, if we try to access to the location of the malware we get:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/8/84594d1fe2937d56c81f5bf12545a25d1a4b6e54.png" alt="" data-base62-sha1="iSOlTDq6YYvszJy4bb4bjVhHFwo" width="624" height="128"></p>
<p>God damnit, we’ll have to find this file manually online! But I have one more trick up my sleeve, what If I just try to access the website as is, without trying to access the sub domain:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/4/46bfbb613d7828b9c2245e39ac17f9aa76f88621.png" alt="" data-base62-sha1="a5ScOJakgqwbno7zwcNndYF9Acx" width="483" height="287"></p>
<p>It’s an open directory! Hosting files called <strong>june11n</strong> and <strong>june11o</strong>! I’m writing this as of date 2020 June 11<sup>th</sup>, so the dates match but the document was viewing now as uploaded at 10<sup>th</sup>!</p>
<p>After downloading both files, I saw that june11n.exe is a zip file containing an email, and the other file was a regular exe file. I instantly assumed that this is the file that was missing holy.exe but further examining their hashes proved me wrong, but still it might be just packed differently but the final payload would be the same. For that I would need to further analyze the files.</p>
<hr>
<h2><span>Initial Stagers Part 1 Summary:</span></h2>
<p><strong>Holy.exe</strong> –</p>
<p>Status: Packed</p>
<p>SHA-256 - 29503feaa5debe98241301a773875a564f67a4183ed681bc90b582824de6944c</p>
<p><a href="https://bazaar.abuse.ch/sample/29503feaa5debe98241301a773875a564f67a4183ed681bc90b582824de6944c/" rel="noopener nofollow ugc">https://bazaar.abuse.ch/sample/29503feaa5debe98241301a773875a564f67a4183ed681bc90b582824de6944c/</a></p>
<p><a href="https://www.virustotal.com/gui/file/29503feaa5debe98241301a773875a564f67a4183ed681bc90b582824de6944c/community" rel="noopener nofollow ugc">https://www.virustotal.com/gui/file/29503feaa5debe98241301a773875a564f67a4183ed681bc90b582824de6944c/community</a></p>
<p><a href="https://analyze.intezer.com/#/analyses/c5194671-cc42-4f93-bdd9-bc8e8b575bd3/sub/78d7877a-362a-46d1-a1ae-0381d7fbbc5b" rel="noopener nofollow ugc">https://analyze.intezer.com/#/analyses/c5194671-cc42-4f93-bdd9-bc8e8b575bd3/sub/78d7877a-362a-46d1-a1ae-0381d7fbbc5b</a></p>
<p><strong>June11o.exe</strong> –</p>
<p>Status: Packed</p>
<p>SHA-256 - B539A1F17ED0C58D80F9088A7AC9985454C4922C0126FFBA86A2B0F5C42D9599</p>
<p><a href="https://www.virustotal.com/gui/file/b539a1f17ed0c58d80f9088a7ac9985454c4922c0126ffba86a2b0f5c42d9599/detection" rel="noopener nofollow ugc">https://www.virustotal.com/gui/file/b539a1f17ed0c58d80f9088a7ac9985454c4922c0126ffba86a2b0f5c42d9599/detection</a></p>
<p><a href="https://analyze.intezer.com/%23/analyses/eeef3469-99ef-440f-8956-ccb288cb801d/sub/8e9324ce-a470-46ee-abd2-d655e657e5da" rel="noopener nofollow ugc">https://analyze.intezer.com/#/analyses/eeef3469-99ef-440f-8956-ccb288cb801d/sub/8e9324ce-a470-46ee-abd2-d655e657e5da</a></p>
<p><strong><a href="http://boasteel.us" rel="noopener nofollow ugc">boasteel.us</a></strong> -</p>
<p><a href="https://whois.domaintools.com/boasteel.us" rel="noopener nofollow ugc">https://whois.domaintools.com/boasteel.us</a></p>
<p><a href="https://urlhaus.abuse.ch/browse.php?search=boasteel" rel="noopener nofollow ugc">https://urlhaus.abuse.ch/browse.php?search=boasteel</a></p>
<hr>
<h2><span>Dealing with Delphi Packers</span></h2>
<p>In this section, I’ll be unpacking our malware. Dealing with SHA-256: 29503feaa5debe98241301a773875a564f67a4183ed681bc90b582824de6944c. I would not be performing a full malware analysis scenario, which means I would solely attempt to unpack the sample as is.</p>
<p><strong><span>Static Analysis </span></strong></p>
<p><strong><span>PEStudio Artifacts:</span></strong></p>
<p>Entropy: 7.16, very high</p>
<p><strong>PE Type</strong>: PE32</p>
<p><strong>Compiler Type</strong>: Borland Delphi</p>
<p><strong>Suspicious Resources:</strong></p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/d/dacd68086386f3796561a6aaf32359e7d63e7230.png" alt="" data-base62-sha1="vdCawiCJhyEzRmVQ8t5B58kSdji" width="624" height="183"></p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/8/8159562ff884b831743dae970754c2ad576b3e19.png" alt="" data-base62-sha1="isgZN0laQx5WrCTpee2IiQjJ9G1" width="624" height="175"></p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/1/184ee3ff6c9331f4a918a3e27ff8a60e543feba2.png" alt="" data-base62-sha1="3t2tRue8zMxuLmsZUTMZtgKIKb0" width="624" height="166"></p>
<p><strong><span>IDA Artifacts:</span></strong></p>
<p><strong>Meaningful strings</strong>: None</p>
<p><strong>Meaningful Imports</strong>:</p>
<ul>
<li>Resource Imports</li>
<li>VirtualAlloc</li>
<li>Create File</li>
<li>Write File</li>
<li>CreateThread</li>
</ul>
<p><strong><span>Dynamic Analysis</span></strong></p>
<p>I decide by setting a break point on:</p>
<ul>
<li>All the resource APIs</li>
<li>VirtualAlloc</li>
<li>VirtualProtect</li>
<li>CreateThread</li>
<li>WriteFile</li>
<li>CreateFile</li>
<li>CreateProcessInternalW</li>
</ul>
<p>Additionally, to deal with Anti-RE I load Syclla-Hide.</p>
<p>I immediately break inside <strong>VirtualAlloc</strong> but only manage to get the allocated memory on the second time I hit <strong>VirtualAlloc</strong>. I decide to set up an hardware breakpoint on the first block of memory allocated and to break the debugger when it’s hit.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/9/9a1ff4197fced7abab8b60f805a31a6e48a38de2.png" alt="" data-base62-sha1="lZrZpCMJTKXZKF3oqey83TTspxg" width="512" height="487"></p>
<p>But nothing interesting happens, I continue execution and land on <strong>LockResource</strong> twice, which means I’m accessing two of the resources but for some reason I did not break on <strong>FindResource</strong> which should be run before. Finally, after a few useless calls that lead to no where I landed on <strong>FindResourceA</strong> which passed the handle returned from it to <strong>LockResource</strong> and finally I got a handle to resource <strong>1033:</strong></p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/a/ab77fa35f409e84ffc787f7f5ea4126d92326fb1.png" alt="" data-base62-sha1="osSHgnJ8XceRaJ1igajy9cU0poZ" width="624" height="81"></p>
<p>Then the resource is copied to a different location using <strong>VirtualAlloc</strong>:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/b/bc2da072d6267c0a2f7b6523083c93419aa58ffd.png" alt="" data-base62-sha1="qQHwcebEJ1xoS49sJ95plVjpcMB" width="590" height="160"></p>
<p>I noticed the malware kept calling more resources again and again, without using strings to access the resource but with a unique ID and when I examined the resource section again I noticed over 200 resources that are trash:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/b/bbf666d5699c3a410d07e9ff5a1768375c268059.png" alt="" data-base62-sha1="qONcprKIOyP6DNc3qhO4VNOx2cN" width="174" height="396"></p>
<p>And the packer was just iterating through all of them. I thought that I can just stop debugging the APIs and see if I can somehow exit this loop. I returned from the call to <strong>FindResource</strong>, and returned back to the sample execution and then I thought that if I’d simply look up my location in IDA I could quickly analyze the loop but then I realized:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/d/db1b6164dcdcc7b8c0f182ee3fca45c540f29c9f.png" alt="" data-base62-sha1="vgje9P1djI2pFds4nox8kCCc6Kz" width="624" height="262"></p>
<p>The sample decrypted itself, so I had to dump the PE and give it a look in IDA again:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/2/2d944d3e605e8ec992fa4e4c3f0c65e6762ac504.png" alt="" data-base62-sha1="6vddIauGNGw9jyPQPZSQZFhJV9G" width="263" height="500"></p>
<p>This little function kept calling itself, and I could assume these four blocks simply call FindResource-&gt;LockResource-&gt;-VirtualAlloc-&gt; memcpy, when I tried to access the functions there were calling this one and view them I got even more confused since the disassembly was completely obfuscated and trashed. I decided to take my chances, remove the breakpoints set on the resources functions and continue execution hoping that <strong>VirtualProtect</strong> would eventually be hit and attempt to change some shellcode or a copied .<strong>text</strong> section to executable.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/5/5b182928b2d25abe335f891a389b4fee3ad99abe.png" alt="" data-base62-sha1="cZRdgL6GgNqHZvRIQX5Wr2lPxFk" width="624" height="120"></p>
<p>But instead I hit <strong>CreateProcessInternalW</strong>, this API was attempting to relaunch the malware in a suspended state:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/f/f0e94e0d7938b369983041f201caba8078f58d90.png" alt="" data-base62-sha1="yncrFIluw15SENV9LyrC3fxOMLe" width="142" height="79"></p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/4/4751e187b6023d36c4782399b5a838ad407b6300.png" alt="" data-base62-sha1="aaVkqVB65eRjDAWHp1SGhtoxeUw" width="624" height="34"></p>
<p>I decided to return set the breakpoints again on <strong>VirtualAlloc</strong> and <strong>WriteProcessMemory</strong>. I hit run and crashed!</p>
<p>Alright at least I know where I’m crashing, I restarted the sample and waiting till I hit <strong>CreateProcessInternal</strong>. After I hit it, I returned out of the API and kept stepping until I hit a suspicious functions:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/1/1d9b2f58bc58149ed63781c90c4fdba97e8b87bd.png" alt="" data-base62-sha1="4dUko8AAdgVRTLL98ChYsQyT3nT" width="624" height="78"></p>
<p>I decided not to skip it and examined the registers and I noticed one of them was pointing to a string with the value <strong>“PE”</strong>. PE Is the value of the Signature filed inside the IMAGE_NT_HEADERS. I quickly examined where the register was pointing at:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/f/f6b3d07f5cd6b24a62c58b2f3ed8167e6671a0d1.png" alt="" data-base62-sha1="zcqHV5f7PfejQaGn1614QCTPtKx" width="595" height="166"></p>
<p>It’s a valid PE file! Alright so before I jump into my suspicious function I decide to dump this memory region:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/e/e29aa314860286c44a997575a8c5ae9534047968.png" alt="" data-base62-sha1="wkDdqK2qFjWHlijgeXvmxXArZ0I" width="453" height="24"></p>
<p>As we can see it is still not executable so perhaps its also unmapped:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/e/e181115e35a3c89c5a76430ffa9a3f1ca9fc6673.png" alt="" data-base62-sha1="waTXmmC4lkhnjKGxGZhJBVY3aRJ" width="624" height="184"></p>
<p>The file is UPX packed! Alright so I can assume this is the second stage packing but before I confirm this I want to know where does my suspicious function lead.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/c/c18e69c32ab60ac564f265ac3ddc4ecc3bc08ec1.png" alt="" data-base62-sha1="rChgLUMEpkMAdwfMOUdsUbTGUWl" width="621" height="24"></p>
<p>Our function calls <strong>ZwCreationSection</strong>, which is usually for me the first indicator of process hollowing, it does so for the new process we spawned. Then on the function calls <strong>ZwMapViewOfSection</strong> on new section, next the malware calls <strong>ZwMapViewOfSection</strong> on itself, which means its going to map the <strong>ImageBase.</strong></p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/1/1a2a6f10c65af67c39f74754eadcd5b3dc8bab81.png" alt="" data-base62-sha1="3Jtkm7w7uSJn0ZAM0l1gOCRYDnz" width="223" height="115"></p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/e/ea66cc8da21dfa04f0c70d4726ebe64a94c7e9c4.png" alt="" data-base62-sha1="xrBYo4unjyVf9KF19IuWqbvB1R2" width="170" height="18"></p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/5/574adbd182742646ce3ad83a66c5c99beb4e1587.png" alt="" data-base62-sha1="csdVhoA5Wr0ARA8O4xGKh14o1oj" width="624" height="18"></p>
<p>Then the malware does something interesting:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/1/1d99ee6208085e94477bda7acf24ce673481612b.png" alt="" data-base62-sha1="4dRDQtbZ8og075Jr2EZtZA9ZBYD" width="624" height="83"></p>
<p>It enters a loop, where it begins to copy the new UPX file we dumped, byte by byte into the new section we created until eventually:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/b/ba8b119fa680bba359898371e6563422c4d21be5.png" alt="" data-base62-sha1="qCeLjrPnXFXaVMNvlRn1FlPzNkh" width="583" height="150"></p>
<p>The malware copies the entire new file into this section. After the copying is complete, the malware attempts to get the context of the main thread of the new sub process, how do I know this? First let’s look at the stack before the <strong>GetThreadContext</strong>:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/c/c5e5ee300b9f0270cd5ecef978d92aec9aa265a6.png" alt="" data-base62-sha1="seGGupXREozAeYVeJPcrT0gUGTI" width="338" height="44"></p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/e/e31f75c678d6dc442ece3ed6d9ad1546250548f7.png" alt="" data-base62-sha1="wpdMTBvTZLaeLEz2hoATWNv6fcP" width="624" height="17"></p>
<p>This thread handle belongs to PID <strong>EF4</strong>:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/b/bd001da845045f15608d1d5cc5b1bffc48d2c6a8.png" alt="" data-base62-sha1="qXYuo1hPqKhg1VUFTjKkApb8ahi" width="380" height="46"></p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/7/7d0577bcd00b31449d80f9aca78d276e6e55cb6b.png" alt="" data-base62-sha1="hPZoHgyiW6mHfsZgTx00UaugU9Z" width="157" height="77"></p>
<p>It changes the process thread context to a new thread, which will execute the new file and invokes <strong>NtResumeThread</strong> to continue execution of the new subprocess:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/b/b04ba57139259aad6ef3850879444e168a18f227.png" alt="" data-base62-sha1="p9A6A5crTse3GQnzhsOWJFVR5JB" width="572" height="35"></p>
<p>Let’s prove this hypothesis. Let’s access the new sub process in process hacker and view its memory:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/8/8257b67a4b621e64e6fbc6015771e46ece102711.png" alt="" data-base62-sha1="iB3ZGG05U9lZcTUavlcNI44jUmR" width="624" height="32"></p>
<p>And dump it.</p>
<p>Let’s examine our mapped PE:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/a/aa272404f98a92b9bc5808c3a2a7a19ecbd0deb8.png" alt="" data-base62-sha1="ohf1LIbCbdKDLKMXPvXwqRYLFc4" width="624" height="190"></p>
<p>It matches our dumped PE exactly; the only difference is that its mapped to memory. So essentially what happened is very simple, our packed malware started a new sub process of itself, it mapped the original old <strong>ImageBase</strong> to memory and it mapped the other embedded <strong>UPX</strong> PE into memory. then it took the <strong>UPX</strong> PE memory and simply overwritten the new sub processes memory. after it completed it simply returns execution on the new PE. This is classic Process Hollowing. The PE seems unmapped so we can simply dump it.</p>
<p>I’ve used CFF Explorer to unpack it, upon viewing it seems it’s just a launcher. Its code section is small, containing two .text sections, The WinMain function is very linear. Usually there is a PE embedded within such a launcher that is executed in various techniques and if we examine the resource section</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/4/46d4f8bc0428629564fe420f8d10dbcb7d561a56.png" alt="" data-base62-sha1="a6BIaVAWhftPifo5MBS5tSP6PmS" width="624" height="125"></p>
<p>Well, this isn’t very stealthy… ahaha alright let’s dump this out.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/4/4a67d869cac475f1e8ea308b8dc69cbf3506a935.png" alt="" data-base62-sha1="aCdORVmVLmJgpV6bSYkyygP6ZrT" width="516" height="273"></p>
<p>I suspect this is the final payload, as this a .NET file and the verdict on malware bazaar was Agent Tesla. Let’s look this file up in <strong>VirusTotal and Intezer:</strong></p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/6/6e86e7dc9b8ad5e25a97eae217ddab817f105287.png" alt="" data-base62-sha1="fLLysSwCTfeO29aqCQBS0K1MbHx" width="624" height="221"></p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/0/09892a7fa322db45d5fe267cbcbcdde9ca96c4e9.png" alt="" data-base62-sha1="1mmaN4fNsDW9hfijsDqxFvoJV0d" width="624" height="255"></p>
<p>The verdict is clear, it’s Agent Tesla packed with <strong>ConfuserEx</strong>. We can use de4dot to deobfuscate <strong>ConfuserEx</strong> and continue analysis but that is beyond the scope of this post.</p>
<p>I hope you guys enjoyed this one <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<p><span><a href="https://analyze.intezer.com/?utm_campaign=website%20to%20community&amp;utm_source=GetStarted%20#/analyses/f704c668-999c-4c7c-9941-9c19a8fb60de/sub/3f32622a-8f38-485a-9add-eea25f2beede" rel="noopener nofollow ugc">https://analyze.intezer.com/?utm_campaign=website%20to%20community&amp;utm_source=GetStarted%20#/analyses/f704c668-999c-4c7c-9941-9c19a8fb60de/sub/3f32622a-8f38-485a-9add-eea25f2beede</a></span></p>
<hr>
<h2><span>Unpacking Delphi PE Summary:</span></h2>
<p><strong>Packed SHA-256:</strong></p>
<p>29503FEAA5DEBE98241301A773875A564F67A4183ED681BC90B582824DE6944C</p>
<p><strong>Unpacked SHA-256(UPX PE):</strong></p>
<p>F3112BD51886FB705F33BEA0DDFA708AE6BABAB6F93162ABFDB931095EC6D116</p>
<p><strong>Unpacked UPX SHA-256:</strong></p>
<p>09A21333C61AA0DE5148E97AA238B8F8295E100891AA6A4F1F1108B27752FAD3</p>
<p><strong>Unpacked Resource SHA-256:</strong></p>
<p>c9b206aeded0795594a450b5717e65ba934c0dfab6005a8c696bd991ba96db15</p>
          <p><a href="https://0x00sec.org/t/zero2auto-initial-stagers-from-one-email-to-a-trojan/21722/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/zero2auto-initial-stagers-from-one-email-to-a-trojan/21722/1</link>
        <pubDate>Thu, 11 Jun 2020 17:12:55 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-21722-1</guid>
        <source url="https://0x00sec.org/t/zero2auto-initial-stagers-from-one-email-to-a-trojan/21722.rss">[Zero2Auto] – Initial Stagers - From one Email to a Trojan</source>
      </item>
  </channel>
</rss>
