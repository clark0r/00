<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>How do those hackers tools work?. Sniffers Part II</title>
    <link>https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777</link>
    <description>In [Part I](https://0x00sec.org/t/how-do-those-hackers-tools-work-sniffers-part-i/686) we learnt how to write a very basic sniffer If you take a look to the code you will notice that, once we capture the packet, we have to do quite some checks in order to get to the data we are interested on.

That is fine for a general packet capture tool like `wireshark`, were you want to see everything. However, if you a writing your own sniffer is likely because it is part of a [specific tool](https://0x00sec.org/t/remote-shells-part-iv-the-invisible-remote-shell/743). In those cases, all that packet parsing is a bit cumbersome.

# BPF Filters
BPF stands for _Berkeley Packet Filter_ ( https://en.wikipedia.org/wiki/Berkeley_Packet_Filter) and they will allow us to specify which kind of packets our sniffer will capture. The low level details are a bit more complex than what I have just said, but, for our current discussion, going deeper will not add much.

So, these filters will allow us to specify, with high detail, the characteristics of the packets we will be capturing. This has two main benefits when we compare it with our original implementation:

1. Our code becomes a lot more simple as we will not have to do all those checks (not all of them)
2. These filters are processed in the kernel (if your operating system support them). This means that they are gonna be faster and more efficient that any code we could write. This also have an impact on the I/O performance as less data has to be transfer from kernel space to user space.

If you are proficient with `tcpdump` you probably already know the syntax. Otherwise, you can take a look to `man 7 pcap-filter`.

Let&#39;s see how we can use them.

# Capturing Just What We Need
As usual we are going to show the code and then go through it to introduce the relevant APIs. Let&#39;s start with the main function:

```
int
main (int argc, char *argv[])
{
  char               err[PCAP_ERRBUF_SIZE];
  pcap_t*            h;
  struct bpf_program fp;
  bpf_u_int32        maskp;
  bpf_u_int32        netp;
  char *             filter = &quot;tcp[tcpflags] &amp; (tcp-syn) != 0 and &quot;
    &quot;tcp[tcpflags] &amp; (tcp-ack) == 0&quot;;

  if (argc != 2)
    {
      fprintf (stderr, &quot;Usage: %s interface \n&quot;, argv[0]);
      exit (1);
    }
  
  if ((pcap_lookupnet (argv[1], &amp;netp, &amp;maskp, err)) &lt; 0)
    {
      fprintf (stderr, &quot;pcap:%s\n&quot;, err);
      exit (1);
    }
  if ((h = pcap_open_live (argv[1], BUFSIZ, 0, 0, err)) == NULL)
    {
      fprintf (stderr, &quot;pcap:%s\n&quot;, err);
      exit (1);

    }

  pcap_compile (h, &amp;fp, filter, 0, netp);
  pcap_setfilter (h, &amp;fp);
  pcap_loop (h, -1, ip_cb, NULL);

  return 0;
}
```
Well, it is a bit longer than the previous one, but do not panic, it is not much complex.

The first thing you will notice is the filter program stored in a variable named `filter`. Yes, that&#39;s an original name, I know:

```
tcp[tcpflags] &amp; (tcp-syn) != 0 and tcp[tcpflags] &amp; (tcp-ack) == 0
```

Can you say what this filter does?

[spoiler]
Sure, it will try to match packet with a TCP header with the SYN flag set and the ACK flag not set. Eureka!. It is a packet to start a connection!
[/spoiler]


The next function we find is `pcap_lookupnet`. This function allows us to get information about the network interface we are going to sniff. As we did in Part I, we are passing the interface we want to use as a command-line parameter (`argv[1]`). The function `pcap_lookupnet` will give us the network address and the network mask for that device. As you will notice in a sec, we need the network address in order to compile our filter.

Then we can open our interface for capturing packets as usual and we are ready to set our filter up.

In order to be able to use our filter, the first thing we have to do is to compile it. The `pcap_compile` function will get our string and will convert it into a `bpf_program` object that we can associate to our current capture session using the `pcap_setfilter`. Yes just that, from this point on, we will only get the packets that match the filter from our packet capture session.

Now you can start your main loop using `pcap_next` (as we did in Part I), or you can use `pcap_loop`.

# Setting Up a Callback
The `pcap_loop` function is roughly (not exactly but almost the same thing) that the while loop we wrote in Part I to capture our packets using `pcap_next`. It does all the work, and whenever a packet is available will call the function we pass as third parameter. In our case `ip_cb`. The fourth parameter will let us pass some user data to the callback if needed. 

Now, the only missing part is our callback function. Here it is:

```
void 
ip_cb (u_char *args, const struct pcap_pkthdr* pkthdr, const u_char *p)
{
  struct ip     *ip_pkt;
  struct tcphdr *tcp_pkt;
  int            port;

  /* Check your link headers here */
  ip_pkt =  (struct ip*) (p + sizeof (struct ether_header));
  tcp_pkt = (struct tcphdr*) (p + sizeof (struct ether_header) + 
			     sizeof(struct ip));


  printf (&quot;+ SYNC From : %s:%d&quot;, inet_ntoa(ip_pkt-&gt;ip_src), ntohs(tcp_pkt-&gt;source));
  printf (&quot;  -&gt; %s:%d\n&quot;,inet_ntoa(ip_pkt-&gt;ip_dst), ntohs(tcp_pkt-&gt;dest));

  return;
}
```

The callback takes three parameters:

1. `args`. This is the pointer to the data we pass to `pcap_loop` if any (the last parameter, do you remember?). For us it is just NULL.
2. `pkthdr`. Contains information about the capture packet, a timestamp and the size of the captured packet
3. `p`. This is our packet.

As we had setup a filter, we know that our callback will be called with a TCP packet, so we do not have to check if there is an IP header or a TCP header. They will just be there. So we just access the data we are interested on and we are done.

In this case, our filter was set up to match SYN packets so we will just show the source and destination IP addresses and ports. Depending on your application you may want to do something more sophisticated.

What about coding your own drifnet tool and going into the fun of parsing application layer protocols?

# The Missing Piece
OK, I had intentionally overlooked a small detail in the callback function above. Did you spotted it?. Yes, sure you did. We were assuming that our packet has an ethernet link header.... which may or may not be the case.

To figure out which header you should expect in your callback, you have to check the datalink format, and we do this with the function `pcap_datalink`. This function will tell us which kind of link we are using and therefore, which kind of link header we should expect in our packet data.

A detailed list of link layers can be found in this link:

http://www.tcpdump.org/linktypes.html

If you check the code of some of those hacking tools out there, some of those that sniffs traffic, you will often find a function returning the size of the link layer header. We always need that to properly decode our packet and jump into the IP header and beyond.

Now we have a use for that user parameter. Do you remember it?. The last parameter in our call to `pcap_loop`. We can use it to let our callback function know the size of the link layer header. 

I will not include the code for this, so you can have fun coding it by yourself but, in a nutshell, you may check the link-layer using `pcap_datalink`, calculate the size of the link-layer header, and then pass that value as parameter to `pcap_loop`. Finally, in your callback, instead of adding the size of the ethernet header, you just can add the value of `arg`, or in other words, the size of the link layer you had calculated before.


# Wifi Sniffers
So, we have seen how to write simple sniffers but you may be wondering how those wifi hacking tools work. I will not provide code for this either, but it surely deserves a couple of words.

To understand how this work, we have to look into the different states of a wifi network interface:

* **Connected to an Access Point**. When we are connected to an access point (that&#39;s the normal case when we use internet from a wireless device), we had already entered the password for the access point and we are also successfully associated and authenticated for that access point. In this case, the wifi interface behaves as a normal wired interface. Actually pcap returns a `ether` header for those packets. This is why, if you try our code on `wlan0` it will work. ( https://wiki.wireshark.org/CaptureSetup/WLAN)

* **Monitor mode**. This is that special mode that some network card support and that is so interesting from a security point of view. In monitor mode, we are not associated to an Access Point and the network card just returns all packets it sees. As we are not associated neither authenticated with an AP, we cannot decode the content of the packets, but we can look at the link layer header which, in this case it will be 802.11, instead of the 802.3 (ethernet) we had seen before. Take a look to `man pcap_set_rfmon`.

For a more detailed description of those mode check the main pcap man page `man pcap`. You know RTFM!!!

The 802.11 packets are quite more complex than the ethernet one, and they have multiple parts that changes depending on the type of packet. When working at this level, we can see the packets sent while connecting to a wifi network... basically this is what `aircrack` does.

If you have a network card supporting monitor mode just activate it and fire wireshark on it to get an idea of the kind of information is in those packets. Then try to write your own sniffer to decode some of the packets you have just seen... for instance deauthentication packets that may be a symptom of a wifi password cracking attack....

# Conclusions
In this two parts series we have explored how to write a sniffer using `libpcap`. I encourage to check the code of the freely available tools out there and try to understand how they work. At least the packet capturing part should be easy to follow now. I hope.

We had also briefly looked into the link layer to better understand how some of the wifi hacking tools work. It is true we have not gone into much detail here, but that is because, that part would require a couple of articles on their own...</description>
    
    <lastBuildDate>Fri, 22 Jul 2016 19:50:23 +0000</lastBuildDate>
    <category>Networking</category>
    <atom:link href="https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>How do those hackers tools work?. Sniffers Part II</title>
        <dc:creator><![CDATA[system]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 30 days. New replies are no longer allowed.</p>
          <p><a href="https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777/17">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777/17</link>
        <pubDate>Sun, 21 Jan 2018 00:37:59 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-777-17</guid>
        <source url="https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777.rss">How do those hackers tools work?. Sniffers Part II</source>
      </item>
      <item>
        <title>How do those hackers tools work?. Sniffers Part II</title>
        <dc:creator><![CDATA[Cromical]]></dc:creator>
        <description><![CDATA[
            <p>Great article mate! Looked forward to something like this!</p>
          <p><a href="https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777/16">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777/16</link>
        <pubDate>Fri, 22 Jul 2016 19:50:23 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-777-16</guid>
        <source url="https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777.rss">How do those hackers tools work?. Sniffers Part II</source>
      </item>
      <item>
        <title>How do those hackers tools work?. Sniffers Part II</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>You know the stuff mate!</p>
          <p><a href="https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777/15">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777/15</link>
        <pubDate>Fri, 22 Jul 2016 19:06:00 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-777-15</guid>
        <source url="https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777.rss">How do those hackers tools work?. Sniffers Part II</source>
      </item>
      <item>
        <title>How do those hackers tools work?. Sniffers Part II</title>
        <dc:creator><![CDATA[Nitrax]]></dc:creator>
        <description><![CDATA[
            <p>In theory, this method is viable and easy to use however, it requires more information about the system in place. Anyway, detect a sniffer in stealth mode is a big deal, mainly, remotely.</p>
<aside class="quote no-group" data-username="0x00pf" data-post="13" data-topic="777">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://d.clarkee.co.uk/user_avatar/d.clarkee.co.uk/0x00pf/48/13708_2.png" class="avatar"> 0x00pf:</div>
<blockquote>
<p>Some other tricks with bogus DNS queries (supposing the sniffer does name resolution)</p>
</blockquote>
</aside>
<p>Yep, you are right, DNS tests, Network latency tests and trapping works only on active sniffers ! <img src="https://d.clarkee.co.uk/images/emoji/twitter/slight_smile.png?v=15" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
<p>By the way, time measurement or also known as Round trip Measuring technique is OS dependent too and the differences between normal mode and promiscuous mode can vary between 10-40% ! Moreover, it relies on the network load, increasing the percentage of false positive but if no other option is available, it is advised to use ICMP messages cause is less network load dependent.</p>
          <p><a href="https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777/14">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777/14</link>
        <pubDate>Fri, 22 Jul 2016 18:29:04 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-777-14</guid>
        <source url="https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777.rss">How do those hackers tools work?. Sniffers Part II</source>
      </item>
      <item>
        <title>How do those hackers tools work?. Sniffers Part II</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>You are right, it is system dependant. However it does not look like a pain. The paper is very well written and self-explanatory… Doesn’t look like there are much options. Some other tricks with bogus DNS queries (supposing the sniffer does name resolution) and time measurement… as far as I know</p>
          <p><a href="https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777/13">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777/13</link>
        <pubDate>Fri, 22 Jul 2016 17:37:58 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-777-13</guid>
        <source url="https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777.rss">How do those hackers tools work?. Sniffers Part II</source>
      </item>
      <item>
        <title>How do those hackers tools work?. Sniffers Part II</title>
        <dc:creator><![CDATA[Nitrax]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="0x00pf" data-post="10" data-topic="777">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://d.clarkee.co.uk/user_avatar/d.clarkee.co.uk/0x00pf/48/13708_2.png" class="avatar"> 0x00pf:</div>
<blockquote>
<p>In your scenario, where the sniffer is running in the machine you want to sniff, you do not really need to activate promiscuous mode, so everything would work as normal.</p>
</blockquote>
</aside>
<p>In this case yes, I agress !</p>
<p>However, I probably forgot to specify that the sniffer aim was, in my scenario, to sniff the network and not only the targeted machine. The victim was more like a vector to spy the entire network. Anyway, I will check your paper ASAP but I know that sniffer ARP detection is OS dependant and a veritable pain in the ass, considering that MAC address has a different meaning according to each operating system <img src="https://d.clarkee.co.uk/images/emoji/twitter/slight_smile.png?v=15" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
          <p><a href="https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777/12">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777/12</link>
        <pubDate>Fri, 22 Jul 2016 16:24:21 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-777-12</guid>
        <source url="https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777.rss">How do those hackers tools work?. Sniffers Part II</source>
      </item>
      <item>
        <title>How do those hackers tools work?. Sniffers Part II</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>You should. In theory, you should be able to decode WEP and WAP if you know the keys. At least <code>wireshark</code> can do it so I think it is possible</p>
          <p><a href="https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777/11">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777/11</link>
        <pubDate>Fri, 22 Jul 2016 16:13:54 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-777-11</guid>
        <source url="https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777.rss">How do those hackers tools work?. Sniffers Part II</source>
      </item>
      <item>
        <title>How do those hackers tools work?. Sniffers Part II</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>In your scenario, where the sniffer is running in the machine you want to sniff, you do not really need to activate promiscuous mode, so everything would work as normal.</p>
<p>In case you want to detect a sniffer running in promiscuous mode in your network, your proposal is one of the possibilities. However, it looks like that only works on old linux kernels</p>
<p>Check this paper for further details on how to do something similar using ARP packets (this is used by nmap detect-sniffer scipt)</p>
<aside class="onebox pdf">
  <header class="source">
      <a href="https://www.securityfriday.com/promiscuous_detection_01.pdf" target="_blank" rel="nofollow noopener">securityfriday.com</a>
  </header>
  <article class="onebox-body">
    <a href="https://www.securityfriday.com/promiscuous_detection_01.pdf" target="_blank" rel="nofollow noopener"><span class="pdf-onebox-logo"></span></a>
<h3><a href="https://www.securityfriday.com/promiscuous_detection_01.pdf" target="_blank" rel="nofollow noopener">promiscuous_detection_01.pdf</a></h3>

<p class="filesize">93.63 KB</p>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>I haven’t tested myself though.</p>
          <p><a href="https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777/10">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777/10</link>
        <pubDate>Fri, 22 Jul 2016 16:03:12 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-777-10</guid>
        <source url="https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777.rss">How do those hackers tools work?. Sniffers Part II</source>
      </item>
      <item>
        <title>How do those hackers tools work?. Sniffers Part II</title>
        <dc:creator><![CDATA[oaktree]]></dc:creator>
        <description><![CDATA[
            <p><a class="mention" href="https://d.clarkee.co.uk/u/smartone">@SmartOne</a>: of course, but sniffing with monitor mode on a WPA2 network, to which your machine is not authenticated, you’re not going to accomplish much.</p>
          <p><a href="https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777/9">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777/9</link>
        <pubDate>Fri, 22 Jul 2016 15:37:35 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-777-9</guid>
        <source url="https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777.rss">How do those hackers tools work?. Sniffers Part II</source>
      </item>
      <item>
        <title>How do those hackers tools work?. Sniffers Part II</title>
        <dc:creator><![CDATA[SmartOne]]></dc:creator>
        <description><![CDATA[
            <p>If we are listening to the wifi traffic via monitor mode, can’t we decode the contents of the packets if it’s an open AP?</p>
          <p><a href="https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777/8">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777/8</link>
        <pubDate>Fri, 22 Jul 2016 10:35:03 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-777-8</guid>
        <source url="https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777.rss">How do those hackers tools work?. Sniffers Part II</source>
      </item>
      <item>
        <title>How do those hackers tools work?. Sniffers Part II</title>
        <dc:creator><![CDATA[Nitrax]]></dc:creator>
        <description><![CDATA[
            <p><a class="mention" href="https://d.clarkee.co.uk/u/0x00pf">@0x00pf</a> <a class="mention" href="https://d.clarkee.co.uk/u/oaktree">@oaktree</a>  Well, we agree on the fact that your NIC has to be in a promiscuous mode to intercept any broadcasted packet over the network. Now, let assume the following scenario :</p>
<p>You infected a machine with your sniffer in order to gather sensitive information such as credentials, credit card numbers, … The host machine is, of course, reachable and responds to a ping request instantly. Consequently, what happen if I send an echo request to the right IP address but with wrong MAC address ? I guess that, according to the NIC configuration, the request will directly be passed up the stack to the IP layer, which will answer and unmask the presence of the sniffer.</p>
          <p><a href="https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777/7">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777/7</link>
        <pubDate>Fri, 22 Jul 2016 10:21:40 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-777-7</guid>
        <source url="https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777.rss">How do those hackers tools work?. Sniffers Part II</source>
      </item>
      <item>
        <title>How do those hackers tools work?. Sniffers Part II</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <aside class="quote group-VIP" data-username="Nitrax" data-post="2" data-topic="777">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://d.clarkee.co.uk/user_avatar/d.clarkee.co.uk/nitrax/48/788_2.png" class="avatar"> Nitrax:</div>
<blockquote>
<p>Edit : What about the fingerprint of your tool ?</p>
</blockquote>
</aside>
<p>Yes, as <a class="mention" href="https://d.clarkee.co.uk/u/oaktree">@oaktree</a> said. Do you mean a sniffer or the reference to the <em>Invisible Shell ™</em> at the beginning of the post.</p>
          <p><a href="https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777/6">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777/6</link>
        <pubDate>Thu, 21 Jul 2016 19:50:04 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-777-6</guid>
        <source url="https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777.rss">How do those hackers tools work?. Sniffers Part II</source>
      </item>
      <item>
        <title>How do those hackers tools work?. Sniffers Part II</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>Good link, covers basically the same. I would posted the link instead if I would new about it <img src="https://0x00sec.org/images/emoji/twitter/wink.png?v=9" title=":wink:" class="emoji" alt=":wink:"></p>
          <p><a href="https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777/5">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777/5</link>
        <pubDate>Thu, 21 Jul 2016 19:47:07 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-777-5</guid>
        <source url="https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777.rss">How do those hackers tools work?. Sniffers Part II</source>
      </item>
      <item>
        <title>How do those hackers tools work?. Sniffers Part II</title>
        <dc:creator><![CDATA[_py]]></dc:creator>
        <description><![CDATA[
            <p>Lovely article <a class="mention" href="https://d.clarkee.co.uk/u/0x00pf">@0x00pf</a>!</p>
<p>Below is a useful pcap documentation based on tcpdump.</p>
<p><a href="http://www.tcpdump.org/pcap.html" class="onebox" target="_blank" rel="nofollow noopener">http://www.tcpdump.org/pcap.html</a></p>
          <p><a href="https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777/4">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777/4</link>
        <pubDate>Thu, 21 Jul 2016 19:44:10 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-777-4</guid>
        <source url="https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777.rss">How do those hackers tools work?. Sniffers Part II</source>
      </item>
      <item>
        <title>How do those hackers tools work?. Sniffers Part II</title>
        <dc:creator><![CDATA[oaktree]]></dc:creator>
        <description><![CDATA[
            <p><a class="mention" href="https://d.clarkee.co.uk/u/nitrax">@Nitrax</a>: would you elaborate on what you mean by “fingerprint of [the] tool?” Are you talking about what it “leaves behind” when intercepting packets?</p>
          <p><a href="https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777/3">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777/3</link>
        <pubDate>Thu, 21 Jul 2016 19:31:56 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-777-3</guid>
        <source url="https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777.rss">How do those hackers tools work?. Sniffers Part II</source>
      </item>
      <item>
        <title>How do those hackers tools work?. Sniffers Part II</title>
        <dc:creator><![CDATA[Nitrax]]></dc:creator>
        <description><![CDATA[
            <p>I already knew how sniffers worked  as well as the network layer stack however, I never looked the code base of such tool ! Very informative ! Good job mate, keep going.</p>
<p>Edit : What about the fingerprint of your tool ?</p>
<p>Best,<br>
Nitrax</p>
          <p><a href="https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777/2">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777/2</link>
        <pubDate>Thu, 21 Jul 2016 17:47:54 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-777-2</guid>
        <source url="https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777.rss">How do those hackers tools work?. Sniffers Part II</source>
      </item>
      <item>
        <title>How do those hackers tools work?. Sniffers Part II</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>In <a href="https://0x00sec.org/t/how-do-those-hackers-tools-work-sniffers-part-i/686">Part I</a> we learnt how to write a very basic sniffer If you take a look to the code you will notice that, once we capture the packet, we have to do quite some checks in order to get to the data we are interested on.</p>
<p>That is fine for a general packet capture tool like <code>wireshark</code>, were you want to see everything. However, if you a writing your own sniffer is likely because it is part of a <a href="https://0x00sec.org/t/remote-shells-part-iv-the-invisible-remote-shell/743">specific tool</a>. In those cases, all that packet parsing is a bit cumbersome.</p>
<h1>BPF Filters</h1>
<p>BPF stands for <em>Berkeley Packet Filter</em> ( <a href="https://en.wikipedia.org/wiki/Berkeley_Packet_Filter" rel="nofollow noopener">https://en.wikipedia.org/wiki/Berkeley_Packet_Filter</a>) and they will allow us to specify which kind of packets our sniffer will capture. The low level details are a bit more complex than what I have just said, but, for our current discussion, going deeper will not add much.</p>
<p>So, these filters will allow us to specify, with high detail, the characteristics of the packets we will be capturing. This has two main benefits when we compare it with our original implementation:</p>
<ol>
<li>Our code becomes a lot more simple as we will not have to do all those checks (not all of them)</li>
<li>These filters are processed in the kernel (if your operating system support them). This means that they are gonna be faster and more efficient that any code we could write. This also have an impact on the I/O performance as less data has to be transfer from kernel space to user space.</li>
</ol>
<p>If you are proficient with <code>tcpdump</code> you probably already know the syntax. Otherwise, you can take a look to <code>man 7 pcap-filter</code>.</p>
<p>Let’s see how we can use them.</p>
<h1>Capturing Just What We Need</h1>
<p>As usual we are going to show the code and then go through it to introduce the relevant APIs. Let’s start with the main function:</p>
<pre><code class="lang-auto">int
main (int argc, char *argv[])
{
  char               err[PCAP_ERRBUF_SIZE];
  pcap_t*            h;
  struct bpf_program fp;
  bpf_u_int32        maskp;
  bpf_u_int32        netp;
  char *             filter = "tcp[tcpflags] &amp; (tcp-syn) != 0 and "
    "tcp[tcpflags] &amp; (tcp-ack) == 0";

  if (argc != 2)
    {
      fprintf (stderr, "Usage: %s interface \n", argv[0]);
      exit (1);
    }
  
  if ((pcap_lookupnet (argv[1], &amp;netp, &amp;maskp, err)) &lt; 0)
    {
      fprintf (stderr, "pcap:%s\n", err);
      exit (1);
    }
  if ((h = pcap_open_live (argv[1], BUFSIZ, 0, 0, err)) == NULL)
    {
      fprintf (stderr, "pcap:%s\n", err);
      exit (1);

    }

  pcap_compile (h, &amp;fp, filter, 0, netp);
  pcap_setfilter (h, &amp;fp);
  pcap_loop (h, -1, ip_cb, NULL);

  return 0;
}
</code></pre>
<p>Well, it is a bit longer than the previous one, but do not panic, it is not much complex.</p>
<p>The first thing you will notice is the filter program stored in a variable named <code>filter</code>. Yes, that’s an original name, I know:</p>
<pre><code class="lang-auto">tcp[tcpflags] &amp; (tcp-syn) != 0 and tcp[tcpflags] &amp; (tcp-ack) == 0
</code></pre>
<p>Can you say what this filter does?</p>
<div class="spoiler"><a href="https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777/1">spoiler</a></div>
<p>The next function we find is <code>pcap_lookupnet</code>. This function allows us to get information about the network interface we are going to sniff. As we did in Part I, we are passing the interface we want to use as a command-line parameter (<code>argv[1]</code>). The function <code>pcap_lookupnet</code> will give us the network address and the network mask for that device. As you will notice in a sec, we need the network address in order to compile our filter.</p>
<p>Then we can open our interface for capturing packets as usual and we are ready to set our filter up.</p>
<p>In order to be able to use our filter, the first thing we have to do is to compile it. The <code>pcap_compile</code> function will get our string and will convert it into a <code>bpf_program</code> object that we can associate to our current capture session using the <code>pcap_setfilter</code>. Yes just that, from this point on, we will only get the packets that match the filter from our packet capture session.</p>
<p>Now you can start your main loop using <code>pcap_next</code> (as we did in Part I), or you can use <code>pcap_loop</code>.</p>
<h1>Setting Up a Callback</h1>
<p>The <code>pcap_loop</code> function is roughly (not exactly but almost the same thing) that the while loop we wrote in Part I to capture our packets using <code>pcap_next</code>. It does all the work, and whenever a packet is available will call the function we pass as third parameter. In our case <code>ip_cb</code>. The fourth parameter will let us pass some user data to the callback if needed.</p>
<p>Now, the only missing part is our callback function. Here it is:</p>
<pre><code class="lang-auto">void 
ip_cb (u_char *args, const struct pcap_pkthdr* pkthdr, const u_char *p)
{
  struct ip     *ip_pkt;
  struct tcphdr *tcp_pkt;
  int            port;

  /* Check your link headers here */
  ip_pkt =  (struct ip*) (p + sizeof (struct ether_header));
  tcp_pkt = (struct tcphdr*) (p + sizeof (struct ether_header) + 
			     sizeof(struct ip));


  printf ("+ SYNC From : %s:%d", inet_ntoa(ip_pkt-&gt;ip_src), ntohs(tcp_pkt-&gt;source));
  printf ("  -&gt; %s:%d\n",inet_ntoa(ip_pkt-&gt;ip_dst), ntohs(tcp_pkt-&gt;dest));

  return;
}
</code></pre>
<p>The callback takes three parameters:</p>
<ol>
<li>
<code>args</code>. This is the pointer to the data we pass to <code>pcap_loop</code> if any (the last parameter, do you remember?). For us it is just NULL.</li>
<li>
<code>pkthdr</code>. Contains information about the capture packet, a timestamp and the size of the captured packet</li>
<li>
<code>p</code>. This is our packet.</li>
</ol>
<p>As we had setup a filter, we know that our callback will be called with a TCP packet, so we do not have to check if there is an IP header or a TCP header. They will just be there. So we just access the data we are interested on and we are done.</p>
<p>In this case, our filter was set up to match SYN packets so we will just show the source and destination IP addresses and ports. Depending on your application you may want to do something more sophisticated.</p>
<p>What about coding your own drifnet tool and going into the fun of parsing application layer protocols?</p>
<h1>The Missing Piece</h1>
<p>OK, I had intentionally overlooked a small detail in the callback function above. Did you spotted it?. Yes, sure you did. We were assuming that our packet has an ethernet link header… which may or may not be the case.</p>
<p>To figure out which header you should expect in your callback, you have to check the datalink format, and we do this with the function <code>pcap_datalink</code>. This function will tell us which kind of link we are using and therefore, which kind of link header we should expect in our packet data.</p>
<p>A detailed list of link layers can be found in this link:</p>
<p><a href="http://www.tcpdump.org/linktypes.html" class="onebox" target="_blank" rel="nofollow noopener">http://www.tcpdump.org/linktypes.html</a></p>
<p>If you check the code of some of those hacking tools out there, some of those that sniffs traffic, you will often find a function returning the size of the link layer header. We always need that to properly decode our packet and jump into the IP header and beyond.</p>
<p>Now we have a use for that user parameter. Do you remember it?. The last parameter in our call to <code>pcap_loop</code>. We can use it to let our callback function know the size of the link layer header.</p>
<p>I will not include the code for this, so you can have fun coding it by yourself but, in a nutshell, you may check the link-layer using <code>pcap_datalink</code>, calculate the size of the link-layer header, and then pass that value as parameter to <code>pcap_loop</code>. Finally, in your callback, instead of adding the size of the ethernet header, you just can add the value of <code>arg</code>, or in other words, the size of the link layer you had calculated before.</p>
<h1>Wifi Sniffers</h1>
<p>So, we have seen how to write simple sniffers but you may be wondering how those wifi hacking tools work. I will not provide code for this either, but it surely deserves a couple of words.</p>
<p>To understand how this work, we have to look into the different states of a wifi network interface:</p>
<ul>
<li>
<p><strong>Connected to an Access Point</strong>. When we are connected to an access point (that’s the normal case when we use internet from a wireless device), we had already entered the password for the access point and we are also successfully associated and authenticated for that access point. In this case, the wifi interface behaves as a normal wired interface. Actually pcap returns a <code>ether</code> header for those packets. This is why, if you try our code on <code>wlan0</code> it will work. ( <a href="https://wiki.wireshark.org/CaptureSetup/WLAN" rel="nofollow noopener">https://wiki.wireshark.org/CaptureSetup/WLAN</a>)</p>
</li>
<li>
<p><strong>Monitor mode</strong>. This is that special mode that some network card support and that is so interesting from a security point of view. In monitor mode, we are not associated to an Access Point and the network card just returns all packets it sees. As we are not associated neither authenticated with an AP, we cannot decode the content of the packets, but we can look at the link layer header which, in this case it will be 802.11, instead of the 802.3 (ethernet) we had seen before. Take a look to <code>man pcap_set_rfmon</code>.</p>
</li>
</ul>
<p>For a more detailed description of those mode check the main pcap man page <code>man pcap</code>. You know RTFM!!!</p>
<p>The 802.11 packets are quite more complex than the ethernet one, and they have multiple parts that changes depending on the type of packet. When working at this level, we can see the packets sent while connecting to a wifi network… basically this is what <code>aircrack</code> does.</p>
<p>If you have a network card supporting monitor mode just activate it and fire wireshark on it to get an idea of the kind of information is in those packets. Then try to write your own sniffer to decode some of the packets you have just seen… for instance deauthentication packets that may be a symptom of a wifi password cracking attack…</p>
<h1>Conclusions</h1>
<p>In this two parts series we have explored how to write a sniffer using <code>libpcap</code>. I encourage to check the code of the freely available tools out there and try to understand how they work. At least the packet capturing part should be easy to follow now. I hope.</p>
<p>We had also briefly looked into the link layer to better understand how some of the wifi hacking tools work. It is true we have not gone into much detail here, but that is because, that part would require a couple of articles on their own…</p>
          <p><a href="https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777/1">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777/1</link>
        <pubDate>Thu, 21 Jul 2016 17:27:06 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-777-1</guid>
        <source url="https://d.clarkee.co.uk/t/how-do-those-hackers-tools-work-sniffers-part-ii/777.rss">How do those hackers tools work?. Sniffers Part II</source>
      </item>
  </channel>
</rss>
