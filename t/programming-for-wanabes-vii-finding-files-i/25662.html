<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Programming for Wanabes VII. Finding files I - Programming - 0x00sec - The Home of the Hacker</title>
<meta name="description" content="Programming for Wanabes VII. Finding files I
It is time to get started with more advanced code. We will be introducing multiple concepts from this point on and hopefully we will boost our programming skills in no time. I&amp;hellip;">
<meta name="generator" content="Discourse 3.1.0.beta6 - https://github.com/discourse/discourse version 80a1709965fa59da824b2e3392976fc6fc898f80">
<link rel="icon" type="image/png" href="../../uploads/default/optimized/2X/3/30c4e7d76acf879a124fdfe4d8d126afe628c189_2_32x32.png">
<link rel="apple-touch-icon" type="image/png" href="../../uploads/default/optimized/2X/c/c5e37f667fd0fe006ffa67653c662fb64fec597e_2_180x180.png">
<meta name="theme-color" media="all" content="#171616">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, user-scalable=yes, viewport-fit=cover">
<link rel="canonical" href="25662.html" />
<link rel="search" type="application/opensearchdescription+xml" href="../../opensearch.xml" title="0x00sec - The Home of the Hacker Search">
<link href="../../stylesheets/color_definitions_0x00sec-v2_15_57_a5ef387651921c3e4c7aa1108536015ba8299efb.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" class="light-scheme" />
<link href="../../stylesheets/desktop_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="desktop" />
<link href="../../stylesheets/chat_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="chat" />
<link href="../../stylesheets/discourse-details_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-details" />
<link href="../../stylesheets/discourse-lazy-videos_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-lazy-videos" />
<link href="../../stylesheets/discourse-local-dates_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-local-dates" />
<link href="../../stylesheets/discourse-narrative-bot_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-narrative-bot" />
<link href="../../stylesheets/discourse-presence_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-presence" />
<link href="../../stylesheets/discourse-spoiler-alert_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-spoiler-alert" />
<link href="../../stylesheets/docker_manager_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="docker_manager" />
<link href="../../stylesheets/poll_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="poll" />
<link href="../../stylesheets/chat_desktop_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="chat_desktop" />
<link href="../../stylesheets/poll_desktop_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="poll_desktop" />
<link href="../../stylesheets/desktop_theme_46_f36ade55bf80933494fe3b5fab518f477de3bd4e.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="desktop_theme" data-theme-id="46" data-theme-name="header links v2" />
<link href="../../stylesheets/desktop_theme_57_8c0e890a61cdb4c5833a9f9c96664ed164e7d645.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="desktop_theme" data-theme-id="57" data-theme-name="0x00sec-v2" />
<link rel="stylesheet" href="https://s3.amazonaws.com/0x00sec/monokai-sublime.css">
<script src="https://s3.amazonaws.com/0x00sec/highlight.pack.js"></script>
<link rel="preload" href="../../theme-javascripts/440fd21108f5ba9e5dfe06cca9fc842569d5a874.js%3F__ws=0x00sec.org" as="script">
<script defer src="../../theme-javascripts/440fd21108f5ba9e5dfe06cca9fc842569d5a874.js%3F__ws=0x00sec.org" data-theme-id="40"></script>
<link rel="alternate nofollow" type="application/rss+xml" title="RSS feed of &#39;Programming for Wanabes VII. Finding files I&#39;" href="25662.rss" />
<meta property="og:site_name" content="0x00sec - The Home of the Hacker" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://0x00sec.org/uploads/default/original/2X/2/27a5373af868edade07624e8205c46e79c247445.jpeg" />
<meta property="og:image" content="https://0x00sec.org/uploads/default/original/2X/2/27a5373af868edade07624e8205c46e79c247445.jpeg" />
<meta property="og:url" content="https://0x00sec.org/t/programming-for-wanabes-vii-finding-files-i/25662" />
<meta name="twitter:url" content="https://0x00sec.org/t/programming-for-wanabes-vii-finding-files-i/25662" />
<meta property="og:title" content="Programming for Wanabes VII. Finding files I" />
<meta name="twitter:title" content="Programming for Wanabes VII. Finding files I" />
<meta property="og:description" content="Programming for Wanabes VII. Finding files I It is time to get started with more advanced code. We will be introducing multiple concepts from this point on and hopefully we will boost our programming skills in no time. In the previous instalment we identified the ability to find files in the disk as a feature required by several malwares.  Actually it is a feature required by many other applications and will let us learn about new system calls, loops and structures. Without further ado, let’s ju..." />
<meta name="twitter:description" content="Programming for Wanabes VII. Finding files I It is time to get started with more advanced code. We will be introducing multiple concepts from this point on and hopefully we will boost our programming skills in no time. In the previous instalment we identified the ability to find files in the disk as a feature required by several malwares.  Actually it is a feature required by many other applications and will let us learn about new system calls, loops and structures. Without further ado, let’s ju..." />
<meta property="og:article:section" content="Programming" />
<meta property="og:article:section:color" content="92278F" />
<meta property="og:article:tag" content="programming" />
<meta property="og:article:tag" content="linux" />
<meta property="og:article:tag" content="malware" />
<meta name="twitter:label1" value="Reading time" />
<meta name="twitter:data1" value="10 mins 🕑" />
<meta name="twitter:label2" value="Likes" />
<meta name="twitter:data2" value="15 ❤" />
<meta property="article:published_time" content="2021-04-14T21:43:19+00:00" />
<meta property="og:ignore_canonical" content="true" />
</head>
<body class="crawler ">
<div id="top-navbar" class="container">
<span id="top-navbar-links" style="display:none;">

<a href="https://init.0x00sec.org" class="dow-menu">Init</a>
<a href="https://discord.gg/c6BHVfn" class="dow-menu">Discord</a>
<a href="https://init.0x00sec.org/?partners" class="dow-menu">Partners</a>
</span>
</div>
<header>
<a href="../../index.html">
0x00sec - The Home of the Hacker
</a>
</header>
<div id="main-outlet" class="wrap" role="main">
<div id="topic-title">
<h1>
<a href="25662.html">Programming for Wanabes VII. Finding files I</a>
</h1>
<div class="topic-category" itemscope itemtype="http://schema.org/BreadcrumbList">
<span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
<a href="../../c/programming/61.html" class="badge-wrapper bullet" itemprop="item">
<span class="badge-category-bg" style="background-color: #92278F"></span>
<span class="badge-category clear-badge">
<span class="category-name" itemprop="name">Programming</span>
</span>
</a>
<meta itemprop="position" content="1" />
</span>
</div>
<div class="topic-category">
<div class="discourse-tags list-tags">
<a href="../../tag/programming.html" class="discourse-tag" rel="tag">programming</a>,
<a href="../../tag/linux.html" class="discourse-tag" rel="tag">linux</a>,
<a href="../../tag/malware.html" class="discourse-tag" rel="tag">malware</a>
</div>
</div>
</div>
<div itemscope itemtype="http://schema.org/DiscussionForumPosting">
<meta itemprop="headline" content="Programming for Wanabes VII. Finding files I">
<meta itemprop="articleSection" content="Programming">
<meta itemprop="keywords" content="programming, linux, malware">
<div itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
<meta itemprop="name" content="0x00sec - The Home of the Hacker">
<div itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
<meta itemprop="url" content="https://0x00sec.org/uploads/default/original/2X/c/c5e37f667fd0fe006ffa67653c662fb64fec597e.png">
</div>
</div>
<div id="post_1" class="topic-body crawler-post">
<div class="crawler-post-meta">
<span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a itemprop="url" href="https://0x00sec.org/u/0x00pf"><span itemprop="name">0x00pf</span></a>
(pico)
</span>
<link itemprop="mainEntityOfPage" href="25662.html">
<span class="crawler-post-infos">
<time itemprop="datePublished" datetime="2021-04-14T21:43:19Z" class="post-time">
April 14, 2021, 9:43pm
</time>
<meta itemprop="dateModified" content="2021-04-15T05:10:24Z">
<span itemprop="position">1</span>
</span>
</div>
<div class="post" itemprop="articleBody">
<h1>Programming for Wanabes VII. Finding files I</h1>
<p>It is time to get started with more advanced code. We will be introducing multiple concepts from this point on and hopefully we will boost our programming skills in no time. In the previous instalment we identified the ability to find files in the disk as a feature required by several malwares.</p>
<p>Actually it is a feature required by many other applications and will let us learn about new system calls, loops and structures. Without further ado, let’s jump into the topic</p>
<h1>Getting Ready to Read directories</h1>
<p>Whenever you need to read the content of a folder and you want to be portable between platforms, the right way to proceed is using the POSIX interface.</p>
<p>I will first dump here a shrink down version of the general program from the <a href="../programming-for-wannabes-part-vi-malware-introduction/25595/index.html">previous instalment</a>. In the rest of this text we will just work out the <code>select_target</code> functions. Everything else will stay the same for the time being. So, this is our starting point:</p>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;

#include &lt;sys/types.h&gt;  // POSIX directoy reading interface
#include &lt;dirent.h&gt;

char *the_folder="/tmp/";

typedef int (*PAYLOAD_FUNC)(char *);

int payload (char *target) {
  printf ("Doing malware things to %s\n", target);
}

int select_target (PAYLOAD_FUNC pf) {
  return 0;
}

int main () {
  while (select_target(payload));
}
</code></pre>
<p>No big surprises here, a bunch of include files with the functions and data structures we will need and the functions we introduced for our generic malware. The only tricky thing here is the definition of a function type. I introduced this silently in the previous instalment, but this time we should look deeper into this so you understand what we are doing.</p>
<h2>Function Pointers</h2>
<p>One of the data types that we can use in C are the so-called pointers. We had introduced them earlier in this series, but for completeness let’s quickly define them again: a pointer is just a variable that contains a memory address. It is said that it <em>Points to</em> that address, hence the name… <em>Pointer</em>.</p>
<p>Usually pointers point to addresses containing data (variable pointers), but there is no reason why a pointer wouldn’t point to an address containing code… a function for instance. In assembly this is very straight forward, we just need to do <code>call/jmp</code> with some kind of indirect addressing (that is, using a register or variable that contains the address to jump into, instead of the direct address, so we can control that value programatically). Let’s see this with an example</p>
<pre><code>DIRECT                 INDIRECT
                       mov    payload, %rax
call payload           callq  *%rax
</code></pre>
<p>In the direct code we are using the <code>payload</code> address directly. In the indirect code we load the function address in a register and then we jump to the address stored in that register. In general, when you declare a function pointer variable, that pointer will be stored somewhere in the stack, and instead of loading the address directly on <code>RAX</code> (like in this example), we will load <code>RAX</code> with that stack value.</p>
<p>Let’s change the <code>select_address</code> above to actually call <code>payload</code> and let’s take a look to the generated code:</p>
<pre><code class="lang-auto">int select_target (PAYLOAD_FUNC pf) {
  pf (the_folder);
  return 0;
}
</code></pre>
<p>This produces the following assembler. You have to compile it with <code>-O2</code> so the code gets slightly optimised, otherwise, gcc will generate code to store the parameter (the function pointer) in the stack and just after that read that stack value and put it in <code>RAX</code>. In other words it just moves the parameter around doing nothing.</p>
<pre><code class="lang-auto">00000000000006c0 &lt;select_target&gt;:
 6c0:   48 83 ec 08             sub    $0x8,%rsp
 6c4:   48 89 f8                mov    %rdi,%rax
 6c7:   48 8b 3d 42 09 20 00    mov    0x200942(%rip),%rdi        # 201010 &lt;the_folder&gt;
 6ce:   ff d0                   callq  *%rax
 6d0:   31 c0                   xor    %eax,%eax
 6d2:   48 83 c4 08             add    $0
 6d6:   c3                      retq

</code></pre>
<p>We already know all this, but let’s refresh our minds once again:</p>
<ul>
<li>We get our parameter (the <code>payload</code> address in this case) in <code>RDI</code>
</li>
<li>We copy it into <code>RAX</code>
</li>
<li>Put the <code>the_folder</code> variable in <code>RDI</code> (remember <code>RDI</code> contains the first parameter)</li>
<li>Run the function indirectly (jump to the content of <code>RAX</code> that in this case is <code>payload</code>)</li>
</ul>
<p>So, that’s it. In this case we are using the pointer directly, but we could store it in memory and then we will be talking about a function pointer variable. This is obvious and straightforward in asm, but in C we need to use a kind of cryptic way to define function pointers:</p>
<pre><code class="lang-auto">return_type (*var/type) (parameters);
</code></pre>
<p>So you just need to put parenthesis (and an <code>*</code>, after all we are defining a pointer) around the variable or type that you want to define. Let’s see a few examples:</p>
<pre><code class="lang-auto">int (*func)(int, int);
</code></pre>
<p>This declares a variable named <code>func</code> that is a pointer to a function returning an integer, and expecting two integers as parameters.</p>
<pre><code class="lang-auto">typedef int (*FUNC)(int, int);
FUNC func;
</code></pre>
<p>This renames a function pointer type (that is what <code>typepdef</code> does) to represent the same function we defined above. Then it declares the same variable but using the new type name. This makes the code more readable, but other than that, there is no difference at all.</p>
<p>Also note that the assembler generated to call our function (via the function pointer) is independent of the actual types in the declaration… you can call the function with whatever you want… but the function will likely not work as expected, or even crash. The types definitions are just used by the compile to let us know that we are doing what we are suppose to do. Just change the type definition and recompile, you will get the same code.</p>
<h1>Reading a directory the POSIX way</h1>
<p>Now we can get back to the main topic, how to read the content of a directory. Remember, virus, ransomware, spyware, all of them need to scan the disk to find different types of files. Let’s see how to do this.</p>
<p>We will start doing it the <em>Right Way</em>, that is, how it is expected to be done by any normal system application. And that is using the POSIX interface that is composed of three functions:</p>
<pre><code>opendir  Opens a directory for reading
readdir  Read one directory entry each time it is called
closedir Closes the directory
</code></pre>
<p>This API is intended to mimic the normal file interface (the stream like interface offered by <code>fopen/fread/fclose</code>), but just using slightly different data structures. Using this function our <code>select_target</code> function will look like this:</p>
<pre><code class="lang-auto">int select_target (PAYLOAD_FUNC pf) {
  struct dirent *de;
  DIR           *d;
  
  if (!(d = opendir (_the_folder))) {perror ("opendir:"); exit (EXIT_FAILURE);}

  while (1) {
      errno = 0;
      if (!(de = readdir (d))) {
	    if (errno) perror ("readdir:");
	    break;
      }
      pf (de-&gt;d_name);
    }
  closedir (d);
  return 0;
}
</code></pre>
<p>The first thing to note is that, <code>DIR*</code> is the type used by all the function, it is similar to the classical <code>FILE*</code> that we use with files (when using the stream interface). Conceptually it is the same, a stream abstraction of a directory. The <code>opendir</code> and <code>closedir</code> are intended to intialise the structure and to finish the processing respectively (and release resources). Not much more to say about them, you need to call <code>opendir</code> before start reading the directory, and you have to call <code>closedir</code> whenever you are done processing your folder. Yes, the parameter to <code>opendir</code> is just a string containing the folder to process. We will see later what those functions really do under the hood.</p>
<p>The interesting function is <code>readdir</code> that is the one that actually reads directory entries one by one.</p>
<h1><code>structs</code></h1>
<p>Before looking into <code>readdir</code> in detail, we need to introduce a new C keyword: <code>struct</code>. A <code>struct</code> is a so-called compound type. It is a compound type because it is composed of other types. Each one of those types together with the new we give to them is known as a field. You can think about a <code>struct</code> like a variable that groups more variables together in a convenient way.</p>
<p>The way to declare them is like this:</p>
<pre><code class="lang-auto">struct name_of_the_struct {
  type1  field1;
  type2  field2;
  ....
};
</code></pre>
<p>A more specific example could be:</p>
<pre><code class="lang-auto">struct linux_dirent {
  long           d_ino;
  long           d_off;
  unsigned short d_reclen;
  char           d_name[];
};

struct linux_dirent de,*pde;
</code></pre>
<p>The code above defines a new type named <code>struct linux_dirent</code> (note that you need to use <code>struct</code> to refer to the new type) composed of two longs (64bits integer), one short (16 bit integer) and a string of unknown size. You can add as many fields as you want, but in this case we are using only 4.</p>
<p>After the <code>struct</code> definition we have defined two variables. One is a <code>struct</code> and the other one is a pointer to a <code>struct</code>. Once the variables are declared, we can access the fields using the <code>.</code> for the struct one and the <code>-&gt;</code> operator for the pointer. Just like this:</p>
<pre><code class="lang-auto">de.d_ino = 12345;
de.d_off = 0;
pde = &amp;de;
pde-&gt;d_ino = 54321;
pde-&gt;d_off = 1;
</code></pre>
<p>Whenever you need to pass structs as parameters to function, it is usual to redefine them using <code>typedef</code>s in order to minimise the writing. Imagine a function that returns one of those <code>struct linux_dirent</code> structs and receives as parameter two of them. The prototype will look like:</p>
<pre><code class="lang-auto">struct linux_dirent my_func (struct linux_dirent p1, struct linux_dirent p2);
</code></pre>
<p>This is a lot of writing and also it is harder to figure out the function prototype at one glance. Now imagine, you have 20 more function in your API to deal with this data type…So we could just create an <em>alias</em> for this type:</p>
<pre><code class="lang-auto">typedef struct linux_dirent LDIRENT;
LDIRENT my_func (LDIRENT p1, LDIRENT p2);
</code></pre>
<p>Which is way more easy to read. However this is a matter of personal use. Both approaches will produce the same code. Some people prefers to write everything so it is always clear what is that type (a struct in this case), and other prefer to redefine them. In the standard C library you will find both.</p>
<p><em>Note: It is not common (but indeed possible) to pass and return structs in C functions, usually you will use pointers instead. The reason is that C passes parameter by value. This means that all parameters we pass have to be copied. It is easier to copy 4/8 bytes for a pointer than the roughly 24 bytes required by the struct in our example.</em></p>
<p>All this may look complicated at first glance, but you will get used to this very quickly. This data structures are all over the place when writing non trivial programs</p>
<p>However, in this course we are not just learning the syntax of C, we are going deeper.</p>
<h1>
<code>structs</code> are just memory blocks</h1>
<p>So, what is really a <code>struct</code> ?. Short answer: It is just a memory block. When we declare a variable of type struct, we are just allocating enough space to contain all the struct elements either in the stack, in case our variable is local to a function, in the data segment, in case it is a global variable, or in the <em>Heap</em> in case we allocate the memory block dynamically. This last case we will cover later in this course.</p>
<p>For our previous example we have:</p>
<pre><code class="lang-auto">struct linux_dirent {
  long           d_ino;      // 8 bytes
  long           d_off;      // 8 bytes
  unsigned short d_reclen;   // 2 bytes
  char           d_name[];   // This is a placeholder we will talk about in a sec
};
</code></pre>
<p>So, this structure requires 18 bytes, which will likely be rounded up to 24 bytes to keep the memory alignment (check previous instalments when we introduce the native word size). You can just add a <code>printf</code> using the <code>sizeof</code> operator to find out the actual size of the struct. In memory it will look like:</p>
<pre><code>ADDR+18 -&gt; | d_name
ADDR+16 -&gt; | d_reclen (2 bytes) 
ADDR+8  -&gt; | d_off    (8 bytes) 
ADDR   --&gt; | d_ino    (8 bytes)
            +--------------
</code></pre>
<p>When declaring a variable, such a variable just names that memory block… Think about it as a label, and therefore it is inmutable (you cannot change its value). It is the same with arrays… they are like pointers but not completely (we will talk about this again when arrays pop up in our way later in the course).</p>
<p>When you declare a pointer to a struct, you are just allocating memory to store an address that will point to memory block. Note that when declaring a pointer to an structure, the structure is not magically created. It is just a pointer. You need to allocate the memory block for the structure by other means.</p>
<p>You can now add the <code>struct</code> we defined above to your program (we will do that in a sec) and declare a local variable in the <code>select_file</code> function. Then take a look to the generated code. The beginning of the function will allocate extra space (the <code>sub $0xVAL,%rsp</code> at the beginning) to accommodate the new variable.</p>
<h1>What about the <code>d_name</code> field?</h1>
<p>Many of you may be wondering this… what does that <code>char d_name[]</code> means. Well, it is actually a placeholder. A field added to the <code>struct</code> to point to whatever comes after the rest of the fields. Or to get access to a specific point inside the struct if you prefer. This technique is used when the programmer needs to deal with variable length items.</p>
<p>In this example we do not known how long the name of the directory entry will be. When this happens we usually have two options. We either provide enough space so the longest possible name will fit in our memory block (and/or we limit the longest possible name with additional checks in the code), or we dynamically allocate space for the directory entry whenever we find out its size. Allocations just don’t happen magically… even on interpreted languages all these processes are happening under the hood… whenever you add two strings in python a lot of allocation and memory movement happens.</p>
<p>Let’s see how would this work. Imagine we are allocating our structure in the stack. Note that the actual memory block is created/managed by the <code>readdir</code> function not for us. The function gives us a pointer to the memory it manages/allocates. As, for the time being, we only know how to allocate memory in the stack, let’s assume <code>readdir</code> allocates memory in the stack, however it is likely to use some global storage or the heap. You should have an idea of the why at this point.</p>
<p>Also, let’s assume, that the syscalls used by <code>readdir</code> (remember <code>readdir</code> is a libc function not a system call), will let us known the size of file name it is reporting. Let’s imagine the length of the filename is <code>len</code>.</p>
<p>Then <code>readdir</code> will allocate in the stack 24 bytes + len, so there is enough space to store the <code>struct linux_dirent</code> fields plus the string. In this case the stack will look like this:</p>
<pre><code>ADDRS+18+len -&gt; | \0
ADDRS+18     -&gt; | d_name (the string goes here)
ADDRS+16     -&gt; | d_reclen (2 bytes) 
ADDRS+8      -&gt; | d_off    (8 bytes) 
ADDRS       --&gt; | d_ino    (8 bytes)
                +--------------
</code></pre>
<p>Whenever we access the <code>d_name</code> field that is located at <code>ADDR+18</code>, we will find a variable length string containing the name of the file being read by <code>readdir</code>.</p>
<p>From a syntactic point of view <code>char d_name[]</code> represents a character string of unknown size. In practise it is just indicating the offset in the memory block holding the structure where the string will be.</p>
<p>This technique is also sometimes used in network programming when the length of the packet is unknown until the packet header is read and the field containing the packet size can be read.</p>
<h1>Reading the directory</h1>
<p>Now that we know what a <code>struct</code> is, we can start using <code>readdir</code>. This function returns a pointer to a <code>struct dirent</code>. This type is defined in <code>#include &lt;dirent.h&gt;</code> and as you had already figure out the name comes from <em>DIRectory ENTry</em>.</p>
<p>So, each time we run <code>readdir</code> we will get the information of one of the files in the directory. We have to call it again and again until the whole directory is read. So, the question is: when should we stop?. Well, the answer, is in the <code>man</code> pages. Never underestimate the amount of information provided by the man pages. So this is what it says:</p>
<pre><code>RETURN VALUE
       On  success, readdir() returns a pointer to a dirent structure.  (This structure
       may be statically allocated; do not attempt to free(3) it.)

       If the end of the directory stream is reached, NULL is returned and errno is not
       changed.   If  an error occurs, NULL is returned and errno is set appropriately.
       To distinguish end of stream and from an error, set errno to zero before calling
       readdir() and then check the value of errno if NULL is returned.
</code></pre>
<p>Crystal clear. Now we can recall the main loop in our <code>select_target</code> function and look at it again:</p>
<pre><code class="lang-auto">  while (1) {
      errno = 0;
      if (!(de = readdir (d))) {
	    if (errno) perror ("readdir:");
	    break;
      }
      pf (de-&gt;d_name);
    }
</code></pre>
<p>We had already introduced the <code>while</code> loop in the past. It just loops <em>while</em> the condition we set in the <code>while</code> is true. In this case, <code>while(1)</code> means that the loop will run forever, because the condition is always true (!= 0).</p>
<p><em>NOTE:C doesn’t has a boolean type. Conditional operators traditionally returns FALSE as 0 and TRUE as not zero. Setting the while condition to 1 means that it is always true. You could set it to 31173 and it will work the same, but why would you type 5 numbers when you can just type 1?.</em></p>
<p>Then we are prepared to call <code>readdir</code>. We set <code>errno</code> to zero as proposed in the man page, and call the function, if we get a <code>NULL</code> we fall into the <code>if</code>. Then we check again the <code>errno</code> variable and if it has changed we show and error. In either case, we had an error or we have reached the end of the list, we leave the while loop using <code>break</code>.</p>
<blockquote>
<p>NOTE: The expression we use above <code>if (!p)</code> is equivalent to <code>if (p == 0)</code> or if you prefer <code>if (p == NULL)</code>, the compiler will see that <code>p</code> is a pointer and will change 0 to a compatible representation of <code>NULL</code>. The way to write this is a matter of personal taste and some people says <code>if (!p)</code> is bad style, and some other say it is good… Just do whatever better suits you, but be aware of what is going under the hood. The key point here is that NULL is a special value and doesn’t need to be the integer 0. This may be confusing for the beginner. You can take a look to <a href="http://c-faq.com/null/" rel="noopener nofollow ugc">the c faq NULL section</a> for details.</p>
</blockquote>
<p>Otherwise, we access the field <code>d_name</code> in the struct <code>struct dirent</code> that contains the name of the directory entry returned by <code>readdir</code> and pass it to the <code>payload</code> function.</p>
<h1>Reading directories with system calls</h1>
<p>We have a working function able to read the content of a directory in the disk using the POSIX interface. Overall, when writing malware we would like to minimise application dependencies and in the extreme case that implies just using the OS and avoid all libraries… However this is not always possible.</p>
<p>In this case, instead of using the POSIX function we can use the associated Linux system call. This is perfectly fine, however the drawback is that the POSIX version will work with all POSIX compatible operating systems and the non-POSIX version will be Linux specific. In other words, all POSIX compatible system have the <code>opendir/readdir/closedir</code> functions but each one will have different system calls to access the directories. That is what standards are for.</p>
<blockquote>
<p>NOTE: That our program will work in any POSIX complaint system (Linux, NetBSD, OpenBSD, Solaris, MacOs…) means that we can recompile for those systems and the program will still work, it doesn’t mean that any compiled version of our program will run magically in all POSIX compliant OSes… <a href="../multi-platform-execution/25663/index.html">However</a></p>
</blockquote>
<blockquote>
<p>NOTE2: Linux is not officially POSIX complaint. Despite of possible minor divergences the main issue is that POSIX certification, as most certifications out there, are really achieved by paying a fee…</p>
</blockquote>
<p>Anyhow, malware is usually target specific (platform-wise) and getting rid of the standard libc will make our program very small and give us much more control on what is in it and what is not.</p>
<p>So, the system call that we have to use is known as <code>getdents</code>. Sure, you got it, it stands for <em>GET Directory ENTries</em>. There is a man page for it and it says that there is no wrapper provided by libc, so we have to write our own if we want to use it (the man page already says how to do that):</p>
<pre><code class="lang-auto">#include &lt;sys/syscall.h&gt;

int getdents (int fd, char *buf, int len)
{ return syscall (SYS_getdents, fd, buf, len); }
</code></pre>
<p>We will not go all the way down to the kernel right now. We implement it using the <code>syscall</code> standard function instead of invoking the <code>syscall</code> processor instruction directly so we can still use C code and we do not need to start adding assembler at this point. We will get to that a bit later.</p>
<p>In order to use this function, we need a file descriptor for the directory. We can get this using the standard <code>open</code> system call. This will do the trick:</p>
<pre><code class="lang-auto">int select_target (PAYLOAD_FUNC pf) {
  char                buf[BUF_SIZE];
  struct linux_dirent *de;
  int                 fd, n, i;
  
  // Open directory using open
  if ((fd = open (folder, O_RDONLY | O_DIRECTORY)) &lt; 0) exit (1);

  while (1) {
    // Read directory entries
    }
  }
  close (fd);
  return 0;
</code></pre>
<p>At this level, we manage the directory exactly the same than a file. We <code>open</code> it… and we <code>close</code> it whenever we are done. Now is time to see how to use <code>getdents</code>.</p>
<h2>Using <code>getdents</code>
</h2>
<p>The <code>getdents</code> prototype is as follows:</p>
<pre><code>int getdents(unsigned int fd, struct linux_dirent *dirp, unsigned int count);
</code></pre>
<p>It receives as parameters a file descriptor (the one we got from the call to <code>open</code> with flag <code>O_DIRECTORY</code>), then a pointer to the <code>struct linux_dirent</code> (actually an pseudo-array of items of this type) and finally the size of the buffer we pass as parameter in the second parameter. You will understand this in a second.</p>
<p>As you can see the second parameter is of type <code>struct linux_dirent</code> instead of the <code>struct_dirent</code> that we used with the POSIX version. These structures are slightly different, but we can get them from the man pages of the <code>readdir</code> function and <code>getdents</code> system call respectively. Anyway we had already introduced it previously when we talked about `structs .</p>
<p>So, how does <code>getdents</code> works?. It doesn’t return just one directory entry… it returns as many as will fit in the buffer we pass as second parameter, and that number will vary depending on… Yes sure, on the length of the name of each entry. So the return value (the number of bytes read) is important in order to extract the information.</p>
<p>The man page also include example code on how to use the system call. I will include here a simplified version to explain how does this syscall work:</p>
<pre><code class="lang-auto">  char                buf[BUF_SIZE];
  struct linux_dirent *de;
  int                 fd, n, i;
(...)
  while (1) {
    n = getdents (fd, buf, BUF_SIZE);
    if (n &lt; 0) exit (1);
    if (n == 0) break;

    // Build file name
    for (i = 0; i &lt; n;) {
      de = (struct linux_dirent *)(buf + i);
      
	pf (de-&gt;d_name);
    i += de-&gt;d_reclen;
  }
</code></pre>
<p>First we call the syscall and process errors and end condition. And after that we have to process all the entries reported by the syscall…and we do not know how many are there. That number will depend on the size of the buffer we pass to the syscall. So we run our loop over bytes and not over <code>struct linux_dirent</code> items because we do not know the size of each entry in the array (actually this is why it is not really an array).</p>
<p>The variable <code>n</code> contains the number of bytes read by <code>getdents</code>.</p>
<p>The first entry will be at offset zero of our buffer. We access it casting our general buffer to the structure, do what we want to do and then we increase the offset by the size of the directory entry that is stored in the field <code>reclen</code>. This will update the offset in the buffer to point to the next entry and we repeat the process.</p>
<blockquote>
<p>NOTE: Casting a pointer is just forcing it into some type. This only make sense for the compiler. In reality, the memory is the same, regardless the cast operation we apply. Casting will allow us to tweak our view of a given memory block. Imaging our memory block is 16 bytes. We can see it as 16 <code>unsigned chars</code>, 8 <code>shorts</code>, 4 <code>ints</code>, 2 <code>longs</code> or 1 <code>longlong</code>. The memory block will have the same content but in our program the values that will get after casting will be different.</p>
<p>Example:<br>
A 8 bytes memory block at address ADDR contains.</p>
<pre><code>addr =  | 0x00 | 0x01 | 0x02 | 0x03 | 0x04 | 0x05 | 0x06 | 0x07 | 
</code></pre>
<pre><code class="lang-auto">long *l = (long *) addr; // l[0] or *l will be 0x0001020304050607
int  *i = (int  *) addr; // i[0] or *i will be 0x00010203 and i[1] or *(i+1) = 0x04050607
char *c = (char *) addr; // c[0] = 0x00, c[1]= 0x01, .... c[7] = 0x07
</code></pre>
</blockquote>
<p>Let’s see this with an example. Imagine a folder containing just a file named <code>a.txt</code>. This is what <code>getdents</code> will return in the buffer:</p>
<pre><code>buf+64     -&gt; | inode
              +-------------- 
buf+59     -&gt; | a.txt\0
buf+57     -&gt; | 24
buf+49     -&gt; | offset
buf+41     -&gt; | inode
              +--------------
buf+38     -&gt; | ..\0
buf+36     -&gt; | 21 
buf+28     -&gt; | offset
buf+20     -&gt; | inode  &lt;----------+-- addr + 20
              +--------------     |           ^
buf+18     -&gt; | .\0               |           |
buf+16     -&gt; | 20     -----------+-----------+
buf+8      -&gt; | offset            |
buf       --&gt; | inode  &lt;----------+--- addr
              +--------------
</code></pre>
<p><em>NOTE: According to the man page, the offset is the distance from the start of the directory to the next dirent struct, however after printing the values I get on my test program those number look strange. I may need to double check, but may be related to the actual EXT3 filesystem that stores the directories as linked lists. For the time being we can use <code>reclen</code> to deal with the buffer returned by <code>getdents</code>, and ignore <code>d_off</code></em></p>
<p>As you can see we always get the current (<code>.</code>) and the parent ( <code>..</code>) directories and then the rest of files. In this case we only have an extra file and our 1024 bytes buffer will be mostly empty after reading the whole folder. A directory containing many files may fill the buffer completely and we may need to call <code>getdents</code> again to keep reading the directory.</p>
<h1>Opaque data types. The <code>DIR</code> struct</h1>
<p>Now we could figure out what is in the <code>DIR</code> type we used with the POSIX interface. It is not that we need that, but figuring out this kind of things will boost your learning… so it is up to you to skip this section or not.</p>
<p>The <code>DIR</code> type is a so-called opaque data type in the sense that the programmer (that is us) cannot see what is in it. Compare this to the <code>struct dirent</code> we have been used in our examples, where we can see the different fields and we actually need to use them.</p>
<p>Opaque data types are used together with an API that does what we need so we do not need to access the structure directly. This has the advantage that new versions of the SW may change the internal structure of the data type and, as far as the API doesn’t change our program will still work. This concept is known generically as <em>Encapsulation</em>.</p>
<p>Making a structure opaque is just a matter of not exposing the internal structure. That’s means, the structure is not defined in the .h files available to the programmer. We will see how to do this later. For the time being this is not relevant.</p>
<p>So, with all the information we have, and after learning how to use the POSIX API we can figure out what is in this <code>DIR</code> data type and also how to implement the different functions. The structure would be more or less like:</p>
<pre><code class="lang-auto">typedef struct __my_dirstream {
	int      fd;             // File descriptor returned by open. Required by getdent
	char     buf[BUF_SIZE];  // Buffer to read directory entries (to call getdent)
	int      n;              // Number of bytes to process
	int      off;            // Number of bytes already processed
} MY_DIR;
</code></pre>
<p>I will leave as exercise to the reader the implementation of the POSIX interface using <code>open/getdents/close</code>. It is a nice exercise to get more fluent with the C programming language. Just do it, it is pretty straightforward with all the information we have learnt so far and will help you to get comfortable with C… you may need to add more fields to the structure above depending on how do you implement the API.</p>
<h1>The final version</h1>
<p>Just for your convenience this is the final complete version of our directory listing program:</p>
<pre><code class="lang-auto">#define _GNU_SOURCE  // Needed by syscall
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/types.h&gt;  
#include &lt;sys/stat.h&gt;   // Stat systemcall

#include &lt;sys/syscall.h&gt;

#define BUF_SIZE 1024

#define MFW_EXIT(s) do {perror (s); exit (EXIT_FAILURE);} while (0)

// Dirent Data struct
struct linux_dirent {
  long           d_ino;
  off_t          d_off;
  unsigned short d_reclen;
  char           d_name[];
};


char folder[1024];

// getdent wrapper. Not provided by glibc
int getdents (int fd, char *buf, int len)
{ return syscall (SYS_getdents, fd, buf, len); }

typedef int (*PAYLOAD_FUNC)(char *);

int payload (char *target) {
  printf ("Doing malware things to %s\n", target);
}

int select_target (PAYLOAD_FUNC pf) {
  char                buf[BUF_SIZE];
  struct linux_dirent *de;
  struct stat         st;
  int                 fd, n, i;
  
  // Open directory using open
  if ((fd = open (folder, O_RDONLY | O_DIRECTORY)) &lt; 0) MFW_EXIT("open:");

  while (1) {
    n = getdents (fd, buf, BUF_SIZE);
    if (n &lt; 0) MFW_EXIT ("getdents:");
    if (n == 0) break;

    for (i = 0; i &lt; n;) {
      de = (struct linux_dirent *)(buf + i);
	  pf (de-&gt;d_name);
      i += de-&gt;d_reclen;
    }
  }
  close (fd);
  return 0;
}

int main (int argc, char *argv[]) {
  strcpy (folder, argv[1]);
  while (select_target(payload));
}

</code></pre>
<p>It has some minor changes and all the required includes and defines. I would recommend to go through it and try to understand the stuff that is not described in this text. Do not hesitate to ask in the comments if you do not understand something.</p>
<h1>Conclusions</h1>
<p>We have learnt how to read a directory using the standard POSIX interface and also using system calls. We have also learnt about function pointers and <code>structs</code>. A lot of stuff to digest. I know.</p>
<p>This is the first step to implement the <code>select_target</code> function. The second one is to be able to determine the details of each file in the directory and thus select the target needed by each specific malware. This is what we will deal with in the next instalment.</p>
<p>Note that these articles are intended for newbies, so be free to ask in the comments about any doubt. There is no stupid question when you are starting so do not be shy, I’ll try to answer all of your doubts and I’m also interested on knowing if the level of the text is too easy or too hard, so your feedback will be pretty much appreciated.</p>
<p>However I would recommend to first try to answer your question by yourself, using Google, and rechecking the previous instalments. It is not just bad <a href="https://en.wikipedia.org/wiki/Etiquette_in_technology" rel="noopener nofollow ugc">nettiquette </a> to ask questions that you can solve yourself it is also way better for your learning process. The things you learn by yourself remind steady in your memory and broads your view of the topic.</p>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/LikeAction" />
<meta itemprop="userInteractionCount" content="6" />
<span class="post-likes">6 Likes</span>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/CommentAction" />
<meta itemprop="userInteractionCount" content="0" />
</div>
<div class="crawler-linkback-list" itemscope itemtype="http://schema.org/ItemList">
<div itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
<a itemprop="url" href="../programming-for-wanabes-viii-file-details/25738.html">Programming for Wanabes VIII. File Details</a>
<meta itemprop="position" content="5">
</div>
<div itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
<a itemprop="url" href="../programming-for-wanabes-x-file-details-in-asm/25843.html">Programming for Wanabes X. File details in asm</a>
<meta itemprop="position" content="6">
</div>
<div itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
<a itemprop="url" href="../programming-for-wanabes-ix-finding-files-in-asm/25794.html">Programming for Wanabes IX. Finding Files in asm</a>
<meta itemprop="position" content="7">
</div>
</div>
</div>
<div id="post_2" itemprop="comment" itemscope itemtype="http://schema.org/Comment" class="topic-body crawler-post">
<div class="crawler-post-meta">
<span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a itemprop="url" href="https://0x00sec.org/u/messede"><span itemprop="name">messede</span></a>
</span>
<link itemprop="mainEntityOfPage" href="25662.html">
<span class="crawler-post-infos">
<time itemprop="datePublished" datetime="2021-04-15T05:37:36Z" class="post-time">
April 15, 2021, 5:37am
</time>
<meta itemprop="dateModified" content="2021-04-15T05:37:36Z">
<span itemprop="position">2</span>
</span>
</div>
<div class="post" itemprop="text">
<p>Good stuff , as usual <img src="../../images/emoji/twitter/+1.png%3Fv=9" title=":+1:" class="emoji" alt=":+1:"><img src="../../images/emoji/twitter/+1.png%3Fv=9" title=":+1:" class="emoji" alt=":+1:"><img src="../../images/emoji/twitter/ok_hand.png%3Fv=9" title=":ok_hand:" class="emoji" alt=":ok_hand:"></p>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/LikeAction" />
<meta itemprop="userInteractionCount" content="2" />
<span class="post-likes">2 Likes</span>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/CommentAction" />
<meta itemprop="userInteractionCount" content="0" />
</div>
</div>
<div id="post_3" itemprop="comment" itemscope itemtype="http://schema.org/Comment" class="topic-body crawler-post">
<div class="crawler-post-meta">
<span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a itemprop="url" href="https://0x00sec.org/u/crimsonRain"><span itemprop="name">crimsonRain</span></a>
</span>
<link itemprop="mainEntityOfPage" href="25662.html">
<span class="crawler-post-infos">
<time itemprop="datePublished" datetime="2021-04-15T18:04:57Z" class="post-time">
April 15, 2021, 6:04pm
</time>
<meta itemprop="dateModified" content="2021-04-15T18:04:57Z">
<span itemprop="position">3</span>
</span>
</div>
<div class="post" itemprop="text">
<p>Once again, another great post. Looking forward to more.<br>
P.S. Thanks for referencing my post on CPE!</p>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/LikeAction" />
<meta itemprop="userInteractionCount" content="2" />
<span class="post-likes">2 Likes</span>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/CommentAction" />
<meta itemprop="userInteractionCount" content="1" />
</div>
</div>
<div id="post_4" itemprop="comment" itemscope itemtype="http://schema.org/Comment" class="topic-body crawler-post">
<div class="crawler-post-meta">
<span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a itemprop="url" href="https://0x00sec.org/u/0x00pf"><span itemprop="name">0x00pf</span></a>
(pico)
</span>
<link itemprop="mainEntityOfPage" href="25662.html">
<span class="crawler-post-infos">
<time itemprop="datePublished" datetime="2021-04-15T18:18:52Z" class="post-time">
April 15, 2021, 6:18pm
</time>
<meta itemprop="dateModified" content="2021-04-15T18:18:52Z">
<span itemprop="position">4</span>
</span>
</div>
<div class="post" itemprop="text">
<p>Thanks mate. Your post come just in time. I wrote that sentence and then I saw it and I have to add the reference. Great job!</p>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/LikeAction" />
<meta itemprop="userInteractionCount" content="2" />
<span class="post-likes">2 Likes</span>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/CommentAction" />
<meta itemprop="userInteractionCount" content="1" />
</div>
</div>
<div id="post_5" itemprop="comment" itemscope itemtype="http://schema.org/Comment" class="topic-body crawler-post">
<div class="crawler-post-meta">
<span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a itemprop="url" href="https://0x00sec.org/u/crimsonRain"><span itemprop="name">crimsonRain</span></a>
</span>
<link itemprop="mainEntityOfPage" href="25662.html">
<span class="crawler-post-infos">
<time itemprop="datePublished" datetime="2021-04-15T18:35:41Z" class="post-time">
April 15, 2021, 6:35pm
</time>
<meta itemprop="dateModified" content="2021-04-15T18:35:41Z">
<span itemprop="position">5</span>
</span>
</div>
<div class="post" itemprop="text">
<p>Really happy to hear that!</p>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/LikeAction" />
<meta itemprop="userInteractionCount" content="0" />
<span class="post-likes"></span>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/CommentAction" />
<meta itemprop="userInteractionCount" content="0" />
</div>
</div>
<div id="post_6" itemprop="comment" itemscope itemtype="http://schema.org/Comment" class="topic-body crawler-post">
<div class="crawler-post-meta">
<span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a itemprop="url" href="https://0x00sec.org/u/jeff"><span itemprop="name">jeff</span></a>
(jeff)
</span>
<link itemprop="mainEntityOfPage" href="25662.html">
<span class="crawler-post-infos">
<time itemprop="datePublished" datetime="2021-04-15T19:56:16Z" class="post-time">
April 15, 2021, 7:56pm
</time>
<meta itemprop="dateModified" content="2021-04-15T19:56:16Z">
<span itemprop="position">6</span>
</span>
</div>
<div class="post" itemprop="text">
<p>thank you for this amazing series!</p>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/LikeAction" />
<meta itemprop="userInteractionCount" content="3" />
<span class="post-likes">3 Likes</span>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/CommentAction" />
<meta itemprop="userInteractionCount" content="0" />
</div>
</div>
<div id="post_7" itemprop="comment" itemscope itemtype="http://schema.org/Comment" class="topic-body crawler-post">
<div class="crawler-post-meta">
<span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a itemprop="url" href="https://0x00sec.org/u/system"><span itemprop="name">system</span></a>
(system)
Closed
</span>
<link itemprop="mainEntityOfPage" href="25662.html">
<span class="crawler-post-infos">
<time itemprop="datePublished" datetime="2021-08-14T13:43:36Z" class="post-time">
August 14, 2021, 1:43pm
</time>
<meta itemprop="dateModified" content="2021-08-14T13:43:36Z">
<span itemprop="position">7</span>
</span>
</div>
<div class="post" itemprop="text">
<p>This topic was automatically closed after 121 days. New replies are no longer allowed.</p>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/LikeAction" />
<meta itemprop="userInteractionCount" content="0" />
<span class="post-likes"></span>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/CommentAction" />
<meta itemprop="userInteractionCount" content="0" />
</div>
</div>
</div>
</div>
<footer class="container wrap">
<nav class="crawler-nav">
<ul>
<li itemscope itemtype="http://schema.org/SiteNavigationElement">
<span itemprop="name">
<a href="../../index.html" itemprop="url">Home </a>
</span>
</li>
<li itemscope itemtype="http://schema.org/SiteNavigationElement">
<span itemprop="name">
<a href="../../categories.html" itemprop="url">Categories </a>
</span>
</li>
<li itemscope itemtype="http://schema.org/SiteNavigationElement">
<span itemprop="name">
<a href="https://0x00sec.org/guidelines" itemprop="url">FAQ/Guidelines </a>
</span>
</li>
<li itemscope itemtype="http://schema.org/SiteNavigationElement">
<span itemprop="name">
<a href="../../tos.html" itemprop="url">Terms of Service </a>
</span>
</li>
<li itemscope itemtype="http://schema.org/SiteNavigationElement">
<span itemprop="name">
<a href="../../privacy.html" itemprop="url">Privacy Policy </a>
</span>
</li>
</ul>
</nav>
<p class="powered-by-link">Powered by <a href="https://www.discourse.org">Discourse</a>, best viewed with JavaScript enabled</p>
</footer>
<script src="https://instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>
</body>
</html>
