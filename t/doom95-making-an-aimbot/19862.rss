<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>DOOM95 | Making an aimbot</title>
    <link>https://d.clarkee.co.uk/t/doom95-making-an-aimbot/19862</link>
    <description>In the name of Allah, the most beneficent, the most merciful.

---

#### Introduction
&quot;.الأفكار تغير طابعك، أما الأفعال فتغير واقعك&quot;

I&#39;ve played lots of classic games as a child, one that I particularly enjoyed was called **DOOM**, its concept was overly simple:
- Kill monsters that spawn all over the map. (%)
- Collect items. (%)
- Unlock each level&#39;s secret.

But as the saying goes: *&quot;There is beauty in simplicity&quot;*.

Those days are *long gone*, and although everything that surrounds me changed, **I didn&#39;t**.
I guess few things never *vanish*.
*Note: I might do things wrong, but it&#39;s all for fun anyway :slight_smile:!*

#### And so it all began

The shareware is available to download from *[ModDB](https://www.moddb.com/games/doom/downloads/doom-shareware-doom95)*. 
![image|477x197](upload://7j0MDqOHb2Nsnsb42LmdNuLS17F.png) 
\
I started off by playing the game for a while, it reminded me of the implemented movement system.
The *left/right* arrow-keys allow **screen rotation**.
While *up/down* keys *render* **forward and backward moves** possible.
![DView|116x144](upload://3PNeSHzBXOAQg09rlbj7rv021Do.png) 
\
In order to look for the Image&#39;s entry point, I used WinDBG and attached to *Doom95.exe* process.
![image|387x77](upload://yTlUaPKf7kPprCH0Pjuce8rXTjT.png) 
\
As you may have noticed, I&#39;m running on a *64-bit machine*.
But the executable is 32-bit:
![image|484x197](upload://iZmM9UauQRmuyryplYkIQdlCO1r.png)
**IMAGE_DOS_HEADER**&#39;s *lfanew* holds the *Offset* to the *PE signature*.
\--
![image|672x225, 75%](upload://eiBJvu8hJBqKPPEEcewOHMURkc.png)
The field next to **&quot;PE\x00\x00&quot;** is called *&#39;Machine&#39;*, a **USHORT** indicating *its type*.
so  I proceeded to switch to *x86 mode* using **wow64exts**.
\
![image|406x83](upload://bjbqvwKzJe1Kb10Hizv8gtolwAl.png) 
\--
![image|199x28](upload://oI1VBC85yqbd4V0ZocwlNRfcA29.png) 

I then looked-up *&quot;Doom&quot;* within *loaded modules*, and used *$iment* to *extract* the *specified module*&#39;s **entry point**.
```bash
0:011:x86&gt; lm m Doom*
start             end                 module name
00400000 00690000   Doom95   C (no symbols)           
10000000 10020000   Doomlnch C (export symbols)       Doomlnch.dll
0:011:x86&gt; ? $iment(00400000)
Evaluate expression: 4474072 = 004444d8
```
Jumping to that address in *IDA* reveals the function of interest: **_WinMain**.
![image|589x35](upload://zgpgeIeL6ORX8Rgdi3Qj2GBNYGm.png)
The search for parts with beneficial information started.
```
push    eax               ; nHeight
add     edx, ebx
push    edx               ; nWidth
push    0                 ; Y
push    0                 ; X
push    0x80CA0000        ; dwStyle
push    offset WindowName ; &quot;Doom 95&quot;
push    offset ClassName  ; &quot;Doom95Class&quot;
push    0x40000           ; dwExStyle
call    cs:CreateWindowExA
```
The **static** *WindowName* used by the call will result in our *fast retrieval* of *Doom&#39;s PID*.
![image|218x55](upload://kVqrn4xhKgfldtnMi0Xb4iSb4Rp.png) 
The combination of **FindWindow()** and **GetWindowThreadProcessId()** makes this possible.
```c++
	HWND	DoomWindow;
	DWORD	PID;
	DoomWindow = FindWindow(NULL, _T(&quot;Doom 95&quot;));

	if (! DoomWindow)
	{
		goto out;
	}

	GetWindowThreadProcessId(DoomWindow, &amp;PID);
	printf(&quot;PID: %d\n&quot;, PID);

	out:
	return 0;
```
![image|110x40](upload://r4UJT1Xqn3IgZ0IczfspueGXUaY.png) 
The next thing that caught my eye in the *_WinMain procedure* were the following lines.
```asm
loc_43AF74:
mov     edi, 1
mov     eax, ds:dword_60B00C
xor     ebp, ebp
mov     ds:dword_60B450, edi
mov     ds:dword_4775CC, ebp
cmp     eax, edi
jz      short loc_43AFB8
call    cs:GetCurrentThreadId
push    eax             ; dwThreadId
mov     edx, ds:hInstance
push    edx             ; hmod
push    offset fn       ; lpfn
push    2               ; idHook
call    cs:SetWindowsHookExA
mov     ds:hhk, eax
```
The function SetWindowsHookEx installs a **hook**(*fn*) within the *current thread* to *monitor System Events*. This example specifically uses an idHook that equals 2, which according to *MSDN* refers to **WH_KEYBOARD**.
![image|670x78, 75%](upload://ddq7X2nwVvrF2EQTW8CjRnoD8zB.png)
The callback function has the documented *[KeyboardProc](https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms644984(v%3Dvs.85))* prototype. It captures the *[Virtual-Key code](https://msdn.microsoft.com/en-us/library/dd375731(v=vs.85))* in *wParam*.
On top of that, the *fn* function invokes *GetAsyncKeyState* to check if a *specific key is pressed* too:
![image|316x128](upload://8cTpRvkiGeQwSna9g5J2MehIPtH.png)
The function that handles *arrow-keys* is *sub_442A90*.
![image|380x265](upload://fkHxHbIhsqedtIP9Nyn6QNpvQ9G.png)
\--
```asm
loc_439229:
mov     ebx, [esp+2Ch+v14]
mov     edx, [esp+2Ch+lParam]
mov     eax, esi
call    sub_442A90
```

#### Player information
Our ignorance of the structure stored within memory puts us at a disadvantage.
In order to find where *Health is mainly stored*, I&#39;ll be using *Cheat Engine* with the assumption that it is a *DWORD*(*4 bytes*): *&quot;\x64\x00\x00\x00&quot;*.
![image|547x136](upload://jOn5cBjBqC8uTeBqUWpc3rhDKVi.png)
I&#39;ll then proceed to get the *character damaged*, and *&#39;Next Scan&#39;* for the *new value*.
We end up with **5** different *pointers*.
![image|546x136](upload://hhNXPKhmsP9io4RoGThDkw28l87.png) 
The **last one** is of a *black color*, meaning that it is a *dynamic address*, modifying it doesn&#39;t result in any **observable change**.
Others are clearly static, modifying *3/4* of them leads to *restoring the original value*, which meant that the *1/4* left is **the parent**, and the *rest just copy its value*.
**00482538**: Health that appear on the screen.
**03682944**: A promising address because it is *not updated with the parent*.
*Health* is stored in *two different locations*, which means one is *nothing but a decoy*.
\
I set the *first one&#39;s value to **1***, and then got *attacked by a monster*.
![image|576x141](upload://b7SDPdPSwcu9qK8BLMwdjl88hdj.png)
The result is:
![image|412x35](upload://9tygzy6nlXGgmv2QsWEWYik4z1g.png)
The value that *appears on the screen hangs at 0*, and the *character doesn&#39;t die*.
While the second kept *decreasing on each attack*, meaning that it effectively held *the real value*.
We need to *inspect the memory region* by selecting the value and clicking *CTRL+B*.
![image|353x370](upload://n2LQxLywl9WNF0JQoZWVNhglWU5.png)
We can change the *Display Type* from **Byte hex** to **4 Byte hex**.
![image|588x53](upload://jS17zXcRgKCeXvP3oZZx1hIqvqG.png)
\--
![image|377x176](upload://bv2I6XTXgFbzoVBcKZnsSMmd8QG.png)
\--
![image|589x52](upload://bX3uqJ05AqeDPUGMSiLEOd4olvD.png)
This is easier to work with, I *started searching* for the **closest pointer** in a *limited range*, and it turned out to be **3682A24**.
![image|426x103](upload://29KWiJMKbPAAHAVlnRHw9fkVNJA.png)
We then *goto address* to see its content:
![image|431x105](upload://1SAx2Bo9VaO7aNnSVPiyfPHELAZ.png)
Notice that the *Object&#39;s health is empty*, and that *the struct* holds a **Backward and Forward link** at *its start*.

#### A spark
The idea that saved me a lot of time!
*[CHEAT CODES](https://doomwiki.org/wiki/Doom_cheat_codes)*, I was both happy and shocked to find out that they really existed!

*DOOMWiki* includes messages that appear on detection of each message.
Two commands were exceptional because of the information they manipulate.

![image|690x26, 100%](upload://AswH77cRyKBwfEHnPDtLbhp4Pd5.png) 
\--
![image|690x46, 100%](upload://2r4cv32Dx1qxUcuDO1t8yTCStfn.png) 

The magical keywords: *&quot;ang=&quot; and &quot;BY REQUEST...&quot;*.
The first one&#39;s usage occurs in:
```bash
loc_432776:
mov     eax, offset off_4669BC
movsx   edx, byte ptr [ebp+4]
call    sub_414E50
test    eax, eax
jz      short loc_4327D4
mov     edx, ds:dword_482A7C
lea     eax, ds:0[edx*8]
add     eax, edx
lea     eax, ds:0[eax*4]
sub     eax, edx
mov     eax, ds:dword_482518[eax*8]
mov     ebx, [eax+10h]
push    ebx
mov     ecx, [eax+0Ch]
push    ecx
mov     esi, [eax+20h]
push    esi
push    offset aAng0xXXY0xX0xX ; &quot;ang=0x%x;x,y=(0x%x,0x%x)&quot;
push    offset unk_5F2758
call    sprintf_
```
This is important and worthy to be added to our *CE Table*.
![image|434x36](upload://tuu3VYDpy6AO94R9Z60WOuyzHWb.png)
A struct layout is also to be concluded:
**@)** +0x10: y
**@)** + 0xC: x
**@)** +0x20: angle
I immediately noticed the missing *Z coordinate*.
I knew it existed, I mean, there&#39;s stairs. (Hey, don&#39;t laugh! :frowning:)
I ended up realizing that it is at *+0x14* after a few tests. (Up and down we go.)
\
![DCoords|217x235](upload://yMVc9VinW9pWVKV9TId1KQMMKye.png)
\
I knew that even if the enemy is on a different altitude: The shot still hits, and so I ignored Z.
X, Y and Angle on the other hand are majorly important because of *distance calculation* and *angle measurement*.
The values they *held look weird*, are *they floats*?
![image|448x98](upload://r7bMTq6GxGzE8b6FEOLRAXsLPfe.png)
![image|478x20](upload://4MqpujagAUzJBxQdAr3nBERf6Vd.png)
No, doesn&#39;t look like it. All I knew for now is that the *view changes upon modification*.

Moving on to the second:
```asm
loc_432533:
mov     eax, offset off_466898
movsx   edx, byte ptr [ebp+4]
call    sub_414E50
test    eax, eax
jz      short loc_43255E
mov     eax, ds:dword_5F274C
mov     dword ptr [eax+0D8h], offset aByRequest___ ; &quot;By request...&quot;
call    sub_420C50
jmp     loc_4326BA
```
We can see that it only passes execution to *sub_420C50*, and that&#39;s where the magic happens.
```bash
sub_420C50 proc near
push    ebx
push    ecx
push    edx
push    esi
mov     esi, ds:dword_484CFC
cmp     esi, offset dword_484CF8
jz      short loc_420C92
loc_420C62:
cmp     dword ptr [esi+8], offset sub_4250D0
jnz     short loc_420C87
test    byte ptr [esi+6Ah], 40h
jz      short loc_420C87
cmp     dword ptr [esi+6Ch], 0
jle     short loc_420C87
mov     ecx, 2710h
mov     eax, esi
xor     ebx, ebx
xor     edx, edx
call    sub_422370
loc_420C87:
mov     esi, [esi+4]
cmp     esi, offset dword_484CF8
jnz     short loc_420C62
loc_420C92:
pop     esi
pop     edx
pop     ecx
pop     ebx
retn
sub_420C50 endp
```
We can see that it traverses a *list of Objects*, starting with **[484CFC]** and ending if the *Forward link(+4)* *equals* **484CF8**.
![image|445x34](upload://oDUbsNrnDnTNWLGOoUwTvch2kK0.png)
The inclusion of **Player Object** in *the list* indicates that it contains *all available* **Entities**.
The three checks there are:
*[Entity + 0x08] == 0x4250D0
[Entity + 0x6A] &amp; 0x40
[Entity + 0x6C] &gt; 0*
I was curious on what the **Player Object** held at those *Offsets*:
![image|434x50](upload://5gdWwwKTdVikWgBGUiWKFuGOaDx.png)
**@)** + 0x8: *Function pointer(Pass)*.
**@)** +0x6A: *Byte(Error)*, *seems like IsMonster check*.
**@)** +0x6C: *Health(Pass)*.

#### A small mistake
&quot;Did anyone do this before?&quot;, I wondered.
So I searched for:
&gt; intext:&quot;ang=0x%x;x,y=(0x%x,0x%x)&quot; doom

And well, I found out that the *source code was available*. :joy:
 ![image|582x98, 100%](upload://oXgIhN7IH09d1M4WeLdnsodp7Cx.png)
At first *I was mad*, because I spent about *3 to 4 days to get the results previously stated*. But, hey! I *needed more information anyway*, and this was an *easy road showing up*.
![image|278x78](upload://dHf644NBUps5ieBj7kW372Z1Je3.png)
\--
![image|245x144](upload://ybrCODwvZyaJOs2ZmxeJuPnRoRK.png) 
\--
![image|204x41](upload://vHHSK5HzoS3EnN34GJQ1Kr7n1Gn.png)
So the structure we look for is defined in *[d_player.h](https://github.com/historicalsource/doom/blob/master/linuxdoom-1.10/d_player.h)*, the *interesting element&#39;s name* is **mo**.
```c
//
// Extended player object info: player_t
//
typedef struct player_s
{
    mobj_t*		mo;
...
```
Its nature is *mobj_t*, declared in *[p_mobj.h](https://github.com/historicalsource/doom/blob/master/linuxdoom-1.10/p_mobj.h)*.
```c
// Map Object definition.
typedef struct mobj_s
{
    // List: thinker links.
    thinker_t		thinker;

    // Info for drawing: position.
    fixed_t		x;
    fixed_t		y;
    fixed_t		z;

    // More list: links in sector (if needed)
    struct mobj_s*	snext;
    struct mobj_s*	sprev;

    //More drawing info: to determine current sprite.
    angle_t		angle;	// orientation
...
```
The size of *[thinker_t](https://github.com/historicalsource/doom/blob/master/linuxdoom-1.10/d_think.h)* is: *sizeof(PVOID) * 3* = 4 * 3 = **12**.
Then comes *X, Y and Z* at *(0x0C, 0x10, 0x14)*.
Two pointers *@0x18* are ignored(*4 * 2* = **8**).
Angle is at *0x20*.
```
...
    int			health;

    // Movement direction, movement generation (zig-zagging).
    int			movedir;	// 0-7
    int			movecount;	// when 0, select a new dir

    // Thing being chased/attacked (or NULL),
    // also the originator for missiles.
    struct mobj_s*	target;
...
```
The target element is interesting, it supposedly holds a pointer to the *Map Object* being attacked!
*Calculating its offset isn&#39;t that hard*, because we know that *Health* is at *0x6C*.
*FIELD_OFFSET(mobj_t, target)* = *0x6C + sizeof(int) * 3* = **0x78**.
The following line in *[r_local.h](https://github.com/historicalsource/doom/blob/master/linuxdoom-1.10/r_local.h)* indicates that there&#39;s a **lookup table/function** for *Angles*, explaining why there&#39;s *weird values therein*.
```
// Binary Angles, sine/cosine/atan lookups.
#include &quot;tables.h&quot;
```
It&#39;s time to see what the *target* element holds for us!
![image|239x270](upload://ifAehZzIQSolfYLFpM5xIpX9v4R.png) 
Since I just started up the game, its value is **NULL**.
![image|496x17](upload://3eLWzimOdQrjafIazsCqWbbGUWe.png)
*Attacking or getting attacked by a monster* leads to a *value change*.
![image|504x16](upload://2xa2QmgNzxJN1N9CBFGzhy6U4Pf.png)
But there is no *update after killing the monster, hmmm*.
![image|197x195](upload://qDyCkdYcWX2bX9YzN5h0oiBWy5w.png)
The **health** is the *only indicator of death if it is &lt;= 0*.
And that&#39;s *not the only problem*:
*Attacking a second Monster doesn&#39;t result in any change occuring*.
Since I want it to be *regularly updated*, I had to *find a way around it*.
I restarted *Doom95.exe*, selected the *Pointer to Player&#39;s Target* and:
![image|562x176](upload://qVGF3JwoHwd3pkjxUw2USoMQJAF.png)
\--
![image|365x122](upload://i14OnO0rhb3BBhGG62hauOh1KOd.png)
\--
![image|341x126](upload://iP6YDDy81DU9khoKHLBpyVPDocj.png) 
\--
![image|407x427](upload://jZYCS75mYllBnHZbdYpc7fZdiAp.png)
We can now start fighting an enemy:
![image|394x63](upload://6UVtY6H9xaKBZFCwM7tgQ8F82SV.png)
This is the instruction *responsible for writing to the Player&#39;s Target element*.
Going back a little in *disassembly window*, there are some **simple checks**:
*Is the Target NULL? Is it equal to the Player itself?*
![image|456x151](upload://pEiQiylHENAW1Ye3LSwacAVngDA.png)
The *origin of EBX register* is the *selected instruction*, and *its location is*: **00422684**.
All I had to do is *find a location* where to place a **JMP 422684**.
I ended up choosing **0042264F**:
![image|446x242](upload://seTB8qbvgQ4Uc2Ocjbrfj2AVdIm.png)
\--
![image|290x106](upload://bY60giAgoBmezhfbuDhUaKuN1xA.png)
\--
![image|424x15](upload://wHbpAsyIpFyZiEnksKs1GQ41AXN.png)
The ***sequence of bytes** turns from {0x7D, 0x1C} to {0xEB, 0x33}*, we aren&#39;t *destroying any instructions after it*.
Let&#39;s now see if it *changes on each attack*:
**Monster #1:**
![image|519x18](upload://6vzKIWFaYsdmfIj1mPIkDqZboGB.png) 
**Monster #2:**
![image|521x18](upload://uEv2BkqbWQF1UG33FQDAxRVciZK.png) 
*PERFECT!*

#### Last piece of the puzzle
Monsters could *accurately aim at my character*.
I knew a function responsible for **angle measurement** existed, *I just had to find it*.
After a *few hours searching*, I ended up looking in *[p_enemy.c](https://github.com/historicalsource/doom/blob/master/linuxdoom-1.10/p_enemy.c)*;
```cpp
boolean P_CheckMeleeRange (mobj_t*	actor)
{
    mobj_t*	pl;
    fixed_t	dist;
	
    if (!actor-&gt;target)
	return false;
		
    pl = actor-&gt;target;
    dist = P_AproxDistance (pl-&gt;x-actor-&gt;x, pl-&gt;y-actor-&gt;y);

    if (dist &gt;= MELEERANGE-20*FRACUNIT+pl-&gt;info-&gt;radius)
	return false;
	
    if (! P_CheckSight (actor, actor-&gt;target) )
	return false;
							
    return true;		
}
```
A collection of interesting functions!
*P_AproxDistance()*
*P_CheckSight()*
And the most **promising** one:
![image|261x103](upload://vkxPq4qMs8lPbNqyrO67hLni9Uv.png)
*R_PointToAngle2()*, and its *[definition](https://github.com/id-Software/DOOM/blob/master/linuxdoom-1.10/r_main.c)* is *the following*:
```cpp
angle_t
R_PointToAngle2
( fixed_t	x1,
  fixed_t	y1,
  fixed_t	x2,
  fixed_t	y2 )
{	
    viewx = x1;
    viewy = y1;
    
    return R_PointToAngle (x2, y2);
}
```
I knew the *Player&#39;s X, Y were read right before invokation*. I used this information to *trace the calls* and *watched for accesses*:
![image|690x179](upload://bKuFQZadhRtHg4j4msdnZYkXKtW.png)
\--
![image|406x426](upload://g4RnIuu5SiJ5yVR8hcLPuG2yiKk.png)
Once a *monster aims at us*, we **get results**:
![image|368x500](upload://jkUWfogcaWDryCQJpGMISr9i7pn.png) 
I *started* with those with the *least hit-count at the middle*.
![image|268x69](upload://pIdj6xtr2mXFjPA6lzUOLcxP0ek.png)
*The second one looks like the thing we&#39;re looking for!*
![image|167x90](upload://7rpj2BhBRF00MNFJ8EPPasWLVx4.png)
It prepares to call **0042DB10** by loading the *Target* in *EAX* and storing its *(X, Y) coordinates* in *EBX and ECX*, while *EAX and EDX* hold *those of the monster*.
*We can deduce that it is a __fastcall.*
**Disassembling** the function *shows*:
![image|495x181](upload://8KIIcQ2qpEtqA5vNpwMcRgwMGcT.png)
*Looks familiar!*
*It is R_PointToAngle2() @ **0042DB10** :slight_smile:!*
With that in *mind, locating this function is made easier*.
```cpp
//
// A_FaceTarget
//
void A_FaceTarget (mobj_t* actor)
{	
    if (!actor-&gt;target)
	return;
    
    actor-&gt;flags &amp;= ~MF_AMBUSH;
	
    actor-&gt;angle = R_PointToAngle2 (actor-&gt;x,
				    actor-&gt;y,
				    actor-&gt;target-&gt;x,
				    actor-&gt;target-&gt;y);
    
    if (actor-&gt;target-&gt;flags &amp; MF_SHADOW)
	actor-&gt;angle += (P_Random()-P_Random())&lt;&lt;21;
}
```
I&#39;ll just use *IDA*.
![image|315x95](upload://b4JuU96bk5LltnYyiU0nyIrw7Dz.png)
\--
![image|349x144](upload://wLnsf5SAqEg7kME3uvwaAZmjMGl.png) 
\--
![image|518x240](upload://oOJliovdZUrItGnJS2vGynk9Tmf.png)
Looks like it, *it starts by returning if Target is **NULL***, then *AND*s [*Monster+0x68*] with **0xDF**. What&#39;s sad, is that *I was looking at it since the beginning* in **CE**, welp :joy:.
*A_FaceTarget is at **0041F670***.

#### The making
All that *we&#39;ve learned about the game* will allow us to start *wrapping things* in *C++*.
Let&#39;s create *ADoom.h*:
```c
#ifndef __ADOOM_H__
#define __ADOOM_H__

class ADoom {
public:
	ADoom(DWORD);
	~ADoom();
private:
	HANDLE	DH;
};

#endif
```
And *ADoom.c*:
```c
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;stdexcept&gt;
#include &lt;tchar.h&gt;
#include &lt;Windows.h&gt;

#include &quot;ADoom.h&quot;

ADoom::ADoom(DWORD CPID)
{
	DH = OpenProcess(PROCESS_ALL_ACCESS, FALSE, CPID);

	if (DH != INVALID_HANDLE_VALUE)
	{
		return;
	}

	throw std::runtime_error(&quot;Can&#39;t open process!&quot;);
}

ADoom::~ADoom(){
	CloseHandle(DH);
}

int main()
{
	HWND	DoomWindow;
	DWORD	PID;

	DoomWindow = FindWindow(NULL, _T(&quot;Doom 95&quot;));
	if (! DoomWindow) goto out;
	GetWindowThreadProcessId(DoomWindow, &amp;PID);

	try
	{
		ADoom	DAim(PID);
	} catch (const std::runtime_error &amp;err) { };

	while (1)
	{
		Sleep(1);
	}
	out:
	return 0;
}
```
I&#39;ll create functions that *read(**rM**)/write(**wM**) to the process memory* by extending *both the header and source file*.
We are going to use *two WINAPI calls for that purpose*: **ReadProcessMemory()** and **WriteProcessMemory()**.
![image|255x152](upload://6Z2etDBlJvvpT3aVS32SPriNUJP.png) | | | | | ![image|282x159](upload://x0fChMctZMlRuOwwZwSDLakufvK.png) 
\--
```
	template&lt;typename ReadType&gt;
	ReadType rM(DWORD, DWORD);
	BOOL wM(DWORD, PVOID, SIZE_T);
```
\--
```c
template&lt;typename ReadType&gt;
ReadType ADoom::rM(DWORD RAddress, DWORD Offset)
{
	ReadType Result;
	PVOID	 External = reinterpret_cast&lt;PVOID&gt;(RAddress + Offset);

	ReadProcessMemory(DH, External, &amp;Result, sizeof(Result), NULL);
	return Result;
}

BOOL ADoom::wM(DWORD RAddress, PVOID LAddress, SIZE_T Size)
{
	BOOL	Status = FALSE;
	PVOID	External = reinterpret_cast&lt;PVOID&gt;(RAddress);

	if (WriteProcessMemory(DH, External, LAddress, Size, NULL))
	{
		Status = TRUE;
	}
	
	return Status;
}
```
*Let&#39;s check if Player&#39;s Object manipulation is possible*:
```c
	try
	{
		ADoom	DAim(PID);
		DWORD	Corrupt = 0x12345678, Player, PPlayer = 0x482518;

		Player = DAim.rM&lt;DWORD&gt;(PPlayer, 0);
		printf(&quot;Player Object @ %lX\n&quot;, Player);

		DAim.wM(PPlayer, &amp;Corrupt, sizeof(Corrupt));
		puts(&quot;Corrupted the Player Object.&quot;);
	} catch (const std::runtime_error &amp;err) { }
```
\--
![image|264x331](upload://ly6c7GFsj6JaDEr7Tj1ZVXLWYQC.png)  
The ***Doom95.exe** process crashes*, *success*.
We have to *apply the **2 byte** patch and keep an eye* on the **Player&#39;s Target** value.
```
	try
	{
		ADoom	DAim(PID);
		BYTE	Patch[2] = {0xEB, 0x33};
		DWORD	PAddress = 0x42264F;
		DWORD	Player, PPlayer = 0x482518;
		int		THealth;
		DWORD	OTarget = 0, Target;

		Player = DAim.rM&lt;DWORD&gt;(PPlayer, 0);
		printf(&quot;Player Object @ %lX\n&quot;, Player);

		printf(&quot;Applying Patch @ %lX\n&quot;, PAddress);
		DAim.wM(PAddress, &amp;Patch[0], sizeof(Patch));

		while (true)
		{
			Target = DAim.rM&lt;DWORD&gt;(Player, 0x78);

			// Are we currently engaging the enemy?
			if (Target != 0)
			{
				// If yes, is it already dead?
				THealth = DAim.rM&lt;int&gt;(Target, 0x6C);
				if (THealth &lt;= 0)
				{
					continue;
				}

				/*
					Uniqueness check.
				*/
				if (! OTarget || OTarget != Target)
				{
					printf(&quot;Current Target @ %lX\n&quot;, Target);
					OTarget = Target;
				}
			}
		}
	} catch (const std::runtime_error &amp;err) { }
```
\--
![image|207x91](upload://lsQqFMUPgeeNOODEyAV4SiDnZ62.png)
*So far so good, we are making progress.*
At first, I totally forgot about the **Health check**, and *it kept aiming at the dead Monster*.
![dead|220x167](upload://jON6o5PLmVhEEy7vMTFJ0rOQXyJ.gif) 
It is time to use our knowledge about *A_FaceTarget(**0041F670**)*.
It takes an *mobj_t \** argument in **EAX**, and *performs a single check*(*EAX-&gt;target != NULL*) before *calculating and storing the correct angle*, this is a *minimum of work on our side*.
All is left to do, is creating a **reliable function** and *storing/running* it in the *remote thread*.
```c
VOID _declspec(naked) Reliable(VOID)
{
	__asm {
		mov eax, 0x482518 // Load PPlayer in EAX
		mov eax, [eax]    // Load Player Object in EAX
		mov edi, 0x41F670 // Indicate the FP(A_FaceTarget)
		call edi          // Call it
		ret
	}
}
```
We can *compile the executable and load it up in IDA*.
![image|240x227](upload://jXTC4USdmpZg5xgnBm5eZCiKXKY.png) 
\--
***Hex-view** is synchronized with **Disassembly-view**, so selecting the first &#39;mov&#39; is all we have to do.*
![image|609x46](upload://g2kdHxZUqFXI7UJ9tHLlmoR7B6F.png)
That is *our function*!
```c
BYTE Payload[] = {0xB8, 0x18, 0x25, 0x48, 0x00, 0x8B, 0x00,
				  0xBF, 0x70, 0xF6, 0x41, 0x00, 0xFF, 0xD7,
				  0xC3};
DWORD PSize = sizeof(Payload);
```
With that done, *we need a location to write it to*, it needs to be *Executable/Readable and Writeable too*.
In order to get it, we will call **VirtualAllocEx()**.
![image|228x157](upload://od9JLxuLm4q7I9SJxPMZpzGMYDv.png)
We have to specify *flProtect* as *PAGE_EXECUTE_READWRITE*.
Another *helper function* will be called **aM** short for *allocate Memory*. :slight_smile:
```c
DWORD aM(SIZE_T);
```
\--
```c
DWORD ADoom::aM(SIZE_T Size)
{
	LPVOID RAddress = VirtualAllocEx(DH, NULL, Size, MEM_COMMIT | MEM_RESERVE,
					  PAGE_EXECUTE_READWRITE);
	DWORD  Cast = reinterpret_cast&lt;DWORD&gt;(RAddress);

	return Cast;
}
```
And then there should be a *function to spawn a Thread* in *Doom95.exe process*.
We&#39;ll be using **CreateRemoteThread()**, and *wait for it to terminate* using **WaitForSingleObject()**.
![image|350x181](upload://ebiICrKofvYkdCrHOasHhs5ivCb.png) | | ![image|220x100](upload://ti7Dc5gUNTnnWzbUY4a5fzX831.png) 
It&#39;ll be called **sT**.
```
VOID sT(DWORD);
```
\--
```cpp
VOID ADoom::sT(DWORD FPtr)
{
	HANDLE RT;

	RT = CreateRemoteThread(DH, NULL, 0, (LPTHREAD_START_ROUTINE) FPtr,
		 NULL, 0, NULL);

	if (RT != INVALID_HANDLE_VALUE)
	{
		WaitForSingleObject(RT, INFINITE);
	}
}
```
That&#39;s all we need, *now we can implement the whole loop*:
```
	try
	{
		ADoom	DAim(PID);
		BYTE	Patch[2] = {0xEB, 0x33};
		DWORD	PAddress = 0x42264F;
		BYTE	Payload[] = {0xB8, 0x18, 0x25, 0x48, 0x00, 0x8B, 0x00,
							 0xBF, 0x70, 0xF6, 0x41, 0x00, 0xFF, 0xD7,
							 0xC3};
		DWORD	Location, PSize = sizeof(Payload);
		DWORD	PPlayer = 0x482518, Player, Target;
		int		THealth;

		/*
			Patch:
			An unconditional JMP instruction that allows Player-&gt;target
			to be updated on every attack.
		*/
		printf(&quot;Applying Patch @ %lX\n&quot;, PAddress);
		DAim.wM(PAddress, Patch, sizeof(Patch));

		printf(&quot;Allocating Memory(%d)\n&quot;, PSize);
		Location = DAim.aM(PSize);

		printf(&quot;Storing Function @ %lX\n&quot;, Location);
		DAim.wM(Location, Payload, PSize);

		puts(&quot;[0x00sec] Aimbot starting.&quot;);

		while (TRUE)
		{
			Player = DAim.rM&lt;DWORD&gt;(PPlayer, 0);
			Target = DAim.rM&lt;DWORD&gt;(Player, 0x78);

			// Did any enemy attack us?
			if (Target != 0)
			{
				// If yes, is it still alive?
				THealth = DAim.rM&lt;int&gt;(Target, 0x6C);
				if (THealth &gt; 0)
				{
					// Aim at it.
					DAim.sT(Location);
				}
			}
		}
	} catch (const std::runtime_error &amp;err) { }
```
\--
![image|225x79](upload://qFQInlJJkzFdgAhszIE640shduk.png)
And it works! :smiley:

#### End
It took many attempts to get to the final product, but it certainly was fun!
I could not include *pictures or GIFs from the game because I didn&#39;t find a way to do it*, for that, I apologize.
Lots of modifications were made to guarantee *reliability*, an example would be *the Player object* is updated on *two events*: **Death**/**Level Change**.
And I also *got rid of some functions such as*:
```
VOID GetMonsters(vector&lt;DWORD&gt; *M, HANDLE Proc)
{
	DWORD	First = 0x484CFC, Last = 0x484CF8;
	int		MHealth;
	UCHAR	IsMonster;

	First = rM&lt;DWORD&gt;(First, Proc);
	Last = rM&lt;DWORD&gt;(Last, Proc);
	
	do {
		IsMonster = rM&lt;UCHAR&gt;(First + 0x6A, Proc);
		MHealth = rM&lt;int&gt;(First + 0x6C, Proc);

		// Is it a monster and is it alive?
		if ((IsMonster &amp; 0x40) &amp;&amp; (MHealth &gt; 0))
		{
			M-&gt;push_back(First);
		}
	} while ((First = rM&lt;DWORD&gt;(First + 4, Proc)) != Last);
}
```
*I didn&#39;t even need to include \&lt;cmath\&gt; in the end!*
**NIAHAHAHA!**
~ exploit</description>
    
    <lastBuildDate>Fri, 26 Jun 2020 05:42:23 +0000</lastBuildDate>
    <category>Reverse Engineering</category>
    <atom:link href="https://d.clarkee.co.uk/t/doom95-making-an-aimbot/19862.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>DOOM95 | Making an aimbot</title>
        <dc:creator><![CDATA[system]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 121 days. New replies are no longer allowed.</p>
          <p><a href="https://d.clarkee.co.uk/t/doom95-making-an-aimbot/19862/12">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/doom95-making-an-aimbot/19862/12</link>
        <pubDate>Thu, 16 Jul 2020 12:50:37 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-19862-12</guid>
        <source url="https://d.clarkee.co.uk/t/doom95-making-an-aimbot/19862.rss">DOOM95 | Making an aimbot</source>
      </item>
      <item>
        <title>DOOM95 | Making an aimbot</title>
        <dc:creator><![CDATA[hartescout]]></dc:creator>
        <description><![CDATA[
            <p>Carmacks’s gonna come at you with a shovel. <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<p>Awesome write up!</p>
          <p><a href="https://d.clarkee.co.uk/t/doom95-making-an-aimbot/19862/11">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/doom95-making-an-aimbot/19862/11</link>
        <pubDate>Fri, 26 Jun 2020 05:42:23 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-19862-11</guid>
        <source url="https://d.clarkee.co.uk/t/doom95-making-an-aimbot/19862.rss">DOOM95 | Making an aimbot</source>
      </item>
      <item>
        <title>DOOM95 | Making an aimbot</title>
        <dc:creator><![CDATA[DamaneDz]]></dc:creator>
        <description><![CDATA[
            <p>Nice one kho <img src="https://0x00sec.org/images/emoji/twitter/stuck_out_tongue.png?v=9" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:"> <img src="https://0x00sec.org/images/emoji/twitter/heart.png?v=9" title=":heart:" class="emoji" alt=":heart:"><br>
One of the best gamehacking sheet I’ve <em>ever read</em> !</p>
          <p><a href="https://d.clarkee.co.uk/t/doom95-making-an-aimbot/19862/10">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/doom95-making-an-aimbot/19862/10</link>
        <pubDate>Fri, 20 Mar 2020 12:47:41 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-19862-10</guid>
        <source url="https://d.clarkee.co.uk/t/doom95-making-an-aimbot/19862.rss">DOOM95 | Making an aimbot</source>
      </item>
      <item>
        <title>DOOM95 | Making an aimbot</title>
        <dc:creator><![CDATA[exploit]]></dc:creator>
        <description><![CDATA[
            <p>Thank youu <a class="mention" href="https://d.clarkee.co.uk/u/danus">@Danus</a>! <img src="https://0x00sec.org/images/emoji/twitter/grin.png?v=9" title=":grin:" class="emoji" alt=":grin:"> <img src="https://0x00sec.org/images/emoji/twitter/heart.png?v=9" title=":heart:" class="emoji" alt=":heart:"></p>
          <p><a href="https://d.clarkee.co.uk/t/doom95-making-an-aimbot/19862/9">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/doom95-making-an-aimbot/19862/9</link>
        <pubDate>Thu, 19 Mar 2020 16:33:04 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-19862-9</guid>
        <source url="https://d.clarkee.co.uk/t/doom95-making-an-aimbot/19862.rss">DOOM95 | Making an aimbot</source>
      </item>
      <item>
        <title>DOOM95 | Making an aimbot</title>
        <dc:creator><![CDATA[Danus]]></dc:creator>
        <description><![CDATA[
            <p>This is some pretty fucking cool stuff <a class="mention" href="https://d.clarkee.co.uk/u/exploit">@exploit</a>, good job!</p>
          <p><a href="https://d.clarkee.co.uk/t/doom95-making-an-aimbot/19862/8">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/doom95-making-an-aimbot/19862/8</link>
        <pubDate>Thu, 19 Mar 2020 15:40:31 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-19862-8</guid>
        <source url="https://d.clarkee.co.uk/t/doom95-making-an-aimbot/19862.rss">DOOM95 | Making an aimbot</source>
      </item>
      <item>
        <title>DOOM95 | Making an aimbot</title>
        <dc:creator><![CDATA[exploit]]></dc:creator>
        <description><![CDATA[
            <p>I know, it took forever <a class="mention" href="https://d.clarkee.co.uk/u/ricksanchez">@ricksanchez</a>. <img src="https://0x00sec.org/images/emoji/twitter/joy.png?v=9" title=":joy:" class="emoji" alt=":joy:"><br>
And thank youu, really happy you liked it! <img src="https://0x00sec.org/images/emoji/twitter/laughing.png?v=9" title=":laughing:" class="emoji" alt=":laughing:"></p>
          <p><a href="https://d.clarkee.co.uk/t/doom95-making-an-aimbot/19862/5">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/doom95-making-an-aimbot/19862/5</link>
        <pubDate>Tue, 17 Mar 2020 17:53:14 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-19862-5</guid>
        <source url="https://d.clarkee.co.uk/t/doom95-making-an-aimbot/19862.rss">DOOM95 | Making an aimbot</source>
      </item>
      <item>
        <title>DOOM95 | Making an aimbot</title>
        <dc:creator><![CDATA[ricksanchez]]></dc:creator>
        <description><![CDATA[
            <p>Good stuff as always <a class="mention" href="https://d.clarkee.co.uk/u/exploit">@exploit</a> ! Really enjoyed the write-up <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"> .<br>
About time you wrote a new article <img src="https://0x00sec.org/images/emoji/twitter/stuck_out_tongue.png?v=9" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:"></p>
          <p><a href="https://d.clarkee.co.uk/t/doom95-making-an-aimbot/19862/4">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/doom95-making-an-aimbot/19862/4</link>
        <pubDate>Tue, 17 Mar 2020 17:31:36 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-19862-4</guid>
        <source url="https://d.clarkee.co.uk/t/doom95-making-an-aimbot/19862.rss">DOOM95 | Making an aimbot</source>
      </item>
      <item>
        <title>DOOM95 | Making an aimbot</title>
        <dc:creator><![CDATA[exploit]]></dc:creator>
        <description><![CDATA[
            <p>Thank you so much, I’ll do my best <img src="https://0x00sec.org/images/emoji/twitter/heart.png?v=9" title=":heart:" class="emoji" alt=":heart:">!<br>
I’m really happy I found the time to write this <img src="https://0x00sec.org/images/emoji/twitter/grin.png?v=9" title=":grin:" class="emoji" alt=":grin:">!</p>
          <p><a href="https://d.clarkee.co.uk/t/doom95-making-an-aimbot/19862/3">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/doom95-making-an-aimbot/19862/3</link>
        <pubDate>Mon, 16 Mar 2020 21:03:10 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-19862-3</guid>
        <source url="https://d.clarkee.co.uk/t/doom95-making-an-aimbot/19862.rss">DOOM95 | Making an aimbot</source>
      </item>
      <item>
        <title>DOOM95 | Making an aimbot</title>
        <dc:creator><![CDATA[pry0cc]]></dc:creator>
        <description><![CDATA[
            <p>Sick article dude!</p>
<p>This is really creative stuff, you always kill it with your articles, keep it up man <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<p>You’re going to go so far in this world, there are few people like you.</p>
          <p><a href="https://d.clarkee.co.uk/t/doom95-making-an-aimbot/19862/2">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/doom95-making-an-aimbot/19862/2</link>
        <pubDate>Mon, 16 Mar 2020 21:00:31 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-19862-2</guid>
        <source url="https://d.clarkee.co.uk/t/doom95-making-an-aimbot/19862.rss">DOOM95 | Making an aimbot</source>
      </item>
      <item>
        <title>DOOM95 | Making an aimbot</title>
        <dc:creator><![CDATA[exploit]]></dc:creator>
        <description><![CDATA[
            <p>In the name of Allah, the most beneficent, the most merciful.</p>
<hr>
<h4><a name="p-54372-introduction-1" class="anchor" href="https://d.clarkee.co.uk#p-54372-introduction-1"></a>Introduction</h4>
<p>“.الأفكار تغير طابعك، أما الأفعال فتغير واقعك”</p>
<p>I’ve played lots of classic games as a child, one that I particularly enjoyed was called <strong>DOOM</strong>, its concept was overly simple:</p>
<ul>
<li>Kill monsters that spawn all over the map. (%)</li>
<li>Collect items. (%)</li>
<li>Unlock each level’s secret.</li>
</ul>
<p>But as the saying goes: <em>“There is beauty in simplicity”</em>.</p>
<p>Those days are <em>long gone</em>, and although everything that surrounds me changed, <strong>I didn’t</strong>.<br>
I guess few things never <em>vanish</em>.<br>
<em>Note: I might do things wrong, but it’s all for fun anyway <img src="https://d.clarkee.co.uk/images/emoji/twitter/slight_smile.png?v=15" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20">!</em></p>
<h4><a name="p-54372-and-so-it-all-began-2" class="anchor" href="https://d.clarkee.co.uk#p-54372-and-so-it-all-began-2"></a>And so it all began</h4>
<p>The shareware is available to download from <em><a href="https://www.moddb.com/games/doom/downloads/doom-shareware-doom95" rel="noopener nofollow ugc">ModDB</a></em>.<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://7j0MDqOHb2Nsnsb42LmdNuLS17F.png" width="477" height="197"><br>
<br>
I started off by playing the game for a while, it reminded me of the implemented movement system.<br>
The <em>left/right</em> arrow-keys allow <strong>screen rotation</strong>.<br>
While <em>up/down</em> keys <em>render</em> <strong>forward and backward moves</strong> possible.<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="DView" data-orig-src="upload://3PNeSHzBXOAQg09rlbj7rv021Do.png" width="116" height="144"><br>
<br>
In order to look for the Image’s entry point, I used WinDBG and attached to <em>Doom95.exe</em> process.<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://yTlUaPKf7kPprCH0Pjuce8rXTjT.png" width="387" height="77"><br>
<br>
As you may have noticed, I’m running on a <em>64-bit machine</em>.<br>
But the executable is 32-bit:<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://iZmM9UauQRmuyryplYkIQdlCO1r.png" width="484" height="197"><br>
<strong>IMAGE_DOS_HEADER</strong>’s <em>lfanew</em> holds the <em>Offset</em> to the <em>PE signature</em>.<br>
--<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://eiBJvu8hJBqKPPEEcewOHMURkc.png" width="504" height="168"><br>
The field next to <strong>“PE\x00\x00”</strong> is called <em>‘Machine’</em>, a <strong>USHORT</strong> indicating <em>its type</em>.<br>
so  I proceeded to switch to <em>x86 mode</em> using <strong>wow64exts</strong>.<br>
<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://bjbqvwKzJe1Kb10Hizv8gtolwAl.png" width="406" height="83"><br>
--<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://oI1VBC85yqbd4V0ZocwlNRfcA29.png" width="199" height="28"></p>
<p>I then looked-up <em>“Doom”</em> within <em>loaded modules</em>, and used <em>$iment</em> to <em>extract</em> the <em>specified module</em>’s <strong>entry point</strong>.</p>
<pre data-code-wrap="bash"><code class="lang-bash">0:011:x86&gt; lm m Doom*
start             end                 module name
00400000 00690000   Doom95   C (no symbols)           
10000000 10020000   Doomlnch C (export symbols)       Doomlnch.dll
0:011:x86&gt; ? $iment(00400000)
Evaluate expression: 4474072 = 004444d8
</code></pre>
<p>Jumping to that address in <em>IDA</em> reveals the function of interest: <strong>_WinMain</strong>.<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://zgpgeIeL6ORX8Rgdi3Qj2GBNYGm.png" width="589" height="35"><br>
The search for parts with beneficial information started.</p>
<pre><code class="lang-auto">push    eax               ; nHeight
add     edx, ebx
push    edx               ; nWidth
push    0                 ; Y
push    0                 ; X
push    0x80CA0000        ; dwStyle
push    offset WindowName ; "Doom 95"
push    offset ClassName  ; "Doom95Class"
push    0x40000           ; dwExStyle
call    cs:CreateWindowExA
</code></pre>
<p>The <strong>static</strong> <em>WindowName</em> used by the call will result in our <em>fast retrieval</em> of <em>Doom’s PID</em>.<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://kVqrn4xhKgfldtnMi0Xb4iSb4Rp.png" width="218" height="55"><br>
The combination of <strong>FindWindow()</strong> and <strong>GetWindowThreadProcessId()</strong> makes this possible.</p>
<pre data-code-wrap="c++"><code class="lang-c++">	HWND	DoomWindow;
	DWORD	PID;
	DoomWindow = FindWindow(NULL, _T("Doom 95"));

	if (! DoomWindow)
	{
		goto out;
	}

	GetWindowThreadProcessId(DoomWindow, &amp;PID);
	printf("PID: %d\n", PID);

	out:
	return 0;
</code></pre>
<p><img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://r4UJT1Xqn3IgZ0IczfspueGXUaY.png" width="110" height="40"><br>
The next thing that caught my eye in the <em>_WinMain procedure</em> were the following lines.</p>
<pre data-code-wrap="asm"><code class="lang-asm">loc_43AF74:
mov     edi, 1
mov     eax, ds:dword_60B00C
xor     ebp, ebp
mov     ds:dword_60B450, edi
mov     ds:dword_4775CC, ebp
cmp     eax, edi
jz      short loc_43AFB8
call    cs:GetCurrentThreadId
push    eax             ; dwThreadId
mov     edx, ds:hInstance
push    edx             ; hmod
push    offset fn       ; lpfn
push    2               ; idHook
call    cs:SetWindowsHookExA
mov     ds:hhk, eax
</code></pre>
<p>The function SetWindowsHookEx installs a <strong>hook</strong>(<em>fn</em>) within the <em>current thread</em> to <em>monitor System Events</em>. This example specifically uses an idHook that equals 2, which according to <em>MSDN</em> refers to <strong>WH_KEYBOARD</strong>.<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://ddq7X2nwVvrF2EQTW8CjRnoD8zB.png" width="502" height="58"><br>
The callback function has the documented <em><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms644984(v%3Dvs.85)" rel="noopener nofollow ugc">KeyboardProc</a></em> prototype. It captures the <em><a href="https://msdn.microsoft.com/en-us/library/dd375731(v=vs.85)" rel="noopener nofollow ugc">Virtual-Key code</a></em> in <em>wParam</em>.<br>
On top of that, the <em>fn</em> function invokes <em>GetAsyncKeyState</em> to check if a <em>specific key is pressed</em> too:<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://8cTpRvkiGeQwSna9g5J2MehIPtH.png" width="316" height="128"><br>
The function that handles <em>arrow-keys</em> is <em>sub_442A90</em>.<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://fkHxHbIhsqedtIP9Nyn6QNpvQ9G.png" width="380" height="265"><br>
--</p>
<pre data-code-wrap="asm"><code class="lang-asm">loc_439229:
mov     ebx, [esp+2Ch+v14]
mov     edx, [esp+2Ch+lParam]
mov     eax, esi
call    sub_442A90
</code></pre>
<h4><a name="p-54372-player-information-3" class="anchor" href="https://d.clarkee.co.uk#p-54372-player-information-3"></a>Player information</h4>
<p>Our ignorance of the structure stored within memory puts us at a disadvantage.<br>
In order to find where <em>Health is mainly stored</em>, I’ll be using <em>Cheat Engine</em> with the assumption that it is a <em>DWORD</em>(<em>4 bytes</em>): <em>“\x64\x00\x00\x00”</em>.<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://jOn5cBjBqC8uTeBqUWpc3rhDKVi.png" width="547" height="136"><br>
I’ll then proceed to get the <em>character damaged</em>, and <em>‘Next Scan’</em> for the <em>new value</em>.<br>
We end up with <strong>5</strong> different <em>pointers</em>.<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://hhNXPKhmsP9io4RoGThDkw28l87.png" width="546" height="136"><br>
The <strong>last one</strong> is of a <em>black color</em>, meaning that it is a <em>dynamic address</em>, modifying it doesn’t result in any <strong>observable change</strong>.<br>
Others are clearly static, modifying <em>3/4</em> of them leads to <em>restoring the original value</em>, which meant that the <em>1/4</em> left is <strong>the parent</strong>, and the <em>rest just copy its value</em>.<br>
<strong>00482538</strong>: Health that appear on the screen.<br>
<strong>03682944</strong>: A promising address because it is <em>not updated with the parent</em>.<br>
<em>Health</em> is stored in <em>two different locations</em>, which means one is <em>nothing but a decoy</em>.<br>
<br>
I set the <em>first one’s value to <strong>1</strong></em>, and then got <em>attacked by a monster</em>.<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://b7SDPdPSwcu9qK8BLMwdjl88hdj.png" width="576" height="141"><br>
The result is:<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://9tygzy6nlXGgmv2QsWEWYik4z1g.png" width="412" height="35"><br>
The value that <em>appears on the screen hangs at 0</em>, and the <em>character doesn’t die</em>.<br>
While the second kept <em>decreasing on each attack</em>, meaning that it effectively held <em>the real value</em>.<br>
We need to <em>inspect the memory region</em> by selecting the value and clicking <em>CTRL+B</em>.<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://n2LQxLywl9WNF0JQoZWVNhglWU5.png" width="353" height="370"><br>
We can change the <em>Display Type</em> from <strong>Byte hex</strong> to <strong>4 Byte hex</strong>.<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://jS17zXcRgKCeXvP3oZZx1hIqvqG.png" width="588" height="53"><br>
--<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://bv2I6XTXgFbzoVBcKZnsSMmd8QG.png" width="377" height="176"><br>
--<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://bX3uqJ05AqeDPUGMSiLEOd4olvD.png" width="589" height="52"><br>
This is easier to work with, I <em>started searching</em> for the <strong>closest pointer</strong> in a <em>limited range</em>, and it turned out to be <strong>3682A24</strong>.<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://29KWiJMKbPAAHAVlnRHw9fkVNJA.png" width="426" height="103"><br>
We then <em>goto address</em> to see its content:<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://1SAx2Bo9VaO7aNnSVPiyfPHELAZ.png" width="431" height="105"><br>
Notice that the <em>Object’s health is empty</em>, and that <em>the struct</em> holds a <strong>Backward and Forward link</strong> at <em>its start</em>.</p>
<h4><a name="p-54372-a-spark-4" class="anchor" href="https://d.clarkee.co.uk#p-54372-a-spark-4"></a>A spark</h4>
<p>The idea that saved me a lot of time!<br>
<em><a href="https://doomwiki.org/wiki/Doom_cheat_codes" rel="noopener nofollow ugc">CHEAT CODES</a></em>, I was both happy and shocked to find out that they really existed!</p>
<p><em>DOOMWiki</em> includes messages that appear on detection of each message.<br>
Two commands were exceptional because of the information they manipulate.</p>
<p><img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://AswH77cRyKBwfEHnPDtLbhp4Pd5.png" width="690" height="26"><br>
--<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://2r4cv32Dx1qxUcuDO1t8yTCStfn.png" width="690" height="46"></p>
<p>The magical keywords: <em>“ang=” and “BY REQUEST…”</em>.<br>
The first one’s usage occurs in:</p>
<pre data-code-wrap="bash"><code class="lang-bash">loc_432776:
mov     eax, offset off_4669BC
movsx   edx, byte ptr [ebp+4]
call    sub_414E50
test    eax, eax
jz      short loc_4327D4
mov     edx, ds:dword_482A7C
lea     eax, ds:0[edx*8]
add     eax, edx
lea     eax, ds:0[eax*4]
sub     eax, edx
mov     eax, ds:dword_482518[eax*8]
mov     ebx, [eax+10h]
push    ebx
mov     ecx, [eax+0Ch]
push    ecx
mov     esi, [eax+20h]
push    esi
push    offset aAng0xXXY0xX0xX ; "ang=0x%x;x,y=(0x%x,0x%x)"
push    offset unk_5F2758
call    sprintf_
</code></pre>
<p>This is important and worthy to be added to our <em>CE Table</em>.<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://tuu3VYDpy6AO94R9Z60WOuyzHWb.png" width="434" height="36"><br>
A struct layout is also to be concluded:<br>
<strong>@)</strong> +0x10: y<br>
<strong>@)</strong> + 0xC: x<br>
<strong>@)</strong> +0x20: angle<br>
I immediately noticed the missing <em>Z coordinate</em>.<br>
I knew it existed, I mean, there’s stairs. (Hey, don’t laugh! <img src="https://d.clarkee.co.uk/images/emoji/twitter/frowning.png?v=15" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20">)<br>
I ended up realizing that it is at <em>+0x14</em> after a few tests. (Up and down we go.)<br>
<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="DCoords" data-orig-src="upload://yMVc9VinW9pWVKV9TId1KQMMKye.png" width="217" height="235"><br>
<br>
I knew that even if the enemy is on a different altitude: The shot still hits, and so I ignored Z.<br>
X, Y and Angle on the other hand are majorly important because of <em>distance calculation</em> and <em>angle measurement</em>.<br>
The values they <em>held look weird</em>, are <em>they floats</em>?<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://r7bMTq6GxGzE8b6FEOLRAXsLPfe.png" width="448" height="98"><br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://4MqpujagAUzJBxQdAr3nBERf6Vd.png" width="478" height="20"><br>
No, doesn’t look like it. All I knew for now is that the <em>view changes upon modification</em>.</p>
<p>Moving on to the second:</p>
<pre data-code-wrap="asm"><code class="lang-asm">loc_432533:
mov     eax, offset off_466898
movsx   edx, byte ptr [ebp+4]
call    sub_414E50
test    eax, eax
jz      short loc_43255E
mov     eax, ds:dword_5F274C
mov     dword ptr [eax+0D8h], offset aByRequest___ ; "By request..."
call    sub_420C50
jmp     loc_4326BA
</code></pre>
<p>We can see that it only passes execution to <em>sub_420C50</em>, and that’s where the magic happens.</p>
<pre data-code-wrap="bash"><code class="lang-bash">sub_420C50 proc near
push    ebx
push    ecx
push    edx
push    esi
mov     esi, ds:dword_484CFC
cmp     esi, offset dword_484CF8
jz      short loc_420C92
loc_420C62:
cmp     dword ptr [esi+8], offset sub_4250D0
jnz     short loc_420C87
test    byte ptr [esi+6Ah], 40h
jz      short loc_420C87
cmp     dword ptr [esi+6Ch], 0
jle     short loc_420C87
mov     ecx, 2710h
mov     eax, esi
xor     ebx, ebx
xor     edx, edx
call    sub_422370
loc_420C87:
mov     esi, [esi+4]
cmp     esi, offset dword_484CF8
jnz     short loc_420C62
loc_420C92:
pop     esi
pop     edx
pop     ecx
pop     ebx
retn
sub_420C50 endp
</code></pre>
<p>We can see that it traverses a <em>list of Objects</em>, starting with <strong>[484CFC]</strong> and ending if the <em>Forward link(+4)</em> <em>equals</em> <strong>484CF8</strong>.<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://oDUbsNrnDnTNWLGOoUwTvch2kK0.png" width="445" height="34"><br>
The inclusion of <strong>Player Object</strong> in <em>the list</em> indicates that it contains <em>all available</em> <strong>Entities</strong>.<br>
The three checks there are:<br>
<em>[Entity + 0x08] == 0x4250D0<br>
[Entity + 0x6A] &amp; 0x40<br>
[Entity + 0x6C] &gt; 0</em><br>
I was curious on what the <strong>Player Object</strong> held at those <em>Offsets</em>:<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://5gdWwwKTdVikWgBGUiWKFuGOaDx.png" width="434" height="50"><br>
<strong>@)</strong> + 0x8: <em>Function pointer(Pass)</em>.<br>
<strong>@)</strong> +0x6A: <em>Byte(Error)</em>, <em>seems like IsMonster check</em>.<br>
<strong>@)</strong> +0x6C: <em>Health(Pass)</em>.</p>
<h4><a name="p-54372-a-small-mistake-5" class="anchor" href="https://d.clarkee.co.uk#p-54372-a-small-mistake-5"></a>A small mistake</h4>
<p>“Did anyone do this before?”, I wondered.<br>
So I searched for:</p>
<blockquote>
<p>intext:“ang=0x%x;x,y=(0x%x,0x%x)” doom</p>
</blockquote>
<p>And well, I found out that the <em>source code was available</em>. <img src="https://d.clarkee.co.uk/images/emoji/twitter/joy.png?v=15" title=":joy:" class="emoji" alt=":joy:" loading="lazy" width="20" height="20"><br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://oXgIhN7IH09d1M4WeLdnsodp7Cx.png" width="582" height="98"><br>
At first <em>I was mad</em>, because I spent about <em>3 to 4 days to get the results previously stated</em>. But, hey! I <em>needed more information anyway</em>, and this was an <em>easy road showing up</em>.<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://dHf644NBUps5ieBj7kW372Z1Je3.png" width="278" height="78"><br>
--<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://ybrCODwvZyaJOs2ZmxeJuPnRoRK.png" width="245" height="144"><br>
--<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://vHHSK5HzoS3EnN34GJQ1Kr7n1Gn.png" width="204" height="41"><br>
So the structure we look for is defined in <em><a href="https://github.com/historicalsource/doom/blob/master/linuxdoom-1.10/d_player.h" rel="noopener nofollow ugc">d_player.h</a></em>, the <em>interesting element’s name</em> is <strong>mo</strong>.</p>
<pre data-code-wrap="c"><code class="lang-c">//
// Extended player object info: player_t
//
typedef struct player_s
{
    mobj_t*		mo;
...
</code></pre>
<p>Its nature is <em>mobj_t</em>, declared in <em><a href="https://github.com/historicalsource/doom/blob/master/linuxdoom-1.10/p_mobj.h" rel="noopener nofollow ugc">p_mobj.h</a></em>.</p>
<pre data-code-wrap="c"><code class="lang-c">// Map Object definition.
typedef struct mobj_s
{
    // List: thinker links.
    thinker_t		thinker;

    // Info for drawing: position.
    fixed_t		x;
    fixed_t		y;
    fixed_t		z;

    // More list: links in sector (if needed)
    struct mobj_s*	snext;
    struct mobj_s*	sprev;

    //More drawing info: to determine current sprite.
    angle_t		angle;	// orientation
...
</code></pre>
<p>The size of <em><a href="https://github.com/historicalsource/doom/blob/master/linuxdoom-1.10/d_think.h" rel="noopener nofollow ugc">thinker_t</a></em> is: <em>sizeof(PVOID) * 3</em> = 4 * 3 = <strong>12</strong>.<br>
Then comes <em>X, Y and Z</em> at <em>(0x0C, 0x10, 0x14)</em>.<br>
Two pointers <em><span class="mention">@0x18</span></em> are ignored(<em>4 * 2</em> = <strong>8</strong>).<br>
Angle is at <em>0x20</em>.</p>
<pre><code class="lang-auto">...
    int			health;

    // Movement direction, movement generation (zig-zagging).
    int			movedir;	// 0-7
    int			movecount;	// when 0, select a new dir

    // Thing being chased/attacked (or NULL),
    // also the originator for missiles.
    struct mobj_s*	target;
...
</code></pre>
<p>The target element is interesting, it supposedly holds a pointer to the <em>Map Object</em> being attacked!<br>
<em>Calculating its offset isn’t that hard</em>, because we know that <em>Health</em> is at <em>0x6C</em>.<br>
<em>FIELD_OFFSET(mobj_t, target)</em> = <em>0x6C + sizeof(int) * 3</em> = <strong>0x78</strong>.<br>
The following line in <em><a href="https://github.com/historicalsource/doom/blob/master/linuxdoom-1.10/r_local.h" rel="noopener nofollow ugc">r_local.h</a></em> indicates that there’s a <strong>lookup table/function</strong> for <em>Angles</em>, explaining why there’s <em>weird values therein</em>.</p>
<pre><code class="lang-auto">// Binary Angles, sine/cosine/atan lookups.
#include "tables.h"
</code></pre>
<p>It’s time to see what the <em>target</em> element holds for us!<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://ifAehZzIQSolfYLFpM5xIpX9v4R.png" width="239" height="270"><br>
Since I just started up the game, its value is <strong>NULL</strong>.<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://3eLWzimOdQrjafIazsCqWbbGUWe.png" width="496" height="17"><br>
<em>Attacking or getting attacked by a monster</em> leads to a <em>value change</em>.<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://2xa2QmgNzxJN1N9CBFGzhy6U4Pf.png" width="504" height="16"><br>
But there is no <em>update after killing the monster, hmmm</em>.<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://qDyCkdYcWX2bX9YzN5h0oiBWy5w.png" width="197" height="195"><br>
The <strong>health</strong> is the <em>only indicator of death if it is &lt;= 0</em>.<br>
And that’s <em>not the only problem</em>:<br>
<em>Attacking a second Monster doesn’t result in any change occuring</em>.<br>
Since I want it to be <em>regularly updated</em>, I had to <em>find a way around it</em>.<br>
I restarted <em>Doom95.exe</em>, selected the <em>Pointer to Player’s Target</em> and:<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://qVGF3JwoHwd3pkjxUw2USoMQJAF.png" width="562" height="176"><br>
--<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://i14OnO0rhb3BBhGG62hauOh1KOd.png" width="365" height="122"><br>
--<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://iP6YDDy81DU9khoKHLBpyVPDocj.png" width="341" height="126"><br>
--<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://jZYCS75mYllBnHZbdYpc7fZdiAp.png" width="407" height="427"><br>
We can now start fighting an enemy:<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://6UVtY6H9xaKBZFCwM7tgQ8F82SV.png" width="394" height="63"><br>
This is the instruction <em>responsible for writing to the Player’s Target element</em>.<br>
Going back a little in <em>disassembly window</em>, there are some <strong>simple checks</strong>:<br>
<em>Is the Target NULL? Is it equal to the Player itself?</em><br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://pEiQiylHENAW1Ye3LSwacAVngDA.png" width="456" height="151"><br>
The <em>origin of EBX register</em> is the <em>selected instruction</em>, and <em>its location is</em>: <strong>00422684</strong>.<br>
All I had to do is <em>find a location</em> where to place a <strong>JMP 422684</strong>.<br>
I ended up choosing <strong>0042264F</strong>:<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://seTB8qbvgQ4Uc2Ocjbrfj2AVdIm.png" width="446" height="242"><br>
--<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://bY60giAgoBmezhfbuDhUaKuN1xA.png" width="290" height="106"><br>
--<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://wHbpAsyIpFyZiEnksKs1GQ41AXN.png" width="424" height="15"><br>
The <em><strong>sequence of bytes</strong> turns from {0x7D, 0x1C} to {0xEB, 0x33}</em>, we aren’t <em>destroying any instructions after it</em>.<br>
Let’s now see if it <em>changes on each attack</em>:<br>
<strong>Monster <span class="hashtag-raw">#1:</span></strong><br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://6vzKIWFaYsdmfIj1mPIkDqZboGB.png" width="519" height="18"><br>
<strong>Monster <span class="hashtag-raw">#2:</span></strong><br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://uEv2BkqbWQF1UG33FQDAxRVciZK.png" width="521" height="18"><br>
<em>PERFECT!</em></p>
<h4><a name="p-54372-last-piece-of-the-puzzle-6" class="anchor" href="https://d.clarkee.co.uk#p-54372-last-piece-of-the-puzzle-6"></a>Last piece of the puzzle</h4>
<p>Monsters could <em>accurately aim at my character</em>.<br>
I knew a function responsible for <strong>angle measurement</strong> existed, <em>I just had to find it</em>.<br>
After a <em>few hours searching</em>, I ended up looking in <em><a href="https://github.com/historicalsource/doom/blob/master/linuxdoom-1.10/p_enemy.c" rel="noopener nofollow ugc">p_enemy.c</a></em>;</p>
<pre data-code-wrap="cpp"><code class="lang-cpp">boolean P_CheckMeleeRange (mobj_t*	actor)
{
    mobj_t*	pl;
    fixed_t	dist;
	
    if (!actor-&gt;target)
	return false;
		
    pl = actor-&gt;target;
    dist = P_AproxDistance (pl-&gt;x-actor-&gt;x, pl-&gt;y-actor-&gt;y);

    if (dist &gt;= MELEERANGE-20*FRACUNIT+pl-&gt;info-&gt;radius)
	return false;
	
    if (! P_CheckSight (actor, actor-&gt;target) )
	return false;
							
    return true;		
}
</code></pre>
<p>A collection of interesting functions!<br>
<em>P_AproxDistance()</em><br>
<em>P_CheckSight()</em><br>
And the most <strong>promising</strong> one:<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://vkxPq4qMs8lPbNqyrO67hLni9Uv.png" width="261" height="103"><br>
<em>R_PointToAngle2()</em>, and its <em><a href="https://github.com/id-Software/DOOM/blob/master/linuxdoom-1.10/r_main.c" rel="noopener nofollow ugc">definition</a></em> is <em>the following</em>:</p>
<pre data-code-wrap="cpp"><code class="lang-cpp">angle_t
R_PointToAngle2
( fixed_t	x1,
  fixed_t	y1,
  fixed_t	x2,
  fixed_t	y2 )
{	
    viewx = x1;
    viewy = y1;
    
    return R_PointToAngle (x2, y2);
}
</code></pre>
<p>I knew the <em>Player’s X, Y were read right before invokation</em>. I used this information to <em>trace the calls</em> and <em>watched for accesses</em>:<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://bKuFQZadhRtHg4j4msdnZYkXKtW.png" width="690" height="179"><br>
--<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://g4RnIuu5SiJ5yVR8hcLPuG2yiKk.png" width="406" height="426"><br>
Once a <em>monster aims at us</em>, we <strong>get results</strong>:<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://jkUWfogcaWDryCQJpGMISr9i7pn.png" width="368" height="500"><br>
I <em>started</em> with those with the <em>least hit-count at the middle</em>.<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://pIdj6xtr2mXFjPA6lzUOLcxP0ek.png" width="268" height="69"><br>
<em>The second one looks like the thing we’re looking for!</em><br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://7rpj2BhBRF00MNFJ8EPPasWLVx4.png" width="167" height="90"><br>
It prepares to call <strong>0042DB10</strong> by loading the <em>Target</em> in <em>EAX</em> and storing its <em>(X, Y) coordinates</em> in <em>EBX and ECX</em>, while <em>EAX and EDX</em> hold <em>those of the monster</em>.<br>
<em>We can deduce that it is a __fastcall.</em><br>
<strong>Disassembling</strong> the function <em>shows</em>:<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://8KIIcQ2qpEtqA5vNpwMcRgwMGcT.png" width="495" height="181"><br>
<em>Looks familiar!</em><br>
<em>It is R_PointToAngle2() @ <strong>0042DB10</strong> <img src="https://d.clarkee.co.uk/images/emoji/twitter/slight_smile.png?v=15" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20">!</em><br>
With that in <em>mind, locating this function is made easier</em>.</p>
<pre data-code-wrap="cpp"><code class="lang-cpp">//
// A_FaceTarget
//
void A_FaceTarget (mobj_t* actor)
{	
    if (!actor-&gt;target)
	return;
    
    actor-&gt;flags &amp;= ~MF_AMBUSH;
	
    actor-&gt;angle = R_PointToAngle2 (actor-&gt;x,
				    actor-&gt;y,
				    actor-&gt;target-&gt;x,
				    actor-&gt;target-&gt;y);
    
    if (actor-&gt;target-&gt;flags &amp; MF_SHADOW)
	actor-&gt;angle += (P_Random()-P_Random())&lt;&lt;21;
}
</code></pre>
<p>I’ll just use <em>IDA</em>.<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://b4JuU96bk5LltnYyiU0nyIrw7Dz.png" width="315" height="95"><br>
--<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://wLnsf5SAqEg7kME3uvwaAZmjMGl.png" width="349" height="144"><br>
--<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://oOJliovdZUrItGnJS2vGynk9Tmf.png" width="518" height="240"><br>
Looks like it, <em>it starts by returning if Target is <strong>NULL</strong></em>, then <em>AND</em>s [<em>Monster+0x68</em>] with <strong>0xDF</strong>. What’s sad, is that <em>I was looking at it since the beginning</em> in <strong>CE</strong>, welp <img src="https://d.clarkee.co.uk/images/emoji/twitter/joy.png?v=15" title=":joy:" class="emoji" alt=":joy:" loading="lazy" width="20" height="20">.<br>
<em>A_FaceTarget is at <strong>0041F670</strong></em>.</p>
<h4><a name="p-54372-the-making-7" class="anchor" href="https://d.clarkee.co.uk#p-54372-the-making-7"></a>The making</h4>
<p>All that <em>we’ve learned about the game</em> will allow us to start <em>wrapping things</em> in <em>C++</em>.<br>
Let’s create <em>ADoom.h</em>:</p>
<pre data-code-wrap="c"><code class="lang-c">#ifndef __ADOOM_H__
#define __ADOOM_H__

class ADoom {
public:
	ADoom(DWORD);
	~ADoom();
private:
	HANDLE	DH;
};

#endif
</code></pre>
<p>And <em>ADoom.c</em>:</p>
<pre data-code-wrap="c"><code class="lang-c">#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;stdexcept&gt;
#include &lt;tchar.h&gt;
#include &lt;Windows.h&gt;

#include "ADoom.h"

ADoom::ADoom(DWORD CPID)
{
	DH = OpenProcess(PROCESS_ALL_ACCESS, FALSE, CPID);

	if (DH != INVALID_HANDLE_VALUE)
	{
		return;
	}

	throw std::runtime_error("Can't open process!");
}

ADoom::~ADoom(){
	CloseHandle(DH);
}

int main()
{
	HWND	DoomWindow;
	DWORD	PID;

	DoomWindow = FindWindow(NULL, _T("Doom 95"));
	if (! DoomWindow) goto out;
	GetWindowThreadProcessId(DoomWindow, &amp;PID);

	try
	{
		ADoom	DAim(PID);
	} catch (const std::runtime_error &amp;err) { };

	while (1)
	{
		Sleep(1);
	}
	out:
	return 0;
}
</code></pre>
<p>I’ll create functions that <em>read(<strong>rM</strong>)/write(<strong>wM</strong>) to the process memory</em> by extending <em>both the header and source file</em>.<br>
We are going to use <em>two WINAPI calls for that purpose</em>: <strong>ReadProcessMemory()</strong> and <strong>WriteProcessMemory()</strong>.<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://6Z2etDBlJvvpT3aVS32SPriNUJP.png" width="255" height="152"> | | | | | <img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://x0fChMctZMlRuOwwZwSDLakufvK.png" width="282" height="159"><br>
--</p>
<pre><code class="lang-auto">	template&lt;typename ReadType&gt;
	ReadType rM(DWORD, DWORD);
	BOOL wM(DWORD, PVOID, SIZE_T);
</code></pre>
<p>--</p>
<pre data-code-wrap="c"><code class="lang-c">template&lt;typename ReadType&gt;
ReadType ADoom::rM(DWORD RAddress, DWORD Offset)
{
	ReadType Result;
	PVOID	 External = reinterpret_cast&lt;PVOID&gt;(RAddress + Offset);

	ReadProcessMemory(DH, External, &amp;Result, sizeof(Result), NULL);
	return Result;
}

BOOL ADoom::wM(DWORD RAddress, PVOID LAddress, SIZE_T Size)
{
	BOOL	Status = FALSE;
	PVOID	External = reinterpret_cast&lt;PVOID&gt;(RAddress);

	if (WriteProcessMemory(DH, External, LAddress, Size, NULL))
	{
		Status = TRUE;
	}
	
	return Status;
}
</code></pre>
<p><em>Let’s check if Player’s Object manipulation is possible</em>:</p>
<pre data-code-wrap="c"><code class="lang-c">	try
	{
		ADoom	DAim(PID);
		DWORD	Corrupt = 0x12345678, Player, PPlayer = 0x482518;

		Player = DAim.rM&lt;DWORD&gt;(PPlayer, 0);
		printf("Player Object @ %lX\n", Player);

		DAim.wM(PPlayer, &amp;Corrupt, sizeof(Corrupt));
		puts("Corrupted the Player Object.");
	} catch (const std::runtime_error &amp;err) { }
</code></pre>
<p>--<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://ly6c7GFsj6JaDEr7Tj1ZVXLWYQC.png" width="264" height="331"><br>
The <em><strong>Doom95.exe</strong> process crashes</em>, <em>success</em>.<br>
We have to <em>apply the <strong>2 byte</strong> patch and keep an eye</em> on the <strong>Player’s Target</strong> value.</p>
<pre><code class="lang-auto">	try
	{
		ADoom	DAim(PID);
		BYTE	Patch[2] = {0xEB, 0x33};
		DWORD	PAddress = 0x42264F;
		DWORD	Player, PPlayer = 0x482518;
		int		THealth;
		DWORD	OTarget = 0, Target;

		Player = DAim.rM&lt;DWORD&gt;(PPlayer, 0);
		printf("Player Object @ %lX\n", Player);

		printf("Applying Patch @ %lX\n", PAddress);
		DAim.wM(PAddress, &amp;Patch[0], sizeof(Patch));

		while (true)
		{
			Target = DAim.rM&lt;DWORD&gt;(Player, 0x78);

			// Are we currently engaging the enemy?
			if (Target != 0)
			{
				// If yes, is it already dead?
				THealth = DAim.rM&lt;int&gt;(Target, 0x6C);
				if (THealth &lt;= 0)
				{
					continue;
				}

				/*
					Uniqueness check.
				*/
				if (! OTarget || OTarget != Target)
				{
					printf("Current Target @ %lX\n", Target);
					OTarget = Target;
				}
			}
		}
	} catch (const std::runtime_error &amp;err) { }
</code></pre>
<p>--<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://lsQqFMUPgeeNOODEyAV4SiDnZ62.png" width="207" height="91"><br>
<em>So far so good, we are making progress.</em><br>
At first, I totally forgot about the <strong>Health check</strong>, and <em>it kept aiming at the dead Monster</em>.<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="dead" data-orig-src="upload://jON6o5PLmVhEEy7vMTFJ0rOQXyJ.gif" width="220" height="167"><br>
It is time to use our knowledge about <em>A_FaceTarget(<strong>0041F670</strong>)</em>.<br>
It takes an <em>mobj_t *</em> argument in <strong>EAX</strong>, and <em>performs a single check</em>(<em>EAX-&gt;target != NULL</em>) before <em>calculating and storing the correct angle</em>, this is a <em>minimum of work on our side</em>.<br>
All is left to do, is creating a <strong>reliable function</strong> and <em>storing/running</em> it in the <em>remote thread</em>.</p>
<pre data-code-wrap="c"><code class="lang-c">VOID _declspec(naked) Reliable(VOID)
{
	__asm {
		mov eax, 0x482518 // Load PPlayer in EAX
		mov eax, [eax]    // Load Player Object in EAX
		mov edi, 0x41F670 // Indicate the FP(A_FaceTarget)
		call edi          // Call it
		ret
	}
}
</code></pre>
<p>We can <em>compile the executable and load it up in IDA</em>.<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://jXTC4USdmpZg5xgnBm5eZCiKXKY.png" width="240" height="227"><br>
--<br>
<em><strong>Hex-view</strong> is synchronized with <strong>Disassembly-view</strong>, so selecting the first ‘mov’ is all we have to do.</em><br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://g2kdHxZUqFXI7UJ9tHLlmoR7B6F.png" width="609" height="46"><br>
That is <em>our function</em>!</p>
<pre data-code-wrap="c"><code class="lang-c">BYTE Payload[] = {0xB8, 0x18, 0x25, 0x48, 0x00, 0x8B, 0x00,
				  0xBF, 0x70, 0xF6, 0x41, 0x00, 0xFF, 0xD7,
				  0xC3};
DWORD PSize = sizeof(Payload);
</code></pre>
<p>With that done, <em>we need a location to write it to</em>, it needs to be <em>Executable/Readable and Writeable too</em>.<br>
In order to get it, we will call <strong>VirtualAllocEx()</strong>.<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://od9JLxuLm4q7I9SJxPMZpzGMYDv.png" width="228" height="157"><br>
We have to specify <em>flProtect</em> as <em>PAGE_EXECUTE_READWRITE</em>.<br>
Another <em>helper function</em> will be called <strong>aM</strong> short for <em>allocate Memory</em>. <img src="https://d.clarkee.co.uk/images/emoji/twitter/slight_smile.png?v=15" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
<pre data-code-wrap="c"><code class="lang-c">DWORD aM(SIZE_T);
</code></pre>
<p>--</p>
<pre data-code-wrap="c"><code class="lang-c">DWORD ADoom::aM(SIZE_T Size)
{
	LPVOID RAddress = VirtualAllocEx(DH, NULL, Size, MEM_COMMIT | MEM_RESERVE,
					  PAGE_EXECUTE_READWRITE);
	DWORD  Cast = reinterpret_cast&lt;DWORD&gt;(RAddress);

	return Cast;
}
</code></pre>
<p>And then there should be a <em>function to spawn a Thread</em> in <em>Doom95.exe process</em>.<br>
We’ll be using <strong>CreateRemoteThread()</strong>, and <em>wait for it to terminate</em> using <strong>WaitForSingleObject()</strong>.<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://ebiICrKofvYkdCrHOasHhs5ivCb.png" width="350" height="181"> | | <img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://ti7Dc5gUNTnnWzbUY4a5fzX831.png" width="220" height="100"><br>
It’ll be called <strong>sT</strong>.</p>
<pre><code class="lang-auto">VOID sT(DWORD);
</code></pre>
<p>--</p>
<pre data-code-wrap="cpp"><code class="lang-cpp">VOID ADoom::sT(DWORD FPtr)
{
	HANDLE RT;

	RT = CreateRemoteThread(DH, NULL, 0, (LPTHREAD_START_ROUTINE) FPtr,
		 NULL, 0, NULL);

	if (RT != INVALID_HANDLE_VALUE)
	{
		WaitForSingleObject(RT, INFINITE);
	}
}
</code></pre>
<p>That’s all we need, <em>now we can implement the whole loop</em>:</p>
<pre><code class="lang-auto">	try
	{
		ADoom	DAim(PID);
		BYTE	Patch[2] = {0xEB, 0x33};
		DWORD	PAddress = 0x42264F;
		BYTE	Payload[] = {0xB8, 0x18, 0x25, 0x48, 0x00, 0x8B, 0x00,
							 0xBF, 0x70, 0xF6, 0x41, 0x00, 0xFF, 0xD7,
							 0xC3};
		DWORD	Location, PSize = sizeof(Payload);
		DWORD	PPlayer = 0x482518, Player, Target;
		int		THealth;

		/*
			Patch:
			An unconditional JMP instruction that allows Player-&gt;target
			to be updated on every attack.
		*/
		printf("Applying Patch @ %lX\n", PAddress);
		DAim.wM(PAddress, Patch, sizeof(Patch));

		printf("Allocating Memory(%d)\n", PSize);
		Location = DAim.aM(PSize);

		printf("Storing Function @ %lX\n", Location);
		DAim.wM(Location, Payload, PSize);

		puts("[0x00sec] Aimbot starting.");

		while (TRUE)
		{
			Player = DAim.rM&lt;DWORD&gt;(PPlayer, 0);
			Target = DAim.rM&lt;DWORD&gt;(Player, 0x78);

			// Did any enemy attack us?
			if (Target != 0)
			{
				// If yes, is it still alive?
				THealth = DAim.rM&lt;int&gt;(Target, 0x6C);
				if (THealth &gt; 0)
				{
					// Aim at it.
					DAim.sT(Location);
				}
			}
		}
	} catch (const std::runtime_error &amp;err) { }
</code></pre>
<p>--<br>
<img src="https://d.clarkee.co.uk/images/transparent.png" alt="image" data-orig-src="upload://qFQInlJJkzFdgAhszIE640shduk.png" width="225" height="79"><br>
And it works! <img src="https://d.clarkee.co.uk/images/emoji/twitter/smiley.png?v=15" title=":smiley:" class="emoji" alt=":smiley:" loading="lazy" width="20" height="20"></p>
<h4><a name="p-54372-end-8" class="anchor" href="https://d.clarkee.co.uk#p-54372-end-8"></a>End</h4>
<p>It took many attempts to get to the final product, but it certainly was fun!<br>
I could not include <em>pictures or GIFs from the game because I didn’t find a way to do it</em>, for that, I apologize.<br>
Lots of modifications were made to guarantee <em>reliability</em>, an example would be <em>the Player object</em> is updated on <em>two events</em>: <strong>Death</strong>/<strong>Level Change</strong>.<br>
And I also <em>got rid of some functions such as</em>:</p>
<pre><code class="lang-auto">VOID GetMonsters(vector&lt;DWORD&gt; *M, HANDLE Proc)
{
	DWORD	First = 0x484CFC, Last = 0x484CF8;
	int		MHealth;
	UCHAR	IsMonster;

	First = rM&lt;DWORD&gt;(First, Proc);
	Last = rM&lt;DWORD&gt;(Last, Proc);
	
	do {
		IsMonster = rM&lt;UCHAR&gt;(First + 0x6A, Proc);
		MHealth = rM&lt;int&gt;(First + 0x6C, Proc);

		// Is it a monster and is it alive?
		if ((IsMonster &amp; 0x40) &amp;&amp; (MHealth &gt; 0))
		{
			M-&gt;push_back(First);
		}
	} while ((First = rM&lt;DWORD&gt;(First + 4, Proc)) != Last);
}
</code></pre>
<p><em>I didn’t even need to include &lt;cmath&gt; in the end!</em><br>
<strong>NIAHAHAHA!</strong><br>
~ exploit</p>
          <p><a href="https://d.clarkee.co.uk/t/doom95-making-an-aimbot/19862/1">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/doom95-making-an-aimbot/19862/1</link>
        <pubDate>Mon, 16 Mar 2020 20:50:35 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-19862-1</guid>
        <source url="https://d.clarkee.co.uk/t/doom95-making-an-aimbot/19862.rss">DOOM95 | Making an aimbot</source>
      </item>
  </channel>
</rss>
