<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>IBI Crypter. A JIT Crypter PoC</title>
    <link>https://0x00sec.org/t/ibi-crypter-a-jit-crypter-poc/1373</link>
    <description>Yesterday, I joined the 0x00sec IRC channel and, as many other times, @dtm come up with an interesting concept... and I had to try. The idea was pretty challenging and I have not completely come up with a full implementation but I manage to get a minimal Proof of Concept program to illustrate the concept and, maybe, to be used as a starting point for other people more interested in the topic than me.

# The IBI Crypter
Sure, we were talking about crypters and I named mine IBI crypter. IBI stands for _Instruction by Instruction_ Crypter, and that is the concept. Instead of decrypting the whole application at once or even a block, this crypter tries to decrypt just the instruction that has to be executed at any time. After running that instruction, the code is immediately crypted again so a live memory dump of the process will still be encrypted. This is why I&#39;m referring to this concept as a __JIT__ (_Just in Time_) crypter.

During our discussion we realised that the problem is not trivial, and I have to admit that it is more challenging that I initially expected. I&#39;ll let you know about the issues at the end of this paper.

Before diving into the code, let me explain you how the crypter works.

# An Embedded Debugger
The idea is pretty simple. We start with a program with some crypted sections. The program starts tracing itself and sets a break point at the first function to run. Once that function is executed, the program execution will stop and the embedded debugger will take control. Then it will decrypt the next instruction to run and, after that, it will execute that instruction.

Once the instruction is executed, the debugger will take control again of the process, it will crypt again the instruction just executed and repeat the process until the code is completely executed.

The concept is pretty simple but the implementation is not that trivial as we will see in a while.

To follow the rest of the paper, it may be useful for you to also read this other text:

https://0x00sec.org/t/linux-infecting-running-processes/1097

# Breakpoints on Intel Processors
As we already know how to trace a program and access its memory and registers (yes, you should read the link I have just mentioned), we only need to know how to set a break point. Again the concept itself is pretty simple, at least for the traditional way of setting breakpoints.

Breakpoints make use of the processor instruction `int 3` (opcode 0xcc). This is a 1 byte processor instruction and stops the current processor execution and runs some code defined by us. So, the process to set a break point is as follows:

* Store the content at the memory address where we want to set our break point.
* Write the `int 3` instruction in that address.
* Run the program

Whenever the program reaches the `int 3` instruction, the program will stop at that point and our code will take control and it can do whatever it needs to do, in our case, decrypt the code to execute. 


Once we are done, we have to do a couple more things to restore the execution of the original program:

* Copy back the original byte (the one we stored when we set the break point) in their original position.
* Decrease the `IP` (Instruction Pointer). As you know, the `IP` always points to the next instruction to be executed. In this case, this is the address of our breakpoint plus 1 (the size of the `int 3` instruction). We want to decrease it in order to run the original instruction (that we broke injecting the `int 3` opcode).
* Give control back to the original process, or ask the process to just run the next instruction.

Overall the concept is pretty straightforward. 

# SingleStep Execution
Fortunately for us, the `ptrace` interface offer a function to execute a single instruction, Otherwise we would have to add some code to figure out the size of the current instruction (it can be 1 to 15 bytes), in order to know where to set up our next breakpoint.

The `ptrace` `PTRACE_SINGLESTEP` will do that for us. It will just run one instruction and give us control back. This is actually the last piece of the puzzle to build our simple proof of concept.

Let&#39;s look into it.

# The Proof of Concept
We have chosen to illustrate the technique a very basic application to check the validity of a user provided code. The function that does the check will be crypted (and only that function) and it will be executed using the awesome IBI Crypter :P.

Let&#39;s start with the main program and our check function. We have call it `target.c`

```
#include &lt;stdio.h&gt;
#include &quot;stub.h&quot;

#define CRYPT_ME __attribute__((section(&quot;.secure&quot;)))

// This function is crypted
CRYPT_ME int
check_key (unsigned char *str)
{
  int  i;
  unsigned char  *p = str;

  while (*p) {*p -= &#39;0&#39;; p++;};
  if (str[0] + str[1] != 5) return 1;
  if (str[2] * str[3] != 10) return 1;
  return 0;
}


int
main (int argc, char*argv[])
{
  _stub (check_key); // Setup run environment
  printf (&quot;Code is %s\n&quot;, check_key (argv[1]) ? &quot;INCORRECT&quot;: &quot;CORRECT&quot;);
}

```

As you can see, the `check_key` function in the code above, do a couple of stupid checks on the key it receives as parameter, and returns 0 if the key is valid or 1 otherwise. The main function is also pretty simple. It first runs our `_stub` and then just prints `CORRECT` or `INCORRECT` based on the result of the `check_key` function.

To off-line crypter  I will be using is the same described in the paper:

https://0x00sec.org/t/a-simple-linux-crypter/537

We are pushing the functions to _secure_ into a separated section for easy identification (see `CRYPT_ME` macro). Then we XOR  it, as described in the paper I have just mentioned. 

The interesting stuff is in the `_stub` function. Let&#39;s look at it

# The `_stub` Function
The `_stub` function has two main parts. First, we set up a breakpoint in the crypted function we want to run (`check_key` in this case). Once we get there, we will start stepping over the function instruction by instruction.

Let&#39;s go with the breakpoint

```
int
_stub (void *ep)
{
  void                    *bp_ip;
  long                    ip1, op1, op2;
  struct user_regs_struct regs;
  int                     status, cnt;

  printf (&quot;%s&quot;, &quot;0x00pf IbI Crypter Stub\n&quot;);

  // Start debugging!!!
  if ((_pid = fork ()) &lt; 0) PERROR(&quot;fork:&quot;);

  if (_pid == 0) return 0;  // Child process just keeps running
  else
    {
      // Father starts debugging child
      if ((ptrace (PTRACE_ATTACH, _pid, NULL, NULL)) &lt; 0) PERROR (&quot;ptrace_attach:&quot;);
      printf (&quot;%s&quot;, &quot;+ Waiting for process...\n&quot;);
      wait (&amp;status);

      bp_ip = ep;

      // Set breakpoint at get there...
      op1 = ptrace (PTRACE_PEEKTEXT, _pid, bp_ip);
      DPRINTF(&quot;BP: %p 1 Opcode: %lx\n&quot;, bp_ip, op1);
      if (ptrace (PTRACE_POKETEXT, _pid, bp_ip, 
		  (op1 &amp; 0xFFFFFFFFFFFFFF00) | 0xcc) &lt; 0) PERROR (&quot;ptrace_poke:&quot;);

      // Run until breakpoint is reached.
      if (ptrace (PTRACE_CONT, _pid, 0, 0) &lt; 0) PERROR(&quot;ptrace_cont:&quot;);
      wait (&amp;status);
      
      ptrace (PTRACE_GETREGS, _pid, 0, &amp;regs);
      DPRINTF (&quot;Breakpoint reached: RIP: %llx\n&quot;, regs.rip);
      regs.rip--;
      ptrace (PTRACE_SETREGS, _pid, 0, &amp;regs);

      // REstore opcode
      ptrace (PTRACE_POKETEXT, _pid, bp_ip, op1);

```

Hope the code is easy to understand. It creates a new process and starts debugging it. Immediately we set the breakpoint (opcode `0xcc`) in the address received as parameter, that in our case is the `check_key` function (check the `main` function above).

Once the break point is set, we just let the program run using the `PTRACE_CONT` and we just wait for the program to hit the break point... i.e. we wait until the function we want to decrypt gets executed.

The program will eventually call the `check_key` function (that is actually the next line in the `main` function) and the `_stub` code will take control back. Then we have to get the `IP` register, decreased in one byte (as explained above), set the register value back and also restore the opcode where the `int3` was inserted.

Time to run the function.

# Decrypting, Running, Encoding and again
At this point we have stopped the application just at the beginning of the `check_key` function and in order to continue the execution we have to decrypt it as we go.

This is the code that does the trick

```
     // Start step by step debugging
      ip1 = (long) ep;
      cnt = 0;
      while (WIFSTOPPED (status))
	{
	  cnt ++;
	  // Read up to 16 bytes to get the longest instruction possible
	  // Decode and write back the decoded code to execute it
	  op1 = ptrace (PTRACE_PEEKTEXT, _pid, ip1);
	  op2 = ptrace (PTRACE_PEEKTEXT, _pid, ip1 + 8);
	  DPRINTF (&quot;%lx :: OPCODES : %lx %lx\n&quot;, ip1, op1, op2);
	  
	  XOR(op1);
	  XOR(op2);

	  DPRINTF (&quot;%lx :: DOPCODES: %lx %lx\n&quot;, ip1, op1, op2);

	  ptrace (PTRACE_POKETEXT, _pid, ip1, op1);
	  ptrace (PTRACE_POKETEXT, _pid, ip1 + 8, op2);

	  /* Make the child execute another instruction */
	  if (ptrace(PTRACE_SINGLESTEP, _pid, 0, 0) &lt; 0) PERROR (&quot;ptrace_singlestep:&quot;);
	  wait(&amp;status);
	  
	  // Re-encode the instruction just executed so we do not have
	  // to count how many bytes got executed
	  XOR(op1);
	  XOR(op2);

	  ptrace (PTRACE_POKETEXT, _pid, ip1, op1);
	  ptrace (PTRACE_POKETEXT, _pid, ip1 + 8, op2);

	  // Get the new IP
	  ptrace (PTRACE_GETREGS, _pid, 0, &amp;regs);
	  ip1 = regs.rip;

	  // If code is outside .secure section we stop debugging 
	  if ((void*)ip1 &lt; secure_ptr || (void*)ip1 &gt; secure_ptr + secure_len)
	    {
	      printf (&quot;Leaving .secure section... %d instructions executed\n&quot;, cnt);
	      break;
	    }
	}

      ptrace (PTRACE_CONT, _pid, 0, 0);
      wait (&amp;status);      
    }

  printf (&quot;DONE\n&quot;);
  exit (1);
}
```

The function is a bit verbose but conceptually very simple. The `XOR` macro just applies the XOR encoding to a `long` (8 bytes) with a predefined key. You can check the details in the full source code (check at the end). At this point, it is not relevant.

If we check the format of the Intel opcodes, you will find out that a instruction, for a 64bits architecture may take up to 15 bytes. As we do not know (and we do not really want to know) anything about the next instruction to run, or in other words, we do not want to decode the opcodes ourselves in the code, then we have to decrypt up to 16 bytes to cover the longest possible opcode. Yes, in general, at a given time there are more than 1 single instruction decoded in memoru.

This is why we do two `PTRACE_PEEK`s to read the current address and that address plus 8 bytes (longs are 8 bytes long). Once we have read the 16 bytes that contains the next instruction to run, we just decrypt it applying our `XOR` macro, and we update the memory using `PTRACE_POKE` so, the next program instruction is now correct.

At this point we can just run the next instruction using `PTRACE_SINGLESTEP` and wait until the instruction is executed and control gets back to us.

Then we just need to encode again the 16 bytes of memory we decoded. This is not just to keep the program encrypted most of the time, but also to avoid some tricky logic to keep at least 16 bytes decoded in the memory program.

The final check in the `while` loop checks if the current `IP` is still in the `.secure` section of it has moved into other executable section... more on this at the end of the text.

# Testing 
Testing the program is not that straightforward. For the time being we have to do some manual tasks to make it work. It is not hard to fully automatise the process so I leave it as an exercise to you :P

First we have to compile the target program:

    $ gcc -o target target.c stub.c

Then we have to crypt the `.secure` section, using the `crypter_rt` tool (provided with the code).

`$ ./crypter_rt target`

Finally we need to manually fix the section information in `stub.c` and redo the process. To get the information `stub` needs about the section just run this command:

    $ readelf -S target | grep secure
      [14] .secure           PROGBITS         0000000000400e22  00000e22

The two last number in this line has to go to the variables `secure_ptr` and `secure_len` in `stub.c`. This information is used to figure out when the execution leaves the secure section and matches not crypted code.

Recompile and rebuild and you should be able to run the program like this:

    $ ./target 1425
    0x00pf B3Crypt Stub (Byte By Byte)
    + Waiting for process...
    Leaving .secure section... 74 instructions executed
    Code is CORRECT
    DONE
     ./target 1426
    0x00pf B3Crypt Stub (Byte By Byte)
    + Waiting for process...
    Leaving .secure section... 75 instructions executed
    Code is INCORRECT
    DONE

# The Tricky part
This example is very simple on purpose. Making a usable version will require some effort and I do not really have a need for this tool so I do not think I will go further on this implementation. However these are a couple of things to do, in order to extend this PoC into a usable tool

* The first thing to do is to extend the `stub` to access the ELF header and get the information associated to the `.secure` section, so you do not need to update the source code to re-compile
* Second is more tricky. You have to detect jumps/calls to functions outside the `.secure` section, as for instance the standard C library (have you seen a single `printf` in the `check_key` function ?). In those cases we have to set a break point just after the call in order to run the function without decoding it (those functions are not encoded) and to restart the decoding when the function returns... The last check in the function may give you some hints on how to proceed.
* I haven&#39;t extensively tested the program. I just made it work on my machine, it is not optimised and it may have some timing issues.
* This only works on 64bits platforms... should be easy to make it work on 32bits... but in any case it is x86 specific. For ARM or MIPS you need to figure out how to set breakpoints.

Well, this is it. I think this proves the concept is feasible and it is up to you to make it work. I see this more as a SW protection mechanism than as a malware development technique... WTF... they are the same thing :stuck_out_tongue: 

As usual you can get the complete source code from my github repo

https://github.com/0x00pf/0x00sec_code/tree/master/ibi_crypter

Any comment is welcomed</description>
    
    <lastBuildDate>Tue, 26 Dec 2017 23:17:12 +0000</lastBuildDate>
    <category>Malware</category>
    <atom:link href="https://0x00sec.org/t/ibi-crypter-a-jit-crypter-poc/1373.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>IBI Crypter. A JIT Crypter PoC</title>
        <dc:creator><![CDATA[_py]]></dc:creator>
        <description><![CDATA[
            
          <p><a href="https://0x00sec.org/t/ibi-crypter-a-jit-crypter-poc/1373/11">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/ibi-crypter-a-jit-crypter-poc/1373/11</link>
        <pubDate>Tue, 26 Dec 2017 23:26:42 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1373-11</guid>
        <source url="https://0x00sec.org/t/ibi-crypter-a-jit-crypter-poc/1373.rss">IBI Crypter. A JIT Crypter PoC</source>
      </item>
      <item>
        <title>IBI Crypter. A JIT Crypter PoC</title>
        <dc:creator><![CDATA[FOX]]></dc:creator>
        <description><![CDATA[
            <p>Thank you for sharing , great post</p>
          <p><a href="https://0x00sec.org/t/ibi-crypter-a-jit-crypter-poc/1373/10">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/ibi-crypter-a-jit-crypter-poc/1373/10</link>
        <pubDate>Tue, 26 Dec 2017 23:17:12 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1373-10</guid>
        <source url="https://0x00sec.org/t/ibi-crypter-a-jit-crypter-poc/1373.rss">IBI Crypter. A JIT Crypter PoC</source>
      </item>
      <item>
        <title>IBI Crypter. A JIT Crypter PoC</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>No. It creates a process at the beginning and starts “debugging” it. Not sure if that can be avoided. After that is works like a normal debugger when you run the program step by step, but decrypting the next 16 bytes (starting at current <code>RIP</code> value) in memory before running each step and crypting them back once the instruction is executed.</p>
          <p><a href="https://0x00sec.org/t/ibi-crypter-a-jit-crypter-poc/1373/9">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/ibi-crypter-a-jit-crypter-poc/1373/9</link>
        <pubDate>Thu, 22 Dec 2016 22:10:51 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1373-9</guid>
        <source url="https://0x00sec.org/t/ibi-crypter-a-jit-crypter-poc/1373.rss">IBI Crypter. A JIT Crypter PoC</source>
      </item>
      <item>
        <title>IBI Crypter. A JIT Crypter PoC</title>
        <dc:creator><![CDATA[oaktree]]></dc:creator>
        <description><![CDATA[
            <p>One more thing:</p>
<p>Does this PoC make a new process for every 16 bytes? If so: Isn’t that costly? Is there a way around this?</p>
          <p><a href="https://0x00sec.org/t/ibi-crypter-a-jit-crypter-poc/1373/8">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/ibi-crypter-a-jit-crypter-poc/1373/8</link>
        <pubDate>Thu, 22 Dec 2016 21:35:45 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1373-8</guid>
        <source url="https://0x00sec.org/t/ibi-crypter-a-jit-crypter-poc/1373.rss">IBI Crypter. A JIT Crypter PoC</source>
      </item>
      <item>
        <title>IBI Crypter. A JIT Crypter PoC</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>Hey <a class="mention" href="https://0x00sec.org/u/fraq">@fraq</a>,</p>
<p>Thanks for reading and for the interesting comments.</p>
<p>First of all, let me say that this was just a PoC. I didn’t though much further, but we can do it now. So these are my first thoughts to kick off the discussion.</p>
<p>I do not think the search space is that small, but I haven’t checked it so I may be wrong. The set of instruction is limited, but for a CISC processor as intel it may be around a few thousands (opcode wise) that is probably more that the number of words many people use in their everyday communication (and it is definitely longer that the number of letters we use in a normal message). On top of that, many instructions have data (offsets to jump to, values to store in registers,…) that, I think, actually increases the search space.</p>
<p>Said that, I think we have to look at this within its context. This was intended to be used as a crypter. Normal crypters need a plain decrypting function (at least the first one, for a multi-level crypter) and they also need the key stored somewhere or at least a way to figure it out/generate it without a user entering it. The program has to run on its own. In this context we should compare to other crypters not to a general cryptographic algorithms.</p>
<p>If we move to the forensics side, one typical way to get the decoded <em>payload</em> (the program part that is crypted), is to run the program, let the decryption function do its job and then dump the memory. That way you do not have to care about the cryptography behind and you do not have to reverse a potentially heavily obfuscated stub. In that sense, this approach avoids such an analysis and, cryptographically wise, I do not see, at first glance, a big difference when compared to a classical crypter.</p>
<p>I cannot assess if this re-encoding approach makes a cryptoanalysis attack more successful. I cannot figure out how to perform it. Haven’t tried but in principle you cannot attach more than one debugger to a binary (that is a classical anti-debug technique), the fact that the crypter uses the debugger functions makes difficult a dynamic analysis, at least a traditional/straightforward one, or even checking the process memory to get the information required for a cryptoanalysis. There is probably a way but it might not be as easy as running the program step by step with <code>gdb</code>,</p>
<p>I hope I have properly understood your question (even when I’m aware I haven’t explicitly answer it) and that this text shows some light on the topic. I would be curious about knowing how could you implement the attack/analysis you mentioned. Just because I’m not an expert myself on cryptography and I cannot figure it out myself.</p>
          <p><a href="https://0x00sec.org/t/ibi-crypter-a-jit-crypter-poc/1373/7">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/ibi-crypter-a-jit-crypter-poc/1373/7</link>
        <pubDate>Thu, 22 Dec 2016 19:47:34 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1373-7</guid>
        <source url="https://0x00sec.org/t/ibi-crypter-a-jit-crypter-poc/1373.rss">IBI Crypter. A JIT Crypter PoC</source>
      </item>
      <item>
        <title>IBI Crypter. A JIT Crypter PoC</title>
        <dc:creator><![CDATA[fraq]]></dc:creator>
        <description><![CDATA[
            <p>I’m gonna have to read this like 4 more times to digest it, but I did have one concern.</p>
<p>There is a very limited set of instructions. This small vocabulary presents a very small search space for attacking the cipher text. Further, repeatedly encrypting and decrypting the same message (the instruction) over and over again makes the cipher increasingly vulnerable to attack. How do you manage the fact that there is such a small search space and that the cipher is used over and over to reencrypt the same few words?</p>
          <p><a href="https://0x00sec.org/t/ibi-crypter-a-jit-crypter-poc/1373/6">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/ibi-crypter-a-jit-crypter-poc/1373/6</link>
        <pubDate>Thu, 22 Dec 2016 18:20:48 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1373-6</guid>
        <source url="https://0x00sec.org/t/ibi-crypter-a-jit-crypter-poc/1373.rss">IBI Crypter. A JIT Crypter PoC</source>
      </item>
      <item>
        <title>IBI Crypter. A JIT Crypter PoC</title>
        <dc:creator><![CDATA[oaktree]]></dc:creator>
        <description><![CDATA[
            <p>This is going to take some serious re-reading. Great post, as usual… I wish I was there for the IRC brainstorming.</p>
          <p><a href="https://0x00sec.org/t/ibi-crypter-a-jit-crypter-poc/1373/5">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/ibi-crypter-a-jit-crypter-poc/1373/5</link>
        <pubDate>Thu, 22 Dec 2016 16:23:03 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1373-5</guid>
        <source url="https://0x00sec.org/t/ibi-crypter-a-jit-crypter-poc/1373.rss">IBI Crypter. A JIT Crypter PoC</source>
      </item>
      <item>
        <title>IBI Crypter. A JIT Crypter PoC</title>
        <dc:creator><![CDATA[pry0cc]]></dc:creator>
        <description><![CDATA[
            <p>Hell yea, getting jiggy with the jit.</p>
          <p><a href="https://0x00sec.org/t/ibi-crypter-a-jit-crypter-poc/1373/4">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/ibi-crypter-a-jit-crypter-poc/1373/4</link>
        <pubDate>Wed, 21 Dec 2016 17:41:12 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1373-4</guid>
        <source url="https://0x00sec.org/t/ibi-crypter-a-jit-crypter-poc/1373.rss">IBI Crypter. A JIT Crypter PoC</source>
      </item>
      <item>
        <title>IBI Crypter. A JIT Crypter PoC</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>Thanks <a class="mention" href="https://0x00sec.org/u/smartone">@SmartOne</a>.</p>
<p>All my code is GPL so anybody can use/modify/redistribute it. Be free to put it anywhere you want and modify it as you wish. Just, please, honour the GPL license and release publicly any modification you do to the code also as a GPL module. That’s it.</p>
          <p><a href="https://0x00sec.org/t/ibi-crypter-a-jit-crypter-poc/1373/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/ibi-crypter-a-jit-crypter-poc/1373/3</link>
        <pubDate>Wed, 21 Dec 2016 10:55:05 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1373-3</guid>
        <source url="https://0x00sec.org/t/ibi-crypter-a-jit-crypter-poc/1373.rss">IBI Crypter. A JIT Crypter PoC</source>
      </item>
      <item>
        <title>IBI Crypter. A JIT Crypter PoC</title>
        <dc:creator><![CDATA[SmartOne]]></dc:creator>
        <description><![CDATA[
            <p>Nice concept! Maybe you could put it on our 0x00sec Gitlab? <img src="https://0x00sec.org/images/emoji/twitter/smiley.png?v=9" title=":smiley:" class="emoji" alt=":smiley:"></p>
          <p><a href="https://0x00sec.org/t/ibi-crypter-a-jit-crypter-poc/1373/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/ibi-crypter-a-jit-crypter-poc/1373/2</link>
        <pubDate>Wed, 21 Dec 2016 10:02:09 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1373-2</guid>
        <source url="https://0x00sec.org/t/ibi-crypter-a-jit-crypter-poc/1373.rss">IBI Crypter. A JIT Crypter PoC</source>
      </item>
      <item>
        <title>IBI Crypter. A JIT Crypter PoC</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>Yesterday, I joined the 0x00sec IRC channel and, as many other times, <a class="mention" href="https://0x00sec.org/u/dtm">@dtm</a> come up with an interesting concept… and I had to try. The idea was pretty challenging and I have not completely come up with a full implementation but I manage to get a minimal Proof of Concept program to illustrate the concept and, maybe, to be used as a starting point for other people more interested in the topic than me.</p>
<h1>The IBI Crypter</h1>
<p>Sure, we were talking about crypters and I named mine IBI crypter. IBI stands for <em>Instruction by Instruction</em> Crypter, and that is the concept. Instead of decrypting the whole application at once or even a block, this crypter tries to decrypt just the instruction that has to be executed at any time. After running that instruction, the code is immediately crypted again so a live memory dump of the process will still be encrypted. This is why I’m referring to this concept as a <strong>JIT</strong> (<em>Just in Time</em>) crypter.</p>
<p>During our discussion we realised that the problem is not trivial, and I have to admit that it is more challenging that I initially expected. I’ll let you know about the issues at the end of this paper.</p>
<p>Before diving into the code, let me explain you how the crypter works.</p>
<h1>An Embedded Debugger</h1>
<p>The idea is pretty simple. We start with a program with some crypted sections. The program starts tracing itself and sets a break point at the first function to run. Once that function is executed, the program execution will stop and the embedded debugger will take control. Then it will decrypt the next instruction to run and, after that, it will execute that instruction.</p>
<p>Once the instruction is executed, the debugger will take control again of the process, it will crypt again the instruction just executed and repeat the process until the code is completely executed.</p>
<p>The concept is pretty simple but the implementation is not that trivial as we will see in a while.</p>
<p>To follow the rest of the paper, it may be useful for you to also read this other text:</p>
<aside class="quote quote-modified" data-post="1" data-topic="1097">
  <div class="title">
    <div class="quote-controls"></div>
    <img alt="" width="20" height="20" src="/user_avatar/0x00sec.org/0x00pf/40/13708_2.png" class="avatar">
    <a href="https://0x00sec.org/t/linux-infecting-running-processes/1097">[Linux] Infecting Running Processes</a> <a class="badge-wrapper  bullet" href="https://0x00sec.org/c/programming/61"><span class="badge-category-bg" style="background-color: #92278F;"></span><span style="" data-drop-close="true" class="badge-category clear-badge">Programming</span></a>
  </div>
  <blockquote>
    We have already seen how to infect a file injecting code into the binary so it gets executed next time the infected program is started. But, how to infect a process that is already running?. Well, this paper will introduce the basic techniques you need to learn in order to fiddle with other processes in memory… In other words, it will introduce you to the basics of how to write your own debugger. 
Use Cases
Before going into the gory details, let’s introduce a couple of situations that may benef…
  </blockquote>
</aside>

<h1>Breakpoints on Intel Processors</h1>
<p>As we already know how to trace a program and access its memory and registers (yes, you should read the link I have just mentioned), we only need to know how to set a break point. Again the concept itself is pretty simple, at least for the traditional way of setting breakpoints.</p>
<p>Breakpoints make use of the processor instruction <code>int 3</code> (opcode 0xcc). This is a 1 byte processor instruction and stops the current processor execution and runs some code defined by us. So, the process to set a break point is as follows:</p>
<ul>
<li>Store the content at the memory address where we want to set our break point.</li>
<li>Write the <code>int 3</code> instruction in that address.</li>
<li>Run the program</li>
</ul>
<p>Whenever the program reaches the <code>int 3</code> instruction, the program will stop at that point and our code will take control and it can do whatever it needs to do, in our case, decrypt the code to execute.</p>
<p>Once we are done, we have to do a couple more things to restore the execution of the original program:</p>
<ul>
<li>Copy back the original byte (the one we stored when we set the break point) in their original position.</li>
<li>Decrease the <code>IP</code> (Instruction Pointer). As you know, the <code>IP</code> always points to the next instruction to be executed. In this case, this is the address of our breakpoint plus 1 (the size of the <code>int 3</code> instruction). We want to decrease it in order to run the original instruction (that we broke injecting the <code>int 3</code> opcode).</li>
<li>Give control back to the original process, or ask the process to just run the next instruction.</li>
</ul>
<p>Overall the concept is pretty straightforward.</p>
<h1>SingleStep Execution</h1>
<p>Fortunately for us, the <code>ptrace</code> interface offer a function to execute a single instruction, Otherwise we would have to add some code to figure out the size of the current instruction (it can be 1 to 15 bytes), in order to know where to set up our next breakpoint.</p>
<p>The <code>ptrace</code> <code>PTRACE_SINGLESTEP</code> will do that for us. It will just run one instruction and give us control back. This is actually the last piece of the puzzle to build our simple proof of concept.</p>
<p>Let’s look into it.</p>
<h1>The Proof of Concept</h1>
<p>We have chosen to illustrate the technique a very basic application to check the validity of a user provided code. The function that does the check will be crypted (and only that function) and it will be executed using the awesome IBI Crypter :P.</p>
<p>Let’s start with the main program and our check function. We have call it <code>target.c</code></p>
<pre><code class="lang-auto">#include &lt;stdio.h&gt;
#include "stub.h"

#define CRYPT_ME __attribute__((section(".secure")))

// This function is crypted
CRYPT_ME int
check_key (unsigned char *str)
{
  int  i;
  unsigned char  *p = str;

  while (*p) {*p -= '0'; p++;};
  if (str[0] + str[1] != 5) return 1;
  if (str[2] * str[3] != 10) return 1;
  return 0;
}


int
main (int argc, char*argv[])
{
  _stub (check_key); // Setup run environment
  printf ("Code is %s\n", check_key (argv[1]) ? "INCORRECT": "CORRECT");
}

</code></pre>
<p>As you can see, the <code>check_key</code> function in the code above, do a couple of stupid checks on the key it receives as parameter, and returns 0 if the key is valid or 1 otherwise. The main function is also pretty simple. It first runs our <code>_stub</code> and then just prints <code>CORRECT</code> or <code>INCORRECT</code> based on the result of the <code>check_key</code> function.</p>
<p>To off-line crypter  I will be using is the same described in the paper:</p>
<aside class="quote quote-modified" data-post="1" data-topic="537">
  <div class="title">
    <div class="quote-controls"></div>
    <img alt="" width="20" height="20" src="/user_avatar/0x00sec.org/0x00pf/40/13708_2.png" class="avatar">
    <a href="https://0x00sec.org/t/a-simple-linux-crypter/537">A simple Linux Crypter</a> <a class="badge-wrapper  bullet" href="https://0x00sec.org/c/malware/56"><span class="badge-category-bg" style="background-color: #F7941D;"></span><span style="" data-drop-close="true" class="badge-category clear-badge">Malware</span></a>
  </div>
  <blockquote>
    As <a class="mention" href="https://0x00sec.org/u/dtm">@dtm</a> has explained us how to write a crypter for Windows, and <a class="mention" href="https://0x00sec.org/u/thedoctor">@TheDoctor</a> has done the same for C#, I’m going to talk about how to build similar stuff for GNU/Linux. This post is kind of based on something else I wrote some months ago for a different community. I had tried to make a twist of the original paper, but… to be honest, it is difficult to come up with something simpler. 
I will skip the scan-time crypter. There are no big differences compared to what has already been said in this com…
  </blockquote>
</aside>

<p>We are pushing the functions to <em>secure</em> into a separated section for easy identification (see <code>CRYPT_ME</code> macro). Then we XOR  it, as described in the paper I have just mentioned.</p>
<p>The interesting stuff is in the <code>_stub</code> function. Let’s look at it</p>
<h1>The <code>_stub</code> Function</h1>
<p>The <code>_stub</code> function has two main parts. First, we set up a breakpoint in the crypted function we want to run (<code>check_key</code> in this case). Once we get there, we will start stepping over the function instruction by instruction.</p>
<p>Let’s go with the breakpoint</p>
<pre><code class="lang-auto">int
_stub (void *ep)
{
  void                    *bp_ip;
  long                    ip1, op1, op2;
  struct user_regs_struct regs;
  int                     status, cnt;

  printf ("%s", "0x00pf IbI Crypter Stub\n");

  // Start debugging!!!
  if ((_pid = fork ()) &lt; 0) PERROR("fork:");

  if (_pid == 0) return 0;  // Child process just keeps running
  else
    {
      // Father starts debugging child
      if ((ptrace (PTRACE_ATTACH, _pid, NULL, NULL)) &lt; 0) PERROR ("ptrace_attach:");
      printf ("%s", "+ Waiting for process...\n");
      wait (&amp;status);

      bp_ip = ep;

      // Set breakpoint at get there...
      op1 = ptrace (PTRACE_PEEKTEXT, _pid, bp_ip);
      DPRINTF("BP: %p 1 Opcode: %lx\n", bp_ip, op1);
      if (ptrace (PTRACE_POKETEXT, _pid, bp_ip, 
		  (op1 &amp; 0xFFFFFFFFFFFFFF00) | 0xcc) &lt; 0) PERROR ("ptrace_poke:");

      // Run until breakpoint is reached.
      if (ptrace (PTRACE_CONT, _pid, 0, 0) &lt; 0) PERROR("ptrace_cont:");
      wait (&amp;status);
      
      ptrace (PTRACE_GETREGS, _pid, 0, &amp;regs);
      DPRINTF ("Breakpoint reached: RIP: %llx\n", regs.rip);
      regs.rip--;
      ptrace (PTRACE_SETREGS, _pid, 0, &amp;regs);

      // REstore opcode
      ptrace (PTRACE_POKETEXT, _pid, bp_ip, op1);

</code></pre>
<p>Hope the code is easy to understand. It creates a new process and starts debugging it. Immediately we set the breakpoint (opcode <code>0xcc</code>) in the address received as parameter, that in our case is the <code>check_key</code> function (check the <code>main</code> function above).</p>
<p>Once the break point is set, we just let the program run using the <code>PTRACE_CONT</code> and we just wait for the program to hit the break point… i.e. we wait until the function we want to decrypt gets executed.</p>
<p>The program will eventually call the <code>check_key</code> function (that is actually the next line in the <code>main</code> function) and the <code>_stub</code> code will take control back. Then we have to get the <code>IP</code> register, decreased in one byte (as explained above), set the register value back and also restore the opcode where the <code>int3</code> was inserted.</p>
<p>Time to run the function.</p>
<h1>Decrypting, Running, Encoding and again</h1>
<p>At this point we have stopped the application just at the beginning of the <code>check_key</code> function and in order to continue the execution we have to decrypt it as we go.</p>
<p>This is the code that does the trick</p>
<pre><code class="lang-auto">     // Start step by step debugging
      ip1 = (long) ep;
      cnt = 0;
      while (WIFSTOPPED (status))
	{
	  cnt ++;
	  // Read up to 16 bytes to get the longest instruction possible
	  // Decode and write back the decoded code to execute it
	  op1 = ptrace (PTRACE_PEEKTEXT, _pid, ip1);
	  op2 = ptrace (PTRACE_PEEKTEXT, _pid, ip1 + 8);
	  DPRINTF ("%lx :: OPCODES : %lx %lx\n", ip1, op1, op2);
	  
	  XOR(op1);
	  XOR(op2);

	  DPRINTF ("%lx :: DOPCODES: %lx %lx\n", ip1, op1, op2);

	  ptrace (PTRACE_POKETEXT, _pid, ip1, op1);
	  ptrace (PTRACE_POKETEXT, _pid, ip1 + 8, op2);

	  /* Make the child execute another instruction */
	  if (ptrace(PTRACE_SINGLESTEP, _pid, 0, 0) &lt; 0) PERROR ("ptrace_singlestep:");
	  wait(&amp;status);
	  
	  // Re-encode the instruction just executed so we do not have
	  // to count how many bytes got executed
	  XOR(op1);
	  XOR(op2);

	  ptrace (PTRACE_POKETEXT, _pid, ip1, op1);
	  ptrace (PTRACE_POKETEXT, _pid, ip1 + 8, op2);

	  // Get the new IP
	  ptrace (PTRACE_GETREGS, _pid, 0, &amp;regs);
	  ip1 = regs.rip;

	  // If code is outside .secure section we stop debugging 
	  if ((void*)ip1 &lt; secure_ptr || (void*)ip1 &gt; secure_ptr + secure_len)
	    {
	      printf ("Leaving .secure section... %d instructions executed\n", cnt);
	      break;
	    }
	}

      ptrace (PTRACE_CONT, _pid, 0, 0);
      wait (&amp;status);      
    }

  printf ("DONE\n");
  exit (1);
}
</code></pre>
<p>The function is a bit verbose but conceptually very simple. The <code>XOR</code> macro just applies the XOR encoding to a <code>long</code> (8 bytes) with a predefined key. You can check the details in the full source code (check at the end). At this point, it is not relevant.</p>
<p>If we check the format of the Intel opcodes, you will find out that a instruction, for a 64bits architecture may take up to 15 bytes. As we do not know (and we do not really want to know) anything about the next instruction to run, or in other words, we do not want to decode the opcodes ourselves in the code, then we have to decrypt up to 16 bytes to cover the longest possible opcode. Yes, in general, at a given time there are more than 1 single instruction decoded in memoru.</p>
<p>This is why we do two <code>PTRACE_PEEK</code>s to read the current address and that address plus 8 bytes (longs are 8 bytes long). Once we have read the 16 bytes that contains the next instruction to run, we just decrypt it applying our <code>XOR</code> macro, and we update the memory using <code>PTRACE_POKE</code> so, the next program instruction is now correct.</p>
<p>At this point we can just run the next instruction using <code>PTRACE_SINGLESTEP</code> and wait until the instruction is executed and control gets back to us.</p>
<p>Then we just need to encode again the 16 bytes of memory we decoded. This is not just to keep the program encrypted most of the time, but also to avoid some tricky logic to keep at least 16 bytes decoded in the memory program.</p>
<p>The final check in the <code>while</code> loop checks if the current <code>IP</code> is still in the <code>.secure</code> section of it has moved into other executable section… more on this at the end of the text.</p>
<h1>Testing</h1>
<p>Testing the program is not that straightforward. For the time being we have to do some manual tasks to make it work. It is not hard to fully automatise the process so I leave it as an exercise to you <img src="https://0x00sec.org/images/emoji/twitter/stuck_out_tongue.png?v=9" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:"></p>
<p>First we have to compile the target program:</p>
<pre><code>$ gcc -o target target.c stub.c
</code></pre>
<p>Then we have to crypt the <code>.secure</code> section, using the <code>crypter_rt</code> tool (provided with the code).</p>
<p><code>$ ./crypter_rt target</code></p>
<p>Finally we need to manually fix the section information in <code>stub.c</code> and redo the process. To get the information <code>stub</code> needs about the section just run this command:</p>
<pre><code>$ readelf -S target | grep secure
  [14] .secure           PROGBITS         0000000000400e22  00000e22
</code></pre>
<p>The two last number in this line has to go to the variables <code>secure_ptr</code> and <code>secure_len</code> in <code>stub.c</code>. This information is used to figure out when the execution leaves the secure section and matches not crypted code.</p>
<p>Recompile and rebuild and you should be able to run the program like this:</p>
<pre><code>$ ./target 1425
0x00pf B3Crypt Stub (Byte By Byte)
+ Waiting for process...
Leaving .secure section... 74 instructions executed
Code is CORRECT
DONE
 ./target 1426
0x00pf B3Crypt Stub (Byte By Byte)
+ Waiting for process...
Leaving .secure section... 75 instructions executed
Code is INCORRECT
DONE
</code></pre>
<h1>The Tricky part</h1>
<p>This example is very simple on purpose. Making a usable version will require some effort and I do not really have a need for this tool so I do not think I will go further on this implementation. However these are a couple of things to do, in order to extend this PoC into a usable tool</p>
<ul>
<li>The first thing to do is to extend the <code>stub</code> to access the ELF header and get the information associated to the <code>.secure</code> section, so you do not need to update the source code to re-compile</li>
<li>Second is more tricky. You have to detect jumps/calls to functions outside the <code>.secure</code> section, as for instance the standard C library (have you seen a single <code>printf</code> in the <code>check_key</code> function ?). In those cases we have to set a break point just after the call in order to run the function without decoding it (those functions are not encoded) and to restart the decoding when the function returns… The last check in the function may give you some hints on how to proceed.</li>
<li>I haven’t extensively tested the program. I just made it work on my machine, it is not optimised and it may have some timing issues.</li>
<li>This only works on 64bits platforms… should be easy to make it work on 32bits… but in any case it is x86 specific. For ARM or MIPS you need to figure out how to set breakpoints.</li>
</ul>
<p>Well, this is it. I think this proves the concept is feasible and it is up to you to make it work. I see this more as a SW protection mechanism than as a malware development technique… WTF… they are the same thing <img src="https://0x00sec.org/images/emoji/twitter/stuck_out_tongue.png?v=9" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:"></p>
<p>As usual you can get the complete source code from my github repo</p>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://github.githubassets.com/favicons/favicon.svg" class="site-icon" width="32" height="32">
      <a href="https://github.com/0x00pf/0x00sec_code/tree/master/ibi_crypter" target="_blank" rel="noopener nofollow ugc">GitHub</a>
  </header>
  <article class="onebox-body">
    <img src="https://0x00sec.s3.amazonaws.com/original/2X/a/a35c2bf9477f702a5322cfd1c8f54353d79c1d16.png" class="thumbnail" width="" height="">

<h3><a href="https://github.com/0x00pf/0x00sec_code/tree/master/ibi_crypter" target="_blank" rel="noopener nofollow ugc">0x00pf/0x00sec_code</a></h3>

<p>Code for my 0x00sec.org posts. Contribute to 0x00pf/0x00sec_code development by creating an account on GitHub.</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>Any comment is welcomed</p>
          <p><a href="https://0x00sec.org/t/ibi-crypter-a-jit-crypter-poc/1373/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/ibi-crypter-a-jit-crypter-poc/1373/1</link>
        <pubDate>Tue, 20 Dec 2016 23:59:02 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-1373-1</guid>
        <source url="https://0x00sec.org/t/ibi-crypter-a-jit-crypter-poc/1373.rss">IBI Crypter. A JIT Crypter PoC</source>
      </item>
  </channel>
</rss>
